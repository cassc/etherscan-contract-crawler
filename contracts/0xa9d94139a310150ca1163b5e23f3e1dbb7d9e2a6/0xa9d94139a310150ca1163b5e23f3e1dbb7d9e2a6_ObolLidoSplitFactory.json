{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/lido/ObolLidoSplitFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\nimport {LibClone} from \\\"solady/utils/LibClone.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"./ObolLidoSplit.sol\\\";\\n\\n/// @title ObolLidoSplitFactory\\n/// @author Obol\\n/// @notice A factory contract for cheaply deploying ObolLidoSplit.\\n/// @dev The address returned should be used to as reward address for Lido\\ncontract ObolLidoSplitFactory {\\n  /// -----------------------------------------------------------------------\\n  /// errors\\n  /// -----------------------------------------------------------------------\\n\\n  /// Invalid wallet\\n  error Invalid_Wallet();\\n\\n  /// -----------------------------------------------------------------------\\n  /// libraries\\n  /// -----------------------------------------------------------------------\\n  using LibClone for address;\\n\\n  /// -----------------------------------------------------------------------\\n  /// events\\n  /// -----------------------------------------------------------------------\\n\\n  /// Emitted after lido split\\n  event CreateObolLidoSplit(address split);\\n\\n  /// -----------------------------------------------------------------------\\n  /// storage\\n  /// -----------------------------------------------------------------------\\n\\n  /// @dev lido split implementation\\n  ObolLidoSplit public immutable lidoSplitImpl;\\n\\n  constructor(address _feeRecipient, uint256 _feeShare, ERC20 _stETH, ERC20 _wstETH) {\\n    lidoSplitImpl = new ObolLidoSplit(_feeRecipient, _feeShare, _stETH, _wstETH);\\n  }\\n\\n  /// Creates a wrapper for splitWallet that transforms stETH token into\\n  /// wstETH\\n  /// @param splitWallet Address of the splitWallet to transfer wstETH to\\n  /// @return lidoSplit Address of the wrappper split\\n  function createSplit(address splitWallet) external returns (address lidoSplit) {\\n    if (splitWallet == address(0)) revert Invalid_Wallet();\\n\\n    lidoSplit = address(lidoSplitImpl).clone(abi.encodePacked(splitWallet));\\n\\n    emit CreateObolLidoSplit(lidoSplit);\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibClone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\\n/// @author Minimal proxy by 0age (https://github.com/0age)\\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\n///\\n/// @dev Minimal proxy:\\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\\n///\\n/// @dev Minimal proxy (PUSH0 variant):\\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \\\"_PUSH0\\\" as\\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\\n/// Please use with caution.\\n///\\n/// @dev Clones with immutable args (CWIA):\\n/// The implementation of CWIA here implements a `receive()` method that emits the\\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\\n/// composability. The minimal proxy implementation does not offer this feature.\\nlibrary LibClone {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// @dev The salt must start with either the zero address or the caller.\\n    error SaltDoesNotStartWithCaller();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  MINIMAL PROXY OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a clone of `implementation`.\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (44 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | 0                      |                       |\\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create(0, 0x0c, 0x35)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\\n    function cloneDeterministic(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            instance := create2(0, 0x0c, 0x35, salt)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\\n            mstore(0x14, implementation)\\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\\n            hash := keccak256(0x0c, 0x35)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x21, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        bytes32 hash = initCodeHash(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a PUSH0 clone of `implementation`.\\n    function clone_PUSH0(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            /**\\n             * --------------------------------------------------------------------------+\\n             * CREATION (9 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\\n             * --------------------------------------------------------------------------|\\n             * 60 runSize | PUSH1 runSize     | r         |                              |\\n             * 5f         | PUSH0             | 0 r       |                              |\\n             * 81         | DUP2              | r 0 r     |                              |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\\n             * --------------------------------------------------------------------------|\\n             * RUNTIME (45 bytes)                                                        |\\n             * --------------------------------------------------------------------------|\\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\\n             * --------------------------------------------------------------------------|\\n             *                                                                           |\\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5f      | PUSH0          | 0                      |                       |\\n             * 5f      | PUSH0          | 0 0                    |                       |\\n             *                                                                           |\\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\\n             *                                                                           |\\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\\n             *                                                                           |\\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * fd      | REVERT         |                        | [0..rds): returndata  |\\n             *                                                                           |\\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\\n             * f3      | RETURN         |                        | [0..rds): returndata  |\\n             * --------------------------------------------------------------------------+\\n             */\\n\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create(0, 0x0e, 0x36)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x24, 0)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            instance := create2(0, 0x0e, 0x36, salt)\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x24, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\\n            mstore(0x14, implementation) // 20\\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\\n            hash := keccak256(0x0e, 0x36)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x24, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\\n    /// with `salt` by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress_PUSH0(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash_PUSH0(implementation);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Deploys a minimal proxy with `implementation`,\\n    /// using immutable arguments encoded in `data`.\\n    ///\\n    /// Note: This implementation of CWIA differs from the original implementation.\\n    /// If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n            // The `creationSize` is `extraLength + 108`\\n            // The `runSize` is `creationSize - 10`.\\n\\n            /**\\n             * ---------------------------------------------------------------------------------------------------+\\n             * CREATION (10 bytes)                                                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\\n             * 81         | DUP2              | r 0 r     |                                                       |\\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * RUNTIME (98 bytes + extraLength)                                                                   |\\n             * ---------------------------------------------------------------------------------------------------|\\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\\n             * ---------------------------------------------------------------------------------------------------|\\n             *                                                                                                    |\\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\\n             * 57       | JUMPI          |                          |                                             |\\n             * 34       | CALLVALUE      | cv                       |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\\n             * 5b       | JUMPDEST       |                          |                                             |\\n             *                                                                                                    |\\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds                      |                                             |\\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\\n             *                                                                                                    |\\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\\n             *                                                                                                    |\\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\\n             *                                                                                                    |\\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\\n             * ---------------------------------------------------------------------------------------------------+\\n             */\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create(0, sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Deploys a deterministic clone of `implementation`,\\n    /// using immutable arguments encoded in `data`, with `salt`.\\n    ///\\n    /// Note: This implementation of CWIA differs from the original implementation.\\n    /// If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\\n        internal\\n        returns (address instance)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\\n                // The actual EVM limit may be smaller and may change over time.\\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the initialization code hash of the clone of `implementation`\\n    /// using immutable arguments encoded in `data`.\\n    /// Used for mining vanity addresses with create2crunch.\\n    function initCodeHash(address implementation, bytes memory data)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\\n            // The actual EVM limit may be smaller and may change over time.\\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`\\n            mstore(\\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Compute and store the bytecode hash.\\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        bytes32 hash = initCodeHash(implementation, data);\\n        predicted = predictDeterministicAddress(hash, salt, deployer);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      OTHER OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the address when a contract with initialization code hash,\\n    /// `hash`, is deployed with `salt`, by `deployer`.\\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\\n        internal\\n        pure\\n        returns (address predicted)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and store the bytecode hash.\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x35, hash)\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x35, 0)\\n        }\\n    }\\n\\n    /// @dev Reverts if `salt` does not start with either the zero address or the caller.\\n    function checkStartsWithCaller(bytes32 salt) internal view {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the salt does not start with the zero address or the caller.\\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\\n                // Store the function selector of `SaltDoesNotStartWithCaller()`.\\n                mstore(0x00, 0x2f634836)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lido/ObolLidoSplit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {Clone} from \\\"solady/utils/Clone.sol\\\";\\nimport {IwstETH} from \\\"src/interfaces/IwstETH.sol\\\";\\n\\n/// @title ObolLidoSplit\\n/// @author Obol\\n/// @notice A wrapper for 0xsplits/split-contracts SplitWallet that transforms\\n/// stETH token to wstETH token because stETH is a rebasing token\\n/// @dev Wraps stETH to wstETH and transfers to defined SplitWallet address\\ncontract ObolLidoSplit is Clone {\\n  error Invalid_Address();\\n  error Invalid_FeeShare(uint256 fee);\\n  error Invalid_FeeRecipient();\\n\\n  /// -----------------------------------------------------------------------\\n  /// libraries\\n  /// -----------------------------------------------------------------------\\n  using SafeTransferLib for ERC20;\\n  using SafeTransferLib for address;\\n\\n  address internal constant ETH_ADDRESS = address(0);\\n  uint256 internal constant PERCENTAGE_SCALE = 1e5;\\n\\n  /// -----------------------------------------------------------------------\\n  /// storage - cwia offsets\\n  /// -----------------------------------------------------------------------\\n\\n  // splitWallet (adress, 20 bytes)\\n  // 0; first item\\n  uint256 internal constant SPLIT_WALLET_ADDRESS_OFFSET = 0;\\n\\n  /// -----------------------------------------------------------------------\\n  /// storage\\n  /// -----------------------------------------------------------------------\\n\\n  /// @notice stETH token\\n  ERC20 public immutable stETH;\\n\\n  /// @notice wstETH token\\n  ERC20 public immutable wstETH;\\n\\n  /// @notice fee address\\n  address public immutable feeRecipient;\\n\\n  /// @notice fee share\\n  uint256 public immutable feeShare;\\n\\n  /// @notice Constructor\\n  /// @param _feeRecipient address to receive fee\\n  /// @param _feeShare fee share scaled by PERCENTAGE_SCALE\\n  /// @param _stETH stETH address\\n  /// @param _wstETH wstETH address\\n  constructor(address _feeRecipient, uint256 _feeShare, ERC20 _stETH, ERC20 _wstETH) {\\n    if (_feeShare >= PERCENTAGE_SCALE) revert Invalid_FeeShare(_feeShare);\\n    if (_feeShare > 0 && _feeRecipient == address(0)) revert Invalid_FeeRecipient();\\n\\n    feeRecipient = _feeRecipient;\\n    stETH = _stETH;\\n    wstETH = _wstETH;\\n    feeShare = _feeShare;\\n  }\\n\\n  /// Address of split wallet to send funds to to\\n  /// @dev equivalent to address public immutable splitWallet\\n  function splitWallet() public pure returns (address) {\\n    return _getArgAddress(SPLIT_WALLET_ADDRESS_OFFSET);\\n  }\\n\\n  /// Wraps the current stETH token balance to wstETH\\n  /// transfers the wstETH balance to splitWallet for distribution\\n  /// @return amount Amount of wstETH transferred to splitWallet\\n  function distribute() external returns (uint256 amount) {\\n    // get current balance\\n    uint256 balance = stETH.balanceOf(address(this));\\n    // approve the wstETH\\n    stETH.approve(address(wstETH), balance);\\n    // wrap into wseth\\n    // we ignore the return value\\n    IwstETH(address(wstETH)).wrap(balance);\\n    // we use balanceOf here in case some wstETH is stuck in the\\n    // contract we would be able to rescue it\\n    amount = ERC20(wstETH).balanceOf(address(this));\\n\\n    if (feeShare > 0) {\\n      uint256 fee = (amount * feeShare) / PERCENTAGE_SCALE;\\n      // transfer to split wallet\\n      // update amount to reflect fee charged\\n      ERC20(wstETH).safeTransfer(splitWallet(), amount -= fee);\\n      // transfer to fee address\\n      ERC20(wstETH).safeTransfer(feeRecipient, fee);\\n    } else {\\n      // transfer to split wallet\\n      ERC20(wstETH).safeTransfer(splitWallet(), amount);\\n    }\\n  }\\n\\n  /// @notice Rescue stuck ETH and tokens\\n  /// Uses token == address(0) to represent ETH\\n  /// @return balance Amount of ETH or tokens rescued\\n  function rescueFunds(address token) external returns (uint256 balance) {\\n    // we check wstETH here so rescueFunds can't be used\\n    // to bypass fee\\n    if (token == address(stETH) || token == address(wstETH)) revert Invalid_Address();\\n\\n    if (token == ETH_ADDRESS) {\\n      balance = address(this).balance;\\n      if (balance > 0) splitWallet().safeTransferETH(balance);\\n    } else {\\n      balance = ERC20(token).balanceOf(address(this));\\n      if (balance > 0) ERC20(token).safeTransfer(splitWallet(), balance);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/Clone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Class with helper read functions for clone with immutable args.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)\\n/// @author Adapted from clones with immutable args by zefram.eth, Saw-mon & Natalie\\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\\nabstract contract Clone {\\n    /// @dev Reads all of the immutable args.\\n    function _getArgBytes() internal pure returns (bytes memory arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := mload(0x40)\\n            let length := sub(calldatasize(), add(2, offset)) // 2 bytes are used for the length.\\n            mstore(arg, length) // Store the length.\\n            calldatacopy(add(arg, 0x20), offset, length)\\n            let o := add(add(arg, 0x20), length)\\n            mstore(o, 0) // Zeroize the slot after the bytes.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type bytes.\\n    function _getArgBytes(uint256 argOffset, uint256 length)\\n        internal\\n        pure\\n        returns (bytes memory arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := mload(0x40)\\n            mstore(arg, length) // Store the length.\\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)\\n            let o := add(add(arg, 0x20), length)\\n            mstore(o, 0) // Zeroize the slot after the bytes.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type address.\\n    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(96, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads a uint256 array stored in the immutable args.\\n    function _getArgUint256Array(uint256 argOffset, uint256 length)\\n        internal\\n        pure\\n        returns (uint256[] memory arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := mload(0x40)\\n            mstore(arg, length) // Store the length.\\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Reads a bytes32 array stored in the immutable args.\\n    function _getArgBytes32Array(uint256 argOffset, uint256 length)\\n        internal\\n        pure\\n        returns (bytes32[] memory arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := mload(0x40)\\n            mstore(arg, length) // Store the length.\\n            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))\\n            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type bytes32.\\n    function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint256.\\n    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint248.\\n    function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(8, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint240.\\n    function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(16, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint232.\\n    function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(24, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint224.\\n    function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(0x20, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint216.\\n    function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(40, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint208.\\n    function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(48, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint200.\\n    function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(56, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint192.\\n    function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(64, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint184.\\n    function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(72, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint176.\\n    function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(80, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint168.\\n    function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(88, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint160.\\n    function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(96, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint152.\\n    function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(104, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint144.\\n    function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(112, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint136.\\n    function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(120, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint128.\\n    function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(128, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint120.\\n    function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(136, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint112.\\n    function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(144, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint104.\\n    function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(152, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint96.\\n    function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(160, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint88.\\n    function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(168, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint80.\\n    function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(176, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint72.\\n    function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(184, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint64.\\n    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(192, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint56.\\n    function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(200, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint48.\\n    function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(208, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint40.\\n    function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(216, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint32.\\n    function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(224, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint24.\\n    function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(232, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint16.\\n    function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(240, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @dev Reads an immutable arg with type uint8.\\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            arg := shr(248, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata.\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IwstETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IwstETH {\\n  function wrap(uint256 amount) external returns (uint256);\\n  function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"splits-tests/=lib/splits-utils/test/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"splits-utils/=lib/splits-utils/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeShare\",\"type\":\"uint256\"},{\"internalType\":\"contract ERC20\",\"name\":\"_stETH\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"_wstETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Invalid_Wallet\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"split\",\"type\":\"address\"}],\"name\":\"CreateObolLidoSplit\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"splitWallet\",\"type\":\"address\"}],\"name\":\"createSplit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lidoSplit\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lidoSplitImpl\",\"outputs\":[{\"internalType\":\"contract ObolLidoSplit\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ObolLidoSplitFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000de5ae4de36c966747ea7df13bd9589642e2b1d0d00000000000000000000000000000000000000000000000000000000000030d4000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe840000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca0", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}