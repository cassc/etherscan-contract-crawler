{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/legacy/ResolvedDelegateProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { AddressManager } from \\\"./AddressManager.sol\\\";\\n\\n/**\\n * @custom:legacy\\n * @title ResolvedDelegateProxy\\n * @notice ResolvedDelegateProxy is a legacy proxy contract that makes use of the AddressManager to\\n *         resolve the implementation address. We're maintaining this contract for backwards\\n *         compatibility so we can manage all legacy proxies where necessary.\\n */\\ncontract ResolvedDelegateProxy {\\n    /**\\n     * @notice Mapping used to store the implementation name that corresponds to this contract. A\\n     *         mapping was originally used as a way to bypass the same issue normally solved by\\n     *         storing the implementation address in a specific storage slot that does not conflict\\n     *         with any other storage slot. Generally NOT a safe solution but works as long as the\\n     *         implementation does not also keep a mapping in the first storage slot.\\n     */\\n    mapping(address => string) private implementationName;\\n\\n    /**\\n     * @notice Mapping used to store the address of the AddressManager contract where the\\n     *         implementation address will be resolved from. Same concept here as with the above\\n     *         mapping. Also generally unsafe but fine if the implementation doesn't keep a mapping\\n     *         in the second storage slot.\\n     */\\n    mapping(address => AddressManager) private addressManager;\\n\\n    /**\\n     * @param _addressManager  Address of the AddressManager.\\n     * @param _implementationName implementationName of the contract to proxy to.\\n     */\\n    constructor(AddressManager _addressManager, string memory _implementationName) {\\n        addressManager[address(this)] = _addressManager;\\n        implementationName[address(this)] = _implementationName;\\n    }\\n\\n    /**\\n     * @notice Fallback, performs a delegatecall to the resolved implementation address.\\n     */\\n    // solhint-disable-next-line no-complex-fallback\\n    fallback() external payable {\\n        address target = addressManager[address(this)].getAddress(\\n            (implementationName[address(this)])\\n        );\\n\\n        require(target != address(0), \\\"ResolvedDelegateProxy: target address must be initialized\\\");\\n\\n        // slither-disable-next-line controlled-delegatecall\\n        (bool success, bytes memory returndata) = target.delegatecall(msg.data);\\n\\n        if (success == true) {\\n            assembly {\\n                return(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else {\\n            assembly {\\n                revert(add(returndata, 0x20), mload(returndata))\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/legacy/AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @custom:legacy\\n * @title AddressManager\\n * @notice AddressManager is a legacy contract that was used in the old version of the Optimism\\n *         system to manage a registry of string names to addresses. We now use a more standard\\n *         proxy system instead, but this contract is still necessary for backwards compatibility\\n *         with several older contracts.\\n */\\ncontract AddressManager is Ownable {\\n    /**\\n     * @notice Mapping of the hashes of string names to addresses.\\n     */\\n    mapping(bytes32 => address) private addresses;\\n\\n    /**\\n     * @notice Emitted when an address is modified in the registry.\\n     *\\n     * @param name       String name being set in the registry.\\n     * @param newAddress Address set for the given name.\\n     * @param oldAddress Address that was previously set for the given name.\\n     */\\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\\n\\n    /**\\n     * @notice Changes the address associated with a particular name.\\n     *\\n     * @param _name    String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * @notice Retrieves the address associated with a given name.\\n     *\\n     * @param _name Name to retrieve an address for.\\n     *\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**\\n     * @notice Computes the hash of a name.\\n     *\\n     * @param _name Name to compute a hash for.\\n     *\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@cwia/=node_modules/clones-with-immutable-args/src/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\r\n      \"@rari-capital/=node_modules/@rari-capital/\",\r\n      \"@rari-capital/solmate/=node_modules/@rari-capital/solmate/\",\r\n      \"clones-with-immutable-args/=node_modules/clones-with-immutable-args/\",\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"forge-std/=node_modules/forge-std/src/\",\r\n      \"hardhat-deploy/=node_modules/hardhat-deploy/\",\r\n      \"hardhat/=node_modules/hardhat/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract AddressManager\",\"name\":\"_addressManager\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_implementationName\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "ResolvedDelegateProxy", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000ef8115f2733fb2033a7c756402fc1deaa56550ef0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000001a4f564d5f4c3143726f7373446f6d61696e4d657373656e676572000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}