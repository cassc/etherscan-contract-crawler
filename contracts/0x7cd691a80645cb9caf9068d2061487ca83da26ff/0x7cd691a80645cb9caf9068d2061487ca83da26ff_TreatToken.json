{"SourceCode": "// File: interfaces/IDexRouter.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IDexRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n}\r\n\r\n// File: interfaces/IDexFactory.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IDexFactory {\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n}\r\n\r\n// File: libraries/SafeMath.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is TKNaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouTKNd) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouTKNd) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouTKNd) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouTKNd) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: interfaces/IERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: interfaces/IERC20Metadata.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: contracts/Context.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/ERC20.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(\r\n        address account\r\n    ) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n\t\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    ) public virtual returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) public virtual returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].sub(\r\n                subtractedValue,\r\n                \"ERC20: decreased allowance below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(\r\n            amount,\r\n            \"ERC20: burn amount exceeds balance\"\r\n        );\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: interfaces/IOwnable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IOwnable {\r\n    function owner() external returns (address);\r\n\r\n    function transferOwnership(address recipient) external;\r\n\r\n    function acceptOwnership() external;\r\n}\r\n\r\n// File: contracts/ConfirmedOwnerWithProposal.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwnerWithProposal is IOwnable {\r\n    address private s_owner;\r\n    address private s_pendingOwner;\r\n\r\n    event OwnershipTransferRequested(address indexed from, address indexed to);\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n    constructor(address newOwner, address pendingOwner) {\r\n        require(newOwner != address(0), \"Cannot set owner to zero\");\r\n\r\n        s_owner = newOwner;\r\n        if (pendingOwner != address(0)) {\r\n            _transferOwnership(pendingOwner);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows an owner to begin transferring ownership to a new address,\r\n     * pending.\r\n     */\r\n    function transferOwnership(address to) public override onlyOwner {\r\n        _transferOwnership(to);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows an ownership transfer to be completed by the recipient.\r\n     */\r\n    function acceptOwnership() external override {\r\n        require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\r\n\r\n        address oldOwner = s_owner;\r\n        s_owner = msg.sender;\r\n        s_pendingOwner = address(0);\r\n\r\n        emit OwnershipTransferred(oldOwner, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current owner\r\n     */\r\n    function owner() public view override returns (address) {\r\n        return s_owner;\r\n    }\r\n\r\n    /**\r\n     * @notice validate, transfer ownership, and emit relevant events\r\n     */\r\n    function _transferOwnership(address to) private {\r\n        require(to != msg.sender, \"Cannot transfer to self\");\r\n\r\n        s_pendingOwner = to;\r\n\r\n        emit OwnershipTransferRequested(s_owner, to);\r\n    }\r\n\r\n    /**\r\n     * @notice validate access\r\n     */\r\n    function _validateOwnership() internal view {\r\n        require(msg.sender == s_owner, \"Only callable by owner\");\r\n    }\r\n\r\n    /**\r\n     * @notice Reverts if called by anyone other than the contract owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _validateOwnership();\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/ConfirmedOwner.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\r\n    constructor(\r\n        address newOwner\r\n    ) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\r\n}\r\n\r\n// File: interfaces/VRFCoordinatorV2Interface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface VRFCoordinatorV2Interface {\r\n    /**\r\n     * @notice Get configuration relevant for making requests\r\n     * @return minimumRequestConfirmations global min for request confirmations\r\n     * @return maxGasLimit global max for request gas limit\r\n     * @return s_provingKeyHashes list of registered key hashes\r\n     */\r\n    function getRequestConfig()\r\n        external\r\n        view\r\n        returns (uint16, uint32, bytes32[] memory);\r\n\r\n    /**\r\n     * @notice Request a set of random words.\r\n     * @param keyHash - Corresponds to a particular oracle job which uses\r\n     * that key for generating the VRF proof. Different keyHash's have different gas price\r\n     * ceilings, so you can select a specific one to bound your maximum per request cost.\r\n     * @param subId  - The ID of the VRF subscription. Must be funded\r\n     * with the minimum subscription balance required for the selected keyHash.\r\n     * @param minimumRequestConfirmations - How many blocks you'd like the\r\n     * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\r\n     * for why you may want to request more. The acceptable range is\r\n     * [minimumRequestBlockConfirmations, 200].\r\n     * @param callbackGasLimit - How much gas you'd like to receive in your\r\n     * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\r\n     * may be slightly less than this amount because of gas used calling the function\r\n     * (argument decoding etc.), so you may need to request slightly more than you expect\r\n     * to have inside fulfillRandomWords. The acceptable range is\r\n     * [0, maxGasLimit]\r\n     * @param numWords - The number of uint256 random values you'd like to receive\r\n     * in your fulfillRandomWords callback. Note these numbers are expanded in a\r\n     * secure way by the VRFCoordinator from a single random value supplied by the oracle.\r\n     * @return requestId - A unique identifier of the request. Can be used to match\r\n     * a request to a response in fulfillRandomWords.\r\n     */\r\n    function requestRandomWords(\r\n        bytes32 keyHash,\r\n        uint64 subId,\r\n        uint16 minimumRequestConfirmations,\r\n        uint32 callbackGasLimit,\r\n        uint32 numWords\r\n    ) external returns (uint256 requestId);\r\n\r\n    /**\r\n     * @notice Create a VRF subscription.\r\n     * @return subId - A unique subscription id.\r\n     * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\r\n     * @dev Note to fund the subscription, use transferAndCall. For example\r\n     * @dev  LINKTOKEN.transferAndCall(\r\n     * @dev    address(COORDINATOR),\r\n     * @dev    amount,\r\n     * @dev    abi.encode(subId));\r\n     */\r\n    function createSubscription() external returns (uint64 subId);\r\n\r\n    /**\r\n     * @notice Get a VRF subscription.\r\n     * @param subId - ID of the subscription\r\n     * @return balance - LINK balance of the subscription in juels.\r\n     * @return reqCount - number of requests for this subscription, determines fee tier.\r\n     * @return owner - owner of the subscription.\r\n     * @return consumers - list of consumer address which are able to use this subscription.\r\n     */\r\n    function getSubscription(\r\n        uint64 subId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint96 balance,\r\n            uint64 reqCount,\r\n            address owner,\r\n            address[] memory consumers\r\n        );\r\n\r\n    /**\r\n     * @notice Request subscription owner transfer.\r\n     * @param subId - ID of the subscription\r\n     * @param newOwner - proposed new owner of the subscription\r\n     */\r\n    function requestSubscriptionOwnerTransfer(\r\n        uint64 subId,\r\n        address newOwner\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Request subscription owner transfer.\r\n     * @param subId - ID of the subscription\r\n     * @dev will revert if original owner of subId has\r\n     * not requested that msg.sender become the new owner.\r\n     */\r\n    function acceptSubscriptionOwnerTransfer(uint64 subId) external;\r\n\r\n    /**\r\n     * @notice Add a consumer to a VRF subscription.\r\n     * @param subId - ID of the subscription\r\n     * @param consumer - New consumer which can use the subscription\r\n     */\r\n    function addConsumer(uint64 subId, address consumer) external;\r\n\r\n    /**\r\n     * @notice Remove a consumer from a VRF subscription.\r\n     * @param subId - ID of the subscription\r\n     * @param consumer - Consumer to remove from the subscription\r\n     */\r\n    function removeConsumer(uint64 subId, address consumer) external;\r\n\r\n    /**\r\n     * @notice Cancel a subscription\r\n     * @param subId - ID of the subscription\r\n     * @param to - Where to send the remaining LINK to\r\n     */\r\n    function cancelSubscription(uint64 subId, address to) external;\r\n\r\n    /*\r\n     * @notice Check to see if there exists a request commitment consumers\r\n     * for all consumers and keyhashes for a given sub.\r\n     * @param subId - ID of the subscription\r\n     * @return true if there exists at least one unfulfilled request for the subscription, false\r\n     * otherwise.\r\n     */\r\n    function pendingRequestExists(uint64 subId) external view returns (bool);\r\n}\r\n\r\n// File: contracts/VRFConsumerBaseV2.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/** ****************************************************************************\r\n * @notice Interface for contracts using VRF randomness\r\n * *****************************************************************************\r\n * @dev PURPOSE\r\n *\r\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\r\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\r\n * @dev making his output up to suit himself. Reggie provides Vera a public key\r\n * @dev to which he knows the secret key. Each time Vera provides a seed to\r\n * @dev Reggie, he gives back a value which is computed completely\r\n * @dev deterministically from the seed and the secret key.\r\n *\r\n * @dev Reggie provides a proof by which Vera can verify that the output was\r\n * @dev correctly computed once Reggie tells it to her, but without that proof,\r\n * @dev the output is indistinguishable to her from a uniform random sample\r\n * @dev from the output space.\r\n *\r\n * @dev The purpose of this contract is to make it easy for unrelated contracts\r\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\r\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\r\n * @dev 1. The fulfillment came from the VRFCoordinator\r\n * @dev 2. The consumer contract implements fulfillRandomWords.\r\n * *****************************************************************************\r\n * @dev USAGE\r\n *\r\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\r\n * @dev initialize VRFConsumerBase's attributes in their constructor as\r\n * @dev shown:\r\n *\r\n * @dev   contract VRFConsumer {\r\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\r\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\r\n * @dev         <initialization with other arguments goes here>\r\n * @dev       }\r\n * @dev   }\r\n *\r\n * @dev The oracle will have given you an ID for the VRF keypair they have\r\n * @dev committed to (let's call it keyHash). Create subscription, fund it\r\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\r\n * @dev subscription management functions).\r\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\r\n * @dev callbackGasLimit, numWords),\r\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\r\n *\r\n * @dev Once the VRFCoordinator has received and validated the oracle's response\r\n * @dev to your request, it will call your contract's fulfillRandomWords method.\r\n *\r\n * @dev The randomness argument to fulfillRandomWords is a set of random words\r\n * @dev generated from your requestId and the blockHash of the request.\r\n *\r\n * @dev If your contract could have concurrent requests open, you can use the\r\n * @dev requestId returned from requestRandomWords to track which response is associated\r\n * @dev with which randomness request.\r\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\r\n * @dev if your contract could have multiple requests in flight simultaneously.\r\n *\r\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\r\n * @dev differ.\r\n *\r\n * *****************************************************************************\r\n * @dev SECURITY CONSIDERATIONS\r\n *\r\n * @dev A method with the ability to call your fulfillRandomness method directly\r\n * @dev could spoof a VRF response with any random value, so it's critical that\r\n * @dev it cannot be directly called by anything other than this base contract\r\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\r\n *\r\n * @dev For your users to trust that your contract's random behavior is free\r\n * @dev from malicious interference, it's best if you can write it so that all\r\n * @dev behaviors implied by a VRF response are executed *during* your\r\n * @dev fulfillRandomness method. If your contract must store the response (or\r\n * @dev anything derived from it) and use it later, you must ensure that any\r\n * @dev user-significant behavior which depends on that stored value cannot be\r\n * @dev manipulated by a subsequent VRF request.\r\n *\r\n * @dev Similarly, both miners and the VRF oracle itself have some influence\r\n * @dev over the order in which VRF responses appear on the blockchain, so if\r\n * @dev your contract could have multiple VRF requests in flight simultaneously,\r\n * @dev you must ensure that the order in which the VRF responses arrive cannot\r\n * @dev be used to manipulate your contract's user-significant behavior.\r\n *\r\n * @dev Since the block hash of the block which contains the requestRandomness\r\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\r\n * @dev miner could, in principle, fork the blockchain to evict the block\r\n * @dev containing the request, forcing the request to be included in a\r\n * @dev different block with a different hash, and therefore a different input\r\n * @dev to the VRF. However, such an attack would incur a substantial economic\r\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\r\n * @dev until it calls responds to a request. It is for this reason that\r\n * @dev that you can signal to an oracle you'd like them to wait longer before\r\n * @dev responding to the request (however this is not enforced in the contract\r\n * @dev and so remains effective only in the case of unmodified oracle software).\r\n */\r\nabstract contract VRFConsumerBaseV2 {\r\n    error OnlyCoordinatorCanFulfill(address have, address want);\r\n    address private immutable vrfCoordinator;\r\n\r\n    /**\r\n     * @param _vrfCoordinator address of VRFCoordinator contract\r\n     */\r\n    constructor(address _vrfCoordinator) {\r\n        vrfCoordinator = _vrfCoordinator;\r\n    }\r\n\r\n    /**\r\n     * @notice fulfillRandomness handles the VRF response. Your contract must\r\n     * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\r\n     * @notice principles to keep in mind when implementing your fulfillRandomness\r\n     * @notice method.\r\n     *\r\n     * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\r\n     * @dev signature, and will call it once it has verified the proof\r\n     * @dev associated with the randomness. (It is triggered via a call to\r\n     * @dev rawFulfillRandomness, below.)\r\n     *\r\n     * @param requestId The Id initially returned by requestRandomness\r\n     * @param randomWords the VRF output expanded to the requested number of words\r\n     */\r\n    function fulfillRandomWords(\r\n        uint256 requestId,\r\n        uint256[] memory randomWords\r\n    ) internal virtual;\r\n\r\n    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\r\n    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\r\n    // the origin of the call\r\n    function rawFulfillRandomWords(\r\n        uint256 requestId,\r\n        uint256[] memory randomWords\r\n    ) external {\r\n        if (msg.sender != vrfCoordinator) {\r\n            revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\r\n        }\r\n        fulfillRandomWords(requestId, randomWords);\r\n    }\r\n}\r\n\r\n// File: contracts/TreatToken.sol\r\n\r\n/*\r\n Halloween coin with a lottery system and possibility of winning up to 10x your bet.\r\n\r\n\r\nhttps://t.me/HalloweenCerc20\r\n\r\ntwitter.com/HalloweenCerc20\r\n\r\nhttps://halloweencoinerc20.com\r\n\r\n\r\n\r\n             .\r\n                 //\r\n       _.-\"\"\"\"\"'//-'\"\"\"\"-._\r\n     .', ,  , , : : ` ` `  `.\r\n    / , , \\'-._ : :_.-'/ ` ` \\\r\n   / , ,  :\\(_)\\  /(_)/ : ` ` \\\r\n  | , ,  ,  \\__//\\\\__/ . . ` ` |\r\n  | . .:_  : : '--`: : . _: ; :|\r\n  | : : \\\\_  _' : _: :__// , , |\r\n   \\ ` ` \\ \\/ \\/\\/ \\_/  / , , /\r\n    \\ ` ` \\_/\\_/\\_/\\_/\\/ , , /\r\n     `._ ` . :  :  :  , , _.'\r\n        `-..............-' \r\n\r\n*/\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TreatToken is ERC20, VRFConsumerBaseV2, ConfirmedOwner {\r\n    // ======================== VRF ========================\r\n    event RequestSent(uint256 requestId, uint32 numWords);\r\n    event RequestFulfilled(uint256 requestId, uint256 randomWords);\r\n\r\n    struct RequestStatus {\r\n        bool fulfilled;\r\n        bool exists;\r\n        uint256 randomWords;\r\n    }\r\n    mapping(uint256 => RequestStatus) public s_requests;\r\n    VRFCoordinatorV2Interface COORDINATOR;\r\n\r\n    uint64 s_subscriptionId;\r\n\r\n    bytes32 keyHash =\r\n        0x9fe0eebf5e446e3c998ec9bb19951541aee00bb90ea201ae456421a2ded86805;\r\n\r\n    uint32 callbackGasLimit = 100000;\r\n\r\n    // The default is 3, but you can set this higher.\r\n    uint16 requestConfirmations = 3;\r\n\r\n    uint32 numWords = 1;\r\n\r\n    // ======================== GAME STRUCTURE ========================\r\n    struct Game {\r\n        uint256 startTime; // start of the game\r\n        uint256 endBet; //timestamp where they can no longer bet\r\n        uint256 claimBegin; //timestamp from which they can claim\r\n        uint256 claimDuration; //timestamp for claim\r\n        uint256 endClaim; //timestamp up to which they can claim\r\n        uint256 idOfTheGame;\r\n        bool gameHasBegun;\r\n        uint16 numberOfDoor;\r\n        bool doorHasBeenGenerated;\r\n        uint256 totalBets;\r\n        uint256 totalBetDoor1;\r\n        uint256 totalBetDoor2;\r\n        uint256 totalBetDoor3;\r\n        uint256 _multiplicator;\r\n    }\r\n\r\n    uint16 public numberOfGame;\r\n    mapping(uint16 => Game) public game;\r\n    mapping(uint16 => uint256) private resultOfGame;\r\n\r\n    event Bet(address indexed user, uint256 amount);\r\n    event DoorGeneration(uint256 indexed requestId);\r\n    event DoorGenerated(uint256 indexed requestId, uint256 result);\r\n\r\n    // ======================== USER STRUCTURE ========================\r\n    struct User {\r\n        uint256 bet;\r\n        uint256 totalBet;\r\n        uint16 chosenDoor;\r\n        bool openedDoor;\r\n        bool win;\r\n        uint256 earned;\r\n        uint256 totalEarned;\r\n    }\r\n\r\n    mapping(address => mapping(uint16 => User)) public userInfos;\r\n\r\n    // ======================== TAXES & LIMITS ========================\r\n\r\n    mapping(address => bool) public exemptFromFees;\r\n    mapping(address => bool) public exemptFromLimits;\r\n\r\n    uint128 public transactionLimit = 26_000e18;\r\n    uint128 public walletLimit = 26_000e18;\r\n\r\n    uint48 buyTax = 5;\r\n    uint48 sellTax = 5;\r\n    uint48 earlyTax = 19;\r\n\r\n    uint64 public constant FEE_DIVISOR = 100;\r\n    uint256 public _buyCount;\r\n    uint256 public swapTokensAmount = 5000e18;\r\n\r\n    // ======================== TOKEN ========================\r\n\r\n    uint256 maxTime = type(uint256).max / 2;\r\n    address team;\r\n    uint256 constant _initial_supply = 1000000 * (10 ** 18);\r\n    bool tradingOpen;\r\n\r\n    address public lpPair;\r\n    IDexRouter public dexRouter;\r\n\r\n    mapping(address => bool) public isAMMPair;\r\n\r\n    // ======================== CONSTRUCTOR ========================\r\n    constructor(\r\n        uint64 subscriptionId\r\n    )\r\n        ERC20(\"Halloween Coin\", \"TREAT\")\r\n        VRFConsumerBaseV2(0x271682DEB8C4E0901D1a1550aD2e64D568E69909)\r\n        ConfirmedOwner(msg.sender)\r\n    {\r\n        COORDINATOR = VRFCoordinatorV2Interface(\r\n            0x271682DEB8C4E0901D1a1550aD2e64D568E69909\r\n        );\r\n        s_subscriptionId = subscriptionId;\r\n        team = msg.sender;\r\n        address _v2Router;\r\n\r\n        // UniswapRouter\r\n        _v2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        dexRouter = IDexRouter(_v2Router);\r\n        lpPair = IDexFactory(dexRouter.factory()).createPair(\r\n            address(this),\r\n            dexRouter.WETH()\r\n        );\r\n\r\n        isAMMPair[lpPair] = true;\r\n\r\n        exemptFromLimits[lpPair] = true;\r\n        exemptFromLimits[msg.sender] = true;\r\n        exemptFromLimits[address(this)] = true;\r\n\r\n        exemptFromFees[msg.sender] = true;\r\n        exemptFromFees[address(this)] = true;\r\n\r\n        _approve(address(this), address(dexRouter), type(uint256).max);\r\n        _approve(address(msg.sender), address(dexRouter), totalSupply());\r\n\r\n        _mint(msg.sender, _initial_supply);\r\n    }\r\n\r\n    modifier onlyTeam() {\r\n        require(msg.sender == team);\r\n        _;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function setGame(\r\n        uint256 _bettingDuration,\r\n        uint256 _claimingDuration,\r\n        uint16 _numberOfDoor,\r\n        uint256 _multipe\r\n    ) external onlyTeam {\r\n        if (game[numberOfGame].gameHasBegun) {\r\n            require(\r\n                block.timestamp > game[numberOfGame].endClaim,\r\n                \"a game is in progress\"\r\n            );\r\n            numberOfGame++;\r\n        }\r\n        game[numberOfGame].startTime = block.timestamp;\r\n        game[numberOfGame].endBet = block.timestamp + _bettingDuration;\r\n        game[numberOfGame].claimDuration = _claimingDuration;\r\n        game[numberOfGame].gameHasBegun = true;\r\n        game[numberOfGame].numberOfDoor = _numberOfDoor;\r\n        game[numberOfGame].claimBegin = maxTime;\r\n        game[numberOfGame]._multiplicator = _multipe;\r\n    }\r\n\r\n    function placeBet(uint256 _betAmount, uint16 _door) external {\r\n        require(game[numberOfGame].gameHasBegun, \"The game hasn't started yet\");\r\n        require(block.timestamp < game[numberOfGame].endBet);\r\n        require(\r\n            _door > 0 && _door <= game[numberOfGame].numberOfDoor,\r\n            \"please select a valid door\"\r\n        );\r\n        if (_door == 1) {\r\n            game[numberOfGame].totalBetDoor1++;\r\n        } else if (_door == 2) {\r\n            game[numberOfGame].totalBetDoor2++;\r\n        } else {\r\n            game[numberOfGame].totalBetDoor3++;\r\n        }\r\n        game[numberOfGame].totalBets++;\r\n        userInfos[msg.sender][numberOfGame].bet = _betAmount;\r\n        userInfos[msg.sender][numberOfGame].totalBet += _betAmount;\r\n        userInfos[msg.sender][numberOfGame].chosenDoor = _door;\r\n        _burn(msg.sender, _betAmount);\r\n        emit Bet(msg.sender, _betAmount);\r\n    }\r\n\r\n    function getPercentage() public view returns (uint256, uint256, uint256) {\r\n        require(game[numberOfGame].totalBets > 0, \"there are no bets\");\r\n        uint256 total = game[numberOfGame].totalBets;\r\n        return (\r\n            (game[numberOfGame].totalBetDoor1 * 100) / total,\r\n            (game[numberOfGame].totalBetDoor2 * 100) / total,\r\n            (game[numberOfGame].totalBetDoor3 * 100) / total\r\n        );\r\n    }\r\n\r\n    function generateRandomDoor()\r\n        external\r\n        onlyTeam\r\n        returns (uint256 requestId)\r\n    {\r\n        require(game[numberOfGame].gameHasBegun, \"The game hasn't started yet\");\r\n        require(\r\n            block.timestamp > game[numberOfGame].endBet,\r\n            \"users can still place bets\"\r\n        );\r\n        require(\r\n            !game[numberOfGame].doorHasBeenGenerated,\r\n            \"the door has already been generated\"\r\n        );\r\n        requestId = COORDINATOR.requestRandomWords(\r\n            keyHash,\r\n            s_subscriptionId,\r\n            requestConfirmations,\r\n            callbackGasLimit,\r\n            numWords\r\n        );\r\n        game[numberOfGame].claimBegin = block.timestamp + 360; // wait 6 minutes\r\n        game[numberOfGame].endClaim =\r\n            game[numberOfGame].claimBegin +\r\n            game[numberOfGame].claimDuration;\r\n        game[numberOfGame].idOfTheGame = requestId;\r\n        game[numberOfGame].doorHasBeenGenerated = true;\r\n        emit DoorGeneration(requestId);\r\n    }\r\n\r\n    function fulfillRandomWords(\r\n        uint256 requestId,\r\n        uint256[] memory randomWords\r\n    ) internal override {\r\n        uint256 doorValue = (randomWords[0] % game[numberOfGame].numberOfDoor) +\r\n            1; // value in [1, ..., numberDoor]\r\n        resultOfGame[numberOfGame] = doorValue;\r\n        emit DoorGenerated(requestId, doorValue);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        if (!exemptFromFees[from] && !exemptFromFees[to]) {\r\n            require(tradingOpen, \"Trading is not open yet\");\r\n            uint128 tax = 0;\r\n            bool sell;\r\n            //buy\r\n            if (isAMMPair[from]) {\r\n                require(\r\n                    amount <= transactionLimit &&\r\n                        amount + balanceOf(to) <= walletLimit,\r\n                    \"amount too high\"\r\n                );\r\n                if (_buyCount <= 20) {\r\n                    tax = earlyTax;\r\n                } else {\r\n                    tax = buyTax;\r\n                }\r\n                _buyCount++;\r\n            }\r\n            // sell\r\n            else if (isAMMPair[to]) {\r\n                require(amount <= transactionLimit, \"amount too high\");\r\n                sell = true;\r\n                if (_buyCount <= 20) {\r\n                    tax = earlyTax;\r\n                } else {\r\n                    tax = sellTax;\r\n                }\r\n            }\r\n            // transfer\r\n            else {\r\n                require(amount + balanceOf(to) <= walletLimit, \"Max Wallet\");\r\n            }\r\n            uint256 taxAmount = (amount * tax) / FEE_DIVISOR;\r\n            amount -= taxAmount;\r\n            super._transfer(from, address(this), taxAmount);\r\n\r\n            if (sell && balanceOf(address(this)) > swapTokensAmount) {\r\n                sendTeamCall();\r\n            }\r\n        }\r\n\r\n        super._transfer(from, to, amount);\r\n    }\r\n\r\n    function sendTeamCall() private {\r\n        uint256 initialETHBalance = address(this).balance;\r\n        swapTokensForEth(swapTokensAmount);\r\n        uint256 newBalance = address(this).balance - initialETHBalance;\r\n        (bool success, ) = team.call{value: newBalance}(\"\");\r\n    }\r\n\r\n    // view the reward before\r\n    function viewResult(uint16 _game) public view returns (uint256) {\r\n        if (block.timestamp > game[_game].endClaim) {\r\n            return resultOfGame[_game];\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function openDoor() external {\r\n        require(\r\n            !userInfos[msg.sender][numberOfGame].openedDoor,\r\n            \"user has already opened the door\"\r\n        );\r\n        require(\r\n            block.timestamp > game[numberOfGame].claimBegin &&\r\n                block.timestamp < game[numberOfGame].endClaim,\r\n            \"you can't claim right now\"\r\n        );\r\n        userInfos[msg.sender][numberOfGame].openedDoor = true;\r\n        if (\r\n            userInfos[msg.sender][numberOfGame].chosenDoor ==\r\n            resultOfGame[numberOfGame]\r\n        ) {\r\n            uint256 mutiplicator = game[numberOfGame]._multiplicator;\r\n            userInfos[msg.sender][numberOfGame].win = true;\r\n            uint256 _earn = mutiplicator *\r\n                userInfos[msg.sender][numberOfGame].bet;\r\n            userInfos[msg.sender][numberOfGame].earned = _earn;\r\n            userInfos[msg.sender][numberOfGame].totalEarned += _earn;\r\n            _mint(msg.sender, _earn);\r\n        }\r\n    }\r\n\r\n    function getResult(\r\n        address _address,\r\n        uint16 _game\r\n    ) public view returns (bool _didWin, uint256 _earned) {\r\n        return (\r\n            userInfos[_address][_game].win,\r\n            userInfos[_address][_game].earned\r\n        );\r\n    }\r\n\r\n    // view if a user has already claimed for a given game\r\n    function hasAlreadyClaimed(\r\n        address _user,\r\n        uint16 _gameNumber\r\n    ) public view returns (bool) {\r\n        return userInfos[_user][_gameNumber].openedDoor;\r\n    }\r\n\r\n    // view for a given game the amount of a user's bet and the gate chosen\r\n    function getBetAndDoor(\r\n        address _user,\r\n        uint16 _gameNumber\r\n    ) public view returns (uint256, uint256) {\r\n        return (\r\n            userInfos[_user][_gameNumber].bet,\r\n            userInfos[_user][_gameNumber].chosenDoor\r\n        );\r\n    }\r\n\r\n    function getStateOfTheGame() public view returns (uint16 _state) {\r\n        if (block.timestamp < game[numberOfGame].endBet) {\r\n            _state = 1;\r\n        } else if (block.timestamp < game[numberOfGame].claimBegin) {\r\n            _state = 2;\r\n        } else if (block.timestamp < game[numberOfGame].endClaim) {\r\n            _state = 3;\r\n        } else {\r\n            _state = 0;\r\n        }\r\n        return _state;\r\n    }\r\n\r\n    function updateTaxesFees(uint48 _buy, uint48 _sell) external onlyTeam {\r\n        buyTax = _buy;\r\n        sellTax = _sell;\r\n    }\r\n\r\n    function updateSwapTokensAmount(uint256 _newAmount) external onlyTeam {\r\n        swapTokensAmount = _newAmount;\r\n    }\r\n\r\n    function enableTrading() external onlyTeam {\r\n        tradingOpen = true;\r\n    }\r\n\r\n    function updateLimits(uint128 _tx, uint128 _wallet) external onlyTeam {\r\n        transactionLimit = _tx;\r\n        walletLimit = _wallet;\r\n    }\r\n\r\n    function setExemptFromFees(address _address) external onlyTeam {\r\n        exemptFromFees[_address] = true;\r\n    }\r\n\r\n    function setExemptFromLimits(address _address) external onlyTeam {\r\n        exemptFromLimits[_address] = true;\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = dexRouter.WETH();\r\n\r\n        //_approve(address(this), address(dexRouter), tokenAmount);\r\n\r\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function swapAndSendEmergency(uint256 tokens) external onlyTeam {\r\n        uint256 initialETHBalance = address(this).balance;\r\n        swapTokensForEth(tokens);\r\n        uint256 newBalance = address(this).balance - initialETHBalance;\r\n        (bool success, ) = team.call{value: newBalance}(\"\");\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Bet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"DoorGenerated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"DoorGeneration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomWords\",\"type\":\"uint256\"}],\"name\":\"RequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"name\":\"RequestSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FEE_DIVISOR\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exemptFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"exemptFromLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"game\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endBet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimBegin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idOfTheGame\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"gameHasBegun\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"numberOfDoor\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"doorHasBeenGenerated\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalBets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBetDoor1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBetDoor2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBetDoor3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiplicator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generateRandomDoor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_gameNumber\",\"type\":\"uint16\"}],\"name\":\"getBetAndDoor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_game\",\"type\":\"uint16\"}],\"name\":\"getResult\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_didWin\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_earned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStateOfTheGame\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"_state\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_gameNumber\",\"type\":\"uint16\"}],\"name\":\"hasAlreadyClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAMMPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfGame\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openDoor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_door\",\"type\":\"uint16\"}],\"name\":\"placeBet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"s_requests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"randomWords\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setExemptFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setExemptFromLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bettingDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimingDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_numberOfDoor\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_multipe\",\"type\":\"uint256\"}],\"name\":\"setGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"swapAndSendEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionLimit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_tx\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_wallet\",\"type\":\"uint128\"}],\"name\":\"updateLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"_buy\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"_sell\",\"type\":\"uint48\"}],\"name\":\"updateTaxesFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBet\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"chosenDoor\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"openedDoor\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"win\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEarned\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_game\",\"type\":\"uint16\"}],\"name\":\"viewResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletLimit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TreatToken", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000361", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2e34fc496947c6ab82ec02ea5db4725d2d436625d0ba6db2d77dc1c191c74a07"}