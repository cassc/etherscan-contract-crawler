{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Zapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport {Errors} from \\\"src/Errors.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nimport {AUniswap, ISwapRouter} from \\\"src/AUniswap.sol\\\";\\nimport {ABalancer} from \\\"src/ABalancer.sol\\\";\\nimport {ACurve} from \\\"src/ACurve.sol\\\";\\nimport {IWarMinter} from \\\"warlord/IWarMinter.sol\\\";\\nimport {IWarStaker} from \\\"warlord/IWarStaker.sol\\\";\\nimport {WETH9} from \\\"int/WETH.sol\\\";\\n\\n/// @title Warlord Zapper Contract\\n/// @author centonze.eth\\n/// @dev This contract enables users to seamlessly convert any pair that is sufficiently liquid on Uniswap V3\\n/// into stkWar tokens for the Warlord protocol by Paladin.vote. The conversion route is designed as:\\n/// anyToken -> WETH (via Uniswap) -> either AURA or CVX based on the selected vlToken.\\ncontract Zapper is AUniswap, ACurve, ABalancer {\\n    using SafeTransferLib for ERC20;\\n\\n    // Tokens that are whitelisted for zap\\n    mapping(address => bool) public allowedTokens;\\n\\n    // Represent 100% of something when calculating ratios\\n    uint256 private constant MAX_BPS = 10_000;\\n\\n    // the address of the WAR token\\n    address public constant WAR = 0xa8258deE2a677874a48F5320670A869D74f0cbC1;\\n\\n    // Contract allowed to mint war\\n    address public warMinter = 0x144a689A8261F1863c89954930ecae46Bd950341;\\n    // Contract allowed to stake war and obtain rewards\\n    address public warStaker = 0xA86c53AF3aadF20bE5d7a8136ACfdbC4B074758A;\\n\\n    /// @notice This event is emitted when a zap operation occurs.\\n    /// @param token The token that was zapped.\\n    /// @param amount The amount of token that was zapped.\\n    /// @param mintedAmount The amount of WAR tokens minted as a result.\\n    /// @param receiver The address of the recipient of the WAR tokens.\\n    event Zapped(address indexed token, uint256 amount, uint256 mintedAmount, address receiver);\\n\\n    /// @notice This event is emitted when a token's whitelist is updated.\\n    /// @param token The token that had its status updated.\\n    /// @param allowed True if the token is now allowed, false otherwise.\\n    event TokenUpdated(address indexed token, bool allowed);\\n\\n    /// @notice This event is emitted when the WarMinter address is changed.\\n    /// @param newMinter The new WarMinter address.\\n    event SetWarMinter(address newMinter);\\n\\n    /// @notice This event is emitted when the WarStaker address is changed.\\n    /// @param newStaker The new WarStaker address.\\n    event SetWarStaker(address newStaker);\\n\\n    /*////////////////////////////////////////////\\n    /              Tokens Management             /\\n    ////////////////////////////////////////////*/\\n\\n    /// @dev Enables a token for zapping and sets the Uniswap V3 fee when swapping to ether.\\n    /// @param token The token to be enabled.\\n    /// @param fee The Uniswap pool fee.\\n    function enableToken(address token, uint24 fee) external onlyOwner {\\n        // Not checking the fee tier correctness for simplicity\\n        // because new ones might be added by uniswap governance.\\n        if (token == address(0)) revert Errors.ZeroAddress();\\n        if (allowedTokens[token]) revert Errors.TokenAlreadyAllowed();\\n\\n        allowedTokens[token] = true;\\n        _setUniswapFee(token, fee);\\n\\n        _resetUniswapAllowance(token);\\n\\n        emit TokenUpdated(token, true);\\n    }\\n\\n    /// @dev Updates the Uniswap fee associated with a token.\\n    /// @param token The token for which the fee is being set.\\n    /// @param fee The new fee value.\\n    function setUniswapFee(address token, uint24 fee) external onlyOwner {\\n        // Not checking the fee tier correctness for simplicity\\n        // because new ones might be added by uniswap governance.\\n        if (token == address(0)) revert Errors.ZeroAddress();\\n        if (!allowedTokens[token]) revert Errors.TokenNotAllowed();\\n\\n        _setUniswapFee(token, fee);\\n    }\\n\\n    /// @dev Disables a token from being used in zapping operations.\\n    /// @notice Can also be used to remove allowance to uniswap router for that token.\\n    /// @param token The token to be disabled.\\n    function disableToken(address token) external onlyOwner {\\n        if (token == address(0)) revert Errors.ZeroAddress();\\n\\n        allowedTokens[token] = false;\\n\\n        _removeUniswapAllowance(token);\\n\\n        emit TokenUpdated(token, false);\\n    }\\n\\n    /*////////////////////////////////////////////\\n    /          Warlord allowance methods         /\\n    ////////////////////////////////////////////*/\\n\\n    /// @dev Resets the allowances for Warlord-related interactions.\\n    function resetWarlordAllowances() external onlyOwner {\\n        ERC20(AURA).safeApprove(warMinter, type(uint256).max);\\n        ERC20(CVX).safeApprove(warMinter, type(uint256).max);\\n        ERC20(WAR).safeApprove(warStaker, type(uint256).max);\\n    }\\n\\n    /// @dev Removes the allowances for Warlord-related interactions.\\n    function removeWarlordAllowances() external onlyOwner {\\n        ERC20(AURA).safeApprove(warMinter, 0);\\n        ERC20(CVX).safeApprove(warMinter, 0);\\n        ERC20(WAR).safeApprove(warStaker, 0);\\n    }\\n\\n    /*////////////////////////////////////////////\\n    /              Warlord setters               /\\n    ////////////////////////////////////////////*/\\n\\n    /// @dev Changes the WarMinter contract address.\\n    /// @param _warMinter The new WarMinter contract address.\\n    function setWarMinter(address _warMinter) external onlyOwner {\\n        if (_warMinter == address(0)) revert Errors.ZeroAddress();\\n        warMinter = _warMinter;\\n\\n        emit SetWarMinter(_warMinter);\\n    }\\n\\n    /// @dev Changes the WarStaker contract address.\\n    /// @param _warStaker The new WarStaker contract address.\\n    function setWarStaker(address _warStaker) external onlyOwner {\\n        if (_warStaker == address(0)) revert Errors.ZeroAddress();\\n        warStaker = _warStaker;\\n\\n        emit SetWarStaker(_warStaker);\\n    }\\n\\n    /*////////////////////////////////////////////\\n    /                Zap Functions               /\\n    ////////////////////////////////////////////*/\\n\\n    /// @notice Internal function to zap WETH into a single token, either AURA or CVX, and then mint and stake WAR tokens.\\n    /// @param receiver The address to receive staked WAR tokens.\\n    /// @param useCvx A boolean to decide whether to zap into CVX (true) or AURA (false).\\n    /// @param amount The amount of WETH to be zapped.\\n    /// @param minVlTokenOut Minimum amount of AURA/CVX expected to receive from zapping.\\n    /// @return Returns the amount of WAR staked.\\n    function _zapWethToSingleToken(address receiver, bool useCvx, uint256 amount, uint256 minVlTokenOut)\\n        internal\\n        returns (uint256)\\n    {\\n        if (useCvx) {\\n            _wethToCvx(amount, minVlTokenOut);\\n            uint256 cvxAmount = ERC20(CVX).balanceOf(address(this));\\n            IWarMinter(warMinter).mint(CVX, cvxAmount);\\n        } else {\\n            _wethToAura(amount, minVlTokenOut);\\n            uint256 auraAmount = ERC20(AURA).balanceOf(address(this));\\n            IWarMinter(warMinter).mint(AURA, auraAmount);\\n        }\\n\\n        uint256 warAmount = ERC20(WAR).balanceOf(address(this));\\n        return IWarStaker(warStaker).stake(warAmount, receiver);\\n    }\\n\\n    /// @notice Zap Ether into a single token (either AURA or CVX) and then mint and stake WAR tokens.\\n    /// @param receiver The address to receive staked WAR tokens.\\n    /// @param useCvx A boolean to decide whether to zap into CVX (true) or AURA (false).\\n    /// @param minVlTokenOut Minimum amount of AURA/CVX expected to receive from zapping.\\n    /// @return stakedAmount Amount of WAR staked.\\n    function zapEtherToSingleToken(address receiver, bool useCvx, uint256 minVlTokenOut)\\n        external\\n        payable\\n        returns (uint256 stakedAmount)\\n    {\\n        if (receiver == address(0)) revert Errors.ZeroAddress();\\n        if (msg.value == 0) revert Errors.NullAmount();\\n\\n        // Convert native eth to weth\\n        WETH9(WETH).deposit{value: msg.value}();\\n\\n        // Zap weth to vlCvx or vlAura\\n        stakedAmount = _zapWethToSingleToken(receiver, useCvx, msg.value, minVlTokenOut);\\n\\n        emit Zapped(WETH, msg.value, stakedAmount, receiver);\\n    }\\n\\n    /// @notice Zap a specified ERC20 token into a single token (either AURA or CVX) and then mint and stake WAR tokens.\\n    /// @param token The ERC20 token to be zapped.\\n    /// @param amount The amount of the ERC20 token to be zapped.\\n    /// @param receiver The address to receive staked WAR tokens.\\n    /// @param useCvx A boolean to decide whether to zap into CVX (true) or AURA (false).\\n    /// @param minEthOut Minimum amount of WETH expected to receive from token -> WETH conversion.\\n    /// @param minVlTokenOut Minimum amount of AURA/CVX expected to receive from WETH -> AURA/CVX conversion.\\n    /// @return stakedAmount Amount of WAR staked.\\n    function zapERC20ToSingleToken(\\n        address token,\\n        uint256 amount,\\n        address receiver,\\n        bool useCvx,\\n        uint256 minEthOut,\\n        uint256 minVlTokenOut\\n    ) external returns (uint256 stakedAmount) {\\n        if (token == address(0)) revert Errors.ZeroAddress();\\n        if (!allowedTokens[token]) revert Errors.TokenNotAllowed();\\n        if (receiver == address(0)) revert Errors.ZeroAddress();\\n        if (amount == 0) revert Errors.NullAmount();\\n\\n        // Pull ether from sender to this contract\\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        // Ensure that we have WETH to zap\\n        if (token != WETH) {\\n            amount = _etherize(token, amount, minEthOut);\\n        }\\n\\n        // Zap weth to vlCvx or vlAura\\n        stakedAmount = _zapWethToSingleToken(receiver, useCvx, amount, minVlTokenOut);\\n\\n        emit Zapped(token, amount, stakedAmount, receiver);\\n    }\\n\\n    /// @notice Internal function to zap WETH into multiple tokens (both AURA and CVX), and then mint and stake WAR tokens.\\n    /// @param receiver The address to receive staked WAR tokens.\\n    /// @param amount The amount of WETH to be zapped.\\n    /// @param ratio Ratio of WETH to be used for AURA vs CVX.\\n    /// @param minAuraOut Minimum amount of AURA expected to receive.\\n    /// @param minCvxOut Minimum amount of CVX expected to receive.\\n    /// @return Returns the amount of WAR staked.\\n    function _zapWethToMultipleTokens(\\n        address receiver,\\n        uint256 amount,\\n        uint256 ratio,\\n        uint256 minAuraOut,\\n        uint256 minCvxOut\\n    ) internal returns (uint256) {\\n        uint256 auraAmount = amount * ratio / MAX_BPS;\\n        uint256 cvxAmount = amount - auraAmount;\\n\\n        _wethToAura(auraAmount, minAuraOut);\\n        _wethToCvx(cvxAmount, minCvxOut);\\n\\n        address[] memory vlTokens = new address[](2);\\n        vlTokens[0] = AURA;\\n        vlTokens[1] = CVX;\\n        uint256[] memory amounts = new uint256[](2);\\n        amounts[0] = ERC20(AURA).balanceOf(address(this));\\n        amounts[1] = ERC20(CVX).balanceOf(address(this));\\n\\n        IWarMinter(warMinter).mintMultiple(vlTokens, amounts);\\n\\n        uint256 warAmount = ERC20(WAR).balanceOf(address(this));\\n        return IWarStaker(warStaker).stake(warAmount, receiver);\\n    }\\n\\n    /// @notice Zap Ether into multiple tokens (both AURA and CVX) and then mint and stake WAR tokens.\\n    /// @param receiver The address to receive staked WAR tokens.\\n    /// @param ratio Ratio of Ether to be used for AURA vs CVX.\\n    /// @param minAuraOut Minimum amount of AURA expected to receive.\\n    /// @param minCvxOut Minimum amount of CVX expected to receive.\\n    /// @return stakedAmount Amount of WAR staked.\\n    function zapEtherToMultipleTokens(address receiver, uint256 ratio, uint256 minAuraOut, uint256 minCvxOut)\\n        external\\n        payable\\n        returns (uint256 stakedAmount)\\n    {\\n        if (receiver == address(0)) revert Errors.ZeroAddress();\\n        if (ratio == 0 || ratio > 9999) revert Errors.InvalidRatio();\\n        if (msg.value == 0) revert Errors.NullAmount();\\n\\n        // Convert native eth to weth\\n        WETH9(WETH).deposit{value: msg.value}();\\n\\n        // Zap weth to vlCvx and vlAura\\n        stakedAmount = _zapWethToMultipleTokens(receiver, msg.value, ratio, minAuraOut, minCvxOut);\\n\\n        emit Zapped(WETH, msg.value, stakedAmount, receiver);\\n    }\\n\\n    /// @notice Zap a specified ERC20 token into multiple tokens (both AURA and CVX) and then mint and stake WAR tokens.\\n    /// @param token The ERC20 token to be zapped.\\n    /// @param amount The amount of the ERC20 token to be zapped.\\n    /// @param receiver The address to receive staked WAR tokens.\\n    /// @param ratio Ratio of token amount to be used for AURA vs CVX.\\n    /// @param minEthOut Minimum amount of WETH expected to receive from token -> WETH conversion.\\n    /// @param minAuraOut Minimum amount of AURA expected to receive from WETH -> AURA conversion.\\n    /// @param minCvxOut Minimum amount of CVX expected to receive from WETH -> CVX conversion.\\n    /// @return stakedAmount Amount of WAR staked.\\n    function zapERC20ToMultipleTokens(\\n        address token,\\n        uint256 amount,\\n        address receiver,\\n        uint256 ratio,\\n        uint256 minEthOut,\\n        uint256 minAuraOut,\\n        uint256 minCvxOut\\n    ) external returns (uint256 stakedAmount) {\\n        if (token == address(0)) revert Errors.ZeroAddress();\\n        if (receiver == address(0)) revert Errors.ZeroAddress();\\n        if (amount == 0) revert Errors.NullAmount();\\n        if (!allowedTokens[token]) revert Errors.TokenNotAllowed();\\n        if (ratio == 0 || ratio > 9999) revert Errors.InvalidRatio();\\n\\n        // Pull ether from sender to this contract\\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        // Ensure that we have WETH to zap\\n        if (token != WETH) {\\n            amount = _etherize(token, amount, minEthOut);\\n        }\\n\\n        // Zap weth to vlCvx and vlAura\\n        stakedAmount = _zapWethToMultipleTokens(receiver, amount, ratio, minAuraOut, minCvxOut);\\n\\n        emit Zapped(token, amount, stakedAmount, receiver);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nlibrary Errors {\\n    // Generic errors\\n    error ZeroAddress();\\n    error NullAmount();\\n\\n    // Token management\\n    error TokenNotAllowed();\\n    error TokenAlreadyAllowed();\\n\\n    // Mint ratios\\n    error InvalidRatio();\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument. Masking not required as it's a full 32 byte type.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/AUniswap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport {Errors} from \\\"src/Errors.sol\\\";\\nimport {ISwapRouter} from \\\"uniswap/ISwapRouter.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {EtherUtils} from \\\"src/EtherUtils.sol\\\";\\n\\n/// @title AUniswap\\n/// @author centonze.eth\\n/// @notice Utility functions related to Uniswap operations.\\nabstract contract AUniswap is EtherUtils {\\n    using SafeTransferLib for ERC20;\\n\\n    // The uniswap pool fee for each token.\\n    mapping(address => uint24) public uniswapFees;\\n    // Address of Uniswap V3 router\\n    ISwapRouter public swapRouter = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\\n\\n    /// @notice Emitted when the Uniswap router address is updated.\\n    /// @param newRouter The address of the new router.\\n    event SetUniswapRouter(address newRouter);\\n\\n    /// @notice Emitted when the Uniswap fee for a token is updated.\\n    /// @param token The token whose fee has been updated.\\n    /// @param fee The new fee value.\\n    event SetUniswapFee(address indexed token, uint24 fee);\\n\\n    /// @notice Sets a new address for the Uniswap router.\\n    /// @param _swapRouter The address of the new router.\\n    function setUniswapRouter(address _swapRouter) external onlyOwner {\\n        if (_swapRouter == address(0)) revert Errors.ZeroAddress();\\n        swapRouter = ISwapRouter(_swapRouter);\\n\\n        emit SetUniswapRouter(_swapRouter);\\n    }\\n\\n    /// @dev Internal function to set Uniswap fee for a token.\\n    /// @param token The token for which to set the fee.\\n    /// @param fee The fee to be set.\\n    function _setUniswapFee(address token, uint24 fee) internal {\\n        uniswapFees[token] = fee;\\n\\n        emit SetUniswapFee(token, fee);\\n    }\\n\\n    /// @dev Resets allowance for the Uniswap router for a specific token.\\n    /// @param token The token for which to reset the allowance.\\n    function _resetUniswapAllowance(address token) internal {\\n        ERC20(token).safeApprove(address(swapRouter), type(uint256).max);\\n    }\\n\\n    /// @dev Removes allowance for the Uniswap router for a specific token.\\n    /// @param token The token for which to remove the allowance.\\n    function _removeUniswapAllowance(address token) internal {\\n        ERC20(token).safeApprove(address(swapRouter), 0);\\n    }\\n\\n    /// @dev Converts a given amount of a token into WETH using Uniswap.\\n    /// @param token The token to be converted.\\n    /// @param amountIn The amount of token to be swapped.\\n    /// @param ethOutMin The minimum amount of WETH expected in return.\\n    /// @return amountOut The amount of WETH received from the swap.\\n    function _etherize(address token, uint256 amountIn, uint256 ethOutMin) internal returns (uint256 amountOut) {\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams({\\n            tokenIn: token, // The input token address\\n            tokenOut: WETH, // The token received should be Wrapped Ether\\n            fee: uniswapFees[token], // The fee tier of the pool\\n            recipient: address(this), // Receiver of the swapped tokens\\n            deadline: block.timestamp, // Swap has to be terminated at block time\\n            amountIn: amountIn, // The exact amount to swap\\n            amountOutMinimum: ethOutMin, // Quote is given by frontend to ensure slippage is minimised\\n            sqrtPriceLimitX96: 0 // Ensure we swap our exact input amount.\\n        });\\n\\n        amountOut = swapRouter.exactInputSingle(params);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ABalancer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport {Errors} from \\\"src/Errors.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {IVault} from \\\"balancer/IVault.sol\\\";\\nimport {EtherUtils} from \\\"src/EtherUtils.sol\\\";\\n\\nabstract contract ABalancer is EtherUtils {\\n    using SafeTransferLib for ERC20;\\n\\n    // Ethereum mainnet address of cvx.\\n    address internal constant AURA = 0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF;\\n\\n    // Ethereum mainnet address balanlcer vault.\\n    address public vault = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\\n    // Ethereum mainnet id for balancer AURA-WETH pool.\\n    bytes32 public poolId = 0xcfca23ca9ca720b6e98e3eb9b6aa0ffc4a5c08b9000200000000000000000274;\\n\\n    /// @notice Emitted when the Balancer vault address is updated.\\n    /// @param newVault The address of the new Balancer vault.\\n    event SetBalancerVault(address newVault);\\n\\n    /// @notice Emitted when the Balancer pool ID is updated.\\n    /// @param newPoolId The new pool ID.\\n    event SetBalancerPoolId(bytes32 newPoolId);\\n\\n    /// @notice Sets a new address for the Balancer vault.\\n    /// @param _vault The address of the new Balancer vault.\\n    function setBalancerVault(address _vault) external onlyOwner {\\n        if (_vault == address(0)) revert Errors.ZeroAddress();\\n        vault = _vault;\\n\\n        emit SetBalancerVault(_vault);\\n    }\\n\\n    /// @notice Sets a new pool ID for Balancer operations.\\n    /// @param _poolId The new pool ID.\\n    function setBalancerPoolId(bytes32 _poolId) external onlyOwner {\\n        poolId = _poolId;\\n\\n        emit SetBalancerPoolId(_poolId);\\n    }\\n\\n    /// @notice Resets WETH allowance for the specified Balancer vault.\\n    function resetBalancerAllowance() external onlyOwner {\\n        _resetWethAllowance(vault);\\n    }\\n\\n    /// @notice Removes WETH allowance for the specified Balancer vault.\\n    function removeBalancerAllowance() external onlyOwner {\\n        _removeWethAllowance(vault);\\n    }\\n\\n    /// @dev Converts a given amount of WETH into AURA using the specified Balancer pool.\\n    /// @param amount The amount of WETH to be exchanged.\\n    /// @param auraOutMin The minimum amount of AURA expected in return.\\n    function _wethToAura(uint256 amount, uint256 auraOutMin) internal {\\n        IVault.SingleSwap memory params = IVault.SingleSwap({\\n            poolId: poolId,\\n            kind: 0, // exact input, output given\\n            assetIn: WETH,\\n            assetOut: AURA,\\n            amount: amount, // Amount to swap\\n            userData: \\\"\\\"\\n        });\\n\\n        IVault.FundManagement memory funds = IVault.FundManagement({\\n            sender: address(this), // Funds are taken from this contract\\n            recipient: address(this), // Swapped tokens are sent back to this contract\\n            fromInternalBalance: false, // Don't take funds from contract LPs (since there's none)\\n            toInternalBalance: false // Don't LP with swapped funds\\n        });\\n\\n        IVault(vault).swap(params, funds, auraOutMin, block.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ACurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport {Errors} from \\\"src/Errors.sol\\\";\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {ICurvePool} from \\\"curve/ICurvePool.sol\\\";\\nimport {EtherUtils} from \\\"src/EtherUtils.sol\\\";\\n\\n/// @title ACurve\\n/// @author centonze.eth\\n/// @notice Utility functions related to Curve operations.\\nabstract contract ACurve is EtherUtils {\\n    using SafeTransferLib for ERC20;\\n\\n    // Ethereum mainnet address of cvx.\\n    address internal constant CVX = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\\n\\n    // Ethereum mainnet address of the WETH-CVX Curve pool.\\n    address public wethCvxPool = 0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4;\\n\\n    /// @notice Emitted when the Curve pool address is updated.\\n    /// @param newPool The address of the new Curve pool.\\n    event SetCurvePool(address newPool);\\n\\n    /// @notice Sets a new address for the Curve pool.\\n    /// @param _wethCvxPool The address of the new Curve pool.\\n    function setCurvePool(address _wethCvxPool) external onlyOwner {\\n        if (_wethCvxPool == address(0)) revert Errors.ZeroAddress();\\n        wethCvxPool = _wethCvxPool;\\n\\n        emit SetCurvePool(_wethCvxPool);\\n    }\\n\\n    /// @notice Resets WETH allowance for the specified Curve pool.\\n    function resetCurveAllowance() external onlyOwner {\\n        _resetWethAllowance(wethCvxPool);\\n    }\\n\\n    /// @notice Removes WETH allowance for the specified Curve pool.\\n    function removeCurveAllowance() external onlyOwner {\\n        _removeWethAllowance(wethCvxPool);\\n    }\\n\\n    /// @dev Converts a given amount of WETH into CVX using the specified Curve pool.\\n    /// @param amount The amount of WETH to be exchanged.\\n    /// @param cvxOutMin The minimum amount of CVX expected in return.\\n    function _wethToCvx(uint256 amount, uint256 cvxOutMin) internal {\\n        ICurvePool(wethCvxPool).exchange(0, 1, amount, cvxOutMin);\\n    }\\n}\\n\"\r\n    },\r\n    \"int/warlord/IWarMinter.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\ninterface IWarMinter {\\n    event MintRatioUpdated(address oldMintRatio, address newMintRatio);\\n    event NewPendingOwner(address indexed previousPendingOwner, address indexed newPendingOwner);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function acceptOwnership() external;\\n    function lockers(address) external view returns (address);\\n    function mint(address vlToken, uint256 amount, address receiver) external;\\n    function mint(address vlToken, uint256 amount) external;\\n    function mintMultiple(address[] memory vlTokens, uint256[] memory amounts) external;\\n    function mintMultiple(address[] memory vlTokens, uint256[] memory amounts, address receiver) external;\\n    function owner() external view returns (address);\\n    function pendingOwner() external view returns (address);\\n    function ratios() external view returns (address);\\n    function renounceOwnership() external;\\n    function setLocker(address vlToken, address warLocker) external;\\n    function setRatios(address newRatios) external;\\n    function transferOwnership(address newOwner) external;\\n    function war() external view returns (address);\\n}\\n\\n\"\r\n    },\r\n    \"int/warlord/IWarStaker.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\ninterface IWarStaker {\\n    event AddedRewardDepositor(address indexed depositor);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event ClaimedRewards(address indexed reward, address indexed user, address indexed receiver, uint256 amount);\\n    event NewPendingOwner(address indexed previousPendingOwner, address indexed newPendingOwner);\\n    event NewRewards(address indexed rewardToken, uint256 amount, uint256 endTimestamp);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event Paused(address account);\\n    event RemovedRewardDepositor(address indexed depositor);\\n    event SetRewardFarmer(address indexed rewardToken, address indexed farmer);\\n    event SetUserAllowedClaimer(address indexed user, address indexed claimer);\\n    event Staked(address indexed caller, address indexed receiver, uint256 amount);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Unpaused(address account);\\n    event Unstaked(address indexed owner, address indexed receiver, uint256 amount);\\n\\n    struct UserClaimableRewards {\\n        address reward;\\n        uint256 claimableAmount;\\n    }\\n\\n    struct UserClaimedRewards {\\n        address reward;\\n        uint256 amount;\\n    }\\n\\n    struct UserRewardState {\\n        uint256 lastRewardPerToken;\\n        uint256 accruedRewards;\\n    }\\n\\n    function acceptOwnership() external;\\n    function addRewardDepositor(address depositor) external;\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function balanceOf(address account) external view returns (uint256);\\n    function claimAllRewards(address receiver) external returns (UserClaimedRewards[] memory);\\n    function claimRewards(address reward, address receiver) external returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n    function farmerLastIndex(address) external view returns (uint256);\\n    function getRewardTokens() external view returns (address[] memory);\\n    function getUserAccruedRewards(address reward, address user) external view returns (uint256);\\n    function getUserRewardState(address reward, address user) external view returns (UserRewardState memory);\\n    function getUserTotalClaimableRewards(address user) external view returns (UserClaimableRewards[] memory);\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n    function lastRewardUpdateTimestamp(address reward) external view returns (uint256);\\n    function name() external view returns (string memory);\\n    function owner() external view returns (address);\\n    function pause() external;\\n    function paused() external view returns (bool);\\n    function pendingOwner() external view returns (address);\\n    function queueRewards(address rewardToken, uint256 amount) external returns (bool);\\n    function removeRewardDepositor(address depositor) external;\\n    function renounceOwnership() external;\\n    function rewardDepositors(address) external view returns (bool);\\n    function rewardFarmers(address) external view returns (address);\\n    function rewardStates(address)\\n        external\\n        view\\n        returns (\\n            uint256 rewardPerToken,\\n            uint128 lastUpdate,\\n            uint128 distributionEndTimestamp,\\n            uint256 ratePerSecond,\\n            uint256 currentRewardAmount,\\n            uint256 queuedRewardAmount\\n        );\\n    function rewardTokens(uint256) external view returns (address);\\n    function setRewardFarmer(address rewardToken, address farmer) external;\\n    function stake(uint256 amount, address receiver) external returns (uint256);\\n    function symbol() external view returns (string memory);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n    function transferOwnership(address newOwner) external;\\n    function unpause() external;\\n    function unstake(uint256 amount, address receiver) external returns (uint256);\\n    function updateAllRewardStates() external;\\n    function updateRewardState(address reward) external;\\n    function warToken() external view returns (address);\\n}\\n\\n\"\r\n    },\r\n    \"int/WETH.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\ninterface WETH9 {\\n    event Approval(address indexed src, address indexed guy, uint256 wad);\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    function allowance(address, address) external view returns (uint256);\\n    function approve(address guy, uint256 wad) external returns (bool);\\n    function balanceOf(address) external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function deposit() external payable;\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n    function transferFrom(address src, address dst, uint256 wad) external returns (bool);\\n    function withdraw(uint256 wad) external;\\n}\\n\\n\"\r\n    },\r\n    \"int/uniswap/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.20;\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"src/EtherUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.20;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport {Ownable2Step} from \\\"oz/access/Ownable2Step.sol\\\";\\n\\n/// @title EtherUtils\\n/// @author centonze.eth\\n/// @dev Utility contract providing functions to manage WETH allowances.\\n/// Inherits from Ownable2Step to provide two-step ownership management.\\nabstract contract EtherUtils is Ownable2Step {\\n    using SafeTransferLib for ERC20;\\n\\n    // The WETH token address on Ethereum mainnet.\\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n    /// @dev Internal function to maximize the WETH allowance for a target address.\\n    /// @param target The address for which the WETH allowance will be set to max.\\n    function _resetWethAllowance(address target) internal {\\n        ERC20(WETH).safeApprove(target, type(uint256).max);\\n    }\\n\\n    /// @dev Internal function to remove the WETH allowance for a target address.\\n    /// @param target The address for which the WETH allowance will be removed.\\n    function _removeWethAllowance(address target) internal {\\n        ERC20(WETH).safeApprove(target, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"int/balancer/IVault.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\ninterface IVault {\\n    event AuthorizerChanged(address indexed newAuthorizer);\\n    event ExternalBalanceTransfer(address indexed token, address indexed sender, address recipient, uint256 amount);\\n    event FlashLoan(address indexed recipient, address indexed token, uint256 amount, uint256 feeAmount);\\n    event InternalBalanceChanged(address indexed user, address indexed token, int256 delta);\\n    event PausedStateChanged(bool paused);\\n    event PoolBalanceChanged(\\n        bytes32 indexed poolId,\\n        address indexed liquidityProvider,\\n        address[] tokens,\\n        int256[] deltas,\\n        uint256[] protocolFeeAmounts\\n    );\\n    event PoolBalanceManaged(\\n        bytes32 indexed poolId,\\n        address indexed assetManager,\\n        address indexed token,\\n        int256 cashDelta,\\n        int256 managedDelta\\n    );\\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, uint8 specialization);\\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\\n    event Swap(\\n        bytes32 indexed poolId, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut\\n    );\\n    event TokensDeregistered(bytes32 indexed poolId, address[] tokens);\\n    event TokensRegistered(bytes32 indexed poolId, address[] tokens, address[] assetManagers);\\n\\n    struct BatchSwapStep {\\n        bytes32 poolId;\\n        uint256 assetInIndex;\\n        uint256 assetOutIndex;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    struct ExitPoolRequest {\\n        address[] assets;\\n        uint256[] minAmountsOut;\\n        bytes userData;\\n        bool toInternalBalance;\\n    }\\n\\n    struct FundManagement {\\n        address sender;\\n        bool fromInternalBalance;\\n        address recipient;\\n        bool toInternalBalance;\\n    }\\n\\n    struct JoinPoolRequest {\\n        address[] assets;\\n        uint256[] maxAmountsIn;\\n        bytes userData;\\n        bool fromInternalBalance;\\n    }\\n\\n    struct PoolBalanceOp {\\n        uint8 kind;\\n        bytes32 poolId;\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    struct SingleSwap {\\n        bytes32 poolId;\\n        uint8 kind;\\n        address assetIn;\\n        address assetOut;\\n        uint256 amount;\\n        bytes userData;\\n    }\\n\\n    struct UserBalanceOp {\\n        uint8 kind;\\n        address asset;\\n        uint256 amount;\\n        address sender;\\n        address recipient;\\n    }\\n\\n    function WETH() external view returns (address);\\n    function batchSwap(\\n        uint8 kind,\\n        BatchSwapStep[] memory swaps,\\n        address[] memory assets,\\n        FundManagement memory funds,\\n        int256[] memory limits,\\n        uint256 deadline\\n    ) external payable returns (int256[] memory assetDeltas);\\n    function deregisterTokens(bytes32 poolId, address[] memory tokens) external;\\n    function exitPool(bytes32 poolId, address sender, address recipient, ExitPoolRequest memory request) external;\\n    function flashLoan(address recipient, address[] memory tokens, uint256[] memory amounts, bytes memory userData)\\n        external;\\n    function getActionId(bytes4 selector) external view returns (bytes32);\\n    function getAuthorizer() external view returns (address);\\n    function getDomainSeparator() external view returns (bytes32);\\n    function getInternalBalance(address user, address[] memory tokens)\\n        external\\n        view\\n        returns (uint256[] memory balances);\\n    function getNextNonce(address user) external view returns (uint256);\\n    function getPausedState()\\n        external\\n        view\\n        returns (bool paused, uint256 pauseWindowEndTime, uint256 bufferPeriodEndTime);\\n    function getPool(bytes32 poolId) external view returns (address, uint8);\\n    function getPoolTokenInfo(bytes32 poolId, address token)\\n        external\\n        view\\n        returns (uint256 cash, uint256 managed, uint256 lastChangeBlock, address assetManager);\\n    function getPoolTokens(bytes32 poolId)\\n        external\\n        view\\n        returns (address[] memory tokens, uint256[] memory balances, uint256 lastChangeBlock);\\n    function getProtocolFeesCollector() external view returns (address);\\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\\n    function joinPool(bytes32 poolId, address sender, address recipient, JoinPoolRequest memory request)\\n        external\\n        payable;\\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\\n    function queryBatchSwap(\\n        uint8 kind,\\n        BatchSwapStep[] memory swaps,\\n        address[] memory assets,\\n        FundManagement memory funds\\n    ) external returns (int256[] memory);\\n    function registerPool(uint8 specialization) external returns (bytes32);\\n    function registerTokens(bytes32 poolId, address[] memory tokens, address[] memory assetManagers) external;\\n    function setAuthorizer(address newAuthorizer) external;\\n    function setPaused(bool paused) external;\\n    function setRelayerApproval(address sender, address relayer, bool approved) external;\\n    function swap(SingleSwap memory singleSwap, FundManagement memory funds, uint256 limit, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256 amountCalculated);\\n}\\n\\n\"\r\n    },\r\n    \"int/curve/ICurvePool.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\ninterface ICurvePool {\\n    event AddLiquidity(address indexed provider, uint256[2] token_amounts, uint256 fee, uint256 token_supply);\\n    event ClaimAdminFee(address indexed admin, uint256 tokens);\\n    event CommitNewAdmin(uint256 indexed deadline, address indexed admin);\\n    event CommitNewParameters(\\n        uint256 indexed deadline,\\n        uint256 admin_fee,\\n        uint256 mid_fee,\\n        uint256 out_fee,\\n        uint256 fee_gamma,\\n        uint256 allowed_extra_profit,\\n        uint256 adjustment_step,\\n        uint256 ma_half_time\\n    );\\n    event NewAdmin(address indexed admin);\\n    event NewParameters(\\n        uint256 admin_fee,\\n        uint256 mid_fee,\\n        uint256 out_fee,\\n        uint256 fee_gamma,\\n        uint256 allowed_extra_profit,\\n        uint256 adjustment_step,\\n        uint256 ma_half_time\\n    );\\n    event RampAgamma(\\n        uint256 initial_A,\\n        uint256 future_A,\\n        uint256 initial_gamma,\\n        uint256 future_gamma,\\n        uint256 initial_time,\\n        uint256 future_time\\n    );\\n    event RemoveLiquidity(address indexed provider, uint256[2] token_amounts, uint256 token_supply);\\n    event RemoveLiquidityOne(address indexed provider, uint256 token_amount, uint256 coin_index, uint256 coin_amount);\\n    event StopRampA(uint256 current_A, uint256 current_gamma, uint256 time);\\n    event TokenExchange(\\n        address indexed buyer, uint256 sold_id, uint256 tokens_sold, uint256 bought_id, uint256 tokens_bought\\n    );\\n\\n    function A() external view returns (uint256);\\n    function D() external view returns (uint256);\\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external payable returns (uint256);\\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount, bool use_eth)\\n        external\\n        payable\\n        returns (uint256);\\n    function adjustment_step() external view returns (uint256);\\n    function admin_actions_deadline() external view returns (uint256);\\n    function admin_fee() external view returns (uint256);\\n    function admin_fee_receiver() external view returns (address);\\n    function allowed_extra_profit() external view returns (uint256);\\n    function apply_new_parameters() external;\\n    function apply_transfer_ownership() external;\\n    function balances(uint256 arg0) external view returns (uint256);\\n    function calc_token_amount(uint256[2] memory amounts) external view returns (uint256);\\n    function calc_withdraw_one_coin(uint256 token_amount, uint256 i) external view returns (uint256);\\n    function claim_admin_fees() external;\\n    function coins(uint256 i) external view returns (address);\\n    function commit_new_parameters(\\n        uint256 _new_mid_fee,\\n        uint256 _new_out_fee,\\n        uint256 _new_admin_fee,\\n        uint256 _new_fee_gamma,\\n        uint256 _new_allowed_extra_profit,\\n        uint256 _new_adjustment_step,\\n        uint256 _new_ma_half_time\\n    ) external;\\n    function commit_transfer_ownership(address _owner) external;\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable returns (uint256);\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth)\\n        external\\n        payable\\n        returns (uint256);\\n    function exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable returns (uint256);\\n    function fee() external view returns (uint256);\\n    function fee_gamma() external view returns (uint256);\\n    function future_A_gamma() external view returns (uint256);\\n    function future_A_gamma_time() external view returns (uint256);\\n    function future_adjustment_step() external view returns (uint256);\\n    function future_admin_fee() external view returns (uint256);\\n    function future_allowed_extra_profit() external view returns (uint256);\\n    function future_fee_gamma() external view returns (uint256);\\n    function future_ma_half_time() external view returns (uint256);\\n    function future_mid_fee() external view returns (uint256);\\n    function future_out_fee() external view returns (uint256);\\n    function future_owner() external view returns (address);\\n    function gamma() external view returns (uint256);\\n    function get_dy(uint256 i, uint256 j, uint256 dx) external view returns (uint256);\\n    function get_virtual_price() external view returns (uint256);\\n    function initial_A_gamma() external view returns (uint256);\\n    function initial_A_gamma_time() external view returns (uint256);\\n    function is_killed() external view returns (bool);\\n    function kill_deadline() external view returns (uint256);\\n    function kill_me() external;\\n    function last_prices() external view returns (uint256);\\n    function last_prices_timestamp() external view returns (uint256);\\n    function lp_price() external view returns (uint256);\\n    function ma_half_time() external view returns (uint256);\\n    function mid_fee() external view returns (uint256);\\n    function out_fee() external view returns (uint256);\\n    function owner() external view returns (address);\\n    function price_oracle() external view returns (uint256);\\n    function price_scale() external view returns (uint256);\\n    function ramp_A_gamma(uint256 future_A, uint256 future_gamma, uint256 future_time) external;\\n    function remove_liquidity(uint256 _amount, uint256[2] memory min_amounts) external;\\n    function remove_liquidity(uint256 _amount, uint256[2] memory min_amounts, bool use_eth) external;\\n    function remove_liquidity_one_coin(uint256 token_amount, uint256 i, uint256 min_amount)\\n        external\\n        returns (uint256);\\n    function remove_liquidity_one_coin(uint256 token_amount, uint256 i, uint256 min_amount, bool use_eth)\\n        external\\n        returns (uint256);\\n    function revert_new_parameters() external;\\n    function revert_transfer_ownership() external;\\n    function set_admin_fee_receiver(address _admin_fee_receiver) external;\\n    function stop_ramp_A_gamma() external;\\n    function token() external view returns (address);\\n    function transfer_ownership_deadline() external view returns (uint256);\\n    function unkill_me() external;\\n    function virtual_price() external view returns (uint256);\\n    function xcp_profit() external view returns (uint256);\\n    function xcp_profit_a() external view returns (uint256);\\n}\\n\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"surl/=lib/surl/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"oz/=lib/openzeppelin-contracts/contracts/\",\r\n      \"warlord/=int/warlord/\",\r\n      \"uniswap/=int/uniswap/\",\r\n      \"curve/=int/curve/\",\r\n      \"balancer/=int/balancer/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solidity-stringutils/=lib/surl/lib/solidity-stringutils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InvalidRatio\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAlreadyAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newPoolId\",\"type\":\"bytes32\"}],\"name\":\"SetBalancerPoolId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"}],\"name\":\"SetBalancerVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPool\",\"type\":\"address\"}],\"name\":\"SetCurvePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"SetUniswapFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"SetUniswapRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"SetWarMinter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStaker\",\"type\":\"address\"}],\"name\":\"SetWarStaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"TokenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"Zapped\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WAR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"disableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"enableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeBalancerAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeCurveAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeWarlordAllowances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetBalancerAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetCurveAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetWarlordAllowances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_poolId\",\"type\":\"bytes32\"}],\"name\":\"setBalancerPoolId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"}],\"name\":\"setBalancerVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wethCvxPool\",\"type\":\"address\"}],\"name\":\"setCurvePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"}],\"name\":\"setUniswapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"}],\"name\":\"setUniswapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_warMinter\",\"type\":\"address\"}],\"name\":\"setWarMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_warStaker\",\"type\":\"address\"}],\"name\":\"setWarStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uniswapFees\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"warMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"warStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethCvxPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEthOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAuraOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCvxOut\",\"type\":\"uint256\"}],\"name\":\"zapERC20ToMultipleTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useCvx\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minEthOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minVlTokenOut\",\"type\":\"uint256\"}],\"name\":\"zapERC20ToSingleToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAuraOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCvxOut\",\"type\":\"uint256\"}],\"name\":\"zapEtherToMultipleTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"useCvx\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minVlTokenOut\",\"type\":\"uint256\"}],\"name\":\"zapEtherToSingleToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Zapper", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}