{"SourceCode": "// File: access/HasAdmin.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\ncontract HasAdmin {\r\n  event AdminChanged(address indexed _oldAdmin, address indexed _newAdmin);\r\n  event AdminRemoved(address indexed _oldAdmin);\r\n\r\n  address public admin;\r\n\r\n  modifier onlyAdmin {\r\n    require(msg.sender == admin, \"HasAdmin: not admin\");\r\n    _;\r\n  }\r\n\r\n  constructor() internal {\r\n    admin = msg.sender;\r\n    emit AdminChanged(address(0), admin);\r\n  }\r\n\r\n  function changeAdmin(address _newAdmin) external onlyAdmin {\r\n    require(_newAdmin != address(0), \"HasAdmin: new admin is the zero address\");\r\n    emit AdminChanged(admin, _newAdmin);\r\n    admin = _newAdmin;\r\n  }\r\n\r\n  function removeAdmin() external onlyAdmin {\r\n    emit AdminRemoved(admin);\r\n    admin = address(0);\r\n  }\r\n}\r\n\r\n// File: math/SafeMath.sol\r\n\r\npragma solidity ^0.5.17;\r\n\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    return a - b;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Since Solidity automatically asserts when dividing by 0,\r\n    // but we only need it to revert.\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    return a / b;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Same reason as `div`.\r\n    require(b > 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: token/erc20/IERC20.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\ninterface IERC20 {\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  function totalSupply() external view returns (uint256 _supply);\r\n  function balanceOf(address _owner) external view returns (uint256 _balance);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool _success);\r\n  function allowance(address _owner, address _spender) external view returns (uint256 _value);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool _success);\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool _success);\r\n}\r\n\r\n// File: token/erc20/TokenVesting.sol\r\n\r\npragma solidity 0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenVesting is HasAdmin {\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n    * @dev a Chunk is a period of time in which the beneficiary can receive the same amount of token each time a followUpDuration passes,\r\n    * starting from effectiveDate (in relative to startTime).\r\n   */\r\n  struct Chunk {\r\n    uint32 effectiveDate; // Duration from startTime that the chunk becomes effective\r\n    uint256 amountPerUnlock;\r\n    uint32 followUps;\r\n    uint32 followUpDuration;\r\n  }\r\n\r\n  struct BeneficiaryInfo {\r\n    uint32 index; // Location of beneficiary in beneficiaryAddresses.\r\n    Chunk[] chunks;\r\n    uint256 claimedAmount;\r\n  }\r\n\r\n  event StartTimeSet(uint256 _startTime);\r\n  event BeneficiaryAdded(address indexed _beneficiary, uint32 _index);\r\n  event BeneficiaryRemoved(address indexed _beneficiary);\r\n  event TokenClaimed(address indexed _beneficiary, uint256 _amount);\r\n\r\n  IERC20 public token;\r\n  uint256 public startTime;\r\n  mapping(address => BeneficiaryInfo) public beneficiaries;\r\n\r\n  address[] public beneficiaryAddresses;\r\n\r\n  constructor(IERC20 _token, uint256 _startTime) public {\r\n    token = _token;\r\n    editStartTime(_startTime);\r\n    // Add a dummy address so all beneficiary index will be positive.\r\n    beneficiaryAddresses.push(address(0));\r\n  }\r\n\r\n  function editStartTime(uint256 _newTime) public onlyAdmin {\r\n    startTime = _newTime;\r\n    emit StartTimeSet(startTime);\r\n  }\r\n\r\n  /**\r\n   * @dev Function for admin to add another beneficiary, initiate with chunks.\r\n  */\r\n  function addBeneficiary(address _beneficiary, Chunk[] calldata _chunks) external onlyAdmin {\r\n    require(beneficiaries[_beneficiary].index == 0, \"TokenVesting: Beneficiary already existed\");\r\n\r\n    uint32 _index = uint32(beneficiaryAddresses.length);\r\n    beneficiaries[_beneficiary].index = _index;\r\n    addChunks(_beneficiary, _chunks);\r\n    beneficiaryAddresses.push(_beneficiary);\r\n\r\n    emit BeneficiaryAdded(_beneficiary, _index);\r\n  }\r\n\r\n  /**\r\n   * @dev Function for admin to add more chunks for a specific beneficiary.\r\n  */\r\n  function addChunks(address _beneficiary, Chunk[] memory _chunks) public onlyAdmin {\r\n    require(beneficiaries[_beneficiary].index > 0, \"TokenVesting: Beneficiary not existed\");\r\n\r\n    Chunk[] storage _beneficiaryChunks = beneficiaries[_beneficiary].chunks;\r\n\r\n    for (uint256 _i = 0; _i < _chunks.length; _i++) {\r\n        _beneficiaryChunks.push(_chunks[_i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Remove beneficiary, only used in rare cases that need some modifications.\r\n  */\r\n  function removeBeneficiary(address _beneficiary) external onlyAdmin {\r\n    require(beneficiaries[_beneficiary].index > 0, \"TokenVesting: Beneficiary not existed\");\r\n\r\n    uint32 _currentIndex = beneficiaries[_beneficiary].index;\r\n    uint256 _lastIndex = beneficiaryAddresses.length.sub(1);\r\n\r\n    // Replace by last item in array\r\n    beneficiaryAddresses[_currentIndex] = beneficiaryAddresses[_lastIndex];\r\n    beneficiaries[beneficiaryAddresses[_currentIndex]].index = _currentIndex;\r\n\r\n    beneficiaryAddresses.pop();\r\n    delete beneficiaries[_beneficiary];\r\n\r\n    emit BeneficiaryRemoved(_beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @dev Remove beneficiary, only used in rare cases that need some modifications.\r\n  */\r\n  function getBeneficiaryList() external view returns (address[] memory) {\r\n    return beneficiaryAddresses;\r\n  }\r\n\r\n  /**\r\n   * @dev Query chunks of a beneficiary.\r\n  */\r\n  function beneficiaryChunks(address _beneficiary) external view returns (Chunk[] memory _chunks) {\r\n    _chunks = beneficiaries[_beneficiary].chunks;\r\n  }\r\n\r\n  /**\r\n   * @dev Query total allocated token, both unlocked and locked.\r\n  */\r\n  function totalAllocatedAmount(address _beneficiary) external view returns (uint256 _amount) {\r\n    Chunk[] storage _chunks = beneficiaries[_beneficiary].chunks;\r\n\r\n    for (uint256 _i = 0; _i < _chunks.length; _i++) {\r\n      Chunk storage _chunk = _chunks[_i];\r\n      _amount = _amount.add(_chunk.amountPerUnlock.mul(uint256(1).add(_chunk.followUps)));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Query unlocked amount at the current time.\r\n   * @return total unlocked amount so far and claimable amount.\r\n  */\r\n  function unlockedAmount(address _beneficiary) public view returns (uint256 _totalUnlocked, uint256 _claimable) {\r\n    _totalUnlocked = unlockedAt(_beneficiary, block.timestamp);\r\n\r\n    uint256 _claimedAmount = beneficiaries[_beneficiary].claimedAmount;\r\n    _claimable = _totalUnlocked.sub(_claimedAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Query unlocked amount at the specific timestamp.\r\n   * @return total unlocked amount at that timestamp\r\n  */\r\n  function unlockedAt(address _beneficiary, uint256 _timestamp) public view returns (uint256 _totalUnlocked) {\r\n    Chunk[] storage _chunks = beneficiaries[_beneficiary].chunks;\r\n\r\n    for (uint256 _i = 0; _i < _chunks.length; _i++) {\r\n      Chunk storage _chunk = _chunks[_i];\r\n\r\n      if (startTime.add(_chunk.effectiveDate) <= _timestamp) {\r\n        // Calculate how many follow-ups have occured\r\n        uint256 followUps = 0;\r\n\r\n        if (_chunk.followUpDuration > 0) {\r\n          followUps = _timestamp.sub(startTime.add(_chunks[_i].effectiveDate)).div(_chunk.followUpDuration);\r\n        }\r\n\r\n        if (followUps > _chunk.followUps) {\r\n          followUps = _chunk.followUps;\r\n        }\r\n\r\n        // There are (followUps + 1) unlocks have happened\r\n        _totalUnlocked = _totalUnlocked.add(_chunk.amountPerUnlock.mul(followUps.add(1)));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Allows beneficiary to claim claimable tokens, can be called by anyone.\r\n  */\r\n  function claimToken(address _beneficiary) external {\r\n    (uint256 _totalUnlocked, uint256 _claimable) = unlockedAmount(_beneficiary);\r\n    require(_claimable > 0, \"TokenVesting: No claimable amount\");\r\n\r\n    beneficiaries[_beneficiary].claimedAmount = _totalUnlocked;\r\n    token.transfer(_beneficiary, _claimable);\r\n\r\n    emit TokenClaimed(_beneficiary, _claimable);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_index\",\"type\":\"uint32\"}],\"name\":\"BeneficiaryAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"StartTimeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenClaimed\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"effectiveDate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amountPerUnlock\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"followUps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"followUpDuration\",\"type\":\"uint32\"}],\"internalType\":\"struct TokenVesting.Chunk[]\",\"name\":\"_chunks\",\"type\":\"tuple[]\"}],\"name\":\"addBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"effectiveDate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amountPerUnlock\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"followUps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"followUpDuration\",\"type\":\"uint32\"}],\"internalType\":\"struct TokenVesting.Chunk[]\",\"name\":\"_chunks\",\"type\":\"tuple[]\"}],\"name\":\"addChunks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaries\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"beneficiaryAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"beneficiaryChunks\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"effectiveDate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amountPerUnlock\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"followUps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"followUpDuration\",\"type\":\"uint32\"}],\"internalType\":\"struct TokenVesting.Chunk[]\",\"name\":\"_chunks\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTime\",\"type\":\"uint256\"}],\"name\":\"editStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBeneficiaryList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removeBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"totalAllocatedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"unlockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalUnlocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"unlockedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalUnlocked\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenVesting", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f5d669627376ebd411e34b98f19c868c8aba5ada000000000000000000000000000000000000000000000000000000005fa2a24c", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b4ededf6c04874c52066f91648009f9c7b54beb8519ae4be65360f6a81732519"}