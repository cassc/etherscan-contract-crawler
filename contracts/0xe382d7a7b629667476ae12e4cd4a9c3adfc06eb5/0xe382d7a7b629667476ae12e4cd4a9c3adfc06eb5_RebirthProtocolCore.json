{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.20;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ninterface IAccessControl {\r\n\r\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\r\n    error AccessControlBadConfirmation();\r\n\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    function renounceRole(bytes32 role, address callerConfirmation) external;\r\n}\r\n\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n\r\n    struct RoleData {\r\n        mapping(address account => bool) hasRole;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n\r\n    mapping(bytes32 role => RoleData) private _roles;\r\n    bytes32 public constant SUPERADMIN = 0x00;\r\n\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role);\r\n        _;\r\n    }\r\n\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\r\n        return _roles[role].hasRole[account];\r\n    }\r\n\r\n    function _checkRole(bytes32 role) internal view virtual {\r\n        _checkRole(role, _msgSender());\r\n    }\r\n\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert AccessControlUnauthorizedAccount(account, role);\r\n        }\r\n    }\r\n\r\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\r\n        if (callerConfirmation != _msgSender()) {\r\n            revert AccessControlBadConfirmation();\r\n        }\r\n\r\n        _revokeRole(role, callerConfirmation);\r\n    }\r\n\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].hasRole[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].hasRole[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract RebirthProtocolCore is AccessControl {\r\n    //Variable Declarations\r\n    address public RBH_SuperAdmin;\r\n    ERC20 public RBH;\r\n    IUniswapV2Factory UniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\r\n    IUniswapV2Router02 UniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    address public Liquidator;\r\n    address public FreemintContract;\r\n    uint256[] public OpenPools;\r\n    uint256[] public ClosedPools;\r\n    uint256 public TotalUsers;\r\n    uint256 public TotalEtherDepositedEquivalents;\r\n    uint256 internal PoolIncrement;\r\n\r\n    bytes32 public constant ADMIN = keccak256(\"ADMIN\");\r\n    bytes32 public constant LIQUIDATOR = keccak256(\"LIQUIDATOR\");\r\n\r\n    //Struct-Enum Declarations\r\n\r\n    enum AlternativePayoutOption { RBHTokens, NFTFreemints, RelaunchShares }\r\n\r\n    struct RebirthPool{\r\n        string Name;\r\n        string Symbol;\r\n        address TokenAddress;\r\n        address RebirthedTokenAddress;\r\n        address PairAddress;\r\n        uint256 PoolOpeningTime;\r\n        uint256 PoolClosingTime;\r\n        uint256 SoftCap;\r\n        uint256 MemecoinsPerRelaunchShare;\r\n        uint256 TotalTokensDeposited;\r\n        bool PoolSuccessful;\r\n        bool PoolClosed;\r\n    }\r\n\r\n    struct UserPoolDetails{\r\n        uint256 AmountDeposited;\r\n        AlternativePayoutOption AlternatePayoutChoice;\r\n        bool PreviouslyDeposited;\r\n        bool Claimed;\r\n    }\r\n\r\n    //Mapping Declarations\r\n    mapping(uint256 => RebirthPool) public Pools;\r\n    mapping(uint256 => mapping(address => UserPoolDetails)) public PoolDeposits;\r\n    mapping(address => uint256[]) public YourPools;\r\n    mapping(uint256 => uint256) internal OpenPoolsIndexer;\r\n    mapping(address => bool) public UserParticipated;\r\n    mapping(address => uint256) public RelaunchShares;\r\n    mapping(address => uint256) public NFT_Freemints;\r\n\r\n    //Event Declarations\r\n\r\n    //Constructor\r\n    constructor(address _RBH) {\r\n        RBH_SuperAdmin = msg.sender;\r\n        _grantRole(SUPERADMIN, msg.sender);\r\n        _grantRole(ADMIN, msg.sender);\r\n        RBH = ERC20(_RBH);\r\n        Liquidator = address(0);\r\n        _grantRole(LIQUIDATOR, address(0));\r\n    }\r\n\r\n    //Public Functions\r\n\r\n    function DepositTokens(uint256 PoolID, uint256 Amount, AlternativePayoutOption AlternatePayoutChoice) public {\r\n        require(block.timestamp >= Pools[PoolID].PoolOpeningTime && block.timestamp <= Pools[PoolID].PoolClosingTime, \"Pool is not open\");\r\n        require(ERC20(Pools[PoolID].TokenAddress).transferFrom(msg.sender, address(this), Amount), \"Transfer failed\");\r\n\r\n        if(!UserParticipated[msg.sender]){ TotalUsers++; UserParticipated[msg.sender] = true; }\r\n\r\n        if(!PoolDeposits[PoolID][msg.sender].PreviouslyDeposited){\r\n            require(Amount >= 1000); //Requires first time depositors to deposit some amount of token\r\n            YourPools[msg.sender].push(PoolID);\r\n        }\r\n\r\n        PoolDeposits[PoolID][msg.sender].AmountDeposited += Amount;\r\n        PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice = AlternatePayoutChoice;\r\n        PoolDeposits[PoolID][msg.sender].PreviouslyDeposited = true;\r\n        Pools[PoolID].TotalTokensDeposited += Amount;\r\n    }\r\n\r\n    function DepositRelaunchShares(uint256 PoolID, uint256 Amount, AlternativePayoutOption AlternatePayoutChoice) public {\r\n        require(block.timestamp >= Pools[PoolID].PoolOpeningTime && block.timestamp <= Pools[PoolID].PoolClosingTime, \"Pool is not open\");\r\n        require(Amount > 0, \"Cannot deposit zero relaunch shares\");\r\n        require(RelaunchShares[msg.sender] >= Amount, \"Not enough relaunch shares\");\r\n\r\n        if(!UserParticipated[msg.sender]){ TotalUsers++; UserParticipated[msg.sender] = true; }\r\n\r\n        if(!PoolDeposits[PoolID][msg.sender].PreviouslyDeposited){\r\n            YourPools[msg.sender].push(PoolID);\r\n        }\r\n\r\n        RelaunchShares[msg.sender] -= Amount;\r\n\r\n        address[] memory Path = new address[](2);\r\n        Path[0] = UniswapRouter.WETH();\r\n        Path[1] = Pools[PoolID].TokenAddress;\r\n\r\n        uint256 MemecoinsPerRelaunchShare = UniswapRouter.getAmountsOut(0.001 ether, Path)[1];\r\n        uint256 DepositEquivalent = MemecoinsPerRelaunchShare * Amount;\r\n\r\n        PoolDeposits[PoolID][msg.sender].AmountDeposited += DepositEquivalent;\r\n        PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice = AlternatePayoutChoice;\r\n        PoolDeposits[PoolID][msg.sender].PreviouslyDeposited = true;\r\n        Pools[PoolID].TotalTokensDeposited += DepositEquivalent;\r\n    }\r\n\r\n    function ClaimPool(uint256 PoolID) public {\r\n        require(Pools[PoolID].PoolClosed, \"Pool is still open\");\r\n        require(!PoolDeposits[PoolID][msg.sender].Claimed, \"Already claimed\");\r\n        require(PoolDeposits[PoolID][msg.sender].AmountDeposited > 0, \"No tokens deposited\");\r\n\r\n        if(Pools[PoolID].PoolSuccessful){\r\n            //Send the new contract tokens to the user\r\n            ERC20 NewMemecoin = ERC20(Pools[PoolID].RebirthedTokenAddress);\r\n            NewMemecoin.transfer(msg.sender, PoolDeposits[PoolID][msg.sender].AmountDeposited);\r\n        }\r\n        else{\r\n            //execute alternative payout option, nft freemints cost 10x relaunch shares\r\n            uint256 UserRelaunchSharesEquivalent = PoolDeposits[PoolID][msg.sender].AmountDeposited / Pools[PoolID].MemecoinsPerRelaunchShare;\r\n            if(PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice == AlternativePayoutOption.RBHTokens){\r\n                //Send RBH tokens to the user\r\n                address[] memory Path = new address[](2);\r\n                Path[0] = UniswapRouter.WETH();\r\n                Path[1] = address(RBH);\r\n\r\n                uint256 RBHpayout = (UniswapRouter.getAmountsOut(0.001 ether * UserRelaunchSharesEquivalent,Path)[1] * 110) / 100;\r\n                RBH.transfer(msg.sender, RBHpayout);\r\n            }\r\n            else if(PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice == AlternativePayoutOption.NFTFreemints){\r\n                NFT_Freemints[msg.sender] += UserRelaunchSharesEquivalent / 10; //Watch out, could be 0 if memecoins are worth less than 0.01 Ether\r\n            }\r\n            else if(PoolDeposits[PoolID][msg.sender].AlternatePayoutChoice == AlternativePayoutOption.RelaunchShares){\r\n                RelaunchShares[msg.sender] += UserRelaunchSharesEquivalent;\r\n            }\r\n        }\r\n\r\n        PoolDeposits[PoolID][msg.sender].Claimed = true;\r\n    }\r\n\r\n    //OnlyOwner Functions\r\n    function CreatePool(address TokenAddress, address PairAddress, uint256 HoursTillOpen, uint256 LenghtInHours, uint256 SoftCap, string memory TokenName, string memory TokenSymbol) public onlyRole(ADMIN) {\r\n        uint256 PoolID = PoolIncrement;\r\n        PoolIncrement++;\r\n        uint256 StartTime = (block.timestamp + (HoursTillOpen * 3600));\r\n        uint256 EndTime = StartTime + (LenghtInHours * 3600);\r\n        Pools[PoolID] = RebirthPool(TokenName, TokenSymbol, TokenAddress, address(0), PairAddress, StartTime, EndTime, SoftCap, 0, 0, false, false);\r\n\r\n        address[] memory Path = new address[](2);\r\n        Path[0] = UniswapRouter.WETH();\r\n        Path[1] = Pools[PoolID].TokenAddress;\r\n\r\n        uint256 MemecoinsPerRelaunchShare = UniswapRouter.getAmountsOut(0.001 ether, Path)[1];\r\n        Pools[PoolID].MemecoinsPerRelaunchShare = MemecoinsPerRelaunchShare;\r\n\r\n        AddRemoveActivePool(PoolID, true);\r\n    }\r\n\r\n    function ClosePool(uint256 PoolID) public onlyRole(ADMIN) {\r\n        require(block.timestamp >= Pools[PoolID].PoolClosingTime, \"Pool is still open\");\r\n        require(Pools[PoolID].PoolClosed == false, \"Pool is already closed\");\r\n        AddRemoveActivePool(PoolID, false);\r\n\r\n        if (Pools[PoolID].TotalTokensDeposited < Pools[PoolID].SoftCap){\r\n            Pools[PoolID].PoolSuccessful = false;\r\n            ERC20 Token = ERC20(Pools[PoolID].TokenAddress);\r\n            Token.transfer(RBH_SuperAdmin, Token.balanceOf(address(this)));\r\n\r\n            address[] memory Path = new address[](2);\r\n            Path[0] = Pools[PoolID].TokenAddress;\r\n            Path[1] = UniswapRouter.WETH();\r\n\r\n            uint256 EtherEquivalent = UniswapRouter.getAmountsOut(Pools[PoolID].TotalTokensDeposited, Path)[1];\r\n            unchecked{\r\n                TotalEtherDepositedEquivalents += EtherEquivalent;\r\n            }\r\n        }\r\n        else{\r\n            Pools[PoolID].PoolSuccessful = true;\r\n\r\n            ERC20 Token = ERC20(Pools[PoolID].TokenAddress);\r\n            Token.approve(address(UniswapRouter), Token.balanceOf(address(this)));\r\n\r\n            address[] memory Path = new address[](2);\r\n            Path[0] = Pools[PoolID].TokenAddress;\r\n            Path[1] = UniswapRouter.WETH();\r\n\r\n            UniswapRouter.swapExactTokensForETH(Token.balanceOf(address(this)), 0, Path, address(this), block.timestamp + 300);\r\n\r\n            //Buy back RBH with wrapped eth\r\n            Path[0] = UniswapRouter.WETH();\r\n            Path[1] = address(RBH);\r\n\r\n            uint256 RBH_TradeAmount = UniswapRouter.getAmountsOut(address(this).balance, Path)[1];\r\n\r\n            unchecked{\r\n                TotalEtherDepositedEquivalents += address(this).balance;\r\n            }\r\n\r\n            payable(RBH_SuperAdmin).transfer(address(this).balance);\r\n\r\n            //Create new ERC20 token with the name and symbol of the old memecoin\r\n            uint256 BalanceToLiquidity = Pools[PoolID].TotalTokensDeposited;\r\n            RebirthedToken NewToken = new RebirthedToken(((Pools[PoolID].TotalTokensDeposited * 210) / 100), Pools[PoolID].Name, Pools[PoolID].Symbol);\r\n            Pools[PoolID].RebirthedTokenAddress = address(NewToken);\r\n            NewToken.transfer(RBH_SuperAdmin, (BalanceToLiquidity / 10));\r\n\r\n            //Create new RBH/Memecoin pair on uniswap, send the liquidity tokens to the zero address\r\n            IUniswapV2Pair NewTokenPair = IUniswapV2Pair(UniswapFactory.createPair(address(RBH), address(NewToken)));\r\n            NewToken.approve(address(UniswapRouter), BalanceToLiquidity);\r\n            RBH.approve(address(UniswapRouter), RBH_TradeAmount);\r\n            UniswapRouter.addLiquidity(address(RBH), address(NewToken), RBH_TradeAmount, BalanceToLiquidity, 0, 0, address(this), (block.timestamp + 300));\r\n            ERC20(address(NewTokenPair)).transfer(address(0), ERC20(address(NewTokenPair)).balanceOf(address(this)));\r\n        }\r\n\r\n        Pools[PoolID].PoolClosed = true;\r\n        ClosedPools.push(PoolID);\r\n    }\r\n\r\n    function setSuperAdmin(address _newAdmin) public onlyRole(SUPERADMIN){\r\n        grantRole(SUPERADMIN, _newAdmin);\r\n        revokeRole(SUPERADMIN, msg.sender);\r\n        RBH_SuperAdmin = _newAdmin;\r\n    }\r\n\r\n    function AddRemoveAdmin(address _newAdmin, bool AddRemove) public onlyRole(SUPERADMIN){\r\n        if (AddRemove) {\r\n            grantRole(ADMIN, _newAdmin);\r\n        } else {\r\n            revokeRole(ADMIN, _newAdmin);\r\n        }\r\n    }\r\n\r\n    function SetFreemintContract(address _FreemintContract) public onlyRole(SUPERADMIN){\r\n        FreemintContract = _FreemintContract;\r\n    }\r\n\r\n    function SetLiquidator(address _Liquidator) public onlyRole(SUPERADMIN){        \r\n        revokeRole(LIQUIDATOR, Liquidator);\r\n        grantRole(LIQUIDATOR, _Liquidator);\r\n        Liquidator = _Liquidator;\r\n        RBH.approve(Liquidator, 2**256 - 1);\r\n    }\r\n\r\n    function WithdrawRBH() public onlyRole(SUPERADMIN){\r\n        RBH.transfer(RBH_SuperAdmin, RBH.balanceOf(address(this)));\r\n    }\r\n\r\n    //Only liquidator functions\r\n\r\n    function AddFreemint(address User, uint256 Amount) public onlyRole(LIQUIDATOR){\r\n        NFT_Freemints[User] += Amount;\r\n    }\r\n\r\n    function AddRelaunchShare(address User, uint256 Amount) public onlyRole(LIQUIDATOR){\r\n        RelaunchShares[User] += Amount;\r\n    }\r\n\r\n    function AddUserToCountAndParticipated(address User) public onlyRole(LIQUIDATOR){\r\n        if(!UserParticipated[User]){ TotalUsers++; UserParticipated[User] = true; }\r\n    }\r\n\r\n    //Only freemint contract\r\n    function Freeminted(address User, uint256 Amount) external {\r\n        require(msg.sender == FreemintContract, \"Only freemint contract can call this function\");\r\n        require(NFT_Freemints[User] > 0 && NFT_Freemints[User] >= Amount, \"User has no freemints or requested amount is too high\");\r\n\r\n        NFT_Freemints[User] -= Amount;\r\n    } \r\n\r\n    //Internal Functions\r\n    function AddRemoveActivePool(uint256 PoolID, bool AddRemove) internal {\r\n        if(AddRemove){\r\n            OpenPools.push(PoolID);\r\n            OpenPoolsIndexer[PoolID] = OpenPools.length - 1;\r\n        }\r\n        else{\r\n            OpenPools[OpenPoolsIndexer[PoolID]] = OpenPools[OpenPools.length - 1];\r\n            OpenPools.pop();\r\n        }\r\n    }\r\n\r\n    //View Functions\r\n    function GetOpenPools() public view returns (uint256[] memory){\r\n        return OpenPools;\r\n    }\r\n\r\n    function GetClosedPools() public view returns (uint256[] memory){\r\n        return ClosedPools;\r\n    }\r\n\r\n    function GetPoolDetails(uint256 PoolID) public view returns (RebirthPool memory){\r\n        return Pools[PoolID];\r\n    }\r\n\r\n    function GetUserPoolDetails(uint256 PoolID, address User) public view returns (UserPoolDetails memory){\r\n        return PoolDeposits[PoolID][User];\r\n    }\r\n\r\n    function GetUserPools(address User) public view returns (uint256[] memory){\r\n        return YourPools[User];\r\n    }\r\n\r\n    //Receive function\r\n    receive() external payable {\r\n    }\r\n}\r\n\r\n//This next contract needs to be able to accept any memecoin with any ethereum liquidity on uniswap, sell the ether, send to the rebirthcore superadmin address, then allow the user to claim once again one of the 3 available options\r\ncontract RebirthLiquidator {\r\n    address public RBH_SuperAdmin;\r\n    address public RebirthCoreAddress;\r\n    IUniswapV2Router02 public uniswapRouter; \r\n    ERC20 public RBH;\r\n    uint256 public TotalEtherLiquidated;\r\n\r\n    mapping(address => mapping(address => UserRBHLiquidation)) public UserRBHLiquidations;\r\n    mapping(address => address[]) public AllUserLiquidations;\r\n\r\n    struct UserRBHLiquidation{\r\n        uint256 RBHPayout;\r\n        uint256 ClaimTime;\r\n    }\r\n\r\n    enum AlternativePayoutOption { RBHTokens, NFTFreemints, RelaunchShares }\r\n\r\n    constructor(address rebirthCoreAddress, address _RBH) {\r\n        RebirthCoreAddress = rebirthCoreAddress;\r\n        RBH_SuperAdmin = RebirthProtocolCore(payable(rebirthCoreAddress)).RBH_SuperAdmin();\r\n        uniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        RBH = ERC20(_RBH);\r\n    }\r\n\r\n    // Function to liquidate memecoins, and allow users to select which of the three options they want to claim\r\n    function Liquidate(address memecoinAddress, uint256 amount, AlternativePayoutOption PayoutChoice) external {\r\n        require(ERC20(uniswapRouter.WETH()).balanceOf(IUniswapV2Factory(uniswapRouter.factory()).getPair(memecoinAddress, uniswapRouter.WETH())) > 0, \"Pair doesn't exist or has no liquidity\");\r\n        require(ERC20(memecoinAddress).transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\r\n        require(UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime == 0, \"Await or claim existing liquidation on this token\");\r\n\r\n        RebirthProtocolCore(payable(RebirthCoreAddress)).AddUserToCountAndParticipated(msg.sender);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = memecoinAddress;\r\n        path[1] = uniswapRouter.WETH();\r\n\r\n        ERC20(memecoinAddress).approve(address(uniswapRouter), amount);\r\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(amount,0, path, address(this), block.timestamp + 300);\r\n        uint256 wETHIn = address(this).balance;\r\n        unchecked{\r\n            TotalEtherLiquidated += wETHIn;\r\n        }\r\n        payable(RBH_SuperAdmin).transfer(address(this).balance);\r\n\r\n        if(PayoutChoice == AlternativePayoutOption.RBHTokens){\r\n            path[0] = uniswapRouter.WETH();\r\n            path[1] = address(RBH);\r\n\r\n            uint256 RBH_TradeAmount = uniswapRouter.getAmountsOut(wETHIn, path)[1];\r\n            UserRBHLiquidations[msg.sender][memecoinAddress].RBHPayout = (RBH_TradeAmount * 110) / 100;\r\n            UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime = block.timestamp + 604800; \r\n            AllUserLiquidations[msg.sender].push(memecoinAddress);\r\n\r\n        }\r\n        else if(PayoutChoice == AlternativePayoutOption.NFTFreemints){\r\n            RebirthProtocolCore(payable(RebirthCoreAddress)).AddFreemint(msg.sender, wETHIn / 10000000000000000);\r\n        }\r\n        else if(PayoutChoice == AlternativePayoutOption.RelaunchShares){\r\n            RebirthProtocolCore(payable(RebirthCoreAddress)).AddRelaunchShare(msg.sender, wETHIn / 1000000000000000);\r\n        }\r\n    }\r\n\r\n    //Function to claim RBH tokens from a liquidation\r\n    function ClaimRBH(address memecoinAddress) external {\r\n        require(UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime != 0, \"No liquidation to claim\");\r\n        require(UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime <= block.timestamp, \"Await liquidation to be claimable\");\r\n\r\n        //transferfrom rbh from rebirthcore \r\n        RBH.transfer(msg.sender, UserRBHLiquidations[msg.sender][memecoinAddress].RBHPayout);\r\n        UserRBHLiquidations[msg.sender][memecoinAddress].RBHPayout = 0;\r\n        UserRBHLiquidations[msg.sender][memecoinAddress].ClaimTime = 0;\r\n    }\r\n\r\n    //create view functions to get all liquidations for a user, and to get the details of a specific liquidation\r\n    function GetUserLiquidations(address User) public view returns (address[] memory){\r\n        return AllUserLiquidations[User];\r\n    }\r\n\r\n    function GetUserLiquidationDetails(address User, address Memecoin) public view returns (UserRBHLiquidation memory){\r\n        return UserRBHLiquidations[User][Memecoin];\r\n    }\r\n\r\n    //receive function\r\n    receive() external payable {\r\n    }\r\n\r\n}\r\n\r\n\r\n//TODO: Update interfaces depending on existing contracts\r\n\r\ncontract RebirthedToken {\r\n    uint256 public tokenCap;\r\n    uint256 public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    address private ZeroAddress;\r\n    //variable Declarations\r\n    \r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event BurnEvent(address indexed burner, uint256 indexed buramount);\r\n    event ManageMinterEvent(address indexed newminter);\r\n    //Event Declarations \r\n    \r\n    mapping(address => uint256) public balances;\r\n\r\n    mapping(address => mapping (address => uint256)) public allowance;\r\n    \r\n    constructor(uint256 _TokenCap, string memory _name, string memory _symbol){\r\n        tokenCap = _TokenCap;\r\n        totalSupply = 0;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = 18;\r\n        Mint(msg.sender, _TokenCap);\r\n    }\r\n    \r\n    function balanceOf(address Address) public view returns (uint256 balance){\r\n        return balances[Address];\r\n    }\r\n\r\n    function approve(address delegate, uint _amount) public returns (bool) {\r\n        allowance[msg.sender][delegate] = _amount;\r\n        emit Approval(msg.sender, delegate, _amount);\r\n        return true;\r\n    }\r\n    //Approves an address to spend your coins\r\n\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\r\n        require(_amount <= balances[_from]);    \r\n        require(_amount <= allowance[_from][msg.sender]);\r\n    \r\n        balances[_from] = balances[_from]-(_amount);\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender]-(_amount);\r\n        balances[_to] = balances[_to]+(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n    //Transfer From an other address\r\n\r\n\r\n    function transfer(address _to, uint256 _amount) public returns (bool) {\r\n        require(_amount <= balances[msg.sender]);\r\n        balances[msg.sender] = balances[msg.sender]-(_amount);\r\n        balances[_to] = balances[_to]+(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function Mint(address _MintTo, uint256 _MintAmount) internal {\r\n        require (totalSupply+(_MintAmount) <= tokenCap);\r\n        balances[_MintTo] = balances[_MintTo]+(_MintAmount);\r\n        totalSupply = totalSupply+(_MintAmount);\r\n        ZeroAddress = 0x0000000000000000000000000000000000000000;\r\n        emit Transfer(ZeroAddress ,_MintTo, _MintAmount);\r\n    } //Can only be used on deploy, view Internal \r\n\r\n\r\n    function Burn(uint256 _BurnAmount) public {\r\n        require (balances[msg.sender] >= _BurnAmount);\r\n        balances[msg.sender] = balances[msg.sender]-(_BurnAmount);\r\n        totalSupply = totalSupply-(_BurnAmount);\r\n        ZeroAddress = 0x0000000000000000000000000000000000000000;\r\n        emit Transfer(msg.sender, ZeroAddress, _BurnAmount);\r\n        emit BurnEvent(msg.sender, _BurnAmount);\r\n        \r\n    }\r\n\r\n}\r\n\r\ninterface ERC20 {\r\n  function balanceOf(address owner) external view returns (uint256);\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool); \r\n  function totalSupply() external view returns (uint);\r\n} \r\n\r\ninterface ERC721{\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router02{\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n     function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RBH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"AddFreemint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"AddRelaunchShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"AddRemove\",\"type\":\"bool\"}],\"name\":\"AddRemoveAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"AddUserToCountAndParticipated\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"PoolID\",\"type\":\"uint256\"}],\"name\":\"ClaimPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"PoolID\",\"type\":\"uint256\"}],\"name\":\"ClosePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ClosedPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"PairAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"HoursTillOpen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LenghtInHours\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SoftCap\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"TokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"TokenSymbol\",\"type\":\"string\"}],\"name\":\"CreatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"PoolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"enum RebirthProtocolCore.AlternativePayoutOption\",\"name\":\"AlternatePayoutChoice\",\"type\":\"uint8\"}],\"name\":\"DepositRelaunchShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"PoolID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"enum RebirthProtocolCore.AlternativePayoutOption\",\"name\":\"AlternatePayoutChoice\",\"type\":\"uint8\"}],\"name\":\"DepositTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FreemintContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"Freeminted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetClosedPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetOpenPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"PoolID\",\"type\":\"uint256\"}],\"name\":\"GetPoolDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RebirthedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"PairAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"PoolOpeningTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PoolClosingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SoftCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MemecoinsPerRelaunchShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalTokensDeposited\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"PoolSuccessful\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"PoolClosed\",\"type\":\"bool\"}],\"internalType\":\"struct RebirthProtocolCore.RebirthPool\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"PoolID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"GetUserPoolDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"AmountDeposited\",\"type\":\"uint256\"},{\"internalType\":\"enum RebirthProtocolCore.AlternativePayoutOption\",\"name\":\"AlternatePayoutChoice\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"PreviouslyDeposited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Claimed\",\"type\":\"bool\"}],\"internalType\":\"struct RebirthProtocolCore.UserPoolDetails\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"User\",\"type\":\"address\"}],\"name\":\"GetUserPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Liquidator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NFT_Freemints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"OpenPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"PoolDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"AmountDeposited\",\"type\":\"uint256\"},{\"internalType\":\"enum RebirthProtocolCore.AlternativePayoutOption\",\"name\":\"AlternatePayoutChoice\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"PreviouslyDeposited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Claimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Pools\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"RebirthedTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"PairAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"PoolOpeningTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PoolClosingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SoftCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MemecoinsPerRelaunchShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalTokensDeposited\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"PoolSuccessful\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"PoolClosed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RBH\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RBH_SuperAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RelaunchShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPERADMIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_FreemintContract\",\"type\":\"address\"}],\"name\":\"SetFreemintContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Liquidator\",\"type\":\"address\"}],\"name\":\"SetLiquidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalEtherDepositedEquivalents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UserParticipated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawRBH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"YourPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RebirthProtocolCore", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a29fb472f0e62bce6127f125e8d5ad2a9fa3839", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1f01c7c7688180b628fca32b9e0c524a4ba604047b179a744160d894c444ad60"}