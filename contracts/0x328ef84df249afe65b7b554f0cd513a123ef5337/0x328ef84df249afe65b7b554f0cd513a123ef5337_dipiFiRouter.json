{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.22;\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint) external;\r\n\r\n    function approve(address to, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n}\r\n\r\ncontract dipiFiRouter {\r\n    address private owner;\r\n    IUniswapV2Router02 private uniswapRouter;\r\n    IWETH private weth;\r\n    bool private locked;\r\n    modifier noReentrancy() {\r\n        require(!locked, \"ReentrancyGuard: reentrant call\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        uniswapRouter = IUniswapV2Router02(\r\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n        );\r\n        // weth = IWETH(0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6);\r\n        weth = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n    }\r\n\r\n    function _safeTransferETH(address payable _to, uint256 _amount) private {\r\n        (bool success, ) = _to.call{value: _amount}(\"\");\r\n        require(success, \"ETH transfer failed\");\r\n    }\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        address payable feeAddress,\r\n        address payable referralAddress\r\n    ) external payable noReentrancy {\r\n        require(msg.value > 0, \"No ETH sent\");\r\n        require(\r\n            feeAddress != address(0) && referralAddress != address(0),\r\n            \"Invalid fee or referral address\"\r\n        );\r\n\r\n        uint256 fee = msg.value / 100;\r\n        require(fee > 0, \"Fee calculates to zero\");\r\n        uint256 swapValue = msg.value - fee;\r\n        require(swapValue > 0, \"Insufficient value post-fee\");\r\n\r\n        _safeTransferETH(feeAddress, fee / 2);\r\n        _safeTransferETH(referralAddress, fee / 2);\r\n\r\n        weth.deposit{value: swapValue}();\r\n\r\n        require(\r\n            weth.approve(address(uniswapRouter), swapValue),\r\n            \"WETH approve failed\"\r\n        );\r\n\r\n        uint256[] memory amounts = uniswapRouter.swapTokensForExactTokens(\r\n            amountOut,\r\n            swapValue,\r\n            path,\r\n            to,\r\n            deadline\r\n        );\r\n        uint256 usedWeth = amounts[0];\r\n\r\n        if (usedWeth < swapValue) {\r\n            uint256 unusedWeth = swapValue - usedWeth;\r\n            weth.withdraw(unusedWeth);\r\n            _safeTransferETH(payable(msg.sender), unusedWeth);\r\n        }\r\n    }\r\n\r\n    function swapETHForExactTokensWithBribe(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline,\r\n        address payable feeAddress,\r\n        address payable referralAddress,\r\n        uint256 bribeAmount\r\n    ) external payable noReentrancy {\r\n        require(msg.value > 0, \"No ETH sent\");\r\n        require(\r\n            feeAddress != address(0) && referralAddress != address(0),\r\n            \"Invalid fee or referral address\"\r\n        );\r\n        require(msg.value > bribeAmount, \"Insufficient ETH for bribe\");\r\n\r\n        uint256 remainingETHAfterBribe = msg.value - bribeAmount;\r\n        uint256 fee = remainingETHAfterBribe / 100;\r\n        require(fee > 0, \"Fee calculates to zero\");\r\n        uint256 swapValue = remainingETHAfterBribe - fee;\r\n        require(swapValue > 0, \"Insufficient value post-fee\");\r\n\r\n        _safeTransferETH(feeAddress, fee / 2);\r\n        _safeTransferETH(referralAddress, fee / 2);\r\n\r\n        _safeTransferETH(payable(block.coinbase), bribeAmount);\r\n\r\n        weth.deposit{value: swapValue}();\r\n\r\n        require(\r\n            weth.approve(address(uniswapRouter), swapValue),\r\n            \"WETH approve failed\"\r\n        );\r\n\r\n        uint256[] memory amounts = uniswapRouter.swapTokensForExactTokens(\r\n            amountOut,\r\n            swapValue,\r\n            path,\r\n            to,\r\n            deadline\r\n        );\r\n        uint256 usedWeth = amounts[0];\r\n\r\n        if (usedWeth < swapValue) {\r\n            uint256 unusedWeth = swapValue - usedWeth;\r\n            weth.withdraw(unusedWeth);\r\n            _safeTransferETH(payable(msg.sender), unusedWeth);\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline,\r\n        address payable feeAddress,\r\n        address payable referralAddress\r\n    ) external payable noReentrancy {\r\n        require(\r\n            feeAddress != address(0) && referralAddress != address(0),\r\n            \"Invalid address\"\r\n        );\r\n\r\n        uint256 fee = msg.value / 100;\r\n        uint256 swapValue = msg.value - fee;\r\n\r\n        feeAddress.transfer(fee / 2);\r\n        referralAddress.transfer(fee / 2);\r\n\r\n        uniswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: swapValue\r\n        }(amountOutMin, path, to, deadline);\r\n    }\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address payable to,\r\n        uint256 deadline,\r\n        address payable feeAddress,\r\n        address payable referralAddress\r\n    ) external {\r\n        require(\r\n            feeAddress != address(0) && referralAddress != address(0),\r\n            \"Swap: Fee or referral address is zero\"\r\n        );\r\n\r\n        IERC20 token = IERC20(path[0]);\r\n        require(\r\n            token.balanceOf(msg.sender) >= amountIn,\r\n            \"Swap: Insufficient token balance\"\r\n        );\r\n        require(\r\n            token.allowance(msg.sender, address(this)) >= amountIn,\r\n            \"Swap: Token allowance too low\"\r\n        );\r\n\r\n        require(\r\n            token.transferFrom(msg.sender, address(this), amountIn),\r\n            \"Swap: Transfer of tokens to contract failed\"\r\n        );\r\n\r\n        require(\r\n            token.approve(address(uniswapRouter), amountIn),\r\n            \"Swap: Token approval for router failed\"\r\n        );\r\n\r\n        uint256 balanceBeforeSwap = address(this).balance;\r\n\r\n        uniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountIn,\r\n            amountOutMin,\r\n            path,\r\n            address(this),\r\n            deadline\r\n        );\r\n\r\n        uint256 amountETH = address(this).balance - balanceBeforeSwap;\r\n        require(\r\n            amountETH >= amountOutMin,\r\n            \"Swap: Swap did not yield enough ETH\"\r\n        );\r\n\r\n        uint256 fee = amountETH / 100;\r\n        uint256 feeHalf = fee / 2;\r\n\r\n        (bool feeSuccess, ) = feeAddress.call{value: feeHalf}(\"\");\r\n        require(feeSuccess, \"Swap: Fee transfer to fee address failed\");\r\n\r\n        (bool referralSuccess, ) = referralAddress.call{value: feeHalf}(\"\");\r\n        require(\r\n            referralSuccess,\r\n            \"Swap: Fee transfer to referral address failed\"\r\n        );\r\n\r\n        (bool toSuccess, ) = to.call{value: amountETH - fee}(\"\");\r\n        require(toSuccess, \"Swap: ETH transfer to recipient failed\");\r\n    }\r\n\r\n    function sendETH(address payable _to, uint _amount) external onlyOwner {\r\n        require(_amount <= address(this).balance, \"Insufficient Balance\");\r\n        _to.transfer(_amount);\r\n        emit Sent(_to, _amount);\r\n    }\r\n\r\n    event Sent(address, uint);\r\n\r\n    function withdrawETH() external onlyOwner {\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n\r\n    function withdrawTokens(address token, uint amount) external onlyOwner {\r\n        IERC20(token).transfer(owner, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"feeAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"feeAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bribeAmount\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokensWithBribe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"feeAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"feeAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "dipiFiRouter", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6ee0b28cccd1c72aa5f29bdd7619aa6959f511fae347dbeb31814e26f0181b69"}