{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/functions/dev/1_0_0/FunctionsBilling.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IFunctionsSubscriptions} from \\\"./interfaces/IFunctionsSubscriptions.sol\\\";\\nimport {AggregatorV3Interface} from \\\"../../../interfaces/AggregatorV3Interface.sol\\\";\\nimport {IFunctionsBilling} from \\\"./interfaces/IFunctionsBilling.sol\\\";\\n\\nimport {Routable} from \\\"./Routable.sol\\\";\\nimport {FunctionsResponse} from \\\"./libraries/FunctionsResponse.sol\\\";\\n\\nimport {SafeCast} from \\\"../../../vendor/openzeppelin-solidity/v4.8.0/contracts/utils/math/SafeCast.sol\\\";\\n\\n/// @title Functions Billing contract\\n/// @notice Contract that calculates payment from users to the nodes of the Decentralized Oracle Network (DON).\\n/// @dev THIS CONTRACT HAS NOT GONE THROUGH ANY SECURITY REVIEW. DO NOT USE IN PROD.\\nabstract contract FunctionsBilling is Routable, IFunctionsBilling {\\n  using FunctionsResponse for FunctionsResponse.RequestMeta;\\n  using FunctionsResponse for FunctionsResponse.Commitment;\\n  using FunctionsResponse for FunctionsResponse.FulfillResult;\\n\\n  uint256 private constant REASONABLE_GAS_PRICE_CEILING = 1_000_000_000_000_000; // 1 million gwei\\n  // ================================================================\\n  // |                  Request Commitment state                    |\\n  // ================================================================\\n\\n  mapping(bytes32 requestId => bytes32 commitmentHash) private s_requestCommitments;\\n\\n  event CommitmentDeleted(bytes32 requestId);\\n\\n  // ================================================================\\n  // |                     Configuration state                      |\\n  // ================================================================\\n\\n  struct Config {\\n    uint32 fulfillmentGasPriceOverEstimationBP; // \u2550\u2550\u2557 Percentage of gas price overestimation to account for changes in gas price between request and response. Held as basis points (one hundredth of 1 percentage point)\\n    uint32 feedStalenessSeconds; //                  \u2551 How long before we consider the feed price to be stale and fallback to fallbackNativePerUnitLink.\\n    uint32 gasOverheadBeforeCallback; //             \u2551 Represents the average gas execution cost before the fulfillment callback. This amount is always billed for every request.\\n    uint32 gasOverheadAfterCallback; //              \u2551 Represents the average gas execution cost after the fulfillment callback. This amount is always billed for every request.\\n    uint32 requestTimeoutSeconds; //                 \u2551 How many seconds it takes before we consider a request to be timed out\\n    uint72 donFee; //                                \u2551 Additional flat fee (in Juels of LINK) that will be split between Node Operators. Max value is 2^80 - 1 == 1.2m LINK.\\n    uint16 maxSupportedRequestDataVersion; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d The highest support request data version supported by the node. All lower versions should also be supported.\\n    uint224 fallbackNativePerUnitLink; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 fallback NATIVE CURRENCY / LINK conversion rate if the data feed is stale\\n  }\\n\\n  Config private s_config;\\n\\n  event ConfigUpdated(Config config);\\n\\n  error UnsupportedRequestDataVersion();\\n  error InsufficientBalance();\\n  error InvalidSubscription();\\n  error UnauthorizedSender();\\n  error MustBeSubOwner(address owner);\\n  error InvalidLinkWeiPrice(int256 linkWei);\\n  error PaymentTooLarge();\\n  error NoTransmittersSet();\\n  error InvalidCalldata();\\n\\n  // ================================================================\\n  // |                        Balance state                         |\\n  // ================================================================\\n\\n  mapping(address transmitter => uint96 balanceJuelsLink) private s_withdrawableTokens;\\n  // Pool together collected DON fees\\n  // Disperse them on withdrawal or change in OCR configuration\\n  uint96 internal s_feePool;\\n\\n  AggregatorV3Interface private s_linkToNativeFeed;\\n\\n  // ================================================================\\n  // |                       Initialization                         |\\n  // ================================================================\\n  constructor(address router, Config memory config, address linkToNativeFeed) Routable(router) {\\n    s_linkToNativeFeed = AggregatorV3Interface(linkToNativeFeed);\\n\\n    updateConfig(config);\\n  }\\n\\n  // ================================================================\\n  // |                        Configuration                         |\\n  // ================================================================\\n\\n  /// @notice Gets the Chainlink Coordinator's billing configuration\\n  /// @return config\\n  function getConfig() external view returns (Config memory) {\\n    return s_config;\\n  }\\n\\n  /// @notice Sets the Chainlink Coordinator's billing configuration\\n  /// @param config - See the contents of the Config struct in IFunctionsBilling.Config for more information\\n  function updateConfig(Config memory config) public {\\n    _onlyOwner();\\n\\n    s_config = config;\\n    emit ConfigUpdated(config);\\n  }\\n\\n  // ================================================================\\n  // |                       Fee Calculation                        |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsBilling\\n  function getDONFee(bytes memory /* requestData */) public view override returns (uint72) {\\n    return s_config.donFee;\\n  }\\n\\n  /// @inheritdoc IFunctionsBilling\\n  function getAdminFee() public view override returns (uint72) {\\n    return _getRouter().getAdminFee();\\n  }\\n\\n  /// @inheritdoc IFunctionsBilling\\n  function getWeiPerUnitLink() public view returns (uint256) {\\n    Config memory config = s_config;\\n    (, int256 weiPerUnitLink, , uint256 timestamp, ) = s_linkToNativeFeed.latestRoundData();\\n    // solhint-disable-next-line not-rely-on-time\\n    if (config.feedStalenessSeconds < block.timestamp - timestamp && config.feedStalenessSeconds > 0) {\\n      return config.fallbackNativePerUnitLink;\\n    }\\n    if (weiPerUnitLink <= 0) {\\n      revert InvalidLinkWeiPrice(weiPerUnitLink);\\n    }\\n    return uint256(weiPerUnitLink);\\n  }\\n\\n  function _getJuelsPerGas(uint256 gasPriceWei) private view returns (uint96) {\\n    // (1e18 juels/link) * (wei/gas) / (wei/link) = juels per gas\\n    // There are only 1e9*1e18 = 1e27 juels in existence, should not exceed uint96 (2^96 ~ 7e28)\\n    return SafeCast.toUint96((1e18 * gasPriceWei) / getWeiPerUnitLink());\\n  }\\n\\n  // ================================================================\\n  // |                       Cost Estimation                        |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsBilling\\n  function estimateCost(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint32 callbackGasLimit,\\n    uint256 gasPriceWei\\n  ) external view override returns (uint96) {\\n    _getRouter().isValidCallbackGasLimit(subscriptionId, callbackGasLimit);\\n    // Reasonable ceilings to prevent integer overflows\\n    if (gasPriceWei > REASONABLE_GAS_PRICE_CEILING) {\\n      revert InvalidCalldata();\\n    }\\n    uint72 adminFee = getAdminFee();\\n    uint72 donFee = getDONFee(data);\\n    return _calculateCostEstimate(callbackGasLimit, gasPriceWei, donFee, adminFee);\\n  }\\n\\n  /// @notice Estimate the cost in Juels of LINK\\n  // that will be charged to a subscription to fulfill a Functions request\\n  // Gas Price can be overestimated to account for flucuations between request and response time\\n  function _calculateCostEstimate(\\n    uint32 callbackGasLimit,\\n    uint256 gasPriceWei,\\n    uint72 donFee,\\n    uint72 adminFee\\n  ) internal view returns (uint96) {\\n    uint256 executionGas = s_config.gasOverheadBeforeCallback + s_config.gasOverheadAfterCallback + callbackGasLimit;\\n\\n    uint256 gasPriceWithOverestimation = gasPriceWei +\\n      ((gasPriceWei * s_config.fulfillmentGasPriceOverEstimationBP) / 10_000);\\n    /// @NOTE: Basis Points are 1/100th of 1%, divide by 10_000 to bring back to original units\\n\\n    uint96 juelsPerGas = _getJuelsPerGas(gasPriceWithOverestimation);\\n    uint256 estimatedGasReimbursement = juelsPerGas * executionGas;\\n    uint96 fees = uint96(donFee) + uint96(adminFee);\\n\\n    return SafeCast.toUint96(estimatedGasReimbursement + fees);\\n  }\\n\\n  // ================================================================\\n  // |                           Billing                            |\\n  // ================================================================\\n\\n  /// @notice Initiate the billing process for an Functions request\\n  /// @dev Only callable by the Functions Router\\n  /// @param request - Chainlink Functions request data, see FunctionsResponse.RequestMeta for the structure\\n  /// @return commitment - The parameters of the request that must be held consistent at response time\\n  function _startBilling(\\n    FunctionsResponse.RequestMeta memory request\\n  ) internal returns (FunctionsResponse.Commitment memory commitment) {\\n    Config memory config = s_config;\\n\\n    // Nodes should support all past versions of the structure\\n    if (request.dataVersion > config.maxSupportedRequestDataVersion) {\\n      revert UnsupportedRequestDataVersion();\\n    }\\n\\n    uint72 donFee = getDONFee(request.data);\\n    uint96 estimatedTotalCostJuels = _calculateCostEstimate(\\n      request.callbackGasLimit,\\n      tx.gasprice,\\n      donFee,\\n      request.adminFee\\n    );\\n\\n    // Check that subscription can afford the estimated cost\\n    if ((request.availableBalance) < estimatedTotalCostJuels) {\\n      revert InsufficientBalance();\\n    }\\n\\n    bytes32 requestId = _computeRequestId(\\n      address(this),\\n      request.requestingContract,\\n      request.subscriptionId,\\n      request.initiatedRequests + 1\\n    );\\n\\n    commitment = FunctionsResponse.Commitment({\\n      adminFee: request.adminFee,\\n      coordinator: address(this),\\n      client: request.requestingContract,\\n      subscriptionId: request.subscriptionId,\\n      callbackGasLimit: request.callbackGasLimit,\\n      estimatedTotalCostJuels: estimatedTotalCostJuels,\\n      timeoutTimestamp: uint32(block.timestamp + config.requestTimeoutSeconds),\\n      requestId: requestId,\\n      donFee: donFee,\\n      gasOverheadBeforeCallback: config.gasOverheadBeforeCallback,\\n      gasOverheadAfterCallback: config.gasOverheadAfterCallback\\n    });\\n\\n    s_requestCommitments[requestId] = keccak256(abi.encode(commitment));\\n\\n    return commitment;\\n  }\\n\\n  /// @notice Generate a keccak hash request ID\\n  /// @dev uses the number of requests that the consumer of a subscription has sent as a nonce\\n  function _computeRequestId(\\n    address don,\\n    address client,\\n    uint64 subscriptionId,\\n    uint64 nonce\\n  ) private pure returns (bytes32) {\\n    return keccak256(abi.encode(don, client, subscriptionId, nonce));\\n  }\\n\\n  /// @notice Finalize billing process for an Functions request by sending a callback to the Client contract and then charging the subscription\\n  /// @param requestId identifier for the request that was generated by the Registry in the beginBilling commitment\\n  /// @param response response data from DON consensus\\n  /// @param err error from DON consensus\\n  /// @return result fulfillment result\\n  /// @dev Only callable by a node that has been approved on the Coordinator\\n  /// @dev simulated offchain to determine if sufficient balance is present to fulfill the request\\n  function _fulfillAndBill(\\n    bytes32 requestId,\\n    bytes memory response,\\n    bytes memory err,\\n    bytes memory onchainMetadata,\\n    bytes memory /* offchainMetadata TODO: use in getDonFee() for dynamic billing */\\n  ) internal returns (FunctionsResponse.FulfillResult) {\\n    FunctionsResponse.Commitment memory commitment = abi.decode(onchainMetadata, (FunctionsResponse.Commitment));\\n\\n    if (s_requestCommitments[requestId] == bytes32(0)) {\\n      return FunctionsResponse.FulfillResult.INVALID_REQUEST_ID;\\n    }\\n\\n    if (s_requestCommitments[requestId] != keccak256(abi.encode(commitment))) {\\n      return FunctionsResponse.FulfillResult.INVALID_COMMITMENT;\\n    }\\n\\n    uint96 juelsPerGas = _getJuelsPerGas(tx.gasprice);\\n    // Gas overhead without callback\\n    uint96 gasOverheadJuels = juelsPerGas *\\n      (commitment.gasOverheadBeforeCallback + commitment.gasOverheadAfterCallback);\\n\\n    // The Functions Router will perform the callback to the client contract\\n    (FunctionsResponse.FulfillResult resultCode, uint96 callbackCostJuels) = _getRouter().fulfill(\\n      response,\\n      err,\\n      juelsPerGas,\\n      gasOverheadJuels + commitment.donFee, // costWithoutFulfillment\\n      msg.sender,\\n      commitment\\n    );\\n\\n    // The router will only pay the DON on successfully processing the fulfillment\\n    // In these two fulfillment results the user has been charged\\n    // Otherwise, the Coordinator should hold on to the request commitment\\n    if (\\n      resultCode == FunctionsResponse.FulfillResult.FULFILLED ||\\n      resultCode == FunctionsResponse.FulfillResult.USER_CALLBACK_ERROR\\n    ) {\\n      delete s_requestCommitments[requestId];\\n      // Reimburse the transmitter for the fulfillment gas cost\\n      s_withdrawableTokens[msg.sender] = gasOverheadJuels + callbackCostJuels;\\n      // Put donFee into the pool of fees, to be split later\\n      // Saves on storage writes that would otherwise be charged to the user\\n      s_feePool += commitment.donFee;\\n    }\\n\\n    return resultCode;\\n  }\\n\\n  // ================================================================\\n  // |                       Request Timeout                        |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsBilling\\n  /// @dev Only callable by the Router\\n  /// @dev Used by FunctionsRouter.sol during timeout of a request\\n  function deleteCommitment(bytes32 requestId) external override onlyRouter {\\n    // Delete commitment\\n    delete s_requestCommitments[requestId];\\n    emit CommitmentDeleted(requestId);\\n  }\\n\\n  // ================================================================\\n  // |                    Fund withdrawal                           |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsBilling\\n  function oracleWithdraw(address recipient, uint96 amount) external {\\n    _disperseFeePool();\\n\\n    if (amount == 0) {\\n      amount = s_withdrawableTokens[msg.sender];\\n    } else if (s_withdrawableTokens[msg.sender] < amount) {\\n      revert InsufficientBalance();\\n    }\\n    s_withdrawableTokens[msg.sender] -= amount;\\n    IFunctionsSubscriptions(address(_getRouter())).oracleWithdraw(recipient, amount);\\n  }\\n\\n  /// @inheritdoc IFunctionsBilling\\n  /// @dev Only callable by the Coordinator owner\\n  function oracleWithdrawAll() external {\\n    _onlyOwner();\\n    _disperseFeePool();\\n\\n    address[] memory transmitters = _getTransmitters();\\n\\n    // Bounded by \\\"maxNumOracles\\\" on OCR2Abstract.sol\\n    for (uint256 i = 0; i < transmitters.length; ++i) {\\n      uint96 balance = s_withdrawableTokens[transmitters[i]];\\n      if (balance > 0) {\\n        s_withdrawableTokens[transmitters[i]] = 0;\\n        IFunctionsSubscriptions(address(_getRouter())).oracleWithdraw(transmitters[i], balance);\\n      }\\n    }\\n  }\\n\\n  // Overriden in FunctionsCoordinator, which has visibility into transmitters\\n  function _getTransmitters() internal view virtual returns (address[] memory);\\n\\n  // DON fees are collected into a pool s_feePool\\n  // When OCR configuration changes, or any oracle withdraws, this must be dispersed\\n  function _disperseFeePool() internal {\\n    if (s_feePool == 0) {\\n      return;\\n    }\\n    // All transmitters are assumed to also be observers\\n    // Pay out the DON fee to all transmitters\\n    address[] memory transmitters = _getTransmitters();\\n    if (transmitters.length == 0) {\\n      revert NoTransmittersSet();\\n    }\\n    uint96 feePoolShare = s_feePool / uint96(transmitters.length);\\n    // Bounded by \\\"maxNumOracles\\\" on OCR2Abstract.sol\\n    for (uint256 i = 0; i < transmitters.length; ++i) {\\n      s_withdrawableTokens[transmitters[i]] += feePoolShare;\\n    }\\n    s_feePool -= feePoolShare * uint96(transmitters.length);\\n  }\\n\\n  // Overriden in FunctionsCoordinator.sol\\n  function _onlyOwner() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/FunctionsClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IFunctionsRouter} from \\\"./interfaces/IFunctionsRouter.sol\\\";\\nimport {IFunctionsClient} from \\\"./interfaces/IFunctionsClient.sol\\\";\\n\\nimport {FunctionsRequest} from \\\"./libraries/FunctionsRequest.sol\\\";\\n\\n/// @title The Chainlink Functions client contract\\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\\nabstract contract FunctionsClient is IFunctionsClient {\\n  using FunctionsRequest for FunctionsRequest.Request;\\n\\n  IFunctionsRouter internal immutable i_router;\\n\\n  event RequestSent(bytes32 indexed id);\\n  event RequestFulfilled(bytes32 indexed id);\\n\\n  error OnlyRouterCanFulfill();\\n\\n  constructor(address router) {\\n    i_router = IFunctionsRouter(router);\\n  }\\n\\n  /// @notice Sends a Chainlink Functions request\\n  /// @param data The CBOR encoded bytes data for a Functions request\\n  /// @param subscriptionId The subscription ID that will be charged to service the request\\n  /// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\\n  /// @return requestId The generated request ID for this request\\n  function _sendRequest(\\n    bytes memory data,\\n    uint64 subscriptionId,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) internal returns (bytes32) {\\n    bytes32 requestId = i_router.sendRequest(\\n      subscriptionId,\\n      data,\\n      FunctionsRequest.REQUEST_DATA_VERSION,\\n      callbackGasLimit,\\n      donId\\n    );\\n    emit RequestSent(requestId);\\n    return requestId;\\n  }\\n\\n  /// @notice User defined function to handle a response from the DON\\n  /// @param requestId The request ID, returned by sendRequest()\\n  /// @param response Aggregated response from the execution of the user's source code\\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\\n  /// @dev Either response or error parameter will be set, but never both\\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\\n\\n  /// @inheritdoc IFunctionsClient\\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\\n    if (msg.sender != address(i_router)) {\\n      revert OnlyRouterCanFulfill();\\n    }\\n    fulfillRequest(requestId, response, err);\\n    emit RequestFulfilled(requestId);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/FunctionsCoordinator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IFunctionsCoordinator} from \\\"./interfaces/IFunctionsCoordinator.sol\\\";\\nimport {IFunctionsBilling} from \\\"./interfaces/IFunctionsBilling.sol\\\";\\nimport {ITypeAndVersion} from \\\"../../../shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nimport {FunctionsBilling} from \\\"./FunctionsBilling.sol\\\";\\nimport {OCR2Base} from \\\"./ocr/OCR2Base.sol\\\";\\nimport {FunctionsResponse} from \\\"./libraries/FunctionsResponse.sol\\\";\\n\\n/// @title Functions Coordinator contract\\n/// @notice Contract that nodes of a Decentralized Oracle Network (DON) interact with\\n/// @dev THIS CONTRACT HAS NOT GONE THROUGH ANY SECURITY REVIEW. DO NOT USE IN PROD.\\ncontract FunctionsCoordinator is OCR2Base, IFunctionsCoordinator, FunctionsBilling {\\n  using FunctionsResponse for FunctionsResponse.RequestMeta;\\n  using FunctionsResponse for FunctionsResponse.Commitment;\\n  using FunctionsResponse for FunctionsResponse.FulfillResult;\\n\\n  /// @inheritdoc ITypeAndVersion\\n  string public constant override typeAndVersion = \\\"Functions Coordinator v1.0.0\\\";\\n\\n  event OracleRequest(\\n    bytes32 indexed requestId,\\n    address indexed requestingContract,\\n    address requestInitiator,\\n    uint64 subscriptionId,\\n    address subscriptionOwner,\\n    bytes data,\\n    uint16 dataVersion,\\n    bytes32 flags,\\n    uint64 callbackGasLimit,\\n    FunctionsResponse.Commitment commitment\\n  );\\n  event OracleResponse(bytes32 indexed requestId, address transmitter);\\n\\n  error InconsistentReportData();\\n  error EmptyPublicKey();\\n  error UnauthorizedPublicKeyChange();\\n\\n  bytes private s_donPublicKey;\\n  bytes private s_thresholdPublicKey;\\n\\n  constructor(\\n    address router,\\n    Config memory config,\\n    address linkToNativeFeed\\n  ) OCR2Base(true) FunctionsBilling(router, config, linkToNativeFeed) {}\\n\\n  /// @inheritdoc IFunctionsCoordinator\\n  function getThresholdPublicKey() external view override returns (bytes memory) {\\n    if (s_thresholdPublicKey.length == 0) {\\n      revert EmptyPublicKey();\\n    }\\n    return s_thresholdPublicKey;\\n  }\\n\\n  /// @inheritdoc IFunctionsCoordinator\\n  function setThresholdPublicKey(bytes calldata thresholdPublicKey) external override onlyOwner {\\n    if (thresholdPublicKey.length == 0) {\\n      revert EmptyPublicKey();\\n    }\\n    s_thresholdPublicKey = thresholdPublicKey;\\n  }\\n\\n  /// @inheritdoc IFunctionsCoordinator\\n  function getDONPublicKey() external view override returns (bytes memory) {\\n    if (s_donPublicKey.length == 0) {\\n      revert EmptyPublicKey();\\n    }\\n    return s_donPublicKey;\\n  }\\n\\n  /// @inheritdoc IFunctionsCoordinator\\n  function setDONPublicKey(bytes calldata donPublicKey) external override onlyOwner {\\n    if (donPublicKey.length == 0) {\\n      revert EmptyPublicKey();\\n    }\\n    s_donPublicKey = donPublicKey;\\n  }\\n\\n  /// @dev check if node is in current transmitter list\\n  function _isTransmitter(address node) internal view returns (bool) {\\n    address[] memory nodes = s_transmitters;\\n    // Bounded by \\\"maxNumOracles\\\" on OCR2Abstract.sol\\n    for (uint256 i = 0; i < nodes.length; ++i) {\\n      if (nodes[i] == node) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /// @inheritdoc IFunctionsCoordinator\\n  function startRequest(\\n    FunctionsResponse.RequestMeta calldata request\\n  ) external override onlyRouter returns (FunctionsResponse.Commitment memory commitment) {\\n    commitment = _startBilling(request);\\n\\n    emit OracleRequest(\\n      commitment.requestId,\\n      request.requestingContract,\\n      tx.origin,\\n      request.subscriptionId,\\n      request.subscriptionOwner,\\n      request.data,\\n      request.dataVersion,\\n      request.flags,\\n      request.callbackGasLimit,\\n      commitment\\n    );\\n\\n    return commitment;\\n  }\\n\\n  /// @dev DON fees are pooled together. If the OCR configuration is going to change, these need to be distributed.\\n  function _beforeSetConfig(uint8 /* _f */, bytes memory /* _onchainConfig */) internal override {\\n    if (_getTransmitters().length > 0) {\\n      _disperseFeePool();\\n    }\\n  }\\n\\n  /// @dev Used by FunctionsBilling.sol\\n  function _getTransmitters() internal view override returns (address[] memory) {\\n    return s_transmitters;\\n  }\\n\\n  /// @dev Report hook called within OCR2Base.sol\\n  function _report(\\n    uint256 /*initialGas*/,\\n    address /*transmitter*/,\\n    uint8 /*signerCount*/,\\n    address[MAX_NUM_ORACLES] memory /*signers*/,\\n    bytes calldata report\\n  ) internal override {\\n    bytes32[] memory requestIds;\\n    bytes[] memory results;\\n    bytes[] memory errors;\\n    bytes[] memory onchainMetadata;\\n    bytes[] memory offchainMetadata;\\n    (requestIds, results, errors, onchainMetadata, offchainMetadata) = abi.decode(\\n      report,\\n      (bytes32[], bytes[], bytes[], bytes[], bytes[])\\n    );\\n\\n    if (\\n      requestIds.length == 0 ||\\n      requestIds.length != results.length ||\\n      requestIds.length != errors.length ||\\n      requestIds.length != onchainMetadata.length ||\\n      requestIds.length != offchainMetadata.length\\n    ) {\\n      revert ReportInvalid();\\n    }\\n\\n    // Bounded by \\\"MaxRequestBatchSize\\\" on the Job's ReportingPluginConfig\\n    for (uint256 i = 0; i < requestIds.length; ++i) {\\n      FunctionsResponse.FulfillResult result = FunctionsResponse.FulfillResult(\\n        _fulfillAndBill(requestIds[i], results[i], errors[i], onchainMetadata[i], offchainMetadata[i])\\n      );\\n\\n      // Emit on successfully processing the fulfillment\\n      // In these two fulfillment results the user has been charged\\n      // Otherwise, the DON will re-try\\n      if (\\n        result == FunctionsResponse.FulfillResult.FULFILLED ||\\n        result == FunctionsResponse.FulfillResult.USER_CALLBACK_ERROR\\n      ) {\\n        emit OracleResponse(requestIds[i], msg.sender);\\n      }\\n    }\\n  }\\n\\n  /// @dev Used in FunctionsBilling.sol\\n  function _onlyOwner() internal view override {\\n    _validateOwnership();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/FunctionsRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {ITypeAndVersion} from \\\"../../../shared/interfaces/ITypeAndVersion.sol\\\";\\nimport {IFunctionsRouter} from \\\"./interfaces/IFunctionsRouter.sol\\\";\\nimport {IFunctionsCoordinator} from \\\"./interfaces/IFunctionsCoordinator.sol\\\";\\nimport {IAccessController} from \\\"../../../shared/interfaces/IAccessController.sol\\\";\\n\\nimport {FunctionsSubscriptions} from \\\"./FunctionsSubscriptions.sol\\\";\\nimport {FunctionsResponse} from \\\"./libraries/FunctionsResponse.sol\\\";\\nimport {ConfirmedOwner} from \\\"../../../shared/access/ConfirmedOwner.sol\\\";\\n\\nimport {SafeCast} from \\\"../../../vendor/openzeppelin-solidity/v4.8.0/contracts/utils/math/SafeCast.sol\\\";\\nimport {Pausable} from \\\"../../../vendor/openzeppelin-solidity/v4.8.0/contracts/security/Pausable.sol\\\";\\n\\ncontract FunctionsRouter is IFunctionsRouter, FunctionsSubscriptions, Pausable, ITypeAndVersion, ConfirmedOwner {\\n  using FunctionsResponse for FunctionsResponse.RequestMeta;\\n  using FunctionsResponse for FunctionsResponse.Commitment;\\n  using FunctionsResponse for FunctionsResponse.FulfillResult;\\n\\n  string public constant override typeAndVersion = \\\"Functions Router v1.0.0\\\";\\n\\n  // We limit return data to a selector plus 4 words. This is to avoid\\n  // malicious contracts from returning large amounts of data and causing\\n  // repeated out-of-gas scenarios.\\n  uint16 public constant MAX_CALLBACK_RETURN_BYTES = 4 + 4 * 32;\\n  uint8 private constant MAX_CALLBACK_GAS_LIMIT_FLAGS_INDEX = 0;\\n\\n  event RequestStart(\\n    bytes32 indexed requestId,\\n    bytes32 indexed donId,\\n    uint64 indexed subscriptionId,\\n    address subscriptionOwner,\\n    address requestingContract,\\n    address requestInitiator,\\n    bytes data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    uint96 estimatedTotalCostJuels\\n  );\\n\\n  event RequestProcessed(\\n    bytes32 indexed requestId,\\n    uint64 indexed subscriptionId,\\n    uint96 totalCostJuels,\\n    address transmitter,\\n    FunctionsResponse.FulfillResult resultCode,\\n    bytes response,\\n    bytes err,\\n    bytes callbackReturnData\\n  );\\n\\n  event RequestNotProcessed(\\n    bytes32 indexed requestId,\\n    address coordinator,\\n    address transmitter,\\n    FunctionsResponse.FulfillResult resultCode\\n  );\\n\\n  error EmptyRequestData();\\n  error OnlyCallableFromCoordinator();\\n  error SenderMustAcceptTermsOfService(address sender);\\n  error InvalidGasFlagValue(uint8 value);\\n  error GasLimitTooBig(uint32 limit);\\n  error DuplicateRequestId(bytes32 requestId);\\n\\n  struct CallbackResult {\\n    bool success; // \u2550\u2550\u2550\u2550\u2550\u2550\u2578 Whether the callback succeeded or not\\n    uint256 gasUsed; // \u2550\u2550\u2550\u2578 The amount of gas consumed during the callback\\n    bytes returnData; // \u2550\u2550\u2578 The return of the callback function\\n  }\\n\\n  // ================================================================\\n  // |                    Route state                       |\\n  // ================================================================\\n\\n  mapping(bytes32 id => address routableContract) private s_route;\\n\\n  error RouteNotFound(bytes32 id);\\n\\n  // Identifier for the route to the Terms of Service Allow List\\n  bytes32 private s_allowListId;\\n\\n  // ================================================================\\n  // |                    Configuration state                       |\\n  // ================================================================\\n  struct Config {\\n    uint16 maxConsumersPerSubscription; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 Maximum number of consumers which can be added to a single subscription. This bound ensures we are able to loop over all subscription consumers as needed, without exceeding gas limits. Should a user require more consumers, they can use multiple subscriptions.\\n    uint72 adminFee; //                             \u2551 Flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\\n    bytes4 handleOracleFulfillmentSelector; //      \u2551 The function selector that is used when calling back to the Client contract\\n    uint16 gasForCallExactCheck; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d Used during calling back to the client. Ensures we have at least enough gas to be able to revert if gasAmount >  63//64*gas available.\\n    uint32[] maxCallbackGasLimits; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 List of max callback gas limits used by flag with GAS_FLAG_INDEX\\n    uint16 subscriptionDepositMinimumRequests; //\u2550\u2550\u2550\u2557 Amount of requests that must be completed before the full subscription balance will be released when closing a subscription account.\\n    uint72 subscriptionDepositJuels; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d Amount of subscription funds that are held as a deposit until Config.subscriptionDepositMinimumRequests are made using the subscription.\\n  }\\n\\n  Config private s_config;\\n\\n  event ConfigUpdated(Config);\\n\\n  // ================================================================\\n  // |                         Proposal state                       |\\n  // ================================================================\\n\\n  uint8 private constant MAX_PROPOSAL_SET_LENGTH = 8;\\n\\n  struct ContractProposalSet {\\n    bytes32[] ids; // \u2550\u2550\u2578 The IDs that key into the routes that will be modified if the update is applied\\n    address[] to; // \u2550\u2550\u2550\u2578 The address of the contracts that the route will point to if the updated is applied\\n  }\\n  ContractProposalSet private s_proposedContractSet;\\n\\n  event ContractProposed(\\n    bytes32 proposedContractSetId,\\n    address proposedContractSetFromAddress,\\n    address proposedContractSetToAddress\\n  );\\n\\n  event ContractUpdated(bytes32 id, address from, address to);\\n\\n  error InvalidProposal();\\n  error IdentifierIsReserved(bytes32 id);\\n\\n  // ================================================================\\n  // |                       Initialization                         |\\n  // ================================================================\\n\\n  constructor(\\n    address linkToken,\\n    Config memory config\\n  ) FunctionsSubscriptions(linkToken) ConfirmedOwner(msg.sender) Pausable() {\\n    // Set the intial configuration\\n    updateConfig(config);\\n  }\\n\\n  // ================================================================\\n  // |                        Configuration                         |\\n  // ================================================================\\n\\n  /// @notice The identifier of the route to retrieve the address of the access control contract\\n  // The access control contract controls which accounts can manage subscriptions\\n  /// @return id - bytes32 id that can be passed to the \\\"getContractById\\\" of the Router\\n  function getConfig() external view returns (Config memory) {\\n    return s_config;\\n  }\\n\\n  /// @notice The router configuration\\n  function updateConfig(Config memory config) public onlyOwner {\\n    s_config = config;\\n    emit ConfigUpdated(config);\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) public view {\\n    uint8 callbackGasLimitsIndexSelector = uint8(getFlags(subscriptionId)[MAX_CALLBACK_GAS_LIMIT_FLAGS_INDEX]);\\n    if (callbackGasLimitsIndexSelector >= s_config.maxCallbackGasLimits.length) {\\n      revert InvalidGasFlagValue(callbackGasLimitsIndexSelector);\\n    }\\n    uint32 maxCallbackGasLimit = s_config.maxCallbackGasLimits[callbackGasLimitsIndexSelector];\\n    if (callbackGasLimit > maxCallbackGasLimit) {\\n      revert GasLimitTooBig(maxCallbackGasLimit);\\n    }\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function getAdminFee() external view override returns (uint72) {\\n    return s_config.adminFee;\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function getAllowListId() external view override returns (bytes32) {\\n    return s_allowListId;\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function setAllowListId(bytes32 allowListId) external override onlyOwner {\\n    s_allowListId = allowListId;\\n  }\\n\\n  /// @dev Used within FunctionsSubscriptions.sol\\n  function _getMaxConsumers() internal view override returns (uint16) {\\n    return s_config.maxConsumersPerSubscription;\\n  }\\n\\n  /// @dev Used within FunctionsSubscriptions.sol\\n  function _getSubscriptionDepositDetails() internal view override returns (uint16, uint72) {\\n    return (s_config.subscriptionDepositMinimumRequests, s_config.subscriptionDepositJuels);\\n  }\\n\\n  // ================================================================\\n  // |                           Requests                           |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function sendRequest(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) external override returns (bytes32) {\\n    IFunctionsCoordinator coordinator = IFunctionsCoordinator(getContractById(donId));\\n    return _sendRequest(donId, coordinator, subscriptionId, data, dataVersion, callbackGasLimit);\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function sendRequestToProposed(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) external override returns (bytes32) {\\n    IFunctionsCoordinator coordinator = IFunctionsCoordinator(getProposedContractById(donId));\\n    return _sendRequest(donId, coordinator, subscriptionId, data, dataVersion, callbackGasLimit);\\n  }\\n\\n  function _sendRequest(\\n    bytes32 donId,\\n    IFunctionsCoordinator coordinator,\\n    uint64 subscriptionId,\\n    bytes memory data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit\\n  ) private returns (bytes32) {\\n    _whenNotPaused();\\n    _isExistingSubscription(subscriptionId);\\n    _isAllowedConsumer(msg.sender, subscriptionId);\\n    isValidCallbackGasLimit(subscriptionId, callbackGasLimit);\\n\\n    if (data.length == 0) {\\n      revert EmptyRequestData();\\n    }\\n\\n    Subscription memory subscription = getSubscription(subscriptionId);\\n    Consumer memory consumer = getConsumer(msg.sender, subscriptionId);\\n    uint72 adminFee = s_config.adminFee;\\n\\n    // Forward request to DON\\n    FunctionsResponse.Commitment memory commitment = coordinator.startRequest(\\n      FunctionsResponse.RequestMeta({\\n        requestingContract: msg.sender,\\n        data: data,\\n        subscriptionId: subscriptionId,\\n        dataVersion: dataVersion,\\n        flags: getFlags(subscriptionId),\\n        callbackGasLimit: callbackGasLimit,\\n        adminFee: adminFee,\\n        initiatedRequests: consumer.initiatedRequests,\\n        completedRequests: consumer.completedRequests,\\n        availableBalance: subscription.balance - subscription.blockedBalance,\\n        subscriptionOwner: subscription.owner\\n      })\\n    );\\n\\n    // Do not allow setting a comittment for a requestId that already exists\\n    if (s_requestCommitments[commitment.requestId] != bytes32(0)) {\\n      revert DuplicateRequestId(commitment.requestId);\\n    }\\n\\n    // Store a commitment about the request\\n    s_requestCommitments[commitment.requestId] = keccak256(\\n      abi.encode(\\n        FunctionsResponse.Commitment({\\n          adminFee: adminFee,\\n          coordinator: address(coordinator),\\n          client: msg.sender,\\n          subscriptionId: subscriptionId,\\n          callbackGasLimit: callbackGasLimit,\\n          estimatedTotalCostJuels: commitment.estimatedTotalCostJuels,\\n          timeoutTimestamp: commitment.timeoutTimestamp,\\n          requestId: commitment.requestId,\\n          donFee: commitment.donFee,\\n          gasOverheadBeforeCallback: commitment.gasOverheadBeforeCallback,\\n          gasOverheadAfterCallback: commitment.gasOverheadAfterCallback\\n        })\\n      )\\n    );\\n\\n    _markRequestInFlight(msg.sender, subscriptionId, commitment.estimatedTotalCostJuels);\\n\\n    emit RequestStart({\\n      requestId: commitment.requestId,\\n      donId: donId,\\n      subscriptionId: subscriptionId,\\n      subscriptionOwner: subscription.owner,\\n      requestingContract: msg.sender,\\n      requestInitiator: tx.origin,\\n      data: data,\\n      dataVersion: dataVersion,\\n      callbackGasLimit: callbackGasLimit,\\n      estimatedTotalCostJuels: commitment.estimatedTotalCostJuels\\n    });\\n\\n    return commitment.requestId;\\n  }\\n\\n  // ================================================================\\n  // |                           Responses                          |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function fulfill(\\n    bytes memory response,\\n    bytes memory err,\\n    uint96 juelsPerGas,\\n    uint96 costWithoutCallback,\\n    address transmitter,\\n    FunctionsResponse.Commitment memory commitment\\n  ) external override returns (FunctionsResponse.FulfillResult resultCode, uint96) {\\n    _whenNotPaused();\\n\\n    if (msg.sender != commitment.coordinator) {\\n      revert OnlyCallableFromCoordinator();\\n    }\\n\\n    {\\n      bytes32 commitmentHash = s_requestCommitments[commitment.requestId];\\n\\n      if (commitmentHash == bytes32(0)) {\\n        resultCode = FunctionsResponse.FulfillResult.INVALID_REQUEST_ID;\\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\\n        return (resultCode, 0);\\n      }\\n\\n      if (keccak256(abi.encode(commitment)) != commitmentHash) {\\n        resultCode = FunctionsResponse.FulfillResult.INVALID_COMMITMENT;\\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\\n        return (resultCode, 0);\\n      }\\n\\n      // Check that the transmitter has supplied enough gas for the callback to succeed\\n      if (gasleft() < commitment.callbackGasLimit + commitment.gasOverheadAfterCallback) {\\n        resultCode = FunctionsResponse.FulfillResult.INSUFFICIENT_GAS_PROVIDED;\\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\\n        return (resultCode, 0);\\n      }\\n    }\\n\\n    {\\n      uint96 callbackCost = juelsPerGas * SafeCast.toUint96(commitment.callbackGasLimit);\\n      uint96 totalCostJuels = commitment.adminFee + costWithoutCallback + callbackCost;\\n\\n      // Check that the subscription can still afford to fulfill the request\\n      if (totalCostJuels > getSubscription(commitment.subscriptionId).balance) {\\n        resultCode = FunctionsResponse.FulfillResult.SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION;\\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\\n        return (resultCode, 0);\\n      }\\n\\n      // Check that the cost has not exceeded the quoted cost\\n      if (totalCostJuels > commitment.estimatedTotalCostJuels) {\\n        resultCode = FunctionsResponse.FulfillResult.COST_EXCEEDS_COMMITMENT;\\n        emit RequestNotProcessed(commitment.requestId, commitment.coordinator, transmitter, resultCode);\\n        return (resultCode, 0);\\n      }\\n    }\\n\\n    delete s_requestCommitments[commitment.requestId];\\n\\n    CallbackResult memory result = _callback(\\n      commitment.requestId,\\n      response,\\n      err,\\n      commitment.callbackGasLimit,\\n      commitment.client\\n    );\\n\\n    resultCode = result.success\\n      ? FunctionsResponse.FulfillResult.FULFILLED\\n      : FunctionsResponse.FulfillResult.USER_CALLBACK_ERROR;\\n\\n    Receipt memory receipt = _pay(\\n      commitment.subscriptionId,\\n      commitment.estimatedTotalCostJuels,\\n      commitment.client,\\n      commitment.adminFee,\\n      juelsPerGas,\\n      SafeCast.toUint96(result.gasUsed),\\n      costWithoutCallback\\n    );\\n\\n    emit RequestProcessed({\\n      requestId: commitment.requestId,\\n      subscriptionId: commitment.subscriptionId,\\n      totalCostJuels: receipt.totalCostJuels,\\n      transmitter: transmitter,\\n      resultCode: resultCode,\\n      response: response,\\n      err: err,\\n      callbackReturnData: result.returnData\\n    });\\n\\n    return (resultCode, receipt.callbackGasCostJuels);\\n  }\\n\\n  function _callback(\\n    bytes32 requestId,\\n    bytes memory response,\\n    bytes memory err,\\n    uint32 callbackGasLimit,\\n    address client\\n  ) private returns (CallbackResult memory) {\\n    bool destinationNoLongerExists;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      // solidity calls check that a contract actually exists at the destination, so we do the same\\n      destinationNoLongerExists := iszero(extcodesize(client))\\n    }\\n    if (destinationNoLongerExists) {\\n      // Return without attempting callback\\n      // The subscription will still be charged to reimburse transmitter's gas overhead\\n      return CallbackResult({success: false, gasUsed: 0, returnData: new bytes(0)});\\n    }\\n\\n    bytes memory encodedCallback = abi.encodeWithSelector(\\n      s_config.handleOracleFulfillmentSelector,\\n      requestId,\\n      response,\\n      err\\n    );\\n\\n    uint16 gasForCallExactCheck = s_config.gasForCallExactCheck;\\n\\n    // Call with explicitly the amount of callback gas requested\\n    // Important to not let them exhaust the gas budget and avoid payment.\\n    // NOTE: that callWithExactGas will revert if we do not have sufficient gas\\n    // to give the callee their requested amount.\\n\\n    bool success;\\n    uint256 gasUsed;\\n    // allocate return data memory ahead of time\\n    bytes memory returnData = new bytes(MAX_CALLBACK_RETURN_BYTES);\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      let g := gas()\\n      // Compute g -= gasForCallExactCheck and check for underflow\\n      // The gas actually passed to the callee is _min(gasAmount, 63//64*gas available).\\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\\n      // as we do not want to provide them with less, however that check itself costs\\n      // gas. gasForCallExactCheck ensures we have at least enough gas to be able\\n      // to revert if gasAmount >  63//64*gas available.\\n      if lt(g, gasForCallExactCheck) {\\n        revert(0, 0)\\n      }\\n      g := sub(g, gasForCallExactCheck)\\n      // if g - g//64 <= gasAmount, revert\\n      // (we subtract g//64 because of EIP-150)\\n      if iszero(gt(sub(g, div(g, 64)), callbackGasLimit)) {\\n        revert(0, 0)\\n      }\\n      // call and report whether we succeeded\\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\\n      let gasBeforeCall := gas()\\n      success := call(callbackGasLimit, client, 0, add(encodedCallback, 0x20), mload(encodedCallback), 0, 0)\\n      gasUsed := sub(gasBeforeCall, gas())\\n\\n      // limit our copy to MAX_CALLBACK_RETURN_BYTES bytes\\n      let toCopy := returndatasize()\\n      if gt(toCopy, MAX_CALLBACK_RETURN_BYTES) {\\n        toCopy := MAX_CALLBACK_RETURN_BYTES\\n      }\\n      // Store the length of the copied bytes\\n      mstore(returnData, toCopy)\\n      // copy the bytes from returnData[0:_toCopy]\\n      returndatacopy(add(returnData, 0x20), 0, toCopy)\\n    }\\n\\n    return CallbackResult({success: success, gasUsed: gasUsed, returnData: returnData});\\n  }\\n\\n  // ================================================================\\n  // |                        Route methods                         |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function getContractById(bytes32 id) public view override returns (address) {\\n    address currentImplementation = s_route[id];\\n    if (currentImplementation == address(0)) {\\n      revert RouteNotFound(id);\\n    }\\n    return currentImplementation;\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function getProposedContractById(bytes32 id) public view override returns (address) {\\n    // Iterations will not exceed MAX_PROPOSAL_SET_LENGTH\\n    for (uint8 i = 0; i < s_proposedContractSet.ids.length; ++i) {\\n      if (id == s_proposedContractSet.ids[i]) {\\n        return s_proposedContractSet.to[i];\\n      }\\n    }\\n    revert RouteNotFound(id);\\n  }\\n\\n  // ================================================================\\n  // |                 Contract Proposal methods                    |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function getProposedContractSet() external view override returns (bytes32[] memory, address[] memory) {\\n    return (s_proposedContractSet.ids, s_proposedContractSet.to);\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function proposeContractsUpdate(\\n    bytes32[] memory proposedContractSetIds,\\n    address[] memory proposedContractSetAddresses\\n  ) external override onlyOwner {\\n    // IDs and addresses arrays must be of equal length and must not exceed the max proposal length\\n    uint256 idsArrayLength = proposedContractSetIds.length;\\n    if (idsArrayLength != proposedContractSetAddresses.length || idsArrayLength > MAX_PROPOSAL_SET_LENGTH) {\\n      revert InvalidProposal();\\n    }\\n\\n    // NOTE: iterations of this loop will not exceed MAX_PROPOSAL_SET_LENGTH\\n    for (uint256 i = 0; i < idsArrayLength; ++i) {\\n      bytes32 id = proposedContractSetIds[i];\\n      address proposedContract = proposedContractSetAddresses[i];\\n      if (\\n        proposedContract == address(0) || // The Proposed address must be a valid address\\n        s_route[id] == proposedContract // The Proposed address must point to a different address than what is currently set\\n      ) {\\n        revert InvalidProposal();\\n      }\\n\\n      emit ContractProposed({\\n        proposedContractSetId: id,\\n        proposedContractSetFromAddress: s_route[id],\\n        proposedContractSetToAddress: proposedContract\\n      });\\n    }\\n\\n    s_proposedContractSet = ContractProposalSet({ids: proposedContractSetIds, to: proposedContractSetAddresses});\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function updateContracts() external override onlyOwner {\\n    // Iterations will not exceed MAX_PROPOSAL_SET_LENGTH\\n    for (uint256 i = 0; i < s_proposedContractSet.ids.length; ++i) {\\n      bytes32 id = s_proposedContractSet.ids[i];\\n      address to = s_proposedContractSet.to[i];\\n      emit ContractUpdated({id: id, from: s_route[id], to: to});\\n      s_route[id] = to;\\n    }\\n\\n    delete s_proposedContractSet;\\n  }\\n\\n  // ================================================================\\n  // |                           Modifiers                          |\\n  // ================================================================\\n  // Favoring internal functions over actual modifiers to reduce contract size\\n\\n  /// @dev Used within FunctionsSubscriptions.sol\\n  function _whenNotPaused() internal view override {\\n    _requireNotPaused();\\n  }\\n\\n  /// @dev Used within FunctionsSubscriptions.sol\\n  function _onlyRouterOwner() internal view override {\\n    _validateOwnership();\\n  }\\n\\n  /// @dev Used within FunctionsSubscriptions.sol\\n  function _onlySenderThatAcceptedToS() internal view override {\\n    address currentImplementation = s_route[s_allowListId];\\n    if (currentImplementation == address(0)) {\\n      // If not set, ignore this check, allow all access\\n      return;\\n    }\\n    if (!IAccessController(currentImplementation).hasAccess(msg.sender, new bytes(0))) {\\n      revert SenderMustAcceptTermsOfService(msg.sender);\\n    }\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function pause() external override onlyOwner {\\n    _pause();\\n  }\\n\\n  /// @inheritdoc IFunctionsRouter\\n  function unpause() external override onlyOwner {\\n    _unpause();\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/FunctionsSubscriptions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IFunctionsSubscriptions} from \\\"./interfaces/IFunctionsSubscriptions.sol\\\";\\nimport {IERC677Receiver} from \\\"../../../shared/interfaces/IERC677Receiver.sol\\\";\\nimport {LinkTokenInterface} from \\\"../../../shared/interfaces/LinkTokenInterface.sol\\\";\\nimport {IFunctionsBilling} from \\\"./interfaces/IFunctionsBilling.sol\\\";\\nimport {IFunctionsRouter} from \\\"./interfaces/IFunctionsRouter.sol\\\";\\n\\nimport {FunctionsResponse} from \\\"./libraries/FunctionsResponse.sol\\\";\\n\\nimport {IERC20} from \\\"../../../vendor/openzeppelin-solidity/v4.8.0/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"../../../vendor/openzeppelin-solidity/v4.8.0/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {SafeCast} from \\\"../../../vendor/openzeppelin-solidity/v4.8.0/contracts/utils/math/SafeCast.sol\\\";\\n\\n/// @title Functions Subscriptions contract\\n/// @notice Contract that coordinates payment from users to the nodes of the Decentralized Oracle Network (DON).\\n/// @dev THIS CONTRACT HAS NOT GONE THROUGH ANY SECURITY REVIEW. DO NOT USE IN PROD.\\nabstract contract FunctionsSubscriptions is IFunctionsSubscriptions, IERC677Receiver {\\n  using SafeERC20 for IERC20;\\n  using FunctionsResponse for FunctionsResponse.Commitment;\\n\\n  // ================================================================\\n  // |                         Balance state                        |\\n  // ================================================================\\n  // link token address\\n  IERC20 internal immutable i_linkToken;\\n\\n  // s_totalLinkBalance tracks the total LINK sent to/from\\n  // this contract through onTokenTransfer, cancelSubscription and oracleWithdraw.\\n  // A discrepancy with this contract's LINK balance indicates that someone\\n  // sent tokens using transfer and so we may need to use recoverFunds.\\n  uint96 private s_totalLinkBalance;\\n\\n  /// @dev NOP balances are held as a single amount. The breakdown is held by the Coordinator.\\n  mapping(address coordinator => uint96 balanceJuelsLink) private s_withdrawableTokens;\\n\\n  // ================================================================\\n  // |                      Subscription state                      |\\n  // ================================================================\\n  // Keep a count of the number of subscriptions so that its possible to\\n  // loop through all the current subscriptions via .getSubscription().\\n  uint64 private s_currentSubscriptionId;\\n\\n  mapping(uint64 subscriptionId => Subscription) private s_subscriptions;\\n\\n  // Maintains the list of keys in s_consumers.\\n  // We do this for 2 reasons:\\n  // 1. To be able to clean up all keys from s_consumers when canceling a subscription.\\n  // 2. To be able to return the list of all consumers in getSubscription.\\n  // Note that we need the s_consumers map to be able to directly check if a\\n  // consumer is valid without reading all the consumers from storage.\\n  mapping(address consumer => mapping(uint64 subscriptionId => Consumer)) private s_consumers;\\n\\n  event SubscriptionCreated(uint64 indexed subscriptionId, address owner);\\n  event SubscriptionFunded(uint64 indexed subscriptionId, uint256 oldBalance, uint256 newBalance);\\n  event SubscriptionConsumerAdded(uint64 indexed subscriptionId, address consumer);\\n  event SubscriptionConsumerRemoved(uint64 indexed subscriptionId, address consumer);\\n  event SubscriptionCanceled(uint64 indexed subscriptionId, address fundsRecipient, uint256 fundsAmount);\\n  event SubscriptionOwnerTransferRequested(uint64 indexed subscriptionId, address from, address to);\\n  event SubscriptionOwnerTransferred(uint64 indexed subscriptionId, address from, address to);\\n\\n  error TooManyConsumers(uint16 maximumConsumers);\\n  error InsufficientBalance(uint96 currentBalanceJuels);\\n  error InvalidConsumer();\\n  error CannotRemoveWithPendingRequests();\\n  error InvalidSubscription();\\n  error OnlyCallableFromLink();\\n  error InvalidCalldata();\\n  error MustBeSubscriptionOwner();\\n  error TimeoutNotExceeded();\\n  error MustBeProposedOwner(address proposedOwner);\\n  event FundsRecovered(address to, uint256 amount);\\n\\n  // ================================================================\\n  // |                       Request state                          |\\n  // ================================================================\\n\\n  mapping(bytes32 requestId => bytes32 commitmentHash) internal s_requestCommitments;\\n\\n  struct Receipt {\\n    uint96 callbackGasCostJuels;\\n    uint96 totalCostJuels;\\n  }\\n\\n  event RequestTimedOut(bytes32 indexed requestId);\\n\\n  // ================================================================\\n  // |                       Initialization                         |\\n  // ================================================================\\n  constructor(address link) {\\n    i_linkToken = IERC20(link);\\n  }\\n\\n  // ================================================================\\n  // |                      Request/Response                        |\\n  // ================================================================\\n\\n  /// @notice Sets a request as in-flight\\n  /// @dev Only callable within the Router\\n  function _markRequestInFlight(address client, uint64 subscriptionId, uint96 estimatedTotalCostJuels) internal {\\n    // Earmark subscription funds\\n    s_subscriptions[subscriptionId].blockedBalance += estimatedTotalCostJuels;\\n\\n    // Increment sent requests\\n    s_consumers[client][subscriptionId].initiatedRequests += 1;\\n  }\\n\\n  /// @notice Moves funds from one subscription account to another.\\n  /// @dev Only callable by the Coordinator contract that is saved in the request commitment\\n  function _pay(\\n    uint64 subscriptionId,\\n    uint96 estimatedTotalCostJuels,\\n    address client,\\n    uint96 adminFee,\\n    uint96 juelsPerGas,\\n    uint96 gasUsed,\\n    uint96 costWithoutCallbackJuels\\n  ) internal returns (Receipt memory) {\\n    uint96 callbackGasCostJuels = juelsPerGas * gasUsed;\\n    uint96 totalCostJuels = costWithoutCallbackJuels + adminFee + callbackGasCostJuels;\\n\\n    if (\\n      s_subscriptions[subscriptionId].balance < totalCostJuels ||\\n      s_subscriptions[subscriptionId].blockedBalance < estimatedTotalCostJuels\\n    ) {\\n      revert InsufficientBalance(s_subscriptions[subscriptionId].balance);\\n    }\\n\\n    // Charge the subscription\\n    s_subscriptions[subscriptionId].balance -= totalCostJuels;\\n\\n    // Unblock earmarked funds\\n    s_subscriptions[subscriptionId].blockedBalance -= estimatedTotalCostJuels;\\n\\n    // Pay the DON's fees and gas reimbursement\\n    s_withdrawableTokens[msg.sender] += costWithoutCallbackJuels + callbackGasCostJuels;\\n\\n    // Pay out the administration fee\\n    s_withdrawableTokens[address(this)] += adminFee;\\n\\n    // Increment finished requests\\n    s_consumers[client][subscriptionId].completedRequests += 1;\\n\\n    return Receipt({callbackGasCostJuels: callbackGasCostJuels, totalCostJuels: totalCostJuels});\\n  }\\n\\n  // ================================================================\\n  // |                      Owner methods                           |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function ownerCancelSubscription(uint64 subscriptionId) external override {\\n    _onlyRouterOwner();\\n    _isExistingSubscription(subscriptionId);\\n    _cancelSubscriptionHelper(subscriptionId, s_subscriptions[subscriptionId].owner, false);\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function recoverFunds(address to) external override {\\n    _onlyRouterOwner();\\n    uint256 externalBalance = i_linkToken.balanceOf(address(this));\\n    uint256 internalBalance = uint256(s_totalLinkBalance);\\n    if (internalBalance < externalBalance) {\\n      uint256 amount = externalBalance - internalBalance;\\n      i_linkToken.safeTransfer(to, amount);\\n      emit FundsRecovered(to, amount);\\n    }\\n    // If the balances are equal, nothing to be done.\\n  }\\n\\n  // ================================================================\\n  // |                      Fund withdrawal                         |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function oracleWithdraw(address recipient, uint96 amount) external override {\\n    _whenNotPaused();\\n\\n    if (amount == 0) {\\n      revert InvalidCalldata();\\n    }\\n    uint96 currentBalance = s_withdrawableTokens[msg.sender];\\n    if (currentBalance < amount) {\\n      revert InsufficientBalance(currentBalance);\\n    }\\n    s_withdrawableTokens[msg.sender] -= amount;\\n    s_totalLinkBalance -= amount;\\n    i_linkToken.safeTransfer(recipient, amount);\\n  }\\n\\n  /// @notice Owner withdraw LINK earned through admin fees\\n  /// @notice If amount is 0 the full balance will be withdrawn\\n  /// @param recipient where to send the funds\\n  /// @param amount amount to withdraw\\n  function ownerWithdraw(address recipient, uint96 amount) external {\\n    _onlyRouterOwner();\\n    if (amount == 0) {\\n      amount = s_withdrawableTokens[address(this)];\\n    }\\n    uint96 currentBalance = s_withdrawableTokens[address(this)];\\n    if (currentBalance < amount) {\\n      revert InsufficientBalance(currentBalance);\\n    }\\n    s_withdrawableTokens[address(this)] -= amount;\\n    s_totalLinkBalance -= amount;\\n\\n    i_linkToken.safeTransfer(recipient, amount);\\n  }\\n\\n  // ================================================================\\n  // |                TransferAndCall Deposit helper                |\\n  // ================================================================\\n\\n  // This function is to be invoked when using LINK.transferAndCall\\n  /// @dev Note to fund the subscription, use transferAndCall. For example\\n  /// @dev  LINKTOKEN.transferAndCall(\\n  /// @dev    address(ROUTER),\\n  /// @dev    amount,\\n  /// @dev    abi.encode(subscriptionId));\\n  function onTokenTransfer(address /* sender */, uint256 amount, bytes calldata data) external override {\\n    _whenNotPaused();\\n    if (msg.sender != address(i_linkToken)) {\\n      revert OnlyCallableFromLink();\\n    }\\n    if (data.length != 32) {\\n      revert InvalidCalldata();\\n    }\\n    uint64 subscriptionId = abi.decode(data, (uint64));\\n    if (s_subscriptions[subscriptionId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    // We do not check that the msg.sender is the subscription owner,\\n    // anyone can fund a subscription.\\n    uint256 oldBalance = s_subscriptions[subscriptionId].balance;\\n    s_subscriptions[subscriptionId].balance += uint96(amount);\\n    s_totalLinkBalance += uint96(amount);\\n    emit SubscriptionFunded(subscriptionId, oldBalance, oldBalance + amount);\\n  }\\n\\n  // ================================================================\\n  // |                   Subscription management                   |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function getTotalBalance() external view override returns (uint96) {\\n    return s_totalLinkBalance;\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function getSubscriptionCount() external view override returns (uint64) {\\n    return s_currentSubscriptionId;\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function getSubscription(uint64 subscriptionId) public view override returns (Subscription memory) {\\n    _isExistingSubscription(subscriptionId);\\n    return s_subscriptions[subscriptionId];\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function getSubscriptionsInRange(\\n    uint64 subscriptionIdStart,\\n    uint64 subscriptionIdEnd\\n  ) external view override returns (Subscription[] memory subscriptions) {\\n    if (\\n      subscriptionIdStart > subscriptionIdEnd ||\\n      subscriptionIdEnd > s_currentSubscriptionId ||\\n      s_currentSubscriptionId == 0\\n    ) {\\n      revert InvalidCalldata();\\n    }\\n\\n    subscriptions = new Subscription[]((subscriptionIdEnd - subscriptionIdStart) + 1);\\n    for (uint256 i = 0; i <= subscriptionIdEnd - subscriptionIdStart; ++i) {\\n      subscriptions[i] = s_subscriptions[uint64(subscriptionIdStart + i)];\\n    }\\n\\n    return subscriptions;\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function getConsumer(address client, uint64 subscriptionId) public view override returns (Consumer memory) {\\n    return s_consumers[client][subscriptionId];\\n  }\\n\\n  /// @dev Used within this file & FunctionsRouter.sol\\n  function _isExistingSubscription(uint64 subscriptionId) internal view {\\n    if (s_subscriptions[subscriptionId].owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n  }\\n\\n  /// @dev Used within FunctionsRouter.sol\\n  function _isAllowedConsumer(address client, uint64 subscriptionId) internal view {\\n    if (!s_consumers[client][subscriptionId].allowed) {\\n      revert InvalidConsumer();\\n    }\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function createSubscription() external override returns (uint64 subscriptionId) {\\n    _whenNotPaused();\\n    _onlySenderThatAcceptedToS();\\n\\n    subscriptionId = ++s_currentSubscriptionId;\\n    s_subscriptions[subscriptionId] = Subscription({\\n      balance: 0,\\n      blockedBalance: 0,\\n      owner: msg.sender,\\n      proposedOwner: address(0),\\n      consumers: new address[](0),\\n      flags: bytes32(0)\\n    });\\n\\n    emit SubscriptionCreated(subscriptionId, msg.sender);\\n\\n    return subscriptionId;\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function createSubscriptionWithConsumer(address consumer) external override returns (uint64 subscriptionId) {\\n    _whenNotPaused();\\n    _onlySenderThatAcceptedToS();\\n\\n    subscriptionId = ++s_currentSubscriptionId;\\n    s_subscriptions[subscriptionId] = Subscription({\\n      balance: 0,\\n      blockedBalance: 0,\\n      owner: msg.sender,\\n      proposedOwner: address(0),\\n      consumers: new address[](0),\\n      flags: bytes32(0)\\n    });\\n\\n    s_subscriptions[subscriptionId].consumers.push(consumer);\\n    s_consumers[consumer][subscriptionId].allowed = true;\\n\\n    emit SubscriptionCreated(subscriptionId, msg.sender);\\n    emit SubscriptionConsumerAdded(subscriptionId, consumer);\\n\\n    return subscriptionId;\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function proposeSubscriptionOwnerTransfer(uint64 subscriptionId, address newOwner) external override {\\n    _whenNotPaused();\\n    _onlySubscriptionOwner(subscriptionId);\\n    _onlySenderThatAcceptedToS();\\n\\n    if (newOwner == address(0) || s_subscriptions[subscriptionId].proposedOwner == newOwner) {\\n      revert InvalidCalldata();\\n    }\\n\\n    s_subscriptions[subscriptionId].proposedOwner = newOwner;\\n    emit SubscriptionOwnerTransferRequested(subscriptionId, msg.sender, newOwner);\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function acceptSubscriptionOwnerTransfer(uint64 subscriptionId) external override {\\n    _whenNotPaused();\\n    _onlySenderThatAcceptedToS();\\n\\n    address previousOwner = s_subscriptions[subscriptionId].owner;\\n    address proposedOwner = s_subscriptions[subscriptionId].proposedOwner;\\n    if (proposedOwner != msg.sender) {\\n      revert MustBeProposedOwner(proposedOwner);\\n    }\\n    s_subscriptions[subscriptionId].owner = msg.sender;\\n    s_subscriptions[subscriptionId].proposedOwner = address(0);\\n    emit SubscriptionOwnerTransferred(subscriptionId, previousOwner, msg.sender);\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function removeConsumer(uint64 subscriptionId, address consumer) external override {\\n    _whenNotPaused();\\n    _onlySubscriptionOwner(subscriptionId);\\n    _onlySenderThatAcceptedToS();\\n\\n    Consumer memory consumerData = s_consumers[consumer][subscriptionId];\\n    _isAllowedConsumer(consumer, subscriptionId);\\n    if (consumerData.initiatedRequests != consumerData.completedRequests) {\\n      revert CannotRemoveWithPendingRequests();\\n    }\\n    // Note bounded by config.maxConsumers\\n    address[] memory consumers = s_subscriptions[subscriptionId].consumers;\\n    for (uint256 i = 0; i < consumers.length; ++i) {\\n      if (consumers[i] == consumer) {\\n        // Storage write to preserve last element\\n        s_subscriptions[subscriptionId].consumers[i] = consumers[consumers.length - 1];\\n        // Storage remove last element\\n        s_subscriptions[subscriptionId].consumers.pop();\\n        break;\\n      }\\n    }\\n    delete s_consumers[consumer][subscriptionId];\\n    emit SubscriptionConsumerRemoved(subscriptionId, consumer);\\n  }\\n\\n  /// @dev Overriden in FunctionsRouter.sol\\n  function _getMaxConsumers() internal view virtual returns (uint16);\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function addConsumer(uint64 subscriptionId, address consumer) external override {\\n    _whenNotPaused();\\n    _onlySubscriptionOwner(subscriptionId);\\n    _onlySenderThatAcceptedToS();\\n\\n    // Already maxed, cannot add any more consumers.\\n    uint16 maximumConsumers = _getMaxConsumers();\\n    if (s_subscriptions[subscriptionId].consumers.length >= maximumConsumers) {\\n      revert TooManyConsumers(maximumConsumers);\\n    }\\n    if (s_consumers[consumer][subscriptionId].allowed) {\\n      // Idempotence - do nothing if already added.\\n      // Ensures uniqueness in s_subscriptions[subscriptionId].consumers.\\n      return;\\n    }\\n\\n    s_consumers[consumer][subscriptionId].allowed = true;\\n    s_subscriptions[subscriptionId].consumers.push(consumer);\\n\\n    emit SubscriptionConsumerAdded(subscriptionId, consumer);\\n  }\\n\\n  /// @dev Overriden in FunctionsRouter.sol\\n  function _getSubscriptionDepositDetails() internal virtual returns (uint16, uint72);\\n\\n  function _cancelSubscriptionHelper(uint64 subscriptionId, address toAddress, bool checkDepositRefundability) private {\\n    Subscription memory subscription = s_subscriptions[subscriptionId];\\n    uint96 balance = subscription.balance;\\n    uint64 completedRequests = 0;\\n\\n    // NOTE: loop iterations are bounded by config.maxConsumers\\n    // If no consumers, does nothing.\\n    for (uint256 i = 0; i < subscription.consumers.length; ++i) {\\n      address consumer = subscription.consumers[i];\\n      completedRequests += s_consumers[consumer][subscriptionId].completedRequests;\\n      delete s_consumers[consumer][subscriptionId];\\n    }\\n    delete s_subscriptions[subscriptionId];\\n\\n    (uint16 subscriptionDepositMinimumRequests, uint72 subscriptionDepositJuels) = _getSubscriptionDepositDetails();\\n\\n    // If subscription has not made enough requests, deposit will be forfeited\\n    if (checkDepositRefundability && completedRequests < subscriptionDepositMinimumRequests) {\\n      uint96 deposit = subscriptionDepositJuels > balance ? balance : subscriptionDepositJuels;\\n      if (deposit > 0) {\\n        s_withdrawableTokens[address(this)] += deposit;\\n        balance -= deposit;\\n      }\\n    }\\n\\n    if (balance > 0) {\\n      s_totalLinkBalance -= balance;\\n      i_linkToken.safeTransfer(toAddress, uint256(balance));\\n    }\\n    emit SubscriptionCanceled(subscriptionId, toAddress, balance);\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function cancelSubscription(uint64 subscriptionId, address to) external override {\\n    _whenNotPaused();\\n    _onlySubscriptionOwner(subscriptionId);\\n    _onlySenderThatAcceptedToS();\\n\\n    if (pendingRequestExists(subscriptionId)) {\\n      revert CannotRemoveWithPendingRequests();\\n    }\\n\\n    _cancelSubscriptionHelper(subscriptionId, to, true);\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function pendingRequestExists(uint64 subscriptionId) public view override returns (bool) {\\n    address[] memory consumers = s_subscriptions[subscriptionId].consumers;\\n    // NOTE: loop iterations are bounded by config.maxConsumers\\n    for (uint256 i = 0; i < consumers.length; ++i) {\\n      Consumer memory consumer = s_consumers[consumers[i]][subscriptionId];\\n      if (consumer.initiatedRequests != consumer.completedRequests) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function setFlags(uint64 subscriptionId, bytes32 flags) external override {\\n    _onlyRouterOwner();\\n    _isExistingSubscription(subscriptionId);\\n    s_subscriptions[subscriptionId].flags = flags;\\n  }\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function getFlags(uint64 subscriptionId) public view returns (bytes32) {\\n    return s_subscriptions[subscriptionId].flags;\\n  }\\n\\n  // ================================================================\\n  // |                        Request Timeout                       |\\n  // ================================================================\\n\\n  /// @inheritdoc IFunctionsSubscriptions\\n  function timeoutRequests(FunctionsResponse.Commitment[] calldata requestsToTimeoutByCommitment) external override {\\n    _whenNotPaused();\\n\\n    for (uint256 i = 0; i < requestsToTimeoutByCommitment.length; ++i) {\\n      FunctionsResponse.Commitment memory request = requestsToTimeoutByCommitment[i];\\n      bytes32 requestId = request.requestId;\\n      uint64 subscriptionId = request.subscriptionId;\\n\\n      // Check that request ID is valid\\n      if (keccak256(abi.encode(request)) != s_requestCommitments[requestId]) {\\n        revert InvalidCalldata();\\n      }\\n\\n      // Check that request has exceeded allowed request time\\n      if (block.timestamp < request.timeoutTimestamp) {\\n        revert TimeoutNotExceeded();\\n      }\\n\\n      // Notify the Coordinator that the request should no longer be fulfilled\\n      IFunctionsBilling(request.coordinator).deleteCommitment(requestId);\\n      // Release the subscription's balance that had been earmarked for the request\\n      s_subscriptions[subscriptionId].blockedBalance -= request.estimatedTotalCostJuels;\\n      s_consumers[request.client][subscriptionId].completedRequests += 1;\\n      // Delete commitment within Router state\\n      delete s_requestCommitments[requestId];\\n\\n      emit RequestTimedOut(requestId);\\n    }\\n  }\\n\\n  // ================================================================\\n  // |                         Modifiers                            |\\n  // ================================================================\\n\\n  function _onlySubscriptionOwner(uint64 subscriptionId) internal view {\\n    address owner = s_subscriptions[subscriptionId].owner;\\n    if (owner == address(0)) {\\n      revert InvalidSubscription();\\n    }\\n    if (msg.sender != owner) {\\n      revert MustBeSubscriptionOwner();\\n    }\\n  }\\n\\n  /// @dev Overriden in FunctionsRouter.sol\\n  function _onlySenderThatAcceptedToS() internal virtual;\\n\\n  /// @dev Overriden in FunctionsRouter.sol\\n  function _onlyRouterOwner() internal virtual;\\n\\n  /// @dev Overriden in FunctionsRouter.sol\\n  function _whenNotPaused() internal virtual;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/Routable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {ITypeAndVersion} from \\\"../../../shared/interfaces/ITypeAndVersion.sol\\\";\\nimport {IOwnableFunctionsRouter} from \\\"./interfaces/IOwnableFunctionsRouter.sol\\\";\\n\\n/// @title This abstract should be inherited by contracts that will be used\\n/// as the destinations to a route (id=>contract) on the Router.\\n/// It provides a Router getter and modifiers.\\nabstract contract Routable is ITypeAndVersion {\\n  IOwnableFunctionsRouter private immutable i_router;\\n\\n  error RouterMustBeSet();\\n  error OnlyCallableByRouter();\\n  error OnlyCallableByRouterOwner();\\n\\n  /// @dev Initializes the contract.\\n  constructor(address router) {\\n    if (router == address(0)) {\\n      revert RouterMustBeSet();\\n    }\\n    i_router = IOwnableFunctionsRouter(router);\\n  }\\n\\n  /// @notice Return the Router\\n  function _getRouter() internal view returns (IOwnableFunctionsRouter router) {\\n    return i_router;\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the router.\\n  modifier onlyRouter() {\\n    if (msg.sender != address(i_router)) {\\n      revert OnlyCallableByRouter();\\n    }\\n    _;\\n  }\\n\\n  /// @notice Reverts if called by anyone other than the router owner.\\n  modifier onlyRouterOwner() {\\n    if (msg.sender != i_router.owner()) {\\n      revert OnlyCallableByRouterOwner();\\n    }\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/accessControl/TermsOfServiceAllowList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {ITermsOfServiceAllowList} from \\\"./interfaces/ITermsOfServiceAllowList.sol\\\";\\nimport {IAccessController} from \\\"../../../../shared/interfaces/IAccessController.sol\\\";\\nimport {ITypeAndVersion} from \\\"../../../../shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nimport {ConfirmedOwner} from \\\"../../../../shared/access/ConfirmedOwner.sol\\\";\\n\\nimport {Address} from \\\"../../../../vendor/openzeppelin-solidity/v4.8.0/contracts/utils/Address.sol\\\";\\nimport {EnumerableSet} from \\\"../../../../vendor/openzeppelin-solidity/v4.8.0/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\n/// @notice A contract to handle access control of subscription management dependent on signing a Terms of Service\\ncontract TermsOfServiceAllowList is ITermsOfServiceAllowList, IAccessController, ITypeAndVersion, ConfirmedOwner {\\n  using Address for address;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /// @inheritdoc ITypeAndVersion\\n  string public constant override typeAndVersion = \\\"Functions Terms of Service Allow List v1.0.0\\\";\\n\\n  EnumerableSet.AddressSet private s_allowedSenders;\\n  mapping(address => bool) private s_blockedSenders;\\n\\n  event AddedAccess(address user);\\n  event BlockedAccess(address user);\\n  event UnblockedAccess(address user);\\n\\n  error InvalidSignature();\\n  error InvalidUsage();\\n  error RecipientIsBlocked();\\n\\n  // ================================================================\\n  // |                     Configuration state                      |\\n  // ================================================================\\n  struct Config {\\n    bool enabled; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 When enabled, access will be checked against s_allowedSenders. When disabled, all access will be allowed.\\n    address signerPublicKey; // \u2550\u2550\u255d The key pair that needs to sign the acceptance data\\n  }\\n\\n  Config private s_config;\\n\\n  event ConfigUpdated(Config config);\\n\\n  // ================================================================\\n  // |                       Initialization                         |\\n  // ================================================================\\n\\n  constructor(Config memory config) ConfirmedOwner(msg.sender) {\\n    updateConfig(config);\\n  }\\n\\n  // ================================================================\\n  // |                        Configuration                         |\\n  // ================================================================\\n\\n  /// @notice Gets the contracts's configuration\\n  /// @return config\\n  function getConfig() external view returns (Config memory) {\\n    return s_config;\\n  }\\n\\n  /// @notice Sets the contracts's configuration\\n  /// @param config - See the contents of the TermsOfServiceAllowList.Config struct for more information\\n  function updateConfig(Config memory config) public onlyOwner {\\n    s_config = config;\\n    emit ConfigUpdated(config);\\n  }\\n\\n  // ================================================================\\n  // |                      Allow methods                           |\\n  // ================================================================\\n\\n  /// @inheritdoc ITermsOfServiceAllowList\\n  function getMessage(address acceptor, address recipient) public pure override returns (bytes32) {\\n    return keccak256(abi.encodePacked(acceptor, recipient));\\n  }\\n\\n  /// @inheritdoc ITermsOfServiceAllowList\\n  function acceptTermsOfService(address acceptor, address recipient, bytes32 r, bytes32 s, uint8 v) external override {\\n    if (s_blockedSenders[recipient]) {\\n      revert RecipientIsBlocked();\\n    }\\n\\n    // Validate that the signature is correct and the correct data has been signed\\n    bytes32 prefixedMessage = keccak256(\\n      abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", getMessage(acceptor, recipient))\\n    );\\n    if (ecrecover(prefixedMessage, v, r, s) != s_config.signerPublicKey) {\\n      revert InvalidSignature();\\n    }\\n\\n    // If contract, validate that msg.sender == recipient\\n    // This is to prevent EoAs from claiming contracts that they are not in control of\\n    // If EoA, validate that msg.sender == acceptor == recipient\\n    // This is to prevent EoAs from accepting for other EoAs\\n    if (msg.sender != recipient || (msg.sender != acceptor && !msg.sender.isContract())) {\\n      revert InvalidUsage();\\n    }\\n\\n    // Add recipient to the allow list\\n    s_allowedSenders.add(recipient);\\n    emit AddedAccess(recipient);\\n  }\\n\\n  /// @inheritdoc ITermsOfServiceAllowList\\n  function getAllAllowedSenders() external view override returns (address[] memory) {\\n    return s_allowedSenders.values();\\n  }\\n\\n  /// @inheritdoc IAccessController\\n  function hasAccess(address user, bytes calldata /* data */) external view override returns (bool) {\\n    if (!s_config.enabled) {\\n      return true;\\n    }\\n    return s_allowedSenders.contains(user);\\n  }\\n\\n  // ================================================================\\n  // |                         Block methods                        |\\n  // ================================================================\\n\\n  /// @inheritdoc ITermsOfServiceAllowList\\n  function isBlockedSender(address sender) external view override returns (bool) {\\n    if (!s_config.enabled) {\\n      return false;\\n    }\\n    return s_blockedSenders[sender];\\n  }\\n\\n  /// @inheritdoc ITermsOfServiceAllowList\\n  function blockSender(address sender) external override onlyOwner {\\n    s_allowedSenders.remove(sender);\\n    s_blockedSenders[sender] = true;\\n    emit BlockedAccess(sender);\\n  }\\n\\n  /// @inheritdoc ITermsOfServiceAllowList\\n  function unblockSender(address sender) external override onlyOwner {\\n    s_blockedSenders[sender] = false;\\n    emit UnblockedAccess(sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/accessControl/interfaces/ITermsOfServiceAllowList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @notice A contract to handle access control of subscription management dependent on signing a Terms of Service\\ninterface ITermsOfServiceAllowList {\\n  /// @notice Return the message data for the proof given to accept the Terms of Service\\n  /// @param acceptor - The wallet address that has accepted the Terms of Service on the UI\\n  /// @param recipient - The recipient address that the acceptor is taking responsibility for\\n  /// @return Hash of the message data\\n  function getMessage(address acceptor, address recipient) external pure returns (bytes32);\\n\\n  /// @notice Check if the address is blocked for usage\\n  /// @param sender The transaction sender's address\\n  /// @return True or false\\n  function isBlockedSender(address sender) external returns (bool);\\n\\n  /// @notice Get a list of all allowed senders\\n  /// @dev WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n  /// to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n  /// this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n  /// uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n  /// @return addresses - all allowed addresses\\n  function getAllAllowedSenders() external view returns (address[] memory);\\n\\n  /// @notice Allows access to the sender based on acceptance of the Terms of Service\\n  /// @param acceptor - The wallet address that has accepted the Terms of Service on the UI\\n  /// @param recipient - The recipient address that the acceptor is taking responsibility for\\n  /// @param r - ECDSA signature r data produced by the Chainlink Functions Subscription UI\\n  /// @param s - ECDSA signature s produced by the Chainlink Functions Subscription UI\\n  /// @param v - ECDSA signature v produced by the Chainlink Functions Subscription UI\\n  function acceptTermsOfService(address acceptor, address recipient, bytes32 r, bytes32 s, uint8 v) external;\\n\\n  /// @notice Removes a sender's access if already authorized, and disallows re-accepting the Terms of Service\\n  /// @param sender - Address of the sender to block\\n  function blockSender(address sender) external;\\n\\n  /// @notice Re-allows a previously blocked sender to accept the Terms of Service\\n  /// @param sender - Address of the sender to unblock\\n  function unblockSender(address sender) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/example/FunctionsClientExample.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {FunctionsClient} from \\\"../FunctionsClient.sol\\\";\\nimport {ConfirmedOwner} from \\\"../../../../shared/access/ConfirmedOwner.sol\\\";\\nimport {FunctionsRequest} from \\\"../libraries/FunctionsRequest.sol\\\";\\n\\n/// @title Chainlink Functions example Client contract implementation\\ncontract FunctionsClientExample is FunctionsClient, ConfirmedOwner {\\n  using FunctionsRequest for FunctionsRequest.Request;\\n\\n  uint32 public constant MAX_CALLBACK_GAS = 70_000;\\n\\n  bytes32 public s_lastRequestId;\\n  bytes32 public s_lastResponse;\\n  bytes32 public s_lastError;\\n  uint32 public s_lastResponseLength;\\n  uint32 public s_lastErrorLength;\\n\\n  error UnexpectedRequestID(bytes32 requestId);\\n\\n  constructor(address router) FunctionsClient(router) ConfirmedOwner(msg.sender) {}\\n\\n  /// @notice Send a simple request\\n  /// @param source JavaScript source code\\n  /// @param encryptedSecretsReferences Encrypted secrets payload\\n  /// @param args List of arguments accessible from within the source code\\n  /// @param subscriptionId Billing ID\\n  function sendRequest(\\n    string calldata source,\\n    bytes calldata encryptedSecretsReferences,\\n    string[] calldata args,\\n    uint64 subscriptionId,\\n    bytes32 jobId\\n  ) external onlyOwner {\\n    FunctionsRequest.Request memory req;\\n    req.initializeRequestForInlineJavaScript(source);\\n    if (encryptedSecretsReferences.length > 0) req.addSecretsReference(encryptedSecretsReferences);\\n    if (args.length > 0) req.setArgs(args);\\n    s_lastRequestId = _sendRequest(req.encodeCBOR(), subscriptionId, MAX_CALLBACK_GAS, jobId);\\n  }\\n\\n  /// @notice Store latest result/error\\n  /// @param requestId The request ID, returned by sendRequest()\\n  /// @param response Aggregated response from the user code\\n  /// @param err Aggregated error from the user code or from the execution pipeline\\n  /// @dev Either response or error parameter will be set, but never both\\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal override {\\n    if (s_lastRequestId != requestId) {\\n      revert UnexpectedRequestID(requestId);\\n    }\\n    // Save only the first 32 bytes of response/error to always fit within MAX_CALLBACK_GAS\\n    s_lastResponse = bytesToBytes32(response);\\n    s_lastResponseLength = uint32(response.length);\\n    s_lastError = bytesToBytes32(err);\\n    s_lastErrorLength = uint32(err.length);\\n  }\\n\\n  function bytesToBytes32(bytes memory b) private pure returns (bytes32 out) {\\n    uint256 maxLen = 32;\\n    if (b.length < 32) {\\n      maxLen = b.length;\\n    }\\n    for (uint256 i = 0; i < maxLen; ++i) {\\n      out |= bytes32(b[i]) >> (i * 8);\\n    }\\n    return out;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/interfaces/IFunctionsBilling.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @title Chainlink Functions DON billing interface.\\ninterface IFunctionsBilling {\\n  /// @notice Return the current conversion from WEI of ETH to LINK from the configured Chainlink data feed\\n  /// @return weiPerUnitLink - The amount of WEI in one LINK\\n  function getWeiPerUnitLink() external view returns (uint256);\\n\\n  /// @notice Determine the fee that will be split between Node Operators for servicing a request\\n  /// @param requestCBOR - CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\\n  /// @return fee - Cost in Juels (1e18) of LINK\\n  function getDONFee(bytes memory requestCBOR) external view returns (uint72);\\n\\n  /// @notice Determine the fee that will be paid to the Router owner for operating the network\\n  /// @return fee - Cost in Juels (1e18) of LINK\\n  function getAdminFee() external view returns (uint72);\\n\\n  /// @notice Estimate the total cost that will be charged to a subscription to make a request: transmitter gas re-reimbursement, plus DON fee, plus Registry fee\\n  /// @param - subscriptionId An identifier of the billing account\\n  /// @param - data Encoded Chainlink Functions request data, use FunctionsClient API to encode a request\\n  /// @param - callbackGasLimit Gas limit for the fulfillment callback\\n  /// @param - gasPriceWei The blockchain's gas price to estimate with\\n  /// @return - billedCost Cost in Juels (1e18) of LINK\\n  function estimateCost(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint32 callbackGasLimit,\\n    uint256 gasPriceWei\\n  ) external view returns (uint96);\\n\\n  /// @notice Remove a request commitment that the Router has determined to be stale\\n  /// @param requestId - The request ID to remove\\n  function deleteCommitment(bytes32 requestId) external;\\n\\n  /// @notice Oracle withdraw LINK earned through fulfilling requests\\n  /// @notice If amount is 0 the full balance will be withdrawn\\n  /// @param recipient where to send the funds\\n  /// @param amount amount to withdraw\\n  function oracleWithdraw(address recipient, uint96 amount) external;\\n\\n  /// @notice Withdraw all LINK earned by Oracles through fulfilling requests\\n  function oracleWithdrawAll() external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/interfaces/IFunctionsClient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/// @title Chainlink Functions client interface.\\ninterface IFunctionsClient {\\n  /// @notice Chainlink Functions response handler called by the Functions Router\\n  /// during fullilment from the designated transmitter node in an OCR round.\\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\\n  /// @param response Aggregated response from the request's source code.\\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\\n  /// @dev Either response or error parameter will be set, but never both.\\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/interfaces/IFunctionsCoordinator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {FunctionsResponse} from \\\"../libraries/FunctionsResponse.sol\\\";\\n\\n/// @title Chainlink Functions DON Coordinator interface.\\ninterface IFunctionsCoordinator {\\n  /// @notice Returns the DON's threshold encryption public key used to encrypt secrets\\n  /// @dev All nodes on the DON have separate key shares of the threshold decryption key\\n  /// and nodes must participate in a threshold decryption OCR round to decrypt secrets\\n  /// @return thresholdPublicKey the DON's threshold encryption public key\\n  function getThresholdPublicKey() external view returns (bytes memory);\\n\\n  /// @notice Sets the DON's threshold encryption public key used to encrypt secrets\\n  /// @dev Used to rotate the key\\n  /// @param thresholdPublicKey The new public key\\n  function setThresholdPublicKey(bytes calldata thresholdPublicKey) external;\\n\\n  /// @notice Returns the DON's secp256k1 public key that is used to encrypt secrets\\n  /// @dev All nodes on the DON have the corresponding private key\\n  /// needed to decrypt the secrets encrypted with the public key\\n  /// @return publicKey the DON's public key\\n  function getDONPublicKey() external view returns (bytes memory);\\n\\n  /// @notice Sets DON's secp256k1 public key used to encrypt secrets\\n  /// @dev Used to rotate the key\\n  /// @param donPublicKey The new public key\\n  function setDONPublicKey(bytes calldata donPublicKey) external;\\n\\n  /// @notice Receives a request to be emitted to the DON for processing\\n  /// @param request The request metadata\\n  /// @dev see the struct for field descriptions\\n  /// @return commitment - The parameters of the request that must be held consistent at response time\\n  function startRequest(\\n    FunctionsResponse.RequestMeta calldata request\\n  ) external returns (FunctionsResponse.Commitment memory commitment);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/interfaces/IFunctionsRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {FunctionsResponse} from \\\"../libraries/FunctionsResponse.sol\\\";\\n\\n/// @title Chainlink Functions Router interface.\\ninterface IFunctionsRouter {\\n  /// @notice The identifier of the route to retrieve the address of the access control contract\\n  /// The access control contract controls which accounts can manage subscriptions\\n  /// @return id - bytes32 id that can be passed to the \\\"getContractById\\\" of the Router\\n  function getAllowListId() external view returns (bytes32);\\n\\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\\n  /// The access control contract controls which accounts can manage subscriptions\\n  function setAllowListId(bytes32 allowListId) external;\\n\\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\\n  /// @return adminFee\\n  function getAdminFee() external view returns (uint72 adminFee);\\n\\n  /// @notice Sends a request using the provided subscriptionId\\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\\n  /// a client can make requests from different contracts referencing the same subscription\\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\\n  /// @param dataVersion - Gas limit for the fulfillment callback\\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\\n  /// @param donId - An identifier used to determine which route to send the request along\\n  /// @return requestId - A unique request identifier\\n  function sendRequest(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) external returns (bytes32);\\n\\n  /// @notice Sends a request to the proposed contracts\\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\\n  /// a client can make requests from different contracts referencing the same subscription\\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\\n  /// @param dataVersion - Gas limit for the fulfillment callback\\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\\n  /// @param donId - An identifier used to determine which route to send the request along\\n  /// @return requestId - A unique request identifier\\n  function sendRequestToProposed(\\n    uint64 subscriptionId,\\n    bytes calldata data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) external returns (bytes32);\\n\\n  /// @notice Fulfill the request by:\\n  /// - calling back the data that the Oracle returned to the client contract\\n  /// - pay the DON for processing the request\\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\\n  /// @param response response data from DON consensus\\n  /// @param err error from DON consensus\\n  /// @param juelsPerGas - current rate of juels/gas\\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\\n  /// @param transmitter - The Node that transmitted the OCR report\\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\\n  /// @return fulfillResult -\\n  /// @return callbackGasCostJuels -\\n  function fulfill(\\n    bytes memory response,\\n    bytes memory err,\\n    uint96 juelsPerGas,\\n    uint96 costWithoutFulfillment,\\n    address transmitter,\\n    FunctionsResponse.Commitment memory commitment\\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\\n\\n  /// @notice Validate requested gas limit is below the subscription max.\\n  /// @param subscriptionId subscription ID\\n  /// @param callbackGasLimit desired callback gas limit\\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\\n\\n  /// @notice Get the current contract given an ID\\n  /// @param id A bytes32 identifier for the route\\n  /// @return contract The current contract address\\n  function getContractById(bytes32 id) external view returns (address);\\n\\n  /// @notice Get the proposed next contract given an ID\\n  /// @param id A bytes32 identifier for the route\\n  /// @return contract The current or proposed contract address\\n  function getProposedContractById(bytes32 id) external view returns (address);\\n\\n  /// @notice Return the latest proprosal set\\n  /// @return ids The identifiers of the contracts to update\\n  /// @return to The addresses of the contracts that will be updated to\\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\\n\\n  /// @notice Proposes one or more updates to the contract routes\\n  /// @dev Only callable by owner\\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\\n\\n  /// @notice Updates the current contract routes to the proposed contracts\\n  /// @dev Only callable by owner\\n  function updateContracts() external;\\n\\n  /// @dev Puts the system into an emergency stopped state.\\n  /// @dev Only callable by owner\\n  function pause() external;\\n\\n  /// @dev Takes the system out of an emergency stopped state.\\n  /// @dev Only callable by owner\\n  function unpause() external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/interfaces/IFunctionsSubscriptions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {FunctionsResponse} from \\\"../libraries/FunctionsResponse.sol\\\";\\n\\n/// @title Chainlink Functions Subscription interface.\\ninterface IFunctionsSubscriptions {\\n  struct Subscription {\\n    uint96 balance; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 Common LINK balance that is controlled by the Router to be used for all consumer requests.\\n    address owner; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d The owner can fund/withdraw/cancel the subscription.\\n    uint96 blockedBalance; // \u2550\u2550\u2557 LINK balance that is reserved to pay for pending consumer requests.\\n    address proposedOwner; // \u2550\u2550\u255d For safely transferring sub ownership.\\n    address[] consumers; // \u2550\u2550\u2550\u2550\u2578 Client contracts that can use the subscription\\n    bytes32 flags; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 Per-subscription flags\\n  }\\n\\n  struct Consumer {\\n    bool allowed; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 Owner can fund/withdraw/cancel the sub.\\n    uint64 initiatedRequests; //   \u2551 The number of requests that have been started\\n    uint64 completedRequests; // \u2550\u2550\u255d The number of requests that have successfully completed or timed out\\n  }\\n\\n  /// @notice Get details about a subscription.\\n  /// @param subscriptionId - the ID of the subscription\\n  /// @return subscription - see IFunctionsSubscriptions.Subscription for more information on the structure\\n  function getSubscription(uint64 subscriptionId) external view returns (Subscription memory);\\n\\n  /// @notice Retrieve details about multiple subscriptions using an inclusive range\\n  /// @param subscriptionIdStart - the ID of the subscription to start the range at\\n  /// @param subscriptionIdEnd - the ID of the subscription to end the range at\\n  /// @return subscriptions - see IFunctionsSubscriptions.Subscription for more information on the structure\\n  function getSubscriptionsInRange(\\n    uint64 subscriptionIdStart,\\n    uint64 subscriptionIdEnd\\n  ) external view returns (Subscription[] memory);\\n\\n  /// @notice Get details about a consumer of a subscription.\\n  /// @param client - the consumer contract address\\n  /// @param subscriptionId - the ID of the subscription\\n  /// @return consumer - see IFunctionsSubscriptions.Consumer for more information on the structure\\n  function getConsumer(address client, uint64 subscriptionId) external view returns (Consumer memory);\\n\\n  /// @notice Get details about the total amount of LINK within the system\\n  /// @return totalBalance - total Juels of LINK held by the contract\\n  function getTotalBalance() external view returns (uint96);\\n\\n  /// @notice Get details about the total number of subscription accounts\\n  /// @return count - total number of subscriptions in the system\\n  function getSubscriptionCount() external view returns (uint64);\\n\\n  /// @notice Time out all expired requests: unlocks funds and removes the ability for the request to be fulfilled\\n  /// @param requestsToTimeoutByCommitment - A list of request commitments to time out\\n  /// @dev The commitment can be found on the \\\"OracleRequest\\\" event created when sending the request.\\n  function timeoutRequests(FunctionsResponse.Commitment[] calldata requestsToTimeoutByCommitment) external;\\n\\n  /// @notice Oracle withdraw LINK earned through fulfilling requests\\n  /// @notice If amount is 0 the full balance will be withdrawn\\n  /// @notice Both signing and transmitting wallets will have a balance to withdraw\\n  /// @param recipient where to send the funds\\n  /// @param amount amount to withdraw\\n  function oracleWithdraw(address recipient, uint96 amount) external;\\n\\n  /// @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\\n  /// @dev Only callable by the Router Owner\\n  /// @param subscriptionId subscription id\\n  /// @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\\n  function ownerCancelSubscription(uint64 subscriptionId) external;\\n\\n  /// @notice Recover link sent with transfer instead of transferAndCall.\\n  /// @dev Only callable by the Router Owner\\n  /// @param to address to send link to\\n  function recoverFunds(address to) external;\\n\\n  /// @notice Create a new subscription.\\n  /// @return subscriptionId - A unique subscription id.\\n  /// @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n  /// @dev Note to fund the subscription, use transferAndCall. For example\\n  /// @dev  LINKTOKEN.transferAndCall(\\n  /// @dev    address(ROUTER),\\n  /// @dev    amount,\\n  /// @dev    abi.encode(subscriptionId));\\n  function createSubscription() external returns (uint64);\\n\\n  /// @notice Create a new subscription and add a consumer.\\n  /// @return subscriptionId - A unique subscription id.\\n  /// @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n  /// @dev Note to fund the subscription, use transferAndCall. For example\\n  /// @dev  LINKTOKEN.transferAndCall(\\n  /// @dev    address(ROUTER),\\n  /// @dev    amount,\\n  /// @dev    abi.encode(subscriptionId));\\n  function createSubscriptionWithConsumer(address consumer) external returns (uint64 subscriptionId);\\n\\n  /// @notice Propose a new owner for a subscription.\\n  /// @dev Only callable by the Subscription's owner\\n  /// @param subscriptionId - ID of the subscription\\n  /// @param newOwner - proposed new owner of the subscription\\n  function proposeSubscriptionOwnerTransfer(uint64 subscriptionId, address newOwner) external;\\n\\n  /// @notice Accept an ownership transfer.\\n  /// @param subscriptionId - ID of the subscription\\n  /// @dev will revert if original owner of subscriptionId has not requested that msg.sender become the new owner.\\n  function acceptSubscriptionOwnerTransfer(uint64 subscriptionId) external;\\n\\n  /// @notice Remove a consumer from a Chainlink Functions subscription.\\n  /// @dev Only callable by the Subscription's owner\\n  /// @param subscriptionId - ID of the subscription\\n  /// @param consumer - Consumer to remove from the subscription\\n  function removeConsumer(uint64 subscriptionId, address consumer) external;\\n\\n  /// @notice Add a consumer to a Chainlink Functions subscription.\\n  /// @dev Only callable by the Subscription's owner\\n  /// @param subscriptionId - ID of the subscription\\n  /// @param consumer - New consumer which can use the subscription\\n  function addConsumer(uint64 subscriptionId, address consumer) external;\\n\\n  /// @notice Cancel a subscription\\n  /// @dev Only callable by the Subscription's owner\\n  /// @param subscriptionId - ID of the subscription\\n  /// @param to - Where to send the remaining LINK to\\n  function cancelSubscription(uint64 subscriptionId, address to) external;\\n\\n  /// @notice Check to see if there exists a request commitment for all consumers for a given sub.\\n  /// @param subscriptionId - ID of the subscription\\n  /// @return true if there exists at least one unfulfilled request for the subscription, false otherwise.\\n  /// @dev Looping is bounded to MAX_CONSUMERS*(number of DONs).\\n  /// @dev Used to disable subscription canceling while outstanding request are present.\\n  function pendingRequestExists(uint64 subscriptionId) external view returns (bool);\\n\\n  /// @notice Set subscription specific flags for a subscription.\\n  /// Each byte of the flag is used to represent a resource tier that the subscription can utilize.\\n  /// @param subscriptionId - ID of the subscription\\n  /// @param flags - desired flag values\\n  function setFlags(uint64 subscriptionId, bytes32 flags) external;\\n\\n  /// @notice Get flags for a given subscription.\\n  /// @param subscriptionId - ID of the subscription\\n  /// @return flags - current flag values\\n  function getFlags(uint64 subscriptionId) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/interfaces/IOwnableFunctionsRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IFunctionsRouter} from \\\"./IFunctionsRouter.sol\\\";\\nimport {IOwnable} from \\\"../../../../shared/interfaces/IOwnable.sol\\\";\\n\\n/// @title Chainlink Functions Router interface with Ownability.\\ninterface IOwnableFunctionsRouter is IOwnable, IFunctionsRouter {\\n\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/libraries/FunctionsRequest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {CBOR} from \\\"../../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\\\";\\n\\n/// @title Library for encoding the input data of a Functions request into CBOR\\nlibrary FunctionsRequest {\\n  using CBOR for CBOR.CBORBuffer;\\n\\n  uint16 public constant REQUEST_DATA_VERSION = 1;\\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\\n\\n  enum Location {\\n    Inline, // Provided within the Request\\n    Remote, // Hosted through remote location that can be accessed through a provided URL\\n    DONHosted // Hosted on the DON's storage\\n  }\\n\\n  enum CodeLanguage {\\n    JavaScript\\n    // In future version we may add other languages\\n  }\\n\\n  struct Request {\\n    Location codeLocation; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 The location of the source code that will be executed on each node in the DON\\n    Location secretsLocation; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 The location of secrets that will be passed into the source code. *Only Remote secrets are supported\\n    CodeLanguage language; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 The coding language that the source code is written in\\n    string source; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\\n    bytes encryptedSecretsReference; // \u2550\u2550\u2578 Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\\n    string[] args; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 String arguments that will be passed into the source code\\n    bytes[] bytesArgs; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 Bytes arguments that will be passed into the source code\\n  }\\n\\n  error EmptySource();\\n  error EmptySecrets();\\n  error EmptyArgs();\\n  error NoInlineSecrets();\\n\\n  /// @notice Encodes a Request to CBOR encoded bytes\\n  /// @param self The request to encode\\n  /// @return CBOR encoded bytes\\n  function encodeCBOR(Request memory self) internal pure returns (bytes memory) {\\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\\n\\n    buffer.writeString(\\\"codeLocation\\\");\\n    buffer.writeUInt256(uint256(self.codeLocation));\\n\\n    buffer.writeString(\\\"language\\\");\\n    buffer.writeUInt256(uint256(self.language));\\n\\n    buffer.writeString(\\\"source\\\");\\n    buffer.writeString(self.source);\\n\\n    if (self.args.length > 0) {\\n      buffer.writeString(\\\"args\\\");\\n      buffer.startArray();\\n      for (uint256 i = 0; i < self.args.length; ++i) {\\n        buffer.writeString(self.args[i]);\\n      }\\n      buffer.endSequence();\\n    }\\n\\n    if (self.encryptedSecretsReference.length > 0) {\\n      if (self.secretsLocation == Location.Inline) {\\n        revert NoInlineSecrets();\\n      }\\n      buffer.writeString(\\\"secretsLocation\\\");\\n      buffer.writeUInt256(uint256(self.secretsLocation));\\n      buffer.writeString(\\\"secrets\\\");\\n      buffer.writeBytes(self.encryptedSecretsReference);\\n    }\\n\\n    if (self.bytesArgs.length > 0) {\\n      buffer.writeString(\\\"bytesArgs\\\");\\n      buffer.startArray();\\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\\n        buffer.writeBytes(self.bytesArgs[i]);\\n      }\\n      buffer.endSequence();\\n    }\\n\\n    return buffer.buf.buf;\\n  }\\n\\n  /// @notice Initializes a Chainlink Functions Request\\n  /// @dev Sets the codeLocation and code on the request\\n  /// @param self The uninitialized request\\n  /// @param codeLocation The user provided source code location\\n  /// @param language The programming language of the user code\\n  /// @param source The user provided source code or a url\\n  function initializeRequest(\\n    Request memory self,\\n    Location codeLocation,\\n    CodeLanguage language,\\n    string memory source\\n  ) internal pure {\\n    if (bytes(source).length == 0) revert EmptySource();\\n\\n    self.codeLocation = codeLocation;\\n    self.language = language;\\n    self.source = source;\\n  }\\n\\n  /// @notice Initializes a Chainlink Functions Request\\n  /// @dev Simplified version of initializeRequest for PoC\\n  /// @param self The uninitialized request\\n  /// @param javaScriptSource The user provided JS code (must not be empty)\\n  function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\\n    initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\\n  }\\n\\n  /// @notice Adds Remote user encrypted secrets to a Request\\n  /// @param self The initialized request\\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\\n  function addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\\n\\n    self.secretsLocation = Location.Remote;\\n    self.encryptedSecretsReference = encryptedSecretsReference;\\n  }\\n\\n  /// @notice Adds DON-hosted secrets reference to a Request\\n  /// @param self The initialized request\\n  /// @param slotID Slot ID of the user's secrets hosted on DON\\n  /// @param version User data version (for the slotID)\\n  function addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\\n\\n    buffer.writeString(\\\"slotID\\\");\\n    buffer.writeUInt64(slotID);\\n    buffer.writeString(\\\"version\\\");\\n    buffer.writeUInt64(version);\\n\\n    self.secretsLocation = Location.DONHosted;\\n    self.encryptedSecretsReference = buffer.buf.buf;\\n  }\\n\\n  /// @notice Sets args for the user run function\\n  /// @param self The initialized request\\n  /// @param args The array of string args (must not be empty)\\n  function setArgs(Request memory self, string[] memory args) internal pure {\\n    if (args.length == 0) revert EmptyArgs();\\n\\n    self.args = args;\\n  }\\n\\n  /// @notice Sets bytes args for the user run function\\n  /// @param self The initialized request\\n  /// @param args The array of bytes args (must not be empty)\\n  function setBytesArgs(Request memory self, bytes[] memory args) internal pure {\\n    if (args.length == 0) revert EmptyArgs();\\n\\n    self.bytesArgs = args;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/libraries/FunctionsResponse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {IFunctionsSubscriptions} from \\\"../interfaces/IFunctionsSubscriptions.sol\\\";\\n\\n/// @title Library of types that are used for fulfillment of a Functions request\\nlibrary FunctionsResponse {\\n  // Used to send request information from the Router to the Coordinator\\n  struct RequestMeta {\\n    bytes data; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\\n    bytes32 flags; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 Per-subscription flags\\n    address requestingContract; // \u2550\u2550\u2557 The client contract that is sending the request\\n    uint96 availableBalance; // \u2550\u2550\u2550\u2550\u2550\u255d Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\\n    uint72 adminFee; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\\n    uint64 subscriptionId; //        \u2551 Identifier of the billing subscription that will be charged for the request\\n    uint64 initiatedRequests; //     \u2551 The number of requests that have been started\\n    uint32 callbackGasLimit; //      \u2551 The amount of gas that the callback to the consuming contract will be given\\n    uint16 dataVersion; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d The version of the structure of the CBOR encoded request data\\n    uint64 completedRequests; // \u2550\u2550\u2550\u2550\u2557 The number of requests that have successfully completed or timed out\\n    address subscriptionOwner; // \u2550\u2550\u2550\u255d The owner of the billing subscription\\n  }\\n\\n  enum FulfillResult {\\n    FULFILLED, // 0\\n    USER_CALLBACK_ERROR, // 1\\n    INVALID_REQUEST_ID, // 2\\n    COST_EXCEEDS_COMMITMENT, // 3\\n    INSUFFICIENT_GAS_PROVIDED, // 4\\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\\n    INVALID_COMMITMENT // 6\\n  }\\n\\n  struct Commitment {\\n    bytes32 requestId; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2578 A unique identifier for a Chainlink Functions request\\n    address coordinator; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 The Coordinator contract that manages the DON that is servicing a request\\n    uint96 estimatedTotalCostJuels; // \u2550\u2550\u2550\u2550\u255d The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\\n    address client; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 The client contract that sent the request\\n    uint64 subscriptionId; //              \u2551 Identifier of the billing subscription that will be charged for the request\\n    uint32 callbackGasLimit; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d The amount of gas that the callback to the consuming contract will be given\\n    uint72 adminFee; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\\n    uint72 donFee; //                      \u2551 Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\\n    uint40 gasOverheadBeforeCallback; //   \u2551 Represents the average gas execution cost before the fulfillment callback.\\n    uint40 gasOverheadAfterCallback; //    \u2551 Represents the average gas execution cost after the fulfillment callback.\\n    uint32 timeoutTimestamp; // \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d The timestamp at which a request will be eligible to be timed out\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/mocks/FunctionsV1EventsMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\ncontract FunctionsV1EventsMock {\\n  struct Config {\\n    uint16 maxConsumersPerSubscription;\\n    uint72 adminFee;\\n    bytes4 handleOracleFulfillmentSelector;\\n    uint16 gasForCallExactCheck;\\n    uint32[] maxCallbackGasLimits;\\n  }\\n  event ConfigUpdated(Config param1);\\n  event ContractProposed(\\n    bytes32 proposedContractSetId,\\n    address proposedContractSetFromAddress,\\n    address proposedContractSetToAddress\\n  );\\n  event ContractUpdated(bytes32 id, address from, address to);\\n  event FundsRecovered(address to, uint256 amount);\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n  event Paused(address account);\\n  event RequestNotProcessed(bytes32 indexed requestId, address coordinator, address transmitter, uint8 resultCode);\\n  event RequestProcessed(\\n    bytes32 indexed requestId,\\n    uint64 indexed subscriptionId,\\n    uint96 totalCostJuels,\\n    address transmitter,\\n    uint8 resultCode,\\n    bytes response,\\n    bytes err,\\n    bytes callbackReturnData\\n  );\\n  event RequestStart(\\n    bytes32 indexed requestId,\\n    bytes32 indexed donId,\\n    uint64 indexed subscriptionId,\\n    address subscriptionOwner,\\n    address requestingContract,\\n    address requestInitiator,\\n    bytes data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    uint96 estimatedTotalCostJuels\\n  );\\n  event RequestTimedOut(bytes32 indexed requestId);\\n  event SubscriptionCanceled(uint64 indexed subscriptionId, address fundsRecipient, uint256 fundsAmount);\\n  event SubscriptionConsumerAdded(uint64 indexed subscriptionId, address consumer);\\n  event SubscriptionConsumerRemoved(uint64 indexed subscriptionId, address consumer);\\n  event SubscriptionCreated(uint64 indexed subscriptionId, address owner);\\n  event SubscriptionFunded(uint64 indexed subscriptionId, uint256 oldBalance, uint256 newBalance);\\n  event SubscriptionOwnerTransferRequested(uint64 indexed subscriptionId, address from, address to);\\n  event SubscriptionOwnerTransferred(uint64 indexed subscriptionId, address from, address to);\\n  event Unpaused(address account);\\n\\n  function emitConfigUpdated(Config memory param1) public {\\n    emit ConfigUpdated(param1);\\n  }\\n\\n  function emitContractProposed(\\n    bytes32 proposedContractSetId,\\n    address proposedContractSetFromAddress,\\n    address proposedContractSetToAddress\\n  ) public {\\n    emit ContractProposed(proposedContractSetId, proposedContractSetFromAddress, proposedContractSetToAddress);\\n  }\\n\\n  function emitContractUpdated(bytes32 id, address from, address to) public {\\n    emit ContractUpdated(id, from, to);\\n  }\\n\\n  function emitFundsRecovered(address to, uint256 amount) public {\\n    emit FundsRecovered(to, amount);\\n  }\\n\\n  function emitOwnershipTransferRequested(address from, address to) public {\\n    emit OwnershipTransferRequested(from, to);\\n  }\\n\\n  function emitOwnershipTransferred(address from, address to) public {\\n    emit OwnershipTransferred(from, to);\\n  }\\n\\n  function emitPaused(address account) public {\\n    emit Paused(account);\\n  }\\n\\n  function emitRequestNotProcessed(\\n    bytes32 requestId,\\n    address coordinator,\\n    address transmitter,\\n    uint8 resultCode\\n  ) public {\\n    emit RequestNotProcessed(requestId, coordinator, transmitter, resultCode);\\n  }\\n\\n  function emitRequestProcessed(\\n    bytes32 requestId,\\n    uint64 subscriptionId,\\n    uint96 totalCostJuels,\\n    address transmitter,\\n    uint8 resultCode,\\n    bytes memory response,\\n    bytes memory err,\\n    bytes memory callbackReturnData\\n  ) public {\\n    emit RequestProcessed(\\n      requestId,\\n      subscriptionId,\\n      totalCostJuels,\\n      transmitter,\\n      resultCode,\\n      response,\\n      err,\\n      callbackReturnData\\n    );\\n  }\\n\\n  function emitRequestStart(\\n    bytes32 requestId,\\n    bytes32 donId,\\n    uint64 subscriptionId,\\n    address subscriptionOwner,\\n    address requestingContract,\\n    address requestInitiator,\\n    bytes memory data,\\n    uint16 dataVersion,\\n    uint32 callbackGasLimit,\\n    uint96 estimatedTotalCostJuels\\n  ) public {\\n    emit RequestStart(\\n      requestId,\\n      donId,\\n      subscriptionId,\\n      subscriptionOwner,\\n      requestingContract,\\n      requestInitiator,\\n      data,\\n      dataVersion,\\n      callbackGasLimit,\\n      estimatedTotalCostJuels\\n    );\\n  }\\n\\n  function emitRequestTimedOut(bytes32 requestId) public {\\n    emit RequestTimedOut(requestId);\\n  }\\n\\n  function emitSubscriptionCanceled(uint64 subscriptionId, address fundsRecipient, uint256 fundsAmount) public {\\n    emit SubscriptionCanceled(subscriptionId, fundsRecipient, fundsAmount);\\n  }\\n\\n  function emitSubscriptionConsumerAdded(uint64 subscriptionId, address consumer) public {\\n    emit SubscriptionConsumerAdded(subscriptionId, consumer);\\n  }\\n\\n  function emitSubscriptionConsumerRemoved(uint64 subscriptionId, address consumer) public {\\n    emit SubscriptionConsumerRemoved(subscriptionId, consumer);\\n  }\\n\\n  function emitSubscriptionCreated(uint64 subscriptionId, address owner) public {\\n    emit SubscriptionCreated(subscriptionId, owner);\\n  }\\n\\n  function emitSubscriptionFunded(uint64 subscriptionId, uint256 oldBalance, uint256 newBalance) public {\\n    emit SubscriptionFunded(subscriptionId, oldBalance, newBalance);\\n  }\\n\\n  function emitSubscriptionOwnerTransferRequested(uint64 subscriptionId, address from, address to) public {\\n    emit SubscriptionOwnerTransferRequested(subscriptionId, from, to);\\n  }\\n\\n  function emitSubscriptionOwnerTransferred(uint64 subscriptionId, address from, address to) public {\\n    emit SubscriptionOwnerTransferred(subscriptionId, from, to);\\n  }\\n\\n  function emitUnpaused(address account) public {\\n    emit Unpaused(account);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/ocr/OCR2Abstract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {ITypeAndVersion} from \\\"../../../../shared/interfaces/ITypeAndVersion.sol\\\";\\n\\nabstract contract OCR2Abstract is ITypeAndVersion {\\n  // Maximum number of oracles the offchain reporting protocol is designed for\\n  uint256 internal constant MAX_NUM_ORACLES = 31;\\n\\n  /**\\n   * @notice triggers a new run of the offchain reporting protocol\\n   * @param previousConfigBlockNumber block in which the previous config was set, to simplify historic analysis\\n   * @param configDigest configDigest of this configuration\\n   * @param configCount ordinal number of this config setting among all config settings over the life of this contract\\n   * @param signers ith element is address ith oracle uses to sign a report\\n   * @param transmitters ith element is address ith oracle uses to transmit a report via the transmit method\\n   * @param f maximum number of faulty/dishonest oracles the protocol can tolerate while still working correctly\\n   * @param onchainConfig serialized configuration used by the contract (and possibly oracles)\\n   * @param offchainConfigVersion version of the serialization format used for \\\"offchainConfig\\\" parameter\\n   * @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\\n   */\\n  event ConfigSet(\\n    uint32 previousConfigBlockNumber,\\n    bytes32 configDigest,\\n    uint64 configCount,\\n    address[] signers,\\n    address[] transmitters,\\n    uint8 f,\\n    bytes onchainConfig,\\n    uint64 offchainConfigVersion,\\n    bytes offchainConfig\\n  );\\n\\n  /**\\n   * @notice sets offchain reporting protocol configuration incl. participating oracles\\n   * @param signers addresses with which oracles sign the reports\\n   * @param transmitters addresses oracles use to transmit the reports\\n   * @param f number of faulty oracles the system can tolerate\\n   * @param onchainConfig serialized configuration used by the contract (and possibly oracles)\\n   * @param offchainConfigVersion version number for offchainEncoding schema\\n   * @param offchainConfig serialized configuration used by the oracles exclusively and only passed through the contract\\n   */\\n  function setConfig(\\n    address[] memory signers,\\n    address[] memory transmitters,\\n    uint8 f,\\n    bytes memory onchainConfig,\\n    uint64 offchainConfigVersion,\\n    bytes memory offchainConfig\\n  ) external virtual;\\n\\n  /**\\n   * @notice information about current offchain reporting protocol configuration\\n   * @return configCount ordinal number of current config, out of all configs applied to this contract so far\\n   * @return blockNumber block at which this config was set\\n   * @return configDigest domain-separation tag for current config (see _configDigestFromConfigData)\\n   */\\n  function latestConfigDetails()\\n    external\\n    view\\n    virtual\\n    returns (uint32 configCount, uint32 blockNumber, bytes32 configDigest);\\n\\n  function _configDigestFromConfigData(\\n    uint256 chainId,\\n    address contractAddress,\\n    uint64 configCount,\\n    address[] memory signers,\\n    address[] memory transmitters,\\n    uint8 f,\\n    bytes memory onchainConfig,\\n    uint64 offchainConfigVersion,\\n    bytes memory offchainConfig\\n  ) internal pure returns (bytes32) {\\n    uint256 h = uint256(\\n      keccak256(\\n        abi.encode(\\n          chainId,\\n          contractAddress,\\n          configCount,\\n          signers,\\n          transmitters,\\n          f,\\n          onchainConfig,\\n          offchainConfigVersion,\\n          offchainConfig\\n        )\\n      )\\n    );\\n    uint256 prefixMask = type(uint256).max << (256 - 16); // 0xFFFF00..00\\n    uint256 prefix = 0x0001 << (256 - 16); // 0x000100..00\\n    return bytes32((prefix & prefixMask) | (h & ~prefixMask));\\n  }\\n\\n  /**\\n    * @notice optionally emited to indicate the latest configDigest and epoch for\\n     which a report was successfully transmited. Alternatively, the contract may\\n     use latestConfigDigestAndEpoch with scanLogs set to false.\\n  */\\n  event Transmitted(bytes32 configDigest, uint32 epoch);\\n\\n  /**\\n     * @notice optionally returns the latest configDigest and epoch for which a\\n     report was successfully transmitted. Alternatively, the contract may return\\n     scanLogs set to true and use Transmitted events to provide this information\\n     to offchain watchers.\\n   * @return scanLogs indicates whether to rely on the configDigest and epoch\\n     returned or whether to scan logs for the Transmitted event instead.\\n   * @return configDigest\\n   * @return epoch\\n   */\\n  function latestConfigDigestAndEpoch()\\n    external\\n    view\\n    virtual\\n    returns (bool scanLogs, bytes32 configDigest, uint32 epoch);\\n\\n  /**\\n   * @notice transmit is called to post a new report to the contract\\n   * @param report serialized report, which the signatures are signing.\\n   * @param rs ith element is the R components of the ith signature on report. Must have at most maxNumOracles entries\\n   * @param ss ith element is the S components of the ith signature on report. Must have at most maxNumOracles entries\\n   * @param rawVs ith element is the the V component of the ith signature\\n   */\\n  function transmit(\\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\\n    bytes32[3] calldata reportContext,\\n    bytes calldata report,\\n    bytes32[] calldata rs,\\n    bytes32[] calldata ss,\\n    bytes32 rawVs // signatures\\n  ) external virtual;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/dev/1_0_0/ocr/OCR2Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ConfirmedOwner} from \\\"../../../../shared/access/ConfirmedOwner.sol\\\";\\nimport {OCR2Abstract} from \\\"./OCR2Abstract.sol\\\";\\n\\n/**\\n * @notice Onchain verification of reports from the offchain reporting protocol\\n * @dev THIS CONTRACT HAS NOT GONE THROUGH ANY SECURITY REVIEW. DO NOT USE IN PROD.\\n * @dev For details on its operation, see the offchain reporting protocol design\\n * doc, which refers to this contract as simply the \\\"contract\\\".\\n * @dev This contract is meant to aid rapid development of new applications based on OCR2.\\n * However, for actual production contracts, it is expected that most of the logic of this contract\\n * will be folded directly into the application contract. Inheritance prevents us from doing lots\\n * of juicy storage layout optimizations, leading to a substantial increase in gas cost.\\n */\\nabstract contract OCR2Base is ConfirmedOwner, OCR2Abstract {\\n  error ReportInvalid();\\n  error InvalidConfig(string message);\\n\\n  bool internal immutable i_uniqueReports;\\n\\n  constructor(bool uniqueReports) ConfirmedOwner(msg.sender) {\\n    i_uniqueReports = uniqueReports;\\n  }\\n\\n  uint256 private constant maxUint32 = (1 << 32) - 1;\\n\\n  // incremented each time a new config is posted. This count is incorporated\\n  // into the config digest, to prevent replay attacks.\\n  uint32 internal s_configCount;\\n  uint32 internal s_latestConfigBlockNumber; // makes it easier for offchain systems\\n  // to extract config from logs.\\n\\n  // Storing these fields used on the hot path in a ConfigInfo variable reduces the\\n  // retrieval of all of them to a single SLOAD. If any further fields are\\n  // added, make sure that storage of the struct still takes at most 32 bytes.\\n  struct ConfigInfo {\\n    bytes32 latestConfigDigest;\\n    uint8 f; // TODO: could be optimized by squeezing into one slot\\n    uint8 n;\\n  }\\n  ConfigInfo internal s_configInfo;\\n\\n  // Used for s_oracles[a].role, where a is an address, to track the purpose\\n  // of the address, or to indicate that the address is unset.\\n  enum Role {\\n    // No oracle role has been set for address a\\n    Unset,\\n    // Signing address for the s_oracles[a].index'th oracle. I.e., report\\n    // signatures from this oracle should ecrecover back to address a.\\n    Signer,\\n    // Transmission address for the s_oracles[a].index'th oracle. I.e., if a\\n    // report is received by OCR2Aggregator.transmit in which msg.sender is\\n    // a, it is attributed to the s_oracles[a].index'th oracle.\\n    Transmitter\\n  }\\n\\n  struct Oracle {\\n    uint8 index; // Index of oracle in s_signers/s_transmitters\\n    Role role; // Role of the address which mapped to this struct\\n  }\\n\\n  mapping(address signerOrTransmitter => Oracle) internal s_oracles;\\n\\n  // s_signers contains the signing address of each oracle\\n  address[] internal s_signers;\\n\\n  // s_transmitters contains the transmission address of each oracle,\\n  // i.e. the address the oracle actually sends transactions to the contract from\\n  address[] internal s_transmitters;\\n\\n  /*\\n   * Config logic\\n   */\\n\\n  // Reverts transaction if config args are invalid\\n  modifier checkConfigValid(\\n    uint256 numSigners,\\n    uint256 numTransmitters,\\n    uint256 f\\n  ) {\\n    if (numSigners > MAX_NUM_ORACLES) revert InvalidConfig(\\\"too many signers\\\");\\n    if (f == 0) revert InvalidConfig(\\\"f must be positive\\\");\\n    if (numSigners != numTransmitters) revert InvalidConfig(\\\"oracle addresses out of registration\\\");\\n    if (numSigners <= 3 * f) revert InvalidConfig(\\\"faulty-oracle f too high\\\");\\n    _;\\n  }\\n\\n  struct SetConfigArgs {\\n    address[] signers;\\n    address[] transmitters;\\n    uint8 f;\\n    bytes onchainConfig;\\n    uint64 offchainConfigVersion;\\n    bytes offchainConfig;\\n  }\\n\\n  /// @inheritdoc OCR2Abstract\\n  function latestConfigDigestAndEpoch()\\n    external\\n    view\\n    virtual\\n    override\\n    returns (bool scanLogs, bytes32 configDigest, uint32 epoch)\\n  {\\n    return (true, bytes32(0), uint32(0));\\n  }\\n\\n  /**\\n   * @notice sets offchain reporting protocol configuration incl. participating oracles\\n   * @param _signers addresses with which oracles sign the reports\\n   * @param _transmitters addresses oracles use to transmit the reports\\n   * @param _f number of faulty oracles the system can tolerate\\n   * @param _onchainConfig encoded on-chain contract configuration\\n   * @param _offchainConfigVersion version number for offchainEncoding schema\\n   * @param _offchainConfig encoded off-chain oracle configuration\\n   */\\n  function setConfig(\\n    address[] memory _signers,\\n    address[] memory _transmitters,\\n    uint8 _f,\\n    bytes memory _onchainConfig,\\n    uint64 _offchainConfigVersion,\\n    bytes memory _offchainConfig\\n  ) external override checkConfigValid(_signers.length, _transmitters.length, _f) onlyOwner {\\n    SetConfigArgs memory args = SetConfigArgs({\\n      signers: _signers,\\n      transmitters: _transmitters,\\n      f: _f,\\n      onchainConfig: _onchainConfig,\\n      offchainConfigVersion: _offchainConfigVersion,\\n      offchainConfig: _offchainConfig\\n    });\\n\\n    _beforeSetConfig(args.f, args.onchainConfig);\\n\\n    while (s_signers.length != 0) {\\n      // remove any old signer/transmitter addresses\\n      uint256 lastIdx = s_signers.length - 1;\\n      address signer = s_signers[lastIdx];\\n      address transmitter = s_transmitters[lastIdx];\\n      delete s_oracles[signer];\\n      delete s_oracles[transmitter];\\n      s_signers.pop();\\n      s_transmitters.pop();\\n    }\\n\\n    // Bounded by MAX_NUM_ORACLES in OCR2Abstract.sol\\n    for (uint256 i = 0; i < args.signers.length; i++) {\\n      // add new signer/transmitter addresses\\n      require(s_oracles[args.signers[i]].role == Role.Unset, \\\"repeated signer address\\\");\\n      s_oracles[args.signers[i]] = Oracle(uint8(i), Role.Signer);\\n      require(s_oracles[args.transmitters[i]].role == Role.Unset, \\\"repeated transmitter address\\\");\\n      s_oracles[args.transmitters[i]] = Oracle(uint8(i), Role.Transmitter);\\n      s_signers.push(args.signers[i]);\\n      s_transmitters.push(args.transmitters[i]);\\n    }\\n    s_configInfo.f = args.f;\\n    uint32 previousConfigBlockNumber = s_latestConfigBlockNumber;\\n    s_latestConfigBlockNumber = uint32(block.number);\\n    s_configCount += 1;\\n    {\\n      s_configInfo.latestConfigDigest = configDigestFromConfigData(\\n        block.chainid,\\n        address(this),\\n        s_configCount,\\n        args.signers,\\n        args.transmitters,\\n        args.f,\\n        args.onchainConfig,\\n        args.offchainConfigVersion,\\n        args.offchainConfig\\n      );\\n    }\\n    s_configInfo.n = uint8(args.signers.length);\\n\\n    emit ConfigSet(\\n      previousConfigBlockNumber,\\n      s_configInfo.latestConfigDigest,\\n      s_configCount,\\n      args.signers,\\n      args.transmitters,\\n      args.f,\\n      args.onchainConfig,\\n      args.offchainConfigVersion,\\n      args.offchainConfig\\n    );\\n  }\\n\\n  function configDigestFromConfigData(\\n    uint256 _chainId,\\n    address _contractAddress,\\n    uint64 _configCount,\\n    address[] memory _signers,\\n    address[] memory _transmitters,\\n    uint8 _f,\\n    bytes memory _onchainConfig,\\n    uint64 _encodedConfigVersion,\\n    bytes memory _encodedConfig\\n  ) internal pure returns (bytes32) {\\n    uint256 h = uint256(\\n      keccak256(\\n        abi.encode(\\n          _chainId,\\n          _contractAddress,\\n          _configCount,\\n          _signers,\\n          _transmitters,\\n          _f,\\n          _onchainConfig,\\n          _encodedConfigVersion,\\n          _encodedConfig\\n        )\\n      )\\n    );\\n    uint256 prefixMask = type(uint256).max << (256 - 16); // 0xFFFF00..00\\n    uint256 prefix = 0x0001 << (256 - 16); // 0x000100..00\\n    return bytes32((prefix & prefixMask) | (h & ~prefixMask));\\n  }\\n\\n  /**\\n   * @notice information about current offchain reporting protocol configuration\\n   * @return configCount ordinal number of current config, out of all configs applied to this contract so far\\n   * @return blockNumber block at which this config was set\\n   * @return configDigest domain-separation tag for current config (see configDigestFromConfigData)\\n   */\\n  function latestConfigDetails()\\n    external\\n    view\\n    override\\n    returns (uint32 configCount, uint32 blockNumber, bytes32 configDigest)\\n  {\\n    return (s_configCount, s_latestConfigBlockNumber, s_configInfo.latestConfigDigest);\\n  }\\n\\n  /**\\n   * @return list of addresses permitted to transmit reports to this contract\\n   * @dev The list will match the order used to specify the transmitter during setConfig\\n   */\\n  function transmitters() external view returns (address[] memory) {\\n    return s_transmitters;\\n  }\\n\\n  function _beforeSetConfig(uint8 _f, bytes memory _onchainConfig) internal virtual;\\n\\n  /**\\n   * @dev hook called after the report has been fully validated\\n   * for the extending contract to handle additional logic, such as oracle payment\\n   * @param initialGas the amount of gas before validation\\n   * @param transmitter the address of the account that submitted the report\\n   * @param signers the addresses of all signing accounts\\n   * @param report serialized report\\n   */\\n  function _report(\\n    uint256 initialGas,\\n    address transmitter,\\n    uint8 signerCount,\\n    address[MAX_NUM_ORACLES] memory signers,\\n    bytes calldata report\\n  ) internal virtual;\\n\\n  // The constant-length components of the msg.data sent to transmit.\\n  // See the \\\"If we wanted to call sam\\\" example on for example reasoning\\n  // https://solidity.readthedocs.io/en/v0.7.2/abi-spec.html\\n  uint16 private constant TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT =\\n    4 + // function selector\\n      32 *\\n      3 + // 3 words containing reportContext\\n      32 + // word containing start location of abiencoded report value\\n      32 + // word containing location start of abiencoded rs value\\n      32 + // word containing start location of abiencoded ss value\\n      32 + // rawVs value\\n      32 + // word containing length of report\\n      32 + // word containing length rs\\n      32 + // word containing length of ss\\n      0; // placeholder\\n\\n  function requireExpectedMsgDataLength(\\n    bytes calldata report,\\n    bytes32[] calldata rs,\\n    bytes32[] calldata ss\\n  ) private pure {\\n    // calldata will never be big enough to make this overflow\\n    uint256 expected = uint256(TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT) +\\n      report.length + // one byte pure entry in _report\\n      rs.length *\\n      32 + // 32 bytes per entry in _rs\\n      ss.length *\\n      32 + // 32 bytes per entry in _ss\\n      0; // placeholder\\n    require(msg.data.length == expected, \\\"calldata length mismatch\\\");\\n  }\\n\\n  /**\\n   * @notice transmit is called to post a new report to the contract\\n   * @param report serialized report, which the signatures are signing.\\n   * @param rs ith element is the R components of the ith signature on report. Must have at most maxNumOracles entries\\n   * @param ss ith element is the S components of the ith signature on report. Must have at most maxNumOracles entries\\n   * @param rawVs ith element is the the V component of the ith signature\\n   */\\n  function transmit(\\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\\n    bytes32[3] calldata reportContext,\\n    bytes calldata report,\\n    bytes32[] calldata rs,\\n    bytes32[] calldata ss,\\n    bytes32 rawVs // signatures\\n  ) external override {\\n    uint256 initialGas = gasleft(); // This line must come first\\n\\n    {\\n      // reportContext consists of:\\n      // reportContext[0]: ConfigDigest\\n      // reportContext[1]: 27 byte padding, 4-byte epoch and 1-byte round\\n      // reportContext[2]: ExtraHash\\n      bytes32 configDigest = reportContext[0];\\n      uint32 epochAndRound = uint32(uint256(reportContext[1]));\\n\\n      emit Transmitted(configDigest, uint32(epochAndRound >> 8));\\n\\n      ConfigInfo memory configInfo = s_configInfo;\\n      require(configInfo.latestConfigDigest == configDigest, \\\"configDigest mismatch\\\");\\n\\n      requireExpectedMsgDataLength(report, rs, ss);\\n\\n      uint256 expectedNumSignatures;\\n      if (i_uniqueReports) {\\n        expectedNumSignatures = (configInfo.n + configInfo.f) / 2 + 1;\\n      } else {\\n        expectedNumSignatures = configInfo.f + 1;\\n      }\\n\\n      require(rs.length == expectedNumSignatures, \\\"wrong number of signatures\\\");\\n      require(rs.length == ss.length, \\\"signatures out of registration\\\");\\n\\n      Oracle memory transmitter = s_oracles[msg.sender];\\n      require( // Check that sender is authorized to report\\n        transmitter.role == Role.Transmitter && msg.sender == s_transmitters[transmitter.index],\\n        \\\"unauthorized transmitter\\\"\\n      );\\n    }\\n\\n    address[MAX_NUM_ORACLES] memory signed;\\n    uint8 signerCount = 0;\\n\\n    {\\n      // Verify signatures attached to report\\n      bytes32 h = keccak256(abi.encodePacked(keccak256(report), reportContext));\\n\\n      Oracle memory o;\\n      // Bounded by MAX_NUM_ORACLES in OCR2Abstract.sol\\n      for (uint256 i = 0; i < rs.length; ++i) {\\n        address signer = ecrecover(h, uint8(rawVs[i]) + 27, rs[i], ss[i]);\\n        o = s_oracles[signer];\\n        require(o.role == Role.Signer, \\\"address not authorized to sign\\\");\\n        require(signed[o.index] == address(0), \\\"non-unique signature\\\");\\n        signed[o.index] = signer;\\n        signerCount += 1;\\n      }\\n    }\\n\\n    _report(initialGas, msg.sender, signerCount, signed, report);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/functions/tests/1_0_0/testhelpers/FunctionsClientUpgradeHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport {FunctionsRequest} from \\\"../../../dev/1_0_0/libraries/FunctionsRequest.sol\\\";\\nimport {FunctionsClient} from \\\"../../../dev/1_0_0/FunctionsClient.sol\\\";\\nimport {ConfirmedOwner} from \\\"../../../../shared/access/ConfirmedOwner.sol\\\";\\n\\ncontract FunctionsClientUpgradeHelper is FunctionsClient, ConfirmedOwner {\\n  using FunctionsRequest for FunctionsRequest.Request;\\n\\n  constructor(address router) FunctionsClient(router) ConfirmedOwner(msg.sender) {}\\n\\n  event ResponseReceived(bytes32 indexed requestId, bytes result, bytes err);\\n\\n  /**\\n   * @notice Send a simple request\\n   *\\n   * @param donId DON ID\\n   * @param source JavaScript source code\\n   * @param secrets Encrypted secrets payload\\n   * @param args List of arguments accessible from within the source code\\n   * @param subscriptionId Funtions billing subscription ID\\n   * @param callbackGasLimit Maximum amount of gas used to call the client contract's `handleOracleFulfillment` function\\n   * @return Functions request ID\\n   */\\n  function sendRequest(\\n    bytes32 donId,\\n    string calldata source,\\n    bytes calldata secrets,\\n    string[] calldata args,\\n    bytes[] memory bytesArgs,\\n    uint64 subscriptionId,\\n    uint32 callbackGasLimit\\n  ) public onlyOwner returns (bytes32) {\\n    FunctionsRequest.Request memory req;\\n    req.initializeRequestForInlineJavaScript(source);\\n    if (secrets.length > 0) req.addSecretsReference(secrets);\\n    if (args.length > 0) req.setArgs(args);\\n    if (bytesArgs.length > 0) req.setBytesArgs(bytesArgs);\\n\\n    return _sendRequest(FunctionsRequest.encodeCBOR(req), subscriptionId, callbackGasLimit, donId);\\n  }\\n\\n  /**\\n   * @notice Same as sendRequest but for DONHosted secrets\\n   */\\n  function sendRequestWithDONHostedSecrets(\\n    bytes32 donId,\\n    string calldata source,\\n    uint8 slotId,\\n    uint64 slotVersion,\\n    string[] calldata args,\\n    uint64 subscriptionId,\\n    uint32 callbackGasLimit\\n  ) public onlyOwner returns (bytes32) {\\n    FunctionsRequest.Request memory req;\\n    req.initializeRequestForInlineJavaScript(source);\\n    req.addDONHostedSecrets(slotId, slotVersion);\\n\\n    if (args.length > 0) req.setArgs(args);\\n\\n    return _sendRequest(FunctionsRequest.encodeCBOR(req), subscriptionId, callbackGasLimit, donId);\\n  }\\n\\n  // @notice Sends a Chainlink Functions request\\n  // @param data The CBOR encoded bytes data for a Functions request\\n  // @param subscriptionId The subscription ID that will be charged to service the request\\n  // @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\\n  // @return requestId The generated request ID for this request\\n  function _sendRequestToProposed(\\n    bytes memory data,\\n    uint64 subscriptionId,\\n    uint32 callbackGasLimit,\\n    bytes32 donId\\n  ) internal returns (bytes32) {\\n    bytes32 requestId = i_router.sendRequestToProposed(\\n      subscriptionId,\\n      data,\\n      FunctionsRequest.REQUEST_DATA_VERSION,\\n      callbackGasLimit,\\n      donId\\n    );\\n    emit RequestSent(requestId);\\n    return requestId;\\n  }\\n\\n  /**\\n   * @notice Send a simple request to the proposed contract\\n   *\\n   * @param donId DON ID\\n   * @param source JavaScript source code\\n   * @param secrets Encrypted secrets payload\\n   * @param args List of arguments accessible from within the source code\\n   * @param subscriptionId Funtions billing subscription ID\\n   * @param callbackGasLimit Maximum amount of gas used to call the client contract's `handleOracleFulfillment` function\\n   * @return Functions request ID\\n   */\\n  function sendRequestToProposed(\\n    bytes32 donId,\\n    string calldata source,\\n    bytes calldata secrets,\\n    string[] calldata args,\\n    bytes[] memory bytesArgs,\\n    uint64 subscriptionId,\\n    uint32 callbackGasLimit\\n  ) public onlyOwner returns (bytes32) {\\n    FunctionsRequest.Request memory req;\\n    req.initializeRequestForInlineJavaScript(source);\\n    if (secrets.length > 0) req.addSecretsReference(secrets);\\n    if (args.length > 0) req.setArgs(args);\\n    if (bytesArgs.length > 0) req.setBytesArgs(bytesArgs);\\n\\n    return _sendRequestToProposed(FunctionsRequest.encodeCBOR(req), subscriptionId, callbackGasLimit, donId);\\n  }\\n\\n  /**\\n   * @notice Same as sendRequestToProposed but for DONHosted secrets\\n   */\\n  function sendRequestToProposedWithDONHostedSecrets(\\n    bytes32 donId,\\n    string calldata source,\\n    uint8 slotId,\\n    uint64 slotVersion,\\n    string[] calldata args,\\n    uint64 subscriptionId,\\n    uint32 callbackGasLimit\\n  ) public onlyOwner returns (bytes32) {\\n    FunctionsRequest.Request memory req;\\n    req.initializeRequestForInlineJavaScript(source);\\n    req.addDONHostedSecrets(slotId, slotVersion);\\n\\n    if (args.length > 0) req.setArgs(args);\\n\\n    return _sendRequestToProposed(FunctionsRequest.encodeCBOR(req), subscriptionId, callbackGasLimit, donId);\\n  }\\n\\n  /**\\n   * @notice Callback that is invoked once the DON has resolved the request or hit an error\\n   *\\n   * @param requestId The request ID, returned by sendRequest()\\n   * @param response Aggregated response from the user code\\n   * @param err Aggregated error from the user code or from the execution pipeline\\n   * Either response or error parameter will be set, but never both\\n   */\\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal override {\\n    emit ResponseReceived(requestId, response, err);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/access/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IOwnable.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is IOwnable {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/interfaces/IAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAccessController {\\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/interfaces/IERC677Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\ninterface IERC677Receiver {\\n  function onTokenTransfer(address sender, uint256 amount, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/interfaces/ITypeAndVersion.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITypeAndVersion {\\n  function typeAndVersion() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\\n\\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/@ensdomains/buffer/0.1.0/Buffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-2-Clause\\npragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for appending to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            let fpm := add(32, add(ptr, capacity))\\n            if lt(fpm, ptr) {\\n                revert(0, 0)\\n            }\\n            mstore(0x40, fpm)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        uint off = buf.buf.length;\\n        uint newCapacity = off + len;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(newCapacity, buflen) {\\n                mstore(bufptr, newCapacity)\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return append(buf, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint offPlusOne = off + 1;\\n        if (off >= buf.capacity) {\\n            resize(buf, offPlusOne * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if gt(offPlusOne, mload(bufptr)) {\\n                mstore(bufptr, offPlusOne)\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + newCapacity\\n                let dest := add(bufptr, newCapacity)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(newCapacity, mload(bufptr)) {\\n                    mstore(bufptr, newCapacity)\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return append(buf, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return append(buf, data, 32);\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     *      exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @param len The number of bytes to write (right-aligned).\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        uint off = buf.buf.length;\\n        uint newCapacity = len + off;\\n        if (newCapacity > buf.capacity) {\\n            resize(buf, newCapacity * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + sizeof(buffer length) + newCapacity\\n            let dest := add(bufptr, newCapacity)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(newCapacity, mload(bufptr)) {\\n                mstore(bufptr, newCapacity)\\n            }\\n        }\\n        return buf;\\n    }\\n}\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n  /**\\n   * @dev Emitted when the pause is triggered by `account`.\\n   */\\n  event Paused(address account);\\n\\n  /**\\n   * @dev Emitted when the pause is lifted by `account`.\\n   */\\n  event Unpaused(address account);\\n\\n  bool private _paused;\\n\\n  /**\\n   * @dev Initializes the contract in unpaused state.\\n   */\\n  constructor() {\\n    _paused = false;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  modifier whenNotPaused() {\\n    _requireNotPaused();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  modifier whenPaused() {\\n    _requirePaused();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns true if the contract is paused, and false otherwise.\\n   */\\n  function paused() public view virtual returns (bool) {\\n    return _paused;\\n  }\\n\\n  /**\\n   * @dev Throws if the contract is paused.\\n   */\\n  function _requireNotPaused() internal view virtual {\\n    require(!paused(), \\\"Pausable: paused\\\");\\n  }\\n\\n  /**\\n   * @dev Throws if the contract is not paused.\\n   */\\n  function _requirePaused() internal view virtual {\\n    require(paused(), \\\"Pausable: not paused\\\");\\n  }\\n\\n  /**\\n   * @dev Triggers stopped state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  function _pause() internal virtual whenNotPaused {\\n    _paused = true;\\n    emit Paused(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Returns to normal state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  function _unpause() internal virtual whenPaused {\\n    _paused = false;\\n    emit Unpaused(_msgSender());\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `to`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `from` to `to` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n   * given ``owner``'s signed approval.\\n   *\\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n   * ordering also apply here.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `deadline` must be a timestamp in the future.\\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n   * over the EIP712-formatted function arguments.\\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\\n   *\\n   * For more information on the signature format, see the\\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n   * section].\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n   * included whenever a signature is generated for {permit}.\\n   *\\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n   * prevents a signature from being used multiple times.\\n   */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n   */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n   * {IERC20-approve}, and its usage is discouraged.\\n   *\\n   * Whenever possible, use {safeIncreaseAllowance} and\\n   * {safeDecreaseAllowance} instead.\\n   */\\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n    unchecked {\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n      uint256 newAllowance = oldAllowance - value;\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n   *\\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n   * constructor.\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n   *\\n   * _Available since v4.8._\\n   */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason or using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n  /**\\n   * @dev Returns the downcasted uint248 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint248).\\n   *\\n   * Counterpart to Solidity's `uint248` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 248 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint248(uint256 value) internal pure returns (uint248) {\\n    require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    return uint248(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint240 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint240).\\n   *\\n   * Counterpart to Solidity's `uint240` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 240 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint240(uint256 value) internal pure returns (uint240) {\\n    require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    return uint240(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint232 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint232).\\n   *\\n   * Counterpart to Solidity's `uint232` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 232 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint232(uint256 value) internal pure returns (uint232) {\\n    require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    return uint232(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint224 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint224).\\n   *\\n   * Counterpart to Solidity's `uint224` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 224 bits\\n   *\\n   * _Available since v4.2._\\n   */\\n  function toUint224(uint256 value) internal pure returns (uint224) {\\n    require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    return uint224(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint216 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint216).\\n   *\\n   * Counterpart to Solidity's `uint216` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 216 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint216(uint256 value) internal pure returns (uint216) {\\n    require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    return uint216(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint208 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint208).\\n   *\\n   * Counterpart to Solidity's `uint208` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 208 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint208(uint256 value) internal pure returns (uint208) {\\n    require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    return uint208(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint200 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint200).\\n   *\\n   * Counterpart to Solidity's `uint200` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 200 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint200(uint256 value) internal pure returns (uint200) {\\n    require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    return uint200(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint192 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint192).\\n   *\\n   * Counterpart to Solidity's `uint192` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 192 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint192(uint256 value) internal pure returns (uint192) {\\n    require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    return uint192(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint184 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint184).\\n   *\\n   * Counterpart to Solidity's `uint184` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 184 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint184(uint256 value) internal pure returns (uint184) {\\n    require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    return uint184(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint176 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint176).\\n   *\\n   * Counterpart to Solidity's `uint176` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 176 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint176(uint256 value) internal pure returns (uint176) {\\n    require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    return uint176(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint168 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint168).\\n   *\\n   * Counterpart to Solidity's `uint168` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 168 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint168(uint256 value) internal pure returns (uint168) {\\n    require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    return uint168(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint160 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint160).\\n   *\\n   * Counterpart to Solidity's `uint160` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 160 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint160(uint256 value) internal pure returns (uint160) {\\n    require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    return uint160(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint152 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint152).\\n   *\\n   * Counterpart to Solidity's `uint152` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 152 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint152(uint256 value) internal pure returns (uint152) {\\n    require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    return uint152(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint144 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint144).\\n   *\\n   * Counterpart to Solidity's `uint144` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 144 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint144(uint256 value) internal pure returns (uint144) {\\n    require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    return uint144(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint136 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint136).\\n   *\\n   * Counterpart to Solidity's `uint136` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 136 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint136(uint256 value) internal pure returns (uint136) {\\n    require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    return uint136(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint128 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint128).\\n   *\\n   * Counterpart to Solidity's `uint128` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 128 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint128(uint256 value) internal pure returns (uint128) {\\n    require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    return uint128(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint120 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint120).\\n   *\\n   * Counterpart to Solidity's `uint120` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 120 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint120(uint256 value) internal pure returns (uint120) {\\n    require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    return uint120(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint112 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint112).\\n   *\\n   * Counterpart to Solidity's `uint112` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 112 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint112(uint256 value) internal pure returns (uint112) {\\n    require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    return uint112(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint104 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint104).\\n   *\\n   * Counterpart to Solidity's `uint104` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 104 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint104(uint256 value) internal pure returns (uint104) {\\n    require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    return uint104(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint96 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint96).\\n   *\\n   * Counterpart to Solidity's `uint96` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 96 bits\\n   *\\n   * _Available since v4.2._\\n   */\\n  function toUint96(uint256 value) internal pure returns (uint96) {\\n    require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    return uint96(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint88 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint88).\\n   *\\n   * Counterpart to Solidity's `uint88` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 88 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint88(uint256 value) internal pure returns (uint88) {\\n    require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    return uint88(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint80 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint80).\\n   *\\n   * Counterpart to Solidity's `uint80` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 80 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint80(uint256 value) internal pure returns (uint80) {\\n    require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    return uint80(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint72 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint72).\\n   *\\n   * Counterpart to Solidity's `uint72` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 72 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint72(uint256 value) internal pure returns (uint72) {\\n    require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    return uint72(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint64 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint64).\\n   *\\n   * Counterpart to Solidity's `uint64` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 64 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint64(uint256 value) internal pure returns (uint64) {\\n    require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    return uint64(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint56 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint56).\\n   *\\n   * Counterpart to Solidity's `uint56` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 56 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint56(uint256 value) internal pure returns (uint56) {\\n    require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    return uint56(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint48 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint48).\\n   *\\n   * Counterpart to Solidity's `uint48` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 48 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint48(uint256 value) internal pure returns (uint48) {\\n    require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    return uint48(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint40 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint40).\\n   *\\n   * Counterpart to Solidity's `uint40` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 40 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint40(uint256 value) internal pure returns (uint40) {\\n    require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    return uint40(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint32 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint32).\\n   *\\n   * Counterpart to Solidity's `uint32` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 32 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint32(uint256 value) internal pure returns (uint32) {\\n    require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    return uint32(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint24 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint24).\\n   *\\n   * Counterpart to Solidity's `uint24` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 24 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toUint24(uint256 value) internal pure returns (uint24) {\\n    require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    return uint24(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint16 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint16).\\n   *\\n   * Counterpart to Solidity's `uint16` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 16 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint16(uint256 value) internal pure returns (uint16) {\\n    require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    return uint16(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted uint8 from uint256, reverting on\\n   * overflow (when the input is greater than largest uint8).\\n   *\\n   * Counterpart to Solidity's `uint8` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 8 bits\\n   *\\n   * _Available since v2.5._\\n   */\\n  function toUint8(uint256 value) internal pure returns (uint8) {\\n    require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    return uint8(value);\\n  }\\n\\n  /**\\n   * @dev Converts a signed int256 into an unsigned uint256.\\n   *\\n   * Requirements:\\n   *\\n   * - input must be greater than or equal to 0.\\n   *\\n   * _Available since v3.0._\\n   */\\n  function toUint256(int256 value) internal pure returns (uint256) {\\n    require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n    return uint256(value);\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int248 from int256, reverting on\\n   * overflow (when the input is less than smallest int248 or\\n   * greater than largest int248).\\n   *\\n   * Counterpart to Solidity's `int248` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 248 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n    downcasted = int248(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int240 from int256, reverting on\\n   * overflow (when the input is less than smallest int240 or\\n   * greater than largest int240).\\n   *\\n   * Counterpart to Solidity's `int240` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 240 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n    downcasted = int240(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int232 from int256, reverting on\\n   * overflow (when the input is less than smallest int232 or\\n   * greater than largest int232).\\n   *\\n   * Counterpart to Solidity's `int232` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 232 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n    downcasted = int232(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int224 from int256, reverting on\\n   * overflow (when the input is less than smallest int224 or\\n   * greater than largest int224).\\n   *\\n   * Counterpart to Solidity's `int224` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 224 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n    downcasted = int224(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int216 from int256, reverting on\\n   * overflow (when the input is less than smallest int216 or\\n   * greater than largest int216).\\n   *\\n   * Counterpart to Solidity's `int216` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 216 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n    downcasted = int216(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int208 from int256, reverting on\\n   * overflow (when the input is less than smallest int208 or\\n   * greater than largest int208).\\n   *\\n   * Counterpart to Solidity's `int208` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 208 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n    downcasted = int208(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int200 from int256, reverting on\\n   * overflow (when the input is less than smallest int200 or\\n   * greater than largest int200).\\n   *\\n   * Counterpart to Solidity's `int200` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 200 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n    downcasted = int200(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int192 from int256, reverting on\\n   * overflow (when the input is less than smallest int192 or\\n   * greater than largest int192).\\n   *\\n   * Counterpart to Solidity's `int192` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 192 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n    downcasted = int192(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int184 from int256, reverting on\\n   * overflow (when the input is less than smallest int184 or\\n   * greater than largest int184).\\n   *\\n   * Counterpart to Solidity's `int184` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 184 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n    downcasted = int184(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int176 from int256, reverting on\\n   * overflow (when the input is less than smallest int176 or\\n   * greater than largest int176).\\n   *\\n   * Counterpart to Solidity's `int176` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 176 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n    downcasted = int176(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int168 from int256, reverting on\\n   * overflow (when the input is less than smallest int168 or\\n   * greater than largest int168).\\n   *\\n   * Counterpart to Solidity's `int168` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 168 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n    downcasted = int168(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int160 from int256, reverting on\\n   * overflow (when the input is less than smallest int160 or\\n   * greater than largest int160).\\n   *\\n   * Counterpart to Solidity's `int160` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 160 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n    downcasted = int160(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int152 from int256, reverting on\\n   * overflow (when the input is less than smallest int152 or\\n   * greater than largest int152).\\n   *\\n   * Counterpart to Solidity's `int152` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 152 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n    downcasted = int152(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int144 from int256, reverting on\\n   * overflow (when the input is less than smallest int144 or\\n   * greater than largest int144).\\n   *\\n   * Counterpart to Solidity's `int144` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 144 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n    downcasted = int144(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int136 from int256, reverting on\\n   * overflow (when the input is less than smallest int136 or\\n   * greater than largest int136).\\n   *\\n   * Counterpart to Solidity's `int136` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 136 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n    downcasted = int136(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int128 from int256, reverting on\\n   * overflow (when the input is less than smallest int128 or\\n   * greater than largest int128).\\n   *\\n   * Counterpart to Solidity's `int128` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 128 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n    downcasted = int128(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int120 from int256, reverting on\\n   * overflow (when the input is less than smallest int120 or\\n   * greater than largest int120).\\n   *\\n   * Counterpart to Solidity's `int120` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 120 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n    downcasted = int120(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int112 from int256, reverting on\\n   * overflow (when the input is less than smallest int112 or\\n   * greater than largest int112).\\n   *\\n   * Counterpart to Solidity's `int112` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 112 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n    downcasted = int112(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int104 from int256, reverting on\\n   * overflow (when the input is less than smallest int104 or\\n   * greater than largest int104).\\n   *\\n   * Counterpart to Solidity's `int104` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 104 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n    downcasted = int104(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int96 from int256, reverting on\\n   * overflow (when the input is less than smallest int96 or\\n   * greater than largest int96).\\n   *\\n   * Counterpart to Solidity's `int96` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 96 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n    downcasted = int96(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int88 from int256, reverting on\\n   * overflow (when the input is less than smallest int88 or\\n   * greater than largest int88).\\n   *\\n   * Counterpart to Solidity's `int88` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 88 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n    downcasted = int88(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int80 from int256, reverting on\\n   * overflow (when the input is less than smallest int80 or\\n   * greater than largest int80).\\n   *\\n   * Counterpart to Solidity's `int80` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 80 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n    downcasted = int80(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int72 from int256, reverting on\\n   * overflow (when the input is less than smallest int72 or\\n   * greater than largest int72).\\n   *\\n   * Counterpart to Solidity's `int72` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 72 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n    downcasted = int72(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int64 from int256, reverting on\\n   * overflow (when the input is less than smallest int64 or\\n   * greater than largest int64).\\n   *\\n   * Counterpart to Solidity's `int64` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 64 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n    downcasted = int64(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int56 from int256, reverting on\\n   * overflow (when the input is less than smallest int56 or\\n   * greater than largest int56).\\n   *\\n   * Counterpart to Solidity's `int56` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 56 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n    downcasted = int56(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int48 from int256, reverting on\\n   * overflow (when the input is less than smallest int48 or\\n   * greater than largest int48).\\n   *\\n   * Counterpart to Solidity's `int48` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 48 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n    downcasted = int48(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int40 from int256, reverting on\\n   * overflow (when the input is less than smallest int40 or\\n   * greater than largest int40).\\n   *\\n   * Counterpart to Solidity's `int40` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 40 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n    downcasted = int40(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int32 from int256, reverting on\\n   * overflow (when the input is less than smallest int32 or\\n   * greater than largest int32).\\n   *\\n   * Counterpart to Solidity's `int32` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 32 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n    downcasted = int32(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int24 from int256, reverting on\\n   * overflow (when the input is less than smallest int24 or\\n   * greater than largest int24).\\n   *\\n   * Counterpart to Solidity's `int24` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 24 bits\\n   *\\n   * _Available since v4.7._\\n   */\\n  function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n    downcasted = int24(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int16 from int256, reverting on\\n   * overflow (when the input is less than smallest int16 or\\n   * greater than largest int16).\\n   *\\n   * Counterpart to Solidity's `int16` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 16 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n    downcasted = int16(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the downcasted int8 from int256, reverting on\\n   * overflow (when the input is less than smallest int8 or\\n   * greater than largest int8).\\n   *\\n   * Counterpart to Solidity's `int8` operator.\\n   *\\n   * Requirements:\\n   *\\n   * - input must fit into 8 bits\\n   *\\n   * _Available since v3.1._\\n   */\\n  function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n    downcasted = int8(value);\\n    require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n  }\\n\\n  /**\\n   * @dev Converts an unsigned uint256 into a signed int256.\\n   *\\n   * Requirements:\\n   *\\n   * - input must be less than or equal to maxInt256.\\n   *\\n   * _Available since v3.0._\\n   */\\n  function toInt256(uint256 value) internal pure returns (int256) {\\n    // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n    require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n    return int256(value);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/openzeppelin-solidity/v4.8.0/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n  // To implement this library for multiple types with as little code\\n  // repetition as possible, we write it in terms of a generic Set type with\\n  // bytes32 values.\\n  // The Set implementation uses private functions, and user-facing\\n  // implementations (such as AddressSet) are just wrappers around the\\n  // underlying Set.\\n  // This means that we can only create new EnumerableSets for types that fit\\n  // in bytes32.\\n\\n  struct Set {\\n    // Storage of set values\\n    bytes32[] _values;\\n    // Position of the value in the `values` array, plus 1 because index 0\\n    // means a value is not in the set.\\n    mapping(bytes32 => uint256) _indexes;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function _add(Set storage set, bytes32 value) private returns (bool) {\\n    if (!_contains(set, value)) {\\n      set._values.push(value);\\n      // The value is stored at length-1, but we add 1 to all indexes\\n      // and use 0 as a sentinel value\\n      set._indexes[value] = set._values.length;\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\\n    // We read and store the value's index to prevent multiple reads from the same storage slot\\n    uint256 valueIndex = set._indexes[value];\\n\\n    if (valueIndex != 0) {\\n      // Equivalent to contains(set, value)\\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\\n      // This modifies the order of the array, as noted in {at}.\\n\\n      uint256 toDeleteIndex = valueIndex - 1;\\n      uint256 lastIndex = set._values.length - 1;\\n\\n      if (lastIndex != toDeleteIndex) {\\n        bytes32 lastValue = set._values[lastIndex];\\n\\n        // Move the last value to the index where the value to delete is\\n        set._values[toDeleteIndex] = lastValue;\\n        // Update the index for the moved value\\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n      }\\n\\n      // Delete the slot where the moved value was stored\\n      set._values.pop();\\n\\n      // Delete the index for the deleted slot\\n      delete set._indexes[value];\\n\\n      return true;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n    return set._indexes[value] != 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of values on the set. O(1).\\n   */\\n  function _length(Set storage set) private view returns (uint256) {\\n    return set._values.length;\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n    return set._values[index];\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function _values(Set storage set) private view returns (bytes32[] memory) {\\n    return set._values;\\n  }\\n\\n  // Bytes32Set\\n\\n  struct Bytes32Set {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _add(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n    return _remove(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n    return _contains(set._inner, value);\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(Bytes32Set storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n    return _at(set._inner, index);\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    bytes32[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // AddressSet\\n\\n  struct AddressSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(AddressSet storage set, address value) internal returns (bool) {\\n    return _add(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(AddressSet storage set, address value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(AddressSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n    return address(uint160(uint256(_at(set._inner, index))));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(AddressSet storage set) internal view returns (address[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    address[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n\\n  // UintSet\\n\\n  struct UintSet {\\n    Set _inner;\\n  }\\n\\n  /**\\n   * @dev Add a value to a set. O(1).\\n   *\\n   * Returns true if the value was added to the set, that is if it was not\\n   * already present.\\n   */\\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _add(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Removes a value from a set. O(1).\\n   *\\n   * Returns true if the value was removed from the set, that is if it was\\n   * present.\\n   */\\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n    return _remove(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns true if the value is in the set. O(1).\\n   */\\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n    return _contains(set._inner, bytes32(value));\\n  }\\n\\n  /**\\n   * @dev Returns the number of values in the set. O(1).\\n   */\\n  function length(UintSet storage set) internal view returns (uint256) {\\n    return _length(set._inner);\\n  }\\n\\n  /**\\n   * @dev Returns the value stored at position `index` in the set. O(1).\\n   *\\n   * Note that there are no guarantees on the ordering of values inside the\\n   * array, and it may change when more values are added or removed.\\n   *\\n   * Requirements:\\n   *\\n   * - `index` must be strictly less than {length}.\\n   */\\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n    return uint256(_at(set._inner, index));\\n  }\\n\\n  /**\\n   * @dev Return the entire set in an array\\n   *\\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n   */\\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\\n    bytes32[] memory store = _values(set._inner);\\n    uint256[] memory result;\\n\\n    /// @solidity memory-safe-assembly\\n    assembly {\\n      result := store\\n    }\\n\\n    return result;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../../@ensdomains/buffer/0.1.0/Buffer.sol\\\";\\n\\n/**\\n* @dev A library for populating CBOR encoded payload in Solidity.\\n*\\n* https://datatracker.ietf.org/doc/html/rfc7049\\n*\\n* The library offers various write* and start* methods to encode values of different types.\\n* The resulted buffer can be obtained with data() method.\\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\\n* in an invalid CBOR if start/write/end flow is violated.\\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\\n* except for nested start/end pairs.\\n*/\\n\\nlibrary CBOR {\\n    using Buffer for Buffer.buffer;\\n\\n    struct CBORBuffer {\\n        Buffer.buffer buf;\\n        uint256 depth;\\n    }\\n\\n    uint8 private constant MAJOR_TYPE_INT = 0;\\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\\n    uint8 private constant MAJOR_TYPE_STRING = 3;\\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n    uint8 private constant MAJOR_TYPE_MAP = 5;\\n    uint8 private constant MAJOR_TYPE_TAG = 6;\\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n    uint8 private constant CBOR_FALSE = 20;\\n    uint8 private constant CBOR_TRUE = 21;\\n    uint8 private constant CBOR_NULL = 22;\\n    uint8 private constant CBOR_UNDEFINED = 23;\\n\\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\\n        Buffer.init(cbor.buf, capacity);\\n        cbor.depth = 0;\\n        return cbor;\\n    }\\n\\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\\n        require(buf.depth == 0, \\\"Invalid CBOR\\\");\\n        return buf.buf.buf;\\n    }\\n\\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n        writeBytes(buf, abi.encode(value));\\n    }\\n\\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\\n        if (value < 0) {\\n            buf.buf.appendUint8(\\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\\n            );\\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\\n        } else {\\n            writeUInt256(buf, uint256(value));\\n        }\\n    }\\n\\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\\n    }\\n\\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\\n        if(value >= 0) {\\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\\n        } else{\\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\\n        }\\n    }\\n\\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\\n        buf.buf.append(value);\\n    }\\n\\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\\n        buf.buf.append(bytes(value));\\n    }\\n\\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\\n    }\\n\\n    function writeNull(CBORBuffer memory buf) internal pure {\\n        writeContentFree(buf, CBOR_NULL);\\n    }\\n\\n    function writeUndefined(CBORBuffer memory buf) internal pure {\\n        writeContentFree(buf, CBOR_UNDEFINED);\\n    }\\n\\n    function startArray(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n        buf.depth += 1;\\n    }\\n\\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\\n    }\\n\\n    function startMap(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n        buf.depth += 1;\\n    }\\n\\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\\n    }\\n\\n    function endSequence(CBORBuffer memory buf) internal pure {\\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n        buf.depth -= 1;\\n    }\\n\\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\\n        writeString(buf, key);\\n        writeString(buf, value);\\n    }\\n\\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\\n        writeString(buf, key);\\n        writeBytes(buf, value);\\n    }\\n\\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\\n        writeString(buf, key);\\n        writeUInt256(buf, value);\\n    }\\n\\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\\n        writeString(buf, key);\\n        writeInt256(buf, value);\\n    }\\n\\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\\n        writeString(buf, key);\\n        writeUInt64(buf, value);\\n    }\\n\\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\\n        writeString(buf, key);\\n        writeInt64(buf, value);\\n    }\\n\\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\\n        writeString(buf, key);\\n        writeBool(buf, value);\\n    }\\n\\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        writeNull(buf);\\n    }\\n\\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        writeUndefined(buf);\\n    }\\n\\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        startMap(buf);\\n    }\\n\\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\\n        writeString(buf, key);\\n        startArray(buf);\\n    }\\n\\n    function writeFixedNumeric(\\n        CBORBuffer memory buf,\\n        uint8 major,\\n        uint64 value\\n    ) private pure {\\n        if (value <= 23) {\\n            buf.buf.appendUint8(uint8((major << 5) | value));\\n        } else if (value <= 0xFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 24));\\n            buf.buf.appendInt(value, 1);\\n        } else if (value <= 0xFFFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 25));\\n            buf.buf.appendInt(value, 2);\\n        } else if (value <= 0xFFFFFFFF) {\\n            buf.buf.appendUint8(uint8((major << 5) | 26));\\n            buf.buf.appendInt(value, 4);\\n        } else {\\n            buf.buf.appendUint8(uint8((major << 5) | 27));\\n            buf.buf.appendInt(value, 8);\\n        }\\n    }\\n\\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\\n        private\\n        pure\\n    {\\n        buf.buf.appendUint8(uint8((major << 5) | 31));\\n    }\\n\\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\\n        private\\n        pure\\n    {\\n        writeFixedNumeric(buf, major, length);\\n    }\\n\\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=foundry-lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=foundry-lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=foundry-lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"erc4626-tests/=foundry-lib/openzeppelin-contracts/lib/erc4626-tests/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"linkToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxConsumersPerSubscription\",\"type\":\"uint16\"},{\"internalType\":\"uint72\",\"name\":\"adminFee\",\"type\":\"uint72\"},{\"internalType\":\"bytes4\",\"name\":\"handleOracleFulfillmentSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint16\",\"name\":\"gasForCallExactCheck\",\"type\":\"uint16\"},{\"internalType\":\"uint32[]\",\"name\":\"maxCallbackGasLimits\",\"type\":\"uint32[]\"},{\"internalType\":\"uint16\",\"name\":\"subscriptionDepositMinimumRequests\",\"type\":\"uint16\"},{\"internalType\":\"uint72\",\"name\":\"subscriptionDepositJuels\",\"type\":\"uint72\"}],\"internalType\":\"struct FunctionsRouter.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CannotRemoveWithPendingRequests\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"DuplicateRequestId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyRequestData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"limit\",\"type\":\"uint32\"}],\"name\":\"GasLimitTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"IdentifierIsReserved\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"currentBalanceJuels\",\"type\":\"uint96\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCalldata\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidConsumer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"value\",\"type\":\"uint8\"}],\"name\":\"InvalidGasFlagValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSubscription\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"}],\"name\":\"MustBeProposedOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustBeSubscriptionOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableFromCoordinator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCallableFromLink\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"RouteNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"SenderMustAcceptTermsOfService\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimeoutNotExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"maximumConsumers\",\"type\":\"uint16\"}],\"name\":\"TooManyConsumers\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxConsumersPerSubscription\",\"type\":\"uint16\"},{\"internalType\":\"uint72\",\"name\":\"adminFee\",\"type\":\"uint72\"},{\"internalType\":\"bytes4\",\"name\":\"handleOracleFulfillmentSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint16\",\"name\":\"gasForCallExactCheck\",\"type\":\"uint16\"},{\"internalType\":\"uint32[]\",\"name\":\"maxCallbackGasLimits\",\"type\":\"uint32[]\"},{\"internalType\":\"uint16\",\"name\":\"subscriptionDepositMinimumRequests\",\"type\":\"uint16\"},{\"internalType\":\"uint72\",\"name\":\"subscriptionDepositJuels\",\"type\":\"uint72\"}],\"indexed\":false,\"internalType\":\"struct FunctionsRouter.Config\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"ConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proposedContractSetId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposedContractSetFromAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposedContractSetToAddress\",\"type\":\"address\"}],\"name\":\"ContractProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"coordinator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum FunctionsResponse.FulfillResult\",\"name\":\"resultCode\",\"type\":\"uint8\"}],\"name\":\"RequestNotProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"totalCostJuels\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum FunctionsResponse.FulfillResult\",\"name\":\"resultCode\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"err\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callbackReturnData\",\"type\":\"bytes\"}],\"name\":\"RequestProcessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"donId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"subscriptionOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requestingContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requestInitiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"dataVersion\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"estimatedTotalCostJuels\",\"type\":\"uint96\"}],\"name\":\"RequestStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"RequestTimedOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundsRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundsAmount\",\"type\":\"uint256\"}],\"name\":\"SubscriptionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"SubscriptionConsumerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"SubscriptionConsumerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SubscriptionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"SubscriptionFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SubscriptionOwnerTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SubscriptionOwnerTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_CALLBACK_RETURN_BYTES\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"acceptSubscriptionOwnerTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"addConsumer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"cancelSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createSubscription\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"createSubscriptionWithConsumer\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"err\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"juelsPerGas\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"costWithoutCallback\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"coordinator\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"estimatedTotalCostJuels\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint72\",\"name\":\"adminFee\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"donFee\",\"type\":\"uint72\"},{\"internalType\":\"uint40\",\"name\":\"gasOverheadBeforeCallback\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"gasOverheadAfterCallback\",\"type\":\"uint40\"},{\"internalType\":\"uint32\",\"name\":\"timeoutTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct FunctionsResponse.Commitment\",\"name\":\"commitment\",\"type\":\"tuple\"}],\"name\":\"fulfill\",\"outputs\":[{\"internalType\":\"enum FunctionsResponse.FulfillResult\",\"name\":\"resultCode\",\"type\":\"uint8\"},{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdminFee\",\"outputs\":[{\"internalType\":\"uint72\",\"name\":\"\",\"type\":\"uint72\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowListId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxConsumersPerSubscription\",\"type\":\"uint16\"},{\"internalType\":\"uint72\",\"name\":\"adminFee\",\"type\":\"uint72\"},{\"internalType\":\"bytes4\",\"name\":\"handleOracleFulfillmentSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint16\",\"name\":\"gasForCallExactCheck\",\"type\":\"uint16\"},{\"internalType\":\"uint32[]\",\"name\":\"maxCallbackGasLimits\",\"type\":\"uint32[]\"},{\"internalType\":\"uint16\",\"name\":\"subscriptionDepositMinimumRequests\",\"type\":\"uint16\"},{\"internalType\":\"uint72\",\"name\":\"subscriptionDepositJuels\",\"type\":\"uint72\"}],\"internalType\":\"struct FunctionsRouter.Config\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"getConsumer\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"initiatedRequests\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"completedRequests\",\"type\":\"uint64\"}],\"internalType\":\"struct IFunctionsSubscriptions.Consumer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getContractById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"getFlags\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getProposedContractById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposedContractSet\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"getSubscription\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"blockedBalance\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"consumers\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"flags\",\"type\":\"bytes32\"}],\"internalType\":\"struct IFunctionsSubscriptions.Subscription\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubscriptionCount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionIdStart\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionIdEnd\",\"type\":\"uint64\"}],\"name\":\"getSubscriptionsInRange\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"blockedBalance\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"consumers\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"flags\",\"type\":\"bytes32\"}],\"internalType\":\"struct IFunctionsSubscriptions.Subscription[]\",\"name\":\"subscriptions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBalance\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"}],\"name\":\"isValidCallbackGasLimit\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onTokenTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"oracleWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"ownerCancelSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"ownerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"pendingRequestExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proposedContractSetIds\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"proposedContractSetAddresses\",\"type\":\"address[]\"}],\"name\":\"proposeContractsUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"proposeSubscriptionOwnerTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"recoverFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"}],\"name\":\"removeConsumer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"dataVersion\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"donId\",\"type\":\"bytes32\"}],\"name\":\"sendRequest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"dataVersion\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"donId\",\"type\":\"bytes32\"}],\"name\":\"sendRequestToProposed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"allowListId\",\"type\":\"bytes32\"}],\"name\":\"setAllowListId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"flags\",\"type\":\"bytes32\"}],\"name\":\"setFlags\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"coordinator\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"estimatedTotalCostJuels\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"callbackGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint72\",\"name\":\"adminFee\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"donFee\",\"type\":\"uint72\"},{\"internalType\":\"uint40\",\"name\":\"gasOverheadBeforeCallback\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"gasOverheadAfterCallback\",\"type\":\"uint40\"},{\"internalType\":\"uint32\",\"name\":\"timeoutTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct FunctionsResponse.Commitment[]\",\"name\":\"requestsToTimeoutByCommitment\",\"type\":\"tuple[]\"}],\"name\":\"timeoutRequests\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxConsumersPerSubscription\",\"type\":\"uint16\"},{\"internalType\":\"uint72\",\"name\":\"adminFee\",\"type\":\"uint72\"},{\"internalType\":\"bytes4\",\"name\":\"handleOracleFulfillmentSelector\",\"type\":\"bytes4\"},{\"internalType\":\"uint16\",\"name\":\"gasForCallExactCheck\",\"type\":\"uint16\"},{\"internalType\":\"uint32[]\",\"name\":\"maxCallbackGasLimits\",\"type\":\"uint32[]\"},{\"internalType\":\"uint16\",\"name\":\"subscriptionDepositMinimumRequests\",\"type\":\"uint16\"},{\"internalType\":\"uint72\",\"name\":\"subscriptionDepositJuels\",\"type\":\"uint72\"}],\"internalType\":\"struct FunctionsRouter.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"updateConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FunctionsRouter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000000ca7617500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000138800000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000493e0000000000000000000000000000000000000000000000000000000000007a12000000000000000000000000000000000000000000000000000000000000b71b000000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000000016e36000000000000000000000000000000000000000000000000000000000001e848000000000000000000000000000000000000000000000000000000000002625a000000000000000000000000000000000000000000000000000000000002dc6c000000000000000000000000000000000000000000000000000000000003567e000000000000000000000000000000000000000000000000000000000003d0900000000000000000000000000000000000000000000000000000000000044aa2000000000000000000000000000000000000000000000000000000000004c4b40", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}