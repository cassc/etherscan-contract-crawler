{"SourceCode": "//  ___  ___  ________  _____ ______   ________  ________  ________     \r\n// |\\  \\|\\  \\|\\   __  \\|\\   _ \\  _   \\|\\   __  \\|\\   ____\\|\\   __  \\    \r\n// \\ \\  \\\\\\  \\ \\  \\|\\  \\ \\  \\\\\\__\\ \\  \\ \\  \\|\\  \\ \\  \\___|\\ \\  \\|\\  \\   \r\n//  \\ \\   __  \\ \\   __  \\ \\  \\\\|__| \\  \\ \\   __  \\ \\  \\    \\ \\   __  \\  \r\n//   \\ \\  \\ \\  \\ \\  \\ \\  \\ \\  \\    \\ \\  \\ \\  \\ \\  \\ \\  \\____\\ \\  \\ \\  \\ \r\n//    \\ \\__\\ \\__\\ \\__\\ \\__\\ \\__\\    \\ \\__\\ \\__\\ \\__\\ \\_______\\ \\__\\ \\__\\\r\n//     \\|__|\\|__|\\|__|\\|__|\\|__|     \\|__|\\|__|\\|__|\\|_______|\\|__|\\|__|\r\n\r\n\r\n// File: solady/src/auth/Ownable.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\r\n///\r\n/// @dev Note:\r\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\r\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\r\n///\r\n/// While the ownable portion follows\r\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\r\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\r\nabstract contract Ownable {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The caller is not authorized to call the function.\r\n    error Unauthorized();\r\n\r\n    /// @dev The `newOwner` cannot be the zero address.\r\n    error NewOwnerIsZeroAddress();\r\n\r\n    /// @dev The `pendingOwner` does not have a valid handover request.\r\n    error NoHandoverRequest();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\r\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\r\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\r\n    /// despite it not being as lightweight as a single argument event.\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @dev An ownership handover to `pendingOwner` has been requested.\r\n    event OwnershipHandoverRequested(address indexed pendingOwner);\r\n\r\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\r\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\r\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\r\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\r\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\r\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\r\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\r\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\r\n    /// It is intentionally chosen to be a high value\r\n    /// to avoid collision with lower slots.\r\n    /// The choice of manual storage layout is to enable compatibility\r\n    /// with both regular and upgradeable contracts.\r\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\r\n\r\n    /// The ownership handover slot of `newOwner` is given by:\r\n    /// ```\r\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\r\n    ///     let handoverSlot := keccak256(0x00, 0x20)\r\n    /// ```\r\n    /// It stores the expiry timestamp of the two-step ownership handover.\r\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     INTERNAL FUNCTIONS                     */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Initializes the owner directly without authorization guard.\r\n    /// This function must be called upon initialization,\r\n    /// regardless of whether the contract is upgradeable or not.\r\n    /// This is to enable generalization to both regular and upgradeable contracts,\r\n    /// and to save gas in case the initial owner is not the caller.\r\n    /// For performance reasons, this function will not check if there\r\n    /// is an existing owner.\r\n    function _initializeOwner(address newOwner) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clean the upper 96 bits.\r\n            newOwner := shr(96, shl(96, newOwner))\r\n            // Store the new value.\r\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\r\n            // Emit the {OwnershipTransferred} event.\r\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\r\n        }\r\n    }\r\n\r\n    /// @dev Sets the owner directly without authorization guard.\r\n    function _setOwner(address newOwner) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ownerSlot := not(_OWNER_SLOT_NOT)\r\n            // Clean the upper 96 bits.\r\n            newOwner := shr(96, shl(96, newOwner))\r\n            // Emit the {OwnershipTransferred} event.\r\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\r\n            // Store the new value.\r\n            sstore(ownerSlot, newOwner)\r\n        }\r\n    }\r\n\r\n    /// @dev Throws if the sender is not the owner.\r\n    function _checkOwner() internal view virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // If the caller is not the stored owner, revert.\r\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\r\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\r\n    /// Override to return a different value if needed.\r\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\r\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\r\n        return 48 * 3600;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\r\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(shl(96, newOwner)) {\r\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows the owner to renounce their ownership.\r\n    function renounceOwnership() public payable virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /// @dev Request a two-step ownership handover to the caller.\r\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\r\n    function requestOwnershipHandover() public payable virtual {\r\n        unchecked {\r\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // Compute and set the handover slot to `expires`.\r\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n                mstore(0x00, caller())\r\n                sstore(keccak256(0x0c, 0x20), expires)\r\n                // Emit the {OwnershipHandoverRequested} event.\r\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\r\n    function cancelOwnershipHandover() public payable virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and set the handover slot to 0.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            sstore(keccak256(0x0c, 0x20), 0)\r\n            // Emit the {OwnershipHandoverCanceled} event.\r\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\r\n        }\r\n    }\r\n\r\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\r\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\r\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and set the handover slot to 0.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, pendingOwner)\r\n            let handoverSlot := keccak256(0x0c, 0x20)\r\n            // If the handover does not exist, or has expired.\r\n            if gt(timestamp(), sload(handoverSlot)) {\r\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Set the handover slot to 0.\r\n            sstore(handoverSlot, 0)\r\n        }\r\n        _setOwner(pendingOwner);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   PUBLIC READ FUNCTIONS                    */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the owner of the contract.\r\n    function owner() public view virtual returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := sload(not(_OWNER_SLOT_NOT))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\r\n    function ownershipHandoverExpiresAt(address pendingOwner)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the handover slot.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, pendingOwner)\r\n            // Load the handover slot.\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         MODIFIERS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Marks a function as only callable by the owner.\r\n    modifier onlyOwner() virtual {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n}\r\n\r\n// File: solady/src/tokens/ERC20.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Simple ERC20 + EIP-2612 implementation.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\r\n///\r\n/// @dev Note:\r\n/// The ERC20 standard allows minting and transferring to and from the zero address,\r\n/// minting and transferring zero tokens, as well as self-approvals.\r\n/// For performance, this implementation WILL NOT revert for such actions.\r\n/// Please add any checks with overrides if desired.\r\nabstract contract ERC20 {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The total supply has overflowed.\r\n    error TotalSupplyOverflow();\r\n\r\n    /// @dev The allowance has overflowed.\r\n    error AllowanceOverflow();\r\n\r\n    /// @dev The allowance has underflowed.\r\n    error AllowanceUnderflow();\r\n\r\n    /// @dev Insufficient balance.\r\n    error InsufficientBalance();\r\n\r\n    /// @dev Insufficient allowance.\r\n    error InsufficientAllowance();\r\n\r\n    /// @dev The permit is invalid.\r\n    error InvalidPermit();\r\n\r\n    /// @dev The permit has expired.\r\n    error PermitExpired();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\r\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\r\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The storage slot for the total supply.\r\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\r\n\r\n    /// @dev The balance slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\r\n    /// ```\r\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\r\n\r\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\r\n    /// ```\r\n    ///     mstore(0x20, spender)\r\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\r\n    /// ```\r\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\r\n\r\n    /// @dev The nonce slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\r\n    /// ```\r\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       ERC20 METADATA                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the name of the token.\r\n    function name() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the symbol of the token.\r\n    function symbol() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the decimals places of the token.\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           ERC20                            */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the amount of tokens in existence.\r\n    function totalSupply() public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := sload(_TOTAL_SUPPLY_SLOT)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens owned by `owner`.\r\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x34))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and store the amount.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            sstore(keccak256(0x0c, 0x34), amount)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Atomically increases the allowance granted to `spender` by the caller.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function increaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowanceBefore := sload(allowanceSlot)\r\n            // Add to the allowance.\r\n            let allowanceAfter := add(allowanceBefore, difference)\r\n            // Revert upon overflow.\r\n            if lt(allowanceAfter, allowanceBefore) {\r\n                mstore(0x00, 0xf9067066) // `AllowanceOverflow()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Store the updated allowance.\r\n            sstore(allowanceSlot, allowanceAfter)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, allowanceAfter)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function decreaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowanceBefore := sload(allowanceSlot)\r\n            // Revert if will underflow.\r\n            if lt(allowanceBefore, difference) {\r\n                mstore(0x00, 0x8301ab38) // `AllowanceUnderflow()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated allowance.\r\n            let allowanceAfter := sub(allowanceBefore, difference)\r\n            sstore(allowanceSlot, allowanceAfter)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, allowanceAfter)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer `amount` tokens from the caller to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        _beforeTokenTransfer(msg.sender, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers `amount` tokens from `from` to `to`.\r\n    ///\r\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\r\n        _beforeTokenTransfer(from, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let from_ := shl(96, from)\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, caller())\r\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowance_ := sload(allowanceSlot)\r\n            // If the allowance is not the maximum uint256 value.\r\n            if iszero(eq(allowance_, not(0))) {\r\n                // Revert if the amount to be transferred exceeds the allowance.\r\n                if gt(amount, allowance_) {\r\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Subtract and store the updated allowance.\r\n                sstore(allowanceSlot, sub(allowance_, amount))\r\n            }\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          EIP-2612                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the current nonce for `owner`.\r\n    /// This value is used to compute the signature for EIP-2612 permit.\r\n    function nonces(address owner) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the nonce slot and load its value.\r\n            mstore(0x0c, _NONCES_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\r\n    /// authorized by a signed approval by `owner`.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        bytes32 domainSeparator = DOMAIN_SEPARATOR();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            let m := mload(0x40)\r\n            // Revert if the block timestamp greater than `deadline`.\r\n            if gt(timestamp(), deadline) {\r\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Clean the upper 96 bits.\r\n            owner := shr(96, shl(96, owner))\r\n            spender := shr(96, shl(96, spender))\r\n            // Compute the nonce slot and load its value.\r\n            mstore(0x0c, _NONCES_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            let nonceSlot := keccak256(0x0c, 0x20)\r\n            let nonceValue := sload(nonceSlot)\r\n            // Increment and store the updated nonce.\r\n            sstore(nonceSlot, add(nonceValue, 1))\r\n            // Prepare the inner hash.\r\n            // `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\r\n            // forgefmt: disable-next-item\r\n            mstore(m, 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9)\r\n            mstore(add(m, 0x20), owner)\r\n            mstore(add(m, 0x40), spender)\r\n            mstore(add(m, 0x60), value)\r\n            mstore(add(m, 0x80), nonceValue)\r\n            mstore(add(m, 0xa0), deadline)\r\n            // Prepare the outer hash.\r\n            mstore(0, 0x1901)\r\n            mstore(0x20, domainSeparator)\r\n            mstore(0x40, keccak256(m, 0xc0))\r\n            // Prepare the ecrecover calldata.\r\n            mstore(0, keccak256(0x1e, 0x42))\r\n            mstore(0x20, and(0xff, v))\r\n            mstore(0x40, r)\r\n            mstore(0x60, s)\r\n            pop(staticcall(gas(), 1, 0, 0x80, 0x20, 0x20))\r\n            // If the ecrecover fails, the returndatasize will be 0x00,\r\n            // `owner` will be be checked if it equals the hash at 0x00,\r\n            // which evaluates to false (i.e. 0), and we will revert.\r\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\r\n            // `owner` will be compared against the returned address at 0x20.\r\n            if iszero(eq(mload(returndatasize()), owner)) {\r\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Compute the allowance slot and store the value.\r\n            // The `owner` is already at slot 0x20.\r\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\r\n            sstore(keccak256(0x2c, 0x34), value)\r\n            // Emit the {Approval} event.\r\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the EIP-2612 domains separator.\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := mload(0x40) // Grab the free memory pointer.\r\n        }\r\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\r\n        bytes32 nameHash = keccak256(bytes(name()));\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := result\r\n            // `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\r\n            // forgefmt: disable-next-item\r\n            mstore(m, 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f)\r\n            mstore(add(m, 0x20), nameHash)\r\n            // `keccak256(\"1\")`.\r\n            // forgefmt: disable-next-item\r\n            mstore(add(m, 0x40), 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6)\r\n            mstore(add(m, 0x60), chainid())\r\n            mstore(add(m, 0x80), address())\r\n            result := keccak256(m, 0xa0)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL MINT FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(address(0), to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\r\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\r\n            // Revert if the total supply overflows.\r\n            if lt(totalSupplyAfter, totalSupplyBefore) {\r\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Store the updated total supply.\r\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(address(0), to, amount);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL BURN FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(from, address(0), amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, from)\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Subtract and store the updated total supply.\r\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\r\n        }\r\n        _afterTokenTransfer(from, address(0), amount);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Moves `amount` of tokens from `from` to `to`.\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(from, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let from_ := shl(96, from)\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowance_ := sload(allowanceSlot)\r\n            // If the allowance is not the maximum uint256 value.\r\n            if iszero(eq(allowance_, not(0))) {\r\n                // Revert if the amount to be transferred exceeds the allowance.\r\n                if gt(amount, allowance_) {\r\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Subtract and store the updated allowance.\r\n                sstore(allowanceSlot, sub(allowance_, amount))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let owner_ := shl(96, owner)\r\n            // Compute the allowance slot and store the amount.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\r\n            sstore(keccak256(0x0c, 0x34), amount)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     HOOKS TO OVERRIDE                      */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Hook that is called before any transfer of tokens.\r\n    /// This includes minting and burning.\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n    /// @dev Hook that is called after any transfer of tokens.\r\n    /// This includes minting and burning.\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\n\r\n// File: hama/hama.sol\r\n\r\n\r\npragma solidity ^0.8.13;\r\n\r\n\r\n\r\ncontract HamacaToken is Ownable, ERC20{\r\n    \r\n    bool public limited;\r\n    uint256 public maxHoldingAmount;\r\n    uint256 public minHoldingAmount;\r\n    address public liquidityPair;\r\n    mapping(address => bool) public blacklists;\r\n    mapping(uint256 => bool) public claimed;\r\n\r\n    constructor() ERC20() {\r\n        _initializeOwner(0x11F9e0e1760c45B942874b1417d8383d724A5635);\r\n        _mint(0x11F9e0e1760c45B942874b1417d8383d724A5635, 18900000000000000000000000000);\r\n        _mint(0x55AA01b62ED325bDcce1738562ed8d510CBc934d,1050000000000000000000000000);\r\n        _mint(0x6Eb3b4FbCd7394b4a81cF3FE5CB47A35cfBa5505,1050000000000000000000000000);\r\n    }\r\n\r\n    /// @dev Returns the name of the token.\r\n    function name() public view virtual override returns (string memory) {\r\n        return \"Hamaca\";\r\n    }\r\n\r\n    /// @dev Returns the symbol of the token.\r\n    function symbol() public view virtual override returns (string memory){\r\n        return \"HAMA\";\r\n    }\r\n\r\n    function blacklist(address _address, bool _isBlacklisting) external onlyOwner {\r\n        blacklists[_address] = _isBlacklisting;\r\n    }\r\n\r\n    function setRule(bool _limited, address _liquidityPair, uint256 _maxHoldingAmount, uint256 _minHoldingAmount) external onlyOwner {\r\n        limited = _limited;\r\n        liquidityPair = _liquidityPair;\r\n        maxHoldingAmount = _maxHoldingAmount;\r\n        minHoldingAmount = _minHoldingAmount;\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) override internal virtual {\r\n        require(!blacklists[to] && !blacklists[from], \"Blacklisted\");\r\n\r\n        if (liquidityPair == address(0)) {\r\n            require(from == owner() || to == owner() || from == address(0), \"trading is not started\");\r\n            return;\r\n        }\r\n\r\n        if (limited && from == liquidityPair) {\r\n            require(super.balanceOf(to) + amount <= maxHoldingAmount && super.balanceOf(to) + amount >= minHoldingAmount, \"Forbid\");\r\n        }\r\n    }\r\n\r\n    function burn(uint256 value) external {\r\n        _burn(msg.sender, value);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AllowanceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AllowanceUnderflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPermit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TotalSupplyOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBlacklisting\",\"type\":\"bool\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"difference\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"difference\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limited\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxHoldingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minHoldingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_limited\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_liquidityPair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxHoldingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minHoldingAmount\",\"type\":\"uint256\"}],\"name\":\"setRule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "HamacaToken", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://68762856fe4ad7c4d1236e3f9b903971e2cffdfd5968a5925c7c16c4af9e2a6a"}