{"SourceCode": "// File: contracts/lib/math/SafeMath.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ownership/Ownable.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be aplied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), owner);\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier throws if called by any account other than the pendingOwner.\r\n    */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == pendingOwner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to set the pendingOwner address.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the pendingOwner address to finalize the transfer.\r\n    */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(owner, pendingOwner);\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/utils/ReentrancyGuard.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n// File: contracts/Utils.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\ninterface ERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ninterface MarketDapp {\r\n    // Returns the address to approve tokens for\r\n    function tokenReceiver(address[] calldata assetIds, uint256[] calldata dataValues, address[] calldata addresses) external view returns(address);\r\n    function trade(address[] calldata assetIds, uint256[] calldata dataValues, address[] calldata addresses, address payable recipient) external payable;\r\n}\r\n\r\n/// @title Util functions for the BrokerV2 contract for Switcheo Exchange\r\n/// @author Switcheo Network\r\n/// @notice Functions were moved from the BrokerV2 contract into this contract\r\n/// so that the BrokerV2 contract would not exceed the maximum contract size of\r\n/// 24 KB.\r\nlibrary Utils {\r\n    using SafeMath for uint256;\r\n\r\n    // The constants for EIP-712 are precompiled to reduce contract size,\r\n    // the original values are left here for reference and verification.\r\n    //\r\n    // bytes32 public constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"EIP712Domain(\",\r\n    //         \"string name,\",\r\n    //         \"string version,\",\r\n    //         \"uint256 chainId,\",\r\n    //         \"address verifyingContract,\",\r\n    //         \"bytes32 salt\",\r\n    //     \")\"\r\n    // ));\r\n    // bytes32 public constant EIP712_DOMAIN_TYPEHASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;\r\n    //\r\n    // bytes32 public constant CONTRACT_NAME = keccak256(\"Switcheo Exchange\");\r\n    // bytes32 public constant CONTRACT_VERSION = keccak256(\"2\");\r\n    // uint256 public constant CHAIN_ID = 1;\r\n    // address public constant VERIFYING_CONTRACT = 0x7ee7Ca6E75dE79e618e88bDf80d0B1DB136b22D0;\r\n    // bytes32 public constant SALT = keccak256(\"switcheo-eth-salt\");\r\n\r\n    // bytes32 public constant DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n    //     EIP712_DOMAIN_TYPEHASH,\r\n    //     CONTRACT_NAME,\r\n    //     CONTRACT_VERSION,\r\n    //     CHAIN_ID,\r\n    //     VERIFYING_CONTRACT,\r\n    //     SALT\r\n    // ));\r\n    bytes32 public constant DOMAIN_SEPARATOR = 0x256c0713d13c6a01bd319a2f7edabde771b6c167d37c01778290d60b362ccc7d;\r\n\r\n    // bytes32 public constant OFFER_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Offer(\",\r\n    //         \"address maker,\",\r\n    //         \"address offerAssetId,\",\r\n    //         \"uint256 offerAmount,\",\r\n    //         \"address wantAssetId,\",\r\n    //         \"uint256 wantAmount,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant OFFER_TYPEHASH = 0xf845c83a8f7964bc8dd1a092d28b83573b35be97630a5b8a3b8ae2ae79cd9260;\r\n\r\n    // bytes32 public constant CANCEL_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Cancel(\",\r\n    //         \"bytes32 offerHash,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant CANCEL_TYPEHASH = 0x46f6d088b1f0ff5a05c3f232c4567f2df96958e05457e6c0e1221dcee7d69c18;\r\n\r\n    // bytes32 public constant FILL_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Fill(\",\r\n    //         \"address filler,\",\r\n    //         \"address offerAssetId,\",\r\n    //         \"uint256 offerAmount,\",\r\n    //         \"address wantAssetId,\",\r\n    //         \"uint256 wantAmount,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant FILL_TYPEHASH = 0x5f59dbc3412a4575afed909d028055a91a4250ce92235f6790c155a4b2669e99;\r\n\r\n    // The Ether token address is set as the constant 0x00 for backwards\r\n    // compatibility\r\n    address private constant ETHER_ADDR = address(0);\r\n\r\n    uint256 private constant mask8 = ~(~uint256(0) << 8);\r\n    uint256 private constant mask16 = ~(~uint256(0) << 16);\r\n    uint256 private constant mask24 = ~(~uint256(0) << 24);\r\n    uint256 private constant mask32 = ~(~uint256(0) << 32);\r\n    uint256 private constant mask40 = ~(~uint256(0) << 40);\r\n    uint256 private constant mask48 = ~(~uint256(0) << 48);\r\n    uint256 private constant mask56 = ~(~uint256(0) << 56);\r\n    uint256 private constant mask120 = ~(~uint256(0) << 120);\r\n    uint256 private constant mask128 = ~(~uint256(0) << 128);\r\n    uint256 private constant mask136 = ~(~uint256(0) << 136);\r\n    uint256 private constant mask144 = ~(~uint256(0) << 144);\r\n\r\n    event Trade(\r\n        address maker,\r\n        address taker,\r\n        address makerGiveAsset,\r\n        uint256 makerGiveAmount,\r\n        address fillerGiveAsset,\r\n        uint256 fillerGiveAmount\r\n    );\r\n\r\n    /// @dev Calculates the balance increments for a set of trades\r\n    /// @param _values The _values param from the trade method\r\n    /// @param _incrementsLength Should match the value of _addresses.length / 2\r\n    /// from the trade method\r\n    /// @return An array of increments\r\n    function calculateTradeIncrements(\r\n        uint256[] memory _values,\r\n        uint256 _incrementsLength\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory increments = new uint256[](_incrementsLength);\r\n        _creditFillBalances(increments, _values);\r\n        _creditMakerBalances(increments, _values);\r\n        _creditMakerFeeBalances(increments, _values);\r\n        return increments;\r\n    }\r\n\r\n    /// @dev Calculates the balance decrements for a set of trades\r\n    /// @param _values The _values param from the trade method\r\n    /// @param _decrementsLength Should match the value of _addresses.length / 2\r\n    /// from the trade method\r\n    /// @return An array of decrements\r\n    function calculateTradeDecrements(\r\n        uint256[] memory _values,\r\n        uint256 _decrementsLength\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory decrements = new uint256[](_decrementsLength);\r\n        _deductFillBalances(decrements, _values);\r\n        _deductMakerBalances(decrements, _values);\r\n        return decrements;\r\n    }\r\n\r\n    /// @dev Calculates the balance increments for a set of network trades\r\n    /// @param _values The _values param from the networkTrade method\r\n    /// @param _incrementsLength Should match the value of _addresses.length / 2\r\n    /// from the networkTrade method\r\n    /// @return An array of increments\r\n    function calculateNetworkTradeIncrements(\r\n        uint256[] memory _values,\r\n        uint256 _incrementsLength\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory increments = new uint256[](_incrementsLength);\r\n        _creditMakerBalances(increments, _values);\r\n        _creditMakerFeeBalances(increments, _values);\r\n        return increments;\r\n    }\r\n\r\n    /// @dev Calculates the balance decrements for a set of network trades\r\n    /// @param _values The _values param from the trade method\r\n    /// @param _decrementsLength Should match the value of _addresses.length / 2\r\n    /// from the networkTrade method\r\n    /// @return An array of decrements\r\n    function calculateNetworkTradeDecrements(\r\n        uint256[] memory _values,\r\n        uint256 _decrementsLength\r\n    )\r\n        public\r\n        pure\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory decrements = new uint256[](_decrementsLength);\r\n        _deductMakerBalances(decrements, _values);\r\n        return decrements;\r\n    }\r\n\r\n    /// @dev Validates `BrokerV2.trade` parameters to ensure trade fairness,\r\n    /// see `BrokerV2.trade` for param details.\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes Hashes from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function validateTrades(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        public\r\n        returns (bytes32[] memory)\r\n    {\r\n        _validateTradeInputLengths(_values, _hashes);\r\n        _validateUniqueOffers(_values);\r\n        _validateMatches(_values, _addresses);\r\n        _validateFillAmounts(_values);\r\n        _validateTradeData(_values, _addresses, _operator);\r\n\r\n        // validate signatures of all offers\r\n        _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            OFFER_TYPEHASH,\r\n            0,\r\n            _values[0] & mask8 // numOffers\r\n        );\r\n\r\n        // validate signatures of all fills\r\n        _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            FILL_TYPEHASH,\r\n            _values[0] & mask8, // numOffers\r\n            (_values[0] & mask8) + ((_values[0] & mask16) >> 8) // numOffers + numFills\r\n        );\r\n\r\n        _emitTradeEvents(_values, _addresses, new address[](0), false);\r\n\r\n        return _hashes;\r\n    }\r\n\r\n    /// @dev Validates `BrokerV2.networkTrade` parameters to ensure trade fairness,\r\n    /// see `BrokerV2.networkTrade` for param details.\r\n    /// @param _values Values from `networkTrade`\r\n    /// @param _hashes Hashes from `networkTrade`\r\n    /// @param _addresses Addresses from `networkTrade`\r\n    /// @param _operator Address of the `BrokerV2.operator`\r\n    function validateNetworkTrades(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32[] memory)\r\n    {\r\n        _validateNetworkTradeInputLengths(_values, _hashes);\r\n        _validateUniqueOffers(_values);\r\n        _validateNetworkMatches(_values, _addresses, _operator);\r\n        _validateTradeData(_values, _addresses, _operator);\r\n\r\n        // validate signatures of all offers\r\n        _validateTradeSignatures(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            OFFER_TYPEHASH,\r\n            0,\r\n            _values[0] & mask8 // numOffers\r\n        );\r\n\r\n        return _hashes;\r\n    }\r\n\r\n    /// @dev Executes trades against external markets,\r\n    /// see `BrokerV2.networkTrade` for param details.\r\n    /// @param _values Values from `networkTrade`\r\n    /// @param _addresses Addresses from `networkTrade`\r\n    /// @param _marketDapps See `BrokerV2.marketDapps`\r\n    function performNetworkTrades(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address[] memory _marketDapps\r\n    )\r\n        public\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\r\n        // i = 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & mask8) * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for(i; i < end; i++) {\r\n            uint256[] memory data = new uint256[](9);\r\n            data[0] = _values[i]; // match data\r\n            data[1] = data[0] & mask8; // offerIndex\r\n            data[2] = (data[0] & mask24) >> 16; // operator.surplusAssetIndex\r\n            data[3] = _values[data[1] * 2 + 1]; // offer.dataA\r\n            data[4] = _values[data[1] * 2 + 2]; // offer.dataB\r\n            data[5] = ((data[3] & mask16) >> 8); // maker.offerAssetIndex\r\n            data[6] = ((data[3] & mask24) >> 16); // maker.wantAssetIndex\r\n            // amount of offerAssetId to take from the offer is equal to the match.takeAmount\r\n            data[7] = data[0] >> 128;\r\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\r\n            data[8] = data[7].mul(data[4] >> 128).div(data[4] & mask128);\r\n\r\n            address[] memory assetIds = new address[](3);\r\n            assetIds[0] = _addresses[data[5] * 2 + 1]; // offer.offerAssetId\r\n            assetIds[1] = _addresses[data[6] * 2 + 1]; // offer.wantAssetId\r\n            assetIds[2] = _addresses[data[2] * 2 + 1]; // surplusAssetId\r\n\r\n            uint256[] memory dataValues = new uint256[](3);\r\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\r\n            dataValues[1] = data[8]; // the proportion of wantAmount to receive for the offer\r\n            dataValues[2] = data[0]; // match data\r\n\r\n            increments[data[2]] = _performNetworkTrade(\r\n                assetIds,\r\n                dataValues,\r\n                _marketDapps,\r\n                _addresses\r\n            );\r\n        }\r\n\r\n        _emitTradeEvents(_values, _addresses, _marketDapps, true);\r\n\r\n        return increments;\r\n    }\r\n\r\n    /// @dev Validates the signature of a cancel invocation\r\n    /// @param _values The _values param from the cancel method\r\n    /// @param _hashes The _hashes param from the cancel method\r\n    /// @param _addresses The _addresses param from the cancel method\r\n    function validateCancel(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses\r\n    )\r\n        public\r\n        pure\r\n    {\r\n        bytes32 offerHash = hashOffer(_values, _addresses);\r\n\r\n        bytes32 cancelHash = keccak256(abi.encode(\r\n            CANCEL_TYPEHASH,\r\n            offerHash,\r\n            _addresses[4],\r\n            _values[1] >> 128\r\n        ));\r\n\r\n        validateSignature(\r\n            cancelHash,\r\n            _addresses[0], // maker\r\n            uint8((_values[2] & mask144) >> 136), // v\r\n            _hashes[0], // r\r\n            _hashes[1], // s\r\n            ((_values[2] & mask136) >> 128) != 0 // prefixedSignature\r\n        );\r\n    }\r\n\r\n    /// @dev Hashes an offer for the cancel method\r\n    /// @param _values The _values param from the cancel method\r\n    /// @param _addresses THe _addresses param from the cancel method\r\n    /// @return The hash of the offer\r\n    function hashOffer(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(\r\n            OFFER_TYPEHASH,\r\n            _addresses[0], // maker\r\n            _addresses[1], // offerAssetId\r\n            _values[0] & mask128, // offerAmount\r\n            _addresses[2], // wantAssetId\r\n            _values[0] >> 128, // wantAmount\r\n            _addresses[3], // feeAssetId\r\n            _values[1] & mask128, // feeAmount\r\n            _values[2] >> 144 // offerNonce\r\n        ));\r\n    }\r\n\r\n    /// @notice Approves a token transfer\r\n    /// @param _assetId The address of the token to approve\r\n    /// @param _spender The address of the spender to approve\r\n    /// @param _amount The number of tokens to approve\r\n    function approveTokenTransfer(\r\n        address _assetId,\r\n        address _spender,\r\n        uint256 _amount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        // Some tokens have an `approve` which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"approve(address,uint256)\",\r\n            _spender,\r\n            _amount\r\n        );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n    }\r\n\r\n    /// @notice Transfers tokens into the contract\r\n    /// @param _user The address to transfer the tokens from\r\n    /// @param _assetId The address of the token to transfer\r\n    /// @param _amount The number of tokens to transfer\r\n    /// @param _expectedAmount The number of tokens expected to be received,\r\n    /// this may not match `_amount`, for example, tokens which have a\r\n    /// proportion burnt on transfer will have a different amount received.\r\n    function transferTokensIn(\r\n        address _user,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        uint256 _expectedAmount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        uint256 initialBalance = tokenBalance(_assetId);\r\n\r\n        // Some tokens have a `transferFrom` which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"transferFrom(address,address,uint256)\",\r\n            _user,\r\n            address(this),\r\n            _amount\r\n        );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n\r\n        uint256 finalBalance = tokenBalance(_assetId);\r\n        uint256 transferredAmount = finalBalance.sub(initialBalance);\r\n\r\n        require(transferredAmount == _expectedAmount, \"Invalid transfer\");\r\n    }\r\n\r\n    /// @notice Transfers tokens from the contract to a user\r\n    /// @param _receivingAddress The address to transfer the tokens to\r\n    /// @param _assetId The address of the token to transfer\r\n    /// @param _amount The number of tokens to transfer\r\n    function transferTokensOut(\r\n        address _receivingAddress,\r\n        address _assetId,\r\n        uint256 _amount\r\n    )\r\n        public\r\n    {\r\n        _validateContractAddress(_assetId);\r\n\r\n        // Some tokens have a `transfer` which returns a boolean and some do not.\r\n        // The ERC20 interface cannot be used here because it requires specifying\r\n        // an explicit return value, and an EVM exception would be raised when calling\r\n        // a token with the mismatched return value.\r\n        bytes memory payload = abi.encodeWithSignature(\r\n                                   \"transfer(address,uint256)\",\r\n                                   _receivingAddress,\r\n                                   _amount\r\n                               );\r\n        bytes memory returnData = _callContract(_assetId, payload);\r\n\r\n        // Ensure that the asset transfer succeeded\r\n        _validateContractCallResult(returnData);\r\n    }\r\n\r\n    /// @notice Returns the number of tokens owned by this contract\r\n    /// @param _assetId The address of the token to query\r\n    function externalBalance(address _assetId) public view returns (uint256) {\r\n        if (_assetId == ETHER_ADDR) {\r\n            return address(this).balance;\r\n        }\r\n        return tokenBalance(_assetId);\r\n    }\r\n\r\n    /// @notice Returns the number of tokens owned by this contract.\r\n    /// @dev This will not work for Ether tokens, use `externalBalance` for\r\n    /// Ether tokens.\r\n    /// @param _assetId The address of the token to query\r\n    function tokenBalance(address _assetId) public view returns (uint256) {\r\n        return ERC20(_assetId).balanceOf(address(this));\r\n    }\r\n\r\n    /// @dev Validates that the specified `_hash` was signed by the specified `_user`.\r\n    /// This method supports the EIP712 specification, the older Ethereum\r\n    /// signed message specification is also supported for backwards compatibility.\r\n    /// @param _hash The original hash that was signed by the user\r\n    /// @param _user The user who signed the hash\r\n    /// @param _v The `v` component of the `_user`'s signature\r\n    /// @param _r The `r` component of the `_user`'s signature\r\n    /// @param _s The `s` component of the `_user`'s signature\r\n    /// @param _prefixed If true, the signature will be verified\r\n    /// against the Ethereum signed message specification instead of the\r\n    /// EIP712 specification\r\n    function validateSignature(\r\n        bytes32 _hash,\r\n        address _user,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        bool _prefixed\r\n    )\r\n        public\r\n        pure\r\n    {\r\n        bytes32 eip712Hash = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            _hash\r\n        ));\r\n\r\n        if (_prefixed) {\r\n            bytes32 prefixedHash = keccak256(abi.encodePacked(\r\n                \"\\x19Ethereum Signed Message:\\n32\",\r\n                eip712Hash\r\n            ));\r\n            require(_user == ecrecover(prefixedHash, _v, _r, _s), \"Invalid signature\");\r\n        } else {\r\n            require(_user == ecrecover(eip712Hash, _v, _r, _s), \"Invalid signature\");\r\n        }\r\n    }\r\n\r\n    /// @dev Ensures that `_address` is not the zero address\r\n    /// @param _address The address to check\r\n    function validateAddress(address _address) public pure {\r\n        require(_address != address(0), \"Invalid address\");\r\n    }\r\n\r\n    /// @dev Credit fillers for each fill.wantAmount,and credit the operator\r\n    /// for each fill.feeAmount. See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _creditFillBalances(\r\n        uint256[] memory _increments,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & mask8) * 2;\r\n        // i + numFills * 2\r\n        uint256 end = i + ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        // loop fills\r\n        for(i; i < end; i += 2) {\r\n            uint256 fillerWantAssetIndex = (_values[i] & mask24) >> 16;\r\n            uint256 wantAmount = _values[i + 1] >> 128;\r\n\r\n            // credit fill.wantAmount to filler\r\n            _increments[fillerWantAssetIndex] = _increments[fillerWantAssetIndex].add(wantAmount);\r\n\r\n            uint256 feeAmount = _values[i] >> 128;\r\n            if (feeAmount == 0) { continue; }\r\n\r\n            uint256 operatorFeeAssetIndex = ((_values[i] & mask40) >> 32);\r\n            // credit fill.feeAmount to operator\r\n            _increments[operatorFeeAssetIndex] = _increments[operatorFeeAssetIndex].add(feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Credit makers for each amount received through a matched fill.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _creditMakerBalances(\r\n        uint256[] memory _increments,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 i = 1;\r\n        // i += numOffers * 2\r\n        i += (_values[0] & mask8) * 2;\r\n        // i += numFills * 2\r\n        i += ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for(i; i < end; i++) {\r\n            // match.offerIndex\r\n            uint256 offerIndex = _values[i] & mask8;\r\n            // maker.wantAssetIndex\r\n            uint256 makerWantAssetIndex = (_values[1 + offerIndex * 2] & mask24) >> 16;\r\n\r\n            // match.takeAmount\r\n            uint256 amount = _values[i] >> 128;\r\n            // receiveAmount = match.takeAmount * offer.wantAmount / offer.offerAmount\r\n            amount = amount.mul(_values[2 + offerIndex * 2] >> 128)\r\n                           .div(_values[2 + offerIndex * 2] & mask128);\r\n\r\n            // credit maker for the amount received from the match\r\n            _increments[makerWantAssetIndex] = _increments[makerWantAssetIndex].add(amount);\r\n        }\r\n    }\r\n\r\n    /// @dev Credit the operator for each offer.feeAmount if the offer has not\r\n    /// been recorded through a previous `trade` call.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _creditMakerFeeBalances(\r\n        uint256[] memory _increments,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 i = 1;\r\n        // i + numOffers * 2\r\n        uint256 end = i + (_values[0] & mask8) * 2;\r\n\r\n        // loop offers\r\n        for(i; i < end; i += 2) {\r\n            bool nonceTaken = ((_values[i] & mask128) >> 120) == 1;\r\n            if (nonceTaken) { continue; }\r\n\r\n            uint256 feeAmount = _values[i] >> 128;\r\n            if (feeAmount == 0) { continue; }\r\n\r\n            uint256 operatorFeeAssetIndex = (_values[i] & mask40) >> 32;\r\n\r\n            // credit make.feeAmount to operator\r\n            _increments[operatorFeeAssetIndex] = _increments[operatorFeeAssetIndex].add(feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Deduct tokens from fillers for each fill.offerAmount\r\n    /// and each fill.feeAmount.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _deductFillBalances(\r\n        uint256[] memory _decrements,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & mask8) * 2;\r\n        // i + numFills * 2\r\n        uint256 end = i + ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        // loop fills\r\n        for(i; i < end; i += 2) {\r\n            uint256 fillerOfferAssetIndex = (_values[i] & mask16) >> 8;\r\n            uint256 offerAmount = _values[i + 1] & mask128;\r\n\r\n            // deduct fill.offerAmount from filler\r\n            _decrements[fillerOfferAssetIndex] = _decrements[fillerOfferAssetIndex].add(offerAmount);\r\n\r\n            uint256 feeAmount = _values[i] >> 128;\r\n            if (feeAmount == 0) { continue; }\r\n\r\n            // deduct fill.feeAmount from filler\r\n            uint256 fillerFeeAssetIndex = (_values[i] & mask32) >> 24;\r\n            _decrements[fillerFeeAssetIndex] = _decrements[fillerFeeAssetIndex].add(feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Deduct tokens from makers for each offer.offerAmount\r\n    /// and each offer.feeAmount if the offer has not been recorded\r\n    /// through a previous `trade` call.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _deductMakerBalances(\r\n        uint256[] memory _decrements,\r\n        uint256[] memory _values\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 i = 1;\r\n        // i + numOffers * 2\r\n        uint256 end = i + (_values[0] & mask8) * 2;\r\n\r\n        // loop offers\r\n        for(i; i < end; i += 2) {\r\n            bool nonceTaken = ((_values[i] & mask128) >> 120) == 1;\r\n            if (nonceTaken) { continue; }\r\n\r\n            uint256 makerOfferAssetIndex = (_values[i] & mask16) >> 8;\r\n            uint256 offerAmount = _values[i + 1] & mask128;\r\n\r\n            // deduct make.offerAmount from maker\r\n            _decrements[makerOfferAssetIndex] = _decrements[makerOfferAssetIndex].add(offerAmount);\r\n\r\n            uint256 feeAmount = _values[i] >> 128;\r\n            if (feeAmount == 0) { continue; }\r\n\r\n            // deduct make.feeAmount from maker\r\n            uint256 makerFeeAssetIndex = (_values[i] & mask32) >> 24;\r\n            _decrements[makerFeeAssetIndex] = _decrements[makerFeeAssetIndex].add(feeAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Emits trade events for easier tracking\r\n    /// @param _values The _values param from the trade / networkTrade method\r\n    /// @param _addresses The _addresses param from the trade / networkTrade method\r\n    /// @param _marketDapps The _marketDapps from BrokerV2\r\n    /// @param _forNetworkTrade Whether this is called from the networkTrade method\r\n    function _emitTradeEvents(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address[] memory _marketDapps,\r\n        bool _forNetworkTrade\r\n    )\r\n        private\r\n    {\r\n        uint256 i = 1;\r\n        // i += numOffers * 2\r\n        i += (_values[0] & mask8) * 2;\r\n        // i += numFills * 2\r\n        i += ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for(i; i < end; i++) {\r\n            uint256[] memory data = new uint256[](7);\r\n            data[0] = _values[i] & mask8; // match.offerIndex\r\n            data[1] = _values[1 + data[0] * 2] & mask8; // makerIndex\r\n            data[2] = (_values[1 + data[0] * 2] & mask16) >> 8; // makerOfferAssetIndex\r\n            data[3] = (_values[1 + data[0] * 2] & mask24) >> 16; // makerWantAssetIndex\r\n            data[4] = _values[i] >> 128; // match.takeAmount\r\n            // receiveAmount = match.takeAmount * offer.wantAmount / offer.offerAmount\r\n            data[5] = data[4].mul(_values[2 + data[0] * 2] >> 128)\r\n                             .div(_values[2 + data[0] * 2] & mask128);\r\n            // match.fillIndex for `trade`, marketDappIndex for `networkTrade`\r\n            data[6] = (_values[i] & mask16) >> 8;\r\n\r\n            address filler;\r\n            if (_forNetworkTrade) {\r\n                filler = _marketDapps[data[6]];\r\n            } else {\r\n                uint256 fillerIndex = (_values[1 + data[6] * 2] & mask8);\r\n                filler = _addresses[fillerIndex * 2];\r\n            }\r\n\r\n            emit Trade(\r\n                _addresses[data[1] * 2], // maker\r\n                filler,\r\n                _addresses[data[2] * 2 + 1], // makerGiveAsset\r\n                data[4], // makerGiveAmount\r\n                _addresses[data[3] * 2 + 1], // fillerGiveAsset\r\n                data[5] // fillerGiveAmount\r\n            );\r\n        }\r\n    }\r\n\r\n\r\n    /// @notice Executes a trade against an external market.\r\n    /// @dev The initial Ether or token balance is compared with the\r\n    /// balance after the trade to ensure that the appropriate amounts of\r\n    /// tokens were taken and an appropriate amount received.\r\n    /// The trade will fail if the number of tokens received is less than\r\n    /// expected. If the number of tokens received is more than expected than\r\n    /// the excess tokens are transferred to the `BrokerV2.operator`.\r\n    /// @param _assetIds[0] The offerAssetId of the offer\r\n    /// @param _assetIds[1] The wantAssetId of the offer\r\n    /// @param _assetIds[2] The surplusAssetId\r\n    /// @param _dataValues[0] The number of tokens offerred\r\n    /// @param _dataValues[1] The number of tokens expected to be received\r\n    /// @param _dataValues[2] Match data\r\n    /// @param _marketDapps See `BrokerV2.marketDapps`\r\n    /// @param _addresses Addresses from `networkTrade`\r\n    function _performNetworkTrade(\r\n        address[] memory _assetIds,\r\n        uint256[] memory _dataValues,\r\n        address[] memory _marketDapps,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 dappIndex = (_dataValues[2] & mask16) >> 8;\r\n        validateAddress(_marketDapps[dappIndex]);\r\n        MarketDapp marketDapp = MarketDapp(_marketDapps[dappIndex]);\r\n\r\n        uint256[] memory funds = new uint256[](6);\r\n        funds[0] = externalBalance(_assetIds[0]); // initialOfferTokenBalance\r\n        funds[1] = externalBalance(_assetIds[1]); // initialWantTokenBalance\r\n        if (_assetIds[2] != _assetIds[0] && _assetIds[2] != _assetIds[1]) {\r\n            funds[2] = externalBalance(_assetIds[2]); // initialSurplusTokenBalance\r\n        }\r\n\r\n        uint256 ethValue = 0;\r\n        address tokenReceiver;\r\n\r\n        if (_assetIds[0] == ETHER_ADDR) {\r\n            ethValue = _dataValues[0]; // offerAmount\r\n        } else {\r\n            tokenReceiver = marketDapp.tokenReceiver(_assetIds, _dataValues, _addresses);\r\n            approveTokenTransfer(\r\n                _assetIds[0], // offerAssetId\r\n                tokenReceiver,\r\n                _dataValues[0] // offerAmount\r\n            );\r\n        }\r\n\r\n        marketDapp.trade.value(ethValue)(\r\n            _assetIds,\r\n            _dataValues,\r\n            _addresses,\r\n            // use uint160 to cast `address` to `address payable`\r\n            address(uint160(address(this))) // destAddress\r\n        );\r\n\r\n        funds[3] = externalBalance(_assetIds[0]); // finalOfferTokenBalance\r\n        funds[4] = externalBalance(_assetIds[1]); // finalWantTokenBalance\r\n        if (_assetIds[2] != _assetIds[0] && _assetIds[2] != _assetIds[1]) {\r\n            funds[5] = externalBalance(_assetIds[2]); // finalSurplusTokenBalance\r\n        }\r\n\r\n        uint256 surplusAmount = 0;\r\n\r\n        // validate that the appropriate offerAmount was deducted\r\n        // surplusAssetId == offerAssetId\r\n        if (_assetIds[2] == _assetIds[0]) {\r\n            // surplusAmount = finalOfferTokenBalance - (initialOfferTokenBalance - offerAmount)\r\n            surplusAmount = funds[3].sub(funds[0].sub(_dataValues[0]));\r\n        } else {\r\n            // finalOfferTokenBalance == initialOfferTokenBalance - offerAmount\r\n            require(funds[3] == funds[0].sub(_dataValues[0]), \"Invalid offer asset balance\");\r\n        }\r\n\r\n        // validate that the appropriate wantAmount was credited\r\n        // surplusAssetId == wantAssetId\r\n        if (_assetIds[2] == _assetIds[1]) {\r\n            // surplusAmount = finalWantTokenBalance - (initialWantTokenBalance + wantAmount)\r\n            surplusAmount = funds[4].sub(funds[1].add(_dataValues[1]));\r\n        } else {\r\n            // finalWantTokenBalance == initialWantTokenBalance + wantAmount\r\n            require(funds[4] == funds[1].add(_dataValues[1]), \"Invalid want asset balance\");\r\n        }\r\n\r\n        // surplusAssetId != offerAssetId && surplusAssetId != wantAssetId\r\n        if (_assetIds[2] != _assetIds[0] && _assetIds[2] != _assetIds[1]) {\r\n            // surplusAmount = finalSurplusTokenBalance - initialSurplusTokenBalance\r\n            surplusAmount = funds[5].sub(funds[2]);\r\n        }\r\n\r\n        // set the approved token amount back to zero\r\n        if (_assetIds[0] != ETHER_ADDR) {\r\n            approveTokenTransfer(\r\n                _assetIds[0],\r\n                tokenReceiver,\r\n                0\r\n            );\r\n        }\r\n\r\n        return surplusAmount;\r\n    }\r\n\r\n    /// @dev Validates input lengths based on the expected format\r\n    /// detailed in the `trade` method.\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes Hashes from `trade`\r\n    function _validateTradeInputLengths(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & mask8;\r\n        uint256 numFills = (_values[0] & mask16) >> 8;\r\n        uint256 numMatches = (_values[0] & mask24) >> 16;\r\n\r\n        // Validate that bits(24..256) are zero\r\n        require(_values[0] >> 24 == 0, \"Invalid trade input\");\r\n\r\n        // It is enforced by other checks that if a fill is present\r\n        // then it must be completely filled so there must be at least one offer\r\n        // and at least one match in this case.\r\n        // It is possible to have one offer with no matches and no fills\r\n        // but that is blocked by this check as there is no foreseeable use\r\n        // case for it.\r\n        require(\r\n            numOffers > 0 && numFills > 0 && numMatches > 0,\r\n            \"Invalid trade input\"\r\n        );\r\n\r\n        require(\r\n            _values.length == 1 + numOffers * 2 + numFills * 2 + numMatches,\r\n            \"Invalid _values.length\"\r\n        );\r\n\r\n        require(\r\n            _hashes.length == (numOffers + numFills) * 2,\r\n            \"Invalid _hashes.length\"\r\n        );\r\n    }\r\n\r\n    /// @dev Validates input lengths based on the expected format\r\n    /// detailed in the `networkTrade` method.\r\n    /// @param _values Values from `networkTrade`\r\n    /// @param _hashes Hashes from `networkTrade`\r\n    function _validateNetworkTradeInputLengths(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & mask8;\r\n        uint256 numFills = (_values[0] & mask16) >> 8;\r\n        uint256 numMatches = (_values[0] & mask24) >> 16;\r\n\r\n        // Validate that bits(24..256) are zero\r\n        require(_values[0] >> 24 == 0, \"Invalid networkTrade input\");\r\n\r\n        // Validate that numFills is zero because the offers\r\n        // should be filled against external orders\r\n        require(\r\n            numOffers > 0 && numMatches > 0 && numFills == 0,\r\n            \"Invalid networkTrade input\"\r\n        );\r\n\r\n        require(\r\n            _values.length == 1 + numOffers * 2 + numMatches,\r\n            \"Invalid _values.length\"\r\n        );\r\n\r\n        require(\r\n            _hashes.length == numOffers * 2,\r\n            \"Invalid _hashes.length\"\r\n        );\r\n    }\r\n\r\n    /// @dev See the `BrokerV2.trade` method for an explanation of why offer\r\n    /// uniquness is required.\r\n    /// The set of offers in `_values` must be sorted such that offer nonces'\r\n    /// are arranged in a strictly ascending order.\r\n    /// This allows the validation of offer uniqueness to be done in O(N) time,\r\n    /// with N being the number of offers.\r\n    /// @param _values Values from `trade`\r\n    function _validateUniqueOffers(uint256[] memory _values) private pure {\r\n        uint256 numOffers = _values[0] & mask8;\r\n\r\n        uint256 prevNonce;\r\n\r\n        for(uint256 i = 0; i < numOffers; i++) {\r\n            uint256 nonce = (_values[i * 2 + 1] & mask120) >> 56;\r\n\r\n            if (i == 0) {\r\n                // Set the value of the first nonce\r\n                prevNonce = nonce;\r\n                continue;\r\n            }\r\n\r\n            require(nonce > prevNonce, \"Invalid offer nonces\");\r\n            prevNonce = nonce;\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that for every match:\r\n    /// 1. offerIndexes fall within the range of offers\r\n    /// 2. fillIndexes falls within the range of fills\r\n    /// 3. offer.offerAssetId == fill.wantAssetId\r\n    /// 4. offer.wantAssetId == fill.offerAssetId\r\n    /// 5. takeAmount > 0\r\n    /// 6. (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function _validateMatches(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & mask8;\r\n        uint256 numFills = (_values[0] & mask16) >> 8;\r\n\r\n        uint256 i = 1 + numOffers * 2 + numFills * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & mask8;\r\n            uint256 fillIndex = (_values[i] & mask16) >> 8;\r\n\r\n            require(offerIndex < numOffers, \"Invalid match.offerIndex\");\r\n\r\n            require(fillIndex >= numOffers && fillIndex < numOffers + numFills, \"Invalid match.fillIndex\");\r\n\r\n            require(\r\n                _addresses[_values[1 + offerIndex * 2] & mask8] !=\r\n                _addresses[_values[1 + fillIndex * 2] & mask8],\r\n                \"offer.maker cannot be the same as fill.filler\"\r\n            );\r\n\r\n            uint256 makerOfferAssetIndex = (_values[1 + offerIndex * 2] & mask16) >> 8;\r\n            uint256 makerWantAssetIndex = (_values[1 + offerIndex * 2] & mask24) >> 16;\r\n            uint256 fillerOfferAssetIndex = (_values[1 + fillIndex * 2] & mask16) >> 8;\r\n            uint256 fillerWantAssetIndex = (_values[1 + fillIndex * 2] & mask24) >> 16;\r\n\r\n            require(\r\n                _addresses[makerOfferAssetIndex * 2 + 1] ==\r\n                _addresses[fillerWantAssetIndex * 2 + 1],\r\n                \"offer.offerAssetId does not match fill.wantAssetId\"\r\n            );\r\n\r\n            require(\r\n                _addresses[makerWantAssetIndex * 2 + 1] ==\r\n                _addresses[fillerOfferAssetIndex * 2 + 1],\r\n                \"offer.wantAssetId does not match fill.offerAssetId\"\r\n            );\r\n\r\n            // require that bits(16..128) are all zero for every match\r\n            require((_values[i] & mask128) >> 16 == uint256(0), \"Invalid match data\");\r\n\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            require(takeAmount > 0, \"Invalid match.takeAmount\");\r\n\r\n            uint256 offerDataB = _values[2 + offerIndex * 2];\r\n            // (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n            require(\r\n                (offerDataB >> 128).mul(takeAmount).mod(offerDataB & mask128) == 0,\r\n                \"Invalid amounts\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that for every match:\r\n    /// 1. offerIndexes fall within the range of offers\r\n    /// 2. _addresses[surplusAssetIndexes * 2] matches the operator address\r\n    /// 3. takeAmount > 0\r\n    /// 4. (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    /// @param _operator Address of the `BrokerV2.operator`\r\n    function _validateNetworkMatches(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        uint256 numOffers = _values[0] & mask8;\r\n\r\n        // 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & mask8) * 2;\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & mask8;\r\n            uint256 surplusAssetIndex = (_values[i] & mask24) >> 16;\r\n\r\n            require(offerIndex < numOffers, \"Invalid match.offerIndex\");\r\n            require(_addresses[surplusAssetIndex * 2] == _operator, \"Invalid operator address\");\r\n\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            require(takeAmount > 0, \"Invalid match.takeAmount\");\r\n\r\n            uint256 offerDataB = _values[2 + offerIndex * 2];\r\n            // (offer.wantAmount * takeAmount) % offer.offerAmount == 0\r\n            require(\r\n                (offerDataB >> 128).mul(takeAmount).mod(offerDataB & mask128) == 0,\r\n                \"Invalid amounts\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validate that all fills will be completely filled by the specified\r\n    /// matches. See the `BrokerV2.trade` method for an explanation of why\r\n    /// fills must be completely filled.\r\n    /// @param _values Values from `trade`\r\n    function _validateFillAmounts(uint256[] memory _values) private pure {\r\n        // \"filled\" is used to store the sum of `takeAmount`s and `giveAmount`s.\r\n        // While a fill's `offerAmount` and `wantAmount` are combined to share\r\n        // a single uint256 value, each sum of `takeAmount`s and `giveAmount`s\r\n        // for a fill is tracked with an individual uint256 value.\r\n        // This is to prevent the verification from being vulnerable to overflow\r\n        // issues.\r\n        uint256[] memory filled = new uint256[](_values.length);\r\n\r\n        uint256 i = 1;\r\n        // i += numOffers * 2\r\n        i += (_values[0] & mask8) * 2;\r\n        // i += numFills * 2\r\n        i += ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & mask8;\r\n            uint256 fillIndex = (_values[i] & mask16) >> 8;\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            uint256 wantAmount = _values[2 + offerIndex * 2] >> 128;\r\n            uint256 offerAmount = _values[2 + offerIndex * 2] & mask128;\r\n            // giveAmount = takeAmount * wantAmount / offerAmount\r\n            uint256 giveAmount = takeAmount.mul(wantAmount).div(offerAmount);\r\n\r\n            // (1 + fillIndex * 2) would give the index of the first part\r\n            // of the data for the fill at fillIndex within `_values`,\r\n            // and (2 + fillIndex * 2) would give the index of the second part\r\n            filled[1 + fillIndex * 2] = filled[1 + fillIndex * 2].add(giveAmount);\r\n            filled[2 + fillIndex * 2] = filled[2 + fillIndex * 2].add(takeAmount);\r\n        }\r\n\r\n        // numOffers\r\n        i = _values[0] & mask8;\r\n        // i + numFills\r\n        end = i + ((_values[0] & mask16) >> 8);\r\n\r\n        // loop fills\r\n        for(i; i < end; i++) {\r\n            require(\r\n                // fill.offerAmount == (sum of given amounts for fill)\r\n                _values[i * 2 + 2] & mask128 == filled[i * 2 + 1] &&\r\n                // fill.wantAmount == (sum of taken amounts for fill)\r\n                _values[i * 2 + 2] >> 128 == filled[i * 2 + 2],\r\n                \"Invalid fills\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates that for every offer / fill\r\n    /// 1. user address matches address referenced by user.offerAssetIndex\r\n    /// 2. user address matches address referenced by user.wantAssetIndex\r\n    /// 3. user address matches address referenced by user.feeAssetIndex\r\n    /// 4. offerAssetId != wantAssetId\r\n    /// 5. offerAmount > 0 && wantAmount > 0\r\n    /// 6. Specified `operator` address matches the expected `operator` address,\r\n    /// 7. Specified `operator.feeAssetId` matches the offer's feeAssetId\r\n    /// @param _values Values from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    function _validateTradeData(\r\n        uint256[] memory _values,\r\n        address[] memory _addresses,\r\n        address _operator\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        // numOffers + numFills\r\n        uint256 end = (_values[0] & mask8) +\r\n                      ((_values[0] & mask16) >> 8);\r\n\r\n        for (uint256 i = 0; i < end; i++) {\r\n            uint256 dataA = _values[i * 2 + 1];\r\n            uint256 dataB = _values[i * 2 + 2];\r\n            uint256 feeAssetIndex = ((dataA & mask40) >> 32) * 2;\r\n\r\n            require(\r\n                // user address == user in user.offerAssetIndex pair\r\n                _addresses[(dataA & mask8) * 2] ==\r\n                _addresses[((dataA & mask16) >> 8) * 2],\r\n                \"Invalid user in user.offerAssetIndex\"\r\n            );\r\n\r\n            require(\r\n                // user address == user in user.wantAssetIndex pair\r\n                _addresses[(dataA & mask8) * 2] ==\r\n                _addresses[((dataA & mask24) >> 16) * 2],\r\n                \"Invalid user in user.wantAssetIndex\"\r\n            );\r\n\r\n            require(\r\n                // user address == user in user.feeAssetIndex pair\r\n                _addresses[(dataA & mask8) * 2] ==\r\n                _addresses[((dataA & mask32) >> 24) * 2],\r\n                \"Invalid user in user.feeAssetIndex\"\r\n            );\r\n\r\n            require(\r\n                // offerAssetId != wantAssetId\r\n                _addresses[((dataA & mask16) >> 8) * 2 + 1] !=\r\n                _addresses[((dataA & mask24) >> 16) * 2 + 1],\r\n                \"Invalid trade assets\"\r\n            );\r\n\r\n            require(\r\n                // offerAmount > 0 && wantAmount > 0\r\n                (dataB & mask128) > 0 && (dataB >> 128) > 0,\r\n                \"Invalid trade amounts\"\r\n            );\r\n\r\n             require(\r\n                _addresses[feeAssetIndex] == _operator,\r\n                \"Invalid operator address\"\r\n            );\r\n\r\n             require(\r\n                _addresses[feeAssetIndex + 1] ==\r\n                _addresses[((dataA & mask32) >> 24) * 2 + 1],\r\n                \"Invalid operator fee asset ID\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Validates signatures for a set of offers or fills\r\n    /// Note that the r value of the offer / fill in _hashes will be\r\n    /// overwritten by the hash of that offer / fill\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes Hashes from `trade`\r\n    /// @param _addresses Addresses from `trade`\r\n    /// @param _typehash The typehash used to construct the signed hash\r\n    /// @param _i The starting index to verify\r\n    /// @param _end The ending index to verify\r\n    /// @return An array of hash keys if _i started as 0, because only\r\n    /// the hash keys of offers are needed\r\n    function _validateTradeSignatures(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses,\r\n        bytes32 _typehash,\r\n        uint256 _i,\r\n        uint256 _end\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        for (_i; _i < _end; _i++) {\r\n            uint256 dataA = _values[_i * 2 + 1];\r\n            uint256 dataB = _values[_i * 2 + 2];\r\n\r\n            bytes32 hashKey = keccak256(abi.encode(\r\n                _typehash,\r\n                _addresses[(dataA & mask8) * 2], // user\r\n                _addresses[((dataA & mask16) >> 8) * 2 + 1], // offerAssetId\r\n                dataB & mask128, // offerAmount\r\n                _addresses[((dataA & mask24) >> 16) * 2 + 1], // wantAssetId\r\n                dataB >> 128, // wantAmount\r\n                _addresses[((dataA & mask32) >> 24) * 2 + 1], // feeAssetId\r\n                dataA >> 128, // feeAmount\r\n                (dataA & mask120) >> 56 // nonce\r\n            ));\r\n\r\n            bool prefixedSignature = ((dataA & mask56) >> 48) != 0;\r\n\r\n            validateSignature(\r\n                hashKey,\r\n                _addresses[(dataA & mask8) * 2], // user\r\n                uint8((dataA & mask48) >> 40), // The `v` component of the user's signature\r\n                _hashes[_i * 2], // The `r` component of the user's signature\r\n                _hashes[_i * 2 + 1], // The `s` component of the user's signature\r\n                prefixedSignature\r\n            );\r\n\r\n            _hashes[_i * 2] = hashKey;\r\n        }\r\n    }\r\n\r\n    /// @dev Ensure that the address is a deployed contract\r\n    /// @param _contract The address to check\r\n    function _validateContractAddress(address _contract) private view {\r\n        assembly {\r\n            if iszero(extcodesize(_contract)) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @dev A thin wrapper around the native `call` function, to\r\n    /// validate that the contract `call` must be successful.\r\n    /// See https://solidity.readthedocs.io/en/v0.5.1/050-breaking-changes.html\r\n    /// for details on constructing the `_payload`\r\n    /// @param _contract Address of the contract to call\r\n    /// @param _payload The data to call the contract with\r\n    /// @return The data returned from the contract call\r\n    function _callContract(\r\n        address _contract,\r\n        bytes memory _payload\r\n    )\r\n        private\r\n        returns (bytes memory)\r\n    {\r\n        bool success;\r\n        bytes memory returnData;\r\n\r\n        (success, returnData) = _contract.call(_payload);\r\n        require(success, \"Contract call failed\");\r\n\r\n        return returnData;\r\n    }\r\n\r\n    /// @dev Fix for ERC-20 tokens that do not have proper return type\r\n    /// See: https://github.com/ethereum/solidity/issues/4116\r\n    /// https://medium.com/loopring-protocol/an-incompatibility-in-smart-contract-threatening-dapp-ecosystem-72b8ca5db4da\r\n    /// https://github.com/sec-bit/badERC20Fix/blob/master/badERC20Fix.sol\r\n    /// @param _data The data returned from a transfer call\r\n    function _validateContractCallResult(bytes memory _data) private pure {\r\n        require(\r\n            _data.length == 0 ||\r\n            (_data.length == 32 && _getUint256FromBytes(_data) != 0),\r\n            \"Invalid contract call result\"\r\n        );\r\n    }\r\n\r\n    /// @dev Converts data of type `bytes` into its corresponding `uint256` value\r\n    /// @param _data The data in bytes\r\n    /// @return The corresponding `uint256` value\r\n    function _getUint256FromBytes(\r\n        bytes memory _data\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 parsed;\r\n        assembly { parsed := mload(add(_data, 32)) }\r\n        return parsed;\r\n    }\r\n}\r\n\r\n// File: contracts/BrokerV2.sol\r\n\r\npragma solidity 0.5.12;\r\n\r\n\r\n\r\n\r\n\r\ninterface IERC1820Registry {\r\n    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\r\n}\r\n\r\ninterface TokenList {\r\n    function validateToken(address assetId) external view;\r\n}\r\n\r\ninterface SpenderList {\r\n    function validateSpender(address spender) external view;\r\n    function validateSpenderAuthorization(address user, address spender) external view;\r\n}\r\n\r\n/// @title The BrokerV2 contract for Switcheo Exchange\r\n/// @author Switcheo Network\r\n/// @notice This contract faciliates Ethereum and Ethereum token trades\r\n/// between users.\r\n/// Users can trade with each other by making and taking offers without\r\n/// giving up custody of their tokens.\r\n/// Users should first deposit tokens, then communicate off-chain\r\n/// with the exchange coordinator, in order to place orders.\r\n/// This allows trades to be confirmed immediately by the coordinator,\r\n/// and settled on-chain through this contract at a later time.\r\n///\r\n/// @dev Bit compacting is used in the contract to reduce gas costs, when\r\n/// it is used, params are documented as bits(n..m).\r\n/// This means that the documented value is represented by bits starting\r\n/// from and including `n`, up to and excluding `m`.\r\n/// For example, bits(8..16), indicates that the value is represented by bits:\r\n/// [8, 9, 10, 11, 12, 13, 14, 15].\r\n///\r\n/// Bit manipulation of the form (data & ~(~uint(0) << m)) >> n is frequently\r\n/// used to recover the value at the specified bits.\r\n/// For example, to recover bits(2..7) from a uint8 value, we can use\r\n/// (data & ~(~uint8(0) << 7)) >> 2.\r\n/// Given a `data` value of `1101,0111`, bits(2..7) should give \"10101\".\r\n/// ~uint8(0): \"1111,1111\" (8 ones)\r\n/// (~uint8(0) << 7): \"1000,0000\" (1 followed by 7 zeros)\r\n/// ~(~uint8(0) << 7): \"0111,1111\" (0 followed by 7 ones)\r\n/// (data & ~(~uint8(0) << 7)): \"0101,0111\" (bits after the 7th bit is zeroed)\r\n/// (data & ~(~uint8(0) << 7)) >> 2: \"0001,0101\" (matching the expected \"10101\")\r\n///\r\n/// Additionally, bit manipulation of the form data >> n is used to recover\r\n/// bits(n..e), where e is equal to the number of bits in the data.\r\n/// For example, to recover bits(4..8) from a uint8 value, we can use data >> 4.\r\n/// Given a data value of \"1111,1111\", bits(4..8) should give \"1111\".\r\n/// data >> 4: \"0000,1111\" (matching the expected \"1111\")\r\n///\r\n/// There is frequent reference and usage of asset IDs, this is a unique\r\n/// identifier used within the contract to represent individual assets.\r\n/// For all tokens, the asset ID is identical to the contract address\r\n/// of the token, this is so that additional mappings are not needed to\r\n/// identify tokens during deposits and withdrawals.\r\n/// The only exception is the Ethereum token, which does not have a contract\r\n/// address, for this reason, the zero address is used to represent the\r\n/// Ethereum token's ID.\r\ncontract BrokerV2 is Ownable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    struct WithdrawalAnnouncement {\r\n        uint256 amount;\r\n        uint256 withdrawableAt;\r\n    }\r\n\r\n    // Exchange states\r\n    enum State { Active, Inactive }\r\n    // Exchange admin states\r\n    enum AdminState { Normal, Escalated }\r\n\r\n    // The constants for EIP-712 are precompiled to reduce contract size,\r\n    // the original values are left here for reference and verification.\r\n    //\r\n    // bytes32 public constant WITHDRAW_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Withdraw(\",\r\n    //         \"address withdrawer,\",\r\n    //         \"address receivingAddress,\",\r\n    //         \"address assetId,\",\r\n    //         \"uint256 amount,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant WITHDRAW_TYPEHASH = 0xbe2f4292252fbb88b129dc7717b2f3f74a9afb5b13a2283cac5c056117b002eb;\r\n\r\n    // bytes32 public constant OFFER_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Offer(\",\r\n    //         \"address maker,\",\r\n    //         \"address offerAssetId,\",\r\n    //         \"uint256 offerAmount,\",\r\n    //         \"address wantAssetId,\",\r\n    //         \"uint256 wantAmount,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant OFFER_TYPEHASH = 0xf845c83a8f7964bc8dd1a092d28b83573b35be97630a5b8a3b8ae2ae79cd9260;\r\n\r\n    // bytes32 public constant SWAP_TYPEHASH = keccak256(abi.encodePacked(\r\n    //     \"Swap(\",\r\n    //         \"address maker,\",\r\n    //         \"address taker,\",\r\n    //         \"address assetId,\",\r\n    //         \"uint256 amount,\",\r\n    //         \"bytes32 hashedSecret,\",\r\n    //         \"uint256 expiryTime,\",\r\n    //         \"address feeAssetId,\",\r\n    //         \"uint256 feeAmount,\",\r\n    //         \"uint256 nonce\",\r\n    //     \")\"\r\n    // ));\r\n    bytes32 public constant SWAP_TYPEHASH = 0x6ba9001457a287c210b728198a424a4222098d7fac48f8c5fb5ab10ef907d3ef;\r\n\r\n    // The Ether token address is set as the constant 0x00 for backwards\r\n    // compatibility\r\n    address private constant ETHER_ADDR = address(0);\r\n\r\n    // The maximum length of swap secret values\r\n    uint256 private constant MAX_SWAP_SECRET_LENGTH = 64;\r\n\r\n    // Reason codes are used by the off-chain coordinator to track balance changes\r\n    uint256 private constant REASON_DEPOSIT = 0x01;\r\n\r\n    uint256 private constant REASON_WITHDRAW = 0x09;\r\n    uint256 private constant REASON_WITHDRAW_FEE_GIVE = 0x14;\r\n    uint256 private constant REASON_WITHDRAW_FEE_RECEIVE = 0x15;\r\n\r\n    uint256 private constant REASON_CANCEL = 0x08;\r\n    uint256 private constant REASON_CANCEL_FEE_GIVE = 0x12;\r\n    uint256 private constant REASON_CANCEL_FEE_RECEIVE = 0x13;\r\n\r\n    uint256 private constant REASON_SWAP_GIVE = 0x30;\r\n    uint256 private constant REASON_SWAP_FEE_GIVE = 0x32;\r\n    uint256 private constant REASON_SWAP_RECEIVE = 0x35;\r\n    uint256 private constant REASON_SWAP_FEE_RECEIVE = 0x37;\r\n\r\n    uint256 private constant REASON_SWAP_CANCEL_RECEIVE = 0x38;\r\n    uint256 private constant REASON_SWAP_CANCEL_FEE_RECEIVE = 0x3B;\r\n    uint256 private constant REASON_SWAP_CANCEL_FEE_REFUND = 0x3D;\r\n\r\n    // 7 days * 24 hours * 60 mins * 60 seconds: 604800\r\n    uint256 private constant MAX_SLOW_WITHDRAW_DELAY = 604800;\r\n    uint256 private constant MAX_SLOW_CANCEL_DELAY = 604800;\r\n\r\n    uint256 private constant mask8 = ~(~uint256(0) << 8);\r\n    uint256 private constant mask16 = ~(~uint256(0) << 16);\r\n    uint256 private constant mask24 = ~(~uint256(0) << 24);\r\n    uint256 private constant mask32 = ~(~uint256(0) << 32);\r\n    uint256 private constant mask40 = ~(~uint256(0) << 40);\r\n    uint256 private constant mask120 = ~(~uint256(0) << 120);\r\n    uint256 private constant mask128 = ~(~uint256(0) << 128);\r\n    uint256 private constant mask136 = ~(~uint256(0) << 136);\r\n    uint256 private constant mask144 = ~(~uint256(0) << 144);\r\n\r\n    State public state;\r\n    AdminState public adminState;\r\n    // All fees will be transferred to the operator address\r\n    address public operator;\r\n    TokenList public tokenList;\r\n    SpenderList public spenderList;\r\n\r\n    // The delay in seconds to complete the respective escape hatch (`slowCancel` / `slowWithdraw`).\r\n    // This gives the off-chain service time to update the off-chain state\r\n    // before the state is separately updated by the user.\r\n    uint256 public slowCancelDelay;\r\n    uint256 public slowWithdrawDelay;\r\n\r\n    // A mapping of remaining offer amounts: offerHash => availableAmount\r\n    mapping(bytes32 => uint256) public offers;\r\n    // A mapping of used nonces: nonceIndex => nonceData\r\n    // The storing of nonces is used to ensure that transactions signed by\r\n    // the user can only be used once.\r\n    // For space and gas cost efficiency, one nonceData is used to store the\r\n    // state of 256 nonces.\r\n    // This reduces the average cost of storing a new nonce from 20,000 gas\r\n    // to 5000 + 20,000 / 256 = 5078.125 gas\r\n    // See _markNonce and _nonceTaken for more details.\r\n    mapping(uint256 => uint256) public usedNonces;\r\n    // A mapping of user balances: userAddress => assetId => balance\r\n    mapping(address => mapping(address => uint256)) public balances;\r\n    // A mapping of atomic swap states: swapHash => isSwapActive\r\n    mapping(bytes32 => bool) public atomicSwaps;\r\n\r\n    // A record of admin addresses: userAddress => isAdmin\r\n    mapping(address => bool) public adminAddresses;\r\n    // A record of market DApp addresses\r\n    address[] public marketDapps;\r\n    // A mapping of cancellation announcements for the cancel escape hatch: offerHash => cancellableAt\r\n    mapping(bytes32 => uint256) public cancellationAnnouncements;\r\n    // A mapping of withdrawal announcements: userAddress => assetId => { amount, withdrawableAt }\r\n    mapping(address => mapping(address => WithdrawalAnnouncement)) public withdrawalAnnouncements;\r\n\r\n    // Emitted on positive balance state transitions\r\n    event BalanceIncrease(\r\n        address indexed user,\r\n        address indexed assetId,\r\n        uint256 amount,\r\n        uint256 reason,\r\n        uint256 nonce\r\n    );\r\n\r\n    // Emitted on negative balance state transitions\r\n    event BalanceDecrease(\r\n        address indexed user,\r\n        address indexed assetId,\r\n        uint256 amount,\r\n        uint256 reason,\r\n        uint256 nonce\r\n    );\r\n\r\n    // Compacted versions of the `BalanceIncrease` and `BalanceDecrease` events.\r\n    // These are used in the `trade` method, they are compacted to save gas costs.\r\n    event Increment(uint256 data);\r\n    event Decrement(uint256 data);\r\n\r\n    event TokenFallback(\r\n        address indexed user,\r\n        address indexed assetId,\r\n        uint256 amount\r\n    );\r\n\r\n    event TokensReceived(\r\n        address indexed user,\r\n        address indexed assetId,\r\n        uint256 amount\r\n    );\r\n\r\n    event AnnounceCancel(\r\n        bytes32 indexed offerHash,\r\n        uint256 cancellableAt\r\n    );\r\n\r\n    event SlowCancel(\r\n        bytes32 indexed offerHash,\r\n        uint256 amount\r\n    );\r\n\r\n    event AnnounceWithdraw(\r\n        address indexed withdrawer,\r\n        address indexed assetId,\r\n        uint256 amount,\r\n        uint256 withdrawableAt\r\n    );\r\n\r\n    event SlowWithdraw(\r\n        address indexed withdrawer,\r\n        address indexed assetId,\r\n        uint256 amount\r\n    );\r\n\r\n    /// @notice Initializes the Broker contract\r\n    /// @dev The coordinator, operator and owner (through Ownable) is initialized\r\n    /// to be the address of the sender.\r\n    /// The Broker is put into an active state, with maximum exit delays set.\r\n    /// The Broker is also registered as an implementer of ERC777TokensRecipient\r\n    /// through the ERC1820 registry.\r\n    constructor(address _tokenListAddress, address _spenderListAddress) public {\r\n        adminAddresses[msg.sender] = true;\r\n        operator = msg.sender;\r\n        tokenList = TokenList(_tokenListAddress);\r\n        spenderList = SpenderList(_spenderListAddress);\r\n\r\n        slowWithdrawDelay = MAX_SLOW_WITHDRAW_DELAY;\r\n        slowCancelDelay = MAX_SLOW_CANCEL_DELAY;\r\n        state = State.Active;\r\n\r\n        IERC1820Registry erc1820 = IERC1820Registry(\r\n            0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\r\n        );\r\n\r\n        erc1820.setInterfaceImplementer(\r\n            address(this),\r\n            keccak256(\"ERC777TokensRecipient\"),\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        // Error code 1: onlyAdmin, address is not an admin address\r\n        require(adminAddresses[msg.sender], \"1\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyActiveState() {\r\n        // Error code 2: onlyActiveState, state is not 'Active'\r\n        require(state == State.Active, \"2\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyEscalatedAdminState() {\r\n        // Error code 3: onlyEscalatedAdminState, adminState is not 'Escalated'\r\n        require(adminState == AdminState.Escalated, \"3\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Checks whether an address is appointed as an admin user\r\n    /// @param _user The address to check\r\n    /// @return Whether the address is appointed as an admin user\r\n    function isAdmin(address _user) external view returns(bool) {\r\n        return adminAddresses[_user];\r\n    }\r\n\r\n    /// @notice Sets tbe Broker's state.\r\n    /// @dev The two available states are `Active` and `Inactive`.\r\n    /// The `Active` state allows for regular exchange activity,\r\n    /// while the `Inactive` state prevents the invocation of deposit\r\n    /// and trading functions.\r\n    /// The `Inactive` state is intended as a means to cease contract operation\r\n    /// in the case of an upgrade or in an emergency.\r\n    /// @param _state The state to transition the contract into\r\n    function setState(State _state) external onlyOwner nonReentrant { state = _state; }\r\n\r\n    /// @notice Sets the Broker's admin state.\r\n    /// @dev The two available states are `Normal` and `Escalated`.\r\n    /// In the `Normal` admin state, the admin methods `adminCancel` and `adminWithdraw`\r\n    /// are not invocable.\r\n    /// The admin state must be set to `Escalated` by the contract owner for these\r\n    /// methods to become usable.\r\n    /// In an `Escalated` admin state, admin addresses would be able to cancel offers\r\n    /// and withdraw balances to the respective user's wallet on behalf of users.\r\n    /// The escalated state is intended to be used in the case of a contract upgrade or\r\n    /// in an emergency.\r\n    /// It is set separately from the `Inactive` state so that it is possible\r\n    /// to use admin functions without affecting regular operations.\r\n    /// @param _state The admin state to transition the contract into\r\n    function setAdminState(AdminState _state) external onlyOwner nonReentrant { adminState = _state; }\r\n\r\n    /// @notice Sets the operator address.\r\n    /// @dev All fees will be transferred to the operator address.\r\n    /// @param _operator The address to set as the operator\r\n    function setOperator(address _operator) external onlyOwner nonReentrant {\r\n        _validateAddress(operator);\r\n        operator = _operator;\r\n    }\r\n\r\n    /// @notice Sets the minimum delay between an `announceCancel` call and\r\n    /// when the cancellation can actually be executed through `slowCancel`.\r\n    /// @dev This gives the off-chain service time to update the off-chain state\r\n    /// before the state is separately updated by the user.\r\n    /// This differs from the regular `cancel` operation, which does not involve a delay.\r\n    /// @param _delay The delay in seconds\r\n    function setSlowCancelDelay(uint256 _delay) external onlyOwner nonReentrant {\r\n        // Error code 4: setSlowCancelDelay, slow cancel delay exceeds max allowable delay\r\n        require(_delay <= MAX_SLOW_CANCEL_DELAY, \"4\");\r\n        slowCancelDelay = _delay;\r\n    }\r\n\r\n    /// @notice Sets the delay between an `announceWithdraw` call and\r\n    /// when the withdrawal can actually be executed through `slowWithdraw`.\r\n    /// @dev This gives the off-chain service time to update the off-chain state\r\n    /// before the state is separately updated by the user.\r\n    /// This differs from the regular `withdraw` operation, which does not involve a delay.\r\n    /// @param _delay The delay in seconds\r\n    function setSlowWithdrawDelay(uint256 _delay) external onlyOwner nonReentrant {\r\n        // Error code 5: setSlowWithdrawDelay, slow withdraw delay exceeds max allowable delay\r\n        require(_delay <= MAX_SLOW_WITHDRAW_DELAY, \"5\");\r\n        slowWithdrawDelay = _delay;\r\n    }\r\n\r\n    /// @notice Gives admin permissons to the specified address.\r\n    /// @dev Admin addresses are intended to coordinate the regular operation\r\n    /// of the Broker contract, and to perform special functions such as\r\n    /// `adminCancel` and `adminWithdraw`.\r\n    /// @param _admin The address to give admin permissions to\r\n    function addAdmin(address _admin) external onlyOwner nonReentrant {\r\n        _validateAddress(_admin);\r\n        // Error code 6: addAdmin, address is already an admin address\r\n        require(!adminAddresses[_admin], \"6\");\r\n        adminAddresses[_admin] = true;\r\n    }\r\n\r\n    /// @notice Removes admin permissons for the specified address.\r\n    /// @param _admin The admin address to remove admin permissions from\r\n    function removeAdmin(address _admin) external onlyOwner nonReentrant {\r\n        _validateAddress(_admin);\r\n        // Error code 7: removeAdmin, address is not an admin address\r\n        require(adminAddresses[_admin], \"7\");\r\n        delete adminAddresses[_admin];\r\n    }\r\n\r\n    /// @notice Adds a market DApp to be used in `networkTrade`\r\n    /// @param _dapp Address of the market DApp\r\n    function addMarketDapp(address _dapp) external onlyOwner nonReentrant {\r\n        _validateAddress(_dapp);\r\n        marketDapps.push(_dapp);\r\n    }\r\n\r\n    /// @notice Updates a market DApp to be used in `networkTrade`\r\n    /// @param _index Index of the market DApp to update\r\n    /// @param _dapp The new address of the market DApp\r\n    function updateMarketDapp(uint256 _index, address _dapp) external onlyOwner nonReentrant {\r\n        _validateAddress(_dapp);\r\n        // Error code 8: updateMarketDapp, _index does not refer to an existing non-zero address\r\n        require(marketDapps[_index] != address(0), \"8\");\r\n        marketDapps[_index] = _dapp;\r\n    }\r\n\r\n    /// @notice Removes a market DApp\r\n    /// @param _index Index of the market DApp to remove\r\n    function removeMarketDapp(uint256 _index) external onlyOwner nonReentrant {\r\n        // Error code 9: removeMarketDapp, _index does not refer to a DApp address\r\n        require(marketDapps[_index] != address(0), \"9\");\r\n        delete marketDapps[_index];\r\n    }\r\n\r\n    /// @notice Performs a balance transfer from one address to another\r\n    /// @dev This method is intended to be invoked by spender contracts.\r\n    /// To invoke this method, a spender contract must have been\r\n    /// previously whitelisted and also authorized by the address from which\r\n    /// funds will be deducted.\r\n    /// Balance events are not emitted by this method, they should be separately\r\n    /// emitted by the spender contract.\r\n    /// @param _from The address to deduct from\r\n    /// @param _to The address to credit\r\n    /// @param _assetId The asset to transfer\r\n    /// @param _amount The amount to transfer\r\n    function spendFrom(\r\n        address _from,\r\n        address _to,\r\n        address _assetId,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n        spenderList.validateSpenderAuthorization(_from, msg.sender);\r\n\r\n        _validateAddress(_to);\r\n\r\n        balances[_from][_assetId] = balances[_from][_assetId].sub(_amount);\r\n        balances[_to][_assetId] = balances[_to][_assetId].add(_amount);\r\n    }\r\n\r\n    /// @notice Allows a whitelisted contract to mark nonces\r\n    /// @dev If the whitelisted contract is malicious or vulnerable then there is\r\n    /// a possibility of a DoS attack. However, since this attack requires cooperation\r\n    /// of the contract owner, the risk is similar to the contract owner withholding\r\n    /// transactions, so there is no violation of the contract's trust model.\r\n    /// In the case that nonces are misused, users will still be able to cancel their offers\r\n    /// and withdraw all their funds using the escape hatch methods.\r\n    /// @param _nonce The nonce to mark\r\n    function markNonce(uint256 _nonce) external nonReentrant {\r\n        spenderList.validateSpender(msg.sender);\r\n        _markNonce(_nonce);\r\n    }\r\n\r\n    /// @notice Returns whether a nonce has been taken\r\n    /// @param _nonce The nonce to check\r\n    /// @return Whether the nonce has been taken\r\n    function nonceTaken(uint256 _nonce) external view returns (bool) {\r\n        return _nonceTaken(_nonce);\r\n    }\r\n\r\n    /// @notice Deposits ETH into the sender's contract balance\r\n    /// @dev This operation is only usable in an `Active` state\r\n    /// to prevent this contract from receiving ETH in the case that its\r\n    /// operation has been terminated.\r\n    function deposit() external payable onlyActiveState nonReentrant {\r\n        // Error code 10: deposit, msg.value is 0\r\n        require(msg.value > 0, \"10\");\r\n        _increaseBalance(msg.sender, ETHER_ADDR, msg.value, REASON_DEPOSIT, 0);\r\n    }\r\n\r\n    /// @dev This function is needed as market DApps generally send ETH\r\n    /// using the `<address>.transfer` method.\r\n    /// It is left empty to avoid issues with the function call running out\r\n    /// of gas, as some callers set a small limit on how much gas can be\r\n    /// used by the ETH receiver.\r\n    function() payable external {}\r\n\r\n    /// @notice Deposits ERC20 tokens under the `_user`'s balance\r\n    /// @dev Transfers token into the Broker contract using the\r\n    /// token's `transferFrom` method.\r\n    /// The user must have previously authorized the token transfer\r\n    /// through the token's `approve` method.\r\n    /// This method has separate `_amount` and `_expectedAmount` values\r\n    /// to support unconventional token transfers, e.g. tokens which have a\r\n    /// proportion burnt on transfer.\r\n    /// @param _user The address of the user depositing the tokens\r\n    /// @param _assetId The address of the token contract\r\n    /// @param _amount The value to invoke the token's `transferFrom` with\r\n    /// @param _expectedAmount The final amount expected to be received by this contract\r\n    /// @param _nonce A nonce for balance tracking, emitted in the BalanceIncrease event\r\n    function depositToken(\r\n        address _user,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        uint256 _expectedAmount,\r\n        uint256 _nonce\r\n    )\r\n        external\r\n        onlyAdmin\r\n        onlyActiveState\r\n        nonReentrant\r\n    {\r\n        _increaseBalance(\r\n            _user,\r\n            _assetId,\r\n            _expectedAmount,\r\n            REASON_DEPOSIT,\r\n            _nonce\r\n        );\r\n\r\n        Utils.transferTokensIn(\r\n            _user,\r\n            _assetId,\r\n            _amount,\r\n            _expectedAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Deposits ERC223 tokens under the `_user`'s balance\r\n    /// @dev ERC223 tokens should invoke this method when tokens are\r\n    /// sent to the Broker contract.\r\n    /// The invocation will fail unless the token has been previously\r\n    /// whitelisted through the `whitelistToken` method.\r\n    /// @param _user The address of the user sending the tokens\r\n    /// @param _amount The amount of tokens transferred to the Broker\r\n    function tokenFallback(\r\n        address _user,\r\n        uint _amount,\r\n        bytes calldata /* _data */\r\n    )\r\n        external\r\n        onlyActiveState\r\n        nonReentrant\r\n    {\r\n        address assetId = msg.sender;\r\n        tokenList.validateToken(assetId);\r\n        _increaseBalance(_user, assetId, _amount, REASON_DEPOSIT, 0);\r\n        emit TokenFallback(_user, assetId, _amount);\r\n    }\r\n\r\n    /// @notice Deposits ERC777 tokens under the `_user`'s balance\r\n    /// @dev ERC777 tokens should invoke this method when tokens are\r\n    /// sent to the Broker contract.\r\n    /// The invocation will fail unless the token has been previously\r\n    /// whitelisted through the `whitelistToken` method.\r\n    /// @param _user The address of the user sending the tokens\r\n    /// @param _to The address receiving the tokens\r\n    /// @param _amount The amount of tokens transferred to the Broker\r\n    function tokensReceived(\r\n        address /* _operator */,\r\n        address _user,\r\n        address _to,\r\n        uint _amount,\r\n        bytes calldata /* _userData */,\r\n        bytes calldata /* _operatorData */\r\n    )\r\n        external\r\n        onlyActiveState\r\n        nonReentrant\r\n    {\r\n        if (_to != address(this)) { return; }\r\n        address assetId = msg.sender;\r\n        tokenList.validateToken(assetId);\r\n        _increaseBalance(_user, assetId, _amount, REASON_DEPOSIT, 0);\r\n        emit TokensReceived(_user, assetId, _amount);\r\n    }\r\n\r\n    /// @notice Executes an array of offers and fills\r\n    /// @dev This method accepts an array of \"offers\" and \"fills\" together with\r\n    /// an array of \"matches\" to specify the matching between the \"offers\" and \"fills\".\r\n    /// The data is bit compacted for ease of index referencing and to reduce gas costs,\r\n    /// i.e. data representing different types of information is stored within one 256 bit value.\r\n    ///\r\n    /// For efficient balance updates, the `_addresses` array is meant to contain a\r\n    /// unique set of user asset pairs in the form of:\r\n    /// [\r\n    ///     user_1_address,\r\n    ///     asset_1_address,\r\n    ///     user_1_address,\r\n    ///     asset_2_address,\r\n    ///     user_2_address,\r\n    ///     asset_1_address,\r\n    ///     ...\r\n    /// ]\r\n    /// This allows combining multiple balance updates for a user asset pair\r\n    /// into a single update by first calculating the total balance update for\r\n    /// a pair at a specified index, then looping through the sums to perform\r\n    /// the balance update.\r\n    ///\r\n    /// The added benefit is further gas cost reduction because repeated\r\n    /// user asset pairs do not need to be duplicated for the calldata.\r\n    ///\r\n    /// The operator address is enforced to be the contract's current operator\r\n    /// address, and the operator fee asset ID is enforced to be identical to\r\n    /// the maker's / filler's feeAssetId.\r\n    ///\r\n    /// A tradeoff of compacting the bits is that there is a lower maximum value\r\n    /// for offer and fill data, however the limits remain generally practical.\r\n    ///\r\n    /// For `offerAmount`, `wantAmount`, `feeAmount` values, the maximum value\r\n    /// is 2^128. For a token with 18 decimals, this allows support for tokens\r\n    /// with a maximum supply of 1000 million billion billion (33 zeros).\r\n    /// In the case where the maximum value needs to be exceeded, a single\r\n    /// offer / fill can be split into multiple offers / fills by the off-chain\r\n    /// service.\r\n    ///\r\n    /// For nonces the maximum value is 2^64, or more than a billion billion (19 zeros).\r\n    ///\r\n    /// Offers and fills both encompass information about how much (offerAmount)\r\n    /// of a specified token (offerAssetId) the user wants to offer and\r\n    /// how much (wantAmount) of another token (wantAssetId) they want\r\n    /// in return.\r\n    ///\r\n    /// Each match specifies how much of the match's `offer.offerAmount` should\r\n    /// be transferred to the filler, in return, the offer's maker receives:\r\n    /// `offer.wantAmount * match.takeAmount / offer.offerAmount` of the\r\n    /// `offer.wantAssetId` from the filler.\r\n    ///\r\n    /// A few restirctions are enforced to ensure fairness and security of trades:\r\n    /// 1. To prevent unfairness due to rounding issues, it is required that:\r\n    /// `offer.wantAmount * match.takeAmount % offer.offerAmount == 0`.\r\n    ///\r\n    /// 2. Fills can be filled by offers which do not individually match\r\n    /// the `fill.offerAmount` and `fill.wantAmount` ratio. As such, it is\r\n    /// required that:\r\n    /// fill.offerAmount == total amount deducted from filler for the fill's\r\n    /// associated matches (excluding fees)\r\n    /// fill.wantAmount == total amount credited to filler for the fill's\r\n    /// associated matches (excluding fees)\r\n    ///\r\n    /// 3. The offer array must not consist of repeated offers. For efficient\r\n    /// balance updates, a loop through each offer in the offer array is used\r\n    /// to deduct the offer.offerAmount from the respective maker\r\n    /// if the offer has not been recorded by a previos `trade` call.\r\n    /// If an offer is repeated in the offers array, then there would be\r\n    /// duplicate deductions from the maker.\r\n    /// To enforce uniqueness, it is required that offers for a trade transaction\r\n    /// are sorted such that their nonces are in a strictly ascending order.\r\n    ///\r\n    /// 4. The fill array must not consist of repeated fills, for the same\r\n    /// reason why there cannot be repeated offers. Additionally, to prevent\r\n    /// replay attacks, all fill nonces are required to be unused.\r\n    ///\r\n    /// @param _values[0] Number of offers, fills, matches\r\n    /// bits(0..8): number of offers (numOffers)\r\n    /// bits(8..16): number of fills (numFills)\r\n    /// bits(16..24): number of matches (numMatches)\r\n    /// bits(24..256): must be zero\r\n    ///\r\n    /// @param _values[1 + i * 2] First part of offer data for the i'th offer\r\n    /// bits(0..8): Index of the maker's address in _addresses\r\n    /// bits(8..16): Index of the maker offerAssetId pair in _addresses\r\n    /// bits(16..24): Index of the maker wantAssetId pair in _addresses\r\n    /// bits(24..32): Index of the maker feeAssetId pair in _addresses\r\n    /// bits(32..40): Index of the operator feeAssetId pair in _addresses\r\n    /// bits(40..48): The `v` component of the maker's signature for this offer\r\n    /// bits(48..56): Indicates whether the Ethereum signed message\r\n    /// prefix should be prepended during signature verification\r\n    /// bits(56..120): The offer nonce to prevent replay attacks\r\n    /// bits(120..128): Space to indicate whether the offer nonce has been marked before\r\n    /// bits(128..256): The number of tokens to be paid to the operator as fees for this offer\r\n    ///\r\n    /// @param _values[2 + i * 2] Second part of offer data for the i'th offer\r\n    /// bits(0..128): offer.offerAmount, i.e. the number of tokens to offer\r\n    /// bits(128..256): offer.wantAmount, i.e. the number of tokens to ask for in return\r\n    ///\r\n    /// @param _values[1 + numOffers * 2 + i * 2] First part of fill data for the i'th fill\r\n    /// bits(0..8): Index of the filler's address in _addresses\r\n    /// bits(8..16): Index of the filler offerAssetId pair in _addresses\r\n    /// bits(16..24): Index of the filler wantAssetId pair in _addresses\r\n    /// bits(24..32): Index of the filler feeAssetId pair in _addresses\r\n    /// bits(32..40): Index of the operator feeAssetId pair in _addresses\r\n    /// bits(40..48): The `v` component of the filler's signature for this fill\r\n    /// bits(48..56): Indicates whether the Ethereum signed message\r\n    /// prefix should be prepended during signature verification\r\n    /// bits(56..120): The fill nonce to prevent replay attacks\r\n    /// bits(120..128): Left empty to match the offer values format\r\n    /// bits(128..256): The number of tokens to be paid to the operator as fees for this fill\r\n    ///\r\n    /// @param _values[2 + numOffers * 2 + i * 2] Second part of fill data for the i'th fill\r\n    /// bits(0..128): fill.offerAmount, i.e. the number of tokens to offer\r\n    /// bits(128..256): fill.wantAmount, i.e. the number of tokens to ask for in return\r\n    ///\r\n    /// @param _values[1 + numOffers * 2 + numFills * 2 + i] Data for the i'th match\r\n    /// bits(0..8): Index of the offerIndex for this match\r\n    /// bits(8..16): Index of the fillIndex for this match\r\n    /// bits(128..256): The number of tokens to take from the matched offer's offerAmount\r\n    ///\r\n    /// @param _hashes[i * 2] The `r` component of the maker's / filler's signature\r\n    /// for the i'th offer / fill\r\n    ///\r\n    /// @param _hashes[i * 2 + 1] The `s` component of the maker's / filler's signature\r\n    /// for the i'th offer / fill\r\n    ///\r\n    /// @param _addresses An array of user asset pairs in the form of:\r\n    /// [\r\n    ///     user_1_address,\r\n    ///     asset_1_address,\r\n    ///     user_1_address,\r\n    ///     asset_2_address,\r\n    ///     user_2_address,\r\n    ///     asset_1_address,\r\n    ///     ...\r\n    /// ]\r\n    function trade(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses\r\n    )\r\n        public\r\n        onlyAdmin\r\n        onlyActiveState\r\n        nonReentrant\r\n    {\r\n        // Cache the operator address to reduce gas costs from storage reads\r\n        address operatorAddress = operator;\r\n        // An array variable to store balance increments / decrements\r\n        uint256[] memory statements;\r\n\r\n        // Cache whether offer nonces are taken in the offer's nonce space\r\n        _cacheOfferNonceStates(_values);\r\n\r\n        // `validateTrades` needs to calculate the hash keys of offers and fills\r\n        // to verify the signature of the offer / fill.\r\n        // The calculated hash keys are returned to reduce repeated computation.\r\n        _hashes = Utils.validateTrades(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            operatorAddress\r\n        );\r\n\r\n        statements = Utils.calculateTradeIncrements(_values, _addresses.length / 2);\r\n        _incrementBalances(statements, _addresses, 1);\r\n\r\n        statements = Utils.calculateTradeDecrements(_values, _addresses.length / 2);\r\n        _decrementBalances(statements, _addresses);\r\n\r\n        // Reduce available offer amounts of offers and store the remaining\r\n        // offer amount in the `offers` mapping.\r\n        // Offer nonces will also be marked as taken.\r\n        _storeOfferData(_values, _hashes);\r\n\r\n        // Mark all fill nonces as taken in the `usedNonces` mapping.\r\n        _storeFillNonces(_values);\r\n    }\r\n\r\n    /// @notice Executes an array of offers against external orders.\r\n    /// @dev This method accepts an array of \"offers\" together with\r\n    /// an array of \"matches\" to specify the matching between the \"offers\" and\r\n    /// external orders.\r\n    /// The data is bit compacted and formatted in the same way as the `trade` function.\r\n    ///\r\n    /// @param _values[0] Number of offers, fills, matches\r\n    /// bits(0..8): number of offers (numOffers)\r\n    /// bits(8..16): number of fills, must be zero\r\n    /// bits(16..24): number of matches (numMatches)\r\n    /// bits(24..256): must be zero\r\n    ///\r\n    /// @param _values[1 + i * 2] First part of offer data for the i'th offer\r\n    /// bits(0..8): Index of the maker's address in _addresses\r\n    /// bits(8..16): Index of the maker offerAssetId pair in _addresses\r\n    /// bits(16..24): Index of the maker wantAssetId pair in _addresses\r\n    /// bits(24..32): Index of the maker feeAssetId pair in _addresses\r\n    /// bits(32..40): Index of the operator feeAssetId pair in _addresses\r\n    /// bits(40..48): The `v` component of the maker's signature for this offer\r\n    /// bits(48..56): Indicates whether the Ethereum signed message\r\n    /// prefix should be prepended during signature verification\r\n    /// bits(56..120): The offer nonce to prevent replay attacks\r\n    /// bits(120..128): Space to indicate whether the offer nonce has been marked before\r\n    /// bits(128..256): The number of tokens to be paid to the operator as fees for this offer\r\n    ///\r\n    /// @param _values[2 + i * 2] Second part of offer data for the i'th offer\r\n    /// bits(0..128): offer.offerAmount, i.e. the number of tokens to offer\r\n    /// bits(128..256): offer.wantAmount, i.e. the number of tokens to ask for in return\r\n    ///\r\n    /// @param _values[1 + numOffers * 2 + i] Data for the i'th match\r\n    /// bits(0..8): Index of the offerIndex for this match\r\n    /// bits(8..16): Index of the marketDapp for this match\r\n    /// bits(16..24): Index of the surplus receiver and surplus asset ID for this\r\n    /// match, for any excess tokens resulting from the trade\r\n    /// bits(24..128): Additional DApp specific data\r\n    /// bits(128..256): The number of tokens to take from the matched offer's offerAmount\r\n    ///\r\n    /// @param _hashes[i * 2] The `r` component of the maker's / filler's signature\r\n    /// for the i'th offer / fill\r\n    ///\r\n    /// @param _hashes[i * 2 + 1] The `s` component of the maker's / filler's signature\r\n    /// for the i'th offer / fill\r\n    ///\r\n    /// @param _addresses An array of user asset pairs in the form of:\r\n    /// [\r\n    ///     user_1_address,\r\n    ///     asset_1_address,\r\n    ///     user_1_address,\r\n    ///     asset_2_address,\r\n    ///     user_2_address,\r\n    ///     asset_1_address,\r\n    ///     ...\r\n    /// ]\r\n    function networkTrade(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes,\r\n        address[] memory _addresses\r\n    )\r\n        public\r\n        onlyAdmin\r\n        onlyActiveState\r\n        nonReentrant\r\n    {\r\n        // Cache the operator address to reduce gas costs from storage reads\r\n        address operatorAddress = operator;\r\n        // An array variable to store balance increments / decrements\r\n        uint256[] memory statements;\r\n\r\n        // Cache whether offer nonces are taken in the offer's nonce space\r\n        _cacheOfferNonceStates(_values);\r\n\r\n        // `validateNetworkTrades` needs to calculate the hash keys of offers\r\n        // to verify the signature of the offer.\r\n        // The calculated hash keys for each offer is return to reduce repeated\r\n        // computation.\r\n        _hashes = Utils.validateNetworkTrades(\r\n            _values,\r\n            _hashes,\r\n            _addresses,\r\n            operatorAddress\r\n        );\r\n\r\n        statements = Utils.calculateNetworkTradeIncrements(_values, _addresses.length / 2);\r\n        _incrementBalances(statements, _addresses, 1);\r\n\r\n        statements = Utils.calculateNetworkTradeDecrements(_values, _addresses.length / 2);\r\n        _decrementBalances(statements, _addresses);\r\n\r\n        // Reduce available offer amounts of offers and store the remaining\r\n        // offer amount in the `offers` mapping.\r\n        // Offer nonces will also be marked as taken.\r\n        _storeOfferData(_values, _hashes);\r\n\r\n        // There may be excess tokens resulting from a trade\r\n        // Any excess tokens are returned and recorded in `increments`\r\n        statements = Utils.performNetworkTrades(\r\n            _values,\r\n            _addresses,\r\n            marketDapps\r\n        );\r\n        _incrementBalances(statements, _addresses, 0);\r\n    }\r\n\r\n    /// @notice Cancels a perviously made offer and refunds the remaining offer\r\n    /// amount to the offer maker.\r\n    /// To reduce gas costs, the original parameters of the offer are not stored\r\n    /// in the contract's storage, only the hash of the parameters is stored for\r\n    /// verification, so the original parameters need to be re-specified here.\r\n    ///\r\n    /// The `_expectedavailableamount` is required to help prevent accidental\r\n    /// cancellation of an offer ahead of time, for example, if there is\r\n    /// a pending fill in the off-chain state.\r\n    ///\r\n    /// @param _values[0] The offerAmount and wantAmount of the offer\r\n    /// bits(0..128): offer.offerAmount\r\n    /// bits(128..256): offer.wantAmount\r\n    ///\r\n    /// @param _values[1] The fee amounts\r\n    /// bits(0..128): offer.feeAmount\r\n    /// bits(128..256): cancelFeeAmount\r\n    ///\r\n    /// @param _values[2] Additional offer and cancellation data\r\n    /// bits(0..128): expectedAvailableAmount\r\n    /// bits(128..136): prefixedSignature\r\n    /// bits(136..144): The `v` component of the maker's signature for the cancellation\r\n    /// bits(144..256): offer.nonce\r\n    ///\r\n    /// @param _hashes[0] The `r` component of the maker's signature for the cancellation\r\n    /// @param _hashes[1] The `s` component of the maker's signature for the cancellation\r\n    ///\r\n    /// @param _addresses[0] offer.maker\r\n    /// @param _addresses[1] offer.offerAssetId\r\n    /// @param _addresses[2] offer.wantAssetId\r\n    /// @param _addresses[3] offer.feeAssetId\r\n    /// @param _addresses[4] offer.cancelFeeAssetId\r\n    function cancel(\r\n        uint256[] calldata _values,\r\n        bytes32[] calldata _hashes,\r\n        address[] calldata _addresses\r\n    )\r\n        external\r\n        onlyAdmin\r\n        nonReentrant\r\n    {\r\n        Utils.validateCancel(_values, _hashes, _addresses);\r\n        bytes32 offerHash = Utils.hashOffer(_values, _addresses);\r\n        _cancel(\r\n            _addresses[0], // maker\r\n            offerHash,\r\n            _values[2] & mask128, // expectedAvailableAmount\r\n            _addresses[1], // offerAssetId\r\n            _values[2] >> 144, // offerNonce\r\n            _addresses[4], // cancelFeeAssetId\r\n            _values[1] >> 128 // cancelFeeAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Cancels an offer without requiring the maker's signature\r\n    /// @dev This method is intended to be used in the case of a contract\r\n    /// upgrade or in an emergency. It can only be invoked by an admin and only\r\n    /// after the admin state has been set to `Escalated` by the contract owner.\r\n    ///\r\n    /// To reduce gas costs, the original parameters of the offer are not stored\r\n    /// in the contract's storage, only the hash of the parameters is stored for\r\n    /// verification, so the original parameters need to be re-specified here.\r\n    ///\r\n    /// The `_expectedavailableamount` is required to help prevent accidental\r\n    /// cancellation of an offer ahead of time, for example, if there is\r\n    /// a pending fill in the off-chain state.\r\n    /// @param _maker The address of the offer's maker\r\n    /// @param _offerAssetId The contract address of the offerred asset\r\n    /// @param _offerAmount The number of tokens offerred\r\n    /// @param _wantAssetId The contract address of the asset asked in return\r\n    /// @param _wantAmount The number of tokens asked for in return\r\n    /// @param _feeAssetId The contract address of the fee asset\r\n    /// @param _feeAmount The number of tokens to pay as fees to the operator\r\n    /// @param _offerNonce The nonce of the original offer\r\n    /// @param _expectedAvailableAmount The offer amount remaining\r\n    function adminCancel(\r\n        address _maker,\r\n        address _offerAssetId,\r\n        uint256 _offerAmount,\r\n        address _wantAssetId,\r\n        uint256 _wantAmount,\r\n        address _feeAssetId,\r\n        uint256 _feeAmount,\r\n        uint256 _offerNonce,\r\n        uint256 _expectedAvailableAmount\r\n    )\r\n        external\r\n        onlyAdmin\r\n        onlyEscalatedAdminState\r\n        nonReentrant\r\n    {\r\n        bytes32 offerHash = keccak256(abi.encode(\r\n            OFFER_TYPEHASH,\r\n            _maker,\r\n            _offerAssetId,\r\n            _offerAmount,\r\n            _wantAssetId,\r\n            _wantAmount,\r\n            _feeAssetId,\r\n            _feeAmount,\r\n            _offerNonce\r\n        ));\r\n\r\n        _cancel(\r\n            _maker,\r\n            offerHash,\r\n            _expectedAvailableAmount,\r\n            _offerAssetId,\r\n            _offerNonce,\r\n            address(0),\r\n            0\r\n        );\r\n    }\r\n\r\n    /// @notice Announces a user's intention to cancel their offer\r\n    /// @dev This method allows a user to cancel their offer without requiring\r\n    /// admin permissions.\r\n    /// An announcement followed by a delay is needed so that the off-chain\r\n    /// service has time to update the off-chain state.\r\n    ///\r\n    /// To reduce gas costs, the original parameters of the offer are not stored\r\n    /// in the contract's storage, only the hash of the parameters is stored for\r\n    /// verification, so the original parameters need to be re-specified here.\r\n    ///\r\n    /// @param _maker The address of the offer's maker\r\n    /// @param _offerAssetId The contract address of the offerred asset\r\n    /// @param _offerAmount The number of tokens offerred\r\n    /// @param _wantAssetId The contract address of the asset asked in return\r\n    /// @param _wantAmount The number of tokens asked for in return\r\n    /// @param _feeAssetId The contract address of the fee asset\r\n    /// @param _feeAmount The number of tokens to pay as fees to the operator\r\n    /// @param _offerNonce The nonce of the original offer\r\n    function announceCancel(\r\n        address _maker,\r\n        address _offerAssetId,\r\n        uint256 _offerAmount,\r\n        address _wantAssetId,\r\n        uint256 _wantAmount,\r\n        address _feeAssetId,\r\n        uint256 _feeAmount,\r\n        uint256 _offerNonce\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n        // Error code 11: announceCancel, invalid msg.sender\r\n        require(_maker == msg.sender, \"11\");\r\n\r\n        bytes32 offerHash = keccak256(abi.encode(\r\n            OFFER_TYPEHASH,\r\n            _maker,\r\n            _offerAssetId,\r\n            _offerAmount,\r\n            _wantAssetId,\r\n            _wantAmount,\r\n            _feeAssetId,\r\n            _feeAmount,\r\n            _offerNonce\r\n        ));\r\n\r\n        // Error code 12: announceCancel, nothing left to cancel\r\n        require(offers[offerHash] > 0, \"12\");\r\n\r\n        uint256 cancellableAt = now.add(slowCancelDelay);\r\n        cancellationAnnouncements[offerHash] = cancellableAt;\r\n\r\n        emit AnnounceCancel(offerHash, cancellableAt);\r\n    }\r\n\r\n    /// @notice Executes an offer cancellation previously announced in `announceCancel`\r\n    /// @dev This method allows a user to cancel their offer without requiring\r\n    /// admin permissions.\r\n    /// An announcement followed by a delay is needed so that the off-chain\r\n    /// service has time to update the off-chain state.\r\n    ///\r\n    /// To reduce gas costs, the original parameters of the offer are not stored\r\n    /// in the contract's storage, only the hash of the parameters is stored for\r\n    /// verification, so the original parameters need to be re-specified here.\r\n    ///\r\n    /// @param _maker The address of the offer's maker\r\n    /// @param _offerAssetId The contract address of the offerred asset\r\n    /// @param _offerAmount The number of tokens offerred\r\n    /// @param _wantAssetId The contract address of the asset asked in return\r\n    /// @param _wantAmount The number of tokens asked for in return\r\n    /// @param _feeAssetId The contract address of the fee asset\r\n    /// @param _feeAmount The number of tokens to pay as fees to the operator\r\n    /// @param _offerNonce The nonce of the original offer\r\n    function slowCancel(\r\n        address _maker,\r\n        address _offerAssetId,\r\n        uint256 _offerAmount,\r\n        address _wantAssetId,\r\n        uint256 _wantAmount,\r\n        address _feeAssetId,\r\n        uint256 _feeAmount,\r\n        uint256 _offerNonce\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n        bytes32 offerHash = keccak256(abi.encode(\r\n            OFFER_TYPEHASH,\r\n            _maker,\r\n            _offerAssetId,\r\n            _offerAmount,\r\n            _wantAssetId,\r\n            _wantAmount,\r\n            _feeAssetId,\r\n            _feeAmount,\r\n            _offerNonce\r\n        ));\r\n\r\n        uint256 cancellableAt = cancellationAnnouncements[offerHash];\r\n        // Error code 13: slowCancel, cancellation was not announced\r\n        require(cancellableAt != 0, \"13\");\r\n        // Error code 14: slowCancel, cancellation delay not yet reached\r\n        require(now >= cancellableAt, \"14\");\r\n\r\n        uint256 availableAmount = offers[offerHash];\r\n        // Error code 15: slowCancel, nothing left to cancel\r\n        require(availableAmount > 0, \"15\");\r\n\r\n        delete cancellationAnnouncements[offerHash];\r\n        _cancel(\r\n            _maker,\r\n            offerHash,\r\n            availableAmount,\r\n            _offerAssetId,\r\n            _offerNonce,\r\n            address(0),\r\n            0\r\n        );\r\n\r\n        emit SlowCancel(offerHash, availableAmount);\r\n    }\r\n\r\n    /// @notice Withdraws tokens from the Broker contract to a user's wallet balance\r\n    /// @dev The user's internal balance is decreased, and the tokens are transferred\r\n    /// to the `_receivingAddress` signed by the user.\r\n    /// @param _withdrawer The user address whose balance will be reduced\r\n    /// @param _receivingAddress The address to tranfer the tokens to\r\n    /// @param _assetId The contract address of the token to withdraw\r\n    /// @param _amount The number of tokens to withdraw\r\n    /// @param _feeAssetId The contract address of the fee asset\r\n    /// @param _feeAmount The number of tokens to pay as fees to the operator\r\n    /// @param _nonce An unused nonce to prevent replay attacks\r\n    /// @param _v The `v` component of the `_user`'s signature\r\n    /// @param _r The `r` component of the `_user`'s signature\r\n    /// @param _s The `s` component of the `_user`'s signature\r\n    /// @param _prefixedSignature Indicates whether the Ethereum signed message\r\n    /// prefix should be prepended during signature verification\r\n    function withdraw(\r\n        address _withdrawer,\r\n        address payable _receivingAddress,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        address _feeAssetId,\r\n        uint256 _feeAmount,\r\n        uint256 _nonce,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        bool _prefixedSignature\r\n    )\r\n        external\r\n        onlyAdmin\r\n        nonReentrant\r\n    {\r\n        _markNonce(_nonce);\r\n\r\n        _validateSignature(\r\n            keccak256(abi.encode(\r\n                WITHDRAW_TYPEHASH,\r\n                _withdrawer,\r\n                _receivingAddress,\r\n                _assetId,\r\n                _amount,\r\n                _feeAssetId,\r\n                _feeAmount,\r\n                _nonce\r\n            )),\r\n            _withdrawer,\r\n            _v,\r\n            _r,\r\n            _s,\r\n            _prefixedSignature\r\n        );\r\n\r\n        _withdraw(\r\n            _withdrawer,\r\n            _receivingAddress,\r\n            _assetId,\r\n            _amount,\r\n            _feeAssetId,\r\n            _feeAmount,\r\n            _nonce\r\n        );\r\n    }\r\n\r\n    /// @notice Withdraws tokens without requiring the withdrawer's signature\r\n    /// @dev This method is intended to be used in the case of a contract\r\n    /// upgrade or in an emergency. It can only be invoked by an admin and only\r\n    /// after the admin state has been set to `Escalated` by the contract owner.\r\n    /// Unlike `withdraw`, tokens can only be withdrawn to the `_withdrawer`'s\r\n    /// address.\r\n    /// @param _withdrawer The user address whose balance will be reduced\r\n    /// @param _assetId The contract address of the token to withdraw\r\n    /// @param _amount The number of tokens to withdraw\r\n    /// @param _nonce An unused nonce for balance tracking\r\n    function adminWithdraw(\r\n        address payable _withdrawer,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        uint256 _nonce\r\n    )\r\n        external\r\n        onlyAdmin\r\n        onlyEscalatedAdminState\r\n        nonReentrant\r\n    {\r\n        _markNonce(_nonce);\r\n\r\n        _withdraw(\r\n            _withdrawer,\r\n            _withdrawer,\r\n            _assetId,\r\n            _amount,\r\n            address(0),\r\n            0,\r\n            _nonce\r\n        );\r\n    }\r\n\r\n    /// @notice Announces a user's intention to withdraw their funds\r\n    /// @dev This method allows a user to withdraw their funds without requiring\r\n    /// admin permissions.\r\n    /// An announcement followed by a delay before execution is needed so that\r\n    /// the off-chain service has time to update the off-chain state.\r\n    /// @param _assetId The contract address of the token to withdraw\r\n    /// @param _amount The number of tokens to withdraw\r\n    function announceWithdraw(\r\n        address _assetId,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n\r\n        // Error code 16: announceWithdraw, invalid withdrawal amount\r\n        require(_amount > 0 && _amount <= balances[msg.sender][_assetId], \"16\");\r\n\r\n        WithdrawalAnnouncement storage announcement = withdrawalAnnouncements[msg.sender][_assetId];\r\n\r\n        announcement.withdrawableAt = now.add(slowWithdrawDelay);\r\n        announcement.amount = _amount;\r\n\r\n        emit AnnounceWithdraw(msg.sender, _assetId, _amount, announcement.withdrawableAt);\r\n    }\r\n\r\n    /// @notice Executes a withdrawal previously announced in `announceWithdraw`\r\n    /// @dev This method allows a user to withdraw their funds without requiring\r\n    /// admin permissions.\r\n    /// An announcement followed by a delay before execution is needed so that\r\n    /// the off-chain service has time to update the off-chain state.\r\n    /// @param _withdrawer The user address whose balance will be reduced\r\n    /// @param _assetId The contract address of the token to withdraw\r\n    function slowWithdraw(\r\n        address payable _withdrawer,\r\n        address _assetId,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n        WithdrawalAnnouncement memory announcement = withdrawalAnnouncements[_withdrawer][_assetId];\r\n\r\n        // Error code 17: slowWithdraw, withdrawal was not announced\r\n        require(announcement.withdrawableAt != 0, \"17\");\r\n        // Error code 18: slowWithdraw, withdrawal delay not yet reached\r\n        require(now >= announcement.withdrawableAt, \"18\");\r\n        // Error code 19: slowWithdraw, withdrawal amount does not match announced amount\r\n        require(announcement.amount == _amount, \"19\");\r\n\r\n        delete withdrawalAnnouncements[_withdrawer][_assetId];\r\n        _withdraw(\r\n            _withdrawer,\r\n            _withdrawer,\r\n            _assetId,\r\n            _amount,\r\n            address(0),\r\n            0,\r\n            0\r\n        );\r\n        emit SlowWithdraw(_withdrawer, _assetId, _amount);\r\n    }\r\n\r\n    /// @notice Locks a user's balances for the first part of an atomic swap\r\n    /// @param _addresses[0] maker: the address of the user to deduct the swap tokens from\r\n    /// @param _addresses[1] taker: the address of the swap taker who will receive the swap tokens\r\n    /// if the swap is completed through `executeSwap`\r\n    /// @param _addresses[2] assetId: the contract address of the token to swap\r\n    /// @param _addresses[3] feeAssetId: the contract address of the token to use as fees\r\n    /// @param _values[0] amount: the number of tokens to lock and to transfer if the swap\r\n    ///  is completed through `executeSwap`\r\n    /// @param _values[1] expiryTime: the time in epoch seconds after which the swap will become cancellable\r\n    /// @param _values[2] feeAmount: the number of tokens to be paid to the operator as fees\r\n    /// @param _values[3] nonce: an unused nonce to prevent replay attacks\r\n    /// @param _hashes[0] hashedSecret: the hash of the secret decided by the maker\r\n    /// @param _hashes[1] The `r` component of the user's signature\r\n    /// @param _hashes[2] The `s` component of the user's signature\r\n    /// @param _v The `v` component of the user's signature\r\n    /// @param _prefixedSignature Indicates whether the Ethereum signed message\r\n    /// prefix should be prepended during signature verification\r\n    function createSwap(\r\n        address[4] calldata _addresses,\r\n        uint256[4] calldata _values,\r\n        bytes32[3] calldata _hashes,\r\n        uint8 _v,\r\n        bool _prefixedSignature\r\n    )\r\n        external\r\n        onlyAdmin\r\n        onlyActiveState\r\n        nonReentrant\r\n    {\r\n        // Error code 20: createSwap, invalid swap amount\r\n        require(_values[0] > 0, \"20\");\r\n        // Error code 21: createSwap, expiry time has already passed\r\n        require(_values[1] > now, \"21\");\r\n        _validateAddress(_addresses[1]);\r\n\r\n        // Error code 39: createSwap, swap maker cannot be the swap taker\r\n        require(_addresses[0] != _addresses[1], \"39\");\r\n\r\n        bytes32 swapHash = _hashSwap(_addresses, _values, _hashes[0]);\r\n        // Error code 22: createSwap, the swap is already active\r\n        require(!atomicSwaps[swapHash], \"22\");\r\n\r\n        _markNonce(_values[3]);\r\n\r\n        _validateSignature(\r\n            swapHash,\r\n            _addresses[0], // swap.maker\r\n            _v,\r\n            _hashes[1], // r\r\n            _hashes[2], // s\r\n            _prefixedSignature\r\n        );\r\n\r\n        if (_addresses[3] == _addresses[2]) { // feeAssetId == assetId\r\n            // Error code 23: createSwap, swap.feeAmount exceeds swap.amount\r\n            require(_values[2] < _values[0], \"23\"); // feeAmount < amount\r\n        } else {\r\n            _decreaseBalance(\r\n                _addresses[0], // maker\r\n                _addresses[3], // feeAssetId\r\n                _values[2], // feeAmount\r\n                REASON_SWAP_FEE_GIVE,\r\n                _values[3] // nonce\r\n            );\r\n        }\r\n\r\n        _decreaseBalance(\r\n            _addresses[0], // maker\r\n            _addresses[2], // assetId\r\n            _values[0], // amount\r\n            REASON_SWAP_GIVE,\r\n            _values[3] // nonce\r\n        );\r\n\r\n        atomicSwaps[swapHash] = true;\r\n    }\r\n\r\n    /// @notice Executes a swap by transferring the tokens previously locked through\r\n    /// a `createSwap` call to the swap taker.\r\n    ///\r\n    /// @dev To reduce gas costs, the original parameters of the swap are not stored\r\n    /// in the contract's storage, only the hash of the parameters is stored for\r\n    /// verification, so the original parameters need to be re-specified here.\r\n    ///\r\n    /// @param _addresses[0] maker: the address of the user to deduct the swap tokens from\r\n    /// @param _addresses[1] taker: the address of the swap taker who will receive the swap tokens\r\n    /// @param _addresses[2] assetId: the contract address of the token to swap\r\n    /// @param _addresses[3] feeAssetId: the contract address of the token to use as fees\r\n    /// @param _values[0] amount: the number of tokens previously locked\r\n    /// @param _values[1] expiryTime: the time in epoch seconds after which the swap will become cancellable\r\n    /// @param _values[2] feeAmount: the number of tokens to be paid to the operator as fees\r\n    /// @param _values[3] nonce: an unused nonce to prevent replay attacks\r\n    /// @param _hashedSecret The hash of the secret decided by the maker\r\n    /// @param _preimage The preimage of the `_hashedSecret`\r\n    function executeSwap(\r\n        address[4] calldata _addresses,\r\n        uint256[4] calldata _values,\r\n        bytes32 _hashedSecret,\r\n        bytes calldata _preimage\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n        // Error code 37: swap secret length exceeded\r\n        require(_preimage.length <= MAX_SWAP_SECRET_LENGTH, \"37\");\r\n\r\n        bytes32 swapHash = _hashSwap(_addresses, _values, _hashedSecret);\r\n        // Error code 24: executeSwap, swap is not active\r\n        require(atomicSwaps[swapHash], \"24\");\r\n        // Error code 25: executeSwap, hash of preimage does not match hashedSecret\r\n        require(sha256(abi.encodePacked(sha256(_preimage))) == _hashedSecret, \"25\");\r\n\r\n        uint256 takeAmount = _values[0];\r\n        if (_addresses[3] == _addresses[2]) { // feeAssetId == assetId\r\n            takeAmount = takeAmount.sub(_values[2]);\r\n        }\r\n\r\n        delete atomicSwaps[swapHash];\r\n\r\n        _increaseBalance(\r\n            _addresses[1], // taker\r\n            _addresses[2], // assetId\r\n            takeAmount,\r\n            REASON_SWAP_RECEIVE,\r\n            _values[3] // nonce\r\n        );\r\n\r\n        _increaseBalance(\r\n            operator,\r\n            _addresses[3], // feeAssetId\r\n            _values[2], // feeAmount\r\n            REASON_SWAP_FEE_RECEIVE,\r\n            _values[3] // nonce\r\n        );\r\n    }\r\n\r\n    /// @notice Cancels a swap and refunds the previously locked tokens to\r\n    /// the swap maker.\r\n    ///\r\n    /// @dev To reduce gas costs, the original parameters of the swap are not stored\r\n    /// in the contract's storage, only the hash of the parameters is stored for\r\n    /// verification, so the original parameters need to be re-specified here.\r\n    ///\r\n    /// @param _addresses[0] maker: the address of the user to deduct the swap tokens from\r\n    /// @param _addresses[1] taker: the address of the swap taker who will receive the swap tokens\r\n    /// @param _addresses[2] assetId: the contract address of the token to swap\r\n    /// @param _addresses[3] feeAssetId: the contract address of the token to use as fees\r\n    /// @param _values[0] amount: the number of tokens previously locked\r\n    /// @param _values[1] expiryTime: the time in epoch seconds after which the swap will become cancellable\r\n    /// @param _values[2] feeAmount: the number of tokens to be paid to the operator as fees\r\n    /// @param _values[3] nonce: an unused nonce to prevent replay attacks\r\n    /// @param _hashedSecret The hash of the secret decided by the maker\r\n    /// @param _cancelFeeAmount The number of tokens to be paid to the operator as the cancellation fee\r\n    function cancelSwap(\r\n        address[4] calldata _addresses,\r\n        uint256[4] calldata _values,\r\n        bytes32 _hashedSecret,\r\n        uint256 _cancelFeeAmount\r\n    )\r\n        external\r\n        nonReentrant\r\n    {\r\n        // Error code 26: cancelSwap, expiry time has not been reached\r\n        require(_values[1] <= now, \"26\");\r\n        bytes32 swapHash = _hashSwap(_addresses, _values, _hashedSecret);\r\n        // Error code 27: cancelSwap, swap is not active\r\n        require(atomicSwaps[swapHash], \"27\");\r\n\r\n        uint256 cancelFeeAmount = _cancelFeeAmount;\r\n        if (!adminAddresses[msg.sender]) { cancelFeeAmount = _values[2]; }\r\n\r\n        // cancelFeeAmount <= feeAmount\r\n        // Error code 28: cancelSwap, cancelFeeAmount exceeds swap.feeAmount\r\n        require(cancelFeeAmount <= _values[2], \"28\");\r\n\r\n        uint256 refundAmount = _values[0];\r\n        if (_addresses[3] == _addresses[2]) { // feeAssetId == assetId\r\n            refundAmount = refundAmount.sub(cancelFeeAmount);\r\n        }\r\n\r\n        delete atomicSwaps[swapHash];\r\n\r\n        _increaseBalance(\r\n            _addresses[0], // maker\r\n            _addresses[2], // assetId\r\n            refundAmount,\r\n            REASON_SWAP_CANCEL_RECEIVE,\r\n            _values[3] // nonce\r\n        );\r\n\r\n        _increaseBalance(\r\n            operator,\r\n            _addresses[3], // feeAssetId\r\n            cancelFeeAmount,\r\n            REASON_SWAP_CANCEL_FEE_RECEIVE,\r\n            _values[3] // nonce\r\n        );\r\n\r\n        if (_addresses[3] != _addresses[2]) { // feeAssetId != assetId\r\n            uint256 refundFeeAmount = _values[2].sub(cancelFeeAmount);\r\n            _increaseBalance(\r\n                _addresses[0], // maker\r\n                _addresses[3], // feeAssetId\r\n                refundFeeAmount,\r\n                REASON_SWAP_CANCEL_FEE_REFUND,\r\n                _values[3] // nonce\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @dev Cache whether offer nonces are taken in the offer's nonce space\r\n    /// @param _values The _values param from the trade / networkTrade method\r\n    function _cacheOfferNonceStates(uint256[] memory _values) private view {\r\n        uint256 i = 1;\r\n        // i + numOffers * 2\r\n        uint256 end = i + (_values[0] & mask8) * 2;\r\n\r\n        // loop offers\r\n        for(i; i < end; i += 2) {\r\n            // Error code 38: Invalid nonce space\r\n            require(((_values[i] & mask128) >> 120) == 0, \"38\");\r\n\r\n            uint256 nonce = (_values[i] & mask120) >> 56;\r\n            if (_nonceTaken(nonce)) {\r\n                _values[i] = _values[i] | (uint256(1) << 120);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Reduce available offer amounts of offers and store the remaining\r\n    /// offer amount in the `offers` mapping.\r\n    /// Offer nonces will also be marked as taken.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    /// @param _hashes An array of offer hash keys\r\n    function _storeOfferData(\r\n        uint256[] memory _values,\r\n        bytes32[] memory _hashes\r\n    )\r\n        private\r\n    {\r\n        // takenAmounts with same size as numOffers\r\n        uint256[] memory takenAmounts = new uint256[](_values[0] & mask8);\r\n\r\n        uint256 i = 1;\r\n        // i += numOffers * 2\r\n        i += (_values[0] & mask8) * 2;\r\n        // i += numFills * 2\r\n        i += ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        uint256 end = _values.length;\r\n\r\n        // loop matches\r\n        for (i; i < end; i++) {\r\n            uint256 offerIndex = _values[i] & mask8;\r\n            uint256 takeAmount = _values[i] >> 128;\r\n            takenAmounts[offerIndex] = takenAmounts[offerIndex].add(takeAmount);\r\n        }\r\n\r\n        i = 0;\r\n        end = _values[0] & mask8; // numOffers\r\n\r\n        // loop offers\r\n        for (i; i < end; i++) {\r\n            // we can use the cached nonce taken value here because offers have been\r\n            // validated to be unique\r\n            bool existingOffer = ((_values[i * 2 + 1] & mask128) >> 120) == 1;\r\n            bytes32 hashKey = _hashes[i * 2];\r\n\r\n            uint256 availableAmount = existingOffer ? offers[hashKey] : (_values[i * 2 + 2] & mask128);\r\n            // Error code 31: _storeOfferData, offer's available amount is zero\r\n            require(availableAmount > 0, \"31\");\r\n\r\n            uint256 remainingAmount = availableAmount.sub(takenAmounts[i]);\r\n            if (remainingAmount > 0) { offers[hashKey] = remainingAmount; }\r\n            if (existingOffer && remainingAmount == 0) { delete offers[hashKey]; }\r\n\r\n            if (!existingOffer) {\r\n                uint256 nonce = (_values[i * 2 + 1] & mask120) >> 56;\r\n                _markNonce(nonce);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Mark all fill nonces as taken in the `usedNonces` mapping.\r\n    /// This also validates fill uniquness within the set of fills in `_values`,\r\n    /// since fill nonces are marked one at a time with validation that the\r\n    /// nonce to be marked has not been marked before.\r\n    /// See the `trade` method for param details.\r\n    /// @param _values Values from `trade`\r\n    function _storeFillNonces(uint256[] memory _values) private {\r\n        // 1 + numOffers * 2\r\n        uint256 i = 1 + (_values[0] & mask8) * 2;\r\n        // i + numFills * 2\r\n        uint256 end = i + ((_values[0] & mask16) >> 8) * 2;\r\n\r\n        // loop fills\r\n        for(i; i < end; i += 2) {\r\n            uint256 nonce = (_values[i] & mask120) >> 56;\r\n            _markNonce(nonce);\r\n        }\r\n    }\r\n\r\n    /// @dev The actual cancellation logic shared by `cancel`, `adminCancel`,\r\n    /// `slowCancel`.\r\n    /// The remaining offer amount is refunded back to the offer's maker, and\r\n    /// the specified cancellation fee will be deducted from the maker's balances.\r\n    function _cancel(\r\n        address _maker,\r\n        bytes32 _offerHash,\r\n        uint256 _expectedAvailableAmount,\r\n        address _offerAssetId,\r\n        uint256 _offerNonce,\r\n        address _cancelFeeAssetId,\r\n        uint256 _cancelFeeAmount\r\n    )\r\n        private\r\n    {\r\n        uint256 refundAmount = offers[_offerHash];\r\n        // Error code 32: _cancel, there is no offer amount left to cancel\r\n        require(refundAmount > 0, \"32\");\r\n        // Error code 33: _cancel, the remaining offer amount does not match\r\n        // the expectedAvailableAmount\r\n        require(refundAmount == _expectedAvailableAmount, \"33\");\r\n\r\n        delete offers[_offerHash];\r\n\r\n        if (_cancelFeeAssetId == _offerAssetId) {\r\n            refundAmount = refundAmount.sub(_cancelFeeAmount);\r\n        } else {\r\n            _decreaseBalance(\r\n                _maker,\r\n                _cancelFeeAssetId,\r\n                _cancelFeeAmount,\r\n                REASON_CANCEL_FEE_GIVE,\r\n                _offerNonce\r\n            );\r\n        }\r\n\r\n        _increaseBalance(\r\n            _maker,\r\n            _offerAssetId,\r\n            refundAmount,\r\n            REASON_CANCEL,\r\n            _offerNonce\r\n        );\r\n\r\n        _increaseBalance(\r\n            operator,\r\n            _cancelFeeAssetId,\r\n            _cancelFeeAmount,\r\n            REASON_CANCEL_FEE_RECEIVE,\r\n            _offerNonce // offer nonce\r\n        );\r\n    }\r\n\r\n    /// @dev The actual withdrawal logic shared by `withdraw`, `adminWithdraw`,\r\n    /// `slowWithdraw`. The specified amount is deducted from the `_withdrawer`'s\r\n    /// contract balance and transferred to the external `_receivingAddress`,\r\n    /// and the specified withdrawal fee will be deducted from the `_withdrawer`'s\r\n    /// balance.\r\n    function _withdraw(\r\n        address _withdrawer,\r\n        address payable _receivingAddress,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        address _feeAssetId,\r\n        uint256 _feeAmount,\r\n        uint256 _nonce\r\n    )\r\n        private\r\n    {\r\n        // Error code 34: _withdraw, invalid withdrawal amount\r\n        require(_amount > 0, \"34\");\r\n\r\n        _validateAddress(_receivingAddress);\r\n\r\n        _decreaseBalance(\r\n            _withdrawer,\r\n            _assetId,\r\n            _amount,\r\n            REASON_WITHDRAW,\r\n            _nonce\r\n        );\r\n\r\n        _increaseBalance(\r\n            operator,\r\n            _feeAssetId,\r\n            _feeAmount,\r\n            REASON_WITHDRAW_FEE_RECEIVE,\r\n            _nonce\r\n        );\r\n\r\n        uint256 withdrawAmount;\r\n\r\n        if (_feeAssetId == _assetId) {\r\n            withdrawAmount = _amount.sub(_feeAmount);\r\n        } else {\r\n            _decreaseBalance(\r\n                _withdrawer,\r\n                _feeAssetId,\r\n                _feeAmount,\r\n                REASON_WITHDRAW_FEE_GIVE,\r\n                _nonce\r\n            );\r\n            withdrawAmount = _amount;\r\n        }\r\n\r\n        if (_assetId == ETHER_ADDR) {\r\n            _receivingAddress.transfer(withdrawAmount);\r\n            return;\r\n        }\r\n\r\n        Utils.transferTokensOut(\r\n            _receivingAddress,\r\n            _assetId,\r\n            withdrawAmount\r\n        );\r\n    }\r\n\r\n    /// @dev Creates a hash key for a swap using the swap's parameters\r\n    /// @param _addresses[0] Address of the user making the swap\r\n    /// @param _addresses[1] Address of the user taking the swap\r\n    /// @param _addresses[2] Contract address of the asset to swap\r\n    /// @param _addresses[3] Contract address of the fee asset\r\n    /// @param _values[0] The number of tokens to be transferred\r\n    /// @param _values[1] The time in epoch seconds after which the swap will become cancellable\r\n    /// @param _values[2] The number of tokens to pay as fees to the operator\r\n    /// @param _values[3] The swap nonce to prevent replay attacks\r\n    /// @param _hashedSecret The hash of the secret decided by the maker\r\n    /// @return The hash key of the swap\r\n    function _hashSwap(\r\n        address[4] memory _addresses,\r\n        uint256[4] memory _values,\r\n        bytes32 _hashedSecret\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(\r\n            SWAP_TYPEHASH,\r\n            _addresses[0], // maker\r\n            _addresses[1], // taker\r\n            _addresses[2], // assetId\r\n            _values[0], // amount\r\n            _hashedSecret, // hashedSecret\r\n            _values[1], // expiryTime\r\n            _addresses[3], // feeAssetId\r\n            _values[2], // feeAmount\r\n            _values[3] // nonce\r\n        ));\r\n    }\r\n\r\n    /// @dev Checks if the `_nonce` had been previously taken.\r\n    /// To reduce gas costs, a single `usedNonces` value is used to\r\n    /// store the state of 256 nonces, using the formula:\r\n    /// nonceTaken = \"usedNonces[_nonce / 256] bit (_nonce % 256)\" != 0\r\n    /// For example:\r\n    /// nonce 0 taken: \"usedNonces[0] bit 0\" != 0 (0 / 256 = 0, 0 % 256 = 0)\r\n    /// nonce 1 taken: \"usedNonces[0] bit 1\" != 0 (1 / 256 = 0, 1 % 256 = 1)\r\n    /// nonce 2 taken: \"usedNonces[0] bit 2\" != 0 (2 / 256 = 0, 2 % 256 = 2)\r\n    /// nonce 255 taken: \"usedNonces[0] bit 255\" != 0 (255 / 256 = 0, 255 % 256 = 255)\r\n    /// nonce 256 taken: \"usedNonces[1] bit 0\" != 0 (256 / 256 = 1, 256 % 256 = 0)\r\n    /// nonce 257 taken: \"usedNonces[1] bit 1\" != 0 (257 / 256 = 1, 257 % 256 = 1)\r\n    /// @param _nonce The nonce to check\r\n    /// @return Whether the nonce has been taken\r\n    function _nonceTaken(uint256 _nonce) private view returns (bool) {\r\n        uint256 slotData = _nonce.div(256);\r\n        uint256 shiftedBit = uint256(1) << _nonce.mod(256);\r\n        uint256 bits = usedNonces[slotData];\r\n\r\n        // The check is for \"!= 0\" instead of \"== 1\" because the shiftedBit is\r\n        // not at the zero'th position, so it would require an additional\r\n        // shift to compare it with \"== 1\"\r\n        return bits & shiftedBit != 0;\r\n    }\r\n\r\n    /// @dev Sets the corresponding `_nonce` bit to 1.\r\n    /// An error will be raised if the corresponding `_nonce` bit was\r\n    /// previously set to 1.\r\n    /// See `_nonceTaken` for details on calculating the corresponding `_nonce` bit.\r\n    /// @param _nonce The nonce to mark\r\n    function _markNonce(uint256 _nonce) private {\r\n        // Error code 35: _markNonce, nonce cannot be zero\r\n        require(_nonce != 0, \"35\");\r\n\r\n        uint256 slotData = _nonce.div(256);\r\n        uint256 shiftedBit = 1 << _nonce.mod(256);\r\n        uint256 bits = usedNonces[slotData];\r\n\r\n        // Error code 36: _markNonce, nonce has already been marked\r\n        require(bits & shiftedBit == 0, \"36\");\r\n\r\n        usedNonces[slotData] = bits | shiftedBit;\r\n    }\r\n\r\n    /// @dev Validates that the specified `_hash` was signed by the specified `_user`.\r\n    /// This method supports the EIP712 specification, the older Ethereum\r\n    /// signed message specification is also supported for backwards compatibility.\r\n    /// @param _hash The original hash that was signed by the user\r\n    /// @param _user The user who signed the hash\r\n    /// @param _v The `v` component of the `_user`'s signature\r\n    /// @param _r The `r` component of the `_user`'s signature\r\n    /// @param _s The `s` component of the `_user`'s signature\r\n    /// @param _prefixed If true, the signature will be verified\r\n    /// against the Ethereum signed message specification instead of the\r\n    /// EIP712 specification\r\n    function _validateSignature(\r\n        bytes32 _hash,\r\n        address _user,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s,\r\n        bool _prefixed\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        Utils.validateSignature(\r\n            _hash,\r\n            _user,\r\n            _v,\r\n            _r,\r\n            _s,\r\n            _prefixed\r\n        );\r\n    }\r\n\r\n    /// @dev A utility method to increase the balance of a user.\r\n    /// A corressponding `BalanceIncrease` event will also be emitted.\r\n    /// @param _user The address to increase balance for\r\n    /// @param _assetId The asset's contract address\r\n    /// @param _amount The number of tokens to increase the balance by\r\n    /// @param _reasonCode The reason code for the `BalanceIncrease` event\r\n    /// @param _nonce The nonce for the `BalanceIncrease` event\r\n    function _increaseBalance(\r\n        address _user,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        uint256 _reasonCode,\r\n        uint256 _nonce\r\n    )\r\n        private\r\n    {\r\n        if (_amount == 0) { return; }\r\n        balances[_user][_assetId] = balances[_user][_assetId].add(_amount);\r\n\r\n        emit BalanceIncrease(\r\n            _user,\r\n            _assetId,\r\n            _amount,\r\n            _reasonCode,\r\n            _nonce\r\n        );\r\n    }\r\n\r\n    /// @dev A utility method to decrease the balance of a user.\r\n    /// A corressponding `BalanceDecrease` event will also be emitted.\r\n    /// @param _user The address to decrease balance for\r\n    /// @param _assetId The asset's contract address\r\n    /// @param _amount The number of tokens to decrease the balance by\r\n    /// @param _reasonCode The reason code for the `BalanceDecrease` event\r\n    /// @param _nonce The nonce for the `BalanceDecrease` event\r\n    function _decreaseBalance(\r\n        address _user,\r\n        address _assetId,\r\n        uint256 _amount,\r\n        uint256 _reasonCode,\r\n        uint256 _nonce\r\n    )\r\n        private\r\n    {\r\n        if (_amount == 0) { return; }\r\n        balances[_user][_assetId] = balances[_user][_assetId].sub(_amount);\r\n\r\n        emit BalanceDecrease(\r\n            _user,\r\n            _assetId,\r\n            _amount,\r\n            _reasonCode,\r\n            _nonce\r\n        );\r\n    }\r\n\r\n    /// @dev Ensures that `_address` is not the zero address\r\n    /// @param _address The address to check\r\n    function _validateAddress(address _address) private pure {\r\n        Utils.validateAddress(_address);\r\n    }\r\n\r\n    /// @dev A utility method to increase balances of multiple addresses.\r\n    /// A corressponding `Increment` event will also be emitted.\r\n    /// @param _increments An array of amounts to increase a user's balance by,\r\n    /// the corresponding user and assetId is referenced by\r\n    /// _addresses[index * 2] and _addresses[index * 2 + 1] respectively\r\n    /// @param _addresses An array of user asset pairs in the form of:\r\n    /// [\r\n    ///     user_1_address,\r\n    ///     asset_1_address,\r\n    ///     user_1_address,\r\n    ///     asset_2_address,\r\n    ///     user_2_address,\r\n    ///     asset_1_address,\r\n    ///     ...\r\n    /// ]\r\n    /// @param _static Indicates if the amount was pre-calculated or only known\r\n    /// at the time the transaction was executed\r\n    function _incrementBalances(\r\n        uint256[] memory _increments,\r\n        address[] memory _addresses,\r\n        uint256 _static\r\n    )\r\n        private\r\n    {\r\n        uint256 end = _increments.length;\r\n\r\n        for(uint256 i = 0; i < end; i++) {\r\n            uint256 increment = _increments[i];\r\n            if (increment == 0) { continue; }\r\n\r\n            balances[_addresses[i * 2]][_addresses[i * 2 + 1]] =\r\n            balances[_addresses[i * 2]][_addresses[i * 2 + 1]].add(increment);\r\n\r\n            emit Increment((i << 248) | (_static << 240) | increment);\r\n        }\r\n    }\r\n\r\n    /// @dev A utility method to decrease balances of multiple addresses.\r\n    /// A corressponding `Decrement` event will also be emitted.\r\n    /// @param _decrements An array of amounts to decrease a user's balance by,\r\n    /// the corresponding user and assetId is referenced by\r\n    /// _addresses[index * 2] and _addresses[index * 2 + 1] respectively\r\n    /// @param _addresses An array of user asset pairs in the form of:\r\n    /// [\r\n    ///     user_1_address,\r\n    ///     asset_1_address,\r\n    ///     user_1_address,\r\n    ///     asset_2_address,\r\n    ///     user_2_address,\r\n    ///     asset_1_address,\r\n    ///     ...\r\n    /// ]\r\n    function _decrementBalances(\r\n        uint256[] memory _decrements,\r\n        address[] memory _addresses\r\n    )\r\n        private\r\n    {\r\n        uint256 end = _decrements.length;\r\n        for(uint256 i = 0; i < end; i++) {\r\n            uint256 decrement = _decrements[i];\r\n            if (decrement == 0) { continue; }\r\n\r\n            balances[_addresses[i * 2]][_addresses[i * 2 + 1]] =\r\n            balances[_addresses[i * 2]][_addresses[i * 2 + 1]].sub(decrement);\r\n\r\n            emit Decrement(i << 248 | decrement);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenListAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spenderListAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"offerHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cancellableAt\",\"type\":\"uint256\"}],\"name\":\"AnnounceCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawableAt\",\"type\":\"uint256\"}],\"name\":\"AnnounceWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reason\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"BalanceDecrease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reason\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"BalanceIncrease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"Decrement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"Increment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"offerHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SlowCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SlowWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenFallback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"assetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensReceived\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"OFFER_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SWAP_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAW_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dapp\",\"type\":\"address\"}],\"name\":\"addMarketDapp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"adminAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_offerAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wantAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wantAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_offerNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectedAvailableAmount\",\"type\":\"uint256\"}],\"name\":\"adminCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminState\",\"outputs\":[{\"internalType\":\"enum BrokerV2.AdminState\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_withdrawer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_offerAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wantAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wantAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_offerNonce\",\"type\":\"uint256\"}],\"name\":\"announceCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"announceWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"atomicSwaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[4]\",\"name\":\"_addresses\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[4]\",\"name\":\"_values\",\"type\":\"uint256[4]\"},{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_cancelFeeAmount\",\"type\":\"uint256\"}],\"name\":\"cancelSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancellationAnnouncements\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[4]\",\"name\":\"_addresses\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[4]\",\"name\":\"_values\",\"type\":\"uint256[4]\"},{\"internalType\":\"bytes32[3]\",\"name\":\"_hashes\",\"type\":\"bytes32[3]\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_prefixedSignature\",\"type\":\"bool\"}],\"name\":\"createSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[4]\",\"name\":\"_addresses\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[4]\",\"name\":\"_values\",\"type\":\"uint256[4]\"},{\"internalType\":\"bytes32\",\"name\":\"_hashedSecret\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_preimage\",\"type\":\"bytes\"}],\"name\":\"executeSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"markNonce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"marketDapps\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"networkTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"nonceTaken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"offers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeMarketDapp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum BrokerV2.AdminState\",\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"setAdminState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"setSlowCancelDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"setSlowWithdrawDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"enum BrokerV2.State\",\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"setState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_offerAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wantAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wantAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_offerNonce\",\"type\":\"uint256\"}],\"name\":\"slowCancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"slowCancelDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_withdrawer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"slowWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"slowWithdrawDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"spendFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"spenderList\",\"outputs\":[{\"internalType\":\"contract SpenderList\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum BrokerV2.State\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenList\",\"outputs\":[{\"internalType\":\"contract TokenList\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokensReceived\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"trade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_dapp\",\"type\":\"address\"}],\"name\":\"updateMarketDapp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_withdrawer\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_receivingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_assetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_prefixedSignature\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawalAnnouncements\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BrokerV2", "CompilerVersion": "v0.5.12+commit.7709ece9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c860598a9a38eff76dbbbe67fdc1b7975c0c17bd000000000000000000000000dad636e070baa6d9484eee6a2452557833862c03", "EVMVersion": "Default", "Library": "Utils:d6e266d0221a2e7909fb7f9fd45a84d217e909e7", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0xd6e266d0221a2e7909fb7f9fd45a84d217e909e7", "SwarmSource": "bzzr://8320f1a86db0d7f110c710dd3181db0600eca41d862c7c9460c632f3e17f7ed9"}