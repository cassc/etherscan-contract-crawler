// SPDX-License-Identifier: BUSL-1.1
pragma solidity 0.8.2;

import { AccessControl } from "AccessControl.sol";
import { Address } from "Address.sol";
import "Ownable.sol";
import "SafeERC20.sol";
import "ReentrancyGuard.sol";



/// @title XYDexAggregator helps swap assets through designated routes of pools stated in calls array
/// @notice Use `multiswap` to swap assets by `calls` array and receiver address
contract XYDexAggregator is AccessControl, ReentrancyGuard {

    using SafeERC20 for IERC20;

    /* ========== STRUCTURE ========== */

    // Call describes a swap for XYDexAggregator
    struct Call {
        // the contract to execute the swap
        address target;
        // prefix of the swap bytecode
        bytes prefix;
        // suffix of the swap bytecode
        bytes suffix;
        // from token address
        address fromToken;
        // to token address
        address toToken;
        // amount of the token to swap (optional, use non-zero value to specified amount to swap if needed)
        uint256 amountIn;
    }

    /* ========== STATE VARIABLES ========== */
    bytes32 public constant ROLE_OWNER = keccak256("ROLE_OWNER");
    bytes32 public constant ROLE_AGGREGATOR_ADAPTOR = keccak256("ROLE_AGGREGATOR_ADAPTOR");
    address public constant ETHER_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    // Store the whitelisted swap routers.
    mapping(address => bool) public routerWhitelist;

    receive() external payable {}

    /// @dev Constuctor sets deployer as owner. Also, owner is the admin of the role aggregator.
    constructor() {
        _setRoleAdmin(ROLE_OWNER, ROLE_OWNER);
        _setRoleAdmin(ROLE_AGGREGATOR_ADAPTOR, ROLE_OWNER);
        _setupRole(ROLE_OWNER, msg.sender);
    }

    /* ========== INTERNAL FUNCTIONS ========== */

    /// @notice Get balance of the desired account address of the given token
    /// @param token The token address to be checked
    /// @param account The address to be checked
    /// @return The token balance of the desired account address
    function uniBalanceOf(IERC20 token, address account) internal view returns (uint256) {
        if (address(token) == ETHER_ADDRESS) {
            return account.balance;
        } else {
            return token.balanceOf(account);
        }
    }

    /// @notice Infinite approval to spender address if needed
    /// @param token the token contract address to execute `approve` method
    /// @param spender the address allowed to spend
    function approveIfNeeded(IERC20 token, address spender) internal {
        if (address(token) != ETHER_ADDRESS && token.allowance(address(this), spender) == 0) {
            token.safeApprove(spender, 2**256 - 1);
        }
    }

    /* ========== WRITE FUNCTIONS ========== */

    /// @notice Set aggregatorAdaptor address.
    /// @param aggregatorAdaptor The adaptor address. This multicaller should only be used
    /// by `aggregatorAdaptor`.
    function setAggregatorAdaptor(address aggregatorAdaptor) external onlyRole(ROLE_OWNER) {
        require(Address.isContract(aggregatorAdaptor), "AggregatorAdaptor should be a contract");
        _setupRole(ROLE_AGGREGATOR_ADAPTOR, aggregatorAdaptor);
    }

    /// @notice Add/remove a swap router to/from the whitelist. It can only be called by the owner.
    /// @param router The swap router address.
    /// @param isAdding `True` if router is being added and `False` being removed.
    function setRouter(address router, bool isAdding) external onlyRole(ROLE_OWNER) {
        require(Address.isContract(router), "Router should be a contract");
        routerWhitelist[router] = isAdding;
        emit SetRouter(router, isAdding);
    }

    /// @notice Multi-swap through array of calls by sequence and then transfer final swapped token to receiver
    /// @dev Since the output amount of every swap will differ based on exchange conditions, the amount to swap
    /// of next `Call` needs dynamically changed based on the output of the previous swap. In order to support this,
    /// pre-generated bytecode only contains partial call signature excluding input amount param. The complete
    /// calldata will be packed in runtime.
    /// @param calls the array of calls to swap through different pools (See definition of `Call` in this file)
    /// @param receiver the address to receive final swapped token
    function multiswap(
        Call[] memory calls,
        address payable receiver
    )
        public
        payable
        onlyRole(ROLE_AGGREGATOR_ADAPTOR)
        nonReentrant
        returns (uint256 blockNumber, bytes[] memory returnData)
    {
        blockNumber = block.number;
        returnData = new bytes[](calls.length);

        require(calls.length > 0, "Invalid calls length");
        if (calls[0].fromToken == ETHER_ADDRESS) {
            require(msg.value == calls[0].amountIn, "Invalid msg.value");
        } else {
            IERC20(calls[0].fromToken).safeTransferFrom(msg.sender, address(this), calls[0].amountIn);
        }

        // `calls` contain only swap actions
        uint256 amountIn;
        for(uint256 i = 0; i < calls.length; i++) {
            // Check: call target must be a whitelisted swap router.
            require(routerWhitelist[calls[i].target], "ERR_ROUTER_NOT_IN_WHITELIST");

            approveIfNeeded(IERC20(calls[i].fromToken), calls[i].target);

            if (calls[i].amountIn > 0) {
                amountIn = calls[i].amountIn;
            }
            uint256 value = 0;
            bytes memory callData;
            if (calls[i].fromToken == ETHER_ADDRESS) {
                value = amountIn;
                callData = abi.encodePacked(calls[i].prefix, calls[i].suffix);
            } else {
                callData = abi.encodePacked(calls[i].prefix, amountIn, calls[i].suffix);
            }
            uint256 balance = uniBalanceOf(IERC20(calls[i].toToken), address(this));
            bytes memory ret = Address.functionCallWithValue(calls[i].target, callData, value, "Multicall multiswap: call failed");
            amountIn = uniBalanceOf(IERC20(calls[i].toToken), address(this)) - balance;
            returnData[i] = ret;
        }

        Call memory lastCall = calls[calls.length - 1];
        if (lastCall.toToken == ETHER_ADDRESS) {
            receiver.transfer(address(this).balance);
        } else {
            uint256 balance = IERC20(lastCall.toToken).balanceOf(address(this));
            IERC20(lastCall.toToken).safeTransfer(receiver, balance);
        }
    }

    /* ========== EVENTS ========== */

    event SetRouter(address indexed router, bool isAdding);
}