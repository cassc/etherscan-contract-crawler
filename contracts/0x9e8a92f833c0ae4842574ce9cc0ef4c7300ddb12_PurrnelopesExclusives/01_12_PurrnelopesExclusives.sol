/*
                              ▓▓█
                            ▒██▒▒█ 
                           █▓▓▓░▒▓▓     
                         ▒█▓▒█░▒▒▒█     
                        ▒█▒▒▒█▒▒▒▒▓▒    
 ▓▓▒░                  ▓█▒▒▒▓██▓▒░▒█    
 █▓▓██▓░              ▓█▒▒▒▒████▒▒▒█    
 ▓█▓▒▒▓██▓░          ▒█▒▒▒▒▒██▓█▓░░▓▒   
 ▓▒▓▒▒▒▒▒▓█▓░  ░▒▒▓▓██▒▒▒▒▒▒█████▒▒▒▓   
 ▓░█▒▒▒▒▒▒▒▓▓█▓█▓▓▓▓▒▒▒▒▒▒▒▒██▓██▒░▒█   
 ▓░▓█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓████▒▒▒█   
 ▓░▓██▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▓██░░░█   
 ▓░▓███▒▒▒▒▒▒▒▒▒▒▒▓█▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▒▓▓  
 ▒▒▒██▓▒▓█▓▒▒▒▒▒▒▒▓▒▒▒▒▒▒▓▓▓▒▒▒▒▒▒▒▓▒█  
  ▓▒█▓▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒▒▓█▓▓▓▓█▓▒▒▒▒▒▒▒▓▒ 
  ▓▒█▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓      ▓█▓▒▒▒▒▒▓█ 
  ▒▒▓▒▒▒▓▓▓▒▒▒▒▒▒▒▒▒▓▓   ░▓▓   █▓▒▒▒▒▒█ 
   █▒▒▓▓▓▒▒▓▓▒▒▒▒▒▒▓▓   █████▓  █▓▒▒▒▒▓▒
   ▓▓█▒     ▒▓▒▒▒▒▒█   ░██████  ░█▒▒▒▒▓▓
   ▓█▒  ▒███ ▒▓▒▒▒▒█    ██████   ▓▒▒▒▒▒▓
   ██   █████ █▒▒▒▒█     ███▓    ▓▓▒▒▒▒▓
   █▓   █████ ▒▓▒▒▒█             █▓▓▓▒▒▓
   █▓   ░███  ░▓▒▒▒▓█          ░█▓▒▒▒▓▒▓
   ██         ▒▓▒▒▒▒▓▓      ░▒▓█▓    ░▓▓
   ▓█░        █▓██▓▒▒▓█▓▓▓▓██▓▓▒▓▒░░▒▓▒▓
   ▒██░      ▓▒███▓▒▒▒▒▓▓▓▓▒▒▒▒▒▒▓▓▓▓▒▓ 
    █▓█▓▓▒▒▓█▓▒░██▒▒▓▓█▓▒▒▒▒▒▒▒▒▒▒▒▒▓▓█▒
    ▓ ░▓▓▓▓▓▒▓▓▓▓▒▓▓▓▒▓▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▓▓
    ▒▒▒▓▒▒▒▒▒▒▓█░ ░░░ ▓▓▒▒▒▒▒▒▒▒▒▒▒▓██▓▒
     █▓▒▒▒▒▒▒▒▒▓▓ ░░░ ▓▓▒▒▒▒▒▒▒▒▒▓▓▓▒▒▓▒
      ██▓▓▒▒▒▒▒▒█▒░░░░█▒▒▒▒▒▒▒▒▓█▓▓▒▒▒▒▒
       ▒██▓▓▒▒▒▒▒█▓▒▒▓▒▒▒▒▒▒▓███▓▒▒▒▒▒▓▓
          ░▒▓▓▓▓▒▒▓▓▓▓▓▓████▓▓█▒▒▒▒▒▓▓█░
████████████████████████████████████████████████████████████████████████
█▄─▄▄─█▄─██─▄█▄─▄▄▀█▄─▄▄▀█▄─▀█▄─▄█▄─▄▄─█▄─▄███─▄▄─█▄─▄▄─█▄─▄▄─█─▄▄▄▄████
██─▄▄▄██─██─███─▄─▄██─▄─▄██─█▄▀─███─▄█▀██─██▀█─██─██─▄▄▄██─▄█▀█▄▄▄▄─████
█▄▄▄████▄▄▄▄██▄▄█▄▄█▄▄█▄▄█▄▄▄██▄▄█▄▄▄▄▄█▄▄▄▄▄█▄▄▄▄█▄▄▄███▄▄▄▄▄█▄▄▄▄▄████
████████████████████████████████████████████████████████████████████████
█─▄▄▄─█─▄▄─█▄─██─▄█▄─▀█▄─▄█─▄─▄─█▄─▄▄▀█▄─█─▄███─▄▄▄─█▄─▄███▄─██─▄█▄─▄─▀█
█─███▀█─██─██─██─███─█▄▀─████─████─▄─▄██▄─▄████─███▀██─██▀██─██─███─▄─▀█
█▄▄▄▄▄█▄▄▄▄██▄▄▄▄██▄▄▄██▄▄██▄▄▄██▄▄█▄▄██▄▄▄████▄▄▄▄▄█▄▄▄▄▄██▄▄▄▄██▄▄▄▄██*/

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import './ERC721A.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";


/*
# python - please copy/paste, change IPFS_HASH and run to prove provenenance

import requests
import hashlib

FP = 'https://ipfs.io/ipfs/IPFS_HASH/'
PH = 'b4a994a127f3cedd3c96c9bf0db5cd0167d6c6da2c580ceb969b2b103777eb01'
s = hashlib.sha3_256()

def h(path, index, total):
    found = False
    while not found:
        try:
            content = requests.get(path).content
            print(f'getting {index}/{total}')
            s.update(content)           
            time.sleep(1)
            found = "<head><title>" not in str(content)
            if found:
                return s.hexdigest()
            else:
                time.sleep(3)
        except:
            pass


s.update("".join([h(f'{FP}/{i}.png', i) for i in range(0, 10000)]).encode('utf-8'))
print(f'provenance hash is {s.hexdigest()}')
print(f'provenance matches - {s.hexdigest() == PH}')
*/

contract PurrnelopesExclusives is ERC721A, Ownable, VRFConsumerBase{
    using SafeMath for uint256;
    using Strings for uint256;

    string public constant PROVENANCE = 'b4a994a127f3cedd3c96c9bf0db5cd0167d6c6da2c580ceb969b2b103777eb01';
    uint256 public constant MaxSupply = 10000;

    string public BaseHash = '';
    string public PlaceholderHash = 'QmSawfWXzswsgWt3soD421NHeeS6aw9fa2NKCQBAtiiNZt'; // << pre-reveal hash
    bytes32[3] public MerkleRoot;


    bool public SaleOpen;
    

    uint256 public UnitPrice = 0.1 ether;

    
    uint256 public StartingIndex = MaxSupply;

    bytes32 internal vrfRequestId;
    bytes32 internal keyHash;
    uint256 internal fee;

    uint256 public CurrentPhase;
    uint256[3] MaxMintPerPhase;
    uint256 public constant MaxPublicMint = 3;

    mapping(address => mapping(uint256 => uint256)) public WhitelistMinted;

    constructor() ERC721A("Purrnelopes Exclusives", "PE") 
                  VRFConsumerBase(
           0xf0d54349aDdcf704F77AE15b96510dEA15cb7952, 
            0x514910771AF9Ca656af840dff83E8264EcF986CA  
            /* 0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B,// VRF Coordinator
            0x01BE23585060835E02B77ef475b0Cc51aA1e0709// LINK Token */
    ) {
        keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445; //0x2ed0feb3e7fd2022120aa84fab1945545a9f2ffc9076fd6156fa96eaff4c1311
        fee = 2 ether; // 2 LINK (Varies by network)
        MaxMintPerPhase = [3, 3, 3];



    }

    function devMint(uint256 _quantity, address _addr) public onlyOwner{
        require(_quantity.add(totalSupply()) <= MaxSupply, "sale closed");

        _mint(_addr, _quantity);
    }

    function setKey(bytes32 _key) public onlyOwner {
        keyHash = _key;
    }

    function setFee(uint256 _fee) public onlyOwner {
        fee = _fee;
    }

    function setBaseHash(string calldata _hash) public onlyOwner {
        BaseHash = _hash;
    }

    function setPlaceholderHash(string calldata _hash) public onlyOwner {
        PlaceholderHash = _hash;
    }

    function setMerkleRoot(bytes32 _root, uint256 _phase) public onlyOwner {
        MerkleRoot[_phase] = _root;
    }

    function PublicSaleOpen() public returns(bool){
        return CurrentPhase == 2 && SaleOpen;
    }

    function toggleSaleOpen() public onlyOwner {

        SaleOpen = !SaleOpen;
    }


    function setUnitPrice(uint256 _priceInWei) public onlyOwner{
        UnitPrice = _priceInWei;
    }

    function _baseURI() internal view override returns (string memory) {
        return string(abi.encodePacked('ipfs://', BaseHash, '/'));
    }

    function incrementPhase() external onlyOwner {
        CurrentPhase = CurrentPhase + 1;
    }

    function publicMint(bytes32[] calldata _merkleProof, uint256 _quantity) payable public {
        require(SaleOpen, "sale not open yet");
        require(msg.value == _quantity.mul(UnitPrice), "incorrect ether");
        require(_quantity.add(totalSupply()) <= MaxSupply, "sale closed");
        require(_quantity <= MaxPublicMint, "too many");
        
        if (CurrentPhase != 2) {
            require(MaxMintPerPhase[CurrentPhase] >= _quantity.add(WhitelistMinted[msg.sender][CurrentPhase]), "too many");
            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
            require(MerkleProof.verify(_merkleProof, MerkleRoot[CurrentPhase], leaf), "not authorised");
            WhitelistMinted[msg.sender][CurrentPhase] += _quantity;
        }
        _mint(msg.sender, _quantity);
    }

    function revealCollection(string memory _hash) public {
        require(StartingIndex == MaxSupply, "StartingIndex already set");
        BaseHash = _hash;
        vrfRequestId = requestRandomness(keyHash, fee);
    }

    function tokenURI(uint256 tokenId) public view override returns(string memory) {
        require(_exists(tokenId), "token does not exist");
        string memory baseURI = _baseURI();

        if (StartingIndex == MaxSupply) {
            return string(abi.encodePacked('ipfs://', PlaceholderHash));
        } else {
            uint256 id = tokenId.add(StartingIndex) % MaxSupply;
            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id.toString())) : "";
        }
    }

    function remainingToMint(bytes32[] calldata _merkleProof, address _addr) public view returns(uint256) {
        bytes32 leaf = keccak256(abi.encodePacked(_addr));
        if (MerkleProof.verify(_merkleProof, MerkleRoot[CurrentPhase], leaf) && CurrentPhase != 2) {
            return MaxMintPerPhase[CurrentPhase] - WhitelistMinted[_addr][CurrentPhase];
        }
        else{
            return CurrentPhase == 2 ? MaxPublicMint : 0;
        }
    }

    function withdraw() public onlyOwner {
		uint256 balance = address(this).balance;
		payable(msg.sender).transfer(balance);

	}

    function withdrawTokens(IERC20 token) public onlyOwner {
		require(address(token) != address(0));
		uint256 balance = token.balanceOf(address(this));
		token.transfer(msg.sender, balance);
	}

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        require(StartingIndex == MaxSupply, "StartingIndex already set");
        require(vrfRequestId == requestId, "Chainlink VRF Request Id must match");
        StartingIndex = (randomness % MaxSupply);
    }

    function backupRandomness() public onlyOwner {
        require(StartingIndex == MaxSupply || block.chainid == 4, "StartingIndex already set");

        uint256 random = uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, msg.sender, block.number)));

        StartingIndex = (random % MaxSupply);
    }


}