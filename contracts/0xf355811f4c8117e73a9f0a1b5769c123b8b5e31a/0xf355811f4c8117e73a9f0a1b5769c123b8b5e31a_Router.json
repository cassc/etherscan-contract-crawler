{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UniswapFork/Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\n\\nimport './Interfaces/IRouter.sol';\\nimport '../Oracle/PIDController.sol';\\nimport '../XSD/XSDStablecoin.sol';\\nimport '../XSD/Pools/RewardManager.sol';\\nimport './BankXLibrary.sol';\\nimport '../Utils/Initializable.sol';\\nimport '../ERC20/IWETH.sol';\\nimport '../XSD/Pools/XSDWETHpool.sol';\\nimport '../XSD/Pools/BankXWETHpool.sol';\\n//swap first\\n//then burn 10% using different function maybe\\n//recalculate price\\n// do not burn uXSD if there is a deficit\\ncontract Router is IRouter, Initializable {\\n\\n    address public WETH;\\n    address public collateral_pool_address;\\n    address public XSDWETH_pool_address;\\n    address public BankXWETH_pool_address;\\n    address public reward_manager_address;\\n    address public arbitrage;\\n    address public bankx_address;\\n    address public xsd_address;\\n    address public treasury;\\n    address public smartcontract_owner;\\n    uint public last_called;\\n    uint public pid_cooldown;\\n    bool public swap_paused;\\n    bool public liquidity_paused;\\n    XSDStablecoin private XSD;\\n    RewardManager private reward_manager;\\n    PIDController private pid_controller;\\n    modifier ensure(uint deadline) {\\n        require(deadline >= block.timestamp, 'BankXRouter: EXPIRED');\\n        _;\\n    }\\n\\n    function initialize(address _bankx_address, address _xsd_address,address _XSDWETH_pool, address _BankXWETH_pool,address _collateral_pool,address _reward_manager_address,address _pid_address,uint _pid_cooldown,address _treasury, address _smartcontract_owner,address _WETH) public initializer {\\n        require((_bankx_address != address(0))\\n        &&(_xsd_address != address(0))\\n        &&(_XSDWETH_pool != address(0))\\n        &&(_BankXWETH_pool != address(0))\\n        &&(_collateral_pool != address(0))\\n        &&(_treasury != address(0))\\n        &&(_pid_address != address(0))\\n        &&(_pid_cooldown != 0)\\n        &&(_smartcontract_owner != address(0))\\n        &&(_WETH != address(0)), \\\"Zero address detected\\\");\\n        bankx_address = _bankx_address;\\n        xsd_address = _xsd_address;\\n        XSDWETH_pool_address = _XSDWETH_pool;\\n        BankXWETH_pool_address = _BankXWETH_pool;\\n        collateral_pool_address = _collateral_pool;\\n        reward_manager_address = _reward_manager_address;\\n        reward_manager = RewardManager(_reward_manager_address);\\n        pid_controller = PIDController(_pid_address);\\n        pid_cooldown = _pid_cooldown;\\n        XSD = XSDStablecoin(_xsd_address);\\n        treasury = _treasury;\\n        WETH = _WETH;\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    receive() external payable {\\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n    // add a variable that keeps track of 10% swap burn.\\n    // **** ADD LIQUIDITY ****\\n    //creator may add XSD/BankX to their respective pools via this function\\n    function creatorProvideLiquidity(address pool) internal  {\\n        if(pool == XSDWETH_pool_address){\\n            reward_manager.creatorProvideXSDLiquidity();\\n        }\\n        else if(pool == BankXWETH_pool_address){\\n            reward_manager.creatorProvideBankXLiquidity();\\n        }\\n    }\\n\\n    function userProvideLiquidity(address pool, address sender) internal  {\\n        if(pool == XSDWETH_pool_address){\\n            reward_manager.userProvideXSDLiquidity(sender);\\n        }\\n        else if(pool == BankXWETH_pool_address){\\n            reward_manager.userProvideBankXLiquidity(sender);\\n        }\\n    }\\n\\n    function refreshPID() internal{\\n        if(block.timestamp>(last_called+pid_cooldown)){\\n            pid_controller.systemCalculations();\\n            last_called = block.timestamp;\\n        }\\n    }\\n\\n    function creatorAddLiquidityTokens(\\n        address tokenB,\\n        uint amountB\\n    ) public override {\\n        require(msg.sender == treasury || msg.sender == smartcontract_owner, \\\"ONLY TREASURY & SMARTCONTRACT OWNER\\\");\\n        require(tokenB == xsd_address || tokenB == bankx_address, \\\"token address is invalid\\\");\\n        require(amountB>0, \\\"Please enter a valid amount\\\");\\n        if(tokenB == xsd_address){\\n            TransferHelper.safeTransferFrom(tokenB, msg.sender, XSDWETH_pool_address, amountB);\\n            reward_manager.creatorProvideXSDLiquidity();\\n    }\\n    else if(tokenB == bankx_address){\\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, BankXWETH_pool_address, amountB);\\n        reward_manager.creatorProvideBankXLiquidity();\\n    }\\n    }\\n\\n    function creatorAddLiquidityETH(\\n        address pool\\n    ) external payable override {\\n        require(msg.sender == treasury || msg.sender == smartcontract_owner, \\\"ONLY TREASURY & SMARTCONTRACT OWNER\\\");\\n        require(pool == XSDWETH_pool_address || pool == BankXWETH_pool_address, \\\"Pool address is invalid\\\");\\n        require(msg.value>0,\\\"Please enter a valid amount\\\");\\n        IWETH(WETH).deposit{value: msg.value}();\\n        assert(IWETH(WETH).transfer(pool, msg.value));\\n        creatorProvideLiquidity(pool);\\n    }\\n\\n    function userAddLiquidityETH(\\n        address pool\\n    ) external  payable override{\\n        require(pool == XSDWETH_pool_address || pool == BankXWETH_pool_address || pool == collateral_pool_address, \\\"Pool address is not valid\\\");\\n        require(!liquidity_paused, \\\"Liquidity providing has been paused\\\");\\n        IWETH(WETH).deposit{value: msg.value}();\\n        assert(IWETH(WETH).transfer(pool, msg.value));\\n        if(pool==collateral_pool_address){\\n            reward_manager.userProvideCollatPoolLiquidity(msg.sender, msg.value);\\n        }\\n        else{\\n            userProvideLiquidity(pool, msg.sender);\\n        }\\n    }\\n\\n    function userRedeemLiquidity(address pool) external override {\\n        if(pool == XSDWETH_pool_address){\\n            reward_manager.LiquidityRedemption(pool,msg.sender);\\n        }\\n        else if(pool == BankXWETH_pool_address){\\n            reward_manager.LiquidityRedemption(pool,msg.sender);\\n        }\\n        else if (pool == collateral_pool_address){\\n            reward_manager.LiquidityRedemption(pool,msg.sender);\\n        }\\n    }\\n\\n    // **** SWAP ****\\n    function swapETHForXSD(uint amountOut)\\n        external\\n        payable\\n        override\\n    {\\n        require(!swap_paused, \\\"Swaps have been paused\\\");\\n        (uint reserveA, uint reserveB, ) = IXSDWETHpool(XSDWETH_pool_address).getReserves();\\n        uint amounts = BankXLibrary.quote(msg.value, reserveB, reserveA);\\n        require(amounts >= amountOut, 'BankXRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        IWETH(WETH).deposit{value: msg.value}();\\n        assert(IWETH(WETH).transfer(XSDWETH_pool_address, msg.value));\\n        IXSDWETHpool(XSDWETH_pool_address).swap(amountOut, 0, msg.sender);\\n        refreshPID();\\n    }\\n\\n    function swapXSDForETH(uint amountOut, uint amountInMax)\\n        external\\n        override\\n    {\\n        require(!swap_paused, \\\"Swaps have been paused\\\");\\n        (uint reserveA, uint reserveB, ) = IXSDWETHpool(XSDWETH_pool_address).getReserves();\\n        uint amounts = BankXLibrary.quote(amountOut, reserveB, reserveA);\\n        require(amounts <= amountInMax, 'BankXRouter: EXCESSIVE_INPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            xsd_address, msg.sender, XSDWETH_pool_address, amountInMax\\n        );\\n        XSDWETHpool(XSDWETH_pool_address).swap(0, amountOut, address(this));\\n        IWETH(WETH).withdraw(amountOut);\\n        TransferHelper.safeTransferETH(msg.sender, amountOut);\\n        //burn xsd here \\n        if(XSD.totalSupply()-CollateralPool(payable(collateral_pool_address)).collat_XSD()>amountOut/10 && !pid_controller.bucket1()){\\n            XSD.burnpoolXSD(amountInMax/10);\\n        }\\n        refreshPID();\\n    }\\n\\n    function swapETHForBankX(uint amountOut)\\n        external\\n        override\\n        payable\\n    {\\n        require(!swap_paused, \\\"Swaps have been paused\\\");\\n        (uint reserveA, uint reserveB, ) = IBankXWETHpool(BankXWETH_pool_address).getReserves();\\n        uint amounts = BankXLibrary.quote(msg.value, reserveB, reserveA);\\n        require(amounts >= amountOut, 'BankXRouter: INSUFFICIENT_OUTPUT_AMOUNT');\\n        IWETH(WETH).deposit{value: msg.value}();\\n        assert(IWETH(WETH).transfer(BankXWETH_pool_address, msg.value));\\n        IBankXWETHpool(BankXWETH_pool_address).swap(amountOut, 0, msg.sender);\\n        refreshPID();\\n    }\\n\\n    function swapBankXForETH(uint amountOut, uint amountInMax)\\n        external\\n        override\\n    {\\n        require(!swap_paused, \\\"Swaps have been paused\\\");\\n        (uint reserveA, uint reserveB, ) = IBankXWETHpool(BankXWETH_pool_address).getReserves();\\n        uint amounts = BankXLibrary.quote(amountOut, reserveB, reserveA);\\n        require(amounts <= amountInMax, 'BankXRouter: EXCESSIVE_INPUT_AMOUNT');\\n        TransferHelper.safeTransferFrom(\\n            bankx_address, msg.sender, BankXWETH_pool_address, amountInMax\\n        );\\n        IBankXWETHpool(BankXWETH_pool_address).swap(0,amountOut, address(this));\\n        IWETH(WETH).withdraw(amountOut);\\n        TransferHelper.safeTransferETH(msg.sender, amountOut);\\n        if((BankXToken(bankx_address).totalSupply() - amountOut/10)>BankXToken(bankx_address).genesis_supply()){\\n            BankXToken(bankx_address).burnpoolBankX(amountOut/10);\\n        }\\n        refreshPID();\\n    }\\n\\n    function swapXSDForBankX(uint XSD_amount,address sender,uint256 slippage)\\n        external \\n        override\\n    {   //only msg.sender or arbitrage contract\\n        require(!swap_paused, \\\"Swaps have been paused\\\");\\n        require(msg.sender == sender || msg.sender == arbitrage, \\\"Router:UNVERIFIED ADDRESS\\\");\\n        (uint reserveA, uint reserveB, ) = IXSDWETHpool(XSDWETH_pool_address).getReserves();\\n        (uint reserve1, uint reserve2, ) = IBankXWETHpool(BankXWETH_pool_address).getReserves();\\n        uint ethamount = BankXLibrary.quote(XSD_amount, reserveA, reserveB);\\n        ethamount = ethamount - ((ethamount*slippage)/100);\\n        uint bankxamount = BankXLibrary.quote(ethamount, reserve2, reserve1);\\n        bankxamount = bankxamount - ((bankxamount*slippage)/100);\\n        TransferHelper.safeTransferFrom(\\n            xsd_address, sender, XSDWETH_pool_address, XSD_amount\\n        );\\n        IXSDWETHpool(XSDWETH_pool_address).swap(0, ethamount, BankXWETH_pool_address);\\n        IBankXWETHpool(BankXWETH_pool_address).swap(bankxamount,0,sender);\\n    }\\n\\n    function swapBankXForXSD(uint bankx_amount, address sender, uint256 slippage)\\n        external\\n        override\\n    {   \\n        require(!swap_paused, \\\"Swaps have been paused\\\");\\n        require(msg.sender == sender || msg.sender == arbitrage, \\\"Router:UNVERIFIED ADDRESS\\\");\\n        (uint reserveA, uint reserveB, ) = IXSDWETHpool(XSDWETH_pool_address).getReserves();\\n        (uint reserve1, uint reserve2, ) = IBankXWETHpool(BankXWETH_pool_address).getReserves();\\n        uint ethamount = BankXLibrary.quote(bankx_amount, reserve1, reserve2);\\n        ethamount = ethamount - ((ethamount*slippage)/100);\\n        uint xsdamount = BankXLibrary.quote(ethamount, reserveB, reserveA);\\n        xsdamount = xsdamount - ((xsdamount*slippage)/100);\\n        TransferHelper.safeTransferFrom(\\n            bankx_address, sender, BankXWETH_pool_address, bankx_amount\\n        );\\n        IBankXWETHpool(BankXWETH_pool_address).swap(0, ethamount, XSDWETH_pool_address);\\n        IXSDWETHpool(XSDWETH_pool_address).swap(xsdamount,0,sender);\\n    }\\n    \\n    function setSmartContractOwner(address _smartcontract_owner) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        require(msg.sender != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    function renounceOwnership() external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        smartcontract_owner = address(0);\\n    }\\n    \\n    // **** LIBRARY FUNCTIONS ****\\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure  returns (uint amountB) {\\n        return BankXLibrary.quote(amountA, reserveA, reserveB);\\n    }\\n\\n    function pauseSwaps() external {\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        swap_paused = !swap_paused;\\n    }\\n\\n    function pauseLiquidity() external {\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        liquidity_paused = !liquidity_paused;\\n    }\\n    \\n    \\n    function setBankXAddress(address _bankx_address) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        bankx_address = _bankx_address;\\n    }\\n\\n    function setXSDAddress(address _xsd_address) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        xsd_address = _xsd_address;\\n    }\\n\\n    function setXSDPoolAddress(address _XSDWETH_pool) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        XSDWETH_pool_address = _XSDWETH_pool;\\n    }\\n\\n    function setBankXPoolAddress(address _BankXWETH_pool) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        BankXWETH_pool_address = _BankXWETH_pool;\\n    }\\n\\n    function setCollateralPool(address _collateral_pool) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        collateral_pool_address = _collateral_pool;\\n    }\\n\\n    function setRewardManager(address _reward_manager_address) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        reward_manager_address = _reward_manager_address;\\n        reward_manager = RewardManager(_reward_manager_address);\\n    }\\n\\n    function setPIDController(address _pid_address, uint _pid_cooldown) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        pid_controller = PIDController(_pid_address);\\n        pid_cooldown = _pid_cooldown;\\n    }\\n\\n    function setArbitrageAddress(address _arbitrage) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        arbitrage = _arbitrage;\\n    }\\n}\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniswapFork/Interfaces/IRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\ninterface IRouter{\\n    function creatorAddLiquidityTokens(\\n        address tokenB,\\n        uint amountB\\n    ) external;\\n\\n    function creatorAddLiquidityETH(\\n        address pool\\n    ) external payable;\\n\\n    function userAddLiquidityETH(\\n        address pool\\n    ) external payable;\\n\\n    function userRedeemLiquidity(\\n        address pool\\n    ) external;\\n\\n    function swapETHForXSD(uint amountOut) external payable;\\n\\n    function swapXSDForETH(uint amountOut, uint amountInMax) external;\\n\\n    function swapETHForBankX(uint amountOut) external payable;\\n    \\n    function swapBankXForETH(uint amountOut, uint amountInMax) external;\\n\\n    function swapBankXForXSD(uint bankx_amount, address sender, uint256 slippage) external;\\n\\n    function swapXSDForBankX(uint XSD_amount, address sender, uint256 slippage) external;\\n}\"\r\n    },\r\n    \"contracts/Oracle/PIDController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../XSD/XSDStablecoin.sol';\\nimport \\\"../UniswapFork/BankXLibrary.sol\\\";\\nimport \\\"../XSD/Pools/CollateralPool.sol\\\";\\nimport \\\"../XSD/Pools/Interfaces/IBankXWETHpool.sol\\\";\\nimport \\\"../XSD/Pools/Interfaces/IXSDWETHpool.sol\\\";\\nimport \\\"../Utils/Initializable.sol\\\";\\nimport \\\"./Interfaces/BankXNFTInterface.sol\\\";\\nimport \\\"./Interfaces/ICD.sol\\\";\\n\\n\\ncontract PIDController is Initializable {\\n\\n    // Instances\\n    XSDStablecoin public XSD;\\n    BankXToken public BankX;\\n    CollateralPool public collateralpool;\\n\\n\\n    // XSD and BankX addresses\\n    address public xsdwethpool_address;\\n    address public bankxwethpool_address;\\n    address public collateralpool_address;\\n    address public smartcontract_owner;\\n    address public BankXNFT_address;\\n    address public cd_address;\\n    uint public NFT_timestamp;\\n    // Misc addresses\\n    address public reward_manager_address;\\n    address public WETH;\\n    // 6 decimals of precision\\n    uint256 public growth_ratio;\\n    uint256 public xsd_step;\\n    uint256 public GR_top_band;\\n    uint256 public GR_bottom_band;\\n\\n    // Time-related\\n    uint256 public internal_cooldown;\\n    uint256 public last_update;\\n    \\n    // Booleans\\n    bool public is_active;\\n    bool public use_growth_ratio;\\n    bool public collateral_ratio_paused;\\n    bool public FIP_6;\\n    bool public bucket1;\\n    bool public bucket2;\\n    bool public bucket3;\\n    \\n    //deficit related variables\\n    uint public diff1;\\n    uint public diff2;\\n    uint public diff3;\\n\\n    uint public timestamp1;\\n    uint public timestamp2;\\n    uint public timestamp3;\\n\\n    uint public amountpaid1;\\n    uint public amountpaid2;\\n    uint public amountpaid3;\\n\\n    //arbitrage relate variables\\n    uint256 public xsd_percent;\\n    uint256 public xsd_burnable_limit;\\n    uint256 public maxArbBurnAbove;\\n    uint256 public minArbBurnBelow;\\n\\n    uint256 public xsd_percentage_target;\\n    uint256 public bankx_percentage_target;\\n    uint256 public cd_allocated_supply;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyByOwner() {\\n        require(msg.sender == smartcontract_owner || msg.sender == reward_manager_address, \\\"Not owner or reward_manager\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    function initialize(address _xsd_contract_address,address _bankx_contract_address,address _xsd_weth_pool_address, address _bankx_weth_pool_address,address payable _collateralpool_contract_address,address _WETHaddress,address _smartcontract_owner,address _reward_manager_address, uint _xsd_percentage_target, uint _bankx_percentage_target) public initializer{\\n        require(\\n            (_xsd_contract_address != address(0))\\n            && (_bankx_contract_address != address(0))\\n            && (_xsd_weth_pool_address != address(0))\\n            && (_bankx_weth_pool_address != address(0))\\n            && (_collateralpool_contract_address != address(0))\\n            && (_WETHaddress != address(0))\\n            && (_reward_manager_address != address(0))\\n        , \\\"Zero address detected\\\"); \\n        xsdwethpool_address = _xsd_weth_pool_address;\\n        bankxwethpool_address = _bankx_weth_pool_address;\\n        smartcontract_owner = _smartcontract_owner;\\n        reward_manager_address = _reward_manager_address;\\n        xsd_step = 2500;\\n        collateralpool_address = _collateralpool_contract_address;\\n        collateralpool = CollateralPool(_collateralpool_contract_address);\\n        XSD = XSDStablecoin(_xsd_contract_address);\\n        BankX = BankXToken(_bankx_contract_address);\\n        WETH = _WETHaddress;\\n        xsd_percentage_target = _xsd_percentage_target;\\n        bankx_percentage_target = _bankx_percentage_target;\\n\\n        // Upon genesis, if GR changes by more than 1% percent, enable change of collateral ratio\\n        GR_top_band = 1000;\\n        GR_bottom_band = 1000; \\n        is_active = false;\\n    }\\n\\n    \\n\\n    //interest rate variable\\n    /* ========== PUBLIC MUTATIVE FUNCTIONS ========== */\\n    \\n    function systemCalculations() public {\\n    \\trequire(collateral_ratio_paused == false, \\\"Collateral Ratio has been paused\\\");\\n        uint256 time_elapsed = block.timestamp - last_update;\\n        require(time_elapsed >= internal_cooldown, \\\"internal cooldown not passed\\\");\\n        uint256 bankx_reserves = BankX.balanceOf(bankxwethpool_address);\\n        uint256 bankx_price = XSD.bankx_price();\\n        \\n        uint256 bankx_liquidity = bankx_reserves*bankx_price; // Has 6 decimals of precision\\n\\n        uint256 xsd_supply = XSD.totalSupply();\\n        \\n        // Get the XSD price\\n        uint256 xsd_price = XSD.xsd_price();\\n\\n        uint256 new_growth_ratio = (bankx_liquidity/(xsd_supply-collateralpool.collat_XSD())); // (E18 + E6) / E18\\n\\n        uint256 last_collateral_ratio = XSD.global_collateral_ratio();\\n        uint256 new_collateral_ratio = last_collateral_ratio;\\n        uint256 silver_price = (XSD.xag_usd_price()*(1e4))/(311035); //31.1034768\\n        uint256 XSD_top_band = silver_price + (xsd_percent*silver_price)/100;\\n        uint256 XSD_bottom_band = silver_price - (xsd_percent*silver_price)/100;\\n        xsd_burnable_limit = approximateXSD();\\n        // make the top band and bottom band a percentage of silver price.\\n\\n        if(FIP_6){\\n            require(xsd_price > XSD_top_band || xsd_price < XSD_bottom_band, \\\"Use PIDController when XSD is outside of peg\\\");\\n        }\\n\\n        if((NFT_timestamp == 0) || ((block.timestamp - NFT_timestamp)>43200)){\\n            BankXInterface(BankXNFT_address).updateTVLReached();\\n            NFT_timestamp = block.timestamp;\\n        }\\n\\n        // First, check if the price is out of the band\\n        if(xsd_price > XSD_top_band){\\n            new_collateral_ratio = last_collateral_ratio - xsd_step;\\n            maxArbBurnAbove = aboveThePeg();\\n        } else if (xsd_price < XSD_bottom_band){\\n            new_collateral_ratio = last_collateral_ratio + xsd_step;\\n            minArbBurnBelow = belowThePeg();\\n\\n        // Else, check if the growth ratio has increased or decreased since last update\\n        } else if(use_growth_ratio){\\n            if(new_growth_ratio > ((growth_ratio*(1e6 + GR_top_band))/1e6)){\\n                new_collateral_ratio = last_collateral_ratio - xsd_step;\\n            } else if (new_growth_ratio < (growth_ratio*(1e6 - GR_bottom_band)/1e6)){\\n                new_collateral_ratio = last_collateral_ratio + xsd_step;\\n            }\\n        }\\n\\n        growth_ratio = new_growth_ratio;\\n        last_update = block.timestamp;\\n\\n        // No need for checking CR under 0 as the last_collateral_ratio.sub(xsd_step) will throw \\n        // an error above in that case\\n        if(new_collateral_ratio > 1e6){\\n            new_collateral_ratio = 1e6;\\n        }\\n        incentiveChecker1();\\n        incentiveChecker2();\\n        incentiveChecker3();\\n        if(is_active){\\n            uint256 delta_collateral_ratio;\\n            if(new_collateral_ratio > last_collateral_ratio){\\n                delta_collateral_ratio = new_collateral_ratio - last_collateral_ratio;\\n                XSD.setPriceTarget(1000e6); // Set to high value to decrease CR\\n                emit XSDdecollateralize(new_collateral_ratio);\\n            } else if (new_collateral_ratio < last_collateral_ratio){\\n                delta_collateral_ratio = last_collateral_ratio - new_collateral_ratio;\\n                XSD.setPriceTarget(0); // Set to zero to increase CR\\n                emit XSDrecollateralize(new_collateral_ratio);\\n            }\\n\\n            XSD.setXSDStep(delta_collateral_ratio); // Change by the delta\\n            uint256 cooldown_before = XSD.refresh_cooldown(); // Note the existing cooldown period\\n            XSD.setRefreshCooldown(0); // Unlock the CR cooldown\\n            //refresh interest rate.\\n            XSD.refreshCollateralRatio(); // Refresh CR\\n\\n            // Reset params\\n            XSD.setXSDStep(0);\\n            XSD.setRefreshCooldown(cooldown_before); // Set the cooldown period to what it was before, or until next controller refresh\\n            //change price target to that of one ounce/gram of silver.\\n            XSD.setPriceTarget((XSD.xag_usd_price()*(1e4))/(311035));           \\n        }\\n    }\\n\\n    //checks the XSD liquidity pool for a deficit.\\n    //bucket and difference variables should return values only if changed.\\n    // difference is calculated only every week.\\n    function incentiveChecker1() internal{\\n        uint silver_price = (XSD.xag_usd_price()*(1e4))/(311035);\\n        uint XSDvalue = (XSD.totalSupply()*(silver_price))/(1e6);\\n        uint _reserve1;\\n        (,_reserve1,) = IXSDWETHpool(xsdwethpool_address).getReserves();\\n        uint reserve = (_reserve1*(XSD.eth_usd_price())*2)/(1e6);\\n        if(((block.timestamp - timestamp1)>=64800)||(amountpaid1 >= diff3)){\\n            timestamp1 = 0;\\n            bucket1 = false;\\n            diff1 = 0;\\n            amountpaid1 = 0;\\n        }\\n        if(timestamp1 == 0){\\n        if(reserve<((XSDvalue*xsd_percentage_target)/100)){\\n            bucket1 = true;\\n            diff1 = (((XSDvalue*xsd_percentage_target)/100)-reserve)/2;\\n            timestamp1 = block.timestamp;\\n        }\\n        }\\n    }\\n\\n    //checks the BankX liquidity pool for a deficit.\\n    //bucket and difference variables should return values only if changed.\\n    function incentiveChecker2() internal{\\n        cd_allocated_supply = ICD(cd_address).allocatedSupply();\\n        uint BankXvalue = (cd_allocated_supply*(XSD.bankx_price()))/(1e6);\\n        uint _reserve1;\\n        (, _reserve1,) = IBankXWETHpool(bankxwethpool_address).getReserves();\\n        uint reserve = (_reserve1*(XSD.eth_usd_price())*2)/(1e6);\\n        if(((block.timestamp - timestamp2)>=64800)|| (amountpaid2 >= diff2)){\\n            timestamp2 = 0;\\n            bucket2 = false;\\n            diff2 = 0;\\n            amountpaid2 = 0;\\n        }\\n        if(timestamp2 == 0){\\n        if(reserve<((BankXvalue*bankx_percentage_target)/100)){\\n            bucket2 = true;\\n            diff2 = (((BankXvalue*bankx_percentage_target)/100) - reserve)/2;\\n            timestamp2 = block.timestamp;\\n        }\\n        }\\n    }\\n\\n    //checks the Collateral pool for a deficit\\n    // return system collateral as a public global variable\\n    function incentiveChecker3() internal{\\n        uint silver_price = (XSD.xag_usd_price()*(1e4))/(311035);\\n        uint XSDvalue = (collateralpool.collat_XSD()*(silver_price))/(1e6);//use gram of silver price\\n        uint collatValue = collateralpool.collatDollarBalance();// eth value in the collateral pool\\n        XSDvalue = (XSDvalue * XSD.global_collateral_ratio())/(1e6);\\n        if(((block.timestamp-timestamp3)>=604800) || (amountpaid3 >= diff3)){\\n            timestamp3 = 0;\\n            bucket3 = false;\\n            diff3 = 0;\\n            amountpaid3 = 0;\\n        }\\n        if(timestamp3 == 0 && collatValue != 0){\\n        if((collatValue*400)<=(3*XSDvalue)){ //posted collateral - actual collateral <= 0.25% posted collateral\\n            bucket3 = true;\\n            diff3 = (3*XSDvalue) - (collatValue*400); \\n            timestamp3 = block.timestamp;\\n        }\\n        }\\n    }\\n\\n    //Essentially the value of both halves of the pool have to be the same:\\n    // XSD number * XSD USD price = ETH reserves * ETH USD Price\\n    // target XSD number = ETH reserves * ETH USD Price/ silver price\\n\\n    function approximateXSD() internal view returns(uint256 xsd_amount){\\n        (uint reserveA, uint reserveB,) = IXSDWETHpool(xsdwethpool_address).getReserves();\\n        uint silver_price = (XSD.xag_usd_price()*(1e4))/(311035);\\n        uint x = reserveB * XSD.eth_usd_price(); // precision of 1e6\\n        uint target = x/silver_price; //number of xsd we need\\n        if(target>reserveA)\\n            xsd_amount = target - reserveA;\\n        else\\n            xsd_amount = reserveA - target;\\n}\\n//burning BankX for XSD\\n//sol gives the maxXSD that can be minted\\nfunction aboveThePeg() internal view returns(uint256 sol){\\n    uint silver_price = (XSD.xag_usd_price()*(1e4))/(311035);\\n    (uint reserveA, uint reserveB,) = IXSDWETHpool(xsdwethpool_address).getReserves();\\n    sol = ((XSD.xsd_price()*XSD.eth_usd_price()*reserveB) - (reserveA*XSD.xsd_price()*silver_price))/((silver_price+XSD.xsd_price())*silver_price);\\n    if( sol > xsd_burnable_limit){\\n        sol = xsd_burnable_limit;\\n    }\\n}\\n\\n//burning XSD for BankX\\n// sol gives the maxXSD that can be burnt\\nfunction belowThePeg() internal view returns(uint256 sol){\\n    uint silver_price = (XSD.xag_usd_price()*(1e4))/(311035);\\n    (uint reserveA, uint reserveB,) = IXSDWETHpool(xsdwethpool_address).getReserves();\\n    sol = ((reserveA*XSD.xsd_price()*silver_price)-(XSD.xsd_price()*XSD.eth_usd_price()*reserveB))/((silver_price+XSD.xsd_price())*silver_price);\\n    if( sol > xsd_burnable_limit){\\n        sol = xsd_burnable_limit;\\n    }\\n}\\n\\n    //functions to change amountpaid variables\\n    function amountPaidXSDWETH(uint ethvalue) external {\\n        require(msg.sender == reward_manager_address, \\\"Only RewardManager can access this address\\\");\\n        amountpaid1 += ethvalue;\\n    }\\n\\n    function amountPaidBankXWETH(uint ethvalue) external {\\n        require(msg.sender == reward_manager_address, \\\"Only RewardManager can access this address\\\");\\n        amountpaid2 += ethvalue;\\n    }\\n    \\n    function amountPaidCollateralPool(uint ethvalue) external {\\n        require(msg.sender == reward_manager_address,\\\"Only RewardManager can access this address\\\");\\n        amountpaid3 += ethvalue;\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function activate(bool _state) external onlyByOwner {\\n        is_active = _state;\\n    }\\n\\n    function useGrowthRatio(bool _use_growth_ratio) external onlyByOwner {\\n        use_growth_ratio = _use_growth_ratio;\\n    }\\n\\n    // As a percentage added/subtracted from the previous; e.g. top_band = 4000 = 0.4% -> will decollat if GR increases by 0.4% or more\\n    function setGrowthRatioBands(uint256 _GR_top_band, uint256 _GR_bottom_band) external onlyByOwner {\\n        GR_top_band = _GR_top_band;\\n        GR_bottom_band = _GR_bottom_band;\\n    }\\n\\n    function setInternalCooldown(uint256 _internal_cooldown) external onlyByOwner {\\n        internal_cooldown = _internal_cooldown;\\n    }\\n\\n    function setXSDStep(uint256 _new_step) external onlyByOwner {\\n        xsd_step = _new_step;\\n    }\\n\\n    function setPriceBandPercentage(uint256 percent) external onlyByOwner {\\n        require(percent!=0,\\\"PID:Zero value detected\\\");\\n        xsd_percent = percent;\\n    }\\n\\n    function toggleCollateralRatio(bool _is_paused) external onlyByOwner {\\n    \\tcollateral_ratio_paused = _is_paused;\\n    }\\n\\n    function activateFIP6(bool _activate) external onlyByOwner {\\n        FIP_6 = _activate;\\n    }\\n\\n    function setSmartContractOwner(address _smartcontract_owner) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        require(msg.sender != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    function renounceOwnership() external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        smartcontract_owner = address(0);\\n    }\\n    \\n    function setXSDPoolAddress(address _xsd_weth_pool_address) external onlyByOwner{\\n        xsdwethpool_address = _xsd_weth_pool_address;\\n    }\\n\\n    function setBankXPoolAddress(address _bankx_weth_pool_address) external onlyByOwner{\\n        bankxwethpool_address = _bankx_weth_pool_address;\\n    }\\n    \\n    function setRewardManagerAddress(address _reward_manager_address) external onlyByOwner{\\n        reward_manager_address = _reward_manager_address;\\n    }\\n\\n    function setCollateralPoolAddress(address payable _collateralpool_contract_address) external onlyByOwner{\\n        collateralpool_address = _collateralpool_contract_address;\\n        collateralpool = CollateralPool(_collateralpool_contract_address);\\n    }\\n\\n    function setXSDAddress(address _xsd_contract_address) external onlyByOwner{\\n        XSD = XSDStablecoin(_xsd_contract_address);\\n    }\\n\\n    function setBankXAddress(address _bankx_contract_address) external onlyByOwner{\\n        BankX = BankXToken(_bankx_contract_address);\\n    }\\n\\n    function setWETHAddress(address _WETHaddress) external onlyByOwner{\\n        WETH = _WETHaddress;\\n    }\\n\\n    function setBankXNFTAddress(address _BankXNFT_address) external onlyByOwner{\\n        BankXNFT_address = _BankXNFT_address;\\n    }\\n\\n    function setCDAddress(address _cd_address) external onlyByOwner{\\n        cd_address = _cd_address;\\n    }\\n\\n    function setPercentageTarget(uint256 _xsd_percentage_target, uint256 _bankx_percentage_target) external onlyByOwner{\\n        xsd_percentage_target = _xsd_percentage_target;\\n        bankx_percentage_target = _bankx_percentage_target;\\n    }\\n\\n    /* ========== EVENTS ========== */  \\n    event XSDdecollateralize(uint256 new_collateral_ratio);\\n    event XSDrecollateralize(uint256 new_collateral_ratio);\\n}\"\r\n    },\r\n    \"contracts/XSD/XSDStablecoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../ERC20/ERC20Custom.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./Pools/CollateralPool.sol\\\";\\nimport \\\"./Pools/Interfaces/IBankXWETHpool.sol\\\";\\nimport \\\"./Pools/Interfaces/IXSDWETHpool.sol\\\";\\nimport \\\"../Oracle/ChainlinkETHUSDPriceConsumer.sol\\\";\\nimport \\\"../Oracle/ChainlinkXAGUSDPriceConsumer.sol\\\";\\n\\ncontract XSDStablecoin is ERC20Custom {\\n\\n    /* ========== STATE VARIABLES ========== */\\n    enum PriceChoice { XSD, BankX }\\n    ChainlinkETHUSDPriceConsumer private eth_usd_pricer;\\n    ChainlinkXAGUSDPriceConsumer private xag_usd_pricer;\\n    uint8 private eth_usd_pricer_decimals;\\n    uint8 private xag_usd_pricer_decimals;\\n    string public symbol;\\n    string public name;\\n    uint8 public constant decimals = 18;\\n    address public pid_address;\\n    address public treasury; \\n    address public collateral_pool_address;\\n    address public router;\\n    address public eth_usd_oracle_address;\\n    address public xag_usd_oracle_address;\\n    address public smartcontract_owner;\\n    uint256 public interest_rate;\\n    IBankXWETHpool private bankxEthPool;\\n    IXSDWETHpool private xsdEthPool;\\n    uint256 public cap_rate;\\n    uint256 public genesis_supply; \\n\\n    // The addresses in this array are added by the oracle and these contracts are able to mint xsd\\n    address[] public xsd_pools_array;\\n\\n    // Mapping is also used for faster verification\\n    mapping(address => bool) public xsd_pools; \\n\\n    // Constants for various precisions\\n    uint256 private constant PRICE_PRECISION = 1e6;\\n    \\n    uint256 public global_collateral_ratio; // 6 decimals of precision, e.g. 924102 = 0.924102\\n    uint256 public xsd_step; // Amount to change the collateralization ratio by upon refreshCollateralRatio()\\n    uint256 public refresh_cooldown; // Seconds to wait before being able to run refreshCollateralRatio() again\\n    uint256 public price_target; // The price of XSD at which the collateral ratio will respond to; this value is only used for the collateral ratio mechanism and not for minting and redeeming which are hardcoded at $1\\n    uint256 public price_band; // The bound above and below the price target at which the refreshCollateralRatio() will not change the collateral ratio\\n\\n    bool public collateral_ratio_paused = false;\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyPools() {\\n       require(xsd_pools[msg.sender] == true, \\\"Only xsd pools can call this function\\\");\\n        _;//check happens before the function is executed \\n    } \\n\\n    modifier onlyByOwner(){\\n        require(msg.sender == smartcontract_owner, \\\"You are not the owner\\\");\\n        _;\\n    }\\n    \\n    modifier onlyByOwnerPID() {\\n        require(msg.sender == smartcontract_owner || msg.sender == pid_address, \\\"You are not the owner or the pid controller\\\");\\n        _;\\n    }\\n\\n    modifier onlyByOwnerOrPool() {\\n        require(\\n            msg.sender == smartcontract_owner  \\n            || xsd_pools[msg.sender] == true, \\n            \\\"You are not the owner or a pool\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint256 _pool_amount,\\n        uint256 _genesis_supply,\\n        address _smartcontract_owner,\\n        address _treasury,\\n        uint256 _cap_rate\\n    ) {\\n        require((_smartcontract_owner != address(0))\\n                && (_treasury != address(0)), \\\"Zero address detected\\\"); \\n        name = _name;\\n        symbol = _symbol;\\n        genesis_supply = _genesis_supply + _pool_amount;\\n        treasury = _treasury;\\n        _mint(_smartcontract_owner, _pool_amount);\\n        _mint(treasury, _genesis_supply);\\n        smartcontract_owner = _smartcontract_owner;\\n        xsd_step = 2500; // 6 decimals of precision, equal to 0.25%\\n        global_collateral_ratio = 1000000; // XSD system starts off fully collateralized (6 decimals of precision)\\n        interest_rate = 52800; //interest rate starts off at 5%\\n        refresh_cooldown = 3600; // Refresh cooldown period is set to 1 hour (3600 seconds) at genesis\\n        price_target = 800000; // Change price target to 1 gram of silver\\n        price_band = 5000; // Collateral ratio will not adjust if 0.005 off target at genesis\\n        cap_rate = _cap_rate;// Maximum mint amount\\n    }\\n    /* ========== VIEWS ========== */\\n\\n    function pool_price(PriceChoice choice) internal view returns (uint256) {\\n        // Get the ETH / USD price first, and cut it down to 1e6 precision\\n        uint256 _eth_usd_price = (uint256(eth_usd_pricer.getLatestPrice())*PRICE_PRECISION)/(uint256(10) ** eth_usd_pricer_decimals);\\n        uint256 price_vs_eth = 0;\\n        uint256 reserve0;\\n        uint256 reserve1;\\n\\n        if (choice == PriceChoice.XSD) {\\n            (reserve0, reserve1, ) = xsdEthPool.getReserves();\\n            if(reserve0 == 0 || reserve1 == 0){\\n                return 1;\\n            }\\n            price_vs_eth = reserve0/(reserve1); // How much XSD if you put in 1 WETH\\n        }\\n        else if (choice == PriceChoice.BankX) {\\n            (reserve0, reserve1, ) = bankxEthPool.getReserves();\\n            if(reserve0 == 0 || reserve1 == 0){\\n                return 1;\\n            }\\n            price_vs_eth = reserve0/(reserve1);  // How much BankX if you put in 1 WETH\\n        }\\n        else revert(\\\"INVALID PRICE CHOICE. Needs to be either 0 (XSD) or 1 (BankX)\\\");\\n\\n        // Will be in 1e6 format\\n        return _eth_usd_price/price_vs_eth;\\n    }\\n\\n    \\n    //XSD price\\n    function xsd_price() public view returns (uint256) {\\n        return pool_price(PriceChoice.XSD);\\n    }\\n\\n    function bankx_price()  public view returns (uint256) {\\n        return pool_price(PriceChoice.BankX);\\n    }\\n\\n    function eth_usd_price() public view returns (uint256) {\\n        return (uint256(eth_usd_pricer.getLatestPrice())*PRICE_PRECISION)/(uint256(10) ** eth_usd_pricer_decimals);\\n    }\\n    //silver price\\n    function xag_usd_price() public view returns (uint256) {\\n        return (uint256(xag_usd_pricer.getLatestPrice())*PRICE_PRECISION)/(uint256(10) ** xag_usd_pricer_decimals);\\n    }\\n\\n    \\n    // This is needed to avoid costly repeat calls to different getter functions\\n    // It is cheaper gas-wise to just dump everything and only use some of the info\\n    function xsd_info() public view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\\n        return (\\n            pool_price(PriceChoice.XSD), // xsd_price()\\n            pool_price(PriceChoice.BankX), // bankx_price()\\n            totalSupply(), // totalSupply()\\n            global_collateral_ratio, // global_collateral_ratio()\\n            globalCollateralValue(), // globalCollateralValue\\n            (uint256(eth_usd_pricer.getLatestPrice())*PRICE_PRECISION)/(uint256(10) ** eth_usd_pricer_decimals) //eth_usd_price\\n        );\\n    }\\n\\n    // Iterate through all xsd pools and calculate all value of collateral in all pools globally \\n    function globalCollateralValue() public view returns (uint256) {\\n        uint256 collateral_amount = 0;\\n        collateral_amount = CollateralPool(payable(collateral_pool_address)).collatDollarBalance();\\n        return collateral_amount;\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n    \\n    // There needs to be a time interval that this can be called. Otherwise it can be called multiple times per expansion.\\n    // To simulate global collateral ratio set xsd price higher than silver price and hit refresh collateral ratio.\\n    uint256 public last_call_time; // Last time the refreshCollateralRatio function was called\\n    function refreshCollateralRatio() public {\\n        require(collateral_ratio_paused == false, \\\"Collateral Ratio has been paused\\\");\\n        uint256 xsd_price_cur = xsd_price();\\n        require(block.timestamp - last_call_time >= refresh_cooldown, \\\"Must wait for the refresh cooldown since last refresh\\\");\\n\\n        // Step increments are 0.25% (upon genesis, changable by setXSDStep()) \\n        \\n        if (xsd_price_cur > (price_target+price_band)) { //decrease collateral ratio\\n            if(global_collateral_ratio <= xsd_step){ //if within a step of 0, go to 0\\n                global_collateral_ratio = 0;\\n            } else {\\n                global_collateral_ratio = global_collateral_ratio-xsd_step;\\n            }\\n        } else if (xsd_price_cur < price_target-price_band) { //increase collateral ratio\\n            if(global_collateral_ratio+xsd_step >= 1000000){\\n                global_collateral_ratio = 1000000; // cap collateral ratio at 1.000000\\n            } else {\\n                global_collateral_ratio = global_collateral_ratio+xsd_step;\\n            }\\n        }\\n        else\\n        last_call_time = block.timestamp; // Set the time of the last expansion\\n        uint256 _interest_rate = (1000000-global_collateral_ratio)/(2);\\n        //update interest rate\\n        if(_interest_rate>52800){\\n            interest_rate = _interest_rate;\\n        }\\n        else{\\n            interest_rate = 52800;\\n        }\\n\\n        emit CollateralRatioRefreshed(global_collateral_ratio);\\n    }\\n\\n    function creatorMint(uint256 amount) public onlyByOwner{\\n        require(genesis_supply+amount<cap_rate,\\\"cap limit reached\\\");\\n        super._mint(treasury,amount);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    // Used by pools when user redeems\\n    function pool_burn_from(address b_address, uint256 b_amount) public onlyPools {\\n        super._burnFrom(b_address, b_amount);\\n        emit XSDBurned(b_address, msg.sender, b_amount);\\n    }\\n\\n    // This function is what other xsd pools will call to mint new XSD \\n    function pool_mint(address m_address, uint256 m_amount) public onlyPools {\\n        super._mint(m_address, m_amount);\\n        emit XSDMinted(msg.sender, m_address, m_amount);\\n    }\\n    \\n\\n    // Adds collateral addresses supported, such as tether and busd, must be ERC20 \\n    function addPool(address pool_address) public onlyByOwner {\\n        require(pool_address != address(0), \\\"Zero address detected\\\");\\n\\n        require(xsd_pools[pool_address] == false, \\\"Address already exists\\\");\\n        xsd_pools[pool_address] = true; \\n        xsd_pools_array.push(pool_address);\\n\\n        emit PoolAdded(pool_address);\\n    }\\n\\n    // Remove a pool \\n    function removePool(address pool_address) public onlyByOwner {\\n        require(pool_address != address(0), \\\"Zero address detected\\\");\\n\\n        require(xsd_pools[pool_address] == true, \\\"Address nonexistant\\\");\\n        \\n        // Delete from the mapping\\n        delete xsd_pools[pool_address];\\n\\n        // 'Delete' from the array by setting the address to 0x0\\n        for (uint i = 0; i < xsd_pools_array.length; i++){ \\n            if (xsd_pools_array[i] == pool_address) {\\n                xsd_pools_array[i] = address(0); // This will leave a null in the array and keep the indices the same\\n                break;\\n            }\\n        }\\n\\n        emit PoolRemoved(pool_address);\\n    }\\n// create a seperate function for users and the pool\\n    function burnpoolXSD(uint _xsdamount) public {\\n        require(msg.sender == router, \\\"Only the router can access this function\\\");\\n        require(totalSupply()-CollateralPool(payable(collateral_pool_address)).collat_XSD()>_xsdamount, \\\"uXSD has to be positive\\\");\\n        super._burn(address(xsdEthPool),_xsdamount);\\n        xsdEthPool.sync();\\n        emit XSDBurned(msg.sender, address(this), _xsdamount);\\n    }\\n    // add burn function for users\\n    function burnUserXSD(uint _xsdamount) public {\\n        require(totalSupply()-CollateralPool(payable(collateral_pool_address)).collat_XSD()>_xsdamount, \\\"uXSD has to be positive\\\");\\n        super._burn(msg.sender, _xsdamount);\\n        emit XSDBurned(msg.sender, address(this), _xsdamount);\\n    }\\n    function setXSDStep(uint256 _new_step) public onlyByOwnerPID {\\n        xsd_step = _new_step;\\n\\n        emit XSDStepSet(_new_step);\\n    }  \\n\\n    function setPriceTarget (uint256 _new_price_target) public onlyByOwnerPID {\\n        price_target = _new_price_target;\\n\\n        emit PriceTargetSet(_new_price_target);\\n    }\\n\\n    function setRefreshCooldown(uint256 _new_cooldown) public onlyByOwnerPID {\\n    \\trefresh_cooldown = _new_cooldown;\\n\\n        emit RefreshCooldownSet(_new_cooldown);\\n    }\\n\\n    function setTreasury(address _new_treasury) public onlyByOwner {\\n        require(_new_treasury != address(0), \\\"Zero address detected\\\");\\n        treasury = _new_treasury;\\n    }\\n\\n    function setETHUSDOracle(address _eth_usd_oracle_address) public onlyByOwner {\\n        require(_eth_usd_oracle_address != address(0), \\\"Zero address detected\\\");\\n\\n        eth_usd_oracle_address = _eth_usd_oracle_address;\\n        eth_usd_pricer = ChainlinkETHUSDPriceConsumer(eth_usd_oracle_address);\\n        eth_usd_pricer_decimals = eth_usd_pricer.getDecimals();\\n\\n        emit ETHUSDOracleSet(_eth_usd_oracle_address);\\n    }\\n    \\n    function setXAGUSDOracle(address _xag_usd_oracle_address) public onlyByOwner {\\n        require(_xag_usd_oracle_address != address(0), \\\"Zero address detected\\\");\\n\\n        xag_usd_oracle_address = _xag_usd_oracle_address;\\n        xag_usd_pricer = ChainlinkXAGUSDPriceConsumer(xag_usd_oracle_address);\\n        xag_usd_pricer_decimals = xag_usd_pricer.getDecimals();\\n\\n        emit XAGUSDOracleSet(_xag_usd_oracle_address);\\n    }\\n\\n    function setPIDController(address _pid_address) external onlyByOwner {\\n        require(_pid_address != address(0), \\\"Zero address detected\\\");\\n\\n        pid_address = _pid_address;\\n\\n        emit PIDControllerSet(_pid_address);\\n    }\\n\\n    function setRouterAddress(address _router) external onlyByOwner {\\n        require(_router != address(0), \\\"Zero address detected\\\");\\n        router = _router;\\n    }\\n\\n    function setPriceBand(uint256 _price_band) external onlyByOwner {\\n        price_band = _price_band;\\n\\n        emit PriceBandSet(_price_band);\\n    }\\n\\n    // Sets the XSD_ETH Uniswap oracle address \\n    function setXSDEthPool(address _xsd_pool_addr) public onlyByOwner {\\n        require(_xsd_pool_addr != address(0), \\\"Zero address detected\\\");\\n        xsdEthPool = IXSDWETHpool(_xsd_pool_addr); \\n\\n        emit XSDETHPoolSet(_xsd_pool_addr);\\n    }\\n\\n    // Sets the BankX_ETH Uniswap oracle address \\n    function setBankXEthPool(address _bankx_pool_addr) public onlyByOwner {\\n        require(_bankx_pool_addr != address(0), \\\"Zero address detected\\\");\\n        bankxEthPool = IBankXWETHpool(_bankx_pool_addr);\\n\\n        emit BankXEthPoolSet(_bankx_pool_addr);\\n    }\\n\\n    //sets the collateral pool address\\n    function setCollateralEthPool(address _collateral_pool_address) public onlyByOwner {\\n        require(_collateral_pool_address != address(0), \\\"Zero address detected\\\");\\n        collateral_pool_address = payable(_collateral_pool_address);\\n    }\\n\\n    function setSmartContractOwner(address _smartcontract_owner) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        require(msg.sender != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    function renounceOwnership() external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        smartcontract_owner = address(0);\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    // Track XSD burned\\n    event XSDBurned(address indexed from, address indexed to, uint256 amount);\\n\\n    // Track XSD minted\\n    event XSDMinted(address indexed from, address indexed to, uint256 amount);\\n\\n    event CollateralRatioRefreshed(uint256 global_collateral_ratio);\\n    event PoolAdded(address pool_address);\\n    event PoolRemoved(address pool_address);\\n    event RedemptionFeeSet(uint256 red_fee);\\n    event MintingFeeSet(uint256 min_fee);\\n    event XSDStepSet(uint256 new_step);\\n    event PriceTargetSet(uint256 new_price_target);\\n    event RefreshCooldownSet(uint256 new_cooldown);\\n    event ETHUSDOracleSet(address eth_usd_oracle_address);\\n    event XAGUSDOracleSet(address xag_usd_oracle_address);\\n    event PIDControllerSet(address _pid_controller);\\n    event PriceBandSet(uint256 price_band);\\n    event XSDETHPoolSet(address xsd_pool_addr);\\n    event BankXEthPoolSet(address bankx_pool_addr);\\n    event CollateralRatioToggled(bool collateral_ratio_paused);\\n}\"\r\n    },\r\n    \"contracts/XSD/Pools/RewardManager.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport '../../Utils/Initializable.sol';\\nimport './Interfaces/IBankXWETHpool.sol';\\nimport './Interfaces/IXSDWETHpool.sol';\\nimport \\\"../XSDStablecoin.sol\\\";\\nimport \\\"../../BankX/BankXToken.sol\\\";\\nimport \\\"./Interfaces/IRewardManager.sol\\\";\\nimport '../../Oracle/Interfaces/IPIDController.sol';\\n//manages rewards and crossovers for liquidity and collateral pools\\n\\ncontract RewardManager is IRewardManager,ReentrancyGuard,Initializable{\\n    address public smartcontract_owner;\\n    address public bankx_pool_address;\\n    address public xsd_pool_address;\\n    address public collat_pool_address;\\n    address public xsd_address;\\n    address public bankx_address;\\n    address public weth_address;\\n    IPIDController pid_controller;\\n    XSDStablecoin private XSD;\\n    BankXToken private BankX;\\n    IBankXWETHpool private bankxwethpool;\\n    IXSDWETHpool private xsdwethpool;\\n    uint public vesting1;\\n    uint public vesting2;\\n    uint public vesting3;\\n    struct Liquidity_Provider{\\n        uint vestingtimestamp;\\n        uint ethvalue;\\n        uint xsdrewards;\\n        uint bankxrewards;\\n    }\\n    mapping(address => mapping(address => mapping(uint => Liquidity_Provider))) public liquidity_provider;\\n    constructor(\\n        address _smartcontract_owner, \\n        address _weth_address\\n    ){\\n        require((_smartcontract_owner != address(0))\\n        &&(_weth_address != address(0)),\\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n        weth_address = _weth_address;\\n    }\\n    // called once by the smart contract owner at time of deployment\\n    function initialize(address _bankx_address, address _xsd_address,address _xsd_pool_address,address _bankx_pool_address,address _collat_pool_address, address _pid_address,uint _vesting1,uint _vesting2,uint _vesting3) public initializer {\\n        require(msg.sender == smartcontract_owner, 'RewardManager: FORBIDDEN'); // sufficient check\\n        require((_bankx_address != address(0))\\n        &&(_xsd_address != address(0))\\n        &&(_xsd_pool_address != address(0))\\n        &&(_bankx_pool_address != address(0))\\n        &&(_pid_address != address(0)), \\\"Zero address detected\\\");\\n        bankx_address = _bankx_address;\\n        xsd_address = _xsd_address;\\n        bankx_pool_address = _bankx_pool_address;\\n        xsd_pool_address = _xsd_pool_address;\\n        collat_pool_address = _collat_pool_address;\\n        BankX = BankXToken(bankx_address);\\n        XSD = XSDStablecoin(_xsd_address);\\n        bankxwethpool = IBankXWETHpool(_bankx_pool_address);\\n        xsdwethpool = IXSDWETHpool(_xsd_pool_address);\\n        pid_controller = IPIDController(_pid_address);\\n        vesting1 = _vesting1;\\n        vesting2 = _vesting2;\\n        vesting3 = _vesting3;\\n    }\\n\\n    function tier1(address pool,uint percent,address to,uint ethvalue,uint amountpaid,uint difference) private {\\n        uint actdiff = difference - amountpaid;\\n        if(ethvalue>actdiff){\\n           uint left_over = ethvalue - actdiff;\\n           liquidity_provider[pool][to][vesting1].ethvalue += actdiff;\\n           liquidity_provider[pool][to][vesting1].bankxrewards += actdiff + (actdiff*percent/100);\\n           liquidity_provider[pool][to][vesting1].xsdrewards += actdiff/20;\\n           liquidity_provider[bankx_pool_address][to][vesting2].vestingtimestamp = block.timestamp+vesting2;\\n           tier2(pool,percent,to,left_over,difference);\\n        }\\n        else{\\n            liquidity_provider[pool][to][vesting1].ethvalue += ethvalue;\\n            liquidity_provider[pool][to][vesting1].bankxrewards += ethvalue + (ethvalue*percent/100);\\n            liquidity_provider[pool][to][vesting1].xsdrewards += ethvalue/20;\\n        }\\n    }\\n\\n    function tier2(address pool,uint percent,address to,uint ethvalue,uint difference) private {\\n        if(ethvalue>difference){\\n            uint left_over = ethvalue - difference;\\n            liquidity_provider[pool][to][vesting2].ethvalue += difference;\\n            liquidity_provider[pool][to][vesting2].bankxrewards += difference + (difference*percent/100);\\n            liquidity_provider[pool][to][vesting2].xsdrewards += difference/50;\\n            liquidity_provider[pool][to][vesting3].ethvalue += left_over;\\n            liquidity_provider[pool][to][vesting3].bankxrewards += left_over + (left_over*percent/100);\\n            liquidity_provider[bankx_pool_address][to][vesting3].vestingtimestamp = block.timestamp + vesting3;\\n            }\\n        else{\\n            liquidity_provider[pool][to][vesting2].ethvalue += ethvalue;\\n            liquidity_provider[pool][to][vesting2].bankxrewards += ethvalue + (ethvalue*percent/100);\\n            liquidity_provider[pool][to][vesting2].xsdrewards += ethvalue/50;\\n        }\\n    }\\n//When the creator adds liquidity during a deficit period it must be added to the amount paid variables\\n    function creatorProvideBankXLiquidity() external override nonReentrant{\\n        (uint112 _reserve0, uint112 _reserve1,) = bankxwethpool.getReserves(); // gas savings\\n        uint balance0 = IERC20(bankx_address).balanceOf(bankx_pool_address);\\n        uint balance1 = IERC20(weth_address).balanceOf(bankx_pool_address);\\n        uint amount0 = balance0-(_reserve0);\\n        uint amount1 = balance1-(_reserve1);\\n        if(pid_controller.bucket2()){\\n            uint ethvalue = ((amount0*XSD.bankx_price())+(amount1*XSD.eth_usd_price()))/(1e6);\\n            pid_controller.amountPaidBankXWETH(ethvalue);\\n        }\\n        bankxwethpool.sync();\\n        emit CreatorProvideBankXLiquidity(msg.sender, amount0, amount1);\\n    }\\n\\n    function creatorProvideXSDLiquidity() external override nonReentrant{\\n        (uint112 _reserve0, uint112 _reserve1,) = xsdwethpool.getReserves();\\n        uint balance0 = IERC20(xsd_address).balanceOf(xsd_pool_address);\\n        uint balance1 = IERC20(weth_address).balanceOf(xsd_pool_address);\\n        uint amount0 = balance0-(_reserve0);\\n        uint amount1 = balance1-(_reserve1);\\n        if(pid_controller.bucket1()){\\n            uint ethvalue = ((amount0*XSD.xsd_price())+(amount1*XSD.eth_usd_price()))/(1e6);\\n            pid_controller.amountPaidXSDWETH(ethvalue);\\n        }\\n        xsdwethpool.sync();\\n        emit CreatorProvideXSDLiquidity(msg.sender, amount0, amount1);\\n    }\\n    //principal is split among tiers as well\\n    function userProvideBankXLiquidity(address to) external override nonReentrant{\\n        require(pid_controller.bucket2(), \\\"RewardManager:NO DEFICIT\\\");\\n        (, uint112 _reserve1,) = bankxwethpool.getReserves(); // gas savings\\n        uint balance1 = IERC20(weth_address).balanceOf(bankx_pool_address);\\n        uint amount = balance1-_reserve1;\\n        uint ethvalue = (amount*(XSD.eth_usd_price()))/(1e6);\\n        uint bankxamount = ethvalue/XSD.bankx_price();\\n        uint amountpaid = pid_controller.amountpaid2();\\n        uint difference = pid_controller.diff2()/3;\\n        require((ethvalue+amountpaid)<(difference*3),\\\"BankXLiquidity:DEFICIT LIMIT\\\");\\n        if(amountpaid<difference){\\n            tier1(bankx_pool_address,8,to,ethvalue,amountpaid,difference);//+604800;\\n            liquidity_provider[bankx_pool_address][to][vesting1].vestingtimestamp = block.timestamp+vesting1;\\n        }\\n        else if(amountpaid<(difference*(2))){\\n            tier2(bankx_pool_address,8,to,ethvalue,(2*difference)-amountpaid);//1209600;\\n            liquidity_provider[bankx_pool_address][to][vesting2].vestingtimestamp = block.timestamp+vesting2;\\n        }\\n        else{\\n            liquidity_provider[bankx_pool_address][to][vesting3].ethvalue += ethvalue;\\n            liquidity_provider[bankx_pool_address][to][vesting3].bankxrewards += ethvalue + (ethvalue*9/100);\\n            liquidity_provider[bankx_pool_address][to][vesting3].vestingtimestamp = block.timestamp + vesting3;\\n        }\\n        BankX.pool_mint(bankx_pool_address, bankxamount);\\n        pid_controller.amountPaidBankXWETH(ethvalue);\\n        bankxwethpool.sync();\\n        emit UserProvideBankXLiquidity(to, amount);\\n    }\\n\\n    function userProvideXSDLiquidity(address to) external override nonReentrant{\\n        require(pid_controller.bucket1(),\\\"RewardManager:NO DEFICIT\\\");\\n        (, uint112 _reserve1,) = xsdwethpool.getReserves(); // gas savings\\n        uint balance1 = IERC20(weth_address).balanceOf(xsd_pool_address);\\n        uint amount = balance1-_reserve1;\\n        uint ethvalue = (amount*(XSD.eth_usd_price()))/(1e6);\\n        uint xsdamount = ethvalue/XSD.xsd_price();\\n        uint amountpaid = pid_controller.amountpaid1();\\n        uint difference = pid_controller.diff1()/3;\\n        require((ethvalue+amountpaid)<(difference*3),\\\"XSDLiquidity:DEFICIT LIMIT\\\");\\n        if(amountpaid<difference){\\n            tier1(xsd_pool_address,9,to,ethvalue,amountpaid,difference);//+604800;\\n            liquidity_provider[xsd_pool_address][to][vesting1].vestingtimestamp = block.timestamp+vesting1;\\n        }\\n        else if(amountpaid<(difference*(2))){\\n            tier2(xsd_pool_address,9,to,ethvalue,(2*difference)-amountpaid);//1209600;\\n            liquidity_provider[xsd_pool_address][to][vesting2].vestingtimestamp = block.timestamp+vesting2;\\n        }\\n        else{\\n            liquidity_provider[xsd_pool_address][to][vesting3].ethvalue += ethvalue;\\n            liquidity_provider[xsd_pool_address][to][vesting3].bankxrewards += ethvalue + (ethvalue*9/100);\\n            liquidity_provider[xsd_pool_address][to][vesting3].vestingtimestamp = block.timestamp + vesting3;\\n        }\\n        XSD.pool_mint(xsd_pool_address, xsdamount);\\n        pid_controller.amountPaidXSDWETH(ethvalue);\\n        xsdwethpool.sync();\\n        emit UserProvideXSDLiquidity(to, amount);\\n    }\\n\\n    function userProvideCollatPoolLiquidity(address to, uint amount) external override nonReentrant{\\n        require(pid_controller.bucket3(),\\\"RewardManager:NO DEFICIT\\\");\\n        uint ethvalue = (amount*XSD.eth_usd_price())/(1e6);\\n        uint difference = pid_controller.diff3()/3;\\n        uint amountpaid = pid_controller.amountpaid3();\\n        require((ethvalue+amountpaid)<(difference*3),\\\"CollatPoolLiquidity:DEFICIT LIMIT\\\");\\n        if(amountpaid<difference){\\n            tier1(collat_pool_address,7,to,ethvalue,amountpaid,difference);//+604800;\\n            liquidity_provider[collat_pool_address][to][vesting1].vestingtimestamp = block.timestamp+vesting1;\\n        }\\n        else if(amountpaid<(difference*(2))){\\n            tier2(collat_pool_address,7,to,ethvalue,(2*difference)-amountpaid);//1209600;\\n            liquidity_provider[collat_pool_address][to][vesting2].vestingtimestamp = block.timestamp+vesting2;\\n        }\\n        else{\\n            liquidity_provider[collat_pool_address][to][vesting3].ethvalue += ethvalue;\\n            liquidity_provider[collat_pool_address][to][vesting3].bankxrewards += ethvalue + (ethvalue*9/100);\\n            liquidity_provider[collat_pool_address][to][vesting3].vestingtimestamp = block.timestamp + vesting3;\\n        }\\n        pid_controller.amountPaidCollateralPool(ethvalue);\\n        emit UserProvideCollatLiquidity(to, amount);\\n\\n    }\\n\\n    function tier1Redemption(address pool,address to) private returns(uint bankxamount,uint xsdamount){\\n        require(liquidity_provider[pool][to][vesting1].bankxrewards != 0 || liquidity_provider[pool][to][vesting1].xsdrewards != 0, \\\"Nothing to claim\\\");\\n        bankxamount = ((liquidity_provider[pool][to][vesting1].bankxrewards)*(1e6))/(XSD.bankx_price());\\n        xsdamount = ((liquidity_provider[pool][to][vesting1].xsdrewards)*(1e6))/(XSD.xsd_price());\\n        liquidity_provider[pool][to][vesting1].bankxrewards = 0;\\n        liquidity_provider[pool][to][vesting1].xsdrewards = 0;\\n        liquidity_provider[pool][to][vesting1].ethvalue = 0;\\n        liquidity_provider[pool][to][vesting1].vestingtimestamp = 0;\\n    }\\n    function tier2Redemption(address pool,address to) private returns(uint bankxamount,uint xsdamount){\\n        require(liquidity_provider[pool][to][vesting2].bankxrewards != 0 || liquidity_provider[pool][to][vesting2].xsdrewards != 0, \\\"Nothing to claim\\\");\\n        bankxamount = ((liquidity_provider[pool][to][vesting2].bankxrewards)*(1e6))/(XSD.bankx_price());\\n        xsdamount = ((liquidity_provider[pool][to][vesting2].xsdrewards)*(1e6))/(XSD.xsd_price());\\n        liquidity_provider[pool][to][vesting2].bankxrewards = 0;\\n        liquidity_provider[pool][to][vesting2].xsdrewards = 0;\\n        liquidity_provider[pool][to][vesting2].ethvalue = 0;\\n        liquidity_provider[pool][to][vesting2].vestingtimestamp = 0;\\n    }\\n    function tier3Redemption(address pool,address to) private returns(uint bankxamount){\\n        require(liquidity_provider[pool][to][vesting3].bankxrewards != 0, \\\"RewardManager:NO CLAIM\\\");\\n        bankxamount = ((liquidity_provider[pool][to][vesting3].bankxrewards)*(1e6))/(XSD.bankx_price());\\n        liquidity_provider[pool][to][vesting3].bankxrewards = 0;\\n        liquidity_provider[pool][to][vesting3].ethvalue = 0;\\n        liquidity_provider[pool][to][vesting3].vestingtimestamp = 0;\\n    }\\n\\n    function LiquidityRedemption(address pool,address to) external override nonReentrant{\\n        //find a better way to check which tier\\n        uint bankxamount;\\n        uint xsdamount;\\n        if((liquidity_provider[pool][to][vesting1].ethvalue != 0) && (liquidity_provider[pool][to][vesting1].vestingtimestamp<=block.timestamp)){\\n            (bankxamount,xsdamount) = tier1Redemption(pool,to);\\n        }\\n        if((liquidity_provider[pool][to][vesting2].ethvalue != 0) && (liquidity_provider[pool][to][vesting2].vestingtimestamp<=block.timestamp)){\\n            uint bankxamount2;\\n            uint xsdamount2;\\n            (bankxamount2,xsdamount2) = tier2Redemption(pool,to);\\n            bankxamount += bankxamount2;\\n            xsdamount += xsdamount2; \\n        }\\n        if((liquidity_provider[pool][to][vesting3].ethvalue != 0) && (liquidity_provider[pool][to][vesting3].vestingtimestamp<=block.timestamp)){\\n            bankxamount += tier3Redemption(pool,to);\\n        }\\n        BankX.pool_mint(to, bankxamount);\\n        XSD.pool_mint(to, xsdamount);\\n        emit liquidityRedemption(to, bankxamount, xsdamount);\\n    }\\n    function setSmartContractOwner(address _smartcontract_owner) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        require(msg.sender != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    function renounceOwnership() external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        smartcontract_owner = address(0);\\n    }\\n\\n    function resetAddresses(address _bankx_address, address _xsd_address,address _xsd_pool_address,address _bankx_pool_address,address _collat_pool_address, address _pid_address,uint _vesting1,uint _vesting2,uint _vesting3) external{\\n        require(msg.sender == smartcontract_owner, 'RewardManager: FORBIDDEN'); // sufficient check\\n        require((_bankx_address != address(0))\\n        &&(_xsd_address != address(0))\\n        &&(_xsd_pool_address != address(0))\\n        &&(_bankx_pool_address != address(0))\\n        &&(_pid_address != address(0)), \\\"Zero address detected\\\");\\n        bankx_address = _bankx_address;\\n        xsd_address = _xsd_address;\\n        bankx_pool_address = _bankx_pool_address;\\n        xsd_pool_address = _xsd_pool_address;\\n        collat_pool_address = _collat_pool_address;\\n        BankX = BankXToken(bankx_address);\\n        XSD = XSDStablecoin(_xsd_address);\\n        bankxwethpool = IBankXWETHpool(_bankx_pool_address);\\n        xsdwethpool = IXSDWETHpool(_xsd_pool_address);\\n        pid_controller = IPIDController(_pid_address);\\n        vesting1 = _vesting1;\\n        vesting2 = _vesting2;\\n        vesting3 = _vesting3;\\n    }\\n    // ========== EVENTS ========== \\n    event CreatorProvideBankXLiquidity(address sender, uint amount0, uint amount1);\\n    event CreatorProvideXSDLiquidity(address sender, uint amount0, uint amount1);\\n    event UserProvideBankXLiquidity(address sender, uint amount);\\n    event UserProvideXSDLiquidity(address sender, uint amount);\\n    event UserProvideCollatLiquidity(address sender, uint amount);\\n    event liquidityRedemption(address sender, uint bankxamount, uint xsdamount);\\n    \\n}\"\r\n    },\r\n    \"contracts/UniswapFork/BankXLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\nlibrary BankXLibrary {\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'BankXLibrary: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'BankXLibrary: INSUFFICIENT_LIQUIDITY');\\n        amountB = (amountA*reserveB) / reserveA;\\n    }\\n   \\n}\"\r\n    },\r\n    \"contracts/Utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.24;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\\n    function balanceOf(address account) external view returns (uint256);\\n    function withdraw(uint) external;\\n}\"\r\n    },\r\n    \"contracts/XSD/Pools/XSDWETHpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '../../Utils/Initializable.sol';\\nimport '../../Utils/UQ112x112.sol';\\nimport '../../Oracle/Interfaces/IPIDController.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../XSDStablecoin.sol';\\nimport '../../BankX/BankXToken.sol';\\nimport './Interfaces/IXSDWETHpool.sol';\\n\\ncontract XSDWETHpool is IXSDWETHpool, Initializable, ReentrancyGuard{\\n    using UQ112x112 for uint224;\\n\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint) public override nonces;\\n    uint256 private constant PRICE_PRECISION = 1e6;\\n    address private XSDaddress;\\n    address private WETHaddress;\\n    address public smartcontract_owner;\\n    //keeps track of amount that needs to be burnt\\n    uint public xsdamount;\\n\\n    IPIDController pid_controller;\\n    XSDStablecoin private XSD;\\n    BankXToken private BankX;\\n\\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n    \\n    uint public override price0CumulativeLast;\\n    uint public override price1CumulativeLast;\\n    uint public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity even\\n\\n    uint public reserve0_residue;\\n    uint public reserve1_residue;\\n\\n    function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(address token, address to, uint value) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'XSDWETH: TRANSFER_FAILED');\\n    }\\n\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    constructor(address _smartcontract_owner, uint _reserve0_residue, uint _reserve1_residue){\\n        require(_smartcontract_owner != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n        reserve0_residue = _reserve0_residue;\\n        reserve1_residue = _reserve1_residue;\\n    }\\n    // called once by the smartcontract_address at time of deployment\\n    function initialize(address _token0, address _token1, address _bankx_contract_address, address _pid_address, address _collateral_pool_address) public initializer {\\n        require(msg.sender == smartcontract_owner, 'XSD/WETH: FORBIDDEN'); // sufficient check\\n        require((_token0 != address(0))\\n        &&(_token1 != address(0))\\n        &&(_bankx_contract_address != address(0))\\n        &&(_pid_address != address(0))\\n        &&(_collateral_pool_address != address(0)), \\\"Zero address detected\\\");\\n        XSDaddress = _token0;\\n        XSD = XSDStablecoin(XSDaddress);\\n        BankX = BankXToken(_bankx_contract_address);\\n        WETHaddress = _token1;\\n        pid_controller = IPIDController(_pid_address);\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, 'XSDWETH: OVERFLOW');\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // Returns dollar value of collateral held in this XSD pool\\n    function collatDollarBalance() public view override returns (uint256) {\\n            return ((IERC20(WETHaddress).balanceOf(address(this))*(XSD.eth_usd_price()))/(PRICE_PRECISION));     \\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(uint amount0Out, uint amount1Out, address to) external override nonReentrant {\\n        require(amount0Out > 0 || amount1Out > 0, 'XSDWETH: INSUFFICIENT_OUTPUT_AMOUNT');\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        _reserve0 = uint112(_reserve0);\\n        _reserve1 = uint112(_reserve1);\\n        require(amount0Out < (_reserve0-reserve0_residue) && amount1Out < (_reserve1-reserve1_residue), 'XSDWETH: INSUFFICIENT_LIQUIDITY');\\n\\n        uint balance0;\\n        uint balance1;\\n        { // scope for _token{0,1}, avoids stack too deep errors\\n        address _token0 = XSDaddress;\\n        address _token1 = WETHaddress;\\n        require(to != _token0 && to != _token1, 'XSDWETH: INVALID_TO');\\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n        }\\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        require(amount0In > 0 || amount1In > 0, 'XSDWETH: INSUFFICIENT_INPUT_AMOUNT');\\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n        uint balance0Adjusted = balance0;\\n        uint balance1Adjusted = balance1;\\n        require(balance0Adjusted*(balance1Adjusted) >= uint(_reserve0)*(_reserve1), 'XSDWETH: K');\\n        }\\n        if(amount1Out != 0) xsdamount = amount0In;\\n        _update(balance0, balance1,_reserve0,_reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external override nonReentrant {\\n        address _token0 = XSDaddress; // gas savings\\n        address _token1 = WETHaddress; // gas savings\\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this))-(reserve0));\\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this))-(reserve1));\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external override nonReentrant {\\n        _update(IERC20(XSDaddress).balanceOf(address(this)), IERC20(WETHaddress).balanceOf(address(this)), reserve0, reserve1);\\n        kLast = uint(reserve0)*(reserve1);\\n    }\\n\\n    function setSmartContractOwner(address _smartcontract_owner) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        require(msg.sender != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    function renounceOwnership() external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        smartcontract_owner = address(0);\\n    }\\n\\n    function resetAddresses(address _token0, address _token1, address _bankx_contract_address, address _pid_address, address _collateral_pool_address) external{\\n        require(msg.sender == smartcontract_owner, 'XSD/WETH: FORBIDDEN'); // sufficient check\\n        require((_token0 != address(0))\\n        &&(_token1 != address(0))\\n        &&(_bankx_contract_address != address(0))\\n        &&(_pid_address != address(0))\\n        &&(_collateral_pool_address != address(0)), \\\"Zero address detected\\\");\\n        XSDaddress = _token0;\\n        XSD = XSDStablecoin(XSDaddress);\\n        BankX = BankXToken(_bankx_contract_address);\\n        WETHaddress = _token1;\\n        pid_controller = IPIDController(_pid_address);\\n    }\\n    /* ========== EVENTS ========== */\\n    event ProvideLiquidity(address sender, uint amount0, uint amount1);\\n    event ProvideLiquidity2(address sender, uint amount1);\\n    \\n\\n}\"\r\n    },\r\n    \"contracts/XSD/Pools/BankXWETHpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\n//must create interface for it\\nimport '../XSDStablecoin.sol';\\nimport '../../BankX/BankXToken.sol';\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\nimport '../../Utils/Initializable.sol';\\nimport '../../Utils/UQ112x112.sol';\\nimport '../../Oracle/Interfaces/IPIDController.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport './Interfaces/IBankXWETHpool.sol';\\n\\ncontract BankXWETHpool is IBankXWETHpool, Initializable, ReentrancyGuard{\\n    using UQ112x112 for uint224;\\n\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint) public override nonces;\\n    uint256 private constant PRICE_PRECISION = 1e6;\\n    address private bankxaddress;\\n    address private WETHaddress;\\n    address public smartcontract_owner;\\n\\n    uint public bankxamount;\\n\\n    IPIDController pid_controller;\\n    XSDStablecoin private XSD;\\n    BankXToken private BankX;\\n\\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n    \\n    uint public override price0CumulativeLast;\\n    uint public override price1CumulativeLast;\\n    uint public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n    uint public reserve0_residue;\\n    uint public reserve1_residue;\\n\\n    function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(address token, address to, uint value) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'BANKXWETH: TRANSFER_FAILED');\\n    }\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    \\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    constructor(address _smartcontract_owner, uint _reserve0_residue, uint _reserve1_residue){\\n        require(_smartcontract_owner != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n        reserve0_residue = _reserve0_residue;\\n        reserve1_residue = _reserve1_residue;\\n    }\\n\\n    function initialize(address _token0, address _token1, address _xsd_contract_address, address _pid_address) public initializer {\\n        require(msg.sender == smartcontract_owner, 'BankX/WETH: FORBIDDEN'); \\n        require((_token0 != address(0))\\n        &&(_token1 != address(0))\\n        &&(_xsd_contract_address != address(0))\\n        &&(_pid_address != address(0)), \\\"Zero address detected\\\");\\n        bankxaddress = _token0;\\n        BankX = BankXToken(bankxaddress);\\n        XSD = XSDStablecoin(_xsd_contract_address);\\n        WETHaddress = _token1;\\n        pid_controller = IPIDController(_pid_address);\\n    }\\n\\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) internal {\\n        require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, 'BANKXWETH: OVERFLOW');\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // Returns dollar value of collateral held in this XSD pool\\n    function collatDollarBalance() public view override returns (uint256) {\\n            return ((IERC20(WETHaddress).balanceOf(address(this))*XSD.eth_usd_price())/PRICE_PRECISION);   \\n    }\\n    \\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(uint amount0Out, uint amount1Out, address to) external override nonReentrant{\\n        require(amount0Out > 0 || amount1Out > 0, 'BankXWETH: INSUFFICIENT_OUTPUT_AMOUNT');\\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n        _reserve0 = uint112(_reserve0);\\n        _reserve1 = uint112(_reserve1);\\n        require(amount0Out < (_reserve0-(reserve0_residue)) && amount1Out < (_reserve1-(reserve1_residue)), 'BankXWETH: INSUFFICIENT_LIQUIDITY');\\n        uint balance0;\\n        uint balance1;\\n        { // scope for _token{0,1}, avoids stack too deep errors\\n        address _token0 = bankxaddress;\\n        address _token1 = WETHaddress;\\n        require(to != _token0 && to != _token1, 'BankXWETH: INVALID_TO');\\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n        }\\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n        require(amount0In > 0 || amount1In > 0, 'BankXWETH: INSUFFICIENT_INPUT_AMOUNT');\\n        require((balance0*balance1) >= uint(_reserve0)*(_reserve1), 'BankXWETH: K');\\n        if(amount1Out != 0) bankxamount = amount0In;\\n        _update(balance0, balance1,_reserve0,_reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external override nonReentrant {\\n        address _token0 = bankxaddress; // gas savings\\n        address _token1 = WETHaddress; // gas savings\\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this))-(reserve0));\\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this))-(reserve1));\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external override nonReentrant {\\n        _update(IERC20(bankxaddress).balanceOf(address(this)), IERC20(WETHaddress).balanceOf(address(this)), reserve0, reserve1);\\n        kLast = uint(reserve0)*(reserve1);\\n    }\\n\\n    function setSmartContractOwner(address _smartcontract_owner) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        require(msg.sender != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    function renounceOwnership() external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        smartcontract_owner = address(0);\\n    }\\n\\n    function resetAddresses(address _token0, address _token1, address _xsd_contract_address, address _pid_address,uint _reserve0_residue, uint _reserve1_residue ) external{\\n        require(msg.sender == smartcontract_owner, 'BankX/WETH: FORBIDDEN'); // sufficient check\\n        require((_token0 != address(0))\\n        &&(_token1 != address(0))\\n        &&(_xsd_contract_address != address(0))\\n        &&(_pid_address != address(0)), \\\"Zero address detected\\\");\\n        bankxaddress = _token0;\\n        BankX = BankXToken(bankxaddress);\\n        XSD = XSDStablecoin(_xsd_contract_address);\\n        WETHaddress = _token1;\\n        pid_controller = IPIDController(_pid_address);\\n        reserve0_residue = _reserve0_residue;\\n        reserve1_residue = _reserve1_residue;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    event ProvideLiquidity(address sender, uint amount0, uint amount1);\\n    event ProvideLiquidity2(address sender, uint amount1);\\n\\n}\"\r\n    },\r\n    \"contracts/XSD/Pools/CollateralPool.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: MIT\\n/*\\nBBBBBBBBBBBBBBBBB \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0kkkkkkkk \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0XXXXXXX\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 XXXXXXX\\nB::::::::::::::::B \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k::::::k \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X:::::X \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X:::::X\\nB::::::BBBBBB:::::B \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k::::::k \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X:::::X \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X:::::X\\nBB:::::B \u00a0\u00a0\u00a0\u00a0B:::::B \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0k::::::k \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X::::::X \u00a0\u00a0\u00a0\u00a0X::::::X\\n\u00a0 B::::B \u00a0\u00a0\u00a0\u00a0B:::::B \u00a0\u00a0aaaaaaaaaaaaa \u00a0\u00a0nnnn \u00a0nnnnnnnn \u00a0\u00a0\u00a0\u00a0\u00a0k:::::k kkkkkkk XXX:::::X \u00a0\u00a0X:::::XXX\\n\u00a0 B::::B \u00a0\u00a0\u00a0\u00a0B:::::B \u00a0\u00a0a::::::::::::a \u00a0n:::nn::::::::nn \u00a0\u00a0\u00a0k:::::k k:::::k \u00a0\u00a0\u00a0X:::::X X:::::X\\n\u00a0 B::::BBBBBB:::::B \u00a0\u00a0\u00a0aaaaaaaaa:::::a n::::::::::::::nn \u00a0\u00a0k:::::k k:::::k \u00a0\u00a0\u00a0\u00a0X:::::X:::::X\\n\u00a0 B:::::::::::::BB \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a::::a nn:::::::::::::::n \u00a0k:::::k k:::::k \u00a0\u00a0\u00a0\u00a0\u00a0X:::::::::X\\n\u00a0 B::::BBBBBB:::::B \u00a0\u00a0\u00a0\u00a0\u00a0aaaaaaa:::::a \u00a0\u00a0n:::::nnnn:::::n \u00a0k::::::k:::::k \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X:::::::::X\\n\u00a0 B::::B \u00a0\u00a0\u00a0\u00a0B:::::B \u00a0\u00a0aa::::::::::::a \u00a0\u00a0n::::n \u00a0\u00a0\u00a0n::::n \u00a0k:::::::::::k \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X:::::X:::::X\\n\u00a0 B::::B \u00a0\u00a0\u00a0\u00a0B:::::B \u00a0a::::aaaa::::::a \u00a0\u00a0n::::n \u00a0\u00a0\u00a0n::::n \u00a0k:::::::::::k \u00a0\u00a0\u00a0\u00a0\u00a0X:::::X X:::::X\\n\u00a0 B::::B \u00a0\u00a0\u00a0\u00a0B:::::B a::::a \u00a0\u00a0\u00a0a:::::a \u00a0\u00a0n::::n \u00a0\u00a0\u00a0n::::n \u00a0k::::::k:::::k \u00a0XXX:::::X \u00a0\u00a0X:::::XXX\\nBB:::::BBBBBB::::::B a::::a \u00a0\u00a0\u00a0a:::::a \u00a0\u00a0n::::n \u00a0\u00a0\u00a0n::::n k::::::k k:::::k X::::::X \u00a0\u00a0\u00a0\u00a0X::::::X\\nB:::::::::::::::::B \u00a0a:::::aaaa::::::a \u00a0\u00a0n::::n \u00a0\u00a0\u00a0n::::n k::::::k k:::::k X:::::X \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X:::::X\\nB::::::::::::::::B \u00a0\u00a0\u00a0a::::::::::aa:::a \u00a0n::::n \u00a0\u00a0\u00a0n::::n k::::::k k:::::k X:::::X \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X:::::X\\nBBBBBBBBBBBBBBBBB \u00a0\u00a0\u00a0\u00a0\u00a0aaaaaaaaaa \u00a0aaaa \u00a0nnnnnn \u00a0\u00a0\u00a0nnnnnn kkkkkkkk kkkkkkk XXXXXXX \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0XXXXXXX\\n\\n\\n                                          Currency Creators Manifesto\\n\\nOur world faces an urgent crisis of currency manipulation, theft and inflation.  Under the current system, currency is controlled by and benefits elite families, governments and large banking institutions.  We believe currencies should be minted by and benefit the individual, not the establishment.  It is time to take back the control of and the freedom that money can provide.\\n\\nBankX is rebuilding the legacy banking system from the ground up by providing you with the capability to create currency and be in complete control of wealth creation with a concept we call \u2018Individual Created Digital Currency\u2019 (ICDC). You own the collateral.  You mint currency.  You earn interest.  You leverage without the risk of liquidation.  You stake to earn even more returns.  All of this is done with complete autonomy and decentralization.  BankX has built a stablecoin for Individual Freedom.\\n\\nBankX is the antidote for the malevolent financial system bringing in a new future of freedom where you are in complete control with no middlemen, bank or central bank between you and your finances. This capability to create currency and be in complete control of wealth creation will be in the hands of every individual that uses BankX.\\n\\nBy 2030, we will rid the world of the corrupt, tyrannical and incompetent banking system replacing it with a system where billions of people will be in complete control of their financial future.  Everyone will be given ultimate freedom to use their assets to create currency, earn interest and multiply returns to accomplish their individual goals.  The mission of BankX is to be the first to mint $1 trillion in stablecoin. \\n\\nWe will bring about this transformation by attracting people that believe what we believe.  We will partner with other blockchain protocols and build decentralized applications that drive even more usage.  Finally, we will deploy a private network that is never connected to the Internet to communicate between counterparties, that allows for blockchain-to-blockchain interoperability and stores private keys and cryptocurrency wallets.  Our ecosystem, network and platform has never been seen in the market and provides us with a long term sustainable competitive advantage.\\n\\nWe value individual freedom.\\nWe believe in financial autonomy.\\nWe are anti-establishment.\\nWe envision a future of self-empowerment.\\n\\n*/\\npragma solidity ^0.8.0;\\n\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\nimport \\\"../../BankX/BankXToken.sol\\\";\\nimport \\\"../XSDStablecoin.sol\\\";\\nimport \\\"./Interfaces/IBankXWETHpool.sol\\\";\\nimport \\\"./Interfaces/IXSDWETHpool.sol\\\";\\nimport '../../Oracle/Interfaces/IPIDController.sol';\\nimport \\\"../../ERC20/IWETH.sol\\\";\\nimport \\\"./CollateralPoolLibrary.sol\\\";\\n\\ncontract CollateralPool is ReentrancyGuard {\\n    /* ========== STATE VARIABLES ========== */\\n\\n    address public WETH;\\n    address public smartcontract_owner;\\n    address public xsd_contract_address;\\n    address public bankx_contract_address;\\n    address public xsdweth_pool;\\n    address public bankxweth_pool;\\n    address public pid_address;\\n    BankXToken private BankX;\\n    XSDStablecoin private XSD;\\n    IPIDController private pid_controller;\\n    uint256 public collat_XSD;\\n    uint256 public bankx_price;\\n    uint256 public xsd_price;\\n    bool public mint_paused;\\n    bool public redeem_paused;\\n    bool public buyback_paused;\\n\\n    struct MintInfo {\\n        uint256 accum_interest; //accumulated interest from previous mints\\n        uint256 interest_rate; //interest rate at that particular timestamp\\n        uint256 time; //last timestamp\\n        uint256 amount; //XSD amount minted\\n    }\\n    struct PriceCheck{\\n        uint256 lastpricecheck;\\n        bool pricecheck;\\n    }\\n    mapping(address=>MintInfo) public mintMapping; \\n    mapping (address => uint256) public redeemBankXBalances;\\n    mapping (address => uint256) public redeemCollateralBalances;\\n    mapping (address => uint256) public vestingtimestamp;\\n    uint256 public unclaimedPoolCollateral;\\n    uint256 public unclaimedPoolBankX;\\n    uint256 public collateral_equivalent_d18;\\n    uint256 public bankx_minted_count;\\n    mapping (address => uint256) public lastRedeemed;\\n    mapping (address => PriceCheck) public lastPriceCheck;\\n\\n    uint256 public block_delay = 2;\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyByOwner() {\\n        require(msg.sender == smartcontract_owner, \\\"Not owner\\\");\\n        _;\\n    }\\n \\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        address _xsd_contract_address,\\n        address _bankx_contract_address,\\n        address _bankxweth_pool,\\n        address _xsdweth_pool,\\n        address _WETH,\\n        address _smartcontract_owner\\n    ) {\\n        require(\\n            (_xsd_contract_address != address(0))\\n            && (_bankx_contract_address != address(0))\\n            && (_WETH != address(0))\\n            && (_bankxweth_pool != address(0))\\n            && (_xsdweth_pool != address(0))\\n        , \\\"Zero address detected\\\"); \\n        XSD = XSDStablecoin(_xsd_contract_address);\\n        BankX = BankXToken(_bankx_contract_address);\\n        xsd_contract_address = _xsd_contract_address;\\n        bankx_contract_address = _bankx_contract_address;\\n        xsdweth_pool = _xsdweth_pool;\\n        bankxweth_pool = _bankxweth_pool;\\n        WETH = _WETH;\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    //only accept ETH via fallback function from the WETH contract\\n    receive() external payable {\\n        assert(msg.sender == WETH);\\n    }\\n\\n    // Returns dollar value of collateral held in this XSD pool\\n    function collatDollarBalance() public view returns (uint256) {\\n            return ((IWETH(WETH).balanceOf(address(this))*XSD.eth_usd_price())/(1e6));        \\n    }\\n\\n    // Returns the value of excess collateral held in this XSD pool, compared to what is needed to maintain the global collateral ratio\\n    function availableExcessCollatDV() public view returns (uint256) {\\n        uint256 global_collateral_ratio = XSD.global_collateral_ratio();\\n        uint256 global_collat_value = XSD.globalCollateralValue();\\n\\n        if (global_collateral_ratio > (1e6)) global_collateral_ratio = (1e6); // Handles an overcollateralized contract with CR > 1\\n        uint256 required_collat_dollar_value_d18 = ((collat_XSD)*global_collateral_ratio*(XSD.xag_usd_price()*(1e4))/(311035))/(1e12); // Calculates collateral needed to back each 1 XSD with $1 of collateral at current collat ratio\\n        if ((global_collat_value-unclaimedPoolCollateral)>required_collat_dollar_value_d18) return (global_collat_value-unclaimedPoolCollateral-required_collat_dollar_value_d18);\\n        else return 0;\\n    }\\n    /* ========== INTERNAL FUNCTIONS ======== */\\n    function priceCheck() external{\\n        bankx_price = XSD.bankx_price();\\n        xsd_price = XSD.xsd_price();\\n        lastPriceCheck[msg.sender].lastpricecheck = block.number;\\n        lastPriceCheck[msg.sender].pricecheck = true;\\n    }\\n\\n    function mintInterestCalc(uint xsd_amount,address sender) internal {\\n        (mintMapping[sender].accum_interest, mintMapping[sender].interest_rate, mintMapping[sender].time, mintMapping[sender].amount) = CollateralPoolLibrary.calcMintInterest(xsd_amount,XSD.xag_usd_price(), XSD.interest_rate(), mintMapping[sender].accum_interest, mintMapping[sender].interest_rate, mintMapping[sender].time, mintMapping[sender].amount);\\n    }\\n    function redeemInterestCalc(uint xsd_amount,address sender) internal {\\n        (mintMapping[sender].accum_interest, mintMapping[sender].interest_rate, mintMapping[sender].time, mintMapping[sender].amount)=CollateralPoolLibrary.calcRedemptionInterest(xsd_amount,XSD.xag_usd_price(), mintMapping[sender].accum_interest, mintMapping[sender].interest_rate, mintMapping[sender].time, mintMapping[sender].amount);\\n    }\\n\\n    /* ========== PUBLIC FUNCTIONS ========== */\\n    \\n    // We separate out the 1t1, fractional and algorithmic minting functions for gas efficiency \\n    function mint1t1XSD(uint256 XSD_out_min) external payable nonReentrant {\\n        require(!mint_paused, \\\"Mint Paused\\\");\\n        require(msg.value>0, \\\"Invalid collateral amount\\\");\\n        require(XSD.global_collateral_ratio() >= (1e6), \\\"Collateral ratio must be >= 1\\\");\\n        (uint256 xsd_amount_d18) = CollateralPoolLibrary.calcMint1t1XSD(\\n            XSD.eth_usd_price(),\\n            XSD.xag_usd_price(),\\n            msg.value\\n        ); //1 XSD for each $1 worth of collateral\\n        require(XSD_out_min <= xsd_amount_d18, \\\"Slippage limit reached\\\");\\n        mintInterestCalc(xsd_amount_d18,msg.sender);\\n        IWETH(WETH).deposit{value: msg.value}();\\n        assert(IWETH(WETH).transfer(address(this), msg.value));\\n        collat_XSD = collat_XSD + xsd_amount_d18;\\n        XSD.pool_mint(msg.sender, xsd_amount_d18);\\n    }\\n\\n    // 0% collateral-backed\\n    function mintAlgorithmicXSD(uint256 bankx_amount_d18, uint256 XSD_out_min) external nonReentrant {\\n        require(!mint_paused, \\\"Mint Paused\\\");\\n        require(((lastPriceCheck[msg.sender].lastpricecheck+(block_delay)) <= block.number) && (lastPriceCheck[msg.sender].pricecheck), \\\"Must wait for block_delay blocks before minting\\\");\\n        uint256 xag_usd_price = XSD.xag_usd_price();\\n        require(XSD.global_collateral_ratio() == 0, \\\"Collateral ratio must be 0\\\");\\n        (uint256 xsd_amount_d18) = CollateralPoolLibrary.calcMintAlgorithmicXSD(\\n            bankx_price, \\n            xag_usd_price,\\n            bankx_amount_d18\\n        );\\n        require(XSD_out_min <= xsd_amount_d18, \\\"Slippage limit reached\\\");\\n        mintInterestCalc(xsd_amount_d18,msg.sender);\\n        collat_XSD = collat_XSD + xsd_amount_d18;\\n        bankx_minted_count = bankx_minted_count + bankx_amount_d18;\\n        lastPriceCheck[msg.sender].pricecheck = false;\\n        BankX.pool_burn_from(msg.sender, bankx_amount_d18);\\n        XSD.pool_mint(msg.sender, xsd_amount_d18);\\n    }\\n\\n    // Will fail if fully collateralized or fully algorithmic\\n    // > 0% and < 100% collateral-backed\\n    function mintFractionalXSD(uint256 bankx_amount, uint256 XSD_out_min) external payable nonReentrant {\\n        require(!mint_paused, \\\"Mint Paused\\\");\\n        require(((lastPriceCheck[msg.sender].lastpricecheck+(block_delay)) <= block.number) && (lastPriceCheck[msg.sender].pricecheck), \\\"Must wait for block_delay blocks before minting\\\");\\n        uint256 xag_usd_price = XSD.xag_usd_price();\\n        uint256 global_collateral_ratio = XSD.global_collateral_ratio();\\n\\n        require(global_collateral_ratio < (1e6) && global_collateral_ratio > 0, \\\"Collateral ratio needs to be between .000001 and .999999\\\");\\n        CollateralPoolLibrary.MintFF_Params memory input_params = CollateralPoolLibrary.MintFF_Params(\\n            bankx_price,\\n            XSD.eth_usd_price(),\\n            bankx_amount,\\n            msg.value,\\n            global_collateral_ratio\\n        );\\n\\n        (uint256 mint_amount, uint256 bankx_needed) = CollateralPoolLibrary.calcMintFractionalXSD(input_params);\\n        mint_amount = (mint_amount*31103477)/((xag_usd_price)); //grams of silver in calculated mint amount\\n        require(XSD_out_min <= mint_amount, \\\"Slippage limit reached\\\");\\n        require(bankx_needed <= bankx_amount, \\\"Not enough BankX inputted\\\");\\n        mintInterestCalc(mint_amount,msg.sender);\\n        bankx_minted_count = bankx_minted_count + bankx_needed;\\n        BankX.pool_burn_from(msg.sender, bankx_needed);\\n        IWETH(WETH).deposit{value: msg.value}();\\n        assert(IWETH(WETH).transfer(address(this), msg.value));\\n        collat_XSD = collat_XSD + mint_amount;\\n        lastPriceCheck[msg.sender].pricecheck = false;\\n        XSD.pool_mint(msg.sender, mint_amount);\\n    }\\n\\n    // Redeem collateral. 100% collateral-backed\\n    function redeem1t1XSD(uint256 XSD_amount, uint256 COLLATERAL_out_min) external nonReentrant {\\n        require(!pid_controller.bucket3(), \\\"Cannot withdraw in times of deficit\\\");\\n        require(!redeem_paused, \\\"Redeem Paused\\\");\\n        require(XSD.global_collateral_ratio() == (1e6), \\\"Collateral ratio must be == 1\\\");\\n        require(XSD_amount<=mintMapping[msg.sender].amount, \\\"OVERREDEMPTION ERROR\\\");\\n        require(((lastPriceCheck[msg.sender].lastpricecheck+(block_delay)) <= block.number) && (lastPriceCheck[msg.sender].pricecheck), \\\"Must wait for block_delay blocks before redeeming\\\");\\n\\n        // convert xsd to $ and then to collateral value\\n        (uint256 XSD_dollar,uint256 collateral_needed) = CollateralPoolLibrary.calcRedeem1t1XSD(\\n            XSD.eth_usd_price(),\\n            XSD.xag_usd_price(),\\n            XSD_amount\\n        );\\n        uint total_xsd_amount = mintMapping[msg.sender].amount;\\n        require(collateral_needed <= (IWETH(WETH).balanceOf(address(this))-unclaimedPoolCollateral), \\\"Not enough collateral in pool\\\");\\n        require(COLLATERAL_out_min <= collateral_needed, \\\"Slippage limit reached\\\");\\n        redeemInterestCalc(XSD_amount, msg.sender);\\n        uint current_accum_interest = (XSD_amount*mintMapping[msg.sender].accum_interest)/total_xsd_amount;\\n        redeemBankXBalances[msg.sender] = (redeemBankXBalances[msg.sender]+current_accum_interest);\\n        redeemCollateralBalances[msg.sender] = redeemCollateralBalances[msg.sender]+XSD_dollar;\\n        unclaimedPoolCollateral = unclaimedPoolCollateral+XSD_dollar;\\n        lastRedeemed[msg.sender] = block.number;\\n        unclaimedPoolBankX = (unclaimedPoolBankX+current_accum_interest);\\n        uint256 bankx_amount = (current_accum_interest*1e6)/bankx_price;\\n        collat_XSD -= XSD_amount;\\n        mintMapping[msg.sender].accum_interest = (mintMapping[msg.sender].accum_interest - current_accum_interest);\\n        lastPriceCheck[msg.sender].pricecheck = false;\\n        XSD.pool_burn_from(msg.sender, XSD_amount);\\n        BankX.pool_mint(address(this), bankx_amount);\\n    }\\n\\n    // Will fail if fully collateralized or algorithmic\\n    // Redeem XSD for collateral and BankX. > 0% and < 100% collateral-backed\\n    function redeemFractionalXSD(uint256 XSD_amount, uint256 BankX_out_min, uint256 COLLATERAL_out_min) external nonReentrant {\\n        require(!pid_controller.bucket3(), \\\"Cannot withdraw in times of deficit\\\");\\n        require(((lastPriceCheck[msg.sender].lastpricecheck+(block_delay)) <= block.number) && (lastPriceCheck[msg.sender].pricecheck), \\\"Must wait for block_delay blocks before redeeming\\\");\\n        require(!redeem_paused, \\\"Redeem Paused\\\");\\n        require(XSD_amount<=mintMapping[msg.sender].amount, \\\"OVERREDEMPTION ERROR\\\");\\n        uint256 xag_usd_price = XSD.xag_usd_price();\\n        uint256 global_collateral_ratio = XSD.global_collateral_ratio();\\n\\n        require(global_collateral_ratio < (1e6) && global_collateral_ratio > 0, \\\"Collateral ratio needs to be between .000001 and .999999\\\");\\n        \\n\\n        uint256 bankx_dollar_value_d18 = XSD_amount - ((XSD_amount*global_collateral_ratio)/(1e6));\\n        bankx_dollar_value_d18 = (bankx_dollar_value_d18*xag_usd_price)/(31103477);\\n        uint256 bankx_amount = (bankx_dollar_value_d18*1e6)/bankx_price;\\n\\n\\n        uint256 collateral_dollar_value = (XSD_amount*global_collateral_ratio)/(1e6);\\n        collateral_dollar_value = (collateral_dollar_value*xag_usd_price)/31103477;\\n        uint256 collateral_amount = (collateral_dollar_value*1e6)/XSD.eth_usd_price();\\n\\n\\n        require(collateral_amount <= (IWETH(WETH).balanceOf(address(this))-unclaimedPoolCollateral), \\\"Not enough collateral in pool\\\");\\n        require(COLLATERAL_out_min <= collateral_amount, \\\"Slippage limit reached [collateral]\\\");\\n        require(BankX_out_min <= bankx_amount, \\\"Slippage limit reached [BankX]\\\");\\n\\n        redeemCollateralBalances[msg.sender] = redeemCollateralBalances[msg.sender]+collateral_dollar_value;\\n        unclaimedPoolCollateral = unclaimedPoolCollateral+collateral_dollar_value;\\n        lastRedeemed[msg.sender] = block.number;\\n        uint total_xsd_amount = mintMapping[msg.sender].amount;\\n        redeemInterestCalc(XSD_amount, msg.sender);\\n        uint current_accum_interest = (XSD_amount*mintMapping[msg.sender].accum_interest)/total_xsd_amount;\\n        redeemBankXBalances[msg.sender] = redeemBankXBalances[msg.sender]+current_accum_interest;\\n        bankx_amount = bankx_amount + ((current_accum_interest*1e6)/bankx_price);\\n        mintMapping[msg.sender].accum_interest = mintMapping[msg.sender].accum_interest - current_accum_interest;\\n        redeemBankXBalances[msg.sender] = redeemBankXBalances[msg.sender]+bankx_dollar_value_d18;\\n        unclaimedPoolBankX = unclaimedPoolBankX+bankx_dollar_value_d18+current_accum_interest;\\n        collat_XSD -= XSD_amount;\\n        lastPriceCheck[msg.sender].pricecheck = false;\\n    \\n        XSD.pool_burn_from(msg.sender, XSD_amount);\\n        BankX.pool_mint(address(this), bankx_amount);\\n    }\\n\\n    // Redeem XSD for BankX. 0% collateral-backed\\n    function redeemAlgorithmicXSD(uint256 XSD_amount, uint256 BankX_out_min) external nonReentrant {\\n        require(!pid_controller.bucket3(), \\\"Cannot withdraw in times of deficit\\\");\\n        require(!redeem_paused, \\\"Redeem Paused\\\");\\n        require(XSD_amount<=mintMapping[msg.sender].amount, \\\"OVERREDEMPTION ERROR\\\");\\n        require(((lastPriceCheck[msg.sender].lastpricecheck+(block_delay)) <= block.number) && (lastPriceCheck[msg.sender].pricecheck), \\\"Must wait for block_delay blocks before redeeming\\\");\\n        require(XSD.global_collateral_ratio() == 0, \\\"Collateral ratio must be 0\\\"); \\n        uint256 bankx_dollar_value_d18 = (XSD_amount*XSD.xag_usd_price())/(31103477);\\n\\n        uint256 bankx_amount = (bankx_dollar_value_d18*1e6)/bankx_price;\\n        \\n        lastRedeemed[msg.sender] = block.number;\\n        uint total_xsd_amount = mintMapping[msg.sender].amount;\\n        require(BankX_out_min <= bankx_amount, \\\"Slippage limit reached\\\");\\n        redeemInterestCalc(XSD_amount, msg.sender);\\n        uint current_accum_interest = XSD_amount*mintMapping[msg.sender].accum_interest/total_xsd_amount; //precision of 6\\n        redeemBankXBalances[msg.sender] = (redeemBankXBalances[msg.sender]+current_accum_interest);\\n        bankx_amount = bankx_amount + ((current_accum_interest*1e6)/bankx_price);\\n        mintMapping[msg.sender].accum_interest = (mintMapping[msg.sender].accum_interest - current_accum_interest);\\n        redeemBankXBalances[msg.sender] = redeemBankXBalances[msg.sender]+bankx_dollar_value_d18;\\n        unclaimedPoolBankX = unclaimedPoolBankX+bankx_dollar_value_d18+current_accum_interest;\\n        collat_XSD -= XSD_amount;\\n        lastPriceCheck[msg.sender].pricecheck = false;\\n        XSD.pool_burn_from(msg.sender, XSD_amount);\\n        BankX.pool_mint(address(this), bankx_amount);\\n    }\\n\\n    // After a redemption happens, transfer the newly minted BankX and owed collateral from this pool\\n    // contract to the user. Redemption is split into two functions to prevent flash loans from being able\\n    // to take out XSD/collateral from the system, use an AMM to trade the new price, and then mint back into the system.\\n    function collectRedemption() external nonReentrant{\\n        require(!pid_controller.bucket3(), \\\"Cannot withdraw in times of deficit\\\");\\n        require(!redeem_paused, \\\"Redeem Paused\\\");\\n        require(((lastRedeemed[msg.sender]+(block_delay)) <= block.number) && ((lastPriceCheck[msg.sender].lastpricecheck+(block_delay)) <= block.number) && (lastPriceCheck[msg.sender].pricecheck), \\\"Must wait for block_delay blocks before redeeming\\\");\\n        uint BankXDollarAmount;\\n        uint CollateralDollarAmount;\\n        uint BankXAmount;\\n        uint CollateralAmount;\\n\\n        // Use Checks-Effects-Interactions pattern\\n        if(redeemBankXBalances[msg.sender] > 0){\\n            BankXDollarAmount = redeemBankXBalances[msg.sender];\\n            BankXAmount = (BankXDollarAmount*1e6)/bankx_price;\\n            redeemBankXBalances[msg.sender] = 0;\\n            unclaimedPoolBankX = unclaimedPoolBankX-BankXDollarAmount;\\n            TransferHelper.safeTransfer(address(BankX), msg.sender, BankXAmount);\\n        }\\n        \\n        if(redeemCollateralBalances[msg.sender] > 0){\\n            CollateralDollarAmount = redeemCollateralBalances[msg.sender];\\n            CollateralAmount = (CollateralDollarAmount*1e6)/XSD.eth_usd_price();\\n            redeemCollateralBalances[msg.sender] = 0;\\n            unclaimedPoolCollateral = unclaimedPoolCollateral-CollateralDollarAmount;\\n            IWETH(WETH).withdraw(CollateralAmount); //try to unwrap eth in the redeem\\n            TransferHelper.safeTransferETH(msg.sender, CollateralAmount);\\n        }\\n        lastPriceCheck[msg.sender].pricecheck = false;\\n    }\\n\\n    // Function can be called by an BankX holder to have the protocol buy back BankX with excess collateral value from a desired collateral pool\\n    // This can also happen if the collateral ratio > 1\\n    // add XSD as a burn option while uXSD value is positive\\n    // need two seperate functions: one for bankx and one for XSD\\n    function buyBackBankX(uint256 BankX_amount,uint256 COLLATERAL_out_min) external{\\n        require(!buyback_paused, \\\"Buyback Paused\\\");\\n        require(((lastPriceCheck[msg.sender].lastpricecheck+(block_delay)) <= block.number) && (lastPriceCheck[msg.sender].pricecheck), \\\"Must wait for block_delay blocks before buyback\\\");\\n        CollateralPoolLibrary.BuybackBankX_Params memory input_params = CollateralPoolLibrary.BuybackBankX_Params(\\n            availableExcessCollatDV(),\\n            bankx_price,\\n            XSD.eth_usd_price(),\\n            BankX_amount\\n        );\\n\\n        (collateral_equivalent_d18) = (CollateralPoolLibrary.calcBuyBackBankX(input_params));\\n\\n        require(COLLATERAL_out_min <= collateral_equivalent_d18, \\\"Slippage limit reached\\\");\\n        lastPriceCheck[msg.sender].pricecheck = false;\\n        // Give the sender their desired collateral and burn the BankX\\n        BankX.pool_burn_from(msg.sender, BankX_amount);\\n        TransferHelper.safeTransfer(address(WETH), address(this), collateral_equivalent_d18);\\n        IWETH(WETH).withdraw(collateral_equivalent_d18);\\n        TransferHelper.safeTransferETH(msg.sender, collateral_equivalent_d18);\\n    }\\n    //buyback with XSD instead of bankx\\n    function buyBackXSD(uint256 XSD_amount, uint256 collateral_out_min) external {\\n        require(!buyback_paused, \\\"Buyback Paused\\\");\\n        require(((lastPriceCheck[msg.sender].lastpricecheck+(block_delay)) <= block.number) && (lastPriceCheck[msg.sender].pricecheck), \\\"Must wait for block_delay blocks before buyback\\\");\\n        if(XSD_amount != 0) require((XSD.totalSupply()+XSD_amount)>collat_XSD, \\\"uXSD MUST BE POSITIVE\\\");\\n\\n        CollateralPoolLibrary.BuybackXSD_Params memory input_params = CollateralPoolLibrary.BuybackXSD_Params(\\n            availableExcessCollatDV(),\\n            xsd_price,\\n            XSD.eth_usd_price(),\\n            XSD_amount\\n        );\\n\\n        (collateral_equivalent_d18) = (CollateralPoolLibrary.calcBuyBackXSD(input_params));\\n\\n        require(collateral_out_min <= collateral_equivalent_d18, \\\"Slippage limit reached\\\");\\n        lastPriceCheck[msg.sender].pricecheck = false;\\n        XSD.pool_burn_from(msg.sender, XSD_amount);\\n        TransferHelper.safeTransfer(address(WETH), address(this), collateral_equivalent_d18);\\n        IWETH(WETH).withdraw(collateral_equivalent_d18);\\n        TransferHelper.safeTransferETH(msg.sender, collateral_equivalent_d18);\\n    }\\n\\n    // Combined into one function due to 24KiB contract memory limit\\n    function setPoolParameters(uint256 new_block_delay, bool _mint_paused, bool _redeem_paused, bool _buyback_paused) external onlyByOwner {\\n        block_delay = new_block_delay;\\n        mint_paused = _mint_paused;\\n        redeem_paused = _redeem_paused;\\n        buyback_paused = _buyback_paused;\\n        emit PoolParametersSet(new_block_delay);\\n    }\\n\\n    function setPIDController(address new_pid_address) external onlyByOwner {\\n        pid_controller = IPIDController(new_pid_address);\\n        pid_address = new_pid_address;\\n    }\\n    function setSmartContractOwner(address _smartcontract_owner) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        require(msg.sender != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    function renounceOwnership() external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        smartcontract_owner = address(0);\\n    }\\n\\n    function resetAddresses(address _xsd_contract_address,\\n        address _bankx_contract_address,\\n        address _bankxweth_pool,\\n        address _xsdweth_pool,\\n        address _WETH) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        require(\\n            (_xsd_contract_address != address(0))\\n            && (_bankx_contract_address != address(0))\\n            && (_WETH != address(0))\\n            && (_bankxweth_pool != address(0))\\n            && (_xsdweth_pool != address(0))\\n        , \\\"Zero address detected\\\"); \\n        XSD = XSDStablecoin(_xsd_contract_address);\\n        BankX = BankXToken(_bankx_contract_address);\\n        xsd_contract_address = _xsd_contract_address;\\n        bankx_contract_address = _bankx_contract_address;\\n        xsdweth_pool = _xsdweth_pool;\\n        bankxweth_pool = _bankxweth_pool;\\n        WETH = _WETH;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event PoolParametersSet(uint256 new_block_delay);\\n\\n}\"\r\n    },\r\n    \"contracts/XSD/Pools/Interfaces/IBankXWETHpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IBankXWETHpool {\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n    function collatDollarBalance() external returns(uint);\\n    function swap(uint amount0Out, uint amount1Out, address to) external;\\n    //function flush() external;\\n    function skim(address to) external;\\n    function sync() external;\\n}\"\r\n    },\r\n    \"contracts/XSD/Pools/Interfaces/IXSDWETHpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IXSDWETHpool {\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n    function collatDollarBalance() external returns (uint);\\n    function swap(uint amount0Out, uint amount1Out, address to) external;\\n    //function flush() external;\\n    function skim(address to) external;\\n    function sync() external;\\n}\"\r\n    },\r\n    \"contracts/Oracle/Interfaces/BankXNFTInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface BankXInterface {\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function pool_mint(address _entity, uint _amount) external;\\n\\n    function pool_burn_from(address _entity, uint _amount) external;\\n\\n    function genesis_supply() external returns (uint);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function updateTVLReached() external;\\n\\n}\"\r\n    },\r\n    \"contracts/Oracle/Interfaces/ICD.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface ICD{\\n    function allocatedSupply() external view returns (uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20/ERC20Custom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n// Due to compiling issues, _name, _symbol, and _decimals were removed\\n\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Custom is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) internal _balances;\\n\\n    mapping (address => mapping (address => uint256)) internal _allowances;\\n\\n    uint256 private _totalSupply;\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.approve(address spender, uint256 amount)\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for `accounts`'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n\\n\\n    /**\\n     * @dev Transfers 'tokens' from 'account' to origin address, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n       require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n        \\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal virtual {\\n        _burn(account, amount);\\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \\\"ERC20: burn amount exceeds allowance\\\"));\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of `from`'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/Oracle/ChainlinkETHUSDPriceConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ncontract ChainlinkETHUSDPriceConsumer {\\n\\n    AggregatorV3Interface internal priceFeed;\\n\\n    constructor() {\\n        priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\n    }\\n\\n    /**\\n     * Returns the latest price\\n     */\\n    function getLatestPrice() public view returns (int) {\\n        (\\n            , \\n            int price,\\n            ,\\n            ,\\n            \\n        ) = priceFeed.latestRoundData();\\n        return price;\\n    }\\n\\n    function getDecimals() public view returns (uint8) {\\n        return priceFeed.decimals();\\n    }\\n}\"\r\n    },\r\n    \"contracts/Oracle/ChainlinkXAGUSDPriceConsumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ncontract ChainlinkXAGUSDPriceConsumer {\\n\\n    AggregatorV3Interface internal priceFeed;\\n\\n\\n    constructor() {\\n        priceFeed = AggregatorV3Interface(0x379589227b15F1a12195D3f2d90bBc9F31f95235);\\n    }\\n\\n    /**\\n     * Returns the latest price\\n     */\\n    function getLatestPrice() public view returns (int) {\\n        (\\n            , \\n            int price,\\n            ,\\n            ,\\n            \\n        ) = priceFeed.latestRoundData();\\n        return price;\\n    }\\n\\n    function getDecimals() public view returns (uint8) {\\n        return priceFeed.decimals();\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BankX/BankXToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\nimport \\\"../ERC20/ERC20Custom.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../XSD/XSDStablecoin.sol\\\";\\n\\ncontract BankXToken is ERC20Custom {\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    string public symbol;\\n    string public name;\\n    uint8 public constant decimals = 18;\\n    \\n    \\n    uint256 public genesis_supply; // 2B is printed upon genesis\\n    address public pool_address; //points to BankX pool address\\n    address public treasury; //stores the genesis supply\\n    address public router;\\n    XSDStablecoin private XSD; //XSD stablecoin instance\\n    address public smartcontract_owner;\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyPools() {\\n       require(XSD.xsd_pools(msg.sender) == true, \\\"Only xsd pools can mint new BankX\\\");\\n        _;\\n    } \\n    \\n    modifier onlyByOwner() {\\n        require(msg.sender == smartcontract_owner, \\\"You are not an owner\\\");\\n        _;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint256 _pool_amount, \\n        uint256 _genesis_supply,\\n        address _treasury,\\n        address _smartcontract_owner\\n    ) {\\n        require((_treasury != address(0)), \\\"Zero address detected\\\"); \\n        name = _name;\\n        symbol = _symbol;\\n        genesis_supply = _genesis_supply + _pool_amount;\\n        treasury = _treasury;\\n        _mint(_msgSender(), _pool_amount);\\n        _mint(treasury, _genesis_supply);\\n        smartcontract_owner = _smartcontract_owner;\\n\\n    \\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function setPool(address new_pool) external onlyByOwner {\\n        require(new_pool != address(0), \\\"Zero address detected\\\");\\n\\n        pool_address = new_pool;\\n    }\\n\\n    function setTreasury(address new_treasury) external onlyByOwner {\\n        require(new_treasury != address(0), \\\"Treasury address cannot be 0\\\");\\n        treasury = new_treasury;\\n    }\\n\\n    function setRouterAddress(address _router) external onlyByOwner {\\n        require(_router != address(0), \\\"Zero address detected\\\");\\n        router = _router;\\n    }\\n    \\n    function setXSDAddress(address xsd_contract_address) external onlyByOwner {\\n        require(xsd_contract_address != address(0), \\\"Zero address detected\\\");\\n\\n        XSD = XSDStablecoin(xsd_contract_address);\\n\\n        emit XSDAddressSet(xsd_contract_address);\\n    }\\n    \\n    function mint(address to, uint256 amount) public onlyPools {\\n        _mint(to, amount);\\n        emit BankXMinted(address(this), to, amount);\\n    }\\n    \\n    function genesisSupply() public view returns(uint256){\\n        return genesis_supply;\\n    }\\n\\n    // This function is what other xsd pools will call to mint new BankX (similar to the XSD mint) \\n    function pool_mint(address m_address, uint256 m_amount) external onlyPools  {        \\n        super._mint(m_address, m_amount);\\n        emit BankXMinted(address(this), m_address, m_amount);\\n    }\\n\\n    // This function is what other xsd pools will call to burn BankX \\n    function pool_burn_from(address b_address, uint256 b_amount) external onlyPools {\\n\\n        super._burnFrom(b_address, b_amount);\\n        emit BankXBurned(b_address, address(this), b_amount);\\n    }\\n    //burn bankx from the pool when bankx is inflationary\\n    function burnpoolBankX(uint _bankx_amount) public {\\n        require(msg.sender == router, \\\"Only Router can access this function\\\");\\n        require(totalSupply()>genesis_supply,\\\"BankX must be deflationary\\\");\\n        super._burn(pool_address, _bankx_amount);\\n        IBankXWETHpool(pool_address).sync();\\n        emit BankXBurned(msg.sender, address(this), _bankx_amount);\\n    }\\n\\n    function setSmartContractOwner(address _smartcontract_owner) external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        require(msg.sender != address(0), \\\"Zero address detected\\\");\\n        smartcontract_owner = _smartcontract_owner;\\n    }\\n\\n    function renounceOwnership() external{\\n        require(msg.sender == smartcontract_owner, \\\"Only the smart contract owner can access this function\\\");\\n        smartcontract_owner = address(0);\\n    }\\n    /* ========== EVENTS ========== */\\n\\n    // Track BankX burned\\n    event BankXBurned(address indexed from, address indexed to, uint256 amount);\\n\\n    // Track BankX minted\\n    event BankXMinted(address indexed from, address indexed to, uint256 amount);\\n    event XSDAddressSet(address addr);\\n}\"\r\n    },\r\n    \"contracts/Oracle/Interfaces/IPIDController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IPIDController{\\n    function bucket1() external view returns (bool);\\n    function bucket2() external view returns (bool);\\n    function bucket3() external view returns (bool);\\n    function diff1() external view returns (uint);\\n    function diff2() external view returns (uint);\\n    function diff3() external view returns (uint);\\n    function amountpaid1() external view returns (uint);\\n    function amountpaid2() external view returns (uint);\\n    function amountpaid3() external view returns (uint);\\n    function bankx_arbi_limit() external view returns (uint);\\n    function xsd_arbi_limit() external view returns (uint);\\n    function bankx_burnable_limit() external view returns (uint);\\n    function xsd_burnable_limit() external view returns (uint);\\n    function amountPaidBankXWETH(uint ethvalue) external;\\n    function amountPaidXSDWETH(uint ethvalue) external;\\n    function amountPaidCollateralPool(uint ethvalue) external;\\n}\"\r\n    },\r\n    \"contracts/XSD/Pools/CollateralPoolLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\nlibrary CollateralPoolLibrary {\\n    // ================ Structs ================\\n    // Needed to lower stack size\\n    struct MintFF_Params {\\n        uint256 bankx_price_usd; \\n        uint256 col_price_usd;\\n        uint256 bankx_amount;\\n        uint256 collateral_amount;\\n        uint256 col_ratio;\\n    }\\n\\n    struct BuybackBankX_Params {\\n        uint256 excess_collateral_dollar_value_d18;\\n        uint256 bankx_price_usd;\\n        uint256 col_price_usd;\\n        uint256 BankX_amount;\\n    }\\n\\n    struct BuybackXSD_Params {\\n        uint256 excess_collateral_dollar_value_d18;\\n        uint256 xsd_price_usd;\\n        uint256 col_price_usd;\\n        uint256 XSD_amount;\\n    }\\n\\n\\n\\n    // ================ Functions ================\\n// xsd is at the price of one gram of silver.\\n    function calcMint1t1XSD(uint256 col_price, uint256 silver_price, uint256 collateral_amount_d18) public pure returns (uint256) {\\n        uint256 gram_price = (silver_price*(1e4))/(311035);\\n        return (collateral_amount_d18*(col_price))/(gram_price); \\n    }\\n// xsd is at the price of one gram of silver\\n    function calcMintAlgorithmicXSD(uint256 bankx_price_usd, uint256 silver_price, uint256 bankx_amount_d18) public pure returns (uint256) {\\n        uint256 gram_price = (silver_price*(1e4))/(311035);\\n        return (bankx_amount_d18*bankx_price_usd)/(gram_price);\\n    }\\n\\n    function calcMintInterest(uint256 XSD_amount,uint256 silver_price,uint256 rate, uint256 accum_interest, uint256 interest_rate, uint256 time, uint256 amount) internal view returns(uint256, uint256, uint256, uint256) {\\n        uint256 gram_price = (silver_price*(1e4))/(311035);\\n        if(time == 0){\\n        interest_rate = rate;\\n        amount = XSD_amount;\\n        time = block.timestamp;\\n        }\\n        else{\\n        uint delta_t = block.timestamp - time;\\n        delta_t = delta_t/(86400); \\n        accum_interest = accum_interest+((amount*gram_price*interest_rate*delta_t)/(365*(1e12)));\\n    \\n        interest_rate = (amount*interest_rate) + (XSD_amount*rate);\\n        amount = amount+XSD_amount;\\n        interest_rate = interest_rate/amount;\\n        time = block.timestamp;\\n        }\\n        return (\\n            accum_interest,\\n            interest_rate,\\n            time, \\n            amount\\n        );\\n    }\\n\\n    function calcRedemptionInterest(uint256 XSD_amount,uint256 silver_price, uint256 accum_interest, uint256 interest_rate, uint256 time, uint256 amount) internal view returns(uint256, uint256, uint256, uint256){\\n        uint256 gram_price = (silver_price*(1e4))/(311035);\\n        uint delta_t = block.timestamp - time;\\n        delta_t = delta_t/(86400);\\n        accum_interest = accum_interest+((amount*gram_price*interest_rate*delta_t)/(365*(1e12)));\\n        amount = amount - XSD_amount;\\n        time = block.timestamp;\\n        return (\\n            accum_interest,\\n            interest_rate,\\n            time, \\n            amount\\n        );\\n    }\\n    \\n    // Must be internal because of the struct\\n    // xsd must be the dollar value of one price of silver\\n    function calcMintFractionalXSD(MintFF_Params memory params) internal pure returns (uint256, uint256) {\\n        // Since solidity truncates division, every division operation must be the last operation in the equation to ensure minimum error\\n        // The contract must check the proper ratio was sent to mint XSD. We do this by seeing the minimum mintable XSD based on each amount \\n        uint256 bankx_dollar_value_d18;\\n        uint256 c_dollar_value_d18;\\n        \\n        // Scoping for stack concerns\\n        {    \\n            // USD amounts of the collateral and the BankX\\n            bankx_dollar_value_d18 = params.bankx_amount*(params.bankx_price_usd)/(1e6);\\n            c_dollar_value_d18 = params.collateral_amount*(params.col_price_usd)/(1e6);\\n\\n        }\\n        uint calculated_bankx_dollar_value_d18 = \\n                    (c_dollar_value_d18*(1e6)/(params.col_ratio))\\n                    -(c_dollar_value_d18);\\n\\n        uint calculated_bankx_needed = calculated_bankx_dollar_value_d18*(1e6)/(params.bankx_price_usd);\\n\\n        return (\\n            (c_dollar_value_d18+calculated_bankx_dollar_value_d18),\\n            calculated_bankx_needed\\n        );\\n    }\\n\\n    function calcRedeem1t1XSD(uint256 col_price_usd,uint256 silver_price, uint256 XSD_amount) public pure returns (uint256,uint256) {\\n        uint256 gram_price = (silver_price*(1e4))/(311035);\\n        return ((XSD_amount*gram_price/1e6),((XSD_amount*gram_price)/col_price_usd));\\n    }\\n\\n    // Must be internal because of the struct\\n    function calcBuyBackBankX(BuybackBankX_Params memory params) internal pure returns (uint256) {\\n        // If the total collateral value is higher than the amount required at the current collateral ratio then buy back up to the possible BankX with the desired collateral\\n        require(params.excess_collateral_dollar_value_d18 > 0, \\\"No excess collateral to buy back!\\\");\\n\\n        // Make sure not to take more than is available\\n        uint256 bankx_dollar_value_d18 = (params.BankX_amount*params.bankx_price_usd);\\n        require((bankx_dollar_value_d18/1e6) <= params.excess_collateral_dollar_value_d18, \\\"You are trying to buy back more than the excess!\\\");\\n\\n        // Get the equivalent amount of collateral based on the market value of BankX provided \\n        uint256 collateral_equivalent_d18 = (bankx_dollar_value_d18)/(params.col_price_usd);\\n        //collateral_equivalent_d18 = collateral_equivalent_d18-((collateral_equivalent_d18*(params.buyback_fee))/(1e6));\\n\\n        return (\\n            collateral_equivalent_d18\\n        );\\n\\n    }\\n\\n    function calcBuyBackXSD(BuybackXSD_Params memory params) internal pure returns (uint256) {\\n        require(params.excess_collateral_dollar_value_d18 > 0, \\\"No excess collateral to buy back!\\\");\\n\\n        uint256 xsd_dollar_value_d18 = params.XSD_amount*(params.xsd_price_usd);\\n        require((xsd_dollar_value_d18/1e6) <= params.excess_collateral_dollar_value_d18, \\\"You are trying to buy more than the excess!\\\");\\n\\n        uint256 collateral_equivalent_d18 = (xsd_dollar_value_d18)/(params.col_price_usd);\\n\\n        return (\\n            collateral_equivalent_d18\\n        );\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/Oracle/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\"\r\n    },\r\n    \"contracts/XSD/Pools/Interfaces/IRewardManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRewardManager {\\nfunction creatorProvideBankXLiquidity() external;\\nfunction creatorProvideXSDLiquidity() external;\\nfunction userProvideBankXLiquidity(address to) external;\\nfunction userProvideXSDLiquidity(address to) external;\\nfunction userProvideCollatPoolLiquidity(address to, uint amount) external;\\nfunction LiquidityRedemption(address pool,address to) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils/UQ112x112.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"BankXWETH_pool_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"XSDWETH_pool_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arbitrage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankx_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateral_pool_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"creatorAddLiquidityETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"creatorAddLiquidityTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bankx_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xsd_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_XSDWETH_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_BankXWETH_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral_pool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reward_manager_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pid_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid_cooldown\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_smartcontract_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_called\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseSwaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pid_cooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reward_manager_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_arbitrage\",\"type\":\"address\"}],\"name\":\"setArbitrageAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bankx_address\",\"type\":\"address\"}],\"name\":\"setBankXAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BankXWETH_pool\",\"type\":\"address\"}],\"name\":\"setBankXPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collateral_pool\",\"type\":\"address\"}],\"name\":\"setCollateralPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pid_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid_cooldown\",\"type\":\"uint256\"}],\"name\":\"setPIDController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reward_manager_address\",\"type\":\"address\"}],\"name\":\"setRewardManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartcontract_owner\",\"type\":\"address\"}],\"name\":\"setSmartContractOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_xsd_address\",\"type\":\"address\"}],\"name\":\"setXSDAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_XSDWETH_pool\",\"type\":\"address\"}],\"name\":\"setXSDPoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartcontract_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"}],\"name\":\"swapBankXForETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bankx_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"swapBankXForXSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"swapETHForBankX\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"swapETHForXSD\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"XSD_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"swapXSDForBankX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"}],\"name\":\"swapXSDForETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"userAddLiquidityETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"userRedeemLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xsd_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Router", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}