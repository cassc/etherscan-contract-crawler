{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\n/// @notice Simple ERC721 implementation with storage hitchhiking.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC721.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol)\r\n///\r\n/// @dev Note:\r\n/// The ERC721 standard allows for self-approvals.\r\n/// For performance, this implementation WILL NOT revert for such actions.\r\n/// Please add any checks with overrides if desired.\r\n///\r\n/// For performance, methods are made payable where permitted by the ERC721 standard.\r\n///\r\n/// For performance, most of the code is manually duplicated and inlined.\r\n/// Overriding internal functions may not alter the functionality of external functions.\r\n/// Please check and override accordingly.\r\n///\r\n/// Please take care when overriding to never violate the ERC721 invariant:\r\n/// the balance of an owner must be always be equal to their number of ownership slots.\r\nabstract contract ERC721 {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev An account can hold up to 4294967295 tokens.\r\n    uint256 internal constant _MAX_ACCOUNT_BALANCE = 0xffffffff;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Only the token owner or an approved account can manage the token.\r\n    error NotOwnerNorApproved();\r\n\r\n    /// @dev The token does not exist.\r\n    error TokenDoesNotExist();\r\n\r\n    /// @dev The token already exists.\r\n    error TokenAlreadyExists();\r\n\r\n    /// @dev Cannot query the balance for the zero address.\r\n    error BalanceQueryForZeroAddress();\r\n\r\n    /// @dev Cannot mint or transfer to the zero address.\r\n    error TransferToZeroAddress();\r\n\r\n    /// @dev The token must be owned by `from`.\r\n    error TransferFromIncorrectOwner();\r\n\r\n    /// @dev The recipient's balance has overflowed.\r\n    error AccountBalanceOverflow();\r\n\r\n    /// @dev Cannot safely transfer to a contract that does not implement\r\n    /// the ERC721Receiver interface.\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Emitted when token `id` is transferred from `from` to `to`.\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\r\n\r\n    /// @dev Emitted when `owner` enables `account` to manage the `id` token.\r\n    event Approval(address indexed owner, address indexed account, uint256 indexed id);\r\n\r\n    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);\r\n\r\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\r\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\r\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\r\n\r\n    /// @dev `keccak256(bytes(\"ApprovalForAll(address,address,bool)\"))`.\r\n    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =\r\n        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The ownership data slot of `id` is given by:\r\n    /// ```\r\n    ///     mstore(0x00, id)\r\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n    ///     let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\r\n    /// ```\r\n    /// Bits Layout:\r\n    /// - [0..159]   `addr`\r\n    /// - [160..255] `extraData`\r\n    ///\r\n    /// The approved address slot is given by: `add(1, ownershipSlot)`.\r\n    ///\r\n    /// See: https://notes.ethereum.org/%40vbuterin/verkle_tree_eip\r\n    ///\r\n    /// The balance slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let balanceSlot := keccak256(0x0c, 0x1c)\r\n    /// ```\r\n    /// Bits Layout:\r\n    /// - [0..31]   `balance`\r\n    /// - [32..255] `aux`\r\n    ///\r\n    /// The `operator` approval slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\r\n    ///     mstore(0x00, owner)\r\n    ///     let operatorApprovalSlot := keccak256(0x0c, 0x30)\r\n    /// ```\r\n    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;\r\n\r\n    /// @dev Pre-shifted and pre-masked constant.\r\n    uint256 private constant _ERC721_MASTER_SLOT_SEED_MASKED = 0x0a5a2e7a00000000;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                      ERC721 METADATA                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the token collection name.\r\n    function name() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the token collection symbol.\r\n    function symbol() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.\r\n    function tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           ERC721                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the owner of token `id`.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function ownerOf(uint256 id) public view virtual returns (address result) {\r\n        result = _ownerOf(id);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(result) {\r\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the number of tokens owned by `owner`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `owner` must not be the zero address.\r\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Revert if the `owner` is the zero address.\r\n            if iszero(owner) {\r\n                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the account approved to manage token `id`.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function getApproved(uint256 id) public view virtual returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, id)\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\r\n            if iszero(shr(96, shl(96, sload(ownershipSlot)))) {\r\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            result := sload(add(1, ownershipSlot))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `account` as the approved account to manage token `id`.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    /// - The caller must be the owner of the token,\r\n    ///   or an approved operator for the token owner.\r\n    ///\r\n    /// Emits an {Approval} event.\r\n    function approve(address account, uint256 id) public payable virtual {\r\n        _approve(msg.sender, account, id);\r\n    }\r\n\r\n    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.\r\n    function isApprovedForAll(address owner, address operator)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x1c, operator)\r\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x30))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.\r\n    ///\r\n    /// Emits an {ApprovalForAll} event.\r\n    function setApprovalForAll(address operator, bool isApproved) public virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Convert to 0 or 1.\r\n            isApproved := iszero(iszero(isApproved))\r\n            // Update the `isApproved` for (`msg.sender`, `operator`).\r\n            mstore(0x1c, operator)\r\n            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)\r\n            mstore(0x00, caller())\r\n            sstore(keccak256(0x0c, 0x30), isApproved)\r\n            // Emit the {ApprovalForAll} event.\r\n            mstore(0x00, isApproved)\r\n            log3(\r\n                0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator))\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    /// - The caller must be the owner of the token, or be approved to manage the token.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transferFrom(address from, address to, uint256 id) public payable virtual {\r\n        _beforeTokenTransfer(from, to, id);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clear the upper 96 bits.\r\n            let bitmaskAddress := shr(96, not(0))\r\n            from := and(bitmaskAddress, from)\r\n            to := and(bitmaskAddress, to)\r\n            // Load the ownership data.\r\n            mstore(0x00, id)\r\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))\r\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\r\n            let ownershipPacked := sload(ownershipSlot)\r\n            let owner := and(bitmaskAddress, ownershipPacked)\r\n            // Revert if `from` is not the owner, or does not exist.\r\n            if iszero(mul(owner, eq(owner, from))) {\r\n                if iszero(owner) {\r\n                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Revert if `to` is the zero address.\r\n            if iszero(to) {\r\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Load, check, and update the token approval.\r\n            {\r\n                mstore(0x00, from)\r\n                let approvedAddress := sload(add(1, ownershipSlot))\r\n                // Revert if the caller is not the owner, nor approved.\r\n                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {\r\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\r\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                        revert(0x1c, 0x04)\r\n                    }\r\n                }\r\n                // Delete the approved address if any.\r\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\r\n            }\r\n            // Update with the new owner.\r\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\r\n            // Decrement the balance of `from`.\r\n            {\r\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\r\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\r\n            }\r\n            // Increment the balance of `to`.\r\n            {\r\n                mstore(0x00, to)\r\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\r\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\r\n                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {\r\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                sstore(toBalanceSlot, toBalanceSlotPacked)\r\n            }\r\n            // Emit the {Transfer} event.\r\n            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\r\n        }\r\n        _afterTokenTransfer(from, to, id);\r\n    }\r\n\r\n    /// @dev Equivalent to `safeTransferFrom(from, to, id, \"\")`.\r\n    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {\r\n        transferFrom(from, to, id);\r\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, \"\");\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    /// - The caller must be the owner of the token, or be approved to manage the token.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)\r\n        public\r\n        payable\r\n        virtual\r\n    {\r\n        transferFrom(from, to, id);\r\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\r\n    }\r\n\r\n    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.\r\n    /// See: https://eips.ethereum.org/EIPS/eip-165\r\n    /// This function call must use less than 30000 gas.\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let s := shr(224, interfaceId)\r\n            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.\r\n            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL QUERY FUNCTIONS                  */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns if token `id` exists.\r\n    function _exists(uint256 id) internal view virtual returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, id)\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            result := shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the owner of token `id`.\r\n    /// Returns the zero address instead of reverting if the token does not exist.\r\n    function _ownerOf(uint256 id) internal view virtual returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, id)\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*            INTERNAL DATA HITCHHIKING FUNCTIONS             */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    // For performance, no events are emitted for the hitchhiking setters.\r\n    // Please emit your own events if required.\r\n\r\n    /// @dev Returns the auxiliary data for `owner`.\r\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\r\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\r\n    function _getAux(address owner) internal view virtual returns (uint224 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := shr(32, sload(keccak256(0x0c, 0x1c)))\r\n        }\r\n    }\r\n\r\n    /// @dev Set the auxiliary data for `owner` to `value`.\r\n    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.\r\n    /// Auxiliary data can be set for any address, even if it does not have any tokens.\r\n    function _setAux(address owner, uint224 value) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            let balanceSlot := keccak256(0x0c, 0x1c)\r\n            let packed := sload(balanceSlot)\r\n            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the extra data for token `id`.\r\n    /// Minting, transferring, burning a token will not change the extra data.\r\n    /// The extra data can be set on a non-existent token.\r\n    function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, id)\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets the extra data for token `id` to `value`.\r\n    /// Minting, transferring, burning a token will not change the extra data.\r\n    /// The extra data can be set on a non-existent token.\r\n    function _setExtraData(uint256 id, uint96 value) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, id)\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\r\n            let packed := sload(ownershipSlot)\r\n            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL MINT FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Mints token `id` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must not exist.\r\n    /// - `to` cannot be the zero address.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _mint(address to, uint256 id) internal virtual {\r\n        _beforeTokenTransfer(address(0), to, id);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clear the upper 96 bits.\r\n            to := shr(96, shl(96, to))\r\n            // Revert if `to` is the zero address.\r\n            if iszero(to) {\r\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Load the ownership data.\r\n            mstore(0x00, id)\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\r\n            let ownershipPacked := sload(ownershipSlot)\r\n            // Revert if the token already exists.\r\n            if shl(96, ownershipPacked) {\r\n                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Update with the owner.\r\n            sstore(ownershipSlot, or(ownershipPacked, to))\r\n            // Increment the balance of the owner.\r\n            {\r\n                mstore(0x00, to)\r\n                let balanceSlot := keccak256(0x0c, 0x1c)\r\n                let balanceSlotPacked := add(sload(balanceSlot), 1)\r\n                if iszero(and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {\r\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                sstore(balanceSlot, balanceSlotPacked)\r\n            }\r\n            // Emit the {Transfer} event.\r\n            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)\r\n        }\r\n        _afterTokenTransfer(address(0), to, id);\r\n    }\r\n\r\n    /// @dev Equivalent to `_safeMint(to, id, \"\")`.\r\n    function _safeMint(address to, uint256 id) internal virtual {\r\n        _safeMint(to, id, \"\");\r\n    }\r\n\r\n    /// @dev Mints token `id` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must not exist.\r\n    /// - `to` cannot be the zero address.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\r\n        _mint(to, id);\r\n        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL BURN FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Equivalent to `_burn(address(0), id)`.\r\n    function _burn(uint256 id) internal virtual {\r\n        _burn(address(0), id);\r\n    }\r\n\r\n    /// @dev Destroys token `id`, using `by`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - If `by` is not the zero address,\r\n    ///   it must be the owner of the token, or be approved to manage the token.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _burn(address by, uint256 id) internal virtual {\r\n        address owner = ownerOf(id);\r\n        _beforeTokenTransfer(owner, address(0), id);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clear the upper 96 bits.\r\n            by := shr(96, shl(96, by))\r\n            // Load the ownership data.\r\n            mstore(0x00, id)\r\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\r\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\r\n            let ownershipPacked := sload(ownershipSlot)\r\n            // Reload the owner in case it is changed in `_beforeTokenTransfer`.\r\n            owner := shr(96, shl(96, ownershipPacked))\r\n            // Revert if the token does not exist.\r\n            if iszero(owner) {\r\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Load and check the token approval.\r\n            {\r\n                mstore(0x00, owner)\r\n                let approvedAddress := sload(add(1, ownershipSlot))\r\n                // If `by` is not the zero address, do the authorization check.\r\n                // Revert if the `by` is not the owner, nor approved.\r\n                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {\r\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\r\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                        revert(0x1c, 0x04)\r\n                    }\r\n                }\r\n                // Delete the approved address if any.\r\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\r\n            }\r\n            // Clear the owner.\r\n            sstore(ownershipSlot, xor(ownershipPacked, owner))\r\n            // Decrement the balance of `owner`.\r\n            {\r\n                let balanceSlot := keccak256(0x0c, 0x1c)\r\n                sstore(balanceSlot, sub(sload(balanceSlot), 1))\r\n            }\r\n            // Emit the {Transfer} event.\r\n            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)\r\n        }\r\n        _afterTokenTransfer(owner, address(0), id);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL APPROVAL FUNCTIONS                 */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns whether `account` is the owner of token `id`, or is approved to manage it.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    function _isApprovedOrOwner(address account, uint256 id)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := 1\r\n            // Clear the upper 96 bits.\r\n            account := shr(96, shl(96, account))\r\n            // Load the ownership data.\r\n            mstore(0x00, id)\r\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))\r\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\r\n            let owner := shr(96, shl(96, sload(ownershipSlot)))\r\n            // Revert if the token does not exist.\r\n            if iszero(owner) {\r\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Check if `account` is the `owner`.\r\n            if iszero(eq(account, owner)) {\r\n                mstore(0x00, owner)\r\n                // Check if `account` is approved to manage the token.\r\n                if iszero(sload(keccak256(0x0c, 0x30))) {\r\n                    result := eq(account, sload(add(1, ownershipSlot)))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the account approved to manage token `id`.\r\n    /// Returns the zero address instead of reverting if the token does not exist.\r\n    function _getApproved(uint256 id) internal view virtual returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, id)\r\n            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)\r\n            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Equivalent to `_approve(address(0), account, id)`.\r\n    function _approve(address account, uint256 id) internal virtual {\r\n        _approve(address(0), account, id);\r\n    }\r\n\r\n    /// @dev Sets `account` as the approved account to manage token `id`, using `by`.\r\n    ///\r\n    /// Requirements:\r\n    /// - Token `id` must exist.\r\n    /// - If `by` is not the zero address, `by` must be the owner\r\n    ///   or an approved operator for the token owner.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _approve(address by, address account, uint256 id) internal virtual {\r\n        assembly {\r\n            // Clear the upper 96 bits.\r\n            let bitmaskAddress := shr(96, not(0))\r\n            account := and(bitmaskAddress, account)\r\n            by := and(bitmaskAddress, by)\r\n            // Load the owner of the token.\r\n            mstore(0x00, id)\r\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\r\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\r\n            let owner := and(bitmaskAddress, sload(ownershipSlot))\r\n            // Revert if the token does not exist.\r\n            if iszero(owner) {\r\n                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // If `by` is not the zero address, do the authorization check.\r\n            // Revert if `by` is not the owner, nor approved.\r\n            if iszero(or(iszero(by), eq(by, owner))) {\r\n                mstore(0x00, owner)\r\n                if iszero(sload(keccak256(0x0c, 0x30))) {\r\n                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n            // Sets `account` as the approved account to manage `id`.\r\n            sstore(add(1, ownershipSlot), account)\r\n            // Emit the {Approval} event.\r\n            log4(0x00, 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)\r\n        }\r\n    }\r\n\r\n    /// @dev Approve or remove the `operator` as an operator for `by`,\r\n    /// without authorization checks.\r\n    ///\r\n    /// Emits an {ApprovalForAll} event.\r\n    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clear the upper 96 bits.\r\n            by := shr(96, shl(96, by))\r\n            operator := shr(96, shl(96, operator))\r\n            // Convert to 0 or 1.\r\n            isApproved := iszero(iszero(isApproved))\r\n            // Update the `isApproved` for (`by`, `operator`).\r\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))\r\n            mstore(0x00, by)\r\n            sstore(keccak256(0x0c, 0x30), isApproved)\r\n            // Emit the {ApprovalForAll} event.\r\n            mstore(0x00, isApproved)\r\n            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Equivalent to `_transfer(address(0), from, to, id)`.\r\n    function _transfer(address from, address to, uint256 id) internal virtual {\r\n        _transfer(address(0), from, to, id);\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    /// - If `by` is not the zero address,\r\n    ///   it must be the owner of the token, or be approved to manage the token.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _transfer(address by, address from, address to, uint256 id) internal virtual {\r\n        _beforeTokenTransfer(from, to, id);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clear the upper 96 bits.\r\n            let bitmaskAddress := shr(96, not(0))\r\n            from := and(bitmaskAddress, from)\r\n            to := and(bitmaskAddress, to)\r\n            by := and(bitmaskAddress, by)\r\n            // Load the ownership data.\r\n            mstore(0x00, id)\r\n            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))\r\n            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))\r\n            let ownershipPacked := sload(ownershipSlot)\r\n            let owner := and(bitmaskAddress, ownershipPacked)\r\n            // Revert if `from` is not the owner, or does not exist.\r\n            if iszero(mul(owner, eq(owner, from))) {\r\n                if iszero(owner) {\r\n                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Revert if `to` is the zero address.\r\n            if iszero(to) {\r\n                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Load, check, and update the token approval.\r\n            {\r\n                mstore(0x00, from)\r\n                let approvedAddress := sload(add(1, ownershipSlot))\r\n                // If `by` is not the zero address, do the authorization check.\r\n                // Revert if the `by` is not the owner, nor approved.\r\n                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {\r\n                    if iszero(sload(keccak256(0x0c, 0x30))) {\r\n                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.\r\n                        revert(0x1c, 0x04)\r\n                    }\r\n                }\r\n                // Delete the approved address if any.\r\n                if approvedAddress { sstore(add(1, ownershipSlot), 0) }\r\n            }\r\n            // Update with the new owner.\r\n            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))\r\n            // Decrement the balance of `from`.\r\n            {\r\n                let fromBalanceSlot := keccak256(0x0c, 0x1c)\r\n                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))\r\n            }\r\n            // Increment the balance of `to`.\r\n            {\r\n                mstore(0x00, to)\r\n                let toBalanceSlot := keccak256(0x0c, 0x1c)\r\n                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)\r\n                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {\r\n                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                sstore(toBalanceSlot, toBalanceSlotPacked)\r\n            }\r\n            // Emit the {Transfer} event.\r\n            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)\r\n        }\r\n        _afterTokenTransfer(from, to, id);\r\n    }\r\n\r\n    /// @dev Equivalent to `_safeTransfer(from, to, id, \"\")`.\r\n    function _safeTransfer(address from, address to, uint256 id) internal virtual {\r\n        _safeTransfer(from, to, id, \"\");\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    /// - The caller must be the owner of the token, or be approved to manage the token.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _safeTransfer(address from, address to, uint256 id, bytes memory data)\r\n        internal\r\n        virtual\r\n    {\r\n        _transfer(address(0), from, to, id);\r\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\r\n    }\r\n\r\n    /// @dev Equivalent to `_safeTransfer(by, from, to, id, \"\")`.\r\n    function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {\r\n        _safeTransfer(by, from, to, id, \"\");\r\n    }\r\n\r\n    /// @dev Transfers token `id` from `from` to `to`.\r\n    ///\r\n    /// Requirements:\r\n    ///\r\n    /// - Token `id` must exist.\r\n    /// - `from` must be the owner of the token.\r\n    /// - `to` cannot be the zero address.\r\n    /// - If `by` is not the zero address,\r\n    ///   it must be the owner of the token, or be approved to manage the token.\r\n    /// - If `to` refers to a smart contract, it must implement\r\n    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)\r\n        internal\r\n        virtual\r\n    {\r\n        _transfer(by, from, to, id);\r\n        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                    HOOKS FOR OVERRIDING                    */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Hook that is called before any token transfers, including minting and burning.\r\n    function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}\r\n\r\n    /// @dev Hook that is called after any token transfers, including minting and burning.\r\n    function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                      PRIVATE HELPERS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns if `a` has bytecode of non-zero length.\r\n    function _hasCode(address a) private view returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := extcodesize(a) // Can handle dirty upper bits.\r\n        }\r\n    }\r\n\r\n    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.\r\n    /// Reverts if the target does not support the function correctly.\r\n    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)\r\n        private\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Prepare the calldata.\r\n            let m := mload(0x40)\r\n            let onERC721ReceivedSelector := 0x150b7a02\r\n            mstore(m, onERC721ReceivedSelector)\r\n            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.\r\n            mstore(add(m, 0x40), shr(96, shl(96, from)))\r\n            mstore(add(m, 0x60), id)\r\n            mstore(add(m, 0x80), 0x80)\r\n            let n := mload(data)\r\n            mstore(add(m, 0xa0), n)\r\n            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }\r\n            // Revert if the call reverts.\r\n            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {\r\n                if returndatasize() {\r\n                    // Bubble up the revert if the call reverts.\r\n                    returndatacopy(0x00, 0x00, returndatasize())\r\n                    revert(0x00, returndatasize())\r\n                }\r\n                mstore(m, 0)\r\n            }\r\n            // Load the returndata and compare it.\r\n            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {\r\n                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Library for converting numbers into strings and other string operations.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\r\nlibrary LibString {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                        CUSTOM ERRORS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The `length` of the output is too small to contain all the hex digits.\r\n    error HexLengthInsufficient();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The constant returned when the `search` is not found in the string.\r\n    uint256 internal constant NOT_FOUND = type(uint256).max;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     DECIMAL OPERATIONS                     */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the base 10 decimal representation of `value`.\r\n    function toString(uint256 value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\r\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\r\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\r\n            // and 3 words for a maximum of 78 digits.\r\n            str := add(mload(0x40), 0x80)\r\n            // Update the free memory pointer to allocate.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end of the memory to calculate the length later.\r\n            let end := str\r\n\r\n            let w := not(0) // Tsk.\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let temp := value } 1 {} {\r\n                str := add(str, w) // `sub(str, 1)`.\r\n                // Write the character to the pointer.\r\n                // The ASCII index of the '0' character is 48.\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                // Keep dividing `temp` until zero.\r\n                temp := div(temp, 10)\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            // Move the pointer 32 bytes leftwards to make room for the length.\r\n            str := sub(str, 0x20)\r\n            // Store the length.\r\n            mstore(str, length)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the base 10 decimal representation of `value`.\r\n    function toString(int256 value) internal pure returns (string memory str) {\r\n        if (value >= 0) {\r\n            return toString(uint256(value));\r\n        }\r\n        unchecked {\r\n            str = toString(uint256(-value));\r\n        }\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We still have some spare memory space on the left,\r\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\r\n            let length := mload(str) // Load the string length.\r\n            mstore(str, 0x2d) // Store the '-' character.\r\n            str := sub(str, 1) // Move back the string pointer by a byte.\r\n            mstore(str, add(length, 1)) // Update the string length.\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   HEXADECIMAL OPERATIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`,\r\n    /// left-padded to an input length of `length` bytes.\r\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\r\n    /// giving a total length of `length * 2 + 2` bytes.\r\n    /// Reverts if `length` is too small for the output to contain all the digits.\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value, length);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`,\r\n    /// left-padded to an input length of `length` bytes.\r\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\r\n    /// giving a total length of `length * 2` bytes.\r\n    /// Reverts if `length` is too small for the output to contain all the digits.\r\n    function toHexStringNoPrefix(uint256 value, uint256 length)\r\n        internal\r\n        pure\r\n        returns (string memory str)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\r\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\r\n            // We add 0x20 to the total and round down to a multiple of 0x20.\r\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\r\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\r\n            // Allocate the memory.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let start := sub(str, add(length, length))\r\n            let w := not(1) // Tsk.\r\n            let temp := value\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for {} 1 {} {\r\n                str := add(str, w) // `sub(str, 2)`.\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                if iszero(xor(str, start)) { break }\r\n            }\r\n\r\n            if temp {\r\n                // Store the function selector of `HexLengthInsufficient()`.\r\n                mstore(0x00, 0x2194895a)\r\n                // Revert with (offset, size).\r\n                revert(0x1c, 0x04)\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := sub(end, str)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 0x20)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    /// As address are 20 bytes long, the output will left-padded to have\r\n    /// a length of `20 * 2 + 2` bytes.\r\n    function toHexString(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\".\r\n    /// The output excludes leading \"0\" from the `toHexString` output.\r\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\r\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\r\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\r\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\r\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\r\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\r\n            let strLength := mload(str) // Get the length.\r\n            str := add(str, o) // Move the pointer, accounting for leading zero.\r\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    /// As address are 20 bytes long, the output will left-padded to have\r\n    /// a length of `20 * 2` bytes.\r\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\r\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\r\n            str := add(mload(0x40), 0x80)\r\n            // Allocate the memory.\r\n            mstore(0x40, add(str, 0x20))\r\n            // Zeroize the slot after the string.\r\n            mstore(str, 0)\r\n\r\n            // Cache the end to calculate the length later.\r\n            let end := str\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let w := not(1) // Tsk.\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let temp := value } 1 {} {\r\n                str := add(str, w) // `sub(str, 2)`.\r\n                mstore8(add(str, 1), mload(and(temp, 15)))\r\n                mstore8(str, mload(and(shr(4, temp), 15)))\r\n                temp := shr(8, temp)\r\n                if iszero(temp) { break }\r\n            }\r\n\r\n            // Compute the string's length.\r\n            let strLength := sub(end, str)\r\n            // Move the pointer and write the length.\r\n            str := sub(str, 0x20)\r\n            mstore(str, strLength)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\r\n    /// and the alphabets are capitalized conditionally according to\r\n    /// https://eips.ethereum.org/EIPS/eip-55\r\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\r\n        str = toHexString(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\r\n            let o := add(str, 0x22)\r\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\r\n            let t := shl(240, 136) // `0b10001000 << 240`\r\n            for { let i := 0 } 1 {} {\r\n                mstore(add(i, i), mul(t, byte(i, hashed)))\r\n                i := add(i, 1)\r\n                if eq(i, 20) { break }\r\n            }\r\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\r\n            o := add(o, 0x20)\r\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\r\n    function toHexString(address value) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(value);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hexadecimal representation of `value`.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            str := mload(0x40)\r\n\r\n            // Allocate the memory.\r\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\r\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\r\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\r\n            mstore(0x40, add(str, 0x80))\r\n\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            str := add(str, 2)\r\n            mstore(str, 40)\r\n\r\n            let o := add(str, 0x20)\r\n            mstore(add(o, 40), 0)\r\n\r\n            value := shl(96, value)\r\n\r\n            // We write the string from rightmost digit to leftmost digit.\r\n            // The following is essentially a do-while loop that also handles the zero case.\r\n            for { let i := 0 } 1 {} {\r\n                let p := add(o, add(i, i))\r\n                let temp := byte(i, value)\r\n                mstore8(add(p, 1), mload(and(temp, 15)))\r\n                mstore8(p, mload(shr(4, temp)))\r\n                i := add(i, 1)\r\n                if eq(i, 20) { break }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hex encoded string from the raw bytes.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\r\n        str = toHexStringNoPrefix(raw);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let strLength := add(mload(str), 2) // Compute the length.\r\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\r\n            str := sub(str, 2) // Move the pointer.\r\n            mstore(str, strLength) // Write the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the hex encoded string from the raw bytes.\r\n    /// The output is encoded using 2 hexadecimal digits per byte.\r\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let length := mload(raw)\r\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\r\n            mstore(str, add(length, length)) // Store the length of the output.\r\n\r\n            // Store \"0123456789abcdef\" in scratch space.\r\n            mstore(0x0f, 0x30313233343536373839616263646566)\r\n\r\n            let o := add(str, 0x20)\r\n            let end := add(raw, length)\r\n\r\n            for {} iszero(eq(raw, end)) {} {\r\n                raw := add(raw, 1)\r\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\r\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\r\n                o := add(o, 2)\r\n            }\r\n            mstore(o, 0) // Zeroize the slot after the string.\r\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   RUNE STRING OPERATIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the number of UTF characters in the string.\r\n    function runeCount(string memory s) internal pure returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if mload(s) {\r\n                mstore(0x00, div(not(0), 255))\r\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\r\n                let o := add(s, 0x20)\r\n                let end := add(o, mload(s))\r\n                for { result := 1 } 1 { result := add(result, 1) } {\r\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\r\n                    if iszero(lt(o, end)) { break }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns if this string is a 7-bit ASCII string.\r\n    /// (i.e. all characters codes are in [0..127])\r\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let mask := shl(7, div(not(0), 255))\r\n            result := 1\r\n            let n := mload(s)\r\n            if n {\r\n                let o := add(s, 0x20)\r\n                let end := add(o, n)\r\n                let last := mload(end)\r\n                mstore(end, 0)\r\n                for {} 1 {} {\r\n                    if and(mask, mload(o)) {\r\n                        result := 0\r\n                        break\r\n                    }\r\n                    o := add(o, 0x20)\r\n                    if iszero(lt(o, end)) { break }\r\n                }\r\n                mstore(end, last)\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   BYTE STRING OPERATIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    // For performance and bytecode compactness, all indices of the following operations\r\n    // are byte (ASCII) offsets, not UTF character offsets.\r\n\r\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\r\n    function replace(string memory subject, string memory search, string memory replacement)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n            let replacementLength := mload(replacement)\r\n\r\n            subject := add(subject, 0x20)\r\n            search := add(search, 0x20)\r\n            replacement := add(replacement, 0x20)\r\n            result := add(mload(0x40), 0x20)\r\n\r\n            let subjectEnd := add(subject, subjectLength)\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\r\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\r\n                let s := mload(search)\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of\r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                mstore(result, t)\r\n                                result := add(result, 1)\r\n                                subject := add(subject, 1)\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Copy the `replacement` one word at a time.\r\n                        for { let o := 0 } 1 {} {\r\n                            mstore(add(result, o), mload(add(replacement, o)))\r\n                            o := add(o, 0x20)\r\n                            if iszero(lt(o, replacementLength)) { break }\r\n                        }\r\n                        result := add(result, replacementLength)\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    mstore(result, t)\r\n                    result := add(result, 1)\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n            }\r\n\r\n            let resultRemainder := result\r\n            result := add(mload(0x40), 0x20)\r\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\r\n            // Copy the rest of the string one word at a time.\r\n            for {} lt(subject, subjectEnd) {} {\r\n                mstore(resultRemainder, mload(subject))\r\n                resultRemainder := add(resultRemainder, 0x20)\r\n                subject := add(subject, 0x20)\r\n            }\r\n            result := sub(result, 0x20)\r\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n            mstore(result, k) // Store the length.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search, uint256 from)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for { let subjectLength := mload(subject) } 1 {} {\r\n                if iszero(mload(search)) {\r\n                    if iszero(gt(from, subjectLength)) {\r\n                        result := from\r\n                        break\r\n                    }\r\n                    result := subjectLength\r\n                    break\r\n                }\r\n                let searchLength := mload(search)\r\n                let subjectStart := add(subject, 0x20)\r\n\r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n\r\n                subject := add(subjectStart, from)\r\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\r\n\r\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\r\n                let s := mload(add(search, 0x20))\r\n\r\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\r\n\r\n                if iszero(lt(searchLength, 0x20)) {\r\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                        if iszero(shr(m, xor(mload(subject), s))) {\r\n                            if eq(keccak256(subject, searchLength), h) {\r\n                                result := sub(subject, subjectStart)\r\n                                break\r\n                            }\r\n                        }\r\n                        subject := add(subject, 1)\r\n                        if iszero(lt(subject, end)) { break }\r\n                    }\r\n                    break\r\n                }\r\n                for {} 1 {} {\r\n                    if iszero(shr(m, xor(mload(subject), s))) {\r\n                        result := sub(subject, subjectStart)\r\n                        break\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, end)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from left to right.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function indexOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        result = indexOf(subject, search, 0);\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from right to left, starting from `from`.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for {} 1 {} {\r\n                result := not(0) // Initialize to `NOT_FOUND`.\r\n                let searchLength := mload(search)\r\n                if gt(searchLength, mload(subject)) { break }\r\n                let w := result\r\n\r\n                let fromMax := sub(mload(subject), searchLength)\r\n                if iszero(gt(fromMax, from)) { from := fromMax }\r\n\r\n                let end := add(add(subject, 0x20), w)\r\n                subject := add(add(subject, 0x20), from)\r\n                if iszero(gt(subject, end)) { break }\r\n                // As this function is not too often used,\r\n                // we shall simply use keccak256 for smaller bytecode size.\r\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\r\n                    if eq(keccak256(subject, searchLength), h) {\r\n                        result := sub(subject, add(end, 1))\r\n                        break\r\n                    }\r\n                    subject := add(subject, w) // `sub(subject, 1)`.\r\n                    if iszero(gt(subject, end)) { break }\r\n                }\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\r\n    /// searching from right to left.\r\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\r\n    function lastIndexOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256 result)\r\n    {\r\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns whether `subject` starts with `search`.\r\n    function startsWith(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            // Just using keccak256 directly is actually cheaper.\r\n            // forgefmt: disable-next-item\r\n            result := and(\r\n                iszero(gt(searchLength, mload(subject))),\r\n                eq(\r\n                    keccak256(add(subject, 0x20), searchLength),\r\n                    keccak256(add(search, 0x20), searchLength)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `subject` ends with `search`.\r\n    function endsWith(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (bool result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let searchLength := mload(search)\r\n            let subjectLength := mload(subject)\r\n            // Whether `search` is not longer than `subject`.\r\n            let withinRange := iszero(gt(searchLength, subjectLength))\r\n            // Just using keccak256 directly is actually cheaper.\r\n            // forgefmt: disable-next-item\r\n            result := and(\r\n                withinRange,\r\n                eq(\r\n                    keccak256(\r\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\r\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\r\n                        searchLength\r\n                    ),\r\n                    keccak256(add(search, 0x20), searchLength)\r\n                )\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `subject` repeated `times`.\r\n    function repeat(string memory subject, uint256 times)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(or(iszero(times), iszero(subjectLength))) {\r\n                subject := add(subject, 0x20)\r\n                result := mload(0x40)\r\n                let output := add(result, 0x20)\r\n                for {} 1 {} {\r\n                    // Copy the `subject` one word at a time.\r\n                    for { let o := 0 } 1 {} {\r\n                        mstore(add(output, o), mload(add(subject, o)))\r\n                        o := add(o, 0x20)\r\n                        if iszero(lt(o, subjectLength)) { break }\r\n                    }\r\n                    output := add(output, subjectLength)\r\n                    times := sub(times, 1)\r\n                    if iszero(times) { break }\r\n                }\r\n                mstore(output, 0) // Zeroize the slot after the string.\r\n                let resultLength := sub(output, add(result, 0x20))\r\n                mstore(result, resultLength) // Store the length.\r\n                // Allocate the memory.\r\n                mstore(0x40, add(result, add(resultLength, 0x20)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\r\n    /// `start` and `end` are byte offsets.\r\n    function slice(string memory subject, uint256 start, uint256 end)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\r\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\r\n            if lt(start, end) {\r\n                result := mload(0x40)\r\n                let resultLength := sub(end, start)\r\n                mstore(result, resultLength)\r\n                subject := add(subject, start)\r\n                let w := not(0x1f)\r\n                // Copy the `subject` one word at a time, backwards.\r\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\r\n                    mstore(add(result, o), mload(add(subject, o)))\r\n                    o := add(o, w) // `sub(o, 0x20)`.\r\n                    if iszero(o) { break }\r\n                }\r\n                // Zeroize the slot after the string.\r\n                mstore(add(add(result, 0x20), resultLength), 0)\r\n                // Allocate memory for the length and the bytes,\r\n                // rounded up to a multiple of 32.\r\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\r\n    /// `start` is a byte offset.\r\n    function slice(string memory subject, uint256 start)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        result = slice(subject, start, uint256(int256(-1)));\r\n    }\r\n\r\n    /// @dev Returns all the indices of `search` in `subject`.\r\n    /// The indices are byte offsets.\r\n    function indicesOf(string memory subject, string memory search)\r\n        internal\r\n        pure\r\n        returns (uint256[] memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let subjectLength := mload(subject)\r\n            let searchLength := mload(search)\r\n\r\n            if iszero(gt(searchLength, subjectLength)) {\r\n                subject := add(subject, 0x20)\r\n                search := add(search, 0x20)\r\n                result := add(mload(0x40), 0x20)\r\n\r\n                let subjectStart := subject\r\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\r\n                let h := 0\r\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\r\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\r\n                let s := mload(search)\r\n                for {} 1 {} {\r\n                    let t := mload(subject)\r\n                    // Whether the first `searchLength % 32` bytes of\r\n                    // `subject` and `search` matches.\r\n                    if iszero(shr(m, xor(t, s))) {\r\n                        if h {\r\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\r\n                                subject := add(subject, 1)\r\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                                continue\r\n                            }\r\n                        }\r\n                        // Append to `result`.\r\n                        mstore(result, sub(subject, subjectStart))\r\n                        result := add(result, 0x20)\r\n                        // Advance `subject` by `searchLength`.\r\n                        subject := add(subject, searchLength)\r\n                        if searchLength {\r\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                            continue\r\n                        }\r\n                    }\r\n                    subject := add(subject, 1)\r\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\r\n                }\r\n                let resultEnd := result\r\n                // Assign `result` to the free memory pointer.\r\n                result := mload(0x40)\r\n                // Store the length of `result`.\r\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\r\n                // Allocate memory for result.\r\n                // We allocate one more word, so this array can be recycled for {split}.\r\n                mstore(0x40, add(resultEnd, 0x20))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\r\n    function split(string memory subject, string memory delimiter)\r\n        internal\r\n        pure\r\n        returns (string[] memory result)\r\n    {\r\n        uint256[] memory indices = indicesOf(subject, delimiter);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let w := not(0x1f)\r\n            let indexPtr := add(indices, 0x20)\r\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\r\n            mstore(add(indicesEnd, w), mload(subject))\r\n            mstore(indices, add(mload(indices), 1))\r\n            let prevIndex := 0\r\n            for {} 1 {} {\r\n                let index := mload(indexPtr)\r\n                mstore(indexPtr, 0x60)\r\n                if iszero(eq(index, prevIndex)) {\r\n                    let element := mload(0x40)\r\n                    let elementLength := sub(index, prevIndex)\r\n                    mstore(element, elementLength)\r\n                    // Copy the `subject` one word at a time, backwards.\r\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\r\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\r\n                        o := add(o, w) // `sub(o, 0x20)`.\r\n                        if iszero(o) { break }\r\n                    }\r\n                    // Zeroize the slot after the string.\r\n                    mstore(add(add(element, 0x20), elementLength), 0)\r\n                    // Allocate memory for the length and the bytes,\r\n                    // rounded up to a multiple of 32.\r\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\r\n                    // Store the `element` into the array.\r\n                    mstore(indexPtr, element)\r\n                }\r\n                prevIndex := add(index, mload(delimiter))\r\n                indexPtr := add(indexPtr, 0x20)\r\n                if iszero(lt(indexPtr, indicesEnd)) { break }\r\n            }\r\n            result := indices\r\n            if iszero(mload(delimiter)) {\r\n                result := add(indices, 0x20)\r\n                mstore(result, sub(mload(indices), 2))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a concatenated string of `a` and `b`.\r\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\r\n    function concat(string memory a, string memory b)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let w := not(0x1f)\r\n            result := mload(0x40)\r\n            let aLength := mload(a)\r\n            // Copy `a` one word at a time, backwards.\r\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\r\n                mstore(add(result, o), mload(add(a, o)))\r\n                o := add(o, w) // `sub(o, 0x20)`.\r\n                if iszero(o) { break }\r\n            }\r\n            let bLength := mload(b)\r\n            let output := add(result, aLength)\r\n            // Copy `b` one word at a time, backwards.\r\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\r\n                mstore(add(output, o), mload(add(b, o)))\r\n                o := add(o, w) // `sub(o, 0x20)`.\r\n                if iszero(o) { break }\r\n            }\r\n            let totalLength := add(aLength, bLength)\r\n            let last := add(add(result, 0x20), totalLength)\r\n            // Zeroize the slot after the string.\r\n            mstore(last, 0)\r\n            // Stores the length.\r\n            mstore(result, totalLength)\r\n            // Allocate memory for the length and the bytes,\r\n            // rounded up to a multiple of 32.\r\n            mstore(0x40, and(add(last, 0x1f), w))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\r\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\r\n    function toCase(string memory subject, bool toUpper)\r\n        internal\r\n        pure\r\n        returns (string memory result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let length := mload(subject)\r\n            if length {\r\n                result := add(mload(0x40), 0x20)\r\n                subject := add(subject, 1)\r\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\r\n                let w := not(0)\r\n                for { let o := length } 1 {} {\r\n                    o := add(o, w)\r\n                    let b := and(0xff, mload(add(subject, o)))\r\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\r\n                    if iszero(o) { break }\r\n                }\r\n                result := mload(0x40)\r\n                mstore(result, length) // Store the length.\r\n                let last := add(add(result, 0x20), length)\r\n                mstore(last, 0) // Zeroize the slot after the string.\r\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns a lowercased copy of the string.\r\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\r\n    function lower(string memory subject) internal pure returns (string memory result) {\r\n        result = toCase(subject, false);\r\n    }\r\n\r\n    /// @dev Returns an UPPERCASED copy of the string.\r\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\r\n    function upper(string memory subject) internal pure returns (string memory result) {\r\n        result = toCase(subject, true);\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within HTML tags.\r\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for {\r\n                let end := add(s, mload(s))\r\n                result := add(mload(0x40), 0x20)\r\n                // Store the bytes of the packed offsets and strides into the scratch space.\r\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\r\n                mstore(0x1f, 0x900094)\r\n                mstore(0x08, 0xc0000000a6ab)\r\n                // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\r\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\r\n            } iszero(eq(s, end)) {} {\r\n                s := add(s, 1)\r\n                let c := and(mload(s), 0xff)\r\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\r\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\r\n                    mstore8(result, c)\r\n                    result := add(result, 1)\r\n                    continue\r\n                }\r\n                let t := shr(248, mload(c))\r\n                mstore(result, mload(and(t, 0x1f)))\r\n                result := add(result, shr(5, t))\r\n            }\r\n            let last := result\r\n            mstore(last, 0) // Zeroize the slot after the string.\r\n            result := mload(0x40)\r\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\r\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\r\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            for {\r\n                let end := add(s, mload(s))\r\n                result := add(mload(0x40), 0x20)\r\n                // Store \"\\\\u0000\" in scratch space.\r\n                // Store \"0123456789abcdef\" in scratch space.\r\n                // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\r\n                // into the scratch space.\r\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\r\n                // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\r\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\r\n            } iszero(eq(s, end)) {} {\r\n                s := add(s, 1)\r\n                let c := and(mload(s), 0xff)\r\n                if iszero(lt(c, 0x20)) {\r\n                    if iszero(and(shl(c, 1), e)) {\r\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\r\n                        mstore8(result, c)\r\n                        result := add(result, 1)\r\n                        continue\r\n                    }\r\n                    mstore8(result, 0x5c) // \"\\\\\".\r\n                    mstore8(add(result, 1), c)\r\n                    result := add(result, 2)\r\n                    continue\r\n                }\r\n                if iszero(and(shl(c, 1), 0x3700)) {\r\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\r\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\r\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\r\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\r\n                    result := add(result, 6)\r\n                    continue\r\n                }\r\n                mstore8(result, 0x5c) // \"\\\\\".\r\n                mstore8(add(result, 1), mload(add(c, 8)))\r\n                result := add(result, 2)\r\n            }\r\n            let last := result\r\n            mstore(last, 0) // Zeroize the slot after the string.\r\n            result := mload(0x40)\r\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\r\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `a` equals `b`.\r\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\r\n        assembly {\r\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\r\n        }\r\n    }\r\n\r\n    /// @dev Packs a single string with its length into a single word.\r\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\r\n    function packOne(string memory a) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // We don't need to zero right pad the string,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result :=\r\n                mul(\r\n                    // Load the length and the bytes.\r\n                    mload(add(a, 0x1f)),\r\n                    // `length != 0 && length < 32`. Abuses underflow.\r\n                    // Assumes that the length is valid and within the block gas limit.\r\n                    lt(sub(mload(a), 1), 0x1f)\r\n                )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks a string packed using {packOne}.\r\n    /// Returns the empty string if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\r\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            result := mload(0x40)\r\n            // Allocate 2 words (1 for the length, 1 for the bytes).\r\n            mstore(0x40, add(result, 0x40))\r\n            // Zeroize the length slot.\r\n            mstore(result, 0)\r\n            // Store the length and bytes.\r\n            mstore(add(result, 0x1f), packed)\r\n            // Right pad with zeroes.\r\n            mstore(add(add(result, 0x20), mload(result)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Packs two strings with their lengths into a single word.\r\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\r\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let aLength := mload(a)\r\n            // We don't need to zero right pad the strings,\r\n            // since this is our own custom non-standard packing scheme.\r\n            result :=\r\n                mul(\r\n                    // Load the length and the bytes of `a` and `b`.\r\n                    or(\r\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\r\n                        mload(sub(add(b, 0x1e), aLength))\r\n                    ),\r\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\r\n                    // Assumes that the lengths are valid and within the block gas limit.\r\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\r\n                )\r\n        }\r\n    }\r\n\r\n    /// @dev Unpacks strings packed using {packTwo}.\r\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\r\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\r\n    function unpackTwo(bytes32 packed)\r\n        internal\r\n        pure\r\n        returns (string memory resultA, string memory resultB)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            resultA := mload(0x40)\r\n            resultB := add(resultA, 0x40)\r\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\r\n            mstore(0x40, add(resultB, 0x40))\r\n            // Zeroize the length slots.\r\n            mstore(resultA, 0)\r\n            mstore(resultB, 0)\r\n            // Store the lengths and bytes.\r\n            mstore(add(resultA, 0x1f), packed)\r\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\r\n            // Right pad with zeroes.\r\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\r\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\r\n        }\r\n    }\r\n\r\n    /// @dev Directly returns `a` without copying.\r\n    function directReturn(string memory a) internal pure {\r\n        assembly {\r\n            // Assumes that the string does not start from the scratch space.\r\n            let retStart := sub(a, 0x20)\r\n            let retSize := add(mload(a), 0x40)\r\n            // Right pad with zeroes. Just in case the string is produced\r\n            // by a method that doesn't zero right pad.\r\n            mstore(add(retStart, retSize), 0)\r\n            // Store the return offset.\r\n            mstore(retStart, 0x20)\r\n            // End the transaction, returning the string.\r\n            return(retStart, retSize)\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Simple single owner authorization mixin.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\r\n///\r\n/// @dev Note:\r\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\r\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\r\n///\r\n/// While the ownable portion follows\r\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\r\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\r\nabstract contract Ownable {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The caller is not authorized to call the function.\r\n    error Unauthorized();\r\n\r\n    /// @dev The `newOwner` cannot be the zero address.\r\n    error NewOwnerIsZeroAddress();\r\n\r\n    /// @dev The `pendingOwner` does not have a valid handover request.\r\n    error NoHandoverRequest();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\r\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\r\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\r\n    /// despite it not being as lightweight as a single argument event.\r\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n    /// @dev An ownership handover to `pendingOwner` has been requested.\r\n    event OwnershipHandoverRequested(address indexed pendingOwner);\r\n\r\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\r\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\r\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\r\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\r\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\r\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\r\n\r\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\r\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\r\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\r\n    /// It is intentionally chosen to be a high value\r\n    /// to avoid collision with lower slots.\r\n    /// The choice of manual storage layout is to enable compatibility\r\n    /// with both regular and upgradeable contracts.\r\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\r\n\r\n    /// The ownership handover slot of `newOwner` is given by:\r\n    /// ```\r\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\r\n    ///     let handoverSlot := keccak256(0x00, 0x20)\r\n    /// ```\r\n    /// It stores the expiry timestamp of the two-step ownership handover.\r\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     INTERNAL FUNCTIONS                     */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Initializes the owner directly without authorization guard.\r\n    /// This function must be called upon initialization,\r\n    /// regardless of whether the contract is upgradeable or not.\r\n    /// This is to enable generalization to both regular and upgradeable contracts,\r\n    /// and to save gas in case the initial owner is not the caller.\r\n    /// For performance reasons, this function will not check if there\r\n    /// is an existing owner.\r\n    function _initializeOwner(address newOwner) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Clean the upper 96 bits.\r\n            newOwner := shr(96, shl(96, newOwner))\r\n            // Store the new value.\r\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\r\n            // Emit the {OwnershipTransferred} event.\r\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\r\n        }\r\n    }\r\n\r\n    /// @dev Sets the owner directly without authorization guard.\r\n    function _setOwner(address newOwner) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ownerSlot := not(_OWNER_SLOT_NOT)\r\n            // Clean the upper 96 bits.\r\n            newOwner := shr(96, shl(96, newOwner))\r\n            // Emit the {OwnershipTransferred} event.\r\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\r\n            // Store the new value.\r\n            sstore(ownerSlot, newOwner)\r\n        }\r\n    }\r\n\r\n    /// @dev Throws if the sender is not the owner.\r\n    function _checkOwner() internal view virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // If the caller is not the stored owner, revert.\r\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\r\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\r\n    /// Override to return a different value if needed.\r\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\r\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\r\n        return 48 * 3600;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\r\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(shl(96, newOwner)) {\r\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows the owner to renounce their ownership.\r\n    function renounceOwnership() public payable virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /// @dev Request a two-step ownership handover to the caller.\r\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\r\n    function requestOwnershipHandover() public payable virtual {\r\n        unchecked {\r\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                // Compute and set the handover slot to `expires`.\r\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n                mstore(0x00, caller())\r\n                sstore(keccak256(0x0c, 0x20), expires)\r\n                // Emit the {OwnershipHandoverRequested} event.\r\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\r\n    function cancelOwnershipHandover() public payable virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and set the handover slot to 0.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            sstore(keccak256(0x0c, 0x20), 0)\r\n            // Emit the {OwnershipHandoverCanceled} event.\r\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\r\n        }\r\n    }\r\n\r\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\r\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\r\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute and set the handover slot to 0.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, pendingOwner)\r\n            let handoverSlot := keccak256(0x0c, 0x20)\r\n            // If the handover does not exist, or has expired.\r\n            if gt(timestamp(), sload(handoverSlot)) {\r\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Set the handover slot to 0.\r\n            sstore(handoverSlot, 0)\r\n        }\r\n        _setOwner(pendingOwner);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                   PUBLIC READ FUNCTIONS                    */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the owner of the contract.\r\n    function owner() public view virtual returns (address result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := sload(not(_OWNER_SLOT_NOT))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\r\n    function ownershipHandoverExpiresAt(address pendingOwner)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the handover slot.\r\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\r\n            mstore(0x00, pendingOwner)\r\n            // Load the handover slot.\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         MODIFIERS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Marks a function as only callable by the owner.\r\n    modifier onlyOwner() virtual {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\nlibrary AddressBook {\r\n    address internal constant MILADY = 0x5Af0D9827E0c53E4799BB226655A1de152A425a5;\r\n    address internal constant REMILIO = 0xD3D9ddd0CF0A5F0BFB8f7fcEAe075DF687eAEBaB;\r\n    address internal constant PIXELADY = 0x8Fc0D90f2C45a5e7f94904075c952e0943CFCCfd;\r\n\r\n    function isMilady(address addr) public view returns (bool) {\r\n        return IERC20(MILADY).balanceOf(addr) > 0 || IERC20(REMILIO).balanceOf(addr) > 0\r\n            || IERC20(PIXELADY).balanceOf(addr) > 0;\r\n    }\r\n}\r\n\r\n/// @notice Milady meme derivative\r\n/// @author @timmbonodiaz\r\n/// @author shout-out @vectorized for the amazing solady lib\r\ncontract Mileidy is ERC721, Ownable {\r\n    /// @notice Thrown when the mint price is not paid\r\n    error MintPriceNotPaid();\r\n\r\n    /// @dev Only miladys can mint for free\r\n    error NotMilady();\r\n\r\n    /// @notice Thrown when the max supply is reached\r\n    error MaxSupply();\r\n\r\n    /// @notice Total supply of the token\r\n    uint256 public constant TOTAL_SUPPLY = 10_000;\r\n\r\n    /// @notice Mint price (non miladys)\r\n    uint256 public constant MINT_PRICE = 0.003 ether;\r\n\r\n    /// @notice Base URI for the token\r\n    string public baseURI;\r\n\r\n    /// @notice Total supply of the token\r\n    uint256 public totalSupply;\r\n\r\n    /// @notice Constructor\r\n    /// @param _baseURI Base URI for the token\r\n    /// @param _owner Owner of the contract\r\n    constructor(string memory _baseURI, address _owner) {\r\n        baseURI = _baseURI;\r\n        _initializeOwner(_owner);\r\n        _safeMint(_owner, ++totalSupply);\r\n    }\r\n\r\n    /// @notice Mint a new token\r\n    /// @param recipient Address of the recipient\r\n    /// @param count Number of tokens to mint\r\n    function mint(address recipient, uint8 count) external payable {\r\n        if (msg.value != (MINT_PRICE * count)) {\r\n            revert MintPriceNotPaid();\r\n        }\r\n        _doMint(recipient, count);\r\n    }\r\n\r\n    /// @notice Free mint for milady holders\r\n    /// @param recipient Address of the recipient\r\n    function mintlady(address recipient) external payable {\r\n        if (!AddressBook.isMilady(msg.sender)) {\r\n            revert NotMilady();\r\n        }\r\n        _doMint(recipient, 1);\r\n    }\r\n\r\n    /// @notice Mint a new token\r\n    /// @param recipient Address of the recipient\r\n    /// @param count Number of tokens to mint\r\n    /// @dev 5% mileidys devs & arts alloc\r\n    function _doMint(address recipient, uint256 count) internal virtual {\r\n        if ((totalSupply + count) > TOTAL_SUPPLY) revert MaxSupply();\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            _safeMint(recipient, ++totalSupply);\r\n            if (totalSupply < TOTAL_SUPPLY && totalSupply % 20 == 0) {\r\n                _safeMint(owner(), ++totalSupply);\r\n            }\r\n        }\r\n\r\n        /// @dev catch alloc edge cases\r\n        if (totalSupply > TOTAL_SUPPLY) revert MaxSupply();\r\n    }\r\n\r\n    /// @notice Get metadata URI for a given token\r\n    /// @param id ID of the token\r\n    /// @return URI unique uri for the token\r\n    function tokenURI(uint256 id) public view virtual override returns (string memory) {\r\n        if (!_exists(id) || bytes(baseURI).length == 0) revert TokenDoesNotExist();\r\n        return string.concat(baseURI, LibString.toString(id));\r\n    }\r\n\r\n    /// @notice Set the base URI for the token\r\n    /// @param _baseURI New base URI\r\n    function setBaseURI(string memory _baseURI) external onlyOwner {\r\n        baseURI = _baseURI;\r\n    }\r\n\r\n    /// @notice Withdraw funds from the contract\r\n    /// @param payee Address of the recipient\r\n    /// @return success Whether the transfer was successful\r\n    function withdraw(address payable payee) external onlyOwner returns (bool success) {\r\n        if (payee == address(0) || payee == address(this)) {\r\n            revert TransferToZeroAddress();\r\n        }\r\n\r\n        uint256 balance = address(this).balance;\r\n\r\n        // slither-disable-next-line low-level-calls\r\n        (success,) = payee.call{value: balance}(\"\");\r\n        return success;\r\n    }\r\n\r\n    /// @notice Name of the token\r\n    function name() public view virtual override returns (string memory) {\r\n        return \"Mileidy\";\r\n    }\r\n\r\n    /// @notice Symbol of the token\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return \"LLADY\";\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccountBalanceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintPriceNotPaid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMilady\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"count\",\"type\":\"uint8\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintlady\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Mileidy", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000a6c2882feefe3ddcb132467c038edcde4d092372000000000000000000000000000000000000000000000000000000000000005968747470733a2f2f6e667473746f726167652e6c696e6b2f697066732f6261667962656964327074366a637577766c736367377872357969666566767061657068746c7765796332336471716c6c336a79747075716775792f00000000000000", "EVMVersion": "Default", "Library": "AddressBook:fe64563b712958d05e1a2f5c95f7ae00a4c8eec7", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://aecabbf103ca7fc8ca1cb46c361fa08ca45f91e56e2774f59dde63e04c49ecc3"}