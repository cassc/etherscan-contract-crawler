{"SourceCode": "/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: migrations/Migration_Aljanah.sol\n*\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/Migration_Aljanah.sol\n* Docs: https://docs.synthetix.io/contracts/migrations/Migration_Aljanah\n*\n* Contract Dependencies: \n*\t- BaseMigration\n*\t- BaseRewardEscrowV2\n*\t- IAddressResolver\n*\t- IRewardEscrow\n*\t- IRewardEscrowV2Storage\n*\t- IRewardsDistribution\n*\t- LegacyOwned\n*\t- Owned\n*\t- State\n* Libraries: \n*\t- SafeCast\n*\t- SafeDecimalMath\n*\t- SafeMath\n*\t- SignedSafeMath\n*\t- VestingEntries\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2024 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity ^0.5.16;\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\ncontract BaseMigration is Owned {\n    constructor(address _owner) internal Owned(_owner) {}\n\n    // safety value to return ownership (anyone can invoke)\n    function returnOwnership(address forContract) public {\n        bytes memory payload = abi.encodeWithSignature(\"nominateNewOwner(address)\", owner);\n\n        // solhint-disable avoid-low-level-calls\n        (bool success, ) = forContract.call(payload);\n\n        if (!success) {\n            // then try legacy way\n            bytes memory legacyPayload = abi.encodeWithSignature(\"nominateOwner(address)\", owner);\n\n            // solhint-disable avoid-low-level-calls\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\n\n            require(legacySuccess, \"Legacy nomination failed\");\n        }\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n\n    function allNetworksDebtInfo()\n        external\n        view\n        returns (\n            uint256 debt,\n            uint256 sharesSupply,\n            bool isStale\n        );\n\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    function liquidationAmounts(address account, bool isSelfLiquidation)\n        external\n        view\n        returns (\n            uint totalRedeemed,\n            uint debtToRemove,\n            uint escrowToLiquidate,\n            uint initialDebtBalance\n        );\n\n    // Restricted: used internally to Synthetix\n    function addSynths(ISynth[] calldata synthsToAdd) external;\n\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external;\n\n    function setCurrentPeriodId(uint128 periodId) external;\n\n    function liquidateAccount(address account, bool isSelfLiquidation)\n        external\n        returns (\n            uint totalRedeemed,\n            uint debtRemoved,\n            uint escrowToLiquidate\n        );\n\n    function issueSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address to,\n        uint amount\n    ) external returns (bool rateInvalid);\n\n    function burnSynthsWithoutDebt(\n        bytes32 currencyKey,\n        address to,\n        uint amount\n    ) external returns (bool rateInvalid);\n\n    function modifyDebtSharesForMigration(address account, uint amount) external;\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\ncontract Proxyable is Owned {\n    // This contract should be treated like an abstract contract\n\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\n    address public messageSender;\n\n    constructor(address payable _proxy) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setProxy(address payable _proxy) external onlyOwner {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setMessageSender(address sender) external onlyProxy {\n        messageSender = sender;\n    }\n\n    modifier onlyProxy {\n        _onlyProxy();\n        _;\n    }\n\n    function _onlyProxy() private view {\n        require(Proxy(msg.sender) == proxy, \"Only the proxy can call\");\n    }\n\n    modifier optionalProxy {\n        _optionalProxy();\n        _;\n    }\n\n    function _optionalProxy() private {\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n    }\n\n    modifier optionalProxy_onlyOwner {\n        _optionalProxy_onlyOwner();\n        _;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _optionalProxy_onlyOwner() private {\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner, \"Owner only function\");\n    }\n\n    event ProxyUpdated(address proxyAddress);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxy\ncontract Proxy is Owned {\n    Proxyable public target;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function setTarget(Proxyable _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function _emit(\n        bytes calldata callData,\n        uint numTopics,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3,\n        bytes32 topic4\n    ) external onlyTarget {\n        uint size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n                case 0 {\n                    log0(add(_callData, 32), size)\n                }\n                case 1 {\n                    log1(add(_callData, 32), size, topic1)\n                }\n                case 2 {\n                    log2(add(_callData, 32), size, topic1, topic2)\n                }\n                case 3 {\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\n                }\n                case 4 {\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n                }\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n    function() external payable {\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\n        target.setMessageSender(msg.sender);\n\n        assembly {\n            let free_ptr := mload(0x40)\n            calldatacopy(free_ptr, 0, calldatasize)\n\n            /* We must explicitly forward ether to the underlying contract as well. */\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n            returndatacopy(free_ptr, 0, returndatasize)\n\n            if iszero(result) {\n                revert(free_ptr, returndatasize)\n            }\n            return(free_ptr, returndatasize)\n        }\n    }\n\n    modifier onlyTarget {\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n        _;\n    }\n\n    event TargetUpdated(Proxyable newTarget);\n}\n\n\ncontract LegacyOwned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        owner = _owner;\n    }\n\n    function nominateOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner);\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\ncontract LegacyTokenState is LegacyOwned {\n    // the address of the contract that can modify balances and allowances\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n    // ERC20 fields.\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    constructor(address _owner, address _associatedContract) public LegacyOwned(_owner) {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    function setAllowance(\n        address tokenOwner,\n        address spender,\n        uint value\n    ) external onlyAssociatedContract {\n        allowance[tokenOwner][spender] = value;\n    }\n\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\n        balanceOf[account] = value;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract);\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address _associatedContract);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/irewardescrow\ninterface IRewardEscrow {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\n\n    function getNextVestingIndex(address account) external view returns (uint);\n\n    // Mutative functions\n    function appendVestingEntry(address account, uint quantity) external;\n\n    function vest() external;\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    // Computes `a - b`, setting the value to 0 if b > a.\n    function floorsub(uint a, uint b) internal pure returns (uint) {\n        return b >= a ? 0 : a - b;\n    }\n\n    /* ---------- Utilities ---------- */\n    /*\n     * Absolute value of the input, returned as a signed number.\n     */\n    function signedAbs(int x) internal pure returns (int) {\n        return x < 0 ? -x : x;\n    }\n\n    /*\n     * Absolute value of the input, returned as an unsigned number.\n     */\n    function abs(int x) internal pure returns (uint) {\n        return uint(signedAbs(x));\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feesBurned(address account) external view returns (uint);\n\n    function feesToBurn(address account) external view returns (uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalFeesBurned() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    function closeSecondary(uint snxBackedDebt, uint debtShareSupply) external;\n\n    function recordFeePaid(uint sUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\ninterface IVirtualSynth {\n    // Views\n    function balanceOfUnderlying(address account) external view returns (uint);\n\n    function rate() external view returns (uint);\n\n    function readyToSettle() external view returns (bool);\n\n    function secsLeftInWaitingPeriod() external view returns (uint);\n\n    function settled() external view returns (bool);\n\n    function synth() external view returns (ISynth);\n\n    // Mutative functions\n    function settle(address account) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\ninterface ISynthetix {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\n\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\n\n    function transferableSynthetix(address account) external view returns (uint transferable);\n\n    function getFirstNonZeroEscrowIndex(address account) external view returns (uint);\n\n    // Mutative Functions\n    function burnSynths(uint amount) external;\n\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\n\n    function burnSynthsToTarget() external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTracking(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTrackingForInitiator(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithVirtual(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode,\n        uint minAmount\n    ) external returns (uint amountReceived);\n\n    function issueMaxSynths() external;\n\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\n\n    function issueSynths(uint amount) external;\n\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\n\n    function mint() external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    // Liquidations\n    function liquidateDelinquentAccount(address account) external returns (bool);\n\n    function liquidateDelinquentAccountEscrowIndex(address account, uint escrowStartIndex) external returns (bool);\n\n    function liquidateSelf() external returns (bool);\n\n    // Restricted Functions\n\n    function mintSecondary(address account, uint amount) external;\n\n    function mintSecondaryRewards(uint amount) external;\n\n    function burnSecondary(address account, uint amount) external;\n\n    function migrateAccountBalances(address account) external returns (uint totalEscrowRevoked, uint totalLiquidBalance);\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/rewardescrow\ncontract RewardEscrow is Owned, IRewardEscrow {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint internal constant TIME_INDEX = 0;\n    uint internal constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(address(_synthetix));\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(address(_feePool));\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    function _numVestingEntries(address account) internal view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) external view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = _numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2] memory) {\n        uint index = getNextVestingIndex(account);\n        if (index == _numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520] memory) {\n        uint[520] memory _result;\n        uint schedules = _numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function _appendVestingEntry(address account, uint quantity) internal {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) external onlyFeePool {\n        _appendVestingEntry(account, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = _numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty > 0) {\n                vestingSchedules[msg.sender][i] = [0, 0];\n                total = total.add(qty);\n            }\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            IERC20(address(synthetix)).transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/irewardsdistribution\ninterface IRewardsDistribution {\n    // Structs\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    // Views\n    function authority() external view returns (address);\n\n    function distributions(uint index) external view returns (address destination, uint amount); // DistributionData\n\n    function distributionsLength() external view returns (uint);\n\n    // Mutative Functions\n    function distributeRewards(uint amount) external returns (bool);\n}\n\n\n// Inheritance\n\n\n// Libraires\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/rewardsdistribution\ncontract RewardsDistribution is Owned, IRewardsDistribution {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the authority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    function distributeRewards(uint amount) external returns (bool) {\n        require(amount > 0, \"Nothing to distribute\");\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(\n            IERC20(synthetixProxy).balanceOf(address(this)) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) && distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n\n                // solhint-disable avoid-low-level-calls\n                (bool success, bytes memory result) = distributions[i].destination.call(payload);\n\n                if (!success) {\n                    // if the error was emitted by the destination contract, bubble\n                    uint len = result.length;\n                    assembly {\n                        revert(add(result, 0x20), len)\n                    }\n                }\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n\n\npragma experimental ABIEncoderV2;\n\nlibrary VestingEntries {\n    struct VestingEntry {\n        uint64 endTime;\n        uint256 escrowAmount;\n    }\n    struct VestingEntryWithID {\n        uint64 endTime;\n        uint256 escrowAmount;\n        uint256 entryID;\n    }\n}\n\n/// SIP-252: this is the interface for immutable V2 escrow (renamed with suffix Frozen).\n/// These sources need to exist here and match on-chain frozen contracts for tests and reference.\n/// the reason for the naming mess is that the immutable LiquidatorRewards expects a working\n/// RewardEscrowV2 resolver entry for its getReward method, so the \"new\" (would be V3)\n/// needs to be found at that entry for liq-rewards to function.\ninterface IRewardEscrowV2Frozen {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedBalance() external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\n\n    function getVestingSchedules(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\n\n    function getAccountVestingEntryIDs(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (uint256[] memory);\n\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\n\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\n\n    // Mutative functions\n    function vest(uint256[] calldata entryIDs) external;\n\n    function createEscrowEntry(\n        address beneficiary,\n        uint256 deposit,\n        uint256 duration\n    ) external;\n\n    function appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) external;\n\n    function migrateVestingSchedule(address _addressToMigrate) external;\n\n    function migrateAccountEscrowBalances(\n        address[] calldata accounts,\n        uint256[] calldata escrowBalances,\n        uint256[] calldata vestedBalances\n    ) external;\n\n    // Account Merging\n    function startMergingWindow() external;\n\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\n\n    function nominateAccountToMerge(address account) external;\n\n    function accountMergingIsOpen() external view returns (bool);\n\n    // L2 Migration\n    function importVestingEntries(\n        address account,\n        uint256 escrowedAmount,\n        VestingEntries.VestingEntry[] calldata vestingEntries\n    ) external;\n\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\n    function burnForMigration(address account, uint256[] calldata entryIDs)\n        external\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\n\n    function nextEntryId() external view returns (uint);\n\n    function vestingSchedules(address account, uint256 entryId) external view returns (VestingEntries.VestingEntry memory);\n\n    function accountVestingEntryIDs(address account, uint256 index) external view returns (uint);\n\n    //function totalEscrowedAccountBalance(address account) external view returns (uint);\n    //function totalVestedAccountBalance(address account) external view returns (uint);\n}\n\n\ninterface IRewardEscrowV2Storage {\n    /// Views\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function totalEscrowedBalance() external view returns (uint);\n\n    function nextEntryId() external view returns (uint);\n\n    function vestingSchedules(address account, uint256 entryId) external view returns (VestingEntries.VestingEntry memory);\n\n    function accountVestingEntryIDs(address account, uint256 index) external view returns (uint);\n\n    /// Mutative\n    function setZeroAmount(address account, uint entryId) external;\n\n    function setZeroAmountUntilTarget(\n        address account,\n        uint startIndex,\n        uint targetAmount\n    )\n        external\n        returns (\n            uint total,\n            uint endIndex,\n            uint lastEntryTime\n        );\n\n    function updateEscrowAccountBalance(address account, int delta) external;\n\n    function updateVestedAccountBalance(address account, int delta) external;\n\n    function updateTotalEscrowedBalance(int delta) external;\n\n    function addVestingEntry(address account, VestingEntries.VestingEntry calldata entry) external returns (uint);\n\n    // setFallbackRewardEscrow is used for configuration but not used by contracts\n}\n\n/// this should remain backwards compatible to IRewardEscrowV2Frozen\n/// ideally this would be done by inheriting from that interface\n/// but solidity v0.5 doesn't support interface inheritance\ninterface IRewardEscrowV2 {\n    // Views\n    function balanceOf(address account) external view returns (uint);\n\n    function numVestingEntries(address account) external view returns (uint);\n\n    function totalEscrowedBalance() external view returns (uint);\n\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\n\n    function totalVestedAccountBalance(address account) external view returns (uint);\n\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\n\n    function getVestingSchedules(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\n\n    function getAccountVestingEntryIDs(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (uint256[] memory);\n\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\n\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\n\n    // Mutative functions\n    function vest(uint256[] calldata entryIDs) external;\n\n    function createEscrowEntry(\n        address beneficiary,\n        uint256 deposit,\n        uint256 duration\n    ) external;\n\n    function appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) external;\n\n    function migrateVestingSchedule(address _addressToMigrate) external;\n\n    function migrateAccountEscrowBalances(\n        address[] calldata accounts,\n        uint256[] calldata escrowBalances,\n        uint256[] calldata vestedBalances\n    ) external;\n\n    // Account Merging\n    function startMergingWindow() external;\n\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\n\n    function nominateAccountToMerge(address account) external;\n\n    function accountMergingIsOpen() external view returns (bool);\n\n    // L2 Migration\n    function importVestingEntries(\n        address account,\n        uint256 escrowedAmount,\n        VestingEntries.VestingEntry[] calldata vestingEntries\n    ) external;\n\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\n    function burnForMigration(address account, uint256[] calldata entryIDs)\n        external\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\n\n    function nextEntryId() external view returns (uint);\n\n    function vestingSchedules(address account, uint256 entryId) external view returns (VestingEntries.VestingEntry memory);\n\n    function accountVestingEntryIDs(address account, uint256 index) external view returns (uint);\n\n    /// below are methods not available in IRewardEscrowV2Frozen\n\n    // revoke entries for liquidations (access controlled to Synthetix)\n    function revokeFrom(\n        address account,\n        address recipient,\n        uint targetAmount,\n        uint startIndex\n    ) external;\n}\n\n\n// SPDX-License-Identifier: MIT\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2020 zOS Global Limited\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*\n * When we upgrade to solidity v0.6.0 or above, we should be able to\n * just do import `\"openzeppelin-solidity-3.0.0/contracts/math/SignedSafeMath.sol\";`\n * wherever this is used.\n */\n\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 private constant _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/state\ncontract State is Owned {\n    // the address of the contract that can modify variables\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n    constructor(address _associatedContract) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n\n// interface for vesting entries\n\n\n// interface\n\n\n// libraries\n\n\n// inheritance\n\n\n/// A contract for reading and writing to/from storage while falling back to values from\n/// previous RewardEscrowV2 contract.\ncontract RewardEscrowV2Storage is IRewardEscrowV2Storage, State {\n    using SafeMath for uint;\n    using SignedSafeMath for int;\n\n    // cheaper storage for L1 compared to original struct, only used for storage\n    // original struct still used in interface for backwards compatibility\n    struct StorageEntry {\n        uint32 endTime;\n        uint224 escrowAmount;\n    }\n\n    /// INTERNAL storage\n\n    // accounts => vesting entries\n    mapping(address => mapping(uint => StorageEntry)) internal _vestingSchedules;\n\n    // accounts => entry ids\n    mapping(address => uint[]) internal _accountVestingEntryIds;\n\n    // accounts => cache of entry counts in fallback contract\n    // this as an int in order to be able to store ZERO_PLACEHOLDER to only cache once\n    mapping(address => int) internal _fallbackCounts;\n\n    // account's total escrow SNX balance (still to vest)\n    // this as an int in order to be able to store ZERO_PLACEHOLDER to prevent reading stale values\n    mapping(address => int) internal _totalEscrowedAccountBalance;\n\n    // account's total vested rewards (vested already)\n    // this as an int in order to be able to store ZERO_PLACEHOLDER to prevent reading stale values\n    mapping(address => int) internal _totalVestedAccountBalance;\n\n    // The total remaining escrow balance of contract\n    uint internal _totalEscrowedBalance;\n\n    /// PUBLIC storage\n\n    // Counter for new vesting entry ids.\n    uint public nextEntryId;\n\n    // id starting from which the new entries are stored in this contact only (and don't need to be read from fallback)\n    uint public firstNonFallbackId;\n\n    // -1 wei is a zero value placeholder in the read-through storage.\n    // needed to prevent writing zeros and reading stale values (0 is used to mean uninitialized)\n    // The alternative of explicit flags introduces its own set problems of ensuring they are written and read\n    // correctly (in addition to the values themselves). It adds code complexity, and gas costs, which when optimized\n    // lead to added coupling between different variables and even more complexity and potential for mistakenly\n    // invalidating or not invalidating the cache.\n    int internal constant ZERO_PLACEHOLDER = -1;\n\n    // previous rewards escrow contract\n    IRewardEscrowV2Frozen public fallbackRewardEscrow;\n\n    // interface view\n    bytes32 public constant CONTRACT_NAME = \"RewardEscrowV2Storage\";\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /// this can happen only once and assumes that IRewardEscrowV2Frozen is in fact Frozen both in code and in\n    /// data(!!) with most mutative methods reverting (e.g. due to blocked transfers)\n    function setFallbackRewardEscrow(IRewardEscrowV2Frozen _fallbackRewardEscrow) external onlyOwner {\n        require(address(fallbackRewardEscrow) == address(0), \"already set\");\n        require(address(_fallbackRewardEscrow) != address(0), \"cannot be zero address\");\n\n        fallbackRewardEscrow = _fallbackRewardEscrow;\n        nextEntryId = _fallbackRewardEscrow.nextEntryId();\n        firstNonFallbackId = nextEntryId;\n\n        // carry over previous balance tracking\n        _totalEscrowedBalance = fallbackRewardEscrow.totalEscrowedBalance();\n    }\n\n    /* ========== VIEWS ========== */\n\n    function vestingSchedules(address account, uint entryId)\n        public\n        view\n        withFallback\n        returns (VestingEntries.VestingEntry memory entry)\n    {\n        // read stored entry\n        StorageEntry memory stored = _vestingSchedules[account][entryId];\n        // convert to previous data size format\n        entry = VestingEntries.VestingEntry({endTime: stored.endTime, escrowAmount: stored.escrowAmount});\n        // read from fallback if this entryId was created in the old contract and wasn't written locally\n        // this assumes that no new entries can be created with endTime = 0 (checked during addVestingEntry)\n        if (entryId < firstNonFallbackId && entry.endTime == 0) {\n            entry = fallbackRewardEscrow.vestingSchedules(account, entryId);\n        }\n        return entry;\n    }\n\n    function accountVestingEntryIDs(address account, uint index) public view withFallback returns (uint) {\n        uint fallbackCount = _fallbackNumVestingEntries(account);\n\n        // this assumes no new entries can be created in the old contract\n        // any added entries in the old contract after this value is cached will be ignored\n        if (index < fallbackCount) {\n            return fallbackRewardEscrow.accountVestingEntryIDs(account, index);\n        } else {\n            return _accountVestingEntryIds[account][index - fallbackCount];\n        }\n    }\n\n    function totalEscrowedBalance() public view withFallback returns (uint) {\n        return _totalEscrowedBalance;\n    }\n\n    function totalEscrowedAccountBalance(address account) public view withFallback returns (uint) {\n        // this as an int in order to be able to store ZERO_PLACEHOLDER which is -1\n        int v = _totalEscrowedAccountBalance[account];\n\n        // 0 should never be stored to prevent reading stale value from fallback\n        if (v == 0) {\n            return fallbackRewardEscrow.totalEscrowedAccountBalance(account);\n        } else {\n            return _readWithZeroPlaceholder(v);\n        }\n    }\n\n    function totalVestedAccountBalance(address account) public view withFallback returns (uint) {\n        // this as an int in order to be able to store ZERO_PLACEHOLDER which is -1\n        int v = _totalVestedAccountBalance[account];\n\n        // 0 should never be stored to prevent reading stale value from fallback\n        if (v == 0) {\n            return fallbackRewardEscrow.totalVestedAccountBalance(account);\n        } else {\n            return _readWithZeroPlaceholder(v);\n        }\n    }\n\n    /// The number of vesting dates in an account's schedule.\n    function numVestingEntries(address account) public view withFallback returns (uint) {\n        /// assumes no enties can be written in frozen contract\n        return _fallbackNumVestingEntries(account) + _accountVestingEntryIds[account].length;\n    }\n\n    /* ========== INTERNAL VIEWS ========== */\n\n    function _fallbackNumVestingEntries(address account) internal view returns (uint) {\n        // cache is used here to prevent external calls during looping\n        int v = _fallbackCounts[account];\n        if (v == 0) {\n            // uninitialized\n            return fallbackRewardEscrow.numVestingEntries(account);\n        } else {\n            return _readWithZeroPlaceholder(v);\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /// zeros out a single entry\n    function setZeroAmount(address account, uint entryId) public withFallback onlyAssociatedContract {\n        // load storage entry\n        StorageEntry storage storedEntry = _vestingSchedules[account][entryId];\n        // endTime is used for cache invalidation\n        uint endTime = storedEntry.endTime;\n        // update endTime from fallback if this is first time this entry is written in this contract\n        if (endTime == 0) {\n            // entry should be in fallback, otherwise it would have endTime or be uninitialized\n            endTime = fallbackRewardEscrow.vestingSchedules(account, entryId).endTime;\n        }\n        _setZeroAmountWithEndTime(account, entryId, endTime);\n    }\n\n    /// zero out multiple entries in order of accountVestingEntryIDs until target is reached (or entries exhausted)\n    /// @param account: account\n    /// @param startIndex: index into accountVestingEntryIDs to start with. NOT an entryID.\n    /// @param targetAmount: amount to try and reach during the iteration, once the amount it reached (and passed)\n    ///     the iteration stops\n    /// @return total: total sum reached, may different from targetAmount (higher if sum is a bit more), lower\n    ///     if target wasn't reached reaching the length of the array\n    /// @return endIndex: the index of the last revoked entry\n    /// @return lastEntryTime: the endTime of the last revoked entry\n    function setZeroAmountUntilTarget(\n        address account,\n        uint startIndex,\n        uint targetAmount\n    )\n        external\n        withFallback\n        onlyAssociatedContract\n        returns (\n            uint total,\n            uint endIndex,\n            uint lastEntryTime\n        )\n    {\n        require(targetAmount > 0, \"targetAmount is zero\");\n\n        // store the count to reduce external calls in accountVestingEntryIDs\n        _cacheFallbackIDCount(account);\n\n        uint numIds = numVestingEntries(account);\n        require(numIds > 0, \"no entries to iterate\");\n        require(startIndex < numIds, \"startIndex too high\");\n\n        uint entryID;\n        uint i;\n        VestingEntries.VestingEntry memory entry;\n        for (i = startIndex; i < numIds; i++) {\n            entryID = accountVestingEntryIDs(account, i);\n            entry = vestingSchedules(account, entryID);\n\n            // skip vested\n            if (entry.escrowAmount > 0) {\n                total = total.add(entry.escrowAmount);\n\n                // set to zero, endTime is correct because vestingSchedules will use fallback if needed\n                _setZeroAmountWithEndTime(account, entryID, entry.endTime);\n\n                if (total >= targetAmount) {\n                    break;\n                }\n            }\n        }\n        i = i == numIds ? i - 1 : i; // i was incremented one extra time if there was no break\n        return (total, i, entry.endTime);\n    }\n\n    function updateEscrowAccountBalance(address account, int delta) external withFallback onlyAssociatedContract {\n        // add / subtract to previous balance\n        int total = int(totalEscrowedAccountBalance(account)).add(delta);\n        require(total >= 0, \"updateEscrowAccountBalance: balance must be positive\");\n        // zero value must never be written, because it is used to signal uninitialized\n        //  writing an actual 0 will result in stale value being read from fallback\n        // casting is safe because checked above\n        _totalEscrowedAccountBalance[account] = _writeWithZeroPlaceholder(uint(total));\n\n        // update the global total\n        updateTotalEscrowedBalance(delta);\n    }\n\n    function updateVestedAccountBalance(address account, int delta) external withFallback onlyAssociatedContract {\n        // add / subtract to previous balance\n        int total = int(totalVestedAccountBalance(account)).add(delta);\n        require(total >= 0, \"updateVestedAccountBalance: balance must be positive\");\n        // zero value must never be written, because it is used to signal uninitialized\n        //  writing an actual 0 will result in stale value being read from fallback\n        // casting is safe because checked above\n        _totalVestedAccountBalance[account] = _writeWithZeroPlaceholder(uint(total));\n    }\n\n    /// this method is unused in contracts (because updateEscrowAccountBalance uses it), but it is here\n    /// for completeness, in case a fix to one of these values is needed (but not the other)\n    function updateTotalEscrowedBalance(int delta) public withFallback onlyAssociatedContract {\n        int total = int(totalEscrowedBalance()).add(delta);\n        require(total >= 0, \"updateTotalEscrowedBalance: balance must be positive\");\n        _totalEscrowedBalance = uint(total);\n    }\n\n    /// append entry for an account\n    function addVestingEntry(address account, VestingEntries.VestingEntry calldata entry)\n        external\n        withFallback\n        onlyAssociatedContract\n        returns (uint)\n    {\n        // zero time is used as read-miss flag in this contract\n        require(entry.endTime != 0, \"vesting target time zero\");\n\n        uint entryId = nextEntryId;\n        // since this is a completely new entry, it's safe to write it directly without checking fallback data\n        _vestingSchedules[account][entryId] = StorageEntry({\n            endTime: uint32(entry.endTime),\n            escrowAmount: uint224(entry.escrowAmount)\n        });\n\n        // append entryId to list of entries for account\n        _accountVestingEntryIds[account].push(entryId);\n\n        // Increment the next entry id.\n        nextEntryId++;\n\n        return entryId;\n    }\n\n    /* ========== INTERNAL MUTATIVE ========== */\n\n    /// zeros out a single entry in local contract with provided time while ensuring\n    /// that endTime is not being stored as zero if it passed as zero\n    function _setZeroAmountWithEndTime(\n        address account,\n        uint entryId,\n        uint endTime\n    ) internal {\n        // load storage entry\n        StorageEntry storage storedEntry = _vestingSchedules[account][entryId];\n        // Impossible edge-case: checking that endTime is not zero (in which case the entry will be\n        // read from fallback again). A zero endTime with non-zero amount is not possible in the old contract\n        // but it's better to check just for completeness still, and write current timestamp (vestable).\n        storedEntry.endTime = uint32(endTime != 0 ? endTime : block.timestamp);\n        storedEntry.escrowAmount = 0;\n    }\n\n    /// this caching is done to prevent repeatedly calling the old contract for number of entries\n    /// during looping\n    function _cacheFallbackIDCount(address account) internal {\n        if (_fallbackCounts[account] == 0) {\n            uint fallbackCount = fallbackRewardEscrow.numVestingEntries(account);\n            // cache the value but don't write zero\n            _fallbackCounts[account] = _writeWithZeroPlaceholder(fallbackCount);\n        }\n    }\n\n    /* ========== HELPER ========== */\n\n    function _writeWithZeroPlaceholder(uint v) internal pure returns (int) {\n        // 0 is uninitialized value, so a special value is used to store an actual 0 (that is initialized)\n        return v == 0 ? ZERO_PLACEHOLDER : int(v);\n    }\n\n    function _readWithZeroPlaceholder(int v) internal pure returns (uint) {\n        // 0 is uninitialized value, so a special value is used to store an actual 0 (that is initialized)\n        return uint(v == ZERO_PLACEHOLDER ? 0 : v);\n    }\n\n    /* ========== Modifier ========== */\n\n    modifier withFallback() {\n        require(address(fallbackRewardEscrow) != address(0), \"fallback not set\");\n        _;\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/contracts/limitedsetup\ncontract LimitedSetup {\n    uint public setupExpiryTime;\n\n    /**\n     * @dev LimitedSetup Constructor.\n     * @param setupDuration The time the setup period will last for.\n     */\n    constructor(uint setupDuration) internal {\n        setupExpiryTime = now + setupDuration;\n    }\n\n    modifier onlyDuringSetup {\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\n        _;\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\n\n\n/**\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/RewardEscrow\ncontract BaseRewardEscrowV2 is Owned, IRewardEscrowV2, LimitedSetup(8 weeks), MixinResolver {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /* Mapping of nominated address to recieve account merging */\n    mapping(address => address) public nominatedReceiver;\n    mapping(address => bool) public permittedEscrowCreators;\n\n    /* Max escrow duration */\n    uint public max_duration = 2 * 52 weeks; // Default max 2 years duration\n\n    /* Max account merging duration */\n    uint public maxAccountMergingDuration = 4 weeks; // Default 4 weeks is max\n\n    /* ========== ACCOUNT MERGING CONFIGURATION ========== */\n\n    uint public accountMergingDuration = 1 weeks;\n\n    uint public accountMergingStartTime;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n    bytes32 private constant CONTRACT_REWARDESCROWV2STORAGE = \"RewardEscrowV2Storage\";\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinResolver(_resolver) {}\n\n    /* ========== VIEWS ======================= */\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\n    }\n\n    function synthetixERC20() internal view returns (IERC20) {\n        return IERC20(requireAndGetAddress(CONTRACT_SYNTHETIX));\n    }\n\n    function issuer() internal view returns (IIssuer) {\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\n    }\n\n    function state() internal view returns (IRewardEscrowV2Storage) {\n        return IRewardEscrowV2Storage(requireAndGetAddress(CONTRACT_REWARDESCROWV2STORAGE));\n    }\n\n    function _notImplemented() internal pure {\n        revert(\"Cannot be run on this layer\");\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    // Note: use public visibility so that it can be invoked in a subclass\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](4);\n        addresses[0] = CONTRACT_SYNTHETIX;\n        addresses[1] = CONTRACT_FEEPOOL;\n        addresses[2] = CONTRACT_ISSUER;\n        addresses[3] = CONTRACT_REWARDESCROWV2STORAGE;\n    }\n\n    /// views forwarded from storage contract\n\n    function numVestingEntries(address account) public view returns (uint) {\n        return state().numVestingEntries(account);\n    }\n\n    function totalEscrowedBalance() public view returns (uint) {\n        return state().totalEscrowedBalance();\n    }\n\n    function totalEscrowedAccountBalance(address account) public view returns (uint) {\n        return state().totalEscrowedAccountBalance(account);\n    }\n\n    function totalVestedAccountBalance(address account) external view returns (uint) {\n        return state().totalVestedAccountBalance(account);\n    }\n\n    function nextEntryId() external view returns (uint) {\n        return state().nextEntryId();\n    }\n\n    function vestingSchedules(address account, uint256 entryId) public view returns (VestingEntries.VestingEntry memory) {\n        return state().vestingSchedules(account, entryId);\n    }\n\n    function accountVestingEntryIDs(address account, uint256 index) public view returns (uint) {\n        return state().accountVestingEntryIDs(account, index);\n    }\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance(account);\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return The vesting entry object and rate per second emission.\n     */\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64 endTime, uint256 escrowAmount) {\n        VestingEntries.VestingEntry memory entry = vestingSchedules(account, entryID);\n        return (entry.endTime, entry.escrowAmount);\n    }\n\n    function getVestingSchedules(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory) {\n        uint256 endIndex = index + pageSize;\n\n        // If index starts after the endIndex return no results\n        if (endIndex <= index) {\n            return new VestingEntries.VestingEntryWithID[](0);\n        }\n\n        // If the page extends past the end of the accountVestingEntryIDs, truncate it.\n        if (endIndex > numVestingEntries(account)) {\n            endIndex = numVestingEntries(account);\n        }\n\n        uint256 n = endIndex - index;\n        uint256 entryID;\n        VestingEntries.VestingEntry memory entry;\n        VestingEntries.VestingEntryWithID[] memory vestingEntries = new VestingEntries.VestingEntryWithID[](n);\n        for (uint256 i; i < n; i++) {\n            entryID = accountVestingEntryIDs(account, i + index);\n\n            entry = vestingSchedules(account, entryID);\n\n            vestingEntries[i] = VestingEntries.VestingEntryWithID({\n                endTime: uint64(entry.endTime),\n                escrowAmount: entry.escrowAmount,\n                entryID: entryID\n            });\n        }\n        return vestingEntries;\n    }\n\n    function getAccountVestingEntryIDs(\n        address account,\n        uint256 index,\n        uint256 pageSize\n    ) external view returns (uint256[] memory) {\n        uint256 endIndex = index + pageSize;\n\n        // If the page extends past the end of the accountVestingEntryIDs, truncate it.\n        uint numEntries = numVestingEntries(account);\n        if (endIndex > numEntries) {\n            endIndex = numEntries;\n        }\n        if (endIndex <= index) {\n            return new uint256[](0);\n        }\n\n        uint256 n = endIndex - index;\n        uint256[] memory page = new uint256[](n);\n        for (uint256 i; i < n; i++) {\n            page[i] = accountVestingEntryIDs(account, i + index);\n        }\n        return page;\n    }\n\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint total) {\n        VestingEntries.VestingEntry memory entry;\n        for (uint i = 0; i < entryIDs.length; i++) {\n            entry = vestingSchedules(account, entryIDs[i]);\n\n            /* Skip entry if escrowAmount == 0 */\n            if (entry.escrowAmount != 0) {\n                uint256 quantity = _claimableAmount(entry);\n\n                /* add quantity to total */\n                total = total.add(quantity);\n            }\n        }\n    }\n\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint) {\n        return _claimableAmount(vestingSchedules(account, entryID));\n    }\n\n    function _claimableAmount(VestingEntries.VestingEntry memory _entry) internal view returns (uint256) {\n        uint256 quantity;\n        if (_entry.escrowAmount != 0) {\n            /* Escrow amounts claimable if block.timestamp equal to or after entry endTime */\n            quantity = block.timestamp >= _entry.endTime ? _entry.escrowAmount : 0;\n        }\n        return quantity;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * Vest escrowed amounts that are claimable\n     * Allows users to vest their vesting entries based on msg.sender\n     */\n    function vest(uint256[] calldata entryIDs) external {\n        // only account can call vest\n        address account = msg.sender;\n\n        uint256 total;\n        VestingEntries.VestingEntry memory entry;\n        uint256 quantity;\n        for (uint i = 0; i < entryIDs.length; i++) {\n            entry = vestingSchedules(account, entryIDs[i]);\n\n            /* Skip entry if escrowAmount == 0 already vested */\n            if (entry.escrowAmount != 0) {\n                quantity = _claimableAmount(entry);\n\n                /* update entry to remove escrowAmount */\n                if (quantity > 0) {\n                    state().setZeroAmount(account, entryIDs[i]);\n                }\n\n                /* add quantity to total */\n                total = total.add(quantity);\n            }\n        }\n\n        /* Transfer vested tokens. Will revert if total > totalEscrowedAccountBalance */\n        if (total != 0) {\n            _subtractAndTransfer(account, account, total);\n            // update total vested\n            state().updateVestedAccountBalance(account, SafeCast.toInt256(total));\n            emit Vested(account, block.timestamp, total);\n        }\n    }\n\n    /// method for revoking vesting entries regardless of schedule to be used for liquidations\n    /// access controlled to only Synthetix contract\n    /// @param account: account\n    /// @param recipient: account to transfer the revoked tokens to\n    /// @param targetAmount: amount of SNX to revoke, when this amount is reached, no more entries are revoked\n    /// @param startIndex: index into accountVestingEntryIDs[account] to start iterating from\n    function revokeFrom(\n        address account,\n        address recipient,\n        uint targetAmount,\n        uint startIndex\n    ) external onlySynthetix {\n        require(account != address(0), \"account not set\");\n        require(recipient != address(0), \"recipient not set\");\n\n        // set stored entries to zero\n        (uint total, uint endIndex, uint lastEntryTime) =\n            state().setZeroAmountUntilTarget(account, startIndex, targetAmount);\n\n        // check total is indeed enough\n        // the caller should have checked for the general amount of escrow\n        // but only here we check that startIndex results in sufficient amount\n        require(total >= targetAmount, \"entries sum less than target\");\n\n        // if too much was revoked\n        if (total > targetAmount) {\n            // only take the precise amount needed by adding a new entry with the difference from total\n            uint refund = total.sub(targetAmount);\n            uint entryID =\n                state().addVestingEntry(\n                    account,\n                    VestingEntries.VestingEntry({endTime: uint64(lastEntryTime), escrowAmount: refund})\n                );\n            // emit event\n            uint duration = lastEntryTime > block.timestamp ? lastEntryTime.sub(block.timestamp) : 0;\n            emit VestingEntryCreated(account, block.timestamp, refund, duration, entryID);\n        }\n\n        // update the aggregates and move the tokens\n        _subtractAndTransfer(account, recipient, targetAmount);\n\n        emit Revoked(account, recipient, targetAmount, startIndex, endIndex);\n    }\n\n    /// remove tokens from vesting aggregates and transfer them to recipient\n    function _subtractAndTransfer(\n        address subtractFrom,\n        address transferTo,\n        uint256 amount\n    ) internal {\n        state().updateEscrowAccountBalance(subtractFrom, -SafeCast.toInt256(amount));\n        synthetixERC20().transfer(transferTo, amount);\n    }\n\n    function setPermittedEscrowCreator(address creator, bool permitted) external onlyOwner {\n        permittedEscrowCreators[creator] = permitted;\n    }\n\n    /**\n     * @notice Create an escrow entry to lock SNX for a given duration in seconds\n     * @dev This call expects that the depositor (msg.sender) has already approved the Reward escrow contract\n     to spend the the amount being escrowed.\n     */\n    function createEscrowEntry(\n        address beneficiary,\n        uint256 deposit,\n        uint256 duration\n    ) external {\n        require(beneficiary != address(0), \"Cannot create escrow with address(0)\");\n        require(permittedEscrowCreators[msg.sender], \"Only permitted escrow creators can create escrow entries\");\n\n        /* Transfer SNX from msg.sender */\n        require(synthetixERC20().transferFrom(msg.sender, address(this), deposit), \"token transfer failed\");\n\n        /* Append vesting entry for the beneficiary address */\n        _appendVestingEntry(beneficiary, deposit, duration);\n    }\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     * @param duration The duration that SNX will be emitted.\n     */\n    function appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) external onlyFeePool {\n        _appendVestingEntry(account, quantity, duration);\n    }\n\n    function _appendVestingEntry(\n        address account,\n        uint256 quantity,\n        uint256 duration\n    ) internal {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n        require(duration > 0 && duration <= max_duration, \"Cannot escrow with 0 duration OR above max_duration\");\n\n        // Add quantity to account's escrowed balance to the total balance\n        state().updateEscrowAccountBalance(account, SafeCast.toInt256(quantity));\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        require(\n            totalEscrowedBalance() <= synthetixERC20().balanceOf(address(this)),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Escrow the tokens for duration. */\n        uint endTime = block.timestamp + duration;\n\n        // store vesting entry\n        uint entryID =\n            state().addVestingEntry(\n                account,\n                VestingEntries.VestingEntry({endTime: uint64(endTime), escrowAmount: quantity})\n            );\n\n        emit VestingEntryCreated(account, block.timestamp, quantity, duration, entryID);\n    }\n\n    /* ========== ACCOUNT MERGING ========== */\n\n    function accountMergingIsOpen() public view returns (bool) {\n        return accountMergingStartTime.add(accountMergingDuration) > block.timestamp;\n    }\n\n    function startMergingWindow() external onlyOwner {\n        accountMergingStartTime = block.timestamp;\n        emit AccountMergingStarted(accountMergingStartTime, accountMergingStartTime.add(accountMergingDuration));\n    }\n\n    function setAccountMergingDuration(uint256 duration) external onlyOwner {\n        require(duration <= maxAccountMergingDuration, \"exceeds max merging duration\");\n        accountMergingDuration = duration;\n        emit AccountMergingDurationUpdated(duration);\n    }\n\n    function setMaxAccountMergingWindow(uint256 duration) external onlyOwner {\n        maxAccountMergingDuration = duration;\n        emit MaxAccountMergingDurationUpdated(duration);\n    }\n\n    function setMaxEscrowDuration(uint256 duration) external onlyOwner {\n        max_duration = duration;\n        emit MaxEscrowDurationUpdated(duration);\n    }\n\n    /* Nominate an account to merge escrow and vesting schedule */\n    function nominateAccountToMerge(address account) external {\n        require(account != msg.sender, \"Cannot nominate own account to merge\");\n        require(accountMergingIsOpen(), \"Account merging has ended\");\n        require(issuer().debtBalanceOf(msg.sender, \"sUSD\") == 0, \"Cannot merge accounts with debt\");\n        nominatedReceiver[msg.sender] = account;\n        emit NominateAccountToMerge(msg.sender, account);\n    }\n\n    function mergeAccount(address from, uint256[] calldata entryIDs) external {\n        require(accountMergingIsOpen(), \"Account merging has ended\");\n        require(issuer().debtBalanceOf(from, \"sUSD\") == 0, \"Cannot merge accounts with debt\");\n        require(nominatedReceiver[from] == msg.sender, \"Address is not nominated to merge\");\n        address to = msg.sender;\n\n        uint256 totalEscrowAmountMerged;\n        VestingEntries.VestingEntry memory entry;\n        for (uint i = 0; i < entryIDs.length; i++) {\n            // retrieve entry\n            entry = vestingSchedules(from, entryIDs[i]);\n\n            /* ignore vesting entries with zero escrowAmount */\n            if (entry.escrowAmount != 0) {\n                // set previous entry amount to zero\n                state().setZeroAmount(from, entryIDs[i]);\n\n                // append new entry for recipient, the new entry will have new entryID\n                state().addVestingEntry(to, entry);\n\n                /* Add the escrowAmount of entry to the totalEscrowAmountMerged */\n                totalEscrowAmountMerged = totalEscrowAmountMerged.add(entry.escrowAmount);\n            }\n        }\n\n        // remove from old account\n        state().updateEscrowAccountBalance(from, -SafeCast.toInt256(totalEscrowAmountMerged));\n        // add to recipient account\n        state().updateEscrowAccountBalance(to, SafeCast.toInt256(totalEscrowAmountMerged));\n\n        emit AccountMerged(from, to, totalEscrowAmountMerged, entryIDs, block.timestamp);\n    }\n\n    /* ========== MIGRATION OLD ESCROW ========== */\n\n    function migrateVestingSchedule(address) external {\n        _notImplemented();\n    }\n\n    function migrateAccountEscrowBalances(\n        address[] calldata,\n        uint256[] calldata,\n        uint256[] calldata\n    ) external {\n        _notImplemented();\n    }\n\n    /* ========== L2 MIGRATION ========== */\n\n    function burnForMigration(address, uint[] calldata) external returns (uint256, VestingEntries.VestingEntry[] memory) {\n        _notImplemented();\n    }\n\n    function importVestingEntries(\n        address,\n        uint256,\n        VestingEntries.VestingEntry[] calldata\n    ) external {\n        _notImplemented();\n    }\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyFeePool() {\n        require(msg.sender == address(feePool()), \"Only the FeePool can perform this action\");\n        _;\n    }\n\n    modifier onlySynthetix() {\n        require(msg.sender == address(synthetixERC20()), \"Only Synthetix\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    event Vested(address indexed beneficiary, uint time, uint value);\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value, uint duration, uint entryID);\n    event MaxEscrowDurationUpdated(uint newDuration);\n    event MaxAccountMergingDurationUpdated(uint newDuration);\n    event AccountMergingDurationUpdated(uint newDuration);\n    event AccountMergingStarted(uint time, uint endTime);\n    event AccountMerged(\n        address indexed accountToMerge,\n        address destinationAddress,\n        uint escrowAmountMerged,\n        uint[] entryIDs,\n        uint time\n    );\n    event NominateAccountToMerge(address indexed account, address destination);\n    event Revoked(address indexed account, address indexed recipient, uint targetAmount, uint startIndex, uint endIndex);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/RewardEscrow\ncontract RewardEscrowV2 is BaseRewardEscrowV2 {\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYNTHETIX_BRIDGE_OPTIMISM = \"SynthetixBridgeToOptimism\";\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(address _owner, address _resolver) public BaseRewardEscrowV2(_owner, _resolver) {}\n\n    /* ========== VIEWS ======================= */\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = BaseRewardEscrowV2.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](1);\n        newAddresses[0] = CONTRACT_SYNTHETIX_BRIDGE_OPTIMISM;\n        return combineArrays(existingAddresses, newAddresses);\n    }\n\n    function synthetixBridgeToOptimism() internal view returns (address) {\n        return requireAndGetAddress(CONTRACT_SYNTHETIX_BRIDGE_OPTIMISM);\n    }\n\n    /* ========== L2 MIGRATION ========== */\n\n    function burnForMigration(address account, uint[] calldata entryIDs)\n        external\n        onlySynthetixBridge\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries)\n    {\n        require(entryIDs.length > 0, \"Entry IDs required\");\n\n        vestingEntries = new VestingEntries.VestingEntry[](entryIDs.length);\n\n        for (uint i = 0; i < entryIDs.length; i++) {\n            VestingEntries.VestingEntry memory entry = vestingSchedules(account, entryIDs[i]);\n\n            // only unvested\n            if (entry.escrowAmount > 0) {\n                vestingEntries[i] = entry;\n\n                /* add the escrow amount to escrowedAccountBalance */\n                escrowedAccountBalance = escrowedAccountBalance.add(entry.escrowAmount);\n\n                /* Delete the vesting entry being migrated */\n                state().setZeroAmount(account, entryIDs[i]);\n            }\n        }\n\n        /**\n         *  update account total escrow balances for migration\n         *  transfer the escrowed SNX being migrated to the L2 deposit contract\n         */\n        if (escrowedAccountBalance > 0) {\n            state().updateEscrowAccountBalance(account, -SafeCast.toInt256(escrowedAccountBalance));\n            synthetixERC20().transfer(synthetixBridgeToOptimism(), escrowedAccountBalance);\n        }\n\n        emit BurnedForMigrationToL2(account, entryIDs, escrowedAccountBalance, block.timestamp);\n\n        return (escrowedAccountBalance, vestingEntries);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlySynthetixBridge() {\n        require(msg.sender == synthetixBridgeToOptimism(), \"Can only be invoked by SynthetixBridgeToOptimism contract\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n    event BurnedForMigrationToL2(address indexed account, uint[] entryIDs, uint escrowedAmountMigrated, uint time);\n}\n\n\ninterface ISynthetixNamedContract {\n    // solhint-disable func-name-mixedcase\n    function CONTRACT_NAME() external view returns (bytes32);\n}\n\n// solhint-disable contract-name-camelcase\ncontract Migration_Aljanah is BaseMigration {\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\n\n    // ----------------------------\n    // EXISTING SYNTHETIX CONTRACTS\n    // ----------------------------\n\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\n    // https://etherscan.io/address/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\n    Proxy public constant proxysynthetix_i = Proxy(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\n    // https://etherscan.io/address/0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD\n    LegacyTokenState public constant tokenstatesynthetix_i = LegacyTokenState(0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD);\n    // https://etherscan.io/address/0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F\n    RewardEscrow public constant rewardescrow_i = RewardEscrow(0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F);\n    // https://etherscan.io/address/0x94433f0DA8B5bfb473Ea8cd7ad10D9c8aef4aB7b\n    RewardsDistribution public constant rewardsdistribution_i = RewardsDistribution(0x94433f0DA8B5bfb473Ea8cd7ad10D9c8aef4aB7b);\n    // https://etherscan.io/address/0x182738BD9eE9810BC11f1c81b07Ec6F3691110BB\n    RewardEscrowV2Storage public constant rewardescrowv2storage_i = RewardEscrowV2Storage(0x182738BD9eE9810BC11f1c81b07Ec6F3691110BB);\n    // https://etherscan.io/address/0xFAd53Cc9480634563E8ec71E8e693Ffd07981d38\n    RewardEscrowV2 public constant rewardescrowv2_i = RewardEscrowV2(0xFAd53Cc9480634563E8ec71E8e693Ffd07981d38);\n\n    // ----------------------------------\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\n    // ----------------------------------\n\n    // https://etherscan.io/address/0xd711709eFc452152B7ad11DbD01ed4B69c9421B3\n    address public constant new_Synthetix_contract = 0xd711709eFc452152B7ad11DbD01ed4B69c9421B3;\n    // https://etherscan.io/address/0xFAd53Cc9480634563E8ec71E8e693Ffd07981d38\n    address public constant new_RewardEscrowV2_contract = 0xFAd53Cc9480634563E8ec71E8e693Ffd07981d38;\n\n    constructor() public BaseMigration(OWNER) {}\n\n    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {\n        contracts = new address[](7);\n        contracts[0]= address(addressresolver_i);\n        contracts[1]= address(proxysynthetix_i);\n        contracts[2]= address(tokenstatesynthetix_i);\n        contracts[3]= address(rewardescrow_i);\n        contracts[4]= address(rewardsdistribution_i);\n        contracts[5]= address(rewardescrowv2storage_i);\n        contracts[6]= address(rewardescrowv2_i);\n    }\n\n    function migrate() external onlyOwner {\n\n        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes\n        acceptAll();\n\n        // MIGRATION\n        // Import all new contracts into the address resolver;\n        addressresolver_importAddresses_0();\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;\n        addressresolver_rebuildCaches_1();\n        // Ensure the SNX proxy has the correct Synthetix target set;\n        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));\n        // Ensure the Synthetix contract can write to its TokenState contract;\n        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);\n        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;\n        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));\n        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;\n        rewardsdistribution_i.setAuthority(new_Synthetix_contract);\n        // Ensure that RewardEscrowV2 contract is allowed to write to RewardEscrowV2Storage;\n        rewardescrowv2storage_i.setAssociatedContract(new_RewardEscrowV2_contract);\n        // Ensure the RewardsDistribution can read the RewardEscrowV2 address;\n        rewardsdistribution_i.setRewardEscrow(new_RewardEscrowV2_contract);\n        // Allow escrow entry creation by LiquidatorRewards;\n        rewardescrowv2_i.setPermittedEscrowCreator(0xf79603a71144e415730C1A6f57F366E4Ea962C00, true);\n\n        // NOMINATE OWNERSHIP back to owner for aforementioned contracts\n        nominateAll();\n    }\n\n    function acceptAll() internal {\n        address[] memory contracts = contractsRequiringOwnership();\n        for (uint i = 0; i < contracts.length; i++) {\n            Owned(contracts[i]).acceptOwnership();\n        }\n    }\n\n    function nominateAll() internal {\n        address[] memory contracts = contractsRequiringOwnership();\n        for (uint i = 0; i < contracts.length; i++) {\n            returnOwnership(contracts[i]);\n        }\n    }\n\n    \n    function addressresolver_importAddresses_0() internal {\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](2);\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\"Synthetix\");\n        addressresolver_importAddresses_names_0_0[1] = bytes32(\"RewardEscrowV2\");\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](2);\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_Synthetix_contract);\n        addressresolver_importAddresses_destinations_0_1[1] = address(new_RewardEscrowV2_contract);\n        addressresolver_i.importAddresses(addressresolver_importAddresses_names_0_0, addressresolver_importAddresses_destinations_0_1);\n    }\n\n    \n    function addressresolver_rebuildCaches_1() internal {\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](10);\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(new_RewardEscrowV2_contract);\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0x8e9757479D5ad4E7f9d951B60d39F5220b893d6c);\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(0xf79603a71144e415730C1A6f57F366E4Ea962C00);\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(0xaeA0065E146FD75Dc24465961a583827284D405a);\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(0xca68a3D663483515a9D434E854AB59A41b3A523c);\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(0x62922670313bf6b41C580143d1f6C173C5C20019);\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(0x39Ea01a0298C315d149a490E34B59Dbf2EC7e48F);\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(0x94f864e55c77E07C2C7BF7bFBc334b7a8123442A);\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(new_Synthetix_contract);\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(0x83105D7CDd2fd9b8185BFF1cb56bB1595a618618);\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\n    }\n}\n\n    ", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRequiringOwnership\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_RewardEscrowV2_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Synthetix_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysynthetix_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forContract\",\"type\":\"address\"}],\"name\":\"returnOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrow_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrow\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrowv2_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrowV2\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrowv2storage_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrowV2Storage\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsdistribution_i\",\"outputs\":[{\"internalType\":\"contract RewardsDistribution\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesynthetix_i\",\"outputs\":[{\"internalType\":\"contract LegacyTokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Migration_Aljanah", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}