{"SourceCode": "# @version 0.3.9\r\n\"\"\"\r\n@title Curve Momentum Bot\r\n@license Apache 2.0\r\n@author Volume.finance\r\n\"\"\"\r\nstruct Deposit:\r\n    route: address[9]\r\n    swap_params: uint256[3][4]\r\n    amount: uint256\r\n    pools: address[4]\r\n    depositor: address\r\n\r\nenum WithdrawType:\r\n    CANCEL\r\n    PROFIT_TAKING\r\n    STOP_LOSS\r\n\r\ninterface ERC20:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n\r\ninterface WrappedEth:\r\n    def deposit(): payable\r\n\r\ninterface CurveSwapRouter:\r\n    def exchange_multiple(\r\n        _route: address[9],\r\n        _swap_params: uint256[3][4],\r\n        _amount: uint256,\r\n        _expected: uint256,\r\n        _pools: address[4]=[ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS, ZERO_ADDRESS],\r\n        _receiver: address=msg.sender\r\n    ) -> uint256: payable\r\n\r\nevent Deposited:\r\n    deposit_id: uint256\r\n    token0: address\r\n    token1: address\r\n    amount0: uint256\r\n    amount1: uint256\r\n    depositor: address\r\n    profit_taking: uint256\r\n    stop_loss: uint256\r\n\r\nevent Withdrawn:\r\n    deposit_id: uint256\r\n    withdrawer: address\r\n    withdraw_type: WithdrawType\r\n    withdraw_amount: uint256\r\n\r\nevent UpdateCompass:\r\n    old_compass: address\r\n    new_compass: address\r\n\r\nevent UpdateRefundWallet:\r\n    old_refund_wallet: address\r\n    new_refund_wallet: address\r\n\r\nevent UpdateFee:\r\n    old_fee: uint256\r\n    new_fee: uint256\r\n\r\nevent SetPaloma:\r\n    paloma: bytes32\r\n\r\nevent UpdateServiceFeeCollector:\r\n    old_service_fee_collector: address\r\n    new_service_fee_collector: address\r\n\r\nVETH: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE # Virtual ETH\r\nMAX_SIZE: constant(uint256) = 8\r\nROUTER: immutable(address)\r\ncompass: public(address)\r\ndeposit_size: public(uint256)\r\ndeposits: public(HashMap[uint256, Deposit])\r\nrefund_wallet: public(address)\r\nfee: public(uint256)\r\npaloma: public(bytes32)\r\nservice_fee_collector: public(address)\r\n\r\n@external\r\ndef __init__(_compass: address, _router: address, _refund_wallet: address, _fee: uint256, _service_fee_collector: address):\r\n    self.compass = _compass\r\n    ROUTER = _router\r\n    self.refund_wallet = _refund_wallet\r\n    self.fee = _fee\r\n    self.service_fee_collector = _service_fee_collector\r\n    log UpdateCompass(empty(address), _compass)\r\n    log UpdateRefundWallet(empty(address), _refund_wallet)\r\n    log UpdateFee(0, _fee)\r\n    log UpdateServiceFeeCollector(empty(address), _service_fee_collector)\r\n\r\n@internal\r\ndef _safe_approve(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"approve(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed approve\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed approve\r\n\r\n@internal\r\ndef _safe_transfer(_token: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_to, _value, method_id=method_id(\"transfer(address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transfer\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed transfer\r\n\r\n@internal\r\ndef _safe_transfer_from(_token: address, _from: address, _to: address, _value: uint256):\r\n    _response: Bytes[32] = raw_call(\r\n        _token,\r\n        _abi_encode(_from, _to, _value, method_id=method_id(\"transferFrom(address,address,uint256)\")),\r\n        max_outsize=32\r\n    )  # dev: failed transferFrom\r\n    if len(_response) > 0:\r\n        assert convert(_response, bool) # dev: failed transferFrom\r\n\r\n@external\r\n@payable\r\n@nonreentrant(\"lock\")\r\ndef deposit(route: address[9], swap_params: uint256[3][4], amount: uint256, expected: uint256, pools: address[4], profit_taking: uint256, stop_loss: uint256):\r\n    _value: uint256 = msg.value\r\n    _fee: uint256 = self.fee\r\n    assert _value >= _fee, \"Insufficient fee\"\r\n    assert self.paloma != empty(bytes32), \"Paloma not set\"\r\n    send(self.refund_wallet, _fee)\r\n    _value = unsafe_sub(_value, _fee)\r\n    token0: address = route[0]\r\n    amount1: uint256 = 0\r\n    if token0 == VETH:\r\n        assert _value >= amount, \"Insufficient deposit\"\r\n        if _value > amount:\r\n            send(msg.sender, unsafe_sub(_value, amount))\r\n        amount1 = CurveSwapRouter(ROUTER).exchange_multiple(route, swap_params, amount, expected, pools, self, value=amount)\r\n    else:\r\n        send(msg.sender, _value)\r\n        self._safe_transfer_from(token0, msg.sender, self, amount)\r\n        self._safe_approve(token0, ROUTER, amount)\r\n        amount1 = CurveSwapRouter(ROUTER).exchange_multiple(route, swap_params, amount, expected, pools, self)\r\n    assert amount1 > 0, \"Insufficient deposit\"\r\n    deposit: Deposit = Deposit({\r\n        route: empty(address[9]),\r\n        swap_params: empty(uint256[3][4]),\r\n        amount: amount1,\r\n        pools: empty(address[4]),\r\n        depositor: msg.sender\r\n    })\r\n    j: uint256 = 0\r\n    for i in range(4):\r\n        if route[unsafe_sub(8, unsafe_mul(i, 2))] == empty(address):\r\n            continue\r\n        if j == 0:\r\n            deposit.route[0] = route[unsafe_sub(8, unsafe_mul(i, 2))]\r\n        deposit.route[unsafe_add(unsafe_mul(j, 2), 1)] = route[unsafe_sub(7, unsafe_mul(i, 2))]\r\n        deposit.route[unsafe_add(unsafe_mul(j, 2), 2)] = route[unsafe_sub(6, unsafe_mul(i, 2))]\r\n        deposit.swap_params[j][0] = swap_params[unsafe_sub(3, i)][1]\r\n        deposit.swap_params[j][1] = swap_params[unsafe_sub(3, i)][0]\r\n        deposit.swap_params[j][2] = swap_params[unsafe_sub(3, i)][2]\r\n        deposit.pools[j] = pools[unsafe_sub(3, i)]\r\n        j = unsafe_add(j, 1)\r\n    deposit_id: uint256 = self.deposit_size\r\n    self.deposits[deposit_id] = deposit\r\n    self.deposit_size = unsafe_add(deposit_id, 1)\r\n    log Deposited(deposit_id, route[0], deposit.route[0], amount, amount1, msg.sender, profit_taking, stop_loss)\r\n\r\n@internal\r\n@nonreentrant(\"lock\")\r\ndef _withdraw(deposit_id: uint256, expected: uint256, withdraw_type: WithdrawType) -> uint256:\r\n    deposit: Deposit = self.deposits[deposit_id]\r\n    if withdraw_type == WithdrawType.CANCEL:\r\n        assert msg.sender == deposit.depositor, \"Unauthorized\"\r\n    self.deposits[deposit_id] = Deposit({\r\n        route: empty(address[9]),\r\n        swap_params: empty(uint256[3][4]),\r\n        amount: empty(uint256),\r\n        pools: empty(address[4]),\r\n        depositor: msg.sender\r\n    })\r\n    assert deposit.amount > 0, \"Empty deposit\"\r\n    last_token: address = empty(address)\r\n    for i in range(4):\r\n        last_token = deposit.route[unsafe_sub(8, unsafe_add(i, i))]\r\n        if last_token != empty(address):\r\n            break\r\n    amount0: uint256 = 0\r\n    if deposit.route[0] == VETH:\r\n        amount0 = CurveSwapRouter(ROUTER).exchange_multiple(deposit.route, deposit.swap_params, deposit.amount, expected, deposit.pools, self, value=deposit.amount)\r\n        actual_amount: uint256 = unsafe_div(amount0 * 995, 1000)\r\n        self._safe_transfer(last_token, deposit.depositor, actual_amount)\r\n        self._safe_transfer(last_token, self.service_fee_collector, unsafe_sub(amount0, actual_amount))\r\n    else:\r\n        self._safe_approve(deposit.route[0], ROUTER, deposit.amount)\r\n        amount0 = CurveSwapRouter(ROUTER).exchange_multiple(deposit.route, deposit.swap_params, deposit.amount, expected, deposit.pools, self)\r\n        actual_amount: uint256 = unsafe_div(amount0 * 995, 1000)\r\n        if last_token == VETH:\r\n            send(deposit.depositor, actual_amount)\r\n            send(self.service_fee_collector, unsafe_sub(amount0, actual_amount))\r\n        else:\r\n            self._safe_transfer(last_token, deposit.depositor, actual_amount)\r\n            self._safe_transfer(last_token, self.service_fee_collector, unsafe_sub(amount0, actual_amount))\r\n    log Withdrawn(deposit_id, msg.sender, withdraw_type, amount0)\r\n    return amount0\r\n\r\n@external\r\ndef cancel(deposit_id: uint256, expected: uint256) -> uint256:\r\n    return self._withdraw(deposit_id, expected, WithdrawType.CANCEL)\r\n\r\n@external\r\ndef multiple_withdraw(deposit_ids: DynArray[uint256, MAX_SIZE], expected: DynArray[uint256, MAX_SIZE], withdraw_types: DynArray[WithdrawType, MAX_SIZE]):\r\n    assert msg.sender == self.compass, \"Unauthorized\"\r\n    _len: uint256 = len(deposit_ids)\r\n    assert _len == len(expected) and _len == len(withdraw_types), \"Validation error\"\r\n    _len = unsafe_add(unsafe_mul(unsafe_add(_len, 2), 96), 36)\r\n    assert len(msg.data) == _len, \"invalid payload\"\r\n    assert self.paloma == convert(slice(msg.data, unsafe_sub(_len, 32), 32), bytes32), \"invalid paloma\"\r\n    for i in range(MAX_SIZE):\r\n        if i >= len(deposit_ids):\r\n            break\r\n        self._withdraw(deposit_ids[i], expected[i], withdraw_types[i])\r\n\r\n@external\r\ndef multiple_withdraw_view(deposit_ids: DynArray[uint256, MAX_SIZE], expected: DynArray[uint256, MAX_SIZE], withdraw_types: DynArray[WithdrawType, MAX_SIZE]) -> uint256[MAX_SIZE]:\r\n    assert msg.sender == empty(address)\r\n    ret: uint256[MAX_SIZE] = empty(uint256[MAX_SIZE])\r\n    for i in range(MAX_SIZE):\r\n        if i >= len(deposit_ids):\r\n            break\r\n        ret[i] = self._withdraw(deposit_ids[i], expected[i], withdraw_types[i])\r\n    return ret\r\n\r\n@external\r\ndef update_compass(new_compass: address):\r\n    assert msg.sender == self.compass and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    self.compass = new_compass\r\n    log UpdateCompass(msg.sender, new_compass)\r\n\r\n@external\r\ndef update_refund_wallet(new_refund_wallet: address):\r\n    assert msg.sender == self.compass and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    old_refund_wallet: address = self.refund_wallet\r\n    self.refund_wallet = new_refund_wallet\r\n    log UpdateRefundWallet(old_refund_wallet, new_refund_wallet)\r\n\r\n@external\r\ndef update_fee(new_fee: uint256):\r\n    assert msg.sender == self.compass and len(msg.data) == 68 and convert(slice(msg.data, 36, 32), bytes32) == self.paloma, \"Unauthorized\"\r\n    old_fee: uint256 = self.fee\r\n    self.fee = new_fee\r\n    log UpdateFee(old_fee, new_fee)\r\n\r\n@external\r\ndef set_paloma():\r\n    assert msg.sender == self.compass and self.paloma == empty(bytes32) and len(msg.data) == 36, \"Invalid\"\r\n    _paloma: bytes32 = convert(slice(msg.data, 4, 32), bytes32)\r\n    self.paloma = _paloma\r\n    log SetPaloma(_paloma)\r\n\r\n@external\r\ndef update_service_fee_collector(new_service_fee_collector: address):\r\n    assert msg.sender == self.service_fee_collector, \"Unauthorized\"\r\n    self.service_fee_collector = new_service_fee_collector\r\n    log UpdateServiceFeeCollector(msg.sender, new_service_fee_collector)\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    assert msg.sender == ROUTER", "ABI": "[{\"name\":\"Deposited\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token0\",\"type\":\"address\",\"indexed\":false},{\"name\":\"token1\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount0\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"amount1\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"depositor\",\"type\":\"address\",\"indexed\":false},{\"name\":\"profit_taking\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"stop_loss\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdrawn\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"withdrawer\",\"type\":\"address\",\"indexed\":false},{\"name\":\"withdraw_type\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"withdraw_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateCompass\",\"inputs\":[{\"name\":\"old_compass\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_compass\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateRefundWallet\",\"inputs\":[{\"name\":\"old_refund_wallet\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_refund_wallet\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateFee\",\"inputs\":[{\"name\":\"old_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_fee\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetPaloma\",\"inputs\":[{\"name\":\"paloma\",\"type\":\"bytes32\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateServiceFeeCollector\",\"inputs\":[{\"name\":\"old_service_fee_collector\",\"type\":\"address\",\"indexed\":false},{\"name\":\"new_service_fee_collector\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_compass\",\"type\":\"address\"},{\"name\":\"_router\",\"type\":\"address\"},{\"name\":\"_refund_wallet\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_service_fee_collector\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"route\",\"type\":\"address[9]\"},{\"name\":\"swap_params\",\"type\":\"uint256[3][4]\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"expected\",\"type\":\"uint256\"},{\"name\":\"pools\",\"type\":\"address[4]\"},{\"name\":\"profit_taking\",\"type\":\"uint256\"},{\"name\":\"stop_loss\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel\",\"inputs\":[{\"name\":\"deposit_id\",\"type\":\"uint256\"},{\"name\":\"expected\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"multiple_withdraw\",\"inputs\":[{\"name\":\"deposit_ids\",\"type\":\"uint256[]\"},{\"name\":\"expected\",\"type\":\"uint256[]\"},{\"name\":\"withdraw_types\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"multiple_withdraw_view\",\"inputs\":[{\"name\":\"deposit_ids\",\"type\":\"uint256[]\"},{\"name\":\"expected\",\"type\":\"uint256[]\"},{\"name\":\"withdraw_types\",\"type\":\"uint256[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_compass\",\"inputs\":[{\"name\":\"new_compass\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_refund_wallet\",\"inputs\":[{\"name\":\"new_refund_wallet\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_fee\",\"inputs\":[{\"name\":\"new_fee\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_paloma\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_service_fee_collector\",\"inputs\":[{\"name\":\"new_service_fee_collector\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"compass\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposit_size\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposits\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"route\",\"type\":\"address[9]\"},{\"name\":\"swap_params\",\"type\":\"uint256[3][4]\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"pools\",\"type\":\"address[4]\"},{\"name\":\"depositor\",\"type\":\"address\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"refund_wallet\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"paloma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"service_fee_collector\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Curve Momentum Bot", "CompilerVersion": "vyper:0.3.9", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000007eec3e2f4d567794b927b6d904fbf973bc8d15e600000000000000000000000099a58482bd75cbab83b27ec03ca68ff489b5788f0000000000000000000000006dc0a87638cd75cc700ccdb226c7ab6c054bc70b00000000000000000000000000000000000000000000000000354a6ba7a180000000000000000000000000007a16ff8270133f063aab6c9977183d9e72835428", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}