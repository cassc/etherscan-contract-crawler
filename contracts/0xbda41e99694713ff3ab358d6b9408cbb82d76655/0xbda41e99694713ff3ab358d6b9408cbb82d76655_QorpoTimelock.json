{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/TimelockController.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\r\n     * reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC721Receiver} interface.\r\n *\r\n * Accepts all token transfers.\r\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\r\n * {IERC721-setApprovalForAll}.\r\n */\r\nabstract contract ERC721Holder is IERC721Receiver {\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface that must be implemented by smart contracts in order to receive\r\n * ERC-1155 token transfers.\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\r\n *\r\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\r\n * stuck.\r\n */\r\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    function _contextSuffixLength() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev The `account` is missing a role.\r\n     */\r\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\r\n\r\n    /**\r\n     * @dev The caller of a function is not the expected one.\r\n     *\r\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\r\n     */\r\n    error AccessControlBadConfirmation();\r\n\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `callerConfirmation`.\r\n     */\r\n    function renounceRole(bytes32 role, address callerConfirmation) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```solidity\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```solidity\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\r\n * to enforce additional security measures for this role.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address account => bool) hasRole;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 role => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\r\n        return _roles[role].hasRole[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\r\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\r\n     */\r\n    function _checkRole(bytes32 role) internal view virtual {\r\n        _checkRole(role, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\r\n     * is missing `role`.\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert AccessControlUnauthorizedAccount(account, role);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `callerConfirmation`.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\r\n        if (callerConfirmation != _msgSender()) {\r\n            revert AccessControlBadConfirmation();\r\n        }\r\n\r\n        _revokeRole(role, callerConfirmation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].hasRole[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].hasRole[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which acts as a timelocked controller. When set as the\r\n * owner of an `Ownable` smart contract, it enforces a timelock on all\r\n * `onlyOwner` maintenance operations. This gives time for users of the\r\n * controlled contract to exit before a potentially dangerous maintenance\r\n * operation is applied.\r\n *\r\n * By default, this contract is self administered, meaning administration tasks\r\n * have to go through the timelock process. The proposer (resp executor) role\r\n * is in charge of proposing (resp executing) operations. A common use case is\r\n * to position this {TimelockController} as the owner of a smart contract, with\r\n * a multisig or a DAO as the sole proposer.\r\n */\r\ncontract QorpoTimelock is AccessControl, ERC721Holder, ERC1155Holder {\r\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\r\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\r\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\r\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\r\n\r\n    mapping(bytes32 id => uint256) private _timestamps;\r\n    uint256 private _minDelay;\r\n\r\n    enum OperationState {\r\n        Unset,\r\n        Waiting,\r\n        Ready,\r\n        Done\r\n    }\r\n\r\n    /**\r\n     * @dev Mismatch between the parameters length for an operation call.\r\n     */\r\n    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);\r\n\r\n    /**\r\n     * @dev The schedule operation doesn't meet the minimum delay.\r\n     */\r\n    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);\r\n\r\n    /**\r\n     * @dev The current state of an operation is not as required.\r\n     * The `expectedStates` is a bitmap with the bits enabled for each OperationState enum position\r\n     * counting from right to left.\r\n     *\r\n     * See {_encodeStateBitmap}.\r\n     */\r\n    error TimelockUnexpectedOperationState(bytes32 operationId, bytes32 expectedStates);\r\n\r\n    /**\r\n     * @dev The predecessor to an operation not yet done.\r\n     */\r\n    error TimelockUnexecutedPredecessor(bytes32 predecessorId);\r\n\r\n    /**\r\n     * @dev The caller account is not authorized.\r\n     */\r\n    error TimelockUnauthorizedCaller(address caller);\r\n\r\n    /**\r\n     * @dev Emitted when a call is scheduled as part of operation `id`.\r\n     */\r\n    event CallScheduled(\r\n        bytes32 indexed id,\r\n        uint256 indexed index,\r\n        address target,\r\n        uint256 value,\r\n        bytes data,\r\n        bytes32 predecessor,\r\n        uint256 delay\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a call is performed as part of operation `id`.\r\n     */\r\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\r\n\r\n    /**\r\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\r\n     */\r\n    event CallSalt(bytes32 indexed id, bytes32 salt);\r\n\r\n    /**\r\n     * @dev Emitted when operation `id` is cancelled.\r\n     */\r\n    event Cancelled(bytes32 indexed id);\r\n\r\n    /**\r\n     * @dev Emitted when the minimum delay for future operations is modified.\r\n     */\r\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\r\n\r\n    /**\r\n     * @dev Initializes the contract with the following parameters:\r\n     *\r\n     * - `minDelay`: initial minimum delay in seconds for operations\r\n     * - `proposers`: accounts to be granted proposer and canceller roles\r\n     * - `executors`: accounts to be granted executor role\r\n     * - `admin`: optional account to be granted admin role; disable with zero address\r\n     *\r\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\r\n     * without being subject to delay, but this role should be subsequently renounced in favor of\r\n     * administration through timelocked proposals. Previous versions of this contract would assign\r\n     * this admin to the deployer automatically and should be renounced as well.\r\n     */\r\n    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) {\r\n        // self administration\r\n        _grantRole(DEFAULT_ADMIN_ROLE, address(this));\r\n\r\n        // optional admin\r\n        if (admin != address(0)) {\r\n            _grantRole(DEFAULT_ADMIN_ROLE, admin);\r\n        }\r\n\r\n        // register proposers and cancellers\r\n        for (uint256 i = 0; i < proposers.length; ++i) {\r\n            _grantRole(PROPOSER_ROLE, proposers[i]);\r\n            _grantRole(CANCELLER_ROLE, proposers[i]);\r\n        }\r\n\r\n        // register executors\r\n        for (uint256 i = 0; i < executors.length; ++i) {\r\n            _grantRole(EXECUTOR_ROLE, executors[i]);\r\n        }\r\n\r\n        _minDelay = minDelay;\r\n        emit MinDelayChange(0, minDelay);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only by a certain role. In\r\n     * addition to checking the sender's role, `address(0)` 's role is also\r\n     * considered. Granting a role to `address(0)` is equivalent to enabling\r\n     * this role for everyone.\r\n     */\r\n    modifier onlyRoleOrOpenRole(bytes32 role) {\r\n        if (!hasRole(role, address(0))) {\r\n            _checkRole(role, _msgSender());\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view virtual override(AccessControl, ERC1155Holder) returns (bool) {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether an id corresponds to a registered operation. This\r\n     * includes both Waiting, Ready, and Done operations.\r\n     */\r\n    function isOperation(bytes32 id) public view returns (bool) {\r\n        return getOperationState(id) != OperationState.Unset;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\r\n     */\r\n    function isOperationPending(bytes32 id) public view returns (bool) {\r\n        OperationState state = getOperationState(id);\r\n        return state == OperationState.Waiting || state == OperationState.Ready;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\r\n     */\r\n    function isOperationReady(bytes32 id) public view returns (bool) {\r\n        return getOperationState(id) == OperationState.Ready;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether an operation is done or not.\r\n     */\r\n    function isOperationDone(bytes32 id) public view returns (bool) {\r\n        return getOperationState(id) == OperationState.Done;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\r\n     * unset operations, 1 for done operations).\r\n     */\r\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\r\n        return _timestamps[id];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns operation state.\r\n     */\r\n    function getOperationState(bytes32 id) public view virtual returns (OperationState) {\r\n        uint256 timestamp = getTimestamp(id);\r\n        if (timestamp == 0) {\r\n            return OperationState.Unset;\r\n        } else if (timestamp == _DONE_TIMESTAMP) {\r\n            return OperationState.Done;\r\n        } else if (timestamp > block.timestamp) {\r\n            return OperationState.Waiting;\r\n        } else {\r\n            return OperationState.Ready;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the minimum delay in seconds for an operation to become valid.\r\n     *\r\n     * This value can be changed by executing an operation that calls `updateDelay`.\r\n     */\r\n    function getMinDelay() public view virtual returns (uint256) {\r\n        return _minDelay;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the identifier of an operation containing a single\r\n     * transaction.\r\n     */\r\n    function hashOperation(\r\n        address target,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes32 predecessor,\r\n        bytes32 salt\r\n    ) public pure virtual returns (bytes32) {\r\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the identifier of an operation containing a batch of\r\n     * transactions.\r\n     */\r\n    function hashOperationBatch(\r\n        address[] calldata targets,\r\n        uint256[] calldata values,\r\n        bytes[] calldata payloads,\r\n        bytes32 predecessor,\r\n        bytes32 salt\r\n    ) public pure virtual returns (bytes32) {\r\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\r\n    }\r\n\r\n    /**\r\n     * @dev Schedule an operation containing a single transaction.\r\n     *\r\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'proposer' role.\r\n     */\r\n    function schedule(\r\n        address target,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        bytes32 predecessor,\r\n        bytes32 salt,\r\n        uint256 delay\r\n    ) public virtual onlyRole(PROPOSER_ROLE) {\r\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\r\n        _schedule(id, delay);\r\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\r\n        if (salt != bytes32(0)) {\r\n            emit CallSalt(id, salt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Schedule an operation containing a batch of transactions.\r\n     *\r\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'proposer' role.\r\n     */\r\n    function scheduleBatch(\r\n        address[] calldata targets,\r\n        uint256[] calldata values,\r\n        bytes[] calldata payloads,\r\n        bytes32 predecessor,\r\n        bytes32 salt,\r\n        uint256 delay\r\n    ) public virtual onlyRole(PROPOSER_ROLE) {\r\n        if (targets.length != values.length || targets.length != payloads.length) {\r\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\r\n        }\r\n\r\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\r\n        _schedule(id, delay);\r\n        for (uint256 i = 0; i < targets.length; ++i) {\r\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\r\n        }\r\n        if (salt != bytes32(0)) {\r\n            emit CallSalt(id, salt);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Schedule an operation that is to become valid after a given delay.\r\n     */\r\n    function _schedule(bytes32 id, uint256 delay) private {\r\n        if (isOperation(id)) {\r\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Unset));\r\n        }\r\n        uint256 minDelay = getMinDelay();\r\n        if (delay < minDelay) {\r\n            revert TimelockInsufficientDelay(delay, minDelay);\r\n        }\r\n        _timestamps[id] = block.timestamp + delay;\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel an operation.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'canceller' role.\r\n     */\r\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\r\n        if (!isOperationPending(id)) {\r\n            revert TimelockUnexpectedOperationState(\r\n                id,\r\n                _encodeStateBitmap(OperationState.Waiting) | _encodeStateBitmap(OperationState.Ready)\r\n            );\r\n        }\r\n        delete _timestamps[id];\r\n\r\n        emit Cancelled(id);\r\n    }\r\n\r\n    /**\r\n     * @dev Execute an (ready) operation containing a single transaction.\r\n     *\r\n     * Emits a {CallExecuted} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'executor' role.\r\n     */\r\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\r\n    // thus any modifications to the operation during reentrancy should be caught.\r\n    // slither-disable-next-line reentrancy-eth\r\n    function execute(\r\n        address target,\r\n        uint256 value,\r\n        bytes calldata payload,\r\n        bytes32 predecessor,\r\n        bytes32 salt\r\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\r\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\r\n\r\n        _beforeCall(id, predecessor);\r\n        _execute(target, value, payload);\r\n        emit CallExecuted(id, 0, target, value, payload);\r\n        _afterCall(id);\r\n    }\r\n\r\n    /**\r\n     * @dev Execute an (ready) operation containing a batch of transactions.\r\n     *\r\n     * Emits one {CallExecuted} event per transaction in the batch.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have the 'executor' role.\r\n     */\r\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\r\n    // thus any modifications to the operation during reentrancy should be caught.\r\n    // slither-disable-next-line reentrancy-eth\r\n    function executeBatch(\r\n        address[] calldata targets,\r\n        uint256[] calldata values,\r\n        bytes[] calldata payloads,\r\n        bytes32 predecessor,\r\n        bytes32 salt\r\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\r\n        if (targets.length != values.length || targets.length != payloads.length) {\r\n            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);\r\n        }\r\n\r\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\r\n\r\n        _beforeCall(id, predecessor);\r\n        for (uint256 i = 0; i < targets.length; ++i) {\r\n            address target = targets[i];\r\n            uint256 value = values[i];\r\n            bytes calldata payload = payloads[i];\r\n            _execute(target, value, payload);\r\n            emit CallExecuted(id, i, target, value, payload);\r\n        }\r\n        _afterCall(id);\r\n    }\r\n\r\n    /**\r\n     * @dev Execute an operation's call.\r\n     */\r\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        Address.verifyCallResult(success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks before execution of an operation's calls.\r\n     */\r\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\r\n        if (!isOperationReady(id)) {\r\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\r\n        }\r\n        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {\r\n            revert TimelockUnexecutedPredecessor(predecessor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Checks after execution of an operation's calls.\r\n     */\r\n    function _afterCall(bytes32 id) private {\r\n        if (!isOperationReady(id)) {\r\n            revert TimelockUnexpectedOperationState(id, _encodeStateBitmap(OperationState.Ready));\r\n        }\r\n        _timestamps[id] = _DONE_TIMESTAMP;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the minimum timelock duration for future operations.\r\n     *\r\n     * Emits a {MinDelayChange} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\r\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\r\n     */\r\n    function updateDelay(uint256 newDelay) external virtual {\r\n        address sender = _msgSender();\r\n        if (sender != address(this)) {\r\n            revert TimelockUnauthorizedCaller(sender);\r\n        }\r\n        emit MinDelayChange(_minDelay, newDelay);\r\n        _minDelay = newDelay;\r\n    }\r\n\r\n    /**\r\n     * @dev Encodes a `OperationState` into a `bytes32` representation where each bit enabled corresponds to\r\n     * the underlying position in the `OperationState` enum. For example:\r\n     *\r\n     * 0x000...1000\r\n     *   ^^^^^^----- ...\r\n     *         ^---- Done\r\n     *          ^--- Ready\r\n     *           ^-- Waiting\r\n     *            ^- Unset\r\n     */\r\n    function _encodeStateBitmap(OperationState operationState) internal pure returns (bytes32) {\r\n        return bytes32(1 << uint8(operationState));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minDelay\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"proposers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"executors\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDelay\",\"type\":\"uint256\"}],\"name\":\"TimelockInsufficientDelay\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payloads\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"values\",\"type\":\"uint256\"}],\"name\":\"TimelockInvalidOperationLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"TimelockUnauthorizedCaller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"predecessorId\",\"type\":\"bytes32\"}],\"name\":\"TimelockUnexecutedPredecessor\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"operationId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"expectedStates\",\"type\":\"bytes32\"}],\"name\":\"TimelockUnexpectedOperationState\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"CallExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"CallSalt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"CallScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Cancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"MinDelayChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANCELLER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXECUTOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROPOSER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"payloads\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"executeBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getOperationState\",\"outputs\":[{\"internalType\":\"enum QorpoTimelock.OperationState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"hashOperation\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"payloads\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"hashOperationBatch\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"isOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"isOperationDone\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"isOperationPending\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"isOperationReady\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"schedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"payloads\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"predecessor\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"scheduleBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDelay\",\"type\":\"uint256\"}],\"name\":\"updateDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "QorpoTimelock", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000002a300000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000008623f9d75dbb0b7915b509a2e96ca5a2045598e700000000000000000000000000000000000000000000000000000000000000010000000000000000000000008623f9d75dbb0b7915b509a2e96ca5a2045598e7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3bcf0ad4cf9bc9708b2c187770ba2ab087a99c8e837012c734ffab37cc882d99"}