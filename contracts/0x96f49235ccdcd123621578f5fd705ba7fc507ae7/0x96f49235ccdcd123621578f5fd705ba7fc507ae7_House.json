{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\n// \r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// \r\nuint256 constant RESOLUTION = 10000;\r\n\r\nuint256 constant PAYOUT_AMPLIFIER = 10 ** 24;\r\n\r\nlibrary Types {\r\n    struct Bet {\r\n        uint256 globalBetId;\r\n        uint256 playerBetId;\r\n        uint256 gameId;\r\n        uint256 rolls;\r\n        uint256 betNum;\r\n        uint256 stake;\r\n        uint256 payout;\r\n        bool complete;\r\n        uint256 opened;\r\n        uint256 closed;\r\n        uint256[50] data;\r\n        address player;\r\n    }\r\n\r\n    struct Game {\r\n        uint256 id;\r\n        bool live;\r\n        uint256 edge;\r\n        uint256 date;\r\n        address impl;\r\n        string name;\r\n    }\r\n\r\n    struct HouseGame {\r\n        uint256 betCount;\r\n        uint256[] betIds;\r\n    }\r\n\r\n    struct PlayerGame {\r\n        uint256 betCount;\r\n        uint256 wagers;\r\n        uint256 profits;\r\n        uint256 wins;\r\n        uint256 losses;\r\n    }\r\n\r\n    struct Player {\r\n        uint256 betCount;\r\n        uint256[] betIds;\r\n\r\n        uint256 wagers;\r\n        uint256 profits;\r\n\r\n        uint256 wins;\r\n        uint256 losses;\r\n    }\r\n\r\n    struct Player2 {\r\n        Player info;\r\n        mapping (uint256 => PlayerGame) games;\r\n    }\r\n}\r\n\r\n/*\r\npragma solidity ^0.8.0;\r\n\r\nuint256 constant RESOLUTION = 10000;\r\nuint256 constant PAYOUT_AMPLIFIER = 10 ** 24;\r\n\r\ntype BETCOUNT is uint32;\r\ntype GAMECOUNT is uint16;\r\ntype DATAVALUE is uint128;\r\ntype ROLLCOUNT is uint16;\r\ntype BETNUM is uint32;\r\ntype TOKENAMOUNT is uint128;\r\ntype TIMESTAMP is uint32;\r\ntype EDGEAMOUNT is uint16;\r\n\r\nlibrary Types {\r\n\r\n    function add(BETCOUNT a, uint256 b) internal pure returns (BETCOUNT) {\r\n        return BETCOUNT.wrap(uint32(uint256(BETCOUNT.unwrap(a)) + b));\r\n    }\r\n\r\n    function toUint256(BETCOUNT a) internal pure returns (uint256) {\r\n        return uint256(BETCOUNT.unwrap(a));\r\n    }\r\n\r\n    function add(GAMECOUNT a, uint256 b) internal pure returns (GAMECOUNT) {\r\n        return GAMECOUNT.wrap(uint16(uint256(GAMECOUNT.unwrap(a)) + b));\r\n    }\r\n\r\n    struct Bet {\r\n        BETCOUNT globalBetId;\r\n        BETCOUNT playerBetId;\r\n        GAMECOUNT gameId;\r\n        ROLLCOUNT rolls;\r\n        BETNUM betNum;\r\n        TOKENAMOUNT stake;\r\n        TOKENAMOUNT payout;\r\n        bool complete;\r\n        TIMESTAMP opened;\r\n        TIMESTAMP closed;\r\n        DATAVALUE[50] data;\r\n        address player;\r\n    }\r\n\r\n    struct Game {\r\n        GAMECOUNT id;\r\n        bool live;\r\n        EDGEAMOUNT edge;\r\n        TIMESTAMP date;\r\n        address impl;\r\n        string name;\r\n    }\r\n\r\n    struct HouseGame {\r\n        BETCOUNT betCount;\r\n        BETCOUNT[] betIds;\r\n    }\r\n\r\n    struct PlayerGame {\r\n        BETCOUNT betCount;\r\n        TOKENAMOUNT wagers;\r\n        TOKENAMOUNT profits;\r\n        BETCOUNT wins;\r\n        BETCOUNT losses;\r\n    }\r\n\r\n    struct Player {\r\n        BETCOUNT betCount;\r\n        BETCOUNT[] betIds;\r\n\r\n        TOKENAMOUNT wagers;\r\n        TOKENAMOUNT profits;\r\n\r\n        BETCOUNT wins;\r\n        BETCOUNT losses;\r\n\r\n        mapping (GAMECOUNT => PlayerGame) games;\r\n    }\r\n}\r\n*/\r\n\r\n// \r\ninterface IHouse {\r\n    function openWager(address _account, uint256 _game, uint256 _rolls, uint256 _bet, uint256[50] calldata _data, uint256 _betSize, uint256 _maxPayout) external returns (uint256, uint256);\r\n    function closeWager(uint256 betId, address _account, uint256 _gameId, uint256 _payout) external returns (bool);\r\n    function getBet(uint256 _id) external view returns (Types.Bet memory);\r\n}\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20BackwardsCompatible {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external;\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n}\r\n\r\n// \r\ninterface IConsole {\r\n    function getGame(uint256 _id) external view returns (Types.Game memory);\r\n    function getGameByImpl(address _impl) external view returns (Types.Game memory);\r\n}\r\n\r\n// \r\ninterface IUSDTVault {\r\n    function finalizeGame(address _player, uint256 _prize, uint256 _fee) external;\r\n}\r\n\r\n// \r\ncontract House is IHouse, Ownable {\r\n    error InvalidGame(uint256 _game, address _impl, bool _live);\r\n    error AlreadyInitialized();\r\n    error NotInitialized();\r\n    error InsufficientVault(uint256 _betSize, uint256 _vaultSize);\r\n    error MaxBetExceeded(uint256 _betSize, uint256 _maxBet);\r\n    error InsufficientUSDBalance(uint256 _betSize, uint256 _balance);\r\n    error InsufficientUSDAllowance(uint256 _betSize, uint256 _allowance);\r\n    error BetCompleted(uint256 betId);\r\n\r\n    address public usdtVault;\r\n\r\n    uint256 public globalWagers; // Tracks total dollars wagered\r\n    uint256 public globalBets; // Tracks total number of bets\r\n\r\n    mapping (uint256 => Types.HouseGame) games; // statistics of games\r\n    mapping (address => Types.Player2) players; // statistics of players\r\n\r\n    uint256 public betFee = 100; // 1%\r\n\r\n    IERC20BackwardsCompatible public usdtToken;\r\n    IConsole public consoleInst;\r\n\r\n    mapping(uint256 => Types.Bet) bets; // An array of every bet\r\n\r\n    bool private initialized;\r\n\r\n    constructor (address _vault, address _usdt, address _console) {\r\n        usdtVault = _vault;\r\n        usdtToken = IERC20BackwardsCompatible(_usdt);\r\n        consoleInst = IConsole(_console);\r\n    }\r\n\r\n    function initialize() external onlyOwner {\r\n        if (initialized) {\r\n            revert AlreadyInitialized();\r\n        }\r\n\r\n        initialized = true;\r\n    }\r\n\r\n    function calculateBetFee(uint256 _stake) public view returns (uint256) {\r\n        uint256 _feeAmount = _stake * betFee / 10000;\r\n        return _feeAmount;\r\n    }\r\n\r\n    function openWager(address _account, uint256 _gameId, uint256 _rolls, uint256 _bet, uint256[50] calldata _data, uint256 _stake, uint256 _maxPayout) external returns (uint256, uint256) {\r\n        if (!initialized) {\r\n            revert NotInitialized();\r\n        }\r\n\r\n        {\r\n            Types.Game memory _game = consoleInst.getGame(_gameId);\r\n            if (msg.sender != _game.impl || address(0) == _game.impl || !_game.live) {\r\n                revert InvalidGame(_gameId, _game.impl, _game.live);\r\n            }\r\n        }\r\n\r\n        uint256 _betSize = _stake * _rolls;\r\n        uint256 _betSizeWithFee = (_stake + calculateBetFee(_stake)) * _rolls;\r\n        if (_betSizeWithFee > usdtToken.balanceOf(usdtVault)) {\r\n            revert InsufficientVault(_betSize, usdtToken.balanceOf(usdtVault));\r\n        }\r\n\r\n        // 2.5% of vault\r\n        {\r\n            uint256 betLimit = (usdtToken.balanceOf(usdtVault) * 25 / 1000);\r\n            uint256 maxBetPrize = 0;\r\n            if (_maxPayout >= PAYOUT_AMPLIFIER) {\r\n                maxBetPrize = _betSize * (_maxPayout - PAYOUT_AMPLIFIER) / PAYOUT_AMPLIFIER;\r\n            }\r\n\r\n            if (maxBetPrize > betLimit) {\r\n                revert MaxBetExceeded(maxBetPrize, betLimit);\r\n            }\r\n        }\r\n\r\n        {\r\n            uint256 userBalance = usdtToken.balanceOf(_account);\r\n            if (_betSizeWithFee > userBalance) {\r\n                revert InsufficientUSDBalance(_betSizeWithFee, userBalance);\r\n            }\r\n        }\r\n\r\n        {\r\n            uint256 userAllowance = usdtToken.allowance(_account, address(this));\r\n            if (_betSizeWithFee > userAllowance) {\r\n                revert InsufficientUSDAllowance(_betSizeWithFee, userAllowance);\r\n            }\r\n        }\r\n\r\n        // take bet\r\n        usdtToken.transferFrom(_account, usdtVault, _betSizeWithFee);\r\n\r\n        bets[globalBets] = Types.Bet(globalBets, players[_account].info.betCount, _gameId, _rolls, _bet, _stake, 0, false, block.timestamp, 0, _data, _account);\r\n\r\n        globalBets += 1;\r\n        globalWagers += _betSize;\r\n\r\n        players[_account].info.betCount ++;\r\n        players[_account].info.betIds.push(globalBets);\r\n        players[_account].info.wagers += _betSize;\r\n        games[_gameId].betCount += 1;\r\n        games[_gameId].betIds.push(globalBets);\r\n\r\n        return (globalBets - 1, _betSizeWithFee);\r\n    }\r\n\r\n    function closeWager(uint256 betId, address _account, uint256 _gameId, uint256 _payout) external returns (bool) {\r\n        // validate game\r\n        Types.Game memory _game = consoleInst.getGame(_gameId);\r\n        if (msg.sender != _game.impl || address(0) == _game.impl) {\r\n            revert InvalidGame(_gameId, _game.impl, _game.live);\r\n        }\r\n\r\n        // validate bet\r\n        Types.Bet memory _bet = bets[betId];\r\n        if (_bet.complete) {\r\n            revert BetCompleted(betId);\r\n        }\r\n\r\n        // close bet\r\n        _bet.payout = _payout;\r\n        _bet.complete = true;\r\n        _bet.closed = block.timestamp;\r\n        bets[betId] = _bet;\r\n\r\n        // pay out winnings & receive losses\r\n        players[_account].games[_gameId].betCount += 1;\r\n        players[_account].games[_gameId].wagers += _bet.stake * _bet.rolls;\r\n\r\n        if (_payout > _bet.stake) {\r\n            uint256 _profit = _payout - _bet.stake;\r\n\r\n            players[_account].info.profits += _profit;\r\n            players[_account].games[_gameId].profits += _profit;\r\n            players[_account].info.wins += 1;\r\n            players[_account].games[_gameId].wins += 1;\r\n        } else {\r\n            players[_account].info.losses ++;\r\n            players[_account].games[_gameId].losses ++;\r\n        }\r\n\r\n        return _payout > _bet.stake;\r\n    }\r\n\r\n    function getBetsByGame(uint256 _game, uint256 _from, uint256 _to) external view returns (Types.Bet[] memory) {\r\n        uint256 betCount = games[_game].betCount;\r\n\r\n        if (_to >= betCount) _to = betCount;\r\n        if (_from > _to) _from = 0;\r\n\r\n        Types.Bet[] memory _Bets;\r\n        uint256 _counter;\r\n        \r\n        for (uint256 _i = _from; _i < _to; _i++) {\r\n            _Bets[_counter] = bets[games[_game].betIds[_i]];\r\n            _counter++;\r\n        }\r\n        return _Bets;\r\n    }\r\n    \r\n    function getBets(uint256 _from, uint256 _to) external view returns (Types.Bet[] memory) {\r\n        if (_to >= globalBets) _to = globalBets;\r\n        if (_from > _to) _from = 0;\r\n\r\n        Types.Bet[] memory _Bets;\r\n        uint256 _counter;\r\n\r\n        for (uint256 _i = _from; _i < _to; _i++) {\r\n            _Bets[_counter] = bets[_i];\r\n            _counter++;\r\n        }\r\n\r\n        return _Bets;\r\n    }\r\n\r\n    function getBet(uint256 _betId) external view returns (Types.Bet memory) {\r\n        return bets[_betId];\r\n    }\r\n\r\n    function getPlayer(address _user) external view returns (Types.Player memory) {\r\n        return players[_user].info;\r\n    }\r\n\r\n    function getPlayerGame(address _user, uint256 _gameId) external view returns (Types.PlayerGame memory) {\r\n        return players[_user].games[_gameId];\r\n    }\r\n\r\n    function getGame(uint256 _gameId) external view returns (Types.HouseGame memory) {\r\n        return games[_gameId];\r\n    }\r\n\r\n    function setUSDTToken(address _newUSDT) external onlyOwner {\r\n        require(address(usdtToken) != _newUSDT, \"Already Set\");\r\n        usdtToken = IERC20BackwardsCompatible(_newUSDT);\r\n    }\r\n\r\n    function setUSDTVault(address _newVaule) external onlyOwner {\r\n        require(usdtVault != _newVaule, \"Already Set\");\r\n        usdtVault = _newVaule;\r\n    }\r\n\r\n    function setConsoleInst(address _newConsole) external onlyOwner {\r\n        require(address(consoleInst) != _newConsole, \"Already Set\");\r\n        consoleInst = IConsole(_newConsole);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_console\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"}],\"name\":\"BetCompleted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allowance\",\"type\":\"uint256\"}],\"name\":\"InsufficientUSDAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"InsufficientUSDBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vaultSize\",\"type\":\"uint256\"}],\"name\":\"InsufficientVault\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_live\",\"type\":\"bool\"}],\"name\":\"InvalidGame\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBet\",\"type\":\"uint256\"}],\"name\":\"MaxBetExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInitialized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"betFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"}],\"name\":\"calculateBetFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"betId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gameId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"}],\"name\":\"closeWager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"consoleInst\",\"outputs\":[{\"internalType\":\"contract IConsole\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_betId\",\"type\":\"uint256\"}],\"name\":\"getBet\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"globalBetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"playerBetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rolls\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"complete\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"opened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[50]\",\"name\":\"data\",\"type\":\"uint256[50]\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"internalType\":\"struct Types.Bet\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getBets\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"globalBetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"playerBetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rolls\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"complete\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"opened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[50]\",\"name\":\"data\",\"type\":\"uint256[50]\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"internalType\":\"struct Types.Bet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_game\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getBetsByGame\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"globalBetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"playerBetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rolls\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"complete\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"opened\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closed\",\"type\":\"uint256\"},{\"internalType\":\"uint256[50]\",\"name\":\"data\",\"type\":\"uint256[50]\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"internalType\":\"struct Types.Bet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"getGame\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"betCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"betIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Types.HouseGame\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getPlayer\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"betCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"betIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"wagers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"losses\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.Player\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gameId\",\"type\":\"uint256\"}],\"name\":\"getPlayerGame\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"betCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wagers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"losses\",\"type\":\"uint256\"}],\"internalType\":\"struct Types.PlayerGame\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalBets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalWagers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gameId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rolls\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bet\",\"type\":\"uint256\"},{\"internalType\":\"uint256[50]\",\"name\":\"_data\",\"type\":\"uint256[50]\"},{\"internalType\":\"uint256\",\"name\":\"_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPayout\",\"type\":\"uint256\"}],\"name\":\"openWager\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newConsole\",\"type\":\"address\"}],\"name\":\"setConsoleInst\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newUSDT\",\"type\":\"address\"}],\"name\":\"setUSDTToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newVaule\",\"type\":\"address\"}],\"name\":\"setUSDTVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"contract IERC20BackwardsCompatible\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "House", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f23787b0ac145fe83ce27e3796bc9a7e623ed5bf000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000002558d23e8d3c5c54bf96f190ccad584cab0b5196", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fd8cfabe2831c4d06cb42d93d871832b8b7e7cc867b5d13cdf950ec86003a6cf"}