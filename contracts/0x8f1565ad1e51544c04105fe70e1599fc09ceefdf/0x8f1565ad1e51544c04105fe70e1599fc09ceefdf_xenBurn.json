{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"XengameV2Live/XenBurn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n/*\\r\\n\\r\\n\\r\\n\u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\\r\\n\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\\r\\n \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\\r\\n \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\\r\\n\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\\r\\n\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\\r\\n                                                                 \\r\\n\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.17;\\r\\n//import \\\"forge-std/console.sol\\\";\\r\\n\\r\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\r\\n\\r\\n\\r\\ninterface IPriceOracle {\\r\\n    function calculateAveragePrice() external view returns (uint256);\\r\\n    function calculateV2Price() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IBurnRedeemable {\\r\\n    function onTokenBurned(address user, uint256 amount) external;\\r\\n}\\r\\n\\r\\ninterface IBurnableToken {\\r\\n    function burn(address user, uint256 amount) external;\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IPlayerNameRegistryBurn {\\r\\n    function getPlayerNames(address playerAddress) external view returns (string[] memory);\\r\\n}\\r\\n\\r\\ncontract xenBurn is IBurnRedeemable {\\r\\n    address public xenCrypto;\\r\\n    mapping(address => bool) private burnSuccessful;\\r\\n    mapping(address => uint256) public lastCall;\\r\\n    mapping(address => uint256) public callCount;\\r\\n    uint256 public totalCount;\\r\\n    address private uniswapPool = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\r\\n    IPriceOracle private priceOracle;\\r\\n    IPlayerNameRegistryBurn private playerNameRegistry;\\r\\n\\r\\n    constructor(address _priceOracle, address _xenCrypto, address _playerNameRegistry) {\\r\\n        priceOracle = IPriceOracle(_priceOracle);\\r\\n        xenCrypto = _xenCrypto;\\r\\n        playerNameRegistry = IPlayerNameRegistryBurn(_playerNameRegistry);\\r\\n    }\\r\\n\\r\\n    event TokenBurned(address indexed user, uint256 amount, string playerName);\\r\\n\\r\\n    // Modifier to allow only human users to perform certain actions\\r\\n    modifier isHuman() {\\r\\n        require(msg.sender == tx.origin, \\\"Only human users can perform this action\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Modifier to enforce restrictions on the frequency of calls\\r\\n    modifier gatekeeping() {\\r\\n        require(\\r\\n            (lastCall[msg.sender] + 1 days) <= block.timestamp || (callCount[msg.sender] + 5) <= totalCount,\\r\\n            \\\"Function can only be called once per 24 hours, or 5 times within the 24-hour period by different users\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Function to burn tokens by swapping ETH for the token\\r\\n    function burnXenCrypto() public isHuman gatekeeping {\\r\\n        require(address(this).balance > 0, \\\"No ETH available\\\");\\r\\n\\r\\n        address player = msg.sender;\\r\\n\\r\\n        // Pull player's name from game contract\\r\\n        string[] memory names = playerNameRegistry.getPlayerNames(player);\\r\\n        require(names.length > 0, \\\"User must have at least 1 name registered\\\");\\r\\n\\r\\n        // Amount to use for swap (98% of the contract's ETH balance)\\r\\n        uint256 amountETH = address(this).balance * 98 / 100;\\r\\n\\r\\n\\r\\n        // Get current token price from PriceOracle\\r\\n        uint256 tokenPrice = priceOracle.calculateAveragePrice();\\r\\n        \\r\\n\\r\\n        // Calculate the minimum amount of tokens to purchase. Slippage set to 10% max\\r\\n        uint256 minTokenAmount = (amountETH * tokenPrice * 90) / 100;\\r\\n\\r\\n        // Perform a Uniswap transaction to swap the ETH for tokens\\r\\n        uint256 deadline = block.timestamp + 150; // 15 second deadline\\r\\n        uint256[] memory amounts = IUniswapV2Router02(uniswapPool).swapExactETHForTokens{value: amountETH}(\\r\\n            minTokenAmount, getPathForETHtoTOKEN(), address(this), deadline\\r\\n        );\\r\\n\\r\\n        // The actual amount of tokens received from the swap is stored in amounts[1]\\r\\n        uint256 actualTokenAmount = amounts[1];\\r\\n\\r\\n        // Verify that the trade happened successfully\\r\\n        require(actualTokenAmount >= minTokenAmount, \\\"Uniswap trade failed\\\");\\r\\n\\r\\n        // Update the call count and last call timestamp for the user\\r\\n        totalCount++;\\r\\n        callCount[player] = totalCount;\\r\\n        lastCall[player] = block.timestamp;\\r\\n\\r\\n        // Transfer the Xen to the user\\r\\n        IBurnableToken(xenCrypto).transfer(player, actualTokenAmount);\\r\\n\\r\\n        // Call the external contract to burn tokens\\r\\n        IBurnableToken(xenCrypto).burn(player, actualTokenAmount);\\r\\n\\r\\n        // Check if the burn was successful\\r\\n        require(burnSuccessful[player], \\\"Token burn was not successful\\\");\\r\\n\\r\\n        // Reset the burn successful status for the user\\r\\n        burnSuccessful[player] = false;\\r\\n    }\\r\\n\\r\\n    // Function to calculate the expected amount of tokens to be burned based on the contract's ETH balance and token price\\r\\n    function calculateExpectedBurnAmount() public view returns (uint256) {\\r\\n        // Check if the contract has ETH balance\\r\\n        if (address(this).balance == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        // Calculate the amount of ETH to be used for the swap (98% of the contract's ETH balance)\\r\\n        uint256 amountETH = address(this).balance;\\r\\n\\r\\n        // Get current token price from PriceOracle\\r\\n        uint256 tokenPrice = priceOracle.calculateV2Price();\\r\\n\\r\\n        // Calculate the expected amount of tokens to be burned\\r\\n        uint256 expectedBurnAmount = (amountETH * tokenPrice);\\r\\n\\r\\n        return expectedBurnAmount;\\r\\n    }\\r\\n\\r\\n    // Function to deposit ETH into the contract\\r\\n    function deposit() public payable returns (bool) {\\r\\n        require(msg.value > 0, \\\"No ETH received\\\");\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Fallback function to receive ETH\\r\\n    receive() external payable {}\\r\\n\\r\\n    // Function to get the path for swapping ETH to the token\\r\\n    function getPathForETHtoTOKEN() private view returns (address[] memory) {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = IUniswapV2Router02(uniswapPool).WETH();\\r\\n        path[1] = xenCrypto;\\r\\n        return path;\\r\\n    }\\r\\n\\r\\n    // Implementation of the onTokenBurned function from the IBurnRedeemable interface\\r\\n    function onTokenBurned(address user, uint256 amount) external override {\\r\\n        require(msg.sender == address(xenCrypto), \\\"Invalid caller\\\");        \\r\\n\\r\\n        // Transfer 1% of the ETH balance to the user who called the function\\r\\n        uint256 amountETH = address(this).balance / 2;\\r\\n\\r\\n        address payable senderPayable = payable(user);\\r\\n        (bool success,) = senderPayable.call{value: amountETH}(\\\"\\\");\\r\\n        require(success, \\\"Transfer failed.\\\");\\r\\n\\r\\n        // Set the burn operation as successful for the user\\r\\n        burnSuccessful[user] = true;\\r\\n\\r\\n        // Pull player's name from the PlayerNameRegistry contract\\r\\n        string[] memory names = playerNameRegistry.getPlayerNames(user);\\r\\n\\r\\n        string memory playerName = names[0];\\r\\n\\r\\n        // Emit the TokenBurned event\\r\\n        emit TokenBurned(user, amount, playerName);\\r\\n    }\\r\\n\\r\\n    // Function to check if a user's burn operation was successful\\r\\n    function wasBurnSuccessful(address user) external view returns (bool) {\\r\\n        return burnSuccessful[user];\\r\\n    }\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\\r\\n        return\\r\\n            interfaceId == type(IBurnRedeemable).interfaceId;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xenCrypto\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_playerNameRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"playerName\",\"type\":\"string\"}],\"name\":\"TokenBurned\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"burnXenCrypto\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateExpectedBurnAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"callCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastCall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onTokenBurned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"wasBurnSuccessful\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xenCrypto\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "xenBurn", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000768bcc8e638f44f42904f071f9e97bb82196ccff00000000000000000000000006450dee7fd2fb8e39061434babcfc05599a6fb800000000000000000000000068317fe2590dc605c730628fb645de0f17f86bfc", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}