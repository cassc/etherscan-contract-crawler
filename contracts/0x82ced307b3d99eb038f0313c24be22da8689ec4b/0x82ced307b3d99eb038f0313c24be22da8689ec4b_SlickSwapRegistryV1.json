{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"src/contracts/EtherHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n// Imports\\nimport \\\"../libraries/UniswapV3Trading.sol\\\";\\n\\n/**\\n * An abstract contract which enables receiving Ethers.\\n */\\nabstract contract EtherHolder {\\n  // Events\\n  event Deposit(address indexed from, uint256 value);\\n\\n  /**\\n   * Handles incoming Ethers by accepting those and trigerring Deposit() event.\\n   */\\n  receive() external payable {\\n    emit Deposit(msg.sender, msg.value);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n/**\\n * Abstract contract implementing ownership handling and verification.\\n *\\n * The owner address gets stored in the contract's _owner slot and is\\n * used to verify both implicit (direct method calls) and explicit\\n * (passed in as an argument from arbitrary address, on owner's\\n * behalf) signatures.\\n *\\n * The proposed owner address gets stored in _nextOwner slot and is only\\n * promoted to the _owner slot upon receiving a signed approval.\\n *\\n * The reusable modifiers are utilized to validate that certain functions get\\n * invoked by the current owner of the contract.\\n */\\nabstract contract Ownable {\\n  /**\\n   * A struct holding the ECDSA explicit signature and the nonce used to\\n   * produce it.  Nonce is strictly increasing to prevent replay attacks.\\n   *\\n   * The recovery id \\\"v\\\" should be 27 or 28.\\n   */\\n  struct Signature {\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n    uint96 nonce;\\n  }\\n\\n  // Current owner of the contract\\n  address public _owner;\\n  // Last explicit signature's nonce\\n  uint96 public _lastNonce;\\n\\n  // Proposed owner of the contract\\n  address public _nextOwner;\\n\\n  /**\\n   * Validates that the caller of the method matches the requiredOwner parameter.\\n   *\\n   * @param requiredOwner the required address\\n   */\\n  modifier onlyBy(address requiredOwner) {\\n    require(msg.sender == requiredOwner, \\\"Only owner can do that\\\");\\n    _;\\n  }\\n\\n  /**\\n   * Validates that the provided signature was signed by an address matching requiredOwner parameter.\\n   *\\n   * @param requiredOwner the required address for the explicit signature\\n   * @param argsHash an opaque digest of whatever parameters are authorized by the explicit signature\\n   * @param signature an explicit ECDSA signature over argHash\\n   */\\n  modifier onlySignedBy(address requiredOwner, bytes32 argsHash, Signature calldata signature) {\\n    // Pack the hash of the arguments along with the nonce and contract address to prevent replay attacks.\\n    bytes32 hash = keccak256(abi.encodePacked(address(this), argsHash, signature.nonce));\\n    // Check the explicit ECDSA signature by recovering the signer address\\n    address signer = ecrecover(hash, signature.v, signature.r, signature.s);\\n\\n    // Make sure the nonce is strictly greater to avoid re-use\\n    require(signature.nonce > _lastNonce, \\\"The nonce is too old\\\");\\n    // Make sure the signer matches the one requested\\n    require(signer == requiredOwner, \\\"Only owner can do that\\\");\\n\\n    // Update the nonce\\n    _lastNonce = signature.nonce;\\n\\n    _;\\n  }\\n\\n  /**\\n   * Updates the proposed owner to a new address. To be called directly by the Owner.\\n   *\\n   * Requires the transaction to be signed by current owner.\\n   *\\n   * @param nextOwner the proposed address of the new owner\\n   */\\n  function setNextOwner(address nextOwner) public onlyBy(_owner) {\\n    _nextOwner = nextOwner;\\n  }\\n\\n  /**\\n   * Updates the proposed owner to a new address. To be called on Owner's behalf.\\n   *\\n   * Requires the signature from the current owner to be passed.\\n   *\\n   * @param nextOwner the proposed address of the new owner\\n   * @param signature an explicit ECDSA signature of the authorization with the Owner's public key\\n   */\\n  function setNextOwner(address nextOwner, Signature calldata signature) public onlySignedBy(_owner, keccak256(abi.encodePacked(nextOwner)), signature) {\\n    _nextOwner = nextOwner;\\n  }\\n\\n  /**\\n   * Accepts the new owner. To be called by the proposed Owner directly.\\n   */\\n  function acceptNextOwner() public onlyBy(_nextOwner) {\\n    _owner = _nextOwner;\\n  }\\n\\n  /**\\n   * Accepts the new owner. To be called on the proposed Owner's behalf.\\n   *\\n   * @param signature an explicit ECDSA signature of the authorization with the Owner's public key\\n   */\\n  function acceptNextOwner(Signature calldata signature) public onlySignedBy(_nextOwner, keccak256(abi.encodePacked()), signature) {\\n    _owner = _nextOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/contracts/Trading.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n// Imports\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\nimport \\\"../libraries/UniswapV3Trading.sol\\\";\\n\\n/**\\n * This is an abstract contract handling interaction with different DEXs (\\\"brokers\\\").\\n *\\n * It primary purpose is to properly route trading request to the implementation,\\n * receive the result and log corresponding events.\\n *\\n * It also takes care of gathering trade fees: these are forced to never exceed 3%,\\n * but can be as low as 0 (depending on amountFee) parameter.\\n */\\nabstract contract Trading {\\n  // Constants\\n  uint8 constant internal UNISWAP_V3_BROKER = 0x1;\\n  uint16 constant internal MAX_FEE_BASE_1000 = 30;\\n\\n  /**\\n   * An event emitted on a successful trade. All values are actually traded amounts.\\n   *\\n   * @param tradeId a unique identifier of the trade for SlickSwap internal bookkeeping\\n   * @param amountIn actually spent source token amount\\n   * @param amountOut actually obtained destination token amount\\n   * @param amountFee actually spent fee\\n   */\\n  event Trade(uint256 indexed tradeId, uint256 amountIn, uint256 amountOut, uint256 amountFee);\\n\\n  /**\\n   * An event emitted on a failed trade. Various reasons include, but are not limited to:\\n   *  - insufficient balances\\n   *  - low liquidity\\n   *  - slippage overshoot (frontrunning)\\n   *\\n   * @param tradeId a unique identifier of the trade for SlickSwap internal bookkeeping\\n   */\\n  event TradeFailed(uint256 indexed tradeId);\\n\\n  /**\\n   * Perform a trade.\\n   *\\n   * @param tradeId a unique identifier of the trade for SlickSwap internal bookkeeping\\n   * @param broker the type of the broker (the only supported value is 1, meaning Uniswap V3)\\n   * @param path token exchange path, in the format of a specific broker (see UniswapV3Trading for example)\\n   * @param flags a bitmask representing trade settings of a specific broker (see UniswapV3Trading for example)\\n   * @param amountIn amount of the \\\"source\\\" token to trade\\n   * @param amountOut amount of the \\\"destination\\\" token to trade\\n   * @param amountFee amount of the \\\"destination\\\" taken by SlickSwap as a fee. Enforced to be less than 3%.\\n   */\\n  function _trade(uint256 tradeId, uint8 broker, bytes memory path, uint8 flags, uint256 amountIn, uint256 amountOut, uint256 amountFee, address feeRecipient) internal returns (bool success) {\\n    // Invoke the implementation dispatch\\n    (bool tradeSuccess, uint256 actualIn, uint256 actualOut, uint256 actualFee) = _performTrade(broker, path, flags, amountIn, amountOut, amountFee, feeRecipient);\\n\\n    // Emit events\\n    if (tradeSuccess) {\\n      emit Trade(tradeId, actualIn, actualOut, actualFee);\\n    } else {\\n      emit TradeFailed(tradeId);\\n    }\\n\\n    return tradeSuccess;\\n  }\\n\\n  /**\\n   * The actual trading logic implementation.\\n   */\\n  function _performTrade(uint8 broker, bytes memory path, uint8 flags, uint256 amountIn, uint256 amountOut, uint256 amountFee, address feeRecipient) internal returns (bool success, uint256 actualIn, uint256 actualOut, uint256 actualFee) {\\n    // Uniswap V3\\n    if (broker == UNISWAP_V3_BROKER) {\\n      address tokenIn;\\n      address tokenOut;\\n      bool takeFeeInEther;\\n\\n      // Perform the trade\\n      (success, actualIn, actualOut, tokenIn, tokenOut, takeFeeInEther) = UniswapV3Trading.performTrade(path, flags, amountIn, amountOut);\\n\\n      if (!success) {\\n        return (false, 0, 0, 0);\\n      }\\n\\n      // Important: limit fee to 3% of the actual output amount\\n      uint256 maximumFee = actualOut * MAX_FEE_BASE_1000 / 1000;\\n      actualFee = amountFee > maximumFee ? maximumFee : amountFee;\\n\\n      // Collect the fee\\n      if (actualFee > 0) {\\n        if (takeFeeInEther) {\\n          (bool transferSuccess,) = feeRecipient.call{ value: actualFee }(\\\"\\\");\\n          require(transferSuccess, \\\"Ether fee capture failed\\\");\\n        } else {\\n          TransferHelper.safeTransfer(tokenOut, feeRecipient, actualFee);\\n        }\\n      }\\n    } else {\\n      // Revert on unknown broker\\n      require(false, \\\"Unknown broker id\\\");\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/contracts/Upgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n/**\\n * This is an abstract contract implementing updates to the EIP-1967\\n * implementation slot, as used by proxy.\\n */\\nabstract contract Upgradable {\\n  // EIP-1967 defines implementation slot as uint256(keccak256('eip1967.proxy.implementation')) - 1\\n  bytes32 constant EIP_1967_SLOT = hex'360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc';\\n\\n  // Storage - a set of logic contracts already migrated to, used to prevent duplicate updates.\\n  mapping(address => bool) migratedTo;\\n\\n  /**\\n   * A modifier that enforces that the method it's attached to gets invoked just\\n   * once during the specific logic contract tenure. It is used to enforce that\\n   * the migrate() method that is run right after the upgrade takes place cannot\\n   * be run anymore by the external caller.\\n   */\\n  modifier onlyOnce() {\\n    address implementationAddress;\\n\\n    assembly {\\n      implementationAddress := sload(EIP_1967_SLOT)\\n    }\\n\\n    require(!migratedTo[implementationAddress], \\\"This should only be called once\\\");\\n    migratedTo[implementationAddress] = true;\\n\\n    _;\\n  }\\n\\n  /**\\n   * Virtual logic migration method - intended to be called right after the\\n   * wallet is upgraded to a new logic version.\\n   *\\n   * @param previousImplementation the logic contract address before the upgrade\\n   * @return success a flag which is true if the migration was succesful\\n   */\\n  function migrate(address previousImplementation) virtual external returns (bool);\\n\\n  /**\\n   * Upgrade implementation proper. Overwrites the implementation slot and runs migrate().\\n   *\\n   * @param newImplementation new logic contract address\\n   */\\n  function _upgrade(address newImplementation) internal {\\n    address previousImplementation;\\n\\n    // Update the EIP-1967 implementation slot\\n    assembly {\\n      previousImplementation := sload(EIP_1967_SLOT)\\n      sstore(EIP_1967_SLOT, newImplementation)\\n    }\\n\\n    // Run the migrate() method via chained DELEGATECALL to self\\n    (bool success, bytes memory result) = newImplementation.delegatecall(abi.encodeCall(Upgradable.migrate, (previousImplementation)));\\n    require(success, \\\"migrate() call reverted\\\");\\n    require(abi.decode(result, (bool)), \\\"migrate() did not return true\\\");\\n  }\\n}\\n\"\r\n    },\r\n    \"src/contracts/Withdrawable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n// Imports\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\n\\n/**\\n * This is an abstract contract implementing withdraw functions allowing\\n * to take tokens or ethers out of the contract.\\n */\\nabstract contract Withdrawable {\\n  /**\\n   * An event emitted on a successful withdrawal.\\n   *\\n   * @param to withdrawal destination address\\n   * @param token contract address of the token being withdrawn (address(0) for Ether)\\n   * @param amount withdrawal amount\\n   * @param fee withdrawal fee paid to SlickSwap\\n   */\\n  event Withdraw(address indexed to, address token, uint256 amount, uint256 fee);\\n\\n  /**\\n   * An event emitted on a failed withdrawal.\\n   *\\n   * @param to withdrawal destination address\\n   * @param token contract address of the token being withdrawn (zero for Ether)\\n   * @param amount withdrawal amount\\n   * @param fee withdrawal fee paid to SlickSwap\\n   */\\n  event WithdrawFailed(address indexed to, address token, uint256 amount, uint256 fee);\\n\\n  /**\\n   * Attempts to withdraw tokens (or Ether if token is address(0)) in the given amount, transferring\\n   * the fee out to the fee recipient.\\n   *\\n   * @param to withdrawal destination address\\n   * @param token contract address of the token being withdrawn (address(0) for Ether)\\n   * @param amount withdrawal amount\\n   * @param fee withdrawal fee paid to SlickSwap\\n   * @param feeRecipient address to send the fee to\\n   *\\n   * @return a flag that is true on a successful withdrawal\\n   */\\n  function _withdraw(address to, address token, uint256 amount, uint256 fee, address feeRecipient) internal returns (bool) {\\n    if (token == address(0)) {\\n      return _withdrawEther(to, amount, fee, feeRecipient);\\n    } else {\\n      return _withdrawToken(to, token, amount, fee, feeRecipient);\\n    }\\n  }\\n\\n  /**\\n   * Attempts to withdraw tokens (and fee, if nonzero) to the address provided\\n   * using IERC-20 transfer() function.\\n   *\\n   * @param to withdrawal destination address\\n   * @param token contract address of the token being withdrawn (address(0) for Ether)\\n   * @param amount withdrawal amount\\n   * @param fee withdrawal fee paid to SlickSwap\\n   * @param feeRecipient address to send the fee to\\n   *\\n   * @return a flag that is true on a successful withdrawal\\n   */\\n  function _withdrawToken(address to, address token, uint256 amount, uint256 fee, address feeRecipient) internal returns (bool) {\\n    // invoke the transfer() function on the IERC-20 contract\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, amount));\\n\\n    // Special handling around noncompliant tokens (namely Tether)\\n    if (!success || (data.length > 0 && !abi.decode(data, (bool)))) {\\n      // log the event about failed withdrawal \u2013 maybe the user hasn't got enough tokens?\\n      emit WithdrawFailed(to, token, amount, fee);\\n      return false;\\n    }\\n\\n    // Take a fee if it is specified\\n    if (fee > 0) {\\n      TransferHelper.safeTransfer(token, feeRecipient, fee);\\n    }\\n\\n    // Emit successful withdrawal event\\n    emit Withdraw(to, token, amount, fee);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * Attempts to withdraw ethers (and fee, if nonzero) to the address provided.\\n   *\\n   * @param to withdrawal destination address\\n   * @param amount withdrawal amount\\n   * @param fee withdrawal fee paid to SlickSwap\\n   * @param feeRecipient address to send the fee to\\n   *\\n   * @return a flag that is true on a successful withdrawal\\n   */\\n  function _withdrawEther(address to, uint256 amount, uint256 fee, address feeRecipient) internal returns (bool) {\\n    // send Ethers to the address\\n    (bool success,) = to.call{ value: amount }(\\\"\\\");\\n\\n    if (!success) {\\n      // log the event about failed withdrawal \u2013 maybe the user hasn't got enough Ether?\\n      emit WithdrawFailed(to, address(0), amount, fee);\\n      return false;\\n    }\\n\\n    // Take a fee if it is specified\\n    if (fee > 0) {\\n      (success,) = feeRecipient.call{ value: fee }(\\\"\\\");\\n      require(success, \\\"Unable to capture withdrawal fee\\\");\\n    }\\n\\n    // Emit successful withdrawal event\\n    emit Withdraw(to, address(0), amount, fee);\\n\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/DummyLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ncontract DummyLogic {\\n  address ownerAddr;\\n\\n  function initialize(address owner) external {\\n    ownerAddr = owner;\\n  }\\n\\n  function readOwnerAddrViaDelegateCall() external view returns (address) {\\n    return ownerAddr;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n/**\\n * ERC-20 contract interface. See the ERC for method definitions and invariants.\\n */\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint);\\n  function balanceOf(address account) external view returns (uint);\\n  function transfer(address recipient, uint amount) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint);\\n  function approve(address spender, uint amount) external returns (bool);\\n  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint value);\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISlickSwapRegistryV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n/**\\n * This interface defines accessors to be present on the Registry contract.\\n */\\ninterface ISlickSwapRegistryV1 {\\n  /**\\n   * Returns the address that should receive fees from trading operations.\\n   */\\n  function getTradingFeeRecipient() external view returns (address);\\n\\n  /**\\n   * Returns the address that should receive fees from withdrawal operations.\\n   */\\n  function getWithdrawalFeeRecipient() external view returns (address);\\n\\n  /**\\n   * Returns the address of the most up-to-date SlickSwap implementation contract.\\n   */\\n  function getNextImplementation() external view returns (address);\\n\\n  /**\\n   * Reverts unless the provided address is allowed to trade.\\n   */\\n  function verifyTrader(address sender) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * Wrapped Ether (WETH) minting/burning interface.\\n */\\ninterface IWETH9 is IERC20 {\\n  function deposit() external payable;\\n  function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/UniswapV3Trading.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n// Imports\\nimport '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';\\nimport '@uniswap/lib/contracts/libraries/TransferHelper.sol';\\nimport '../interfaces/IWETH9.sol';\\nimport '../interfaces/IERC20.sol';\\n\\n/**\\n * This library provides routines for handling trading via Uniswap V3 exchange.\\n */\\nlibrary UniswapV3Trading {\\n  // Ethereum mainnet address of the UniswapV3Router\\n  address constant internal UNISWAP_V3_ROUTER_ADDRESS = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n  // Ethereum mainnet address of the Wrapped Ether\\n  address constant internal WETH9_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n  // Flags bit mask bit 0: equals 1 if first token in path is Ether (WETH wrapping/unwrapping is necessary).\\n  uint8 constant internal FLAGS_FIRST_TOKEN_IS_ETHER = (1 << 0);\\n  // Flags bit mask bit 1: equals 1 if the last token in path is Ether (WETH wrapping/unwrapping is necessary).\\n  uint8 constant internal FLAGS_LAST_TOKEN_IS_ETHER = (1 << 1);\\n  // Flags bit mask bit 2: equals 1 for \\\"exact in\\\" swaps, 0 for \\\"exact out\\\" swaps.\\n  uint8 constant internal FLAGS_IS_EXACT_IN = (1 << 2);\\n\\n  /**\\n   * A method which calls UniswapV3Router and (optionally) WETH9 to actually execute the trade.\\n   *\\n   * Paths are represented in UniswapV3 Periphery format - 20-byte token contract addresses interspersed with 3-byte fees.\\n   * For \\\"exact in\\\" swaps the paths are non-reversed (first token is \\\"in\\\" token and last token is \\\"out\\\" token) and reversed for \\\"exact out\\\" swaps.\\n   * If one swap side amount is fixed as \\\"exact\\\", the other side acts as an upper/lower bound to permitted slippage.\\n   *\\n   * @param path token exchange path in the aforementioned format\\n   * @param flags a 3-bit OR'ed bitmask of any subset of {FLAGS_FIRST_TOKEN_IS_ETHER, FLAGS_LAST_TOKEN_IS_ETHER, FLAGS_IS_EXACT_IN}\\n   * @param amountIn the \\\"in\\\" token amount (either exact or upper bound, depending on flags)\\n   * @param amountOut the \\\"out\\\" token amount (either exact or lower bound, depending on flags)\\n   *\\n   * @return success a flag indicating whether a swap was performed successfully\\n   * @return actualIn actually consumed amount of the \\\"in\\\" token\\n   * @return actualOut actually obtained amount of the \\\"out\\\" token\\n   * @return tokenIn contract address of the \\\"in\\\" token\\n   * @return tokenOut contract address of the \\\"out\\\" token\\n   * @return takeFeeInEther a flag indicating whether to take the fee in Ether\\n   */\\n  function performTrade(bytes memory path, uint8 flags, uint256 amountIn, uint256 amountOut) internal returns (bool success, uint256 actualIn, uint256 actualOut, address tokenIn, address tokenOut, bool takeFeeInEther) {\\n    takeFeeInEther = false;\\n\\n    // \\\"In\\\" token is Ether - wrap it as WETH\\n    if ((flags & FLAGS_FIRST_TOKEN_IS_ETHER) == FLAGS_FIRST_TOKEN_IS_ETHER) {\\n      (success,) = WETH9_ADDRESS.call{ value: amountIn }(abi.encodeWithSelector(IWETH9.deposit.selector));\\n\\n      if (!success) {\\n        return (false, 0, 0, address(0), address(0), false);\\n      }\\n    }\\n\\n    // Dispatch between \\\"exact in\\\" and \\\"exact out\\\" swaps; note the path encoding difference.\\n    if ((flags & FLAGS_IS_EXACT_IN) == FLAGS_IS_EXACT_IN) {\\n      (success, actualOut, tokenIn, tokenOut) = UniswapV3Trading.performExactInTrade(path, amountIn, amountOut);\\n      actualIn = amountIn;\\n    } else {\\n      (success, actualIn, tokenIn, tokenOut) = UniswapV3Trading.performExactOutTrade(path, amountIn, amountOut);\\n      actualOut = amountOut;\\n    }\\n\\n    // Handle failure\\n    if (!success) {\\n      return (false, 0, 0, address(0), address(0), false);\\n    }\\n\\n    // Clear approvals if leftover is present\\n    if (actualIn < amountIn) {\\n      TransferHelper.safeApprove(tokenIn, UNISWAP_V3_ROUTER_ADDRESS, 0);\\n\\n      // If there is leftover WETH, unwrap it to Ether\\n      if ((flags & FLAGS_FIRST_TOKEN_IS_ETHER) == FLAGS_FIRST_TOKEN_IS_ETHER) {\\n        IWETH9(WETH9_ADDRESS).withdraw(amountIn - actualIn);\\n      }\\n    }\\n\\n    // If the \\\"out\\\" token is Ether, unwrap WETH.\\n    if ((flags & FLAGS_LAST_TOKEN_IS_ETHER) == FLAGS_LAST_TOKEN_IS_ETHER) {\\n      takeFeeInEther = true;\\n      IWETH9(WETH9_ADDRESS).withdraw(actualOut);\\n    }\\n  }\\n\\n  /**\\n   * A helper to perform an \\\"exact in\\\" trade.\\n   *\\n   * @param path token exchange path in direct UniswapV3 format (first token is \\\"in\\\" token, last token is \\\"out\\\" token)\\n   * @param amountIn exact \\\"in\\\" amount to spend\\n   * @param amountOutMinimum lower bound on \\\"out\\\" amount (to limit slippage)\\n   *\\n   * @return success a flag indicating whether a swap was performed successfully\\n   * @return amount actually obtained amount of the \\\"out\\\" token\\n   * @return tokenIn contract address of the \\\"in\\\" token\\n   * @return tokenOut contract address of the \\\"out\\\" token\\n   */\\n  function performExactInTrade(bytes memory path, uint256 amountIn, uint256 amountOutMinimum) internal returns (bool success, uint256 amount, address tokenIn, address tokenOut) {\\n    // Extract \\\"endpoints\\\" from direct path\\n    // Right 96 bit shift is cheap way to get from big-endian uint256 to a 160 bit address at the same offset\\n    uint256 length = path.length - 20;\\n\\n    assembly {\\n      tokenIn := shr(96, mload(add(path, 0x20)))\\n      tokenOut := shr(96, mload(add(add(path, 0x20), length)))\\n    }\\n\\n    // Approve exact input spend\\n    TransferHelper.safeApprove(tokenIn, UNISWAP_V3_ROUTER_ADDRESS, amountIn);\\n\\n    // Perform the swap using UniswapV3 SwapRouter\\n    ISwapRouter swapRouter = ISwapRouter(UNISWAP_V3_ROUTER_ADDRESS);\\n\\n    ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams({\\n      path: path,\\n      recipient: address(this),\\n      deadline: block.timestamp,\\n      amountIn: amountIn,\\n      amountOutMinimum: amountOutMinimum\\n    });\\n\\n    // Catch the error, if any - do not revert.\\n    try swapRouter.exactInput(params) returns (uint256 value) {\\n      success = true;\\n      amount = value;\\n    } catch {\\n      success = false;\\n      amount = 0;\\n    }\\n  }\\n\\n  /**\\n   * A helper to perform an \\\"exact out\\\" trade.\\n   *\\n   * @param path token exchange path in reversed UniswapV3 format (first token is \\\"out\\\" token, last token is \\\"in\\\" token)\\n   * @param amountInMaximum upper bound on \\\"in\\\" amount to spend (to limit slippage)\\n   * @param amountOut exact \\\"out\\\" amount to obtain\\n   *\\n   * @return success a flag indicating whether a swap was performed successfully\\n   * @return amount actually consumed amount of the \\\"in\\\" token\\n   * @return tokenIn contract address of the \\\"in\\\" token\\n   * @return tokenOut contract address of the \\\"out\\\" token\\n   */\\n  function performExactOutTrade(bytes memory path, uint256 amountInMaximum, uint256 amountOut) internal returns (bool success, uint256 amount, address tokenIn, address tokenOut) {\\n    // Extract \\\"endpoints\\\" from direct path\\n    // Right 96 bit shift is cheap way to get from big-endian uint256 to a 160 bit address at the same offset\\n    uint256 length = path.length - 20;\\n\\n    assembly {\\n      tokenOut := shr(96, mload(add(path, 0x20)))\\n      tokenIn := shr(96, mload(add(add(path, 0x20), length)))\\n    }\\n\\n    // Approve \\\"input\\\" spend upper bound\\n    TransferHelper.safeApprove(tokenIn, UNISWAP_V3_ROUTER_ADDRESS, amountInMaximum);\\n\\n    // Perform the swap using UniswapV3 SwapRouter\\n    ISwapRouter swapRouter = ISwapRouter(UNISWAP_V3_ROUTER_ADDRESS);\\n\\n    ISwapRouter.ExactOutputParams memory params = ISwapRouter.ExactOutputParams({\\n      path: path,\\n      recipient: address(this),\\n      deadline: block.timestamp,\\n      amountOut: amountOut,\\n      amountInMaximum: amountInMaximum\\n    });\\n\\n    // Catch the error, if any - do not revert.\\n    try swapRouter.exactOutput(params) returns (uint256 value) {\\n      success = true;\\n      amount = value;\\n    } catch {\\n      success = false;\\n      amount = 0;\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/SlickSwapProxyDeployer.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.20;\\n\\n// SPDX-License-Identifier: MIT\\n\\n/**\\n * SlickSwap Proxy Deployer\\n *\\n * This is a factory contract which deploys minimal (58 bytes in size) proxy contracts to\\n * be used as individual SlickSwap contract wallets.\\n *\\n * All proxies have identical bytecode, but are initialized with the logic contract address stored in the\\n * EIP-1967 implementation slot (see IMPL_SLOT) that makes the implementation discoverable by block explorers.\\n *\\n * Logic contract address in storage allows contract upgrades; see specific implementation for exact conditions.\\n *\\n * Proxy bytecode is almost identical to EIP-1167 Minimal Proxy Contract (again, see initCode() below for details). The DELEGATECALL\\n * logic is fully transparent - calldata gets forwarded to the logic contract as-is, return data is unaltered as well.\\n */\\ncontract SlickSwapProxyDeployer {\\n  // EIP-1967 defines implementation slot as uint256(keccak256('eip1967.proxy.implementation')) - 1\\n  bytes32 constant IMPL_SLOT = hex'360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc';\\n\\n  /**\\n   * Deploy a new proxy contract with a deterministic address (see computeProxyAddress())\\n   *\\n   * @param salt arbitrary 256-bits of entropy provided by the deployer\\n   * @param implAddr the logic contract address (contains code to delegatecall)\\n   * @param constructorCalldata the calldata for a \\\"constructor\\\" method to call right away\\n   */\\n  function deployProxy(bytes32 salt, address implAddr, bytes calldata constructorCalldata) external {\\n    // deterministic proxy address\\n    address proxyAddress;\\n\\n    // proxy creation code instance\\n    bytes memory initCodeInst = initCode(implAddr);\\n\\n    // directly invoking CREATE2 unfortunately still requires assembly in 0.8.20^\\n    assembly {\\n      // \\\"bytes memory\\\" is laid out in memory as:\\n      //   1) mload(initCodeInst)     - 32 byte length\\n      //   2) add(initCodeInst, 0x20) - a byte array\\n      proxyAddress := create2(0, add(initCodeInst, 0x20), mload(initCodeInst), salt)\\n\\n      if iszero(extcodesize(proxyAddress)) {\\n          revert(0, 0)\\n      }\\n    }\\n\\n    // call the constructor immediately\\n    (bool success,) = proxyAddress.call(constructorCalldata);\\n    require(success, \\\"Proxy constructor reverted.\\\");\\n  }\\n\\n  /**\\n   * A way to predict the address of a proxy deployed with specific salt, owner & logic addresses.\\n   *\\n   * @param salt arbitrary 256-bits of entropy provided by the deployer\\n   * @param implAddr the logic contract address (contains code to delegatecall)\\n   *\\n   * @return the proxy deterministic address\\n   */\\n  function computeProxyAddress(bytes32 salt, address implAddr) external view returns (address) {\\n    // first compute the init code hash (it's different every time due to owner & impl addresses)\\n    bytes32 initCodeHash = keccak256(initCode(implAddr));\\n\\n    // then we may predict the EIP-1014 CREATE2 address\\n    return address(uint160(uint256(keccak256(abi.encodePacked(hex'ff', this, salt, initCodeHash)))));\\n  }\\n\\n  /**\\n   * Hand-written init code (total size 122 bytes):\\n   *\\n   *  === Creation time bytecode (64 bytes, parameterized by implAddr) ===\\n   *\\n   *  Offset         Bytecode            Opcode               Stack after               Comment\\n   *\\n   *  00..14           73 <20 bytes>     PUSH20 <implAddr>    implAddr\\n   *  15..35           7F <32 bytes>     PUSH32 <implSlot>    implSlot implAddr\\n   *  36               55                SSTORE                                         Store implementation address into EIP-1967 slot\\n   *  37..38           60 3A             PUSH1 <bcSz>         bcSz                      bcSz = 58 (0x3A)\\n   *  39               80                DUP1                 bcSz bcSz\\n   *  3A..3B           60 40             PUSH1 <bcOffs>       bcOffs bcSz bcSz          bc0ffs = 64 (0x40)\\n   *  3C               3D                RETURNDATASIZE       0 bcOffs bcSz bcSz        EIP-211 zero trick\\n   *  3D               39                CODECOPY             bcSz                      mem[0:bcSz] := code[bcOffs:bcOffs+bcSz]\\n   *  3E               3D                RETURNDATASIZE       0 bcSz\\n   *  3F               F3                RETURN                                         mem[0:bcSz] - returns proxy bytecode\\n   *\\n   *  === Deployed proxy bytecode (58 bytes, identical for all proxies) ===\\n   *\\n   *  Offset  (-0x40)  Bytecode          Opcode               Stack after               Comment\\n   *\\n   *  40      00       36                CALLDATASIZE         cds\\n   *  41      01       3D                RETURNDATASIZE       0 cds                     EIP-211 zero trick\\n   *  42      02       3D                RETURNDATASIZE       0 0 cds\\n   *  43      03       37                CALLDATACOPY                                   mem[0:cds] = calldata\\n   *  44      04       3D                RETURNDATASIZE       0\\n   *  45      05       3D                RETURNDATASIZE       0 0\\n   *  46      06       3D                RETURNDATASIZE       0 0 0\\n   *  47      07       36                CALLDATASIZE         cds 0 0 0\\n   *  48      08       3D                RETURNDATASIZE       0 cds 0 0 0\\n   *  49..69  09..29   7F <32 bytes>     PUSH32 <implSlot>    implSlot 0 cds 0 0 0\\n   *  6A      2A       54                SLOAD                implAddr 0 cds 0 0 0      Read implAddr from EIP-1967 slot\\n   *  6B      2B       5A                GAS                  gas implAddr 0 cds 0 0 0\\n   *  6C      2C       F4                DELEGATECALL         suc 0                     Delegatecall implAddr with full calldata and gas\\n   *  6D      2D       3D                RETURNDATASIZE       rds suc 0                 NB: EIP-211 zero trick doesn't work anymore\\n   *  6E      2E       82                DUP3                 0 rds suc 0\\n   *  6F      2F       80                DUP1                 0 0 rds suc 0\\n   *  70      30       3E                RETURNDATACOPY       suc 0                     mem[0:rds] := returndata[0:rds]\\n   *  71      31       90                SWAP1                0 suc\\n   *  72      32       3D                RETURNDATASIZE       rds 0 suc\\n   *  73      33       91                SWAP2                suc 0 rds\\n   *  74..75  34..35   60 38             PUSH1 :success:      :success: suc 0 rds\\n   *  76      36       57                JUMPI                0 rds                     jumps to :success: if suc != 0\\n   *  77      37       FD                REVERT\\n   *  78      38       5B                JUMPDEST                                       :success: label\\n   *  79      39       F3                RETURN\\n   *\\n   * NB: Proxy bytecode is identical to EIP-1167 Minimal Proxy Contract with two changes - instead of pushing implAddr on stack\\n   *     directly we load it from storage at EIP-1967 slot (offsets 09..2A), and adjusted jump destination (offset 35). These changes\\n   *     were introduced to support individual upgradeability and resulted in proxy size being inflated from 44 bytes to 58 bytes.\\n   *\\n   * @param implAddr the logic contract address (contains code to delegatecall)\\n   *\\n   * @return the proxy initcode\\n   */\\n  function initCode(address implAddr) internal pure returns (bytes memory) {\\n    return abi.encodePacked(\\n      // creation time bytecode\\n      hex'73', implAddr, hex'7f', IMPL_SLOT, hex'55603A8060403d393df3',\\n      // deployed proxy bytecode\\n      hex'363d3d373d3d3d363d7f', IMPL_SLOT, hex'545af43d82803e903d91603857fd5bf3'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"src/SlickSwapRegistryV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n// Imports\\nimport './contracts/Ownable.sol';\\nimport './interfaces/ISlickSwapRegistryV1.sol';\\n\\n/**\\n * SlickSwapRegistryV1 - this contract stores various system settings used by\\n * the individual SlickSwap wallet contracts.\\n *\\n * This contract is immutable (unlike wallet contracts, which are individually upgradeable).\\n * Newer SlickSwap versions may introduce additional Registry contracts for new settings.\\n */\\ncontract SlickSwapRegistryV1 is Ownable, ISlickSwapRegistryV1 {\\n  // Storage variables\\n  address public _tradingFeeRecipient;\\n  address public _withdrawalFeeRecipient;\\n  address public _nextImplementation;\\n  mapping(address => bool) public _traderAddresses;\\n\\n  /**\\n   * Initializes the contract and assigns the owner to the signer\\n   * of the deployment transaction.\\n   */\\n  constructor() {\\n    _owner = msg.sender;\\n  }\\n\\n  /**\\n   * Returns the address that should receive fees from trading operations.\\n   */\\n  function getTradingFeeRecipient() external view returns (address) {\\n    return _tradingFeeRecipient;\\n  }\\n\\n  /**\\n   * Returns the address that should receive fees from trading operations.\\n   */\\n  function getWithdrawalFeeRecipient() external view returns (address) {\\n    return _withdrawalFeeRecipient;\\n  }\\n\\n  /**\\n   * Returns the address of the most up-to-date SlickSwap implementation contract.\\n   */\\n  function getNextImplementation() external view returns (address) {\\n    return _nextImplementation;\\n  }\\n\\n  /**\\n   * Validates that the address is indeed authorized to settle SlickSwap trades.\\n   *\\n   * @param sender the address calling the trade method\\n   */\\n  function verifyTrader(address sender) external view {\\n    require(_traderAddresses[sender], \\\"The address is not allowed to trade\\\");\\n  }\\n\\n  /**\\n   * Updates the address that should receive fees from trading operations.\\n   * Called by Registry owner.\\n   *\\n   * @param tradingFeeRecipient new trading fee recipient.\\n   */\\n  function setTradingFeeRecipient(address tradingFeeRecipient) external onlyBy(_owner) {\\n    _tradingFeeRecipient = tradingFeeRecipient;\\n  }\\n\\n  /**\\n   * Updates the address that should receive fees from withdrawal operations.\\n   * Called by Registry owner.\\n   *\\n   * @param withdrawalFeeRecipient new withdrawal fee recipient\\n   */\\n  function setWithdrawalFeeRecipient(address withdrawalFeeRecipient) external onlyBy(_owner) {\\n    _withdrawalFeeRecipient = withdrawalFeeRecipient;\\n  }\\n\\n  /**\\n   * Updates the address of the most up-to-date SlickSwap implementation contract.\\n   * Called by Registry owner.\\n   *\\n   * @param nextImplementation new address of the SlickSwap logic contract.\\n   */\\n  function setNextImplementation(address nextImplementation) external onlyBy(_owner) {\\n    _nextImplementation = nextImplementation;\\n  }\\n\\n  /**\\n   * Adds/removes the address of the account authorized to perform the trades.\\n   * Called by Registry owner.\\n   *\\n   * @param traderAddress address in consideration\\n   * @param enable adding represented by true, removing by false\\n   */\\n  function enableTradingFor(address traderAddress, bool enable) external onlyBy(_owner) {\\n    _traderAddresses[traderAddress] = enable;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/SlickSwapV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.20;\\npragma abicoder v2;\\n\\n// Imports\\nimport './contracts/Ownable.sol';\\nimport './contracts/Trading.sol';\\nimport './contracts/EtherHolder.sol';\\nimport './contracts/Withdrawable.sol';\\nimport './contracts/Upgradable.sol';\\nimport './interfaces/ISlickSwapRegistryV1.sol';\\n\\n/**\\n * SlickSwap smart contract wallet, version 1\\n *\\n * This is a logic contract intended to be used with the minimal EIP-1967 proxy.\\n * See {proxyDeployer} for provisioning details.\\n *\\n * This wallet can be used to:\\n *  - deposit and hold Ether and ERC-20 tokens\\n *  - withdraw Ether and ERC-20 tokens anytime by means of wallet Owner signature\\n *  - perform Uniswap V3 trades by means of SlickSwap bot\\n *\\n * Owner keys are managed either by SlickSwap or externally (by a Web3 wallet,\\n * for example). In the former case SlickSwap invokes withdrawal and logic\\n * upgrade methods on Owner's behalf by explicitly passing in an ECDSA signature\\n * as an argument; in the latter case the corresponding methods are invoked\\n * directly from the Owner address.\\n *\\n * Wallet contracts are individually upgradeable - each instance can either explicitly\\n * authorize the logic change by means of Owner public key, or opt out.\\n */\\ncontract SlickSwapV1 is Ownable, Trading, EtherHolder, Withdrawable, Upgradable {\\n  // Storage variables\\n  ISlickSwapRegistryV1 immutable _registry;\\n\\n  /**\\n   * Logic contract constructor - creates the common bytecode.\\n   *\\n   * @param registry The address of the Registry contract\\n   */\\n  constructor(address registry) {\\n    _registry = ISlickSwapRegistryV1(registry);\\n  }\\n\\n  /**\\n   * Wallet initializer - invoked on EIP-1967 proxy right after its deployment\\n   * to set up a new instance.\\n   *\\n   * @param owner address of the wallet Owner.\\n   */\\n  function initialize(address owner) external {\\n    require(_owner == address(0), \\\"You can only initialize the contract once\\\");\\n    _owner = owner;\\n  }\\n\\n  /**\\n   * Logic migration method - intended to be called right after the wallet is\\n   * upgraded to a new logic version. The sole parameter is the address of the\\n   * previous logic contract. No-op as this is version 1.\\n   *\\n   * The very presence of this method is used as a safeguard against upgrades to\\n   * \\\"dead\\\" logic addresses, such as zero address, self-destructed contracts or\\n   * contracts with the wrong interface.\\n   */\\n  function migrate(address) override external onlyOnce returns (bool) {\\n    return true;\\n  }\\n\\n  /**\\n   * Upgrade the contract to the latest logic version. To be called directly by the wallet Owner.\\n   */\\n  function upgrade() external onlyBy(_owner) {\\n    _upgrade(_registry.getNextImplementation());\\n  }\\n\\n  /**\\n   * Upgrade the contract to the latest logic version. To be called on Owner's behalf.\\n   *\\n   * @param signature an ECDSA signature of the authorization with the Owner's public key\\n   */\\n\\n  function upgrade(Signature calldata signature) external onlySignedBy(_owner, keccak256(abi.encodePacked()), signature) {\\n    _upgrade(_registry.getNextImplementation());\\n  }\\n\\n  /**\\n   * Perform a trade. To be called by a Trader - an address listed in Registry\\n   * as eligible to settle trades.\\n   *\\n   * @param tradeId a unique identifier of the trade for SlickSwap internal bookkeeping\\n   * @param broker the type of the broker (the only supported value is 1, meaning Uniswap V3)\\n   * @param path token exchange path, in the format of a specific broker\\n   * @param flags a bitmask representing trade settings, see Trading contract for details\\n   * @param amountIn amount of the \\\"source\\\" token to trade\\n   * @param amountOut amount of the \\\"destination\\\" token to trade\\n   * @param amountFee amount of the \\\"destination\\\" taken by SlickSwap as a fee. Enforced to be less than 3%.\\n   *\\n   * @return success a flag indicating whether a swap was performed successfully\\n   */\\n  function trade(uint256 tradeId, uint8 broker, bytes memory path, uint8 flags, uint256 amountIn, uint256 amountOut, uint256 amountFee) external returns (bool success) {\\n    _registry.verifyTrader(msg.sender);\\n    return _trade(tradeId, broker, path, flags, amountIn, amountOut, amountFee, _registry.getTradingFeeRecipient());\\n  }\\n\\n  /**\\n   * Token (including Ether) withdrawal. To be called directly by the wallet Owner.\\n   * No fee is taken.\\n   *\\n   * @param to withdrawal destination address\\n   * @param token the ERC-20 contract address, or zero for Ether\\n   * @param amount withdrawal amount\\n   *\\n   * @return bool withdrawal success flag\\n   */\\n  function withdraw(address to, address token, uint256 amount) external onlyBy(_owner) returns (bool) {\\n    return _withdraw(to, token, amount, 0, address(0));\\n  }\\n\\n  /**\\n   * Token (including Ether) withdrawal. To be called on Owner's behalf.\\n   * A fixed fee is taken on top of the withdrawal amount.\\n   *\\n   * @param to withdrawal destination address\\n   * @param token the ERC-20 contract address, or zero for Ether\\n   * @param amount withdrawal amount\\n   * @param fee withdrawal fee\\n   * @param signature an ECDSA signature of the authorization with the Owner's public key\\n   *\\n   * @return bool withdrawal success flag\\n   */\\n  function withdraw(address to, address token, uint256 amount, uint256 fee, Signature calldata signature) external onlySignedBy(_owner, keccak256(abi.encodePacked(to, token, amount, fee)), signature) returns (bool) {\\n    return _withdraw(to, token, amount, fee, _registry.getWithdrawalFeeRecipient());\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"_lastNonce\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_nextImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_nextOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_traderAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tradingFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_withdrawalFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"}],\"internalType\":\"struct Ownable.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"acceptNextOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"traderAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"enableTradingFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradingFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawalFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextImplementation\",\"type\":\"address\"}],\"name\":\"setNextImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner\",\"type\":\"address\"}],\"name\":\"setNextOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint96\",\"name\":\"nonce\",\"type\":\"uint96\"}],\"internalType\":\"struct Ownable.Signature\",\"name\":\"signature\",\"type\":\"tuple\"}],\"name\":\"setNextOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tradingFeeRecipient\",\"type\":\"address\"}],\"name\":\"setTradingFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"withdrawalFeeRecipient\",\"type\":\"address\"}],\"name\":\"setWithdrawalFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"verifyTrader\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SlickSwapRegistryV1", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e40454944087faba3cca44c1fb529d23d574256b0488440672e14e890196fb96"}