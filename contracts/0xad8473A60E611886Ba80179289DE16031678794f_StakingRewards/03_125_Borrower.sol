// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;

import "../core/BaseUpgradeablePausable.sol";
import "../core/ConfigHelper.sol";
import "../core/CreditLine.sol";
import "../core/GoldfinchConfig.sol";
import "../../interfaces/IERC20withDec.sol";
import "../../interfaces/ITranchedPool.sol";
import "../../interfaces/IBorrower.sol";
import "../../external/BaseRelayRecipient.sol";
import "@openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol";

/**
 * @title Goldfinch's Borrower contract
 * @notice These contracts represent the a convenient way for a borrower to interact with Goldfinch
 *  They are 100% optional. However, they let us add many sophisticated and convient features for borrowers
 *  while still keeping our core protocol small and secure. We therefore expect most borrowers will use them.
 *  This contract is the "official" borrower contract that will be maintained by Goldfinch governance. However,
 *  in theory, anyone can fork or create their own version, or not use any contract at all. The core functionality
 *  is completely agnostic to whether it is interacting with a contract or an externally owned account (EOA).
 * @author Goldfinch
 */

contract Borrower is BaseUpgradeablePausable, BaseRelayRecipient, IBorrower {
  using SafeMath for uint256;

  GoldfinchConfig public config;
  using ConfigHelper for GoldfinchConfig;

  address private constant USDT_ADDRESS = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);
  address private constant BUSD_ADDRESS = address(0x4Fabb145d64652a948d72533023f6E7A623C7C53);
  address private constant GUSD_ADDRESS = address(0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd);
  address private constant DAI_ADDRESS = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);

  function initialize(address owner, address _config) external override initializer {
    require(owner != address(0) && _config != address(0), "Owner and config addresses cannot be empty");
    __BaseUpgradeablePausable__init(owner);
    config = GoldfinchConfig(_config);

    trustedForwarder = config.trustedForwarderAddress();

    // Handle default approvals. Pool, and OneInch for maximum amounts
    address oneInch = config.oneInchAddress();
    IERC20withDec usdc = config.getUSDC();
    usdc.approve(oneInch, uint256(-1));
    bytes memory data = abi.encodeWithSignature("approve(address,uint256)", oneInch, uint256(-1));
    _invoke(USDT_ADDRESS, data);
    _invoke(BUSD_ADDRESS, data);
    _invoke(GUSD_ADDRESS, data);
    _invoke(DAI_ADDRESS, data);
  }

  function lockJuniorCapital(address poolAddress) external onlyAdmin {
    ITranchedPool(poolAddress).lockJuniorCapital();
  }

  function lockPool(address poolAddress) external onlyAdmin {
    ITranchedPool(poolAddress).lockPool();
  }

  /**
   * @notice Allows a borrower to drawdown on their credit line through a TranchedPool.
   * @param poolAddress The creditline from which they would like to drawdown
   * @param amount The amount, in USDC atomic units, that a borrower wishes to drawdown
   * @param addressToSendTo The address where they would like the funds sent. If the zero address is passed,
   *  it will be defaulted to the contracts address (msg.sender). This is a convenience feature for when they would
   *  like the funds sent to an exchange or alternate wallet, different from the authentication address
   */
  function drawdown(
    address poolAddress,
    uint256 amount,
    address addressToSendTo
  ) external onlyAdmin {
    ITranchedPool(poolAddress).drawdown(amount);

    if (addressToSendTo == address(0) || addressToSendTo == address(this)) {
      addressToSendTo = _msgSender();
    }

    transferERC20(config.usdcAddress(), addressToSendTo, amount);
  }

  function drawdownWithSwapOnOneInch(
    address poolAddress,
    uint256 amount,
    address addressToSendTo,
    address toToken,
    uint256 minTargetAmount,
    uint256[] calldata exchangeDistribution
  ) public onlyAdmin {
    // Drawdown to the Borrower contract
    ITranchedPool(poolAddress).drawdown(amount);

    // Do the swap
    swapOnOneInch(config.usdcAddress(), toToken, amount, minTargetAmount, exchangeDistribution);

    // Default to sending to the owner, and don't let funds stay in this contract
    if (addressToSendTo == address(0) || addressToSendTo == address(this)) {
      addressToSendTo = _msgSender();
    }

    // Fulfill the send to
    bytes memory _data = abi.encodeWithSignature("balanceOf(address)", address(this));
    uint256 receivedAmount = _toUint256(_invoke(toToken, _data));
    transferERC20(toToken, addressToSendTo, receivedAmount);
  }

  function transferERC20(
    address token,
    address to,
    uint256 amount
  ) public onlyAdmin {
    bytes memory _data = abi.encodeWithSignature("transfer(address,uint256)", to, amount);
    _invoke(token, _data);
  }

  /**
   * @notice Allows a borrower to pay back loans by calling the `pay` function directly on a TranchedPool
   * @param poolAddress The credit line to be paid back
   * @param amount The amount, in USDC atomic units, that the borrower wishes to pay
   */
  function pay(address poolAddress, uint256 amount) external onlyAdmin {
    IERC20withDec usdc = config.getUSDC();
    bool success = usdc.transferFrom(_msgSender(), address(this), amount);
    require(success, "Failed to transfer USDC");
    _transferAndPay(usdc, poolAddress, amount);
  }

  function payMultiple(address[] calldata pools, uint256[] calldata amounts) external onlyAdmin {
    require(pools.length == amounts.length, "Pools and amounts must be the same length");

    uint256 totalAmount;
    for (uint256 i = 0; i < amounts.length; i++) {
      totalAmount = totalAmount.add(amounts[i]);
    }

    IERC20withDec usdc = config.getUSDC();
    // Do a single transfer, which is cheaper
    bool success = usdc.transferFrom(_msgSender(), address(this), totalAmount);
    require(success, "Failed to transfer USDC");

    for (uint256 i = 0; i < amounts.length; i++) {
      _transferAndPay(usdc, pools[i], amounts[i]);
    }
  }

  function payInFull(address poolAddress, uint256 amount) external onlyAdmin {
    IERC20withDec usdc = config.getUSDC();
    bool success = usdc.transferFrom(_msgSender(), address(this), amount);
    require(success, "Failed to transfer USDC");

    _transferAndPay(usdc, poolAddress, amount);
    require(ITranchedPool(poolAddress).creditLine().balance() == 0, "Failed to fully pay off creditline");
  }

  function payWithSwapOnOneInch(
    address poolAddress,
    uint256 originAmount,
    address fromToken,
    uint256 minTargetAmount,
    uint256[] calldata exchangeDistribution
  ) external onlyAdmin {
    transferFrom(fromToken, _msgSender(), address(this), originAmount);
    IERC20withDec usdc = config.getUSDC();
    swapOnOneInch(fromToken, address(usdc), originAmount, minTargetAmount, exchangeDistribution);
    uint256 usdcBalance = usdc.balanceOf(address(this));
    _transferAndPay(usdc, poolAddress, usdcBalance);
  }

  function payMultipleWithSwapOnOneInch(
    address[] calldata pools,
    uint256[] calldata minAmounts,
    uint256 originAmount,
    address fromToken,
    uint256[] calldata exchangeDistribution
  ) external onlyAdmin {
    require(pools.length == minAmounts.length, "Pools and amounts must be the same length");

    uint256 totalMinAmount = 0;
    for (uint256 i = 0; i < minAmounts.length; i++) {
      totalMinAmount = totalMinAmount.add(minAmounts[i]);
    }

    transferFrom(fromToken, _msgSender(), address(this), originAmount);

    IERC20withDec usdc = config.getUSDC();
    swapOnOneInch(fromToken, address(usdc), originAmount, totalMinAmount, exchangeDistribution);

    for (uint256 i = 0; i < minAmounts.length; i++) {
      _transferAndPay(usdc, pools[i], minAmounts[i]);
    }

    uint256 remainingUSDC = usdc.balanceOf(address(this));
    if (remainingUSDC > 0) {
      _transferAndPay(usdc, pools[0], remainingUSDC);
    }
  }

  function _transferAndPay(
    IERC20withDec usdc,
    address poolAddress,
    uint256 amount
  ) internal {
    ITranchedPool pool = ITranchedPool(poolAddress);
    // We don't use transferFrom since it would require a separate approval per creditline
    bool success = usdc.transfer(address(pool.creditLine()), amount);
    require(success, "USDC Transfer to creditline failed");
    pool.assess();
  }

  function transferFrom(
    address erc20,
    address sender,
    address recipient,
    uint256 amount
  ) internal {
    bytes memory _data;
    // Do a low-level _invoke on this transfer, since Tether fails if we use the normal IERC20 interface
    _data = abi.encodeWithSignature("transferFrom(address,address,uint256)", sender, recipient, amount);
    _invoke(address(erc20), _data);
  }

  function swapOnOneInch(
    address fromToken,
    address toToken,
    uint256 originAmount,
    uint256 minTargetAmount,
    uint256[] calldata exchangeDistribution
  ) internal {
    bytes memory _data = abi.encodeWithSignature(
      "swap(address,address,uint256,uint256,uint256[],uint256)",
      fromToken,
      toToken,
      originAmount,
      minTargetAmount,
      exchangeDistribution,
      0
    );
    _invoke(config.oneInchAddress(), _data);
  }

  /**
   * @notice Performs a generic transaction.
   * @param _target The address for the transaction.
   * @param _data The data of the transaction.
   * Mostly copied from Argent:
   * https://github.com/argentlabs/argent-contracts/blob/develop/contracts/wallet/BaseWallet.sol#L111
   */
  function _invoke(address _target, bytes memory _data) internal returns (bytes memory) {
    // External contracts can be compiled with different Solidity versions
    // which can cause "revert without reason" when called through,
    // for example, a standard IERC20 ABI compiled on the latest version.
    // This low-level call avoids that issue.

    bool success;
    bytes memory _res;
    // solhint-disable-next-line avoid-low-level-calls
    (success, _res) = _target.call(_data);
    if (!success && _res.length > 0) {
      // solhint-disable-next-line no-inline-assembly
      assembly {
        returndatacopy(0, 0, returndatasize())
        revert(0, returndatasize())
      }
    } else if (!success) {
      revert("VM: wallet _invoke reverted");
    }
    return _res;
  }

  function _toUint256(bytes memory _bytes) internal pure returns (uint256 value) {
    assembly {
      value := mload(add(_bytes, 0x20))
    }
  }

  // OpenZeppelin contracts come with support for GSN _msgSender() (which just defaults to msg.sender)
  // Since there are two different versions of the function in the hierarchy, we need to instruct solidity to
  // use the relay recipient version which can actually pull the real sender from the parameters.
  // https://www.notion.so/My-contract-is-using-OpenZeppelin-How-do-I-add-GSN-support-2bee7e9d5f774a0cbb60d3a8de03e9fb
  function _msgSender() internal view override(ContextUpgradeSafe, BaseRelayRecipient) returns (address payable) {
    return BaseRelayRecipient._msgSender();
  }

  function _msgData() internal view override(ContextUpgradeSafe, BaseRelayRecipient) returns (bytes memory ret) {
    return BaseRelayRecipient._msgData();
  }

  function versionRecipient() external view override returns (string memory) {
    return "2.0.0";
  }
}