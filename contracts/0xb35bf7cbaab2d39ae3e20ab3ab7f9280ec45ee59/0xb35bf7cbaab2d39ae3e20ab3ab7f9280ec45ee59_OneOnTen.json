{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n/**\r\n * @title OneOnTen\r\n *\r\n *\r\n * Decentralized gaming room contract that allows players to join rooms and compete.\r\n * \r\n *\r\n * Two modes available : \r\n * - 1v1 gives you 50% probability of winning ( you win 80% of the total pledge of all players ). This mode finishes as soon as the second player enter the room.\r\n * - 1v10 gives you 10% probability of winning ( you win 80% of the total pledge of all players ). This mode finishes as soon as the 10th player enters the room, or after around 1200 mined blocks - around 4h ( you are refunded after the timer ends if no other player's joined ).\r\n *\r\n *\r\n * In order to access a gaming room you just need to enter the desired ETH amount you want to play and select the game mode.\r\n *\r\n * Different rooms fees : \r\n * - 0.01 ETH --> you win :\r\n * - - - - - - - - 0.016 ETH in 1v1\r\n * - - - - - - - - 0.08 ETH in 1v10\r\n *\r\n * - 0.03 ETH --> you win :\r\n * - - - - - - - - 0.048 ETH in 1v1\r\n * - - - - - - - - 0.24 ETH in 1v10\r\n *\r\n * - 0.1 ETH --> you win :\r\n * - - - - - - - - 0.16 ETH in 1v1\r\n * - - - - - - - - 0.8 ETH in 1v10\r\n *\r\n * - 1 ETH --> you win :\r\n * - - - - - - - - 1.6 ETH in 1v1\r\n * - - - - - - - - 8 ETH in 1v10\r\n *\r\n * - 10 ETH --> you win :\r\n * - - - - - - - - 16 ETH in 1v1\r\n * - - - - - - - - 80 ETH in 1v10\r\n *\r\n */\r\ncontract OneOnTen {\r\n    struct Room {\r\n        uint256 entryFee;\r\n        uint8 maxPlayers;\r\n        address[] players;\r\n        uint256 startTimeBlock;\r\n        bool isActive;\r\n    }\r\n\r\n    uint256 public constant BLOCKS_FOR_4_HOURS = 1200;\r\n    uint256 public constant MAX_PLAYERS_1v1 = 2;\r\n    uint256 public constant MAX_PLAYERS_1v10 = 10;\r\n    uint256[] public activeRoomIds;\r\n\r\n    Room[] internal rooms;\r\n    mapping(uint8 => uint256) public roomTypeToEntryFee;\r\n\r\n    event PlayerJoined(uint256 roomId, address player);\r\n    event RoomCreated(uint256 roomId, uint256 entryFee, uint8 maxPlayers);\r\n    event TimerStarted(uint256 roomId, uint256 startBlock);\r\n    event TimerEnded(uint256 roomId);\r\n    event PlayerRefunded(address player, uint256 amount);\r\n    event WinnerPaid(address winner, uint256 amount);\r\n    event RoomDeactivated(uint256 roomId);\r\n    event MissingBlocks(uint256 roomId, uint256 missingBlocks);\r\n    event Debug(string message, uint256 value);\r\n\r\n\r\n    constructor() {\r\n        roomTypeToEntryFee[1] = 0.01 ether;\r\n        roomTypeToEntryFee[2] = 0.03 ether;\r\n        roomTypeToEntryFee[3] = 0.1 ether;\r\n        roomTypeToEntryFee[4] = 1 ether;\r\n        roomTypeToEntryFee[5] = 10 ether;\r\n    }\r\n\r\n    /**\r\n     * @dev External function allowing a player to enter a 1v1 room.\r\n     *      This function is payable, meaning it can accept ether.\r\n     *      It calls the internal {enterRoom} function with MAX_PLAYERS_1v1 as the parameter.\r\n     *\r\n     * @notice The transaction must include the required entry fee in ether.\r\n     *\r\n     * Emits all events through {enterRoom}.\r\n     */\r\n    function enterRoom1v1() external payable {\r\n        enterRoom(uint8(MAX_PLAYERS_1v1));\r\n    }\r\n\r\n    /**\r\n     * @dev External function allowing a player to enter a 1v10 room.\r\n     *      This function is payable, meaning it can accept ether.\r\n     *      It calls the internal {enterRoom} function with MAX_PLAYERS_1v10 as the parameter.\r\n     *\r\n     * @notice The transaction must include the required entry fee in ether.\r\n     *\r\n     * Emits all events through {enterRoom}.\r\n     */\r\n    function enterRoom1v10() external payable {\r\n        enterRoom(uint8(MAX_PLAYERS_1v10));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Internal function to handle the logic for a player to enter a room.\r\n     *      This function will either find an active room or create one if none are available.\r\n     *\r\n     * @param maxPlayers The maximum number of players that the room can have.\r\n     *\r\n     * The sent ether must be enough for the entry fee.\r\n     *\r\n     * Emits a {PlayerJoined} event.\r\n     * Calls {endTimer} to check and conclude any filled or expired rooms.\r\n     * Calls {startTimer} to initiate the timer for a new room.\r\n     *\r\n     * Debug events are for testing and can be removed later.\r\n     */\r\n    function enterRoom(uint8 maxPlayers) internal {\r\n\r\n        endTimer();\r\n\r\n        uint256 entryFee = getRoomTypeBasedOnValue(msg.value);\r\n        emit Debug(\"Entry fee calculated\", entryFee);\r\n        require(entryFee > 0, \"Entry fee must be greater than 0\");\r\n\r\n        uint256 roomId = getOrCreateActiveRoom(entryFee, maxPlayers);\r\n        emit Debug(\"Room ID received\", roomId);\r\n        \r\n        Room storage room = rooms[roomId];\r\n        room.players.push(msg.sender);\r\n        emit PlayerJoined(roomId, msg.sender);\r\n\r\n        if (room.players.length == 1) {\r\n            startTimer(roomId);\r\n        }\r\n\r\n        endTimer();\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the timer for the room by setting the room's `startTimeBlock` to the current block number.\r\n     * @param roomId The ID of the room for which the timer is to be started.\r\n     * @notice This function emits a `TimerStarted` event after successfully starting the timer.\r\n     */\r\n    function startTimer(uint256 roomId) internal {\r\n        Room storage room = rooms[roomId];\r\n        room.startTimeBlock = block.number;\r\n        emit TimerStarted(roomId, block.number);\r\n    }\r\n\r\n    /**\r\n     * @dev Ends the timer for active rooms based on certain conditions.\r\n     *      - If a 1v1 room has 2 players.\r\n     *      - If a 1v10 room has 10 players.\r\n     *      - If the room's timer has exceeded a 4-hour block time.\r\n     *      \r\n     * After the timer ends, the function handles the payout or refund logic.\r\n     * It also deactivates the room and removes it from the active rooms list.\r\n     * \r\n     * @notice This function emits a `TimerEnded` event for each room whose timer is ended.\r\n     * It also emits a `RoomDeactivated` event for rooms that are deactivated.\r\n     * Further events may be emitted for payouts and refunds (see `payout` and `refundPlayer`).\r\n     */\r\n    function endTimer() internal {\r\n        uint256 i = 0;\r\n        while (i < activeRoomIds.length) {\r\n            uint256 roomId = activeRoomIds[i];\r\n            Room storage room = rooms[roomId];\r\n            if (room.isActive) {\r\n                if ((room.maxPlayers == MAX_PLAYERS_1v1 && room.players.length == MAX_PLAYERS_1v1) || \r\n                    (room.maxPlayers == MAX_PLAYERS_1v10 && room.players.length == MAX_PLAYERS_1v10) || \r\n                    (block.number >= room.startTimeBlock + BLOCKS_FOR_4_HOURS)) {\r\n                    \r\n                    emit TimerEnded(roomId);\r\n                    if (room.players.length == 1) {\r\n                        address solePlayer = room.players[0];\r\n                        refundPlayer(solePlayer, room.entryFee);\r\n                    } else if (room.players.length > 1) {  \r\n                        uint256 randomness = uint256(keccak256(abi.encodePacked(block.timestamp, block.number, msg.sender)));\r\n                        address winner = room.players[randomness % room.players.length];\r\n                        uint256 totalPayout = room.players.length * room.entryFee;\r\n                        uint256 winnerPayout = (totalPayout * 8) / 10;\r\n                        payout(winner, winnerPayout);\r\n                    }\r\n\r\n                    room.isActive = false;\r\n                    emit RoomDeactivated(roomId);\r\n                    \r\n                    activeRoomIds[i] = activeRoomIds[activeRoomIds.length - 1];\r\n                    activeRoomIds.pop();\r\n                } else {\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Searches for an active room that matches the given entry fee and maximum players.\r\n     *      If no such room exists, a new room is created.\r\n     * \r\n     * @param entryFee The entry fee to search or create a room with.\r\n     * @param maxPlayers The maximum number of players allowed in the room.\r\n     * \r\n     * @return uint256 The ID of the room that was found or created.\r\n     * \r\n     * @notice This function emits a `RoomCreated` event if a new room is created.\r\n     * It also emits Debug events for debugging purposes; these can be removed in production.\r\n     */\r\n    function getOrCreateActiveRoom(uint256 entryFee, uint8 maxPlayers) internal returns (uint256) {\r\n        emit Debug(\"Entering getOrCreateActiveRoom\", entryFee);\r\n        for (uint256 i = 0; i < activeRoomIds.length; i++) {\r\n            uint256 roomId = activeRoomIds[i];\r\n            Room storage room = rooms[roomId];\r\n            require(room.isActive && room.players.length < room.maxPlayers, \"Room conditions changed\");\r\n            emit Debug(\"Checking room with ID\", roomId);\r\n            if (room.entryFee == entryFee && room.isActive && room.players.length < room.maxPlayers && room.maxPlayers == maxPlayers) {\r\n                return roomId;\r\n            }\r\n        }\r\n        Room memory newRoom = Room(entryFee, maxPlayers, new address[](0), 0, true);\r\n        rooms.push(newRoom);\r\n        uint256 newRoomId = rooms.length - 1;\r\n        activeRoomIds.push(newRoomId);\r\n        emit Debug(\"New room created with ID\", newRoomId);\r\n        emit RoomCreated(newRoomId, entryFee, maxPlayers);\r\n        return newRoomId;\r\n    }\r\n\r\n    /**\r\n     * @dev Determines the appropriate room entry fee based on the provided value.\r\n     *\r\n     * @param value The value in Ether to be checked against predefined entry fee thresholds.\r\n     * \r\n     * @return uint256 The entry fee that matches the provided value based on predefined thresholds.\r\n     * \r\n     * @notice This function does not perform any external calls or state modifications, thus it is marked as pure.\r\n     */\r\n    function getRoomTypeBasedOnValue(uint256 value) internal pure returns (uint256) {\r\n        if (value >= 10 ether) {\r\n            return 10 ether;\r\n        } else if (value >= 1 ether) {\r\n            return 1 ether;\r\n        } else if (value >= 0.1 ether) {\r\n            return 0.1 ether;\r\n        } else if (value >= 0.03 ether) {\r\n            return 0.03 ether;\r\n        } else {\r\n            return 0.01 ether;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Refunds the specified amount of Ether to the provided player address.\r\n     *\r\n     * @param playerAddress The address of the player to be refunded.\r\n     * @param amount The amount of Ether in Wei to refund.\r\n     * \r\n     * @notice This function performs a state-changing operation by transferring funds.\r\n     * \r\n     * Emits a {PlayerRefunded} event.\r\n     */\r\n    function refundPlayer(address playerAddress, uint256 amount) internal {\r\n        payable(playerAddress).transfer(amount);\r\n        emit PlayerRefunded(playerAddress, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Pays out the specified amount of Ether to the provided winner address.\r\n     *\r\n     * @param winner The address of the player who won.\r\n     * @param amount The amount of Ether in Wei to be paid out.\r\n     *\r\n     * @notice This function performs a state-changing operation by transferring funds.\r\n     *\r\n     * Emits a {WinnerPaid} event.\r\n     */\r\n    function payout(address winner, uint256 amount) internal {\r\n        payable(winner).transfer(amount);\r\n        emit WinnerPaid(winner, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves the number of blocks remaining before the timer for a given room expires.\r\n     *\r\n     * @param roomId The ID of the room for which to retrieve the missing blocks.\r\n     *\r\n     * The room must be active.\r\n     *\r\n     * @notice This function is a view function and does not modify state.\r\n     *\r\n     * Emits a {MissingBlocks} event.\r\n     */\r\n    function getMissingBlocks(uint256 roomId) external  {\r\n        Room storage room = rooms[roomId];\r\n        require(room.isActive, \"Room is not active\");\r\n        uint256 missingBlocks = (room.startTimeBlock + BLOCKS_FOR_4_HOURS) - block.number;\r\n        emit MissingBlocks(roomId, missingBlocks);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Debug\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"missingBlocks\",\"type\":\"uint256\"}],\"name\":\"MissingBlocks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"PlayerJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PlayerRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"maxPlayers\",\"type\":\"uint8\"}],\"name\":\"RoomCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"}],\"name\":\"RoomDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"}],\"name\":\"TimerEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"TimerStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WinnerPaid\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BLOCKS_FOR_4_HOURS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PLAYERS_1v1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PLAYERS_1v10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activeRoomIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enterRoom1v1\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enterRoom1v10\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"}],\"name\":\"getMissingBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"roomTypeToEntryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OneOnTen", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7b27e2c69d311c4bc8baa106609ca1a148e5eeeeb9e0aad4f98e6a27a17173d4"}