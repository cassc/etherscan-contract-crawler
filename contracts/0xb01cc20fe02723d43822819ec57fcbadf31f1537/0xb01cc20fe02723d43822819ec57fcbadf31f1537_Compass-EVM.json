{"SourceCode": "#pragma version 0.3.10\r\n#pragma optimize gas\r\n#pragma evm-version paris\r\n\"\"\"\r\n@title Compass-EVM\r\n@author Volume.Finance\r\n\"\"\"\r\n\r\nMAX_VALIDATORS: constant(uint256) = 200\r\nMAX_PAYLOAD: constant(uint256) = 10240\r\nMAX_BATCH: constant(uint256) = 64\r\n\r\nPOWER_THRESHOLD: constant(uint256) = 2_863_311_530 # 2/3 of 2^32, Validator powers will be normalized to sum to 2 ^ 32 in every valset update.\r\ncompass_id: public(immutable(bytes32))\r\n\r\ninterface ERC20:\r\n    def balanceOf(_owner: address) -> uint256: view\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n    def transferFrom(_from: address, _to: address, _value: uint256) -> bool: nonpayable\r\n\r\nstruct Valset:\r\n    validators: DynArray[address, MAX_VALIDATORS] # Validator addresses\r\n    powers: DynArray[uint256, MAX_VALIDATORS] # Powers of given validators, in the same order as validators array\r\n    valset_id: uint256 # nonce of this validator set\r\n\r\nstruct Signature:\r\n    v: uint256\r\n    r: uint256\r\n    s: uint256\r\n\r\nstruct Consensus:\r\n    valset: Valset # Valset data\r\n    signatures: DynArray[Signature, MAX_VALIDATORS] # signatures in the same order as validator array in valset\r\n\r\nstruct LogicCallArgs:\r\n    logic_contract_address: address # the arbitrary contract address to external call\r\n    payload: Bytes[MAX_PAYLOAD] # payloads\r\n\r\nstruct TokenSendArgs:\r\n    receiver: DynArray[address, MAX_BATCH]\r\n    amount: DynArray[uint256, MAX_BATCH]\r\n\r\nevent ValsetUpdated:\r\n    checkpoint: bytes32\r\n    valset_id: uint256\r\n    event_id: uint256\r\n\r\nevent LogicCallEvent:\r\n    logic_contract_address: address\r\n    payload: Bytes[MAX_PAYLOAD]\r\n    message_id: uint256\r\n    event_id: uint256\r\n\r\nevent SendToPalomaEvent:\r\n    token: address\r\n    sender: address\r\n    receiver: String[64]\r\n    amount: uint256\r\n    event_id: uint256\r\n\r\nevent BatchSendEvent:\r\n    token: address\r\n    batch_id: uint256\r\n    event_id: uint256\r\n\r\nevent ERC20DeployedEvent:\r\n    paloma_denom: String[64]\r\n    token_contract: address\r\n    name: String[64]\r\n    symbol: String[32]\r\n    decimals: uint8\r\n    event_id: uint256\r\n\r\nlast_checkpoint: public(bytes32)\r\nlast_valset_id: public(uint256)\r\nlast_event_id: public(uint256)\r\nlast_batch_id: public(HashMap[address, uint256])\r\nmessage_id_used: public(HashMap[uint256, bool])\r\n\r\n# compass_id: unique identifier for compass instance\r\n# valset: initial validator set\r\n@external\r\ndef __init__(_compass_id: bytes32, _event_id: uint256, valset: Valset):\r\n    compass_id = _compass_id\r\n    cumulative_power: uint256 = 0\r\n    i: uint256 = 0\r\n    # check cumulative power is enough\r\n    for validator in valset.validators:\r\n        cumulative_power += valset.powers[i]\r\n        if cumulative_power >= POWER_THRESHOLD:\r\n            break\r\n        i = unsafe_add(i, 1)\r\n    assert cumulative_power >= POWER_THRESHOLD, \"Insufficient Power\"\r\n    new_checkpoint: bytes32 = keccak256(_abi_encode(valset.validators, valset.powers, valset.valset_id, compass_id, method_id=method_id(\"checkpoint(address[],uint256[],uint256,bytes32)\")))\r\n    self.last_checkpoint = new_checkpoint\r\n    self.last_valset_id = valset.valset_id\r\n    self.last_event_id = _event_id\r\n    log ValsetUpdated(new_checkpoint, valset.valset_id, _event_id)\r\n\r\n# utility function to verify EIP712 signature\r\n@internal\r\n@pure\r\ndef verify_signature(signer: address, hash: bytes32, sig: Signature) -> bool:\r\n    message_digest: bytes32 = keccak256(concat(convert(\"\\x19Ethereum Signed Message:\\n32\", Bytes[28]), hash))\r\n    return signer == ecrecover(message_digest, sig.v, sig.r, sig.s)\r\n\r\n# consensus: validator set and signatures\r\n# hash: what we are checking they have signed\r\n@internal\r\ndef check_validator_signatures(consensus: Consensus, hash: bytes32):\r\n    i: uint256 = 0\r\n    cumulative_power: uint256 = 0\r\n    for sig in consensus.signatures:\r\n        if sig.v != 0:\r\n            assert self.verify_signature(consensus.valset.validators[i], hash, sig), \"Invalid Signature\"\r\n            cumulative_power += consensus.valset.powers[i]\r\n            if cumulative_power >= POWER_THRESHOLD:\r\n                break\r\n        i = unsafe_add(i, 1)\r\n    assert cumulative_power >= POWER_THRESHOLD, \"Insufficient Power\"\r\n\r\n# Make a new checkpoint from the supplied validator set\r\n# A checkpoint is a hash of all relevant information about the valset. This is stored by the contract,\r\n# instead of storing the information directly. This saves on storage and gas.\r\n# The format of the checkpoint is:\r\n# keccak256 hash of abi_encoded checkpoint(validators[], powers[], valset_id, compass_id)\r\n# The validator powers must be decreasing or equal. This is important for checking the signatures on the\r\n# next valset, since it allows the caller to stop verifying signatures once a quorum of signatures have been verified.\r\n@internal\r\n@view\r\ndef make_checkpoint(valset: Valset) -> bytes32:\r\n    return keccak256(_abi_encode(valset.validators, valset.powers, valset.valset_id, compass_id, method_id=method_id(\"checkpoint(address[],uint256[],uint256,bytes32)\")))\r\n\r\n# This updates the valset by checking that the validators in the current valset have signed off on the\r\n# new valset. The signatures supplied are the signatures of the current valset over the checkpoint hash\r\n# generated from the new valset.\r\n# Anyone can call this function, but they must supply valid signatures of constant_powerThreshold of the current valset over\r\n# the new valset.\r\n# valset: new validator set to update with\r\n# consensus: current validator set and signatures\r\n@external\r\ndef update_valset(consensus: Consensus, new_valset: Valset):\r\n    # check if new valset_id is greater than current valset_id\r\n    assert new_valset.valset_id > consensus.valset.valset_id, \"Invalid Valset ID\"\r\n    cumulative_power: uint256 = 0\r\n    i: uint256 = 0\r\n    # check cumulative power is enough\r\n    for validator in new_valset.validators:\r\n        cumulative_power += new_valset.powers[i]\r\n        if cumulative_power >= POWER_THRESHOLD:\r\n            break\r\n        i = unsafe_add(i, 1)\r\n    assert cumulative_power >= POWER_THRESHOLD, \"Insufficient Power\"\r\n    # check if the supplied current validator set matches the saved checkpoint\r\n    assert self.last_checkpoint == self.make_checkpoint(consensus.valset), \"Incorrect Checkpoint\"\r\n    # calculate the new checkpoint\r\n    new_checkpoint: bytes32 = self.make_checkpoint(new_valset)\r\n    # check if enough validators signed new validator set (new checkpoint)\r\n    self.check_validator_signatures(consensus, new_checkpoint)\r\n    self.last_checkpoint = new_checkpoint\r\n    self.last_valset_id = new_valset.valset_id\r\n    event_id: uint256 = unsafe_add(self.last_event_id, 1)\r\n    self.last_event_id = event_id\r\n    log ValsetUpdated(new_checkpoint, new_valset.valset_id, event_id)\r\n\r\n# This makes calls to contracts that execute arbitrary logic\r\n# message_id is to prevent replay attack and every message_id can be used only once\r\n@external\r\ndef submit_logic_call(consensus: Consensus, args: LogicCallArgs, message_id: uint256, deadline: uint256):\r\n    assert block.timestamp <= deadline, \"Timeout\"\r\n    assert not self.message_id_used[message_id], \"Used Message_ID\"\r\n    self.message_id_used[message_id] = True\r\n    # check if the supplied current validator set matches the saved checkpoint\r\n    assert self.last_checkpoint == self.make_checkpoint(consensus.valset), \"Incorrect Checkpoint\"\r\n    # signing data is keccak256 hash of abi_encoded logic_call(args, message_id, compass_id, deadline)\r\n    args_hash: bytes32 = keccak256(_abi_encode(args, message_id, compass_id, deadline, method_id=method_id(\"logic_call((address,bytes),uint256,bytes32,uint256)\")))\r\n    # check if enough validators signed args_hash\r\n    self.check_validator_signatures(consensus, args_hash)\r\n    # make call to logic contract\r\n    raw_call(args.logic_contract_address, args.payload)\r\n    event_id: uint256 = unsafe_add(self.last_event_id, 1)\r\n    self.last_event_id = event_id\r\n    log LogicCallEvent(args.logic_contract_address, args.payload, message_id, event_id)\r\n\r\n@external\r\ndef send_token_to_paloma(token: address, receiver: String[64], amount: uint256):\r\n    _balance: uint256 = ERC20(token).balanceOf(self)\r\n    assert ERC20(token).transferFrom(msg.sender, self, amount, default_return_value=True), \"TF fail\"\r\n    _balance = ERC20(token).balanceOf(self) - _balance\r\n    assert _balance > 0, \"Zero Transfer\"\r\n    event_id: uint256 = unsafe_add(self.last_event_id, 1)\r\n    self.last_event_id = event_id\r\n    log SendToPalomaEvent(token, msg.sender, receiver, amount, event_id)\r\n\r\n@external\r\ndef submit_batch(consensus: Consensus, token: address, args: TokenSendArgs, batch_id: uint256, deadline: uint256):\r\n    assert block.timestamp <= deadline, \"Timeout\"\r\n    assert self.last_batch_id[token] < batch_id, \"Wrong batch id\"\r\n    length: uint256 = len(args.receiver)\r\n    assert length == len(args.amount), \"Unmatched Params\"\r\n    # check if the supplied current validator set matches the saved checkpoint\r\n    assert self.last_checkpoint == self.make_checkpoint(consensus.valset), \"Incorrect Checkpoint\"\r\n    # signing data is keccak256 hash of abi_encoded batch_call(args, batch_id, compass_id, deadline)\r\n    args_hash: bytes32 = keccak256(_abi_encode(token, args, batch_id, compass_id, deadline, method_id=method_id(\"batch_call(address,(address[],uint256[]),uint256,bytes32,uint256)\")))\r\n    # check if enough validators signed args_hash\r\n    self.check_validator_signatures(consensus, args_hash)\r\n    # make call to logic contract\r\n    for i in range(MAX_BATCH):\r\n        if  i >= length:\r\n            break\r\n        assert ERC20(token).transfer(args.receiver[i], args.amount[i], default_return_value=True), \"Tr fail\"\r\n    event_id: uint256 = unsafe_add(self.last_event_id, 1)\r\n    self.last_event_id = event_id\r\n    self.last_batch_id[token] = batch_id\r\n    log BatchSendEvent(token, batch_id, event_id)\r\n\r\n@external\r\ndef deploy_erc20(_paloma_denom: String[64], _name: String[64], _symbol: String[32], _decimals: uint8, _blueprint: address):\r\n    assert msg.sender == self, \"Invalid\"\r\n    erc20: address = create_from_blueprint(_blueprint, self, _name, _symbol, _decimals, code_offset=3)\r\n    event_id: uint256 = unsafe_add(self.last_event_id, 1)\r\n    self.last_event_id = event_id\r\n    log ERC20DeployedEvent(_paloma_denom, erc20, _name, _symbol, _decimals, event_id)", "ABI": "[{\"name\":\"ValsetUpdated\",\"inputs\":[{\"name\":\"checkpoint\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"valset_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"event_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LogicCallEvent\",\"inputs\":[{\"name\":\"logic_contract_address\",\"type\":\"address\",\"indexed\":false},{\"name\":\"payload\",\"type\":\"bytes\",\"indexed\":false},{\"name\":\"message_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"event_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SendToPalomaEvent\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"sender\",\"type\":\"address\",\"indexed\":false},{\"name\":\"receiver\",\"type\":\"string\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"event_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BatchSendEvent\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"batch_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"event_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ERC20DeployedEvent\",\"inputs\":[{\"name\":\"paloma_denom\",\"type\":\"string\",\"indexed\":false},{\"name\":\"token_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"name\",\"type\":\"string\",\"indexed\":false},{\"name\":\"symbol\",\"type\":\"string\",\"indexed\":false},{\"name\":\"decimals\",\"type\":\"uint8\",\"indexed\":false},{\"name\":\"event_id\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_compass_id\",\"type\":\"bytes32\"},{\"name\":\"_event_id\",\"type\":\"uint256\"},{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_valset\",\"inputs\":[{\"name\":\"consensus\",\"type\":\"tuple\",\"components\":[{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]},{\"name\":\"signatures\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"new_valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"submit_logic_call\",\"inputs\":[{\"name\":\"consensus\",\"type\":\"tuple\",\"components\":[{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]},{\"name\":\"signatures\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"args\",\"type\":\"tuple\",\"components\":[{\"name\":\"logic_contract_address\",\"type\":\"address\"},{\"name\":\"payload\",\"type\":\"bytes\"}]},{\"name\":\"message_id\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"send_token_to_paloma\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"string\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"submit_batch\",\"inputs\":[{\"name\":\"consensus\",\"type\":\"tuple\",\"components\":[{\"name\":\"valset\",\"type\":\"tuple\",\"components\":[{\"name\":\"validators\",\"type\":\"address[]\"},{\"name\":\"powers\",\"type\":\"uint256[]\"},{\"name\":\"valset_id\",\"type\":\"uint256\"}]},{\"name\":\"signatures\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"v\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"s\",\"type\":\"uint256\"}]}]},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"args\",\"type\":\"tuple\",\"components\":[{\"name\":\"receiver\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"}]},{\"name\":\"batch_id\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_erc20\",\"inputs\":[{\"name\":\"_paloma_denom\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_blueprint\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"compass_id\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_checkpoint\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_valset_id\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_event_id\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_batch_id\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"message_id_used\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]}]", "ContractName": "Compass-EVM", "CompilerVersion": "vyper:0.3.10", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "38383732333038000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000959e000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000a228292447064d5818bbc80b577c91f5212f9355000000000000000000000000092604a080524eff1c875ff13a1b88cbdd41df37000000000000000000000000ee21301af1d9562b5cbedf520077ea0a9bc9d53500000000000000000000000019f5911e4ca69e30449ad6bb71de341f01f118bb00000000000000000000000043e218f96a567dc26c6e65fcabf1fde26af694440000000000000000000000006dc59ee4bdfa2c791229004f29b08f783491a9340000000000000000000000001dd71ee9e7b1cff10ccb7e12520999c2d4fb45e50000000000000000000000001ad90db98da083e117d5f62a1673fc0f3a5930ca000000000000000000000000ade5f5efeae72102d998f6c496ea59731a70eeb0000000000000000000000000443266026738061972012e62d5ecd9d98da8b6f40000000000000000000000001f6ef2784cbb2a5011d8cf12356fb5ee3eaef37200000000000000000000000063f55bc560e981d53e1f5bb3643e3a96d26fc635000000000000000000000000732fbb6018f2cb5b844055c9eb567447a31328330000000000000000000000005a7c9fc846b18944fd2b8f8ae7255db5af7b9c04000000000000000000000000deea5b069208e0ee37b630a3e7672fc50e8fe24a000000000000000000000000ee83770168d4ee756e74562c17bded88091519d00000000000000000000000003ab643728bd503ae41561b4bfe1d309a17255b8d000000000000000000000000279fc7c0ebef3328d3899fe73464347a764c5f2c000000000000000000000000aac74d38c82c367b3da7482e3aecf6dd7a512ef20000000000000000000000000daabb4ff60423eb1f14cc6731394e098ad51bcb00000000000000000000000014aa448c2c918c4427c5671028b63bc17f6132d50000000000000000000000004a89f96fdff3c161937cfbc3e22d2e325612aaec000000000000000000000000cfbbf6341cf13a39ffcaf24b86de09489116783b0000000000000000000000007b5f4b6490ebc2dd03b717d7d26edc78451a88b4000000000000000000000000377d23948d41579f2c3ca40308e3bdd53f6da7b2000000000000000000000000eb784b37365c302c97c9ec8cb0933ce344e6de420000000000000000000000003a188de3d16ddee783990dded1b629e95c8242d9000000000000000000000000bbefe691d2c3bbb835ce2958b453ccd05bdb27a5000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000166b2d26000000000000000000000000000000000000000000000000000000000eafb1d3000000000000000000000000000000000000000000000000000000000e888c60000000000000000000000000000000000000000000000000000000000c315279000000000000000000000000000000000000000000000000000000000c07829c000000000000000000000000000000000000000000000000000000000abf6c64000000000000000000000000000000000000000000000000000000000abf49cf000000000000000000000000000000000000000000000000000000000a99c564000000000000000000000000000000000000000000000000000000000a87e731000000000000000000000000000000000000000000000000000000000a7e0f0b000000000000000000000000000000000000000000000000000000000a73a805000000000000000000000000000000000000000000000000000000000a407b720000000000000000000000000000000000000000000000000000000009fdd59b0000000000000000000000000000000000000000000000000000000009f724810000000000000000000000000000000000000000000000000000000009893802000000000000000000000000000000000000000000000000000000000980b6af00000000000000000000000000000000000000000000000000000000085b2a16000000000000000000000000000000000000000000000000000000000852ee5d000000000000000000000000000000000000000000000000000000000809f5620000000000000000000000000000000000000000000000000000000007ba04bd0000000000000000000000000000000000000000000000000000000007ad20b70000000000000000000000000000000000000000000000000000000007758ec900000000000000000000000000000000000000000000000000000000074ef2330000000000000000000000000000000000000000000000000000000004c79f43000000000000000000000000000000000000000000000000000000000445eea900000000000000000000000000000000000000000000000000000000033cd35c000000000000000000000000000000000000000000000000000000000014dfd900000000000000000000000000000000000000000000000000000000000f4c05", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": ""}