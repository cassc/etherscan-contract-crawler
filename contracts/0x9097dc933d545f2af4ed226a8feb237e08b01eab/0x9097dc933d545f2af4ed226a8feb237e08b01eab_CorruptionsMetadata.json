{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CorruptionsMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Base64.sol\\\";\\n\\ninterface ICorruptionsMetadata {\\n    function tokenURI(uint256 tokenId, uint256 amount) external view returns (string memory);\\n}\\n\\ninterface ICorruptionsDataMapper {\\n    function valueFor(uint256 mapIndex, uint256 key) external view returns (uint256);\\n}\\n\\ninterface ICorruptionsDeviationWriter {\\n    function drawCanvas(uint256 tokenId, uint256 amount) external pure returns (string[32] memory);\\n}\\n\\ninterface ICorruptionsFont {\\n    function font() external view returns (string memory);\\n}\\n\\ninterface ICorruptionsResource {\\n    function resource() external view returns (string memory);\\n}\\n\\ninterface ICorruptionsAscension {\\n    function base() external view returns (string memory);\\n}\\n\\nstruct DeviationInfo {\\n    string name;\\n    address contractAddress;\\n    uint256 extraData;\\n}\\n\\ninterface ICorruptionsDeviationRegistry {\\n    function valueFor(uint256 index) external view returns (DeviationInfo memory);\\n}\\n\\nstruct InsightMap {\\n    uint256 savedXP;\\n    uint256 lastSaveBlock;\\n}\\n\\ninterface ICorruptions {\\n    function insightMap(uint256 tokenID) external view returns (InsightMap memory);\\n    function insight(uint256 tokenID) external view returns (uint256);\\n    function ownerOf(uint256 tokenID) external view returns (address);\\n}\\n\\ncontract CorruptionsMetadata is Ownable, ICorruptionsMetadata {\\n    string public description;\\n    string public betaRendererUri;\\n    \\n    ICorruptionsDataMapper private dataMapper;\\n    ICorruptionsFont private font;\\n    ICorruptionsAscension private menes;\\n    ICorruptions private corruptions;\\n    ICorruptionsResource private characterResource;\\n\\n    struct RandParts {\\n        string border;\\n        string corruptor;\\n        string phrase;\\n        string checker;\\n        bool omitInsight;\\n        uint16 reduction;\\n        bool alternate;\\n        uint256 r1;\\n        uint256 r2;\\n        uint256 r3;\\n        uint256 r4;\\n        string[32] colorCanvas;\\n    }\\n\\n    constructor() Ownable() {\\n        description = \\\"Unknown\\\";\\n        dataMapper = ICorruptionsDataMapper(0x7A96d95a787524a27a4df36b64a96910a2fDCF5B);\\n        font = ICorruptionsFont(0xdf8A48979F33f12952Ab4cF6f960EA4071fc656b);\\n        menes = ICorruptionsAscension(0xD5192Ba5Bd9415b5e0d09633657129086a5F36c4);\\n        corruptions = ICorruptions(0x5BDf397bB2912859Dbd8011F320a222f79A28d2E);\\n        characterResource = ICorruptionsResource(0x112231e2b829BeC90ae75EA9D98D116c3Ae8a69a);\\n    }\\n\\n    function setDescription(string memory desc) public onlyOwner {\\n        description = desc;\\n    }\\n\\n    function setFont(address fontAddress) public onlyOwner {\\n        font = ICorruptionsFont(fontAddress);\\n    }\\n\\n    function setCharacterResource(address resourceAddress) public onlyOwner {\\n        characterResource = ICorruptionsResource(resourceAddress);\\n    }\\n\\n    function setBetaRendererUri(string memory uri) public onlyOwner {\\n        betaRendererUri = uri;\\n    }\\n\\n    function _blank(string[32] memory canvas, bool whitespace) public pure returns (string[32] memory) {\\n        if (whitespace) {\\n            for (uint8 i = 0; i < 32; i++) {\\n                canvas[i] = \\\"&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;&#x000A0;\\\";\\n            }\\n            return canvas;\\n        }\\n        for (uint8 i = 0; i < 32; i++) {\\n            canvas[i] = \\\"&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;&#x0002e;\\\";\\n        }\\n        return canvas;\\n    }\\n\\n    function _insert(bytes memory canvasLine, uint256 offset, bytes memory str, bool singleChar) pure private {\\n        canvasLine[offset * 9 + 0] = str[0];\\n\\n        if (singleChar) {\\n            canvasLine[offset * 9 + 1] = \\\"<\\\";\\n            canvasLine[offset * 9 + 2] = \\\"!\\\";\\n            canvasLine[offset * 9 + 3] = \\\"-\\\";\\n            canvasLine[offset * 9 + 4] = \\\"-\\\";\\n            canvasLine[offset * 9 + 5] = \\\" \\\";\\n            canvasLine[offset * 9 + 6] = \\\"-\\\";\\n            canvasLine[offset * 9 + 7] = \\\"-\\\";\\n            canvasLine[offset * 9 + 8] = \\\">\\\";\\n        } else {\\n            canvasLine[offset * 9 + 1] = str[1];\\n            canvasLine[offset * 9 + 2] = str[2];\\n            canvasLine[offset * 9 + 3] = str[3];\\n            canvasLine[offset * 9 + 4] = str[4];\\n            canvasLine[offset * 9 + 5] = str[5];\\n            canvasLine[offset * 9 + 6] = str[6];\\n            canvasLine[offset * 9 + 7] = str[7];\\n            canvasLine[offset * 9 + 8] = str[8];\\n        }\\n    }\\n\\n    function _box(string[32] memory canvas, string memory char, uint256 x, uint256 y, uint256 w, uint256 h, bool singleChar) public pure returns (string[32] memory) {\\n        bytes memory str = bytes(char);\\n        for (uint256 iy = 0; iy < h; iy++) {\\n            bytes memory canvasLine = bytes(canvas[iy + y]);\\n            for (uint256 ix = 0; ix < w; ix++) {\\n                _insert(canvasLine, ix + x, str, singleChar);\\n            }\\n        }\\n        return canvas;\\n    }\\n\\n    function _checkeredBox(string[32] memory canvas, string memory char, string memory char2, uint256 x, uint256 y, uint256 w, uint256 h, bool singleChar) public pure returns (string[32] memory) {\\n        bytes memory str = bytes(char);\\n        bytes memory str2 = bytes(char2);\\n        for (uint256 iy = 0; iy < h; iy++) {\\n            bytes memory canvasLine = bytes(canvas[iy + y]);\\n            for (uint256 ix = 0; ix < w; ix++) {\\n                _insert(canvasLine, ix + x, ((iy + y) + (ix + x)) % 2 == 0 ? str : str2, singleChar);\\n            }\\n        }\\n        return canvas;\\n    }\\n\\n    function _drawCircle(string[32] memory canvas, string memory char, uint256 xc, uint256 yc, uint256 x, uint256 y, bool singleChar) public pure returns (string[32] memory) { \\n        bytes memory str = bytes(char);\\n\\n        _insert(bytes(canvas[yc + y]), xc + x, str, singleChar);\\n        _insert(bytes(canvas[yc + y]), xc - x, str, singleChar);\\n        _insert(bytes(canvas[yc - y]), xc + x, str, singleChar);\\n        _insert(bytes(canvas[yc - y]), xc - x, str, singleChar);\\n        _insert(bytes(canvas[yc + x]), xc + y, str, singleChar);\\n        _insert(bytes(canvas[yc + x]), xc - y, str, singleChar);\\n        _insert(bytes(canvas[yc - x]), xc + y, str, singleChar);\\n        _insert(bytes(canvas[yc - x]), xc - y, str, singleChar);\\n\\n        return canvas;\\n    }\\n\\n    function _circle(string[32] memory canvas, string memory char, uint256 xc, uint256 yc, int8 r, bool singleChar) public pure returns (string[32] memory) {\\n        // https://www.geeksforgeeks.org/bresenhams-circle-drawing-algorithm/\\n\\n        int256 x = 0;\\n        int256 y = int256(r);\\n        int256 d = 3 - 2 * r;\\n        canvas = _drawCircle(canvas, char, xc, yc, uint256(x), uint256(y), singleChar);\\n        while (y >= x) {\\n            x++;\\n\\n            if (d > 0) {\\n                y--;\\n                d = d + 4 * (x - y) + 10;\\n            } else {\\n                d = d + 4 * x + 6;\\n            }\\n            canvas = _drawCircle(canvas, char, xc, yc, uint256(x), uint256(y), singleChar);\\n        }\\n\\n        return canvas;\\n    }\\n\\n    function _middleBox(string[32] memory canvas, string memory char, string memory char2, uint256 size, bool singleChar) public pure returns (string[32] memory) {\\n        canvas = _checkeredBox(canvas, char, char2, 15 - size, 15 - size, size * 2 + 1, size * 2 + 1, singleChar);\\n        return canvas;\\n    }\\n\\n    function _text(string[32] memory canvas, string memory message, uint256 messageLength, uint256 x, uint256 y) public pure returns (string[32] memory) {\\n        bytes memory canvasLine = bytes(canvas[y]);\\n        for (uint256 i = 0; i < messageLength; i++) {\\n            _insert(canvasLine, x + i, abi.encodePacked(bytes(message)[i]), true);\\n        }\\n\\n        return canvas;\\n    }\\n\\n    function _richText(string[32] memory canvas, string memory message, uint256 messageLength, uint256 x, uint256 y) public pure returns (string[32] memory) {\\n        bytes memory canvasLine = bytes(canvas[y]);\\n        for (uint256 i = 0; i < messageLength / 9; i++) {\\n            bytes memory sequence = abi.encodePacked(abi.encodePacked(\\n                bytes(message)[i * 9], bytes(message)[i * 9 + 1], bytes(message)[i * 9 + 2], bytes(message)[i * 9 + 3],\\n                bytes(message)[i * 9 + 4], bytes(message)[i * 9 + 5]), bytes(message)[i * 9 + 6], bytes(message)[i * 9 + 7],\\n                bytes(message)[i * 9 + 8]\\n            );\\n            _insert(canvasLine, x + i, sequence, false);\\n        }\\n\\n        return canvas;\\n    }\\n\\n    function draw(uint256 tokenId, uint256 amount, string[32] memory oCanvas) public view returns (string memory) {\\n        string[31] memory lookup = [\\n            \\\"20\\\",\\n            \\\"31\\\",\\n            \\\"42\\\",\\n            \\\"53\\\",\\n            \\\"64\\\",\\n            \\\"75\\\",\\n            \\\"86\\\",\\n            \\\"97\\\",\\n            \\\"108\\\",\\n            \\\"119\\\",\\n            \\\"130\\\",\\n            \\\"141\\\",\\n            \\\"152\\\",\\n            \\\"163\\\",\\n            \\\"174\\\",\\n            \\\"185\\\",\\n            \\\"196\\\",\\n            \\\"207\\\",\\n            \\\"218\\\",\\n            \\\"229\\\",\\n            \\\"240\\\",\\n            \\\"251\\\",\\n            \\\"262\\\",\\n            \\\"273\\\",\\n            \\\"284\\\",\\n            \\\"295\\\",\\n            \\\"306\\\",\\n            \\\"317\\\",\\n            \\\"328\\\",\\n            \\\"339\\\",\\n            \\\"350\\\"\\n        ];\\n\\n        string[40] memory randomStrings = [\\n            \\\"/\\\",\\n            \\\"$\\\",\\n            \\\"|\\\",\\n            \\\"8\\\",\\n            \\\"_\\\",\\n            \\\"?\\\",\\n            \\\"#\\\",\\n            \\\"%\\\",\\n            \\\"^\\\",\\n            \\\"~\\\",\\n            \\\":\\\",\\n\\n            \\\"#022FB7\\\",\\n            \\\"#262A36\\\",\\n            \\\"#A802B7\\\",\\n            \\\"#3CB702\\\",\\n            \\\"#B76F02\\\",\\n            \\\"#B70284\\\",\\n\\n            \\\"#0D1302\\\",\\n            \\\"#020A13\\\",\\n            \\\"#130202\\\",\\n            \\\"#1A1616\\\",\\n            \\\"#000000\\\",\\n            \\\"#040A27\\\",\\n            \\n            \\\"GENERATION\\\",\\n            \\\"INDIVIDUAL\\\",\\n            \\\"TECHNOLOGY\\\",\\n            \\\"EVERYTHING\\\",\\n            \\\"EVERYWHERE\\\",\\n            \\\"UNDERWORLD\\\",\\n            \\\"ILLUMINATI\\\",\\n            \\\"TEMPTATION\\\",\\n            \\\"REVELATION\\\",\\n            \\\"CORRUPTION\\\",\\n\\n            \\\"|\\\",\\n            \\\"-\\\",\\n            \\\"=\\\",\\n            \\\"+\\\",\\n            \\\"\\\\\\\\\\\",\\n            \\\":\\\",\\n            \\\"~\\\"\\n        ];\\n\\n        RandParts memory randParts;\\n\\n        randParts.border = randomStrings[uint256(keccak256(abi.encodePacked(\\\"BORDER\\\", tokenId))) % 11];\\n        randParts.corruptor = randomStrings[uint256(keccak256(abi.encodePacked(\\\"CORRUPTOR\\\", tokenId))) % 11];\\n        randParts.phrase = randomStrings[23 + uint256(keccak256(abi.encodePacked(\\\"PHRASE\\\", tokenId))) % 10];\\n        randParts.checker = randomStrings[33 + uint256(keccak256(abi.encodePacked(\\\"CHECKER\\\", tokenId))) % 7];\\n\\n        string[32] memory canvas;\\n\\n\\n        if (bytes(oCanvas[0]).length > 32) {\\n            canvas = _blank(canvas, false);\\n\\n            randParts.omitInsight = true;\\n            randParts.reduction = 64 + uint8(bytes(oCanvas[0])[tokenId % 32]);\\n            randParts.alternate = true;\\n\\n            for (uint256 i = 0; i < 32; i++) {\\n                canvas = _richText(canvas, oCanvas[i], bytes(oCanvas[i]).length, 0, i);\\n            }\\n\\n        } else if (bytes(oCanvas[0]).length > 0) {\\n            canvas = _blank(canvas, false);\\n\\n            randParts.omitInsight = true;\\n            randParts.reduction = 64;\\n\\n            for (uint256 i = 0; i < 32; i++) {\\n                canvas = _text(canvas, oCanvas[i], bytes(oCanvas[i]).length, 0, i);\\n            }\\n\\n        } else {\\n            canvas = _blank(canvas, false);\\n\\n            canvas = _box(canvas, randParts.border, 0, 0, 31, 1, true);\\n            canvas = _box(canvas, randParts.border, 0, 30, 31, 1, true);\\n            canvas = _box(canvas, randParts.border, 0, 0, 1, 31, true);\\n            canvas = _box(canvas, randParts.border, 30, 0, 1, 31, true); \\n\\n            canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[0])), 15, 15, 12, true);\\n            canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[1])), 15, 15, 11, true);\\n\\n            if (amount < 20) {\\n                canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[2])), 15, 15, 10, true);\\n                canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[3])), 15, 15, 9, true);\\n                canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[4])), 15, 15, 8, true);\\n                canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[5])), 15, 15, 7, true);\\n                canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[6])), 15, 15, 6, true);\\n                canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[7])), 15, 15, 5, true);\\n                canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[8])), 15, 15, 4, true);\\n                canvas = _circle(canvas, string(abi.encodePacked(bytes(randParts.phrase)[9])), 15, 15, 3, true);\\n            }\\n        }\\n\\n        uint256 iterations = uint256(keccak256(abi.encodePacked(\\\"CORRUPTION\\\", tokenId))) % 1024;\\n        if (randParts.reduction > 0) {\\n            iterations = iterations % randParts.reduction;\\n        }\\n        for (uint256 i = 0; i < iterations; i++) {\\n            if (randParts.alternate && i % 2 == 0) {\\n                canvas = _box(canvas, randParts.border, uint256(keccak256(abi.encodePacked(\\\"X\\\", i, tokenId))) % 30, uint256(keccak256(abi.encodePacked(\\\"Y\\\", i, tokenId))) % 30, 1, 1, true);\\n            } else {\\n                canvas = _box(canvas, randParts.corruptor, uint256(keccak256(abi.encodePacked(\\\"X\\\", i, tokenId))) % 30, uint256(keccak256(abi.encodePacked(\\\"Y\\\", i, tokenId))) % 30, 1, 1, true);\\n            }\\n        }\\n\\n        if (!randParts.omitInsight) {\\n            uint256 length = 8 + bytes(toString(amount)).length;\\n            canvas = _text(canvas, string(abi.encodePacked(\\\"INSIGHT \\\", toString(amount))), length, 31 - length, 30);\\n\\n\\n            for (uint i = 10; i > 0; i--) { \\n                if (amount >= i * 2) {\\n                    canvas = _middleBox(canvas, string(abi.encodePacked(bytes(randParts.phrase)[i - 1])), randParts.checker, i, true);\\n                }\\n            }\\n        }\\n\\n        string memory output = \\\"\\\";\\n        randParts.r4 = amount >= 20 && bytes(oCanvas[0]).length == 0 ? 1 : 0;\\n\\n        string[12] memory parts;\\n        parts[0] = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 820 1460\\\"><style>@font-face { font-family: CorruptionsFont; src: url(\\\"';\\n        if (randParts.r4 > 0) {\\n            parts[0] = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 1640 1460\\\"><style>@font-face { font-family: CorruptionsFont; src: url(\\\"';\\n        }\\n        parts[1] = font.font();\\n        parts[2] = '\\\") format(\\\"opentype\\\"); } .base { fill: ';\\n        parts[3] = randomStrings[11 + uint256(keccak256(abi.encodePacked(\\\"BGCOLOR\\\", tokenId))) % 6];\\n        parts[4] = '; font-family: CorruptionsFont; font-size: 10px; }</style><g transform=\\\\\\\"scale(4 4)\\\\\\\"><rect width=\\\"205\\\" height=\\\"365\\\" fill=\\\"';\\n        if (randParts.r4 > 0) {\\n            parts[4] = '; font-family: CorruptionsFont; font-size: 10px; }</style><g transform=\\\\\\\"scale(4 4)\\\\\\\"><rect width=\\\"410\\\" height=\\\"365\\\" fill=\\\"';\\n        }\\n        parts[5] = amount >= 2 ? randomStrings[17 + uint256(keccak256(abi.encodePacked(\\\"FGCOLOR\\\", tokenId))) % 6] : randomStrings[27 + uint256(keccak256(abi.encodePacked(\\\"FGCOLOR\\\", tokenId))) % 6];\\n        parts[6] = '\\\" />';\\n        parts[7] = \\\"\\\";\\n        parts[8] = \\\"\\\";\\n        parts[9] = \\\"\\\";\\n        parts[10] = \\\"\\\"; \\n        parts[11] = '</g></svg>';\\n\\n        if (randParts.r4 > 0) {\\n            randParts.colorCanvas = _blank(randParts.colorCanvas, true);\\n\\n            iterations = amount / 4;\\n            for (uint256 i = 0; i < iterations; i++) {\\n                randParts.r1 = uint256(keccak256(abi.encodePacked(\\\"X2\\\", i, tokenId))) % 30;\\n                randParts.r2 = uint256(keccak256(abi.encodePacked(\\\"Y2\\\", i, tokenId))) % 29;\\n                randParts.colorCanvas = _box(randParts.colorCanvas, i % 2 == 0 ? randParts.border : randParts.corruptor, randParts.r1, randParts.r2, 1, 1, true);\\n                canvas = _box(canvas, \\\"&#x000A0;\\\", randParts.r1, randParts.r2, 1, 1, false);\\n            }\\n\\n            for (uint8 i = 0; i < 30; i++) {\\n                parts[9] = randomStrings[11 + ((tokenId + i) * i * 41) % 6];\\n                parts[8] = string(abi.encodePacked(\\n                    parts[8], '<text x=\\\"10\\\" y=\\\"', lookup[i], '\\\" class=\\\"base\\\" style=\\\"fill: ', parts[9], '\\\">', randParts.colorCanvas[i], '</text>'\\n                ));\\n            }\\n\\n            parts[9] = \\\"\\\";\\n\\n            // randParts.colorCanvas = _blank(randParts.colorCanvas, true);\\n            randParts.colorCanvas = _box(randParts.colorCanvas, \\\"|\\\", 0, 0, 31, 1, true);\\n            randParts.colorCanvas = _box(randParts.colorCanvas, \\\"|\\\", 0, 0, 1, 6, true);\\n            randParts.colorCanvas = _box(randParts.colorCanvas, \\\"|\\\", 30, 0, 1, 6, true);\\n            randParts.colorCanvas = _box(randParts.colorCanvas, \\\"|\\\", 0, 5, 31, 1, true);\\n            randParts.colorCanvas = _text(randParts.colorCanvas, \\\" CONCEPTS \\\", 10, 2, 0);\\n            randParts.colorCanvas = _text(randParts.colorCanvas, string(abi.encodePacked(\\\"+ \\\", randParts.phrase)), 12, 2, 2);\\n            randParts.colorCanvas = _text(randParts.colorCanvas, string(abi.encodePacked(\\\"+ \\\", randomStrings[27 + uint256(keccak256(abi.encodePacked(\\\"FGCOLOR\\\", tokenId))) % 6])), 12, 2, 3);\\n\\n            for (uint8 i = 0; i < 6; i++) {\\n                parts[9] = string(abi.encodePacked(\\n                    parts[9], '<text x=\\\"10\\\" y=\\\"', lookup[i], '\\\" class=\\\"base\\\">', randParts.colorCanvas[i], '</text>'\\n                ));\\n            }\\n\\n            // parts[9] = string(abi.encodePacked(\\n            //     '<g transform=\\\\\\\"translate(200 0)\\\\\\\">', parts[9], '</g>'\\n            // ));\\n        }\\n\\n        for (uint8 i = 0; i < 31; i++) {\\n            output = string(abi.encodePacked(\\n                output, '<text x=\\\"10\\\" y=\\\"', lookup[i], '\\\" class=\\\"base\\\">', canvas[i], '</text>'\\n            ));\\n        }\\n\\n        parts[7] = output;\\n\\n        if (!randParts.omitInsight && amount >= 20) {\\n            parts[10] = characterResource.resource();\\n        }\\n\\n        output = string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4], parts[5], parts[6]));\\n        output = string(abi.encodePacked(output, parts[7], parts[8], '<g transform=\\\\\\\"translate(200 0)\\\\\\\">', parts[9], '</g>', parts[10], parts[11]));\\n        return Base64.encode(bytes(output));\\n    }\\n\\n    function tokenURI(uint256 tokenId, uint256 amount) override external view returns (string memory) {\\n        InsightMap memory insightMap = corruptions.insightMap(tokenId);\\n\\n        if (insightMap.lastSaveBlock <= 13604851 && tokenId != 3193) {\\n            amount += 1; // fix early transfer bug\\n        }\\n        \\n        string memory json;\\n        string[32] memory emptyCanvas;\\n        \\n        if (tokenId == 4144) {\\n            // hard-coding since bidirectional data mapper wasn't used in expected way. expected key 0 to == the token id, but this wasn't explained\\n            // will explain better next time it's needed (or perhaps just code the inputs into the respective contract directly)\\n            json = Base64.encode(bytes(string(abi.encodePacked('{\\\"name\\\": \\\"0x', toHexString(tokenId), ' (Menes, Goddess of Kingdoms)\\\", \\\"description\\\": \\\"', description, '\\\", \\\"image\\\": \\\"', menes.base(), '\\\", \\\"attributes\\\": [{\\\"trait_type\\\": \\\"Type\\\", \\\"value\\\": \\\"???\\\"}]}'))));\\n        } else if (dataMapper.valueFor(0, tokenId) > 0) {\\n            DeviationInfo memory info = ICorruptionsDeviationRegistry(0x40f7ad19c7F37AcD76958d61Cbc783c77411cd9b).valueFor(dataMapper.valueFor(0, tokenId));\\n            json = Base64.encode(bytes(string(abi.encodePacked('{\\\"name\\\": \\\"0x', toHexString(tokenId), '\\\", \\\"description\\\": \\\"', description, '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,', draw(tokenId, amount, ICorruptionsDeviationWriter(info.contractAddress).drawCanvas(tokenId, amount)), '\\\", \\\"attributes\\\": [{\\\"trait_type\\\": \\\"Deviation\\\", \\\"value\\\": \\\"', info.name, '\\\"}]}'))));\\n        } else {\\n            string memory uri = string(abi.encodePacked('https://corruptions.art/?tokenId=', toString(tokenId), '&insight=', toString(amount)));\\n\\n            // due to complexity in ch3's rendering techniques, we use an external \\\"beta\\\" renderer until things are stable\\n            // once we're ready to leave beta we can port the new rendering techniques back to chain\\n            json = Base64.encode(bytes(string(abi.encodePacked('{\\\"animation_url\\\": \\\"', uri, '\\\", \\\"name\\\": \\\"0x', toHexString(tokenId), '\\\", \\\"description\\\": \\\"', description, '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,', draw(tokenId, amount, emptyCanvas), '\\\", \\\"attributes\\\": [{\\\"trait_type\\\": \\\"Insight\\\", \\\"value\\\": \\\"', toString(amount), '\\\"}]}'))));\\n        }\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", json));\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT license\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint i) internal pure returns (string memory) {\\n        // https://stackoverflow.com/a/69302348/424107\\n        \\n        if (i == 0) return \\\"0\\\";\\n        uint j = i;\\n        uint length;\\n        while (j != 0) {\\n            length++;\\n            j = j >> 4;\\n        }\\n        uint mask = 15;\\n        bytes memory bstr = new bytes(length);\\n        uint k = length;\\n        while (i != 0) {\\n            uint curr = (i & mask);\\n            bstr[--k] = curr > 9 ?\\n                bytes1(uint8(55 + curr)) :\\n                bytes1(uint8(48 + curr)); // 55 = 65 - 10\\n            i = i >> 4;\\n        }\\n        return string(bstr);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Base64.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"bool\",\"name\":\"whitespace\",\"type\":\"bool\"}],\"name\":\"_blank\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"w\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"h\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_box\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"char2\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"w\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"h\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_checkeredBox\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"xc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yc\",\"type\":\"uint256\"},{\"internalType\":\"int8\",\"name\":\"r\",\"type\":\"int8\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_circle\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"xc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_drawCircle\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"char\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"char2\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"singleChar\",\"type\":\"bool\"}],\"name\":\"_middleBox\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"messageLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"_richText\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[32]\",\"name\":\"canvas\",\"type\":\"string[32]\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"messageLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"_text\",\"outputs\":[{\"internalType\":\"string[32]\",\"name\":\"\",\"type\":\"string[32]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"betaRendererUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string[32]\",\"name\":\"oCanvas\",\"type\":\"string[32]\"}],\"name\":\"draw\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setBetaRendererUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resourceAddress\",\"type\":\"address\"}],\"name\":\"setCharacterResource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"}],\"name\":\"setDescription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fontAddress\",\"type\":\"address\"}],\"name\":\"setFont\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CorruptionsMetadata", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}