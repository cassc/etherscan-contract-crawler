{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SVGRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title A contract used to convert multi-part RLE compressed images to SVG\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { ISVGRenderer } from './interfaces/ISVGRenderer.sol';\\nimport { StringBufferLib } from '@lukasz.glen/string-buffer/contracts/StringBufferLib.sol';\\n\\ncontract SVGRenderer is ISVGRenderer {\\n    bytes16 private constant _HEX_SYMBOLS = '0123456789abcdef';\\n    uint256 private constant _INDEX_TO_BYTES3_FACTOR = 4;\\n\\n    // prettier-ignore\\n    string private constant _SVG_START_TAG = '<svg width=\\\"96\\\" height=\\\"96\\\" viewBox=\\\"0 0 96 96\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" shape-rendering=\\\"crispEdges\\\" fill=\\\"#E1D7D5\\\"><rect width=\\\"100%\\\" height=\\\"100%\\\" />';\\n    string private constant _SVG_END_TAG = '</svg>';\\n\\n    struct ContentBounds {\\n        uint8 top;\\n        uint8 right;\\n        uint8 bottom;\\n        uint8 left;\\n    }\\n\\n    struct Draw {\\n        uint8 length;\\n        uint8 colorIndex;\\n    }\\n\\n    struct DecodedImage {\\n        uint8 paletteId;\\n        ContentBounds bounds;\\n        Draw[] draws;\\n    }\\n\\n    /**\\n     * @notice Given RLE image data and color palette pointers, merge to generate a single SVG image.\\n     */\\n    function generateSVG(SVGParams calldata params) external pure override returns (string memory svg) { // 6 480 356\\n        // if (bytes(params.background).length != 0) {\\n        //     // prettier-ignore\\n        //     return string(\\n        //         abi.encodePacked(\\n        //             _SVG_START_TAG,\\n        //             '<rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"#', params.background, '\\\" />',\\n        //             _generateSVGRects(params),\\n        //             _SVG_END_TAG\\n        //         )\\n        //     );\\n        // }\\n        StringBufferLib.StringBuffer memory outputBuffer = StringBufferLib.initialize(2048);\\n        StringBufferLib.appendBytes(outputBuffer, bytes(_SVG_START_TAG));\\n        _generateSVGRects(params, outputBuffer);\\n        StringBufferLib.appendBytes(outputBuffer, bytes(_SVG_END_TAG));\\n        StringBufferLib.finalize(outputBuffer);\\n        return string(outputBuffer.data);\\n    }\\n\\n    /**\\n     * @notice Given RLE image data and a color palette pointer, merge to generate a partial SVG image.\\n     */\\n    function generateSVGPart(Part calldata part) external pure override returns (string memory partialSVG) {\\n        Part[] memory parts = new Part[](1);\\n        parts[0] = part;\\n\\n        StringBufferLib.StringBuffer memory outputBuffer = StringBufferLib.initialize(2048);\\n        _generateSVGRects(SVGParams({ parts: parts/*, background: '' */}), outputBuffer);\\n        StringBufferLib.finalize(outputBuffer);\\n        return string(outputBuffer.data);\\n    }\\n\\n    /**\\n     * @notice Given RLE image data and color palette pointers, merge to generate a partial SVG image.\\n     */\\n    function generateSVGParts(Part[] calldata parts) external pure override returns (string memory partialSVG) {\\n        StringBufferLib.StringBuffer memory outputBuffer = StringBufferLib.initialize(2048);\\n        _generateSVGRects(SVGParams({ parts: parts/*, background: '' */}), outputBuffer);\\n        StringBufferLib.finalize(outputBuffer);\\n        return string(outputBuffer.data);\\n    }\\n\\n    /**\\n     * @notice Given RLE image parts and color palettes, generate SVG rects.\\n     */\\n    // prettier-ignore\\n    function _generateSVGRects(SVGParams memory params, StringBufferLib.StringBuffer memory outputBuffer)\\n        private\\n        pure\\n    {\\n        bytes32[25] memory lookup = [\\n            bytes32('0'), '4', '8', '12', '16', '20', '24', '28',\\n            '32', '36', '40', '44', '48', '52', '56', '60',\\n            '64', '68', '72', '76', '80', '84', '88', '92',\\n            '96'\\n        ];\\n        string[] memory cache;\\n        uint256 cachedPaletteId = 256; // just to enforce cache initialization, max paletteId is 255\\n        for (uint8 p = 0; p < params.parts.length; p++) {\\n            DecodedImage memory image = _decodeRLEImage(params.parts[p].image);\\n            if (cachedPaletteId != image.paletteId) {\\n                cache = new string[](144); // Initialize color cache, assumed that palette is shorter than 144\\n                cachedPaletteId = image.paletteId;\\n            }\\n            uint256 currentX = image.bounds.left;\\n            uint256 currentY = image.bounds.top;\\n\\n            for (uint256 i = 0; i < image.draws.length; i++) {\\n                Draw memory draw = image.draws[i];\\n\\n                uint8 length = _getRectLength(currentX, draw.length, image.bounds.right);\\n                while (length > 0) {\\n                    if (draw.colorIndex != 0) {\\n                        string memory colorPart = _getColorPart(params.parts[p].palette, draw.colorIndex, cache); // color\\n                        StringBufferLib.appendBytesXX(outputBuffer, 0x3C726563742077696474683D2200000000000000000000000000000000000000, 13);  // <rect width=\\\"\\n                        StringBufferLib.appendBytesXX(outputBuffer, lookup[length], length < 3 ? 1 : 2);\\n                        StringBufferLib.appendBytesXX(outputBuffer, 0x22206865696768743D22342220783D2200000000000000000000000000000000, 16);  // \\\" height=\\\"4\\\" x=\\\"\\n                        StringBufferLib.appendBytesXX(outputBuffer, lookup[currentX], currentX < 3 ? 1 : 2);\\n                        StringBufferLib.appendBytesXX(outputBuffer, 0x2220793D22000000000000000000000000000000000000000000000000000000, 5);  // \\\" y=\\\"\\n                        StringBufferLib.appendBytesXX(outputBuffer, lookup[currentY], currentY < 3 ? 1 : 2);\\n                        StringBufferLib.appendBytes(outputBuffer, bytes(colorPart));\\n                    }\\n\\n                    currentX += length;\\n                    if (currentX == image.bounds.right) {\\n                        currentX = image.bounds.left;\\n                        currentY++;\\n                    }\\n\\n                    draw.length -= length;\\n                    length = _getRectLength(currentX, draw.length, image.bounds.right);\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Given an x-coordinate, draw length, and right bound, return the draw\\n     * length for a single SVG rectangle.\\n     */\\n    function _getRectLength(\\n        uint256 currentX,\\n        uint8 drawLength,\\n        uint8 rightBound\\n    ) private pure returns (uint8) {\\n        uint8 remainingPixelsInLine = rightBound - uint8(currentX);\\n        return drawLength <= remainingPixelsInLine ? drawLength : remainingPixelsInLine;\\n    }\\n\\n    /**\\n     * @notice Decode a single RLE compressed image into a `DecodedImage`.\\n     */\\n    function _decodeRLEImage(bytes memory image) private pure returns (DecodedImage memory) {\\n        ContentBounds memory bounds = ContentBounds({\\n            top: uint8(image[1]),\\n            right: uint8(image[2]),\\n            bottom: uint8(image[3]),\\n            left: uint8(image[4])\\n        });\\n\\n        uint256 cursor;\\n        Draw[] memory draws = new Draw[]((image.length - 5) / 2);\\n        for (uint256 i = 5; i < image.length; i += 2) {\\n            draws[cursor] = Draw({ length: uint8(image[i]), colorIndex: uint8(image[i + 1]) });\\n            cursor++;\\n        }\\n        return DecodedImage({ paletteId: uint8(image[0]), bounds: bounds, draws: draws });\\n    }\\n\\n    /**\\n     * @notice Get the target hex color code from the cache. Populate the cache if\\n     * the color code does not yet exist.\\n     */\\n    function _getColorPart(\\n        bytes memory palette,\\n        uint256 index,\\n        string[] memory cache\\n    ) private pure returns (string memory) {\\n        unchecked {\\n            if (bytes(cache[index]).length == 0) {\\n                uint256 i = index * _INDEX_TO_BYTES3_FACTOR;\\n                bytes memory entry;\\n                if (palette[i + 3] == 0xff) {\\n                    entry = '\\\" fill=\\\"#      \\\" />';\\n                } else {\\n                    entry = '\\\" fill=\\\"#      \\\" opacity=\\\"0.  \\\" />';\\n                    uint256 opacityValue = uint256(uint8(palette[i + 3])) * 100 / 0xff;\\n                    entry[28] = bytes1(uint8(48 + (opacityValue / 10))); // 48 is ascii 0\\n                    entry[29] = bytes1(uint8(48 + (opacityValue % 10))); // 48 is ascii 0\\n                }\\n                entry[9] = _HEX_SYMBOLS[uint8(palette[i]) >> 4];\\n                entry[10] = _HEX_SYMBOLS[uint8(palette[i]) & 0xf];\\n                entry[11] = _HEX_SYMBOLS[uint8(palette[i + 1]) >> 4];\\n                entry[12] = _HEX_SYMBOLS[uint8(palette[i + 1]) & 0xf];\\n                entry[13] = _HEX_SYMBOLS[uint8(palette[i + 2]) >> 4];\\n                entry[14] = _HEX_SYMBOLS[uint8(palette[i + 2]) & 0xf];\\n                cache[index] = string(entry);\\n                return string(entry);\\n            }\\n            return cache[index];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISVGRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for SVGRenderer\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\ninterface ISVGRenderer {\\n    struct Part {\\n        bytes image;\\n        bytes palette;\\n    }\\n\\n    struct SVGParams {\\n        Part[] parts;\\n//        string background;\\n    }\\n\\n    function generateSVG(SVGParams memory params) external view returns (string memory svg);\\n\\n    function generateSVGPart(Part memory part) external view returns (string memory partialSVG);\\n\\n    function generateSVGParts(Part[] memory parts) external view returns (string memory partialSVG);\\n}\\n\"\r\n    },\r\n    \"@lukasz.glen/string-buffer/contracts/StringBufferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * @title String Buffer Library\\n * @author lukasz-glen\\n * @dev String Buffer for Solidity.\\n * Allocates a single buffer and writes data with appending functions.\\n * It works well with large strings/bytes/amount of data/multiple appending.\\n * Multiple appends are more gas efficient than multiple abi.encodePacked().\\n * StringBuffer struct is fly weight because it uses memory pointers.\\n * StringBuffer struct is valid only within a single call, cannot be stored or be passed to another contracts.\\n * It uses low level memory manipulation, so some provers or other tools can fail - you must be careful.\\n * It does not break solidity memory layout, but it depends on its internal memory structures.\\n */\\nlibrary StringBufferLib {\\n\\n    struct StringBuffer {\\n        // a buffer, the length field is changed by finalize()\\n        bytes data;\\n        // a pointer in the memory, the current pointer for buffer writing\\n        uint256 pointer;\\n        // a pointer is the memory, the boundary pointer for buffer writing, 32 bytes margin not included\\n        uint256 limit;\\n    }\\n\\n    /**\\n     * @dev creates a new buffer\\n     * it is better to start large initial length, extending a buffer actually copies byte arrays\\n     * the actual buffer length is length + 32, 32 bytes is the margin for safe copying\\n     * @param length initial buffer length\\n     */\\n    function initialize(uint256 length) internal pure returns (StringBuffer memory stringBuffer) {\\n        unchecked {\\n            bytes memory data = new bytes(length + 32);\\n            uint256 pointer;\\n            assembly {\\n                pointer := add(data, 0x20)\\n            }\\n            stringBuffer = StringBuffer(data, pointer, pointer + length);\\n        }\\n    }\\n\\n    /**\\n     * @dev it sets an actual length of stringBuffer.data\\n     * it can be called multiple times if needed\\n     */\\n    function finalize(StringBuffer memory stringBuffer) internal pure {\\n        // stringBuffer.data.length = stringBuffer.pointer - beginning of stringBuffer.data\\n        assembly {\\n            mstore(mload(stringBuffer), sub(mload(add(stringBuffer, 0x20)), add(mload(stringBuffer), 0x20)))\\n        }\\n    }\\n\\n    /**\\n     * @dev appends bytes/string to a buffer\\n     * the buffer is extended if needed\\n     * if appending a constant string not longer than 32 bytes, it is better to use appendBytesXX()\\n     */\\n    function appendBytes(StringBuffer memory stringBuffer, bytes memory newData) internal pure {\\n        unchecked {\\n            uint256 newDataLength = newData.length;\\n            // const value\\n            uint256 srcEndPointer;\\n            stringBuffer.pointer += newDataLength;\\n            // const value\\n            uint256 destEndPointer = stringBuffer.pointer;\\n            // extend buffer if the limit is exceeded\\n            if (destEndPointer > stringBuffer.limit) {\\n                // values of srcEndPointer and destEndPointer to copy a buffer\\n                srcEndPointer = destEndPointer - newDataLength;\\n                uint256 length;\\n                // length = previous stringBuffer.pointer - beginning of stringBuffer.data\\n                assembly {\\n                    length := sub(srcEndPointer, add(mload(stringBuffer), 0x20))\\n                }\\n                // a new data buffer, + 32 bytes of margin\\n                bytes memory extendedData = new bytes(2 * length + 2 * newDataLength + 32);\\n                assembly {\\n                    destEndPointer := add(add(extendedData, 0x20), length)\\n                }\\n                // copy from an old buffer to a new buffer\\n                // that is assumed that allocating a string of length 1 << 255 is impossible\\n                // the condition fails on underflows (length - 1 and length -= 32)\\n                // length - 1 filters out the case length == 0\\n                // note that this condition is not equal to length < (1 << 255), check the case length == 0\\n                while (length - 1 < 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n                    assembly {\\n                        mstore(sub(destEndPointer, length), mload(sub(srcEndPointer, length)))\\n                    }\\n                    length -= 32;\\n                }\\n                destEndPointer += newDataLength;\\n                stringBuffer.data = extendedData;\\n                stringBuffer.pointer = destEndPointer;\\n                // stringBuffer.limit = beginning of extendedData + extendedData.length - 32;\\n                // 32 bytes are subtracted because of the margin at the end\\n                // first 32 bytes of bytes type keep length, so it is actually - 32 bytes to the length\\n                assembly {\\n                    mstore(add(stringBuffer, 0x40), add(extendedData, mload(extendedData)))\\n                }\\n            }\\n            assembly {\\n                srcEndPointer := add(add(newData, 0x20), newDataLength)\\n            }\\n            // that is assumed that allocating a string of newDataLength 1 << 255 is impossible\\n            // the condition fails on underflows (newDataLength - 1 and newDataLength -= 32)\\n            // newDataLength - 1 filters out the case newDataLength == 0\\n            // note that this condition is not equal to newDataLength < (1 << 255), check the case newDataLength == 0\\n            // copying is safe because of 32 bytes margin\\n            while (newDataLength - 1 < 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n                assembly {\\n                    mstore(sub(destEndPointer, newDataLength), mload(sub(srcEndPointer, newDataLength)))\\n                }\\n                newDataLength -= 32;\\n            }\\n        }\\n    }\\n\\n    function appendBytes32(StringBuffer memory stringBuffer, bytes32 newData) internal pure {\\n        // first copy data, than check limits, it is safe because of 32 bytes margin\\n        // mem[stringBuffer.pointer, +32] = newData\\n        assembly {\\n            mstore(mload(add(stringBuffer, 0x20)), newData)\\n        }\\n        unchecked {\\n            stringBuffer.pointer += 32;\\n            // extend buffer if the limit is exceeded\\n            if (stringBuffer.pointer > stringBuffer.limit) {\\n                // a new data buffer, + 32 bytes of margin\\n                bytes memory extendedData = new bytes(2 * stringBuffer.data.length + 32);\\n                uint256 srcEndPointer = stringBuffer.pointer;\\n                uint256 destEndPointer;\\n                uint256 length;\\n                // length = stringBuffer.pointer - beginning of stringBuffer.data\\n                assembly {\\n                    length := sub(srcEndPointer, add(mload(stringBuffer), 0x20))\\n                    destEndPointer := add(add(extendedData, 0x20), length)\\n                }\\n                // copy from an old buffer to a new buffer\\n                // that is assumed that allocating a string of length 1 << 255 is impossible\\n                // the condition fails on underflows (length - 1 and length -= 32)\\n                // length - 1 filters out the case length == 0\\n                // note that this condition is not equal to length < (1 << 255), check the case length == 0\\n                while (length - 1 < 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n                    assembly {\\n                        mstore(sub(destEndPointer, length), mload(sub(srcEndPointer, length)))\\n                    }\\n                    length -= 32;\\n                }\\n                stringBuffer.data = extendedData;\\n                stringBuffer.pointer = destEndPointer;\\n                // stringBuffer.limit = beginning of extendedData + extendedData.length - 32;\\n                // 32 bytes are subtracted because of the margin at the end\\n                // first 32 bytes of bytes type keep length, so it is actually - 32 bytes to the length\\n                assembly {\\n                    mstore(add(stringBuffer, 0x40), add(extendedData, mload(extendedData)))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev it copies only first 'length' bytes of newData to stringBuffer.data\\n     * it is not validated that length <= 32\\n     * the buffer is extended if needed\\n     */\\n    function appendBytesXX(StringBuffer memory stringBuffer, bytes32 newData, uint256 newDataLength) internal pure {\\n        // first copy data, than check limits, it is safe because of 32 bytes margin\\n        // mem[stringBuffer.pointer, +32] = newData\\n        assembly {\\n            mstore(mload(add(stringBuffer, 0x20)), newData)\\n        }\\n        unchecked {\\n            stringBuffer.pointer += newDataLength;\\n            // extend buffer if the limit is exceeded\\n            if (stringBuffer.pointer > stringBuffer.limit) {\\n                // a new data buffer, + 32 bytes of margin\\n                bytes memory extendedData = new bytes(2 * stringBuffer.data.length + 32);\\n                uint256 srcEndPointer = stringBuffer.pointer;\\n                uint256 destEndPointer;\\n                uint256 length;\\n                // length = stringBuffer.pointer - beginning of stringBuffer.data\\n                assembly {\\n                    length := sub(srcEndPointer, add(mload(stringBuffer), 0x20))\\n                    destEndPointer := add(add(extendedData, 0x20), length)\\n                }\\n                // copy from an old buffer to a new buffer\\n                // that is assumed that allocating a string of length 1 << 255 is impossible\\n                // the condition fails on underflows (length - 1 and length -= 32)\\n                // length - 1 filters out the case length == 0\\n                // note that this condition is not equal to length < (1 << 255), check the case length == 0\\n                while (length - 1 < 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\\n                    assembly {\\n                        mstore(sub(destEndPointer, length), mload(sub(srcEndPointer, length)))\\n                    }\\n                    length -= 32;\\n                }\\n                stringBuffer.data = extendedData;\\n                stringBuffer.pointer = destEndPointer;\\n                // stringBuffer.limit = beginning of extendedData + extendedData.length - 32;\\n                // 32 bytes are subtracted because of the margin at the end\\n                // first 32 bytes of bytes type keep length, so it is actually - 32 bytes to the length\\n                assembly {\\n                    mstore(add(stringBuffer, 0x40), add(extendedData, mload(extendedData)))\\n                }\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"image\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"internalType\":\"struct ISVGRenderer.Part[]\",\"name\":\"parts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISVGRenderer.SVGParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"generateSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"svg\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"image\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"internalType\":\"struct ISVGRenderer.Part\",\"name\":\"part\",\"type\":\"tuple\"}],\"name\":\"generateSVGPart\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"partialSVG\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"image\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"internalType\":\"struct ISVGRenderer.Part[]\",\"name\":\"parts\",\"type\":\"tuple[]\"}],\"name\":\"generateSVGParts\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"partialSVG\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SVGRenderer", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}