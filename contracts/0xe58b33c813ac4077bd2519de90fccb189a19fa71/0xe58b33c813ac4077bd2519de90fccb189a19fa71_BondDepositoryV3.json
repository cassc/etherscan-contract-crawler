{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/BondDepositoryV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport {IKotoV3} from \\\"./interfaces/IKotoV3.sol\\\";\\nimport {IUniswapV2Router02} from \\\"./interfaces/IUniswapV2Router02.sol\\\";\\nimport {IUniswapV2Factory} from \\\"./interfaces/IUniswapv2Factory.sol\\\";\\n\\npragma solidity 0.8.23;\\n\\ninterface IERC20Minimal {\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function balanceOf(address) external view returns (uint256);\\n}\\n\\ncontract BondDepositoryV3 {\\n    IUniswapV2Factory public constant FACTORY = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\\n    address public constant OWNER = 0x946eF43867225695E29241813A8F41519634B36b;\\n    address public constant UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    uint256 public constant TIMELOCK_INTERVAL = 86400 * 3; // 3 day timelock\\n    uint256 public execution = type(uint256).max;\\n    ///@dev set timelock to max so that it can not be called\\n    address public koto;\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != OWNER) revert OnlyOwner();\\n        _;\\n    }\\n\\n    constructor() {}\\n\\n    ///@notice bond ETH held within the depository for Koto Tokens\\n    ///@param _value the ether value to send to the Koto Contract.\\n    function bond(uint256 _value) external onlyOwner {\\n        uint256 amountOut = IKotoV3(koto).bond{value: _value}();\\n        emit DepositoryBond(_value, amountOut);\\n    }\\n\\n    ///@notice redeem Koto tokens held within the depository for ETH\\n    ///@param _amount the amount of Koto tokens to redeem\\n    function redeem(uint256 _amount) external onlyOwner {\\n        uint256 ethAmount = IKotoV3(koto).redeem(_amount);\\n        emit DepositoryRedeem(_amount, ethAmount);\\n    }\\n\\n    ///@notice burn additional Koto tokens held within the depository without redeeming them\\n    ///@param _amount the amount of Koto tokens to burn.\\n    function burn(uint256 _amount) external onlyOwner {\\n        IKotoV3(koto).burn(_amount);\\n        emit DepositoryBurn(_amount);\\n    }\\n\\n    ///@notice swap eth for koto or koto for eth\\n    ///@param _value the amount of either eth or koto to swap\\n    ///@param zeroForOne if you are swaping eth or koto\\n    ///@dev when zeroForOne is true koto is being swapped to eth\\n    function swap(uint256 _value, bool zeroForOne, uint256 _minAmount) external onlyOwner {\\n        if (zeroForOne) {\\n            address[] memory path = new address[](2);\\n            path[0] = koto;\\n            path[1] = WETH;\\n            IUniswapV2Router02(UNISWAP_ROUTER).swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                _value, _minAmount, path, address(this), block.timestamp\\n            );\\n            emit DepositorySell(_value);\\n        } else {\\n            address[] memory path = new address[](2);\\n            path[0] = WETH;\\n            path[1] = koto;\\n            IUniswapV2Router02(UNISWAP_ROUTER).swapExactETHForTokensSupportingFeeOnTransferTokens{value: _value}(\\n                _minAmount, path, address(this), block.timestamp\\n            );\\n            emit DepositoryBuy(_value);\\n        }\\n    }\\n\\n    ///@notice send reward tokens to the Voter contract in order to being reward distribution.\\n    function reward(uint256 amount, address _to) external onlyOwner {\\n        if (msg.sender != OWNER) revert OnlyOwner();\\n        if (amount > IKotoV3(koto).allowance(address(this), _to)) {\\n            IKotoV3(koto).approve(_to, type(uint256).max);\\n        }\\n        assembly {\\n            let ptr := mload(0x40)\\n            ///@dev notifyRewardAmount function sig.\\n            mstore(ptr, 0x3c6b16ab00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(ptr, 4), amount)\\n            let success := call(gas(), _to, 0, ptr, 36, 0, 0)\\n            if iszero(success) { revert(0, 0) }\\n        }\\n    }\\n\\n    ///@notice set the koto contract address\\n    function set(address _koto) external onlyOwner {\\n        koto = _koto;\\n        IKotoV3(_koto).approve(_koto, type(uint256).max);\\n        IKotoV3(_koto).approve(UNISWAP_ROUTER, type(uint256).max);\\n        emit Set(_koto);\\n    }\\n\\n    /// @notice create the markets for the eth and lp bonds\\n    /// @param ethBondAmount the amount of koto tokens to set aside for Eth bonds\\n    /// @param lpBondAmount the amount of koto tokens to set aside for LP Bonds\\n    function deposit(uint256 ethBondAmount, uint256 lpBondAmount) external onlyOwner {\\n        address _koto = koto;\\n        IKotoV3(_koto).create(ethBondAmount, lpBondAmount);\\n        emit DepositoryDeposit(_koto, ethBondAmount + lpBondAmount, ethBondAmount, lpBondAmount);\\n    }\\n\\n    ///@notice begin timelock function if migrating liquidity is needed\\n    function start() external onlyOwner {\\n        execution = block.timestamp + TIMELOCK_INTERVAL;\\n        emit TimelockStart(block.timestamp, execution);\\n    }\\n\\n    ///@notice in a emergency withdraw the liquidity pool tokens after the timelock has passed\\n    ///@param to the address to send the LP tokens to.\\n    function emergencyWithdraw(address to) external onlyOwner {\\n        if (block.timestamp < execution) revert Timelock();\\n        address _pair = FACTORY.getPair(koto, WETH);\\n        uint256 _balance = IERC20Minimal(_pair).balanceOf(address(this));\\n        IERC20Minimal(_pair).transfer(to, _balance);\\n        execution = type(uint256).max;\\n        emit LiquidityMigration(to, _balance);\\n    }\\n\\n    event DepositoryBond(uint256 ethAmountIn, uint256 kotoAmountOut);\\n    event DepositoryBurn(uint256 kotoBurnAmount);\\n    event DepositoryBuy(uint256 ethAmountIn);\\n    event DepositoryDeposit(address indexed token, uint256 kotoIn, uint256 ethCapacity, uint256 lpCapacity);\\n    event DepositoryRedeem(uint256 kotoAmountIn, uint256 ethAmountOut);\\n    event DepositorySell(uint256 kotoAmountOut);\\n    event LiquidityMigration(address indexed receiver, uint256 amount);\\n    event Set(address indexed token);\\n    event TimelockStart(uint256 initializedTime, uint256 executionTime);\\n\\n    error OnlyOwner();\\n    error Timelock();\\n    error TransferFailed();\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IKotoV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport {PricingLibrary} from \\\"../PricingLibrary.sol\\\";\\n\\ninterface IKotoV3 {\\n    // ==================== EXTERNAL FUNCTIONS ===================== \\\\\\\\\\n\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n    ///@notice exchange ETH for Koto tokens at the current bonding price\\n    ///@dev bonds are set on 1 day intervals with 4 hour deposit intervals and 30 minute tune intervals.\\n    function bond() external payable returns (uint256 payout);\\n\\n    function bondLp(uint256 _lpAmount) external returns (uint256 payout);\\n\\n    ///@notice burn Koto tokens in exchange for a piece of the underlying reserves\\n    ///@param amount The amount of Koto tokens to redeem\\n    ///@return payout The amount of ETH received in exchange for the Koto tokens\\n    function redeem(uint256 amount) external returns (uint256 payout);\\n\\n    ///@notice burn Koto tokens, without redemption\\n    ///@param amount the amount of Koto to burn\\n    function burn(uint256 amount) external returns (bool success);\\n\\n    // ==================== EXTERNAL VIEW FUNCTIONS ===================== \\\\\\\\\\n\\n    ///@notice get the tokens name\\n    function name() external pure returns (string memory);\\n\\n    ///@notice get the tokens symbol\\n    function symbol() external pure returns (string memory);\\n\\n    ///@notice get the tokens decimals\\n    function decimals() external pure returns (uint8);\\n\\n    ///@notice get the tokens total supply\\n    function totalSupply() external view returns (uint256);\\n\\n    ///@notice get the current balance of a user\\n    ///@param _owner the user whos balance you want to check\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    ///@notice get current approved amount for transfer from another party\\n    ///@param owner the current owner of the tokens\\n    ///@param spender the user who has approval (or not) to spend the owners tokens\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    ///@notice return the Uniswap V2 Pair address\\n    function pool() external view returns (address);\\n\\n    ///@notice get the owner of the contract\\n    ///@dev ownership is nontransferable and limited to opening trade, exclusion / inclusion,s and increasing liquidity\\n    function ownership() external pure returns (address);\\n\\n    ///@notice the current price a bond\\n    function bondPrice() external view returns (uint256);\\n\\n    function bondPriceLp() external view returns (uint256);\\n\\n    ///@notice return the current redemption price for 1 uint of Koto.\\n    function redemptionPrice() external view returns (uint256);\\n\\n    function marketInfo()\\n        external\\n        view\\n        returns (PricingLibrary.Market memory, PricingLibrary.Term memory, PricingLibrary.Data memory);\\n\\n    function lpMarketInfo()\\n        external\\n        view\\n        returns (PricingLibrary.Market memory, PricingLibrary.Term memory, PricingLibrary.Data memory);\\n\\n    function depository() external pure returns (address);\\n\\n    function create(uint256 ethBondAmount, uint256 lpBondAmount) external;\\n\\n    // ========================= EVENTS ========================= \\\\\\\\\\n\\n    event AmmAdded(address poolAdded);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    event Bond(address indexed buyer, uint256 amount, uint256 bondPrice);\\n    event CreateMarket(uint256 bonds, uint256 start, uint48 end);\\n    event IncreaseLiquidity(uint256 kotoAdded, uint256 ethAdded);\\n    event Launched(uint256 time);\\n    event LimitsRemoved(uint256 time);\\n    event OpenBondMarket(uint256 openingTime);\\n    event Redeem(address indexed sender, uint256 burned, uint256 payout, uint256 floorPrice);\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event UserExcluded(address indexed userToExclude);\\n\\n    // ========================= ERRORS ========================= \\\\\\\\\\n\\n    error AlreadyLaunched();\\n    error BondFailed();\\n    error InsufficentAllowance();\\n    error InsufficentBalance();\\n    error InsufficentBondsAvailable();\\n    error InvalidSender();\\n    error InvalidTransfer();\\n    error LimitsReached();\\n    error MarketClosed();\\n    error MaxPayout();\\n    error OngoingBonds();\\n    error OnlyOwner();\\n    error RedeemFailed();\\n    error Reentrancy();\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router02 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapv2Factory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Factory {\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n}\\n\"\r\n    },\r\n    \"src/PricingLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nlibrary PricingLibrary {\\n    // 1 Slot\\n    struct Data {\\n        uint48 lastTune;\\n        uint48 lastDecay; // last timestamp when market was created and debt was decayed\\n        uint48 length; // time from creation to conclusion. used as speed to decay debt.\\n        uint48 depositInterval; // target frequency of deposits\\n        uint48 tuneInterval; // frequency of tuning\\n    }\\n\\n    // 2 Storage slots\\n    struct Market {\\n        uint96 capacity; // capacity remaining\\n        uint96 totalDebt; // total debt from market\\n        uint96 maxPayout; // max tokens in/out\\n        uint96 sold; // Koto out\\n        uint96 purchased; // Eth in\\n    }\\n\\n    // 1 Storage Slot\\n    struct Adjustment {\\n        uint128 change;\\n        uint48 lastAdjustment;\\n        uint48 timeToAdjusted;\\n        bool active;\\n    }\\n\\n    // 2 Storage slots\\n    struct Term {\\n        uint48 conclusion; // timestamp when the current market will end\\n        uint256 controlVariable; // scaling variable for price\\n    }\\n\\n    function decay(Data memory data, Market memory market, Term memory terms, Adjustment memory adjustments)\\n        internal\\n        view\\n        returns (Market memory, Data memory, Term memory, Adjustment memory)\\n    {\\n        uint48 time = uint48(block.timestamp);\\n        market.totalDebt -= debtDecay(data, market);\\n        data.lastDecay = time;\\n\\n        if (adjustments.active) {\\n            (uint128 adjustby, uint48 dt, bool stillActive) = controlDecay(adjustments);\\n            terms.controlVariable -= adjustby;\\n            if (stillActive) {\\n                adjustments.change -= adjustby;\\n                adjustments.timeToAdjusted -= dt;\\n                adjustments.lastAdjustment = time;\\n            } else {\\n                adjustments.active = false;\\n            }\\n        }\\n        return (market, data, terms, adjustments);\\n    }\\n\\n    function controlDecay(Adjustment memory info) internal view returns (uint128, uint48, bool) {\\n        if (!info.active) return (0, 0, false);\\n\\n        uint48 secondsSince = uint48(block.timestamp) - info.lastAdjustment;\\n        bool active = secondsSince < info.timeToAdjusted;\\n        uint128 _decay = active ? (info.change * secondsSince) / info.timeToAdjusted : info.change;\\n        return (_decay, secondsSince, active);\\n    }\\n\\n    function marketPrice(uint256 _controlVariable, uint256 _totalDebt, uint256 _totalSupply)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return ((_controlVariable * debtRatio(_totalDebt, _totalSupply)) / 1e18);\\n    }\\n\\n    function debtRatio(uint256 _totalDebt, uint256 _totalSupply) internal pure returns (uint256) {\\n        return ((_totalDebt * 1e18) / _totalSupply);\\n    }\\n\\n    function debtDecay(Data memory data, Market memory market) internal view returns (uint64) {\\n        uint256 secondsSince = block.timestamp - data.lastDecay;\\n        return uint64((market.totalDebt * secondsSince) / data.length);\\n    }\\n\\n    struct TuneCache {\\n        uint256 remaining;\\n        uint256 price;\\n        uint256 capacity;\\n        uint256 targetDebt;\\n        uint256 ncv;\\n    }\\n\\n    function tune(\\n        uint48 time,\\n        Market memory market,\\n        Term memory term,\\n        Data memory data,\\n        Adjustment memory adjustment,\\n        uint256 _totalSupply\\n    ) internal pure returns (Market memory, Term memory, Data memory, Adjustment memory) {\\n        TuneCache memory cache;\\n        if (time >= data.lastTune + data.tuneInterval) {\\n            cache.remaining = term.conclusion - time;\\n            cache.price = marketPrice(term.controlVariable, market.totalDebt, _totalSupply);\\n            cache.capacity = market.capacity;\\n            market.maxPayout = uint96((cache.capacity * data.depositInterval / cache.remaining));\\n            cache.targetDebt = cache.capacity * data.length / cache.remaining;\\n            cache.ncv = (cache.price * _totalSupply) / cache.targetDebt;\\n\\n            if (cache.ncv < term.controlVariable) {\\n                uint128 change = uint128(term.controlVariable - cache.ncv);\\n                adjustment = Adjustment(change, time, data.tuneInterval, true);\\n            } else {\\n                term.controlVariable = cache.ncv;\\n            }\\n            data.lastTune = time;\\n        }\\n        return (market, term, data, adjustment);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Timelock\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kotoAmountOut\",\"type\":\"uint256\"}],\"name\":\"DepositoryBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kotoBurnAmount\",\"type\":\"uint256\"}],\"name\":\"DepositoryBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmountIn\",\"type\":\"uint256\"}],\"name\":\"DepositoryBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kotoIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethCapacity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpCapacity\",\"type\":\"uint256\"}],\"name\":\"DepositoryDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kotoAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmountOut\",\"type\":\"uint256\"}],\"name\":\"DepositoryRedeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kotoAmountOut\",\"type\":\"uint256\"}],\"name\":\"DepositorySell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LiquidityMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initializedTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"executionTime\",\"type\":\"uint256\"}],\"name\":\"TimelockStart\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FACTORY\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMELOCK_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"bond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ethBondAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBondAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"execution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"koto\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_koto\",\"type\":\"address\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BondDepositoryV3", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://119a1dcfe61f1cfe4443fb8b70264ce5a773b5d215bfc0735387906b6910fe4d"}