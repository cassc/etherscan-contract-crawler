{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Fundraising Gauge Fx\r\n@license MIT\r\n@author Aladdin DAO\r\n@notice Custom gauge directing emissions entirely to a specific address up to a maximum\r\n\"\"\"\r\n\r\n# Original idea and credit:\r\n# vefunder's Fundraising Gauge\r\n# https://github.com/vefunder/crvfunder/blob/main/contracts/FundraisingGaugeV1.vy\r\n# This contract is an almost-identical fork of the above contract\r\n# The address of CRV, GAUGE_CONTROLLER and MINTER are changed to corresponding one.\r\n\r\ninterface CRV20:\r\n    def rate() -> uint256: view\r\n    def future_epoch_time_write() -> uint256: nonpayable\r\n\r\ninterface GaugeController:\r\n    def checkpoint_gauge(_gauge: address): nonpayable\r\n    def gauge_relative_weight(_gauge: address, _time: uint256) -> uint256: view\r\n\r\ninterface Minter:\r\n    def minted(_user: address, _gauge: address) -> uint256: view\r\n\r\n\r\nevent Checkpoint:\r\n    _timestamp: uint256\r\n    _new_emissions: uint256\r\n\r\n\r\nADMIN: immutable(address)\r\n\r\n\r\nCRV: constant(address) = 0x365AccFCa291e7D3914637ABf1F7635dB165Bb09\r\nGAUGE_CONTROLLER: constant(address) = 0xe60eB8098B34eD775ac44B1ddE864e098C6d7f37\r\nMINTER: constant(address) = 0xC8b194925D55d5dE9555AD1db74c149329F71DeF\r\n\r\nWEEK: constant(uint256) = 604800\r\nYEAR: constant(uint256) = 86400 * 365\r\n\r\n# taken from CRV20 to allow calculating locally\r\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\r\nRATE_REDUCTION_COEFFICIENT: constant(uint256) = 1111111111111111111  # 1/0.9 * 1e18\r\nRATE_REDUCTION_TIME: constant(uint256) = YEAR\r\n\r\n# [uint216 inflation_rate][uint40 future_epoch_time]\r\ninflation_params: uint256\r\n_is_killed: bool\r\n\r\n# _user => accumulated CRV\r\nintegrate_fraction: public(HashMap[address, uint256])\r\nlast_checkpoint: public(uint256)\r\n\r\nreceiver: public(address)\r\nmax_emissions: public(uint256)\r\n\r\n\r\n@external\r\ndef __init__(_admin: address):\r\n    ADMIN = _admin\r\n\r\n    # prevent initialization of the implementation contract\r\n    self.last_checkpoint = MAX_UINT256\r\n\r\n\r\n@internal\r\ndef _user_checkpoint(_user: address) -> bool:\r\n    # timestamp of the last checkpoint and start point for calculating new emissions\r\n    prev_week_time: uint256 = self.last_checkpoint\r\n\r\n    # if time has not advanced since the last checkpoint\r\n    if block.timestamp == prev_week_time:\r\n        return True\r\n\r\n    # load the receiver\r\n    receiver: address = self.receiver\r\n    max_emissions: uint256 = self.max_emissions\r\n\r\n    # initialize emission tracking variables\r\n    receiver_emissions: uint256 = self.integrate_fraction[receiver]\r\n\r\n    # if the maximum emissions has already been reached return early\r\n    if receiver_emissions == max_emissions:\r\n        return True\r\n\r\n    # cache the receiver emissions var\r\n    cached_receiver_emissions: uint256 = receiver_emissions\r\n\r\n    # load and unpack inflation params\r\n    inflation_params: uint256 = self.inflation_params\r\n    rate: uint256 = shift(inflation_params, -40)\r\n    future_epoch_time: uint256 = bitwise_and(inflation_params, 2 ** 40 - 1)\r\n\r\n    # checkpoint the gauge filling in any missing gauge data across weeks\r\n    GaugeController(GAUGE_CONTROLLER).checkpoint_gauge(self)\r\n\r\n    # either the start of the next week or the current timestamp\r\n    week_time: uint256 = min((prev_week_time + WEEK) / WEEK * WEEK, block.timestamp)\r\n\r\n    # iterate 512 times at maximum\r\n    for i in range(512):\r\n        dt: uint256 = week_time - prev_week_time\r\n        w: uint256 = GaugeController(GAUGE_CONTROLLER).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\r\n\r\n        period_emissions: uint256 = 0\r\n\r\n        # if we cross over an inflation epoch, calculate the emissions using old and new rate\r\n        if prev_week_time <= future_epoch_time and future_epoch_time < week_time:\r\n            # calculate up to the epoch using the old rate\r\n            period_emissions = rate * w * (future_epoch_time - prev_week_time) / 10 ** 18\r\n            # update the rate in memory\r\n            rate = rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\r\n            # calculate using the new rate for the rest of the time period\r\n            period_emissions += rate * w * (week_time - future_epoch_time) / 10 ** 18\r\n            # update the new future epoch time\r\n            future_epoch_time += RATE_REDUCTION_TIME\r\n            # update storage\r\n            self.inflation_params = shift(rate, 40) + future_epoch_time\r\n        else:\r\n            period_emissions = rate * w * dt / 10 ** 18\r\n\r\n        # if adding period emissions is still below max emissions add to receiver\r\n        if receiver_emissions + period_emissions <= max_emissions:\r\n            receiver_emissions += period_emissions\r\n        # else set received emissions at max and break\r\n        else:\r\n            receiver_emissions = max_emissions\r\n            break\r\n\r\n        if week_time == block.timestamp:\r\n            break\r\n\r\n        # update timestamps for tracking timedelta\r\n        prev_week_time = week_time\r\n        week_time = min(week_time + WEEK, block.timestamp)\r\n\r\n    # this will only be the case if receiver got emissions\r\n    if receiver_emissions != cached_receiver_emissions:\r\n        self.integrate_fraction[receiver] = receiver_emissions\r\n\r\n    self.last_checkpoint = block.timestamp\r\n\r\n    log Checkpoint(block.timestamp, (receiver_emissions - cached_receiver_emissions))\r\n    return True\r\n\r\n\r\n@external\r\ndef user_checkpoint(_user: address) -> bool:\r\n    \"\"\"\r\n    @notice Checkpoint the gauge updating total emissions\r\n    @param _user The user to checkpoint and update accumulated emissions for\r\n    \"\"\"\r\n    return self._user_checkpoint(_user)\r\n\r\n\r\n@external\r\ndef claimable_tokens_write(_user: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable tokens per user\r\n    @dev This function should be manually changed to \"view\" in the ABI\r\n    @param _user The user to check claimable emissions of\r\n    @return uint256 number of claimable tokens per user\r\n    \"\"\"\r\n    self._user_checkpoint(_user)\r\n    return self.integrate_fraction[_user] - Minter(MINTER).minted(_user, self)\r\n\r\n\r\n@external\r\ndef set_killed(_is_killed: bool):\r\n    \"\"\"\r\n    @notice Set the gauge status\r\n    @dev Inflation params are modified accordingly to disable/enable emissions\r\n    \"\"\"\r\n    assert msg.sender == ADMIN\r\n\r\n    if _is_killed:\r\n        self._is_killed = True\r\n        self.inflation_params = 0\r\n    else:\r\n        self._is_killed = False\r\n        self.inflation_params = shift(CRV20(CRV).rate(), 40) + CRV20(CRV).future_epoch_time_write()\r\n\r\n\r\n@view\r\n@external\r\ndef is_killed() -> bool:\r\n    \"\"\"\r\n    @notice Get whether this gauge is killed and not receiving anymore emissions\r\n    @dev This will return True if the max emissions has been reached or if set to killed by\r\n        the ADMIN.\r\n    \"\"\"\r\n    return self.integrate_fraction[self.receiver] == self.max_emissions or self._is_killed\r\n\r\n\r\n@view\r\n@external\r\ndef inflation_rate() -> uint256:\r\n    \"\"\"\r\n    @notice Get the locally stored inflation rate\r\n    \"\"\"\r\n    return shift(self.inflation_params, -40)\r\n\r\n\r\n@view\r\n@external\r\ndef future_epoch_time() -> uint256:\r\n    \"\"\"\r\n    @notice Get the locally stored timestamp of the inflation rate epoch end\r\n    \"\"\"\r\n    return bitwise_and(self.inflation_params, 2 ** 40 - 1)\r\n\r\n\r\n@pure\r\n@external\r\ndef admin() -> address:\r\n    \"\"\"\r\n    @notice Get the address of the admin which can kill this gauge\r\n    \"\"\"\r\n    return ADMIN\r\n\r\n\r\n@external\r\ndef initialize(_receiver: address, _max_emissions: uint256):\r\n    \"\"\"\r\n    @notice Proxy initializer method\r\n    @dev Placed last in the source file to save some gas, this fn is called only once.\r\n        Additional checks should be made by the DAO before voting in this gauge, specifically\r\n        to make sure that `_fund_recipient` is capable of collecting emissions.\r\n    @param _receiver The address which will receive CRV emissions\r\n    @param _max_emissions The maximum amount of emissions which `_receiver` will\r\n        receive\r\n    \"\"\"\r\n    assert self.last_checkpoint == 0  # dev: already initialized\r\n\r\n    self.receiver = _receiver\r\n    self.max_emissions = _max_emissions\r\n\r\n    self.last_checkpoint = block.timestamp\r\n    future_epoch_time: uint256 = CRV20(CRV).future_epoch_time_write()\r\n    self.inflation_params = shift(CRV20(CRV).rate(), 40) + future_epoch_time", "ABI": "[{\"name\":\"Checkpoint\",\"inputs\":[{\"name\":\"_timestamp\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"_new_emissions\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"user_checkpoint\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claimable_tokens_write\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_killed\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"inflation_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_epoch_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"pure\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_max_emissions\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"integrate_fraction\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_checkpoint\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"max_emissions\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Fundraising Gauge Fx", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000026b2ec4e02ebe2f54583af25b647b1d619e67bbf", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}