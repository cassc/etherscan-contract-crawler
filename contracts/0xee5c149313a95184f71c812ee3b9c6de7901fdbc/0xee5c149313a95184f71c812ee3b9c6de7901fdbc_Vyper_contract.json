{"SourceCode": "# @version 0.3.9\r\n\r\n# Interfaces\r\n\r\ninterface ISelf:\r\n    def tokenid_to_vault(token_id: uint256) -> address: view\r\n    def is_vault_available(token_id: uint256) -> bool: view\r\n\r\n\r\ninterface IVault:\r\n    def is_initialised() -> bool: view\r\n    def initialise(owner: address, payment_token_addr: address, nft_contract_addr: address, delegation_registry_addr: address): nonpayable\r\n    def deposit(token_id: uint256, price: uint256, min_duration: uint256, max_duration: uint256): nonpayable\r\n    def set_listing(sender: address, price: uint256, min_duration: uint256, max_duration: uint256): nonpayable\r\n    def set_listing_and_delegate_to_owner(sender: address, price: uint256, min_duration: uint256, max_duration: uint256): nonpayable\r\n    def start_rental(renter: address, expiration: uint256) -> Rental: nonpayable\r\n    def close_rental(sender: address) -> (Rental, uint256): nonpayable\r\n    def claim(sender: address) -> uint256: nonpayable\r\n    def withdraw(sender: address) -> uint256: nonpayable\r\n    def delegate_to_owner(sender: address): nonpayable\r\n    def owner() -> address: view\r\n\r\n\r\n# Structs\r\n\r\nstruct Rental:\r\n    id: bytes32 # keccak256 of the renter, token_id, start and expiration\r\n    owner: address\r\n    renter: address\r\n    token_id: uint256\r\n    start: uint256\r\n    min_expiration: uint256\r\n    expiration: uint256\r\n    amount: uint256\r\n\r\nstruct VaultLog:\r\n    vault: address\r\n    token_id: uint256\r\n\r\nstruct RentalLog:\r\n    id: bytes32\r\n    vault: address\r\n    owner: address\r\n    token_id: uint256\r\n    start: uint256\r\n    min_expiration: uint256\r\n    expiration: uint256\r\n    amount: uint256\r\n\r\nstruct RewardLog:\r\n    vault: address\r\n    token_id: uint256\r\n    amount: uint256\r\n\r\nstruct WithdrawalLog:\r\n    vault: address\r\n    token_id: uint256\r\n    rewards: uint256\r\n\r\n\r\n# Events\r\n\r\nevent VaultsCreated:\r\n    owner: address\r\n    nft_contract: address\r\n    min_duration: uint256\r\n    max_duration: uint256\r\n    price: uint256\r\n    vaults: DynArray[VaultLog, 32]\r\n\r\nevent NftsDeposited:\r\n    owner: address\r\n    nft_contract: address\r\n    min_duration: uint256\r\n    max_duration: uint256\r\n    price: uint256\r\n    vaults: DynArray[VaultLog, 32]\r\n\r\nevent NftsWithdrawn:\r\n    owner: address\r\n    nft_contract: address\r\n    total_rewards: uint256\r\n    withdrawals: DynArray[WithdrawalLog, 32]\r\n\r\nevent ListingsChanged:\r\n    owner: address\r\n    nft_contract: address\r\n    min_duration: uint256\r\n    max_duration: uint256\r\n    price: uint256\r\n    vaults: DynArray[VaultLog, 32]\r\n\r\nevent ListingsCancelled:\r\n    owner: address\r\n    nft_contract: address\r\n    vaults: DynArray[VaultLog, 32]\r\n\r\nevent RentalStarted:\r\n    renter: address\r\n    nft_contract: address\r\n    rentals: DynArray[RentalLog, 32]\r\n\r\nevent RentalClosed:\r\n    renter: address\r\n    nft_contract: address\r\n    rentals: DynArray[RentalLog, 32]\r\n\r\nevent RewardsClaimed:\r\n    owner: address\r\n    nft_contract: address\r\n    rewards: DynArray[RewardLog, 32]\r\n\r\n\r\n# Global Variables\r\n\r\n_COLLISION_OFFSET: constant(bytes1) = 0xFF\r\n_DEPLOYMENT_CODE: constant(bytes9) = 0x602D3D8160093D39F3\r\n_PRE: constant(bytes10) = 0x363d3d373d3d3d363d73\r\n_POST: constant(bytes15) = 0x5af43d82803e903d91602b57fd5bf3\r\n\r\nvault_impl_addr: public(immutable(address))\r\npayment_token_addr: public(immutable(address))\r\nnft_contract_addr: public(immutable(address))\r\ndelegation_registry_addr: public(immutable(address))\r\n\r\nactive_vaults: public(HashMap[uint256, address]) # token_id -> vault\r\n\r\n\r\n##### EXTERNAL METHODS - WRITE #####\r\n\r\n@external\r\ndef __init__(\r\n    _vault_impl_addr: address,\r\n    _payment_token_addr: address,\r\n    _nft_contract_addr: address,\r\n    _delegation_registry_addr: address\r\n):\r\n    vault_impl_addr = _vault_impl_addr\r\n    payment_token_addr = _payment_token_addr\r\n    nft_contract_addr = _nft_contract_addr\r\n    delegation_registry_addr = _delegation_registry_addr\r\n\r\n\r\n@external\r\ndef create_vaults_and_deposit(token_ids: DynArray[uint256, 32], price: uint256, min_duration: uint256, max_duration: uint256):\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self._create_vault_and_deposit(token_id, price, min_duration, max_duration)\r\n        vault_logs.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_id\r\n        }))\r\n\r\n    log VaultsCreated(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        min_duration,\r\n        max_duration,\r\n        price,\r\n        vault_logs\r\n    )\r\n\r\n\r\n@external\r\ndef deposit(token_ids: DynArray[uint256, 32], price: uint256, min_duration: uint256, max_duration: uint256):\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self._deposit_nft(token_id, price, min_duration, max_duration)\r\n        vault_logs.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_id\r\n        }))\r\n\r\n    log NftsDeposited(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        min_duration,\r\n        max_duration,\r\n        price,\r\n        vault_logs\r\n    )\r\n\r\n\r\n@external\r\ndef set_listings(token_ids: DynArray[uint256, 32], price: uint256, min_duration: uint256, max_duration: uint256):\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self.active_vaults[token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        IVault(vault).set_listing(msg.sender, price, min_duration, max_duration)\r\n\r\n        vault_logs.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_id\r\n        }))\r\n\r\n    log ListingsChanged(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        min_duration,\r\n        max_duration,\r\n        price,\r\n        vault_logs\r\n    )\r\n\r\n\r\n@external\r\ndef set_listings_and_delegate_to_owner(token_ids: DynArray[uint256, 32], price: uint256, min_duration: uint256, max_duration: uint256):\r\n    vault_logs: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self.active_vaults[token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        IVault(vault).set_listing_and_delegate_to_owner(msg.sender, price, min_duration, max_duration)\r\n\r\n        vault_logs.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_id\r\n        }))\r\n\r\n    log ListingsChanged(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        min_duration,\r\n        max_duration,\r\n        price,\r\n        vault_logs\r\n    )\r\n\r\n@external\r\ndef cancel_listings(token_ids: DynArray[uint256, 32]):\r\n    vaults: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self.active_vaults[token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        IVault(vault).set_listing(msg.sender, 0, 0, 0)\r\n\r\n        vaults.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_id\r\n        }))\r\n\r\n    log ListingsCancelled(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        vaults\r\n    )\r\n\r\n\r\n@external\r\ndef cancel_listings_and_delegate_to_owner(token_ids: DynArray[uint256, 32]):\r\n    vaults: DynArray[VaultLog, 32] = empty(DynArray[VaultLog, 32])\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self.active_vaults[token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        IVault(vault).set_listing_and_delegate_to_owner(msg.sender, 0, 0, 0)\r\n\r\n        vaults.append(VaultLog({\r\n            vault: vault,\r\n            token_id: token_id\r\n        }))\r\n\r\n    log ListingsCancelled(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        vaults\r\n    )\r\n\r\n\r\n@external\r\ndef start_rentals(token_ids: DynArray[uint256, 32], duration: uint256):\r\n    rental_logs: DynArray[RentalLog, 32] = []\r\n\r\n    expiration: uint256 = block.timestamp + duration * 3600\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self.active_vaults[token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        rental: Rental = IVault(vault).start_rental(msg.sender, expiration)\r\n\r\n        rental_logs.append(RentalLog({\r\n            id: rental.id,\r\n            vault: vault,\r\n            owner: rental.owner,\r\n            token_id: token_id,\r\n            start: rental.start,\r\n            min_expiration: rental.min_expiration,\r\n            expiration: expiration,\r\n            amount: rental.amount\r\n        }))\r\n\r\n    log RentalStarted(msg.sender, nft_contract_addr, rental_logs)\r\n\r\n\r\n@external\r\ndef close_rentals(token_ids: DynArray[uint256, 32]):\r\n\r\n    amount: uint256 = 0\r\n    rental: Rental = empty(Rental)\r\n    rental_logs: DynArray[RentalLog, 32] = []\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self.active_vaults[token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        rental, amount = IVault(vault).close_rental(msg.sender)\r\n\r\n        rental_logs.append(RentalLog({\r\n            id: rental.id,\r\n            vault: vault,\r\n            owner: rental.owner,\r\n            token_id: token_id,\r\n            start: rental.start,\r\n            min_expiration: rental.min_expiration,\r\n            expiration: block.timestamp,\r\n            amount: amount\r\n        }))\r\n\r\n    log RentalClosed(msg.sender, nft_contract_addr, rental_logs)\r\n\r\n\r\n@external\r\ndef claim(token_ids: DynArray[uint256, 32]):\r\n    reward_logs: DynArray[RewardLog, 32] = []\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self.active_vaults[token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        rewards: uint256 = IVault(vault).claim(msg.sender)\r\n\r\n        reward_logs.append(RewardLog({\r\n            vault: vault,\r\n            token_id: token_id,\r\n            amount: rewards\r\n        }))\r\n\r\n    log RewardsClaimed(msg.sender, nft_contract_addr, reward_logs)\r\n\r\n\r\n@external\r\ndef withdraw(token_ids: DynArray[uint256, 32]):\r\n    withdrawal_log: DynArray[WithdrawalLog, 32] = empty(DynArray[WithdrawalLog, 32])\r\n    total_rewards: uint256 = 0\r\n\r\n    for token_id in token_ids:\r\n        vault: address = self.active_vaults[token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        self.active_vaults[token_id] = empty(address)\r\n\r\n        rewards: uint256 = IVault(vault).withdraw(msg.sender)\r\n\r\n        withdrawal_log.append(WithdrawalLog({\r\n            vault: vault,\r\n            token_id: token_id,\r\n            rewards: rewards\r\n        }))\r\n        total_rewards += rewards\r\n\r\n    log NftsWithdrawn(\r\n        msg.sender,\r\n        nft_contract_addr,\r\n        total_rewards,\r\n        withdrawal_log\r\n    )\r\n\r\n@external\r\ndef delegate_to_owner(token_ids: DynArray[uint256, 32]):\r\n    for token_id in token_ids:\r\n        vault: address = self.active_vaults[token_id]\r\n        assert vault != empty(address), \"no vault exists for token_id\"\r\n\r\n        IVault(vault).delegate_to_owner(msg.sender)\r\n\r\n\r\n\r\n##### INTERNAL METHODS #####\r\n\r\n@pure\r\n@internal\r\ndef _compute_address(salt: bytes32, bytecode_hash: bytes32, deployer: address) -> address:\r\n    \"\"\"\r\n    @dev An `internal` helper function that returns the address\r\n         where a contract will be stored if deployed via `deployer`\r\n         using the `CREATE2` opcode. Any change in the `bytecode_hash`\r\n         or `salt` values will result in a new destination address.\r\n    @param salt The 32-byte random value used to create the contract\r\n           address.\r\n    @param bytecode_hash The 32-byte bytecode digest of the contract\r\n           creation bytecode.\r\n    @param deployer The 20-byte deployer address.\r\n    @return address The 20-byte address where a contract will be stored.\r\n    \"\"\"\r\n    data: bytes32 = keccak256(concat(_COLLISION_OFFSET, convert(deployer, bytes20), salt, bytecode_hash))\r\n    return self._convert_keccak256_2_address(data)\r\n\r\n\r\n@pure\r\n@internal\r\ndef _convert_keccak256_2_address(digest: bytes32) -> address:\r\n    \"\"\"\r\n    @dev Converts a 32-byte keccak256 digest to an address.\r\n    @param digest The 32-byte keccak256 digest.\r\n    @return address The converted 20-byte address.\r\n    \"\"\"\r\n    return convert(convert(digest, uint256) & convert(max_value(uint160), uint256), address)\r\n\r\n\r\n@internal\r\ndef _create_vault_and_deposit(token_id: uint256, price: uint256, min_duration: uint256, max_duration: uint256) -> address:\r\n    assert self.active_vaults[token_id] == empty(address), \"vault exists for token_id\"\r\n\r\n    vault: address = create_minimal_proxy_to(vault_impl_addr, salt=convert(token_id, bytes32))\r\n\r\n    self.active_vaults[token_id] = vault\r\n\r\n    IVault(vault).initialise(\r\n        msg.sender,\r\n        payment_token_addr,\r\n        nft_contract_addr,\r\n        delegation_registry_addr\r\n    )\r\n    IVault(vault).deposit(token_id, price, min_duration, max_duration)\r\n\r\n    return vault\r\n\r\n\r\n@internal\r\ndef _deposit_nft(token_id: uint256, price: uint256, min_duration: uint256, max_duration: uint256) -> address:\r\n    assert ISelf(self).is_vault_available(token_id), \"vault is not available\"\r\n\r\n    vault: address = ISelf(self).tokenid_to_vault(token_id)\r\n    self.active_vaults[token_id] = vault\r\n\r\n    IVault(vault).initialise(\r\n        msg.sender,\r\n        payment_token_addr,\r\n        nft_contract_addr,\r\n        delegation_registry_addr\r\n    )\r\n\r\n    IVault(vault).deposit(token_id, price, min_duration, max_duration)\r\n\r\n    return vault\r\n\r\n\r\n##### EXTERNAL METHODS - VIEW #####\r\n\r\n@view\r\n@external\r\ndef is_vault_available(token_id: uint256) -> bool:\r\n    vault: address = ISelf(self).tokenid_to_vault(token_id)\r\n    return self.active_vaults[token_id] == empty(address) and vault.is_contract and not IVault(vault).is_initialised()\r\n\r\n\r\n@view\r\n@external\r\ndef tokenid_to_vault(token_id: uint256) -> address:\r\n    return self._compute_address(\r\n        convert(token_id, bytes32),\r\n        keccak256(concat(\r\n            _DEPLOYMENT_CODE,\r\n            _PRE,\r\n            convert(vault_impl_addr, bytes20),\r\n            _POST\r\n        )),\r\n        self\r\n    )\r\n\r\n\r\n@view\r\n@external\r\ndef get_nft_contract() -> address:\r\n    return nft_contract_addr\r\n\r\n\r\n@view\r\n@external\r\ndef get_payment_token() -> address:\r\n    return payment_token_addr\r\n\r\n\r\n@view\r\n@external\r\ndef get_delegation_registry() -> address:\r\n    return delegation_registry_addr", "ABI": "[{\"name\":\"VaultsCreated\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"min_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"max_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"price\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NftsDeposited\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"min_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"max_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"price\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NftsWithdrawn\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"total_rewards\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"withdrawals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"rewards\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ListingsChanged\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"min_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"max_duration\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"price\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ListingsCancelled\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"vaults\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RentalStarted\",\"inputs\":[{\"name\":\"renter\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rentals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RentalClosed\",\"inputs\":[{\"name\":\"renter\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rentals\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"min_expiration\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RewardsClaimed\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":false},{\"name\":\"nft_contract\",\"type\":\"address\",\"indexed\":false},{\"name\":\"rewards\",\"type\":\"tuple[]\",\"components\":[{\"name\":\"vault\",\"type\":\"address\"},{\"name\":\"token_id\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_vault_impl_addr\",\"type\":\"address\"},{\"name\":\"_payment_token_addr\",\"type\":\"address\"},{\"name\":\"_nft_contract_addr\",\"type\":\"address\"},{\"name\":\"_delegation_registry_addr\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"create_vaults_and_deposit\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_listings\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_listings_and_delegate_to_owner\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_duration\",\"type\":\"uint256\"},{\"name\":\"max_duration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel_listings\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel_listings_and_delegate_to_owner\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"start_rentals\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"},{\"name\":\"duration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"close_rentals\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"delegate_to_owner\",\"inputs\":[{\"name\":\"token_ids\",\"type\":\"uint256[]\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_vault_available\",\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"tokenid_to_vault\",\"inputs\":[{\"name\":\"token_id\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_nft_contract\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_payment_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_delegation_registry\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"vault_impl_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"payment_token_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nft_contract_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delegation_registry_addr\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"active_vaults\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.9", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000cb1bd8f8ae14beb58e647d0641bba816dba446e70000000000000000000000004d224452801aced8b2f0aebe155379bb5d594381000000000000000000000000e012baf811cf9c05c408e879c399960d1f305903000000000000000000000000c3aa9bc72bd623168860a1e5c6a4530d3d80456c", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}