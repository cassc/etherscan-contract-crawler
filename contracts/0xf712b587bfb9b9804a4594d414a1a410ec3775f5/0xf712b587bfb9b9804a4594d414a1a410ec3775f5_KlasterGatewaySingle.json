{"SourceCode": "// Sources flattened with hardhat v2.17.2 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol@v0.7.6\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// End consumer library.\r\nlibrary Client {\r\n  struct EVMTokenAmount {\r\n    address token; // token address on the local chain.\r\n    uint256 amount; // Amount of tokens.\r\n  }\r\n\r\n  struct Any2EVMMessage {\r\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\r\n    uint64 sourceChainSelector; // Source chain selector.\r\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\r\n    bytes data; // payload sent in original message.\r\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\r\n  }\r\n\r\n  // If extraArgs is empty bytes, the default is 200k gas limit and strict = false.\r\n  struct EVM2AnyMessage {\r\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\r\n    bytes data; // Data payload\r\n    EVMTokenAmount[] tokenAmounts; // Token transfers\r\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\r\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\r\n  }\r\n\r\n  // extraArgs will evolve to support new features\r\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\r\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\r\n  struct EVMExtraArgsV1 {\r\n    uint256 gasLimit; // ATTENTION!!! MAX GAS LIMIT 4M FOR BETA TESTING\r\n    bool strict; // See strict sequencing details below.\r\n  }\r\n\r\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\r\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol@v0.7.6\r\n\r\n/// @notice Application contracts that intend to receive messages from\r\n/// the router should implement this interface.\r\ninterface IAny2EVMMessageReceiver {\r\n  /// @notice Called by the Router to deliver a message.\r\n  /// If this reverts, any token transfers also revert. The message\r\n  /// will move to a FAILED state and become available for manual execution.\r\n  /// @param message CCIP Message\r\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\r\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.0/utils/introspection/IERC165.sol@v0.7.6\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n  /**\r\n    * @dev Returns true if this contract implements the interface defined by\r\n    * `interfaceId`. See the corresponding\r\n    * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n    * to learn more about how these ids are created.\r\n    *\r\n    * This function call must use less than 30 000 gas.\r\n    */\r\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol@v0.7.6\r\n\r\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\r\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\r\n  address internal immutable i_router;\r\n\r\n  constructor(address router) {\r\n    if (router == address(0)) revert InvalidRouter(address(0));\r\n    i_router = router;\r\n  }\r\n\r\n  /// @notice IERC165 supports an interfaceId\r\n  /// @param interfaceId The interfaceId to check\r\n  /// @return true if the interfaceId is supported\r\n  function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\r\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\r\n  }\r\n\r\n  /// @inheritdoc IAny2EVMMessageReceiver\r\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\r\n    _ccipReceive(message);\r\n  }\r\n\r\n  /// @notice Override this function in your implementation.\r\n  /// @param message Any2EVMMessage\r\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\r\n\r\n  /////////////////////////////////////////////////////////////////////\r\n  // Plumbing\r\n  /////////////////////////////////////////////////////////////////////\r\n\r\n  /// @notice Return the current router\r\n  /// @return i_router address\r\n  function getRouter() public view returns (address) {\r\n    return address(i_router);\r\n  }\r\n\r\n  error InvalidRouter(address router);\r\n\r\n  /// @dev only calls from the set router are accepted.\r\n  modifier onlyRouter() {\r\n    if (msg.sender != address(i_router)) revert InvalidRouter(msg.sender);\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol@v0.7.6\r\n\r\ninterface IRouterClient {\r\n  error UnsupportedDestinationChain(uint64 destChainSelector);\r\n  error InsufficientFeeTokenAmount();\r\n  error InvalidMsgValue();\r\n\r\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\r\n  /// @param chainSelector The chain to check.\r\n  /// @return supported is true if it is supported, false if not.\r\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\r\n\r\n  /// @notice Gets a list of all supported tokens which can be sent or received\r\n  /// to/from a given chain id.\r\n  /// @param chainSelector The chainSelector.\r\n  /// @return tokens The addresses of all tokens that are supported.\r\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\r\n\r\n  /// @param destinationChainSelector The destination chainSelector\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return fee returns guaranteed execution fee for the specified message\r\n  /// delivery to destination chain\r\n  /// @dev returns 0 fee on invalid message.\r\n  function getFee(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage memory message\r\n  ) external view returns (uint256 fee);\r\n\r\n  /// @notice Request a message to be sent to the destination chain\r\n  /// @param destinationChainSelector The destination chain ID\r\n  /// @param message The cross-chain CCIP message including data and/or tokens\r\n  /// @return messageId The message ID\r\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\r\n  /// the overpayment with no refund.\r\n  function ccipSend(\r\n    uint64 destinationChainSelector,\r\n    Client.EVM2AnyMessage calldata message\r\n  ) external payable returns (bytes32);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.9.3\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.9.3\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interface/IERC1271.sol\r\n\r\ninterface IERC1271 {\r\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n  // bytes4 constant internal MAGICVALUE = 0x1626ba7e;\r\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view returns (bytes4 magicValue);\r\n}\r\n\r\n\r\n// File contracts/interface/IKlasterGatewayWallet.sol\r\n\r\ninterface IKlasterGatewayWallet {\r\n\r\n    function execute(\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) external returns (bool, address);\r\n\r\n    function executeWithData(\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes32 extraData\r\n    ) external returns (bool, address);\r\n\r\n}\r\n\r\n\r\n// File contracts/gateway/KlasterGatewayWallet.sol\r\n\r\ncontract KlasterGatewayWallet is Ownable, IERC1271, IKlasterGatewayWallet {\r\n\r\n    address public klasterGatewaySingleton;\r\n\r\n    mapping (bytes32 => bool) public signatures;\r\n\r\n    constructor(address _owner) {\r\n        klasterGatewaySingleton = msg.sender;\r\n        _transferOwnership(_owner);\r\n    }\r\n\r\n    function executeWithData(\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes32 extraData\r\n    ) external returns (bool, address) {\r\n        if (destination == address(0)) { // contract deployment\r\n            if (extraData == \"\") { // deploy using create()\r\n                return (true, _performCreate(value, data));\r\n            } else { // deploy using create2()\r\n                return (true, _performCreate2(value, data, extraData));\r\n            }\r\n        } else { // transaction execution (use extra data as contract wallet signature as per ERC-1271)\r\n            if (extraData != \"\") { signatures[extraData] = true; }\r\n            return execute(destination, value, data);\r\n        }\r\n    }\r\n\r\n    function execute(\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data\r\n    ) public returns (bool, address) {\r\n        require(\r\n            msg.sender == klasterGatewaySingleton || msg.sender == owner(),\r\n            \"Not an owner!\"\r\n        );\r\n        bool result;\r\n        uint dataLength = data.length;\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas(), 34710),   // 34710 is the value that solidity is currently emitting\r\n                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +\r\n                                   // callNewAccountGas (25000, in case the destination address does not exist and needs creating)\r\n                destination,\r\n                value,\r\n                d,\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                x,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return (result, address(0));\r\n    }\r\n\r\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view returns (bytes4 magicValue) {\r\n        if (signatures[_hash]) {\r\n            magicValue = 0x1626ba7e; // ERC1271: valid signature = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n        }\r\n    }\r\n\r\n    function _performCreate(\r\n        uint256 value,\r\n        bytes memory deploymentData\r\n    ) internal returns (address newContract) {\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            newContract := create(value, add(deploymentData, 0x20), mload(deploymentData))\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        require(newContract != address(0), \"Could not deploy contract\");\r\n    }\r\n\r\n    function _performCreate2(\r\n        uint256 value,\r\n        bytes memory deploymentData,\r\n        bytes32 salt\r\n    ) internal returns (address newContract) {\r\n        /* solhint-disable no-inline-assembly */\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            newContract := create2(value, add(0x20, deploymentData), mload(deploymentData), salt)\r\n        }\r\n        /* solhint-enable no-inline-assembly */\r\n        require(newContract != address(0), \"Could not deploy contract\");\r\n    }\r\n\r\n    /// @notice Fallback function to allow the contract to receive Ether.\r\n    /// @dev This function has no function body, making it a default function for receiving Ether.\r\n    /// It is automatically called when Ether is sent to the contract without any data.\r\n    receive() external payable {}\r\n\r\n}\r\n\r\n\r\n// File contracts/interface/IKlasterGatewaySingleton.sol\r\n\r\ninterface IKlasterGatewaySingleton {\r\n\r\n    /************************** EVENTS **************************/\r\n\r\n    // Event emitted when a new gateway wallet instance has been deployed.\r\n    event WalletDeploy(\r\n        address indexed owner,\r\n        address gatewayWallet\r\n    );\r\n    \r\n    // Event emitted when a message is sent to another chain.\r\n    event SendRTC(\r\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\r\n        address indexed caller, // Wallet initiating the RTC\r\n        uint64 destinationChainSelector, // The chain selector of the destination chain.\r\n        uint64 execChainSelector, // The chain selector of the execution chain.\r\n        address targetContract, // Remote contract to execute on dest chain\r\n        bytes32 extraData, // Message hash used for ERC-1271 or salt used for create2\r\n        address feeToken, // the token address used to pay CCIP fees.\r\n        uint256 ccipfees, // The fees paid for sending the CCIP message.\r\n        uint256 totalFees // Total fees (ccip + platform fee)\r\n    );\r\n\r\n    // Event emitted when a message is received from another chain.\r\n    event ReceiveRTC(\r\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\r\n        uint64 indexed sourceChainSelector, // The chain selector of the destination chain.\r\n        address caller, // Wallet initiating the RTC.\r\n        address targetContract, // Remote contract to execute on dest chain,\r\n        bytes32 extraData // Message hash used for ERC-1271 or salt used for create2\r\n    );\r\n\r\n    // Event emitted when any gateway wallet action gets executed\r\n    event Execute(\r\n        address indexed caller,\r\n        address indexed gatewayWallet,\r\n        address indexed destination,\r\n        bool status,\r\n        address contractDeployed,\r\n        bytes32 extraData\r\n    );\r\n\r\n    /************************** WRITE **************************/\r\n\r\n    function deploy(string memory salt) external returns (address);\r\n\r\n    function batchExecute(\r\n        uint64[][] memory execChainSelectors,\r\n        string[] memory salt,\r\n        address[] memory destination,\r\n        uint256[] memory value,\r\n        bytes[] memory data,\r\n        uint256[] memory gasLimit,\r\n        bytes32[] memory extraData\r\n    ) external payable returns (bool[] memory, address[] memory, bytes32[] memory);\r\n\r\n    function execute(\r\n        uint64[] memory execChainSelectors,\r\n        string memory salt,\r\n        address destination,\r\n        uint value,\r\n        bytes memory data,\r\n        uint256 gasLimit,\r\n        bytes32 extraData\r\n    ) external payable returns (bool, address, bytes32);\r\n\r\n    /************************** READ **************************/\r\n\r\n    function getDeployedWallets(address owner) external view returns (address[] memory);\r\n    \r\n    function calculateBatchExecuteFee(\r\n        address caller,\r\n        uint64[][] memory execChainSelectors,\r\n        string[] memory salt,\r\n        address[] memory destination,\r\n        uint256[] memory value,\r\n        bytes[] memory data,\r\n        uint256[] memory gasLimit,\r\n        bytes32[] memory extraData\r\n    ) external view returns (uint256);\r\n\r\n    function calculateExecuteFee(\r\n        address caller,\r\n        uint64[] memory execChainSelectors,\r\n        string memory salt,\r\n        address destination,\r\n        uint value,\r\n        bytes memory data,\r\n        uint256 gasLimit,\r\n        bytes32 extraData\r\n    ) external view returns (uint256);\r\n\r\n    function calculateAddress(address owner, string memory salt) external view returns (address);\r\n\r\n    function calculateCreate2Address(\r\n        address owner,\r\n        string memory salt,\r\n        bytes memory byteCode,\r\n        bytes32 create2Salt\r\n    ) external view returns (address);\r\n\r\n}\r\n\r\n\r\n// File contracts/interface/IOwnable.sol\r\n\r\ninterface IOwnable {\r\n    function owner() external view returns (address);\r\n}\r\n\r\n\r\n// File contracts/gateway/KlasterGatewaySingleton.sol\r\n\r\ncontract KlasterGatewaySingleton is IKlasterGatewaySingleton, CCIPReceiver, Ownable {\r\n\r\n    uint256 public feePercentage; // percentage fee on top of the ccip fees (modifiable by the owner)\r\n    uint64 public thisChainSelector; // current chain selector\r\n    uint64 public relayerChainSelector; // relayer chain selector (sepolia for testnet, eth for mainnet)\r\n    \r\n    mapping (address => bool) public deployed;\r\n    mapping (address => string) public salts; // gateway wallet => salt\r\n    mapping (address => address[]) public instances; // user => gateway wallet[]\r\n\r\n    constructor(\r\n        address _sourceRouter,\r\n        uint64 _thisChainSelector,\r\n        uint64 _relayerChainSelector,\r\n        address _owner,\r\n        uint256 _feePercentage\r\n    ) CCIPReceiver(_sourceRouter) {\r\n        thisChainSelector = _thisChainSelector;\r\n        relayerChainSelector = _relayerChainSelector;\r\n        feePercentage = _feePercentage;\r\n        _transferOwnership(_owner);\r\n    }\r\n\r\n    function deploy(string memory salt) public override returns (address) {\r\n       return _deploy(msg.sender, salt);\r\n    }\r\n\r\n    /***\r\n     * OWNER FUNCTIONS (SENSITIVE)\r\n     * \r\n     * Append only. Cant break anything or shut down the service.\r\n     * KlasterGatewayWallet wallets will always work and in that sense it's permissionless.\r\n     * The only two things an owner can affect and change post deployment are:\r\n     *     1) Update platform fee - CAPPED TO 100% of the CCIP fee (!)\r\n     *     2) Withdraw platform fee earnings\r\n     */\r\n    function updateFee(uint256 _feePercentage) external onlyOwner {\r\n        require(_feePercentage <= 100, \"platform fee is capped to 100% of the CCIP fee\");\r\n        feePercentage = _feePercentage;\r\n    }\r\n\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n\r\n    /************ PUBLIC WRITE FUNCTIONS ************/\r\n\r\n    function batchExecute(\r\n        uint64[][] memory execChainSelectors,\r\n        string[] memory salt,\r\n        address[] memory destination,\r\n        uint256[] memory value,\r\n        bytes[] memory data,\r\n        uint256[] memory gasLimit,\r\n        bytes32[] memory extraData\r\n    ) external payable override returns (bool[] memory success, address[] memory contractDeployed, bytes32[] memory messageId) {\r\n        success = new bool[](execChainSelectors.length);\r\n        contractDeployed = new address[](execChainSelectors.length);\r\n        messageId = new bytes32[](execChainSelectors.length);\r\n        for (uint256 i = 0; i < execChainSelectors.length; i++) {\r\n            (success[i], contractDeployed[i], messageId[i]) = execute(\r\n                execChainSelectors[i],\r\n                salt[i],\r\n                destination[i],\r\n                value[i],\r\n                data[i],\r\n                gasLimit[i],\r\n                extraData[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function execute(\r\n        uint64[] memory execChainSelectors,\r\n        string memory salt,\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 gasLimit,\r\n        bytes32 extraData\r\n    ) public payable override returns (bool success, address contractDeployed, bytes32 messageId) {\r\n        \r\n        if (destination != address(0) && extraData != \"\") { // if executing contract call (destination != 0) and extra data exists, then verify if the extra data is a valid signature\r\n            require(\r\n                IERC1271(msg.sender).isValidSignature(\r\n                    extraData,\r\n                    \"\"\r\n                ) == 0x1626ba7e, // ERC1271: valid signature = bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\r\n                \"Invalid signature.\"\r\n            );\r\n        }\r\n\r\n        for (uint256 i = 0; i < execChainSelectors.length; i++) {\r\n            (success, contractDeployed, messageId) = _execute(\r\n                ExecutionData(\r\n                    msg.sender,\r\n                    execChainSelectors[i],\r\n                    salt,\r\n                    destination,\r\n                    value,\r\n                    data,\r\n                    gasLimit,\r\n                    extraData,\r\n                    true\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /************ PUBLIC READ FUNCTIONS ************/\r\n\r\n    function getDeployedWallets(address owner) external view override returns (address[] memory) {\r\n        return instances[owner];\r\n    }\r\n\r\n    function calculateBatchExecuteFee(\r\n        address caller,\r\n        uint64[][] memory execChainSelectors,\r\n        string[] memory salt,\r\n        address[] memory destination,\r\n        uint256[] memory value,\r\n        bytes[] memory data,\r\n        uint256[] memory gasLimit,\r\n        bytes32[] memory extraData\r\n    ) external view override returns (uint256 totalFee) {\r\n        for (uint256 i = 0; i < execChainSelectors.length; i++) {\r\n            totalFee += calculateExecuteFee(\r\n                caller,\r\n                execChainSelectors[i],\r\n                salt[i],\r\n                destination[i],\r\n                value[i],\r\n                data[i],\r\n                gasLimit[i],\r\n                extraData[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function calculateExecuteFee(\r\n        address caller,\r\n        uint64[] memory execChainSelectors,\r\n        string memory salt,\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 gasLimit,\r\n        bytes32 extraData\r\n    ) public view override returns (uint256 totalFee) {\r\n        for (uint256 i = 0; i < execChainSelectors.length; i++) {\r\n            uint64 execChainSelector = execChainSelectors[i];\r\n            if (execChainSelector != thisChainSelector) {\r\n                // Get available lane    \r\n                uint64 destChainSelector = _getDestChainSelector(execChainSelector);\r\n        \r\n                // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n                Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\r\n                    address(this),\r\n                    abi.encode(caller, execChainSelector, salt, destination, value, data, gasLimit, extraData),\r\n                    address(0),\r\n                    gasLimit\r\n                );\r\n\r\n                (, uint256 fee) = _getFees(destChainSelector, execChainSelector, evm2AnyMessage);\r\n                totalFee += fee;\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateAddress(address owner, string memory salt) public view override returns (address) {\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0xff), address(this), keccak256(abi.encodePacked(owner, salt)), keccak256(_getBytecode(owner))\r\n            )\r\n        );\r\n        return address(uint160(uint(hash)));\r\n    }\r\n\r\n    function calculateCreate2Address(\r\n        address owner,\r\n        string memory salt,\r\n        bytes memory byteCode,\r\n        bytes32 create2Salt\r\n    ) external view override returns (address) {\r\n        bytes32 hash_ = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0xff),\r\n                calculateAddress(owner, salt),\r\n                create2Salt,\r\n                keccak256(byteCode)\r\n            )\r\n        );\r\n        return address(uint160(uint256(hash_)));\r\n    }\r\n\r\n    /************ INTERNAL FUNCTIONS ************/\r\n    \r\n    struct ExecutionData {\r\n        address caller;\r\n        uint64 execChainSelector;\r\n        string salt;\r\n        address destination;\r\n        uint256 value;\r\n        bytes data;\r\n        uint256 gasLimit;\r\n        bytes32 extraData;\r\n        bool feeEnabled;\r\n    }\r\n    function _execute(\r\n        ExecutionData memory execData\r\n    ) internal returns (bool success, address contractDeployed, bytes32 messageId) {\r\n        if (execData.execChainSelector == thisChainSelector) { // execute on this chain\r\n            (success, contractDeployed) = _executeOnWallet(\r\n                execData.caller,\r\n                execData.salt,\r\n                execData.destination,\r\n                execData.value,\r\n                execData.data,\r\n                execData.extraData\r\n            );\r\n        } else { // remote execution on target chain via CCIP\r\n\r\n            // Get available lane  \r\n            uint64 destChainSelector = _getDestChainSelector(execData.execChainSelector);\r\n\r\n            // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n            Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\r\n                address(this),\r\n                abi.encode(\r\n                    execData.caller,\r\n                    execData.execChainSelector,\r\n                    execData.salt,\r\n                    execData.destination,\r\n                    execData.value,\r\n                    execData.data,\r\n                    execData.gasLimit,\r\n                    execData.extraData\r\n                ),\r\n                address(0),\r\n                execData.gasLimit\r\n            );\r\n\r\n            (uint256 ccipFees, uint256 totalFee) = _getFees(\r\n                destChainSelector,\r\n                execData.execChainSelector,\r\n                evm2AnyMessage\r\n            );\r\n\r\n            // Take into account platform fee\r\n            if (execData.feeEnabled) {\r\n                require(msg.value >= totalFee, \"Ether amount too low. Send more ether to execute call.\");\r\n            }\r\n            \r\n            success = true;\r\n            messageId = IRouterClient(getRouter()).ccipSend{value: ccipFees}(\r\n                destChainSelector,\r\n                evm2AnyMessage\r\n            );\r\n\r\n            emit SendRTC(\r\n                    messageId,\r\n                    execData.caller,\r\n                    destChainSelector,\r\n                    execData.execChainSelector,\r\n                    execData.destination,\r\n                    execData.extraData,\r\n                    address(0),\r\n                    ccipFees,\r\n                    totalFee\r\n            );\r\n        }\r\n    }\r\n\r\n    // executes given action on the callers gateway wallet\r\n    function _executeOnWallet(\r\n        address caller,\r\n        string memory salt,\r\n        address destination,\r\n        uint256 value,\r\n        bytes memory data,\r\n        bytes32 extraData\r\n    ) internal returns (bool status, address contractDeployed) {\r\n        address walletInstanceAddress = calculateAddress(caller, salt);\r\n        if (!deployed[walletInstanceAddress]) { _deploy(caller, salt); }\r\n        \r\n        IKlasterGatewayWallet walletInstance = IKlasterGatewayWallet(walletInstanceAddress);\r\n        \r\n        require(IOwnable(walletInstanceAddress).owner() == caller, \"Not an owner!\");\r\n        (status, contractDeployed) = walletInstance.executeWithData(destination, value, data, extraData);\r\n        \r\n        emit Execute(caller, walletInstanceAddress, destination, status, contractDeployed, extraData);\r\n    }\r\n\r\n    // deploys new gateway wallet for given owner and salt\r\n    function _deploy(address owner, string memory salt) private returns (address walletInstance) {\r\n        require(!deployed[calculateAddress(owner, salt)], \"Already deployed! Use different salt!\");\r\n        \r\n        bytes memory bytecode = _getBytecode(owner);\r\n        bytes32 calculatedSalt = keccak256(abi.encodePacked(owner, salt));\r\n        assembly {\r\n            walletInstance := create2(0, add(bytecode, 32), mload(bytecode), calculatedSalt)\r\n        }\r\n        deployed[walletInstance] = true;\r\n        salts[walletInstance] = salt;\r\n        instances[owner].push(walletInstance);\r\n        \r\n        emit WalletDeploy(owner, walletInstance);\r\n    }\r\n\r\n    // get the bytecode of the contract KlasterGatewayWallet with encoded constructor\r\n    function _getBytecode(address owner) private pure returns (bytes memory) {\r\n        bytes memory bytecode = type(KlasterGatewayWallet).creationCode;\r\n        return abi.encodePacked(bytecode, abi.encode(owner));\r\n    }\r\n\r\n    // @notice Construct a CCIP message.\r\n    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for sending arbitrary bytes cross chain.\r\n    /// @param _receiver The address of the receiver.\r\n    /// @param _message The bytes data to be sent.\r\n    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.\r\n    /// @param _gasLimit Gas limit.\r\n    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.\r\n    function _buildCCIPMessage(\r\n        address _receiver,\r\n        bytes memory _message,\r\n        address _feeTokenAddress,\r\n        uint256 _gasLimit\r\n    ) internal pure returns (Client.EVM2AnyMessage memory) {\r\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\r\n            receiver: abi.encode(_receiver), // ABI-encoded receiver address\r\n            data: _message, // ABI-encoded string\r\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array aas no tokens are transferred\r\n            extraArgs: Client._argsToBytes(\r\n                // Additional arguments, setting gas limit and non-strict sequencing mode\r\n                Client.EVMExtraArgsV1({gasLimit: _gasLimit, strict: false})\r\n            ),\r\n            // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees\r\n            feeToken: _feeTokenAddress\r\n        });\r\n        return evm2AnyMessage;\r\n    }\r\n\r\n    /// handle received execution message\r\n    function _ccipReceive(\r\n        Client.Any2EVMMessage memory any2EvmMessage\r\n    )\r\n        internal\r\n        override\r\n    {\r\n        require(\r\n            abi.decode(any2EvmMessage.sender, (address)) == address(this),\r\n            \"Only official KlasterGatewaySingleton can send CCIP messages.\"\r\n        );\r\n\r\n        (\r\n            address caller,\r\n            uint64 execChainSelector,\r\n            string memory salt,\r\n            address destination,\r\n            uint256 value,\r\n            bytes memory data,\r\n            uint256 gasLimit,\r\n            bytes32 extraData\r\n        ) = abi.decode(\r\n            any2EvmMessage.data,\r\n            (\r\n                address,\r\n                uint64,\r\n                string,\r\n                address,\r\n                uint256,\r\n                bytes,\r\n                uint256,\r\n                bytes32\r\n            )\r\n        );\r\n\r\n        _execute(ExecutionData(caller, execChainSelector, salt, destination, value, data, gasLimit, extraData, false));\r\n\r\n        emit ReceiveRTC(\r\n            any2EvmMessage.messageId,\r\n            any2EvmMessage.sourceChainSelector,\r\n            caller,\r\n            destination,\r\n            extraData\r\n        );\r\n    }\r\n\r\n    function _getFees(\r\n        uint64 destChainSelector,\r\n        uint64 execChainSelector,\r\n        Client.EVM2AnyMessage memory message\r\n    ) internal view returns (uint256 ccipFee, uint256 totalFee) {\r\n        // Multiply fees by 2 if not a direct lane\r\n        uint256 laneMultiplier = (destChainSelector == execChainSelector) ? 1 : 2;\r\n        ccipFee = IRouterClient(getRouter()).getFee(destChainSelector, message);\r\n        totalFee = (ccipFee + (ccipFee * feePercentage / 100)) * laneMultiplier;\r\n    }\r\n\r\n    function _directLaneExists(uint64 execChainSelector) internal view returns (bool) {\r\n        return IRouterClient(getRouter()).isChainSupported(execChainSelector);\r\n    }\r\n    \r\n    function _getDestChainSelector(uint64 execChainSelector) internal view returns (uint64 selector) {\r\n        selector = _directLaneExists(execChainSelector) ? execChainSelector : relayerChainSelector;\r\n    }\r\n\r\n    /// @notice Fallback function to allow the contract to receive Ether.\r\n    /// @dev This function has no function body, making it a default function for receiving Ether.\r\n    /// It is automatically called when Ether is sent to the contract without any data.\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sourceRouter\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_thisChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"_relayerChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gatewayWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractDeployed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"}],\"name\":\"ReceiveRTC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"destinationChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"execChainSelector\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ccipfees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalFees\",\"type\":\"uint256\"}],\"name\":\"SendRTC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gatewayWallet\",\"type\":\"address\"}],\"name\":\"WalletDeploy\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint64[][]\",\"name\":\"execChainSelectors\",\"type\":\"uint64[][]\"},{\"internalType\":\"string[]\",\"name\":\"salt\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"destination\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"gasLimit\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraData\",\"type\":\"bytes32[]\"}],\"name\":\"batchExecute\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"success\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"contractDeployed\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"messageId\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"}],\"name\":\"calculateAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"uint64[][]\",\"name\":\"execChainSelectors\",\"type\":\"uint64[][]\"},{\"internalType\":\"string[]\",\"name\":\"salt\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"destination\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"gasLimit\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"extraData\",\"type\":\"bytes32[]\"}],\"name\":\"calculateBatchExecuteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"byteCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"create2Salt\",\"type\":\"bytes32\"}],\"name\":\"calculateCreate2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"uint64[]\",\"name\":\"execChainSelectors\",\"type\":\"uint64[]\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"}],\"name\":\"calculateExecuteFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"sender\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"destTokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Client.Any2EVMMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"ccipReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deployed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64[]\",\"name\":\"execChainSelectors\",\"type\":\"uint64[]\"},{\"internalType\":\"string\",\"name\":\"salt\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"extraData\",\"type\":\"bytes32\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"contractDeployed\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getDeployedWallets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"instances\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relayerChainSelector\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"salts\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thisChainSelector\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feePercentage\",\"type\":\"uint256\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KlasterGatewaySingleton", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e561d5e02207fb5eb32cca20a699e0d8919a147600000000000000000000000000000000000000000000000045849994fc9c7b1500000000000000000000000000000000000000000000000045849994fc9c7b1500000000000000000000000075bf490088b7b48c55e066d2f3c8ce030d43dcc10000000000000000000000000000000000000000000000000000000000000019", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://aa19282bc812141f92426e5d12ae4044c486eb76c8b0abfd0bacb4fdbc18f02c"}