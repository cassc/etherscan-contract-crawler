{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/Bytes32AddressLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Library for converting between addresses and bytes32 values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\\nlibrary Bytes32AddressLib {\\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\\n        return address(uint160(uint256(bytesValue)));\\n    }\\n\\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\\n        return bytes32(bytes20(addressValue));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/CREATE3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {Bytes32AddressLib} from \\\"./Bytes32AddressLib.sol\\\";\\n\\n/// @notice Deploy to deterministic addresses without an initcode factor.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/CREATE3.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol)\\nlibrary CREATE3 {\\n    using Bytes32AddressLib for bytes32;\\n\\n    //--------------------------------------------------------------------------------//\\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\\n    //--------------------------------------------------------------------------------//\\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 0 size               //\\n    // 0x37       |  0x37                 | CALLDATACOPY     |                        //\\n    // 0x36       |  0x36                 | CALLDATASIZE     | size                   //\\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 size                 //\\n    // 0x34       |  0x34                 | CALLVALUE        | value 0 size           //\\n    // 0xf0       |  0xf0                 | CREATE           | newContract            //\\n    //--------------------------------------------------------------------------------//\\n    // Opcode     | Opcode + Arguments    | Description      | Stack View             //\\n    //--------------------------------------------------------------------------------//\\n    // 0x67       |  0x67XXXXXXXXXXXXXXXX | PUSH8 bytecode   | bytecode               //\\n    // 0x3d       |  0x3d                 | RETURNDATASIZE   | 0 bytecode             //\\n    // 0x52       |  0x52                 | MSTORE           |                        //\\n    // 0x60       |  0x6008               | PUSH1 08         | 8                      //\\n    // 0x60       |  0x6018               | PUSH1 18         | 24 8                   //\\n    // 0xf3       |  0xf3                 | RETURN           |                        //\\n    //--------------------------------------------------------------------------------//\\n    bytes internal constant PROXY_BYTECODE = hex\\\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\\\";\\n\\n    bytes32 internal constant PROXY_BYTECODE_HASH = keccak256(PROXY_BYTECODE);\\n\\n    function deploy(\\n        bytes32 salt,\\n        bytes memory creationCode,\\n        uint256 value\\n    ) internal returns (address deployed) {\\n        bytes memory proxyChildBytecode = PROXY_BYTECODE;\\n\\n        address proxy;\\n        assembly {\\n            // Deploy a new contract with our pre-made bytecode via CREATE2.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), salt)\\n        }\\n        require(proxy != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n\\n        deployed = getDeployed(salt);\\n        (bool success, ) = proxy.call{value: value}(creationCode);\\n        require(success && deployed.code.length != 0, \\\"INITIALIZATION_FAILED\\\");\\n    }\\n\\n    function getDeployed(bytes32 salt) internal view returns (address) {\\n        address proxy = keccak256(\\n            abi.encodePacked(\\n                // Prefix:\\n                bytes1(0xFF),\\n                // Creator:\\n                address(this),\\n                // Salt:\\n                salt,\\n                // Bytecode hash:\\n                PROXY_BYTECODE_HASH\\n            )\\n        ).fromLast20Bytes();\\n\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01)\\n                    // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\\n                    hex\\\"d6_94\\\",\\n                    proxy,\\n                    hex\\\"01\\\" // Nonce of the proxy contract (1)\\n                )\\n            ).fromLast20Bytes();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/timelocks/interface/ITimelockedDelegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\nimport {IERC20} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IDelegatable is IERC20 {\\n  function delegate(address delegatee) external;\\n}\\n\\n/// @title TimelockedDelegator interface\\n/// @author Fei Protocol\\n/// @dev Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/ITimelockedDelegator.sol\\ninterface ITimelockedDelegator {\\n  // ----------- Events -----------\\n\\n  event Delegate(address indexed _delegatee, uint256 _amount);\\n\\n  event Undelegate(address indexed _delegatee, uint256 _amount);\\n\\n  // ----------- Beneficiary only state changing api -----------\\n\\n  function delegate(address delegatee, uint256 amount) external;\\n\\n  function undelegate(address delegatee) external returns (uint256);\\n\\n  // ----------- Getters -----------\\n\\n  function delegateContract(address delegatee) external view returns (address);\\n\\n  function delegateAmount(address delegatee) external view returns (uint256);\\n\\n  function totalDelegated() external view returns (uint256);\\n\\n  function token() external view returns (IDelegatable);\\n}\\n\"\r\n    },\r\n    \"src/timelocks/interface/ITokenTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\nimport {IERC20} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title TokenTimelock interface\\n/// @author Fei Protocol\\n/// @dev Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/ITokenTimelock.sol\\ninterface ITokenTimelock {\\n  // ----------- Events -----------\\n\\n  event Release(address indexed _beneficiary, address indexed _recipient, uint256 _amount);\\n  event BeneficiaryUpdate(address indexed _beneficiary);\\n  event PendingBeneficiaryUpdate(address indexed _pendingBeneficiary);\\n\\n  // ----------- State changing api -----------\\n\\n  function release(address to, uint256 amount) external;\\n\\n  function releaseMax(address to) external;\\n\\n  function setPendingBeneficiary(address _pendingBeneficiary) external;\\n\\n  function acceptBeneficiary() external;\\n\\n  // ----------- Getters -----------\\n\\n  function lockedToken() external view returns (IERC20);\\n\\n  function beneficiary() external view returns (address);\\n\\n  function pendingBeneficiary() external view returns (address);\\n\\n  function initialBalance() external view returns (uint256);\\n\\n  function availableForRelease() external view returns (uint256);\\n\\n  function totalToken() external view returns (uint256);\\n\\n  function alreadyReleasedAmount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/timelocks/LinearTokenTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\nimport \\\"./TokenTimelock.sol\\\";\\n\\n/// Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/LinearTokenTimelock.sol\\n/// @author Fei Protocol\\ncontract LinearTokenTimelock is TokenTimelock {\\n  constructor(\\n    address _beneficiary,\\n    uint256 _duration,\\n    address _lockedToken,\\n    uint256 _cliffDuration,\\n    address _clawbackAdmin,\\n    uint256 _startTime\\n  ) TokenTimelock(_beneficiary, _duration, _cliffDuration, _lockedToken, _clawbackAdmin) {\\n    if (_startTime != 0) {\\n      startTime = _startTime;\\n    }\\n  }\\n\\n  function _proportionAvailable(\\n    uint256 initialBalance,\\n    uint256 elapsed,\\n    uint256 duration\\n  ) internal pure override returns (uint256) {\\n    return (initialBalance * elapsed) / duration;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/timelocks/Timed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\n/// @title an abstract contract for timed events\\n/// @author Fei Protocol\\n/// @dev Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/utils/Timed.sol\\nabstract contract Timed {\\n  /// @notice the start timestamp of the timed period\\n  uint256 public startTime;\\n\\n  /// @notice the duration of the timed period\\n  uint256 public duration;\\n\\n  event DurationUpdate(uint256 oldDuration, uint256 newDuration);\\n\\n  event TimerReset(uint256 startTime);\\n\\n  constructor(uint256 _duration) {\\n    _setDuration(_duration);\\n  }\\n\\n  modifier duringTime() {\\n    require(isTimeStarted(), \\\"Timed: time not started\\\");\\n    require(!isTimeEnded(), \\\"Timed: time ended\\\");\\n    _;\\n  }\\n\\n  modifier afterTime() {\\n    require(isTimeEnded(), \\\"Timed: time not ended\\\");\\n    _;\\n  }\\n\\n  /// @notice return true if time period has ended\\n  function isTimeEnded() public view returns (bool) {\\n    return remainingTime() == 0;\\n  }\\n\\n  /// @notice number of seconds remaining until time is up\\n  /// @return remaining\\n  function remainingTime() public view returns (uint256) {\\n    return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\\n  }\\n\\n  /// @notice number of seconds since contract was initialized\\n  /// @return timestamp\\n  /// @dev will be less than or equal to duration\\n  function timeSinceStart() public view returns (uint256) {\\n    if (!isTimeStarted()) {\\n      return 0; // uninitialized\\n    }\\n    uint256 _duration = duration;\\n    uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\\n    return timePassed > _duration ? _duration : timePassed;\\n  }\\n\\n  function isTimeStarted() public view returns (bool) {\\n    return startTime != 0 || startTime < block.timestamp;\\n  }\\n\\n  function _initTimed() internal {\\n    startTime = block.timestamp;\\n\\n    emit TimerReset(block.timestamp);\\n  }\\n\\n  function _setDuration(uint256 newDuration) internal {\\n    require(newDuration != 0, \\\"Timed: zero duration\\\");\\n\\n    uint256 oldDuration = duration;\\n    duration = newDuration;\\n    emit DurationUpdate(oldDuration, newDuration);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/timelocks/TimelockedDelegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\nimport {Ownable} from \\\"lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport {ITimelockedDelegator, IDelegatable} from \\\"./interface/ITimelockedDelegator.sol\\\";\\nimport {LinearTokenTimelock} from \\\"./LinearTokenTimelock.sol\\\";\\n\\n/// @title a proxy delegate contract for token\\n/// @author Fei Protocol, modified by Connext. Fei reference:\\n///         https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/LinearTimelockedDelegator.sol\\n/// @dev https://eips.ethereum.org/EIPS/eip-4758 -> inclusion seems likely within\\n///      the next 4 years, so selfdestruct was removed from withdraw()\\n/// @dev\\ncontract Delegatee is Ownable {\\n  IDelegatable public token;\\n\\n  /// @notice Delegatee constructor\\n  /// @param _delegatee the address to delegate token to\\n  /// @param _token the delegatable token address\\n  constructor(address _delegatee, address _token) {\\n    token = IDelegatable(_token);\\n    token.delegate(_delegatee);\\n  }\\n\\n  /// @notice send token back to timelock\\n  function withdraw() public onlyOwner {\\n    IDelegatable _token = token;\\n    uint256 balance = _token.balanceOf(address(this));\\n    _token.transfer(owner(), balance);\\n  }\\n}\\n\\n/// @title a timelock for token allowing for sub-delegation\\n/// @author Fei Protocol\\n/// @notice allows the timelocked token to be delegated by the beneficiary while locked\\ncontract TimelockedDelegator is ITimelockedDelegator, LinearTokenTimelock {\\n  /// @notice associated delegate proxy contract for a delegatee\\n  mapping(address => address) public override delegateContract;\\n\\n  /// @notice associated delegated amount of token for a delegatee\\n  /// @dev Using as source of truth to prevent accounting errors by transferring to Delegate contracts\\n  mapping(address => uint256) public override delegateAmount;\\n\\n  /// @notice the token contract\\n  IDelegatable public override token;\\n\\n  /// @notice the total delegated amount of token\\n  uint256 public override totalDelegated;\\n\\n  /// @notice Delegatee constructor\\n  /// @param _token the token address\\n  /// @param _beneficiary default delegate, admin, and timelock beneficiary\\n  /// @param _clawbackAdmin who can withdraw unclaimed tokens if timelock halted. use address(0) if there\\n  ///        shouldn't be clawbacks for this contract\\n  /// @param _cliffDuration cliff of unlock, in seconds. Use 0 for no cliff.\\n  /// @param _startTime start time of unlock period, in seconds. Use 0 for now.\\n  /// @param _duration duration of the token timelock window\\n  constructor(\\n    address _token,\\n    address _beneficiary,\\n    address _clawbackAdmin,\\n    uint256 _cliffDuration,\\n    uint256 _startTime,\\n    uint256 _duration\\n  ) LinearTokenTimelock(_beneficiary, _duration, _token, _cliffDuration, _clawbackAdmin, _startTime) {\\n    token = IDelegatable(_token);\\n    token.delegate(_beneficiary);\\n  }\\n\\n  /// @notice delegate locked token to a delegatee\\n  /// @param delegatee the target address to delegate to\\n  /// @param amount the amount of token to delegate. Will increment existing delegated token\\n  function delegate(address delegatee, uint256 amount) public override onlyBeneficiary {\\n    require(amount <= _tokenBalance(), \\\"TimelockedDelegator: Not enough balance\\\");\\n\\n    // withdraw and include an existing delegation\\n    if (delegateContract[delegatee] != address(0)) {\\n      amount = amount + undelegate(delegatee);\\n    }\\n\\n    IDelegatable _token = token;\\n    address _delegateContract = address(new Delegatee(delegatee, address(_token)));\\n    delegateContract[delegatee] = _delegateContract;\\n\\n    delegateAmount[delegatee] = amount;\\n    totalDelegated = totalDelegated + amount;\\n\\n    _token.transfer(_delegateContract, amount);\\n\\n    emit Delegate(delegatee, amount);\\n  }\\n\\n  /// @notice return delegated token to the timelock\\n  /// @param delegatee the target address to undelegate from\\n  /// @return the amount of token returned\\n  function undelegate(address delegatee) public override onlyBeneficiary returns (uint256) {\\n    address _delegateContract = delegateContract[delegatee];\\n    require(_delegateContract != address(0), \\\"TimelockedDelegator: Delegate contract nonexistent\\\");\\n\\n    Delegatee(_delegateContract).withdraw();\\n\\n    uint256 amount = delegateAmount[delegatee];\\n    totalDelegated = totalDelegated - amount;\\n\\n    delegateContract[delegatee] = address(0);\\n    delegateAmount[delegatee] = 0;\\n\\n    emit Undelegate(delegatee, amount);\\n\\n    return amount;\\n  }\\n\\n  /// @notice calculate total token held plus delegated\\n  /// @dev used by LinearTokenTimelock to determine the released amount\\n  function totalToken() public view override returns (uint256) {\\n    return _tokenBalance() + totalDelegated;\\n  }\\n\\n  /// @notice accept beneficiary role over timelocked token. Delegates all held (non-subdelegated) token to beneficiary\\n  function acceptBeneficiary() public override {\\n    _setBeneficiary(msg.sender);\\n    token.delegate(msg.sender);\\n  }\\n\\n  function _tokenBalance() internal view returns (uint256) {\\n    return token.balanceOf(address(this));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/timelocks/TimelockFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {IERC20} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {CREATE3} from \\\"lib/solmate/src/utils/CREATE3.sol\\\";\\n\\nimport {TimelockedDelegator} from \\\"./TimelockedDelegator.sol\\\";\\n\\ncontract TimelockFactory {\\n  // ============ events ============\\n  event TimelockDeployed(\\n    address indexed timelock,\\n    address indexed token,\\n    address indexed beneficiary,\\n    address admin,\\n    uint256 cliffDuration,\\n    uint256 startTime,\\n    uint256 duration\\n  );\\n\\n  // ============ public functions ============\\n\\n  /**\\n   * @notice Deploys a LineatTokenTimelock with create3.\\n   * \\n   * @dev Salt generated from token, beneficiary, amount, and deployer.\\n   * @dev Funding is optional. If funding is provided, the timelock will be funded with the funding amount.\\n   * \\n   * @param _token Token to unlock\\n   * @param _beneficiary Unlocking address\\n   * @param _admin Clawback admin\\n   * @param _cliffDuration Duration of cliff in seconds\\n   * @param _startTime Unlock start time in seconds\\n   * @param _duration Duration of the unlock schedule in seconds\\n   * @param _amount The amount to unlock\\n   * @param _funding The initial funding amount\\n   */\\n  function deployTimelock(\\n    address _token,\\n    address _beneficiary,\\n    address _admin,\\n    uint256 _cliffDuration,\\n    uint256 _startTime,\\n    uint256 _duration,\\n    uint256 _amount,\\n    uint256 _funding\\n  ) public returns (address _deployed) {\\n    _deployed = _deployTimelock(_token, _beneficiary, _admin, _cliffDuration, _startTime, _duration, _amount);\\n\\n    if (_funding > 0) {\\n      // fund timelock\\n      IERC20(_token).transferFrom(msg.sender, _deployed, _funding);\\n    }\\n  }\\n\\n  /**\\n   * @notice Computes the address of a timelock contract.\\n   * \\n   * @param _deployer The address that will deploy the contract\\n   * @param _token The token to unlock\\n   * @param _beneficiary The address that will claim unlocks\\n   * @param _startTime The start time\\n   * @param _amount The amount to unlock\\n   */\\n  function computeTimelockAddress(\\n    address _deployer,\\n    address _token,\\n    address _beneficiary,\\n    uint256 _startTime,\\n    uint256 _amount\\n  ) public view returns (address _computed) {\\n    // Get salt\\n    bytes32 salt = _getSalt(_token, _beneficiary, _deployer, _startTime, _amount);\\n\\n    // Deploy timelock\\n    _computed = CREATE3.getDeployed(salt);\\n  }\\n\\n  // ============ internal functions ============\\n  function _deployTimelock(\\n    address _token,\\n    address _beneficiary,\\n    address _admin,\\n    uint256 _cliffDuration,\\n    uint256 _startTime,\\n    uint256 _duration,\\n    uint256 _amount\\n  ) internal returns (address _deployed) {\\n    // Get salt\\n    bytes32 salt = _getSalt(_token, _beneficiary, msg.sender, _startTime, _amount);\\n\\n    // Get bytecode\\n    bytes memory creation = type(TimelockedDelegator).creationCode;\\n    bytes memory bytecode = abi.encodePacked(\\n      creation,\\n      abi.encode(_token, _beneficiary, _admin, _cliffDuration, _startTime, _duration)\\n    );\\n\\n    // Deploy timelock\\n    _deployed = CREATE3.deploy(salt, bytecode, 0);\\n    emit TimelockDeployed(_deployed, _token, _beneficiary, _admin, _cliffDuration, _startTime, _duration);\\n  }\\n\\n  function _getSalt(\\n    address _token,\\n    address _beneficiary,\\n    address _deployer,\\n    uint256 _startTime,\\n    uint256 _amount\\n  ) internal pure returns (bytes32 _salt) {\\n    _salt = keccak256(abi.encodePacked(_token, _beneficiary, _deployer, _startTime, _amount));\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"src/timelocks/TokenTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.19;\\n\\n// Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/TokenTimelock.sol\\n\\n// Inspired by OpenZeppelin TokenTimelock contract\\n// Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/TokenTimelock.sol\\n\\nimport {Timed} from \\\"./Timed.sol\\\";\\nimport {ITokenTimelock, IERC20} from \\\"./interface/ITokenTimelock.sol\\\";\\n\\nabstract contract TokenTimelock is ITokenTimelock, Timed {\\n  /// @notice ERC20 basic token contract being held in timelock\\n  IERC20 public override lockedToken;\\n\\n  /// @notice beneficiary of tokens after they are released\\n  address public override beneficiary;\\n\\n  /// @notice pending beneficiary appointed by current beneficiary\\n  address public override pendingBeneficiary;\\n\\n  /// @notice initial balance of lockedToken\\n  uint256 public override initialBalance;\\n\\n  uint256 internal lastBalance;\\n\\n  /// @notice number of seconds before releasing is allowed\\n  uint256 public immutable cliffSeconds;\\n\\n  address public immutable clawbackAdmin;\\n\\n  constructor(\\n    address _beneficiary,\\n    uint256 _duration,\\n    uint256 _cliffSeconds,\\n    address _lockedToken,\\n    address _clawbackAdmin\\n  ) Timed(_duration) {\\n    require(_duration != 0, \\\"TokenTimelock: duration is 0\\\");\\n    require(_beneficiary != address(0), \\\"TokenTimelock: Beneficiary must not be 0 address\\\");\\n\\n    beneficiary = _beneficiary;\\n    _initTimed();\\n\\n    _setLockedToken(_lockedToken);\\n\\n    cliffSeconds = _cliffSeconds;\\n\\n    clawbackAdmin = _clawbackAdmin;\\n  }\\n\\n  // Prevents incoming LP tokens from messing up calculations\\n  modifier balanceCheck() {\\n    if (totalToken() > lastBalance) {\\n      uint256 delta = totalToken() - lastBalance;\\n      initialBalance = initialBalance + delta;\\n    }\\n    _;\\n    lastBalance = totalToken();\\n  }\\n\\n  modifier onlyBeneficiary() {\\n    require(msg.sender == beneficiary, \\\"TokenTimelock: Caller is not a beneficiary\\\");\\n    _;\\n  }\\n\\n  /// @notice releases `amount` unlocked tokens to address `to`\\n  function release(address to, uint256 amount) external override onlyBeneficiary balanceCheck {\\n    require(amount != 0, \\\"TokenTimelock: no amount desired\\\");\\n    require(passedCliff(), \\\"TokenTimelock: Cliff not passed\\\");\\n\\n    uint256 available = availableForRelease();\\n    require(amount <= available, \\\"TokenTimelock: not enough released tokens\\\");\\n\\n    _release(to, amount);\\n  }\\n\\n  /// @notice releases maximum unlocked tokens to address `to`\\n  function releaseMax(address to) external override onlyBeneficiary balanceCheck {\\n    require(passedCliff(), \\\"TokenTimelock: Cliff not passed\\\");\\n    _release(to, availableForRelease());\\n  }\\n\\n  /// @notice the total amount of tokens held by timelock\\n  function totalToken() public view virtual override returns (uint256) {\\n    return lockedToken.balanceOf(address(this));\\n  }\\n\\n  /// @notice amount of tokens released to beneficiary\\n  function alreadyReleasedAmount() public view override returns (uint256) {\\n    return initialBalance == 0 ? 0 : initialBalance - totalToken();\\n  }\\n\\n  /// @notice amount of held tokens unlocked and available for release\\n  function availableForRelease() public view override returns (uint256) {\\n    uint256 elapsed = timeSinceStart();\\n\\n    uint256 totalAvailable = _proportionAvailable(initialBalance, elapsed, duration);\\n    uint256 netAvailable = totalAvailable - alreadyReleasedAmount();\\n    return netAvailable;\\n  }\\n\\n  /// @notice current beneficiary can appoint new beneficiary, which must be accepted\\n  function setPendingBeneficiary(address _pendingBeneficiary) public override onlyBeneficiary {\\n    pendingBeneficiary = _pendingBeneficiary;\\n    emit PendingBeneficiaryUpdate(_pendingBeneficiary);\\n  }\\n\\n  /// @notice pending beneficiary accepts new beneficiary\\n  function acceptBeneficiary() public virtual override {\\n    _setBeneficiary(msg.sender);\\n  }\\n\\n  function clawback() public balanceCheck {\\n    require(msg.sender == clawbackAdmin, \\\"TokenTimelock: Only clawbackAdmin\\\");\\n    if (passedCliff()) {\\n      _release(beneficiary, availableForRelease());\\n    }\\n    _release(clawbackAdmin, totalToken());\\n  }\\n\\n  function passedCliff() public view returns (bool) {\\n    return timeSinceStart() >= cliffSeconds;\\n  }\\n\\n  function _proportionAvailable(\\n    uint256 initialBalance,\\n    uint256 elapsed,\\n    uint256 duration\\n  ) internal pure virtual returns (uint256);\\n\\n  function _setBeneficiary(address newBeneficiary) internal {\\n    require(newBeneficiary == pendingBeneficiary, \\\"TokenTimelock: Caller is not pending beneficiary\\\");\\n    beneficiary = newBeneficiary;\\n    emit BeneficiaryUpdate(newBeneficiary);\\n    pendingBeneficiary = address(0);\\n  }\\n\\n  function _setLockedToken(address tokenAddress) internal {\\n    lockedToken = IERC20(tokenAddress);\\n  }\\n\\n  function _release(address to, uint256 amount) internal {\\n    lockedToken.transfer(to, amount);\\n    emit Release(beneficiary, to, amount);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"\": {\r\n        \"__CACHE_BREAKER__\": \"0x0000000000000031363934313338313537393734\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"timelock\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cliffDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"TimelockDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deployer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"computeTimelockAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_computed\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cliffDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_funding\",\"type\":\"uint256\"}],\"name\":\"deployTimelock\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_deployed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TimelockFactory", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}