{"SourceCode": "// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: airdropcontract2.sol\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2023-04-08\r\n*/\r\n\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuardUpgradeable  {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    function __ReentrancyGuard_init() internal  {\r\n        __ReentrancyGuard_init_unchained();\r\n    }\r\n\r\n    function __ReentrancyGuard_init_unchained() internal  {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev This empty reserved space is put in place to allow future versions to add new\r\n     * variables without shifting down storage in the inheritance chain.\r\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\r\n     */\r\n    uint256[49] private __gap;\r\n}\r\n\r\n\r\ninterface IAirdropERC1155 {\r\n    /// @notice Emitted when an airdrop fails for a recipient address.\r\n    event AirdropFailed(\r\n        address indexed tokenAddress,\r\n        address indexed tokenOwner,\r\n        address indexed recipient,\r\n        uint256 tokenId,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     *  @notice Details of amount and recipient for airdropped token.\r\n     *\r\n     *  @param recipient The recipient of the tokens.\r\n     *  @param tokenId ID of the ERC1155 token being airdropped.\r\n     *  @param amount The quantity of tokens to airdrop.\r\n     */\r\n    struct AirdropContent {\r\n        address recipient;\r\n        uint256 tokenId;\r\n        uint256 amount;\r\n    }\r\n\r\n    /**\r\n     *  @notice          Lets contract-owner send ERC1155 tokens to a list of addresses.\r\n     *  @dev             The token-owner should approve target tokens to Airdrop contract,\r\n     *                   which acts as operator for the tokens.\r\n     *\r\n     *  @param tokenAddress    The contract address of the tokens to transfer.\r\n     *  @param tokenOwner      The owner of the the tokens to transfer.\r\n     *  @param contents        List containing recipient, tokenId to airdrop.\r\n     */\r\n    function airdropERC1155(\r\n        address tokenAddress,\r\n        address tokenOwner,\r\n        AirdropContent[] calldata contents\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IOwnable {\r\n    /// @dev Returns the owner of the contract.\r\n    function owner() external view returns (address);\r\n\r\n    /// @dev Lets a module admin set a new owner for the contract. The new owner must be a module admin.\r\n    function setOwner(address _newOwner) external;\r\n\r\n    /// @dev Emitted when a new Owner is set.\r\n    event OwnerUpdated(address indexed prevOwner, address indexed newOwner);\r\n}\r\n\r\n/**\r\n *  @title   Ownable\r\n *  @notice  Thirdweb's `Ownable` is a contract extension to be used with any base contract. It exposes functions for setting and reading\r\n *           who the 'owner' of the inheriting smart contract is, and lets the inheriting contract perform conditional logic that uses\r\n *           information about who the contract's owner is.\r\n */\r\n\r\nabstract contract Ownable is IOwnable {\r\n    /// @dev Owner of the contract (purpose: OpenSea compatibility)\r\n    address private _owner;\r\n\r\n    /// @dev Reverts if caller is not the owner.\r\n    modifier onlyOwner() {\r\n        if (msg.sender != _owner) {\r\n            revert(\"Not authorized\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     *  @notice Returns the owner of the contract.\r\n     */\r\n    function owner() public view override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     *  @notice Lets an authorized wallet set a new owner for the contract.\r\n     *  @param _newOwner The address to set as the new owner of the contract.\r\n     */\r\n    function setOwner(address _newOwner) external override {\r\n        if (!_canSetOwner()) {\r\n            revert(\"Not authorized\");\r\n        }\r\n        _setupOwner(_newOwner);\r\n    }\r\n\r\n    /// @dev Lets a contract admin set a new owner for the contract. The new owner must be a contract admin.\r\n    function _setupOwner(address _newOwner) internal {\r\n        address _prevOwner = _owner;\r\n        _owner = _newOwner;\r\n\r\n        emit OwnerUpdated(_prevOwner, _newOwner);\r\n    }\r\n\r\n    /// @dev Returns whether owner can be set in the given execution context.\r\n    function _canSetOwner() internal view virtual returns (bool);\r\n}\r\n\r\ncontract Bulk_Airdrop_1155 is  Ownable, ReentrancyGuardUpgradeable, IAirdropERC1155 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            State variables\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    bytes32 private constant MODULE_TYPE = bytes32(\"AirdropERC1155\");\r\n    uint256 private constant VERSION = 1.0;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    Constructor + initializer logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor() {\r\n        _setupOwner(msg.sender);\r\n        __ReentrancyGuard_init();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                        Generic contract logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Returns the type of the contract.\r\n    function contractType() external pure returns (bytes32) {\r\n        return MODULE_TYPE;\r\n    }\r\n\r\n    /// @dev Returns the version of the contract.\r\n    function contractVersion() external pure returns (uint8) {\r\n        return uint8(VERSION);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            Airdrop logic\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /**\r\n     *  @notice          Lets contract-owner send ERC1155 tokens to a list of addresses.\r\n     *  @dev             The token-owner should approve target tokens to Airdrop contract,\r\n     *                   which acts as operator for the tokens.\r\n     *\r\n     *  @param _tokenAddress    The contract address of the tokens to transfer.\r\n     *  @param _tokenOwner      The owner of the the tokens to transfer.\r\n     *  @param _contents        List containing recipient, tokenId and amounts to airdrop.\r\n     */\r\n    function airdropERC1155(\r\n        address _tokenAddress,\r\n        address _tokenOwner,\r\n        AirdropContent[] calldata _contents\r\n    ) external nonReentrant onlyOwner{\r\n\r\n        uint256 len = _contents.length;\r\n\r\n        for (uint256 i = 0; i < len; ) {\r\n            try\r\n                IERC1155(_tokenAddress).safeTransferFrom(\r\n                    _tokenOwner,\r\n                    _contents[i].recipient,\r\n                    _contents[i].tokenId,\r\n                    _contents[i].amount,\r\n                    \"\"\r\n                )\r\n            {} catch {\r\n                // revert if failure is due to unapproved tokens\r\n                require(\r\n                    IERC1155(_tokenAddress).balanceOf(_tokenOwner, _contents[i].tokenId) >= _contents[i].amount &&\r\n                        IERC1155(_tokenAddress).isApprovedForAll(_tokenOwner, address(this)),\r\n                    \"Not balance or approved\"\r\n                );\r\n\r\n                emit AirdropFailed(\r\n                    _tokenAddress,\r\n                    _tokenOwner,\r\n                    _contents[i].recipient,\r\n                    _contents[i].tokenId,\r\n                    _contents[i].amount\r\n                );\r\n            }\r\n\r\n            unchecked {\r\n                i += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                        Miscellaneous\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    /// @dev Returns whether owner can be set in the given execution context.\r\n    function _canSetOwner() internal view virtual override returns (bool) {\r\n        return msg.sender == owner();\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AirdropFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IAirdropERC1155.AirdropContent[]\",\"name\":\"_contents\",\"type\":\"tuple[]\"}],\"name\":\"airdropERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractType\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractVersion\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Bulk_Airdrop_1155", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4cff2bc89b6f465c2c7a61283ff564e28bb3e65a17c0a56fb30194252507cd36"}