{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/Core.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./managers/FallbackManager.sol\\\";\\nimport \\\"./ICoreStorage.sol\\\";\\n\\nimport \\\"../helpers/Utils.sol\\\";\\n\\n/// @title Cyan Wallet Core - A Cyan wallet's core features.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\ncontract Core is ICoreStorage, IFallbackManager {\\n    struct Call {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    constructor() ICoreStorage(msg.sender) {}\\n\\n    /// @notice Initiates new wallet.\\n    /// @param owner Address of the wallet owner.\\n    function initiate(address owner) external {\\n        require(_owner == address(0x0), \\\"Wallet already initialized.\\\");\\n        require(owner != address(0x0), \\\"Invalid owner address.\\\");\\n\\n        _owner = owner;\\n        emit SetOwner(owner);\\n    }\\n\\n    /// @notice Main transaction handling method of the wallet.\\n    ///      Note: All the non-core transactions go through this method.\\n    /// @param to Destination contract address.\\n    /// @param value Native token value of the transaction.\\n    /// @param data Data payload of the transaction.\\n    /// @return Result of the transaction.\\n    function execute(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) public payable onlyDelegateCall onlyOwner returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Not enough balance.\\\");\\n        if (data.length == 0) {\\n            return Utils._execute(to, value, data);\\n        }\\n\\n        bytes4 funcHash = Utils.parseFunctionSelector(data);\\n        address module = Core(_this).getModule(to, funcHash);\\n        require(module != address(0x0), \\\"Not supported method.\\\");\\n\\n        (bool success, bytes memory result) = module.delegatecall(\\n            abi.encodeWithSignature(\\\"handleTransaction(address,uint256,bytes)\\\", to, value, data)\\n        );\\n        if (!success) {\\n            assembly {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n        return result;\\n    }\\n\\n    function executeBatch(Call[] calldata data) external payable onlyDelegateCall onlyOwner {\\n        for (uint8 i = 0; i < data.length; ++i) {\\n            execute(data[i].to, data[i].value, data[i].data);\\n        }\\n    }\\n\\n    /// @inheritdoc IModuleManager\\n    function executeModule(bytes calldata data) external override onlyDelegateCall onlyOperator returns (bytes memory) {\\n        bytes4 funcHash = Utils.parseFunctionSelector(data);\\n        address module = Core(_this).getInternalModule(funcHash);\\n        require(module != address(0x0), \\\"Not supported method.\\\");\\n\\n        (bool success, bytes memory result) = module.delegatecall(data);\\n        if (!success) {\\n            assembly {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /// @inheritdoc IFallbackManager\\n    function setFallbackHandler(address handler) external override noDelegateCall onlyAdmin {\\n        require(handler != address(0x0), \\\"Invalid handler address.\\\");\\n        _setFallbackHandler(handler);\\n    }\\n\\n    fallback() external payable onlyDelegateCall {\\n        address handler = Core(_this).getFallbackHandler();\\n        assembly {\\n            if iszero(handler) {\\n                return(0, 0)\\n            }\\n\\n            calldatacopy(0, 0, calldatasize())\\n            let success := delegatecall(gas(), handler, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            if gt(success, 0) {\\n                return(0, returndatasize())\\n            }\\n\\n            revert(0, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nlibrary Utils {\\n    /// @notice Executes a transaction to the given address.\\n    /// @param to Target address.\\n    /// @param value Native token value to be sent to the address.\\n    /// @param data Data to be sent to the address.\\n    /// @return result Result of the transaciton.\\n    function _execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal returns (bytes memory result) {\\n        assembly {\\n            let success := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\\n\\n            mstore(result, returndatasize())\\n            returndatacopy(add(result, 0x20), 0, returndatasize())\\n\\n            if eq(success, 0) {\\n                revert(add(result, 0x20), returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @notice Recover signer address from signature.\\n    /// @param signedHash Arbitrary length data signed on the behalf of the wallet.\\n    /// @param signature Signature byte array associated with signedHash.\\n    /// @return Recovered signer address.\\n    function recoverSigner(bytes32 signedHash, bytes memory signature) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n        require(v == 27 || v == 28, \\\"Bad v value in signature.\\\");\\n\\n        address recoveredAddress = ecrecover(signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"ecrecover returned 0.\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /// @notice Helper method to parse the function selector from data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @return result Parsed function sighash.\\n    function parseFunctionSelector(bytes memory data) internal pure returns (bytes4 result) {\\n        require(data.length >= 4, \\\"Invalid data.\\\");\\n        assembly {\\n            result := mload(add(data, 0x20))\\n        }\\n    }\\n\\n    /// @notice Parse uint256 from given data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @param position Position in the data.\\n    /// @return result Uint256 parsed from given data.\\n    function getUint256At(bytes memory data, uint8 position) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mload(add(data, add(position, 0x20)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ICoreStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./managers/DelegateCallManager.sol\\\";\\nimport \\\"./managers/RoleManager.sol\\\";\\nimport \\\"./managers/ModuleManager.sol\\\";\\n\\n/// @title Cyan Wallet Core Storage - A Cyan wallet's core storage features.\\n/// @dev This contract must be the very first parent of the Core contract and Module contracts.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract ICoreStorage is DelegateCallManager, IRoleManager, IModuleManager {\\n    constructor(address admin) IRoleManager(admin) {\\n        require(admin != address(0x0), \\\"Invalid admin address.\\\");\\n    }\\n\\n    /// @inheritdoc IModuleManager\\n    function setModule(\\n        address target,\\n        bytes4 funcHash,\\n        address module\\n    ) external override noDelegateCall onlyAdmin {\\n        emit SetModule(target, funcHash, _modules[target][funcHash], module);\\n        _modules[target][funcHash] = module;\\n    }\\n\\n    /// @inheritdoc IModuleManager\\n    function setInternalModule(bytes4 funcHash, address module) external override noDelegateCall onlyAdmin {\\n        emit SetInternalModule(funcHash, _internalModules[funcHash], module);\\n        _internalModules[funcHash] = module;\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function getOwner() external view override onlyDelegateCall returns (address) {\\n        return _owner;\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function setAdmin(address admin) external override noDelegateCall onlyAdmin {\\n        require(admin != address(0x0), \\\"Invalid admin address.\\\");\\n        _admin = admin;\\n        emit SetAdmin(admin);\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function getAdmin() external view override noDelegateCall returns (address) {\\n        return _admin;\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function setOperator(address operator, bool isActive) external override noDelegateCall onlyAdmin {\\n        require(operator != address(0x0), \\\"Invalid operator address.\\\");\\n        _operators[operator] = isActive;\\n        emit SetOperator(operator, isActive);\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function _checkOnlyAdmin() internal view override {\\n        if (address(this) != _this) {\\n            require(ICoreStorage(_this).getAdmin() == msg.sender, \\\"Caller is not an admin.\\\");\\n        } else {\\n            require(_admin == msg.sender, \\\"Caller is not an admin.\\\");\\n        }\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function isOperator(address operator) external view override noDelegateCall returns (bool result) {\\n        return _operators[operator];\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function _checkOnlyOperator() internal view override {\\n        require(ICoreStorage(_this).isOperator(msg.sender), \\\"Caller is not an operator.\\\");\\n    }\\n\\n    /// @inheritdoc IRoleManager\\n    function _checkOnlyOwner() internal view override {\\n        require(_owner == msg.sender, \\\"Caller is not an owner.\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/managers/FallbackManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Cyan Wallet Fallback Manager - A Cyan wallet's fallback manager.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract IFallbackManager {\\n    // keccak256(\\\"core.fallbackHandler.address\\\")\\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT =\\n        0x7734d301adfb6b9d8ff43068373ec4ffef29a42d1456fb5e0ba2ebb9f4793edb;\\n\\n    event ChangedFallbackHandler(address handler);\\n\\n    /// @notice Sets the fallback handler.\\n    /// @param handler Address of the fallback handler.\\n    function _setFallbackHandler(address handler) internal {\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\n        assembly {\\n            sstore(slot, handler)\\n        }\\n        emit ChangedFallbackHandler(handler);\\n    }\\n\\n    /// @notice Sets the fallback handler.\\n    /// @param handler Address of the fallback handler.\\n    function setFallbackHandler(address handler) external virtual;\\n\\n    /// @notice Returns the fallback handler.\\n    /// @return handler Address of the fallback handler.\\n    function getFallbackHandler() external view returns (address handler) {\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\n        assembly {\\n            handler := sload(slot)\\n        }\\n    }\\n\\n    /// @notice Returns an native token balance of the wallet.\\n    /// return native token balance of the wallet.\\n    function getBalance() external view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    /// @notice Allows the wallet to receive native token.\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/core/managers/DelegateCallManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Manage the delegatecall to a contract\\n/// @notice Base contract that provides a modifier for managing delegatecall to methods in a child contract\\nabstract contract DelegateCallManager {\\n    /// @dev The address of this contract\\n    address payable internal immutable _this;\\n\\n    constructor() {\\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\\n        // In other words, this variable won't change when it's checked at runtime.\\n        _this = payable(address(this));\\n    }\\n\\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\\n    function _checkNotDelegateCall() private view {\\n        require(address(this) == _this, \\\"Only direct calls allowed.\\\");\\n    }\\n\\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\\n    function _checkOnlyDelegateCall() private view {\\n        require(address(this) != _this, \\\"Cannot be called directly.\\\");\\n    }\\n\\n    /// @notice Prevents delegatecall into the modified method\\n    modifier noDelegateCall() {\\n        _checkNotDelegateCall();\\n        _;\\n    }\\n\\n    /// @notice Prevents non delegatecall into the modified method\\n    modifier onlyDelegateCall() {\\n        _checkOnlyDelegateCall();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/managers/ModuleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Cyan Wallet Module Manager Storage - A Cyan wallet's module manager's storage.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract ModuleManagerStorage {\\n    /// @notice Storing allowed contract methods.\\n    ///     Note: Target Contract Address => Sighash of method => Module address\\n    mapping(address => mapping(bytes4 => address)) internal _modules;\\n\\n    /// @notice Storing internally allowed module methods.\\n    ///     Note: Sighash of module method => Module address\\n    mapping(bytes4 => address) internal _internalModules;\\n}\\n\\n/// @title Cyan Wallet Module Manager - A Cyan wallet's module manager's functionalities.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract IModuleManager is ModuleManagerStorage {\\n    event SetModule(address target, bytes4 funcHash, address oldModule, address newModule);\\n    event SetInternalModule(bytes4 funcHash, address oldModule, address newModule);\\n\\n    /// @notice Sets the handler module of the target's function.\\n    /// @param target Address of the target contract.\\n    /// @param funcHash Sighash of the target contract's method.\\n    /// @param module Address of the handler module.\\n    function setModule(\\n        address target,\\n        bytes4 funcHash,\\n        address module\\n    ) external virtual;\\n\\n    /// @notice Returns a handling module of the target function.\\n    /// @param target Address of the target contract.\\n    /// @param funcHash Sighash of the target contract's method.\\n    /// @return module Handler module.\\n    function getModule(address target, bytes4 funcHash) external view returns (address) {\\n        return _modules[target][funcHash];\\n    }\\n\\n    /// @notice Sets the internal handler module of the function.\\n    /// @param funcHash Sighash of the module method.\\n    /// @param module Address of the handler module.\\n    function setInternalModule(bytes4 funcHash, address module) external virtual;\\n\\n    /// @notice Returns an internal handling module of the given function.\\n    /// @param funcHash Sighash of the module's method.\\n    /// @return module Handler module.\\n    function getInternalModule(bytes4 funcHash) external view returns (address) {\\n        return _internalModules[funcHash];\\n    }\\n\\n    /// @notice Used to call module functions on the wallet.\\n    ///     Usually used to call locking function of the module on the wallet.\\n    /// @param data Data payload of the transaction.\\n    /// @return Result of the execution.\\n    function executeModule(bytes memory data) external virtual returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/core/managers/RoleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Cyan Wallet Role Manager - A Cyan wallet's role manager's storage.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract RoleManagerStorage {\\n    address[3] internal _deprecatedOperators; // Deprecated\\n    address internal _admin;\\n    address internal _owner;\\n    mapping(address => bool) internal _operators;\\n}\\n\\n/// @title Cyan Wallet Role Manager - A Cyan wallet's role manager's functionalities.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract IRoleManager is RoleManagerStorage {\\n    event SetOwner(address owner);\\n    event SetAdmin(address admin);\\n    event SetOperator(address operator, bool isActive);\\n\\n    modifier onlyOperator() {\\n        _checkOnlyOperator();\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        _checkOnlyAdmin();\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOnlyOwner();\\n        _;\\n    }\\n\\n    constructor(address admin) {\\n        require(admin != address(0x0), \\\"Invalid admin address.\\\");\\n        _admin = admin;\\n    }\\n\\n    /// @notice Returns current owner of the wallet.\\n    /// @return Address of the current owner.\\n    function getOwner() external view virtual returns (address);\\n\\n    /// @notice Changes the current admin.\\n    /// @param admin New admin address.\\n    function setAdmin(address admin) external virtual;\\n\\n    /// @notice Returns current admin of the core contract.\\n    /// @return Address of the current admin.\\n    function getAdmin() external view virtual returns (address);\\n\\n    /// @notice Sets the operator status.\\n    /// @param operator Operator address.\\n    /// @param isActive Is active or not.\\n    function setOperator(address operator, bool isActive) external virtual;\\n\\n    /// @notice Checks whether the given address is an operator.\\n    /// @param operator Address that will be checked.\\n    /// @return result Boolean result.\\n    function isOperator(address operator) external view virtual returns (bool result);\\n\\n    /// @notice Checks whether the message sender is an operator.\\n    function _checkOnlyOperator() internal view virtual;\\n\\n    /// @notice Checks whether the message sender is an admin.\\n    function _checkOnlyAdmin() internal view virtual;\\n\\n    /// @notice Checks whether the message sender is an owner.\\n    function _checkOnlyOwner() internal view virtual;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"ChangedFallbackHandler\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"SetAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"funcHash\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldModule\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newModule\",\"type\":\"address\"}],\"name\":\"SetInternalModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"funcHash\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldModule\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newModule\",\"type\":\"address\"}],\"name\":\"SetModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"SetOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Core.Call[]\",\"name\":\"data\",\"type\":\"tuple[]\"}],\"name\":\"executeBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeModule\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFallbackHandler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"funcHash\",\"type\":\"bytes4\"}],\"name\":\"getInternalModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"funcHash\",\"type\":\"bytes4\"}],\"name\":\"getModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"initiate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handler\",\"type\":\"address\"}],\"name\":\"setFallbackHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"funcHash\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"setInternalModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"funcHash\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"}],\"name\":\"setModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Core", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}