{"SourceCode": "/*\r\nfile:   VentanaToken.sol\r\nver:    0.1.0\r\nauthor: Darryl Morris\r\ndate:   14-Aug-2017\r\nemail:  o0ragman0o AT gmail.com\r\n(c) Darryl Morris 2017\r\n\r\nA collated contract set for a token sale specific to the requirments of\r\nVeredictum's Ventana token product.\r\n\r\nThis software is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  \r\nSee MIT Licence for further details.\r\n<https://opensource.org/licenses/MIT>.\r\n\r\nRelease Notes\r\n-------------\r\n0.1.0\r\n* Release version\r\n* updated owner, fundWallet, USD_PER_ETH, and START_DATE to final values in VentanaTokenConfig\r\n\r\n\r\n*/\r\n\r\n\r\npragma solidity ^0.4.13;\r\n\r\n/*-----------------------------------------------------------------------------\\\r\n\r\n Ventana token sale configuration\r\n\r\n\\*----------------------------------------------------------------------------*/\r\n\r\n// Contains token sale parameters\r\ncontract VentanaTokenConfig\r\n{\r\n    // ERC20 trade name and symbol\r\n    string public           name            = \"Ventana\";\r\n    string public           symbol          = \"VNT\";\r\n\r\n    // Owner has power to abort, discount addresses, sweep successful funds,\r\n    // change owner, sweep alien tokens.\r\n    address public          owner           = 0xF4b087Ad256ABC5BE11E0433B15Ed012c8AEC8B4; // veredictumPrimary address checksummed\r\n    \r\n    // Fund wallet should also be audited prior to deployment\r\n    // NOTE: Must be checksummed address!\r\n    address public          fundWallet      = 0xd6514387236595e080B97c8ead1cBF12f9a6Ab65; // multiSig address checksummed\r\n\r\n    // Tokens awarded per USD contributed\r\n    uint public constant    TOKENS_PER_USD  = 3;\r\n\r\n    // Ether market price in USD\r\n    uint public constant    USD_PER_ETH     = 258; // calculated from 60 day moving average as at 14th August 2017\r\n    \r\n    // Minimum and maximum target in USD\r\n    uint public constant    MIN_USD_FUND    = 2000000;  // $2m\r\n    uint public constant    MAX_USD_FUND    = 20000000; // $20m\r\n    \r\n    // Non-KYC contribution limit in USD\r\n    uint public constant    KYC_USD_LMT     = 10000;\r\n    \r\n    // There will be exactly 300,000,000 tokens regardless of number sold\r\n    // Unsold tokens are put into the Strategic Growth token pool\r\n    uint public constant    MAX_TOKENS      = 300000000;\r\n    \r\n    // Funding begins on 14th August 2017\r\n    // `+ new Date('19:00 14 August 2017')/1000`\r\n    uint public constant    START_DATE      = 1502701200; // Mon Aug 14 2017 19:00:00 GMT+1000 (AEST)\r\n\r\n    // Period for fundraising\r\n    uint public constant    FUNDING_PERIOD  = 28 days;\r\n}\r\n\r\n\r\nlibrary SafeMath\r\n{\r\n    // a add to b\r\n    function add(uint a, uint b) internal returns (uint c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n    }\r\n    \r\n    // a subtract b\r\n    function sub(uint a, uint b) internal returns (uint c) {\r\n        c = a - b;\r\n        assert(c <= a);\r\n    }\r\n    \r\n    // a multiplied by b\r\n    function mul(uint a, uint b) internal returns (uint c) {\r\n        c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n    }\r\n    \r\n    // a divided by b\r\n    function div(uint a, uint b) internal returns (uint c) {\r\n        c = a / b;\r\n        // No assert required as no overflows are posible.\r\n    }\r\n}\r\n\r\n\r\ncontract ReentryProtected\r\n{\r\n    // The reentry protection state mutex.\r\n    bool __reMutex;\r\n\r\n    // Sets and resets mutex in order to block functin reentry\r\n    modifier preventReentry() {\r\n        require(!__reMutex);\r\n        __reMutex = true;\r\n        _;\r\n        delete __reMutex;\r\n    }\r\n\r\n    // Blocks function entry if mutex is set\r\n    modifier noReentry() {\r\n        require(!__reMutex);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ERC20Token\r\n{\r\n    using SafeMath for uint;\r\n\r\n/* Constants */\r\n\r\n    // none\r\n    \r\n/* State variable */\r\n\r\n    /// @return The Total supply of tokens\r\n    uint public totalSupply;\r\n    \r\n    /// @return Token symbol\r\n    string public symbol;\r\n    \r\n    // Token ownership mapping\r\n    mapping (address => uint) balances;\r\n    \r\n    // Allowances mapping\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n/* Events */\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _amount);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _amount) is called.\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _amount);\r\n\r\n/* Modifiers */\r\n\r\n    // none\r\n    \r\n/* Functions */\r\n\r\n    // Using an explicit getter allows for function overloading    \r\n    function balanceOf(address _addr)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return balances[_addr];\r\n    }\r\n    \r\n    // Using an explicit getter allows for function overloading    \r\n    function allowance(address _owner, address _spender)\r\n        public\r\n        constant\r\n        returns (uint)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        return xfer(msg.sender, _to, _amount);\r\n    }\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_amount <= allowed[_from][msg.sender]);\r\n        \r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        return xfer(_from, _to, _amount);\r\n    }\r\n\r\n    // Process a transfer internally.\r\n    function xfer(address _from, address _to, uint _amount)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        require(_amount <= balances[_from]);\r\n\r\n        Transfer(_from, _to, _amount);\r\n        \r\n        // avoid wasting gas on 0 token transfers\r\n        if(_amount == 0) return true;\r\n        \r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to]   = balances[_to].add(_amount);\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Approves a third-party spender\r\n    function approve(address _spender, uint256 _amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _amount;\r\n        Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n\r\n/*-----------------------------------------------------------------------------\\\r\n\r\n## Conditional Entry Table\r\n\r\nFunctions must throw on F conditions\r\n\r\nConditional Entry Table (functions must throw on F conditions)\r\n\r\nrenetry prevention on all public mutating functions\r\nReentry mutex set in moveFundsToWallet(), refund()\r\n\r\n|function                |<START_DATE|<END_DATE |fundFailed  |fundSucceeded|icoSucceeded\r\n|------------------------|:---------:|:--------:|:----------:|:-----------:|:---------:|\r\n|()                      |KYC        |T         |F           |T            |F          |\r\n|abort()                 |T          |T         |T           |T            |F          |\r\n|proxyPurchase()         |KYC        |T         |F           |T            |F          |\r\n|addKycAddress()         |T          |T         |F           |T            |T          |\r\n|finaliseICO()           |F          |F         |F           |T            |T          |\r\n|refund()                |F          |F         |T           |F            |F          |\r\n|transfer()              |F          |F         |F           |F            |T          |\r\n|transferFrom()          |F          |F         |F           |F            |T          |\r\n|approve()               |F          |F         |F           |F            |T          |\r\n|changeOwner()           |T          |T         |T           |T            |T          |\r\n|acceptOwnership()       |T          |T         |T           |T            |T          |\r\n|changeVeredictum()      |T          |T         |T           |T            |T          |\r\n|destroy()               |F          |F         |!__abortFuse|F            |F          |\r\n|transferAnyERC20Tokens()|T          |T         |T           |T            |T          |\r\n\r\n\\*----------------------------------------------------------------------------*/\r\n\r\ncontract VentanaTokenAbstract\r\n{\r\n// TODO comment events\r\n    event KYCAddress(address indexed _addr, bool indexed _kyc);\r\n    event Refunded(address indexed _addr, uint indexed _value);\r\n    event ChangedOwner(address indexed _from, address indexed _to);\r\n    event ChangeOwnerTo(address indexed _to);\r\n    event FundsTransferred(address indexed _wallet, uint indexed _value);\r\n\r\n    // This fuse blows upon calling abort() which forces a fail state\r\n    bool public __abortFuse = true;\r\n    \r\n    // Set to true after the fund is swept to the fund wallet, allows token\r\n    // transfers and prevents abort()\r\n    bool public icoSuccessful;\r\n\r\n    // Token conversion factors are calculated with decimal places at parity with ether\r\n    uint8 public constant decimals = 18;\r\n\r\n    // An address authorised to take ownership\r\n    address public newOwner;\r\n    \r\n    // The Veredictum smart contract address\r\n    address public veredictum;\r\n    \r\n    // Total ether raised during funding\r\n    uint public etherRaised;\r\n    \r\n    // Preauthorized tranch discount addresses\r\n    // holder => discount\r\n    mapping (address => bool) public kycAddresses;\r\n    \r\n    // Record of ether paid per address\r\n    mapping (address => uint) public etherContributed;\r\n\r\n    // Return `true` if MIN_FUNDS were raised\r\n    function fundSucceeded() public constant returns (bool);\r\n    \r\n    // Return `true` if MIN_FUNDS were not raised before END_DATE\r\n    function fundFailed() public constant returns (bool);\r\n\r\n    // Returns USD raised for set ETH/USD rate\r\n    function usdRaised() public constant returns (uint);\r\n\r\n    // Returns an amount in eth equivilent to USD at the set rate\r\n    function usdToEth(uint) public constant returns(uint);\r\n    \r\n    // Returns the USD value of ether at the set USD/ETH rate\r\n    function ethToUsd(uint _wei) public constant returns (uint);\r\n\r\n    // Returns token/ether conversion given ether value and address. \r\n    function ethToTokens(uint _eth)\r\n        public constant returns (uint);\r\n\r\n    // Processes a token purchase for a given address\r\n    function proxyPurchase(address _addr) payable returns (bool);\r\n\r\n    // Owner can move funds of successful fund to fundWallet \r\n    function finaliseICO() public returns (bool);\r\n    \r\n    // Registers a discounted address\r\n    function addKycAddress(address _addr, bool _kyc)\r\n        public returns (bool);\r\n\r\n    // Refund on failed or aborted sale \r\n    function refund(address _addr) public returns (bool);\r\n\r\n    // To cancel token sale prior to START_DATE\r\n    function abort() public returns (bool);\r\n    \r\n    // Change the Veredictum backend contract address\r\n    function changeVeredictum(address _addr) public returns (bool);\r\n    \r\n    // For owner to salvage tokens sent to contract\r\n    function transferAnyERC20Token(address tokenAddress, uint amount)\r\n        returns (bool);\r\n}\r\n\r\n\r\n/*-----------------------------------------------------------------------------\\\r\n\r\n Ventana token implimentation\r\n\r\n\\*----------------------------------------------------------------------------*/\r\n\r\ncontract VentanaToken is \r\n    ReentryProtected,\r\n    ERC20Token,\r\n    VentanaTokenAbstract,\r\n    VentanaTokenConfig\r\n{\r\n    using SafeMath for uint;\r\n\r\n//\r\n// Constants\r\n//\r\n\r\n    // USD to ether conversion factors calculated from `VentanaTokenConfig` constants \r\n    uint public constant TOKENS_PER_ETH = TOKENS_PER_USD * USD_PER_ETH;\r\n    uint public constant MIN_ETH_FUND   = 1 ether * MIN_USD_FUND / USD_PER_ETH;\r\n    uint public constant MAX_ETH_FUND   = 1 ether * MAX_USD_FUND / USD_PER_ETH;\r\n    uint public constant KYC_ETH_LMT    = 1 ether * KYC_USD_LMT  / USD_PER_ETH;\r\n\r\n    // General funding opens LEAD_IN_PERIOD after deployment (timestamps can't be constant)\r\n    uint public END_DATE  = START_DATE + FUNDING_PERIOD;\r\n\r\n//\r\n// Modifiers\r\n//\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n//\r\n// Functions\r\n//\r\n\r\n    // Constructor\r\n    function VentanaToken()\r\n    {\r\n        // ICO parameters are set in VentanaTSConfig\r\n        // Invalid configuration catching here\r\n        require(bytes(symbol).length > 0);\r\n        require(bytes(name).length > 0);\r\n        require(owner != 0x0);\r\n        require(fundWallet != 0x0);\r\n        require(TOKENS_PER_USD > 0);\r\n        require(USD_PER_ETH > 0);\r\n        require(MIN_USD_FUND > 0);\r\n        require(MAX_USD_FUND > MIN_USD_FUND);\r\n        require(START_DATE > 0);\r\n        require(FUNDING_PERIOD > 0);\r\n        \r\n        // Setup and allocate token supply to 18 decimal places\r\n        totalSupply = MAX_TOKENS * 1e18;\r\n        balances[fundWallet] = totalSupply;\r\n        Transfer(0x0, fundWallet, totalSupply);\r\n    }\r\n    \r\n    // Default function\r\n    function ()\r\n        payable\r\n    {\r\n        // Pass through to purchasing function. Will throw on failed or\r\n        // successful ICO\r\n        proxyPurchase(msg.sender);\r\n    }\r\n\r\n//\r\n// Getters\r\n//\r\n\r\n    // ICO fails if aborted or minimum funds are not raised by the end date\r\n    function fundFailed() public constant returns (bool)\r\n    {\r\n        return !__abortFuse\r\n            || (now > END_DATE && etherRaised < MIN_ETH_FUND);\r\n    }\r\n    \r\n    // Funding succeeds if not aborted, minimum funds are raised before end date\r\n    function fundSucceeded() public constant returns (bool)\r\n    {\r\n        return !fundFailed()\r\n            && etherRaised >= MIN_ETH_FUND;\r\n    }\r\n\r\n    // Returns the USD value of ether at the set USD/ETH rate\r\n    function ethToUsd(uint _wei) public constant returns (uint)\r\n    {\r\n        return USD_PER_ETH.mul(_wei).div(1 ether);\r\n    }\r\n    \r\n    // Returns the ether value of USD at the set USD/ETH rate\r\n    function usdToEth(uint _usd) public constant returns (uint)\r\n    {\r\n        return _usd.mul(1 ether).div(USD_PER_ETH);\r\n    }\r\n    \r\n    // Returns the USD value of ether raised at the set USD/ETH rate\r\n    function usdRaised() public constant returns (uint)\r\n    {\r\n        return ethToUsd(etherRaised);\r\n    }\r\n    \r\n    // Returns the number of tokens for given amount of ether for an address \r\n    function ethToTokens(uint _wei) public constant returns (uint)\r\n    {\r\n        uint usd = ethToUsd(_wei);\r\n        \r\n        // Percent bonus funding tiers for USD funding\r\n        uint bonus =\r\n            usd >= 2000000 ? 35 :\r\n            usd >= 500000  ? 30 :\r\n            usd >= 100000  ? 20 :\r\n            usd >= 25000   ? 15 :\r\n            usd >= 10000   ? 10 :\r\n            usd >= 5000    ? 5  :\r\n                             0;  \r\n        \r\n        // using n.2 fixed point decimal for whole number percentage.\r\n        return _wei.mul(TOKENS_PER_ETH).mul(bonus + 100).div(100);\r\n    }\r\n\r\n//\r\n// ICO functions\r\n//\r\n\r\n    // The fundraising can be aborted any time before funds are swept to the\r\n    // fundWallet.\r\n    // This will force a fail state and allow refunds to be collected.\r\n    function abort()\r\n        public\r\n        noReentry\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(!icoSuccessful);\r\n        delete __abortFuse;\r\n        return true;\r\n    }\r\n    \r\n    // General addresses can purchase tokens during funding\r\n    function proxyPurchase(address _addr)\r\n        payable\r\n        noReentry\r\n        returns (bool)\r\n    {\r\n        require(!fundFailed());\r\n        require(!icoSuccessful);\r\n        require(now <= END_DATE);\r\n        require(msg.value > 0);\r\n        \r\n        // Non-KYC'ed funders can only contribute up to $10000 after prefund period\r\n        if(!kycAddresses[_addr])\r\n        {\r\n            require(now >= START_DATE);\r\n            require((etherContributed[_addr].add(msg.value)) <= KYC_ETH_LMT);\r\n        }\r\n\r\n        // Get ether to token conversion\r\n        uint tokens = ethToTokens(msg.value);\r\n        \r\n        // transfer tokens from fund wallet\r\n        xfer(fundWallet, _addr, tokens);\r\n        \r\n        // Update holder payments\r\n        etherContributed[_addr] = etherContributed[_addr].add(msg.value);\r\n        \r\n        // Update funds raised\r\n        etherRaised = etherRaised.add(msg.value);\r\n        \r\n        // Bail if this pushes the fund over the USD cap or Token cap\r\n        require(etherRaised <= MAX_ETH_FUND);\r\n\r\n        return true;\r\n    }\r\n    \r\n    // Owner can KYC (or revoke) addresses until close of funding\r\n    function addKycAddress(address _addr, bool _kyc)\r\n        public\r\n        noReentry\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(!fundFailed());\r\n\r\n        kycAddresses[_addr] = _kyc;\r\n        KYCAddress(_addr, _kyc);\r\n        return true;\r\n    }\r\n    \r\n    // Owner can sweep a successful funding to the fundWallet\r\n    // Contract can be aborted up until this action.\r\n    function finaliseICO()\r\n        public\r\n        onlyOwner\r\n        preventReentry()\r\n        returns (bool)\r\n    {\r\n        require(fundSucceeded());\r\n\r\n        icoSuccessful = true;\r\n\r\n        FundsTransferred(fundWallet, this.balance);\r\n        fundWallet.transfer(this.balance);\r\n        return true;\r\n    }\r\n    \r\n    // Refunds can be claimed from a failed ICO\r\n    function refund(address _addr)\r\n        public\r\n        preventReentry()\r\n        returns (bool)\r\n    {\r\n        require(fundFailed());\r\n        \r\n        uint value = etherContributed[_addr];\r\n\r\n        // Transfer tokens back to origin\r\n        // (Not really necessary but looking for graceful exit)\r\n        xfer(_addr, fundWallet, balances[_addr]);\r\n\r\n        // garbage collect\r\n        delete etherContributed[_addr];\r\n        delete kycAddresses[_addr];\r\n        \r\n        Refunded(_addr, value);\r\n        if (value > 0) {\r\n            _addr.transfer(value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n//\r\n// ERC20 overloaded functions\r\n//\r\n\r\n    function transfer(address _to, uint _amount)\r\n        public\r\n        preventReentry\r\n        returns (bool)\r\n    {\r\n        // ICO must be successful\r\n        require(icoSuccessful);\r\n        super.transfer(_to, _amount);\r\n\r\n        if (_to == veredictum)\r\n            // Notify the Veredictum contract it has been sent tokens\r\n            require(Notify(veredictum).notify(msg.sender, _amount));\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _amount)\r\n        public\r\n        preventReentry\r\n        returns (bool)\r\n    {\r\n        // ICO must be successful\r\n        require(icoSuccessful);\r\n        super.transferFrom(_from, _to, _amount);\r\n\r\n        if (_to == veredictum)\r\n            // Notify the Veredictum contract it has been sent tokens\r\n            require(Notify(veredictum).notify(msg.sender, _amount));\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint _amount)\r\n        public\r\n        noReentry\r\n        returns (bool)\r\n    {\r\n        // ICO must be successful\r\n        require(icoSuccessful);\r\n        super.approve(_spender, _amount);\r\n        return true;\r\n    }\r\n\r\n//\r\n// Contract managment functions\r\n//\r\n\r\n    // To initiate an ownership change\r\n    function changeOwner(address _newOwner)\r\n        public\r\n        noReentry\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        ChangeOwnerTo(_newOwner);\r\n        newOwner = _newOwner;\r\n        return true;\r\n    }\r\n\r\n    // To accept ownership. Required to prove new address can call the contract.\r\n    function acceptOwnership()\r\n        public\r\n        noReentry\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == newOwner);\r\n        ChangedOwner(owner, newOwner);\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n\r\n    // Change the address of the Veredictum contract address. The contract\r\n    // must impliment the `Notify` interface.\r\n    function changeVeredictum(address _addr)\r\n        public\r\n        noReentry\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        veredictum = _addr;\r\n        return true;\r\n    }\r\n    \r\n    // The contract can be selfdestructed after abort and ether balance is 0.\r\n    function destroy()\r\n        public\r\n        noReentry\r\n        onlyOwner\r\n    {\r\n        require(!__abortFuse);\r\n        require(this.balance == 0);\r\n        selfdestruct(owner);\r\n    }\r\n    \r\n    // Owner can salvage ERC20 tokens that may have been sent to the account\r\n    function transferAnyERC20Token(address tokenAddress, uint amount)\r\n        public\r\n        onlyOwner\r\n        preventReentry\r\n        returns (bool) \r\n    {\r\n        require(ERC20Token(tokenAddress).transfer(owner, amount));\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ninterface Notify\r\n{\r\n    event Notified(address indexed _from, uint indexed _amount);\r\n    \r\n    function notify(address _from, uint _amount) public returns (bool);\r\n}\r\n\r\n\r\ncontract VeredictumTest is Notify\r\n{\r\n    address public vnt;\r\n    \r\n    function setVnt(address _addr) { vnt = _addr; }\r\n    \r\n    function notify(address _from, uint _amount) public returns (bool)\r\n    {\r\n        require(msg.sender == vnt);\r\n        Notified(_from, _amount);\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"veredictum\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"abort\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finaliseICO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ETH_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_kyc\",\"type\":\"bool\"}],\"name\":\"addKycAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"proxyPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"END_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"changeVeredictum\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundSucceeded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundFailed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"__abortFuse\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_ETH_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_USD_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoSuccessful\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"kycAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"ethToUsd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYC_ETH_LMT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"ethToTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"etherContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_USD_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USD_PER_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_PER_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_usd\",\"type\":\"uint256\"}],\"name\":\"usdToEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KYC_USD_LMT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKENS_PER_USD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FUNDING_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_kyc\",\"type\":\"bool\"}],\"name\":\"KYCAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"ChangedOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"ChangeOwnerTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"FundsTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "VentanaToken", "CompilerVersion": "v0.4.13+commit.fb4cb1a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://47ec3a879e678ba748a9e0a0ca93b62f73bf9c4fa1918fc4c95492a838cd3e9c"}