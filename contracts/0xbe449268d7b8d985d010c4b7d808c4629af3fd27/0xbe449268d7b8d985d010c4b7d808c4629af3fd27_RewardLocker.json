{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/RewardLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Bloodline} from \\\"./Bloodline.sol\\\";\\n\\n/// Attempt to access meme altar functionality from unauthorized address.\\nerror NotMemeAltar();\\n\\n/// Initialization is one time action.\\nerror AlreadyInitialized();\\n\\n/// MemeAltar and RewardLocker are unsynchronized.\\nerror Unsynchronized();\\n\\n/// Action is disallowed until current cycle will be completed.\\nerror CycleIsNotCompletedYet();\\n\\n/// Unstake is ordered, but the cycle is still not completed, wait.\\nerror TooEarlyToUnstake();\\n\\n/// Stake coefficient cannot be bigger than 10000.\\nerror StakePartMoreThan100Percent();\\n\\n/**\\n * @title RewardLocker - Rewards registry for cycles, the only minter of `bloodline`,\\n *                          provides an ability to claim and stake reward token.\\n */\\ncontract RewardLocker {\\n    struct Cycle {\\n        uint32 cycleCompletedTimestamp;\\n        uint224 totalSacrificeCompetitionRewards;\\n        uint256 totalStakeRewards;\\n        address[] sacrificableTokens;\\n        // sacrificedToken -> coefficient\\n        mapping(address => uint256) coefficients;\\n        // sacrificedToken -> total sacrifice rewards\\n        mapping(address => uint256) totalSacrificeRewardsForToken;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n    event CycleStarted(uint256 indexed index);\\n\\n    event CycleCompleted(\\n        uint256 indexed index, address indexed winnerToken, uint256 indexed totalCycleRewards\\n    );\\n\\n    event Rewarded(\\n        address indexed user,\\n        uint256 indexed cycleNumber,\\n        address indexed token,\\n        uint256 reward\\n    );\\n\\n    event ClaimedReward(address indexed claimer, uint256 indexed amount);\\n\\n    event RewardStaked(\\n        address indexed staker, uint256 indexed stakedCycle, uint256 indexed stakedAmount\\n    );\\n\\n    event UnstakeOrdered(\\n        address indexed unstaker, uint256 indexed unstakeCycle, uint256 indexed unstakedAmount\\n    );\\n\\n    event RewardUnstaked(\\n        address indexed unstaker, uint256 indexed unstakeCycle, uint256 indexed unstakedAmount\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Constant used in calculation as a denominator for accurancy.\\n    uint256 constant DENOMINATOR = 10_000;\\n    /// @notice Constants represents a bonus percentage for competition and stake rewards.\\n    uint256 constant BONUS_PERCENTAGE = 25;\\n    uint256 constant HUNDRED = 100;\\n    /// @notice Represents a developer fee as a percentage, which is additionally minted on top of total cycle rewards.\\n    uint256 constant DEVELOPER_PERCENTAGE = 3;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        REWARD LOCKER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice ERC20 which is a reward token and can be minted only by this contract.\\n    Bloodline public bloodline;\\n    /// @notice Contract that defines the rewards, cycles and their completion.\\n    address public memeAltar;\\n    // @notice Contract, which receives developer fee and provides BDL liquidity.\\n    address public devLiquidityHolder;\\n    /// @notice The number of the last completed cycle.\\n    uint256 public lastCompletedCycle;\\n    /// @notice Stores the data related to the cycles.\\n    /// @dev cycleNumber -> Cycle struct\\n    mapping(uint256 => Cycle) public cycles;\\n\\n    /// @notice Stores the rewards concatenated 128bit stake amount and 128bit sacrifice amount.\\n    /// @dev user -> cycleNumber -> sacrificedToken -> concatenated amounts\\n    mapping(address => mapping(uint256 => mapping(address => uint256))) private rewards;\\n    /// @notice Stores the staked amounts.\\n    /// @dev user -> stakedAmount\\n    mapping(address => uint256) public staked;\\n    /// @notice Stores the unstake orders.\\n    /// @dev cycleNumber -> user -> unstakeAmount\\n    mapping(uint256 => mapping(address => uint256)) public unstakeOrdered;\\n\\n    modifier onlyMemeAltar() {\\n        if (msg.sender != memeAltar) {\\n            revert NotMemeAltar();\\n        }\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            INITIALIZATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Method initialize memeAltar and bloodline, sets first cycle as 1.\\n     * @param _memeAltar address of contract that defines the rewards, cycles and their completion.\\n     * @param _bloodline address of ERC20 which is a reward token and can be minted only by this contract.\\n     * @param _devLiquidityHolder address which receives developer fee and provides BDL liquidity.\\n     */\\n    function init(\\n        address _memeAltar,\\n        address _bloodline,\\n        address _devLiquidityHolder\\n    )\\n        external\\n    {\\n        if (\\n            memeAltar != address(0) && address(bloodline) != address(0)\\n                && devLiquidityHolder != address(0)\\n        ) {\\n            revert AlreadyInitialized();\\n        }\\n        devLiquidityHolder = _devLiquidityHolder;\\n        memeAltar = _memeAltar;\\n        bloodline = Bloodline(_bloodline);\\n        Cycle storage cycle0 = cycles[0];\\n        cycle0.cycleCompletedTimestamp = uint32(block.timestamp);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            CYCLE AND REWARD LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n    /**\\n     * @notice Method inits data related to the next cycle.\\n     * @dev Should be called after `registerCycleCompleted`.\\n     *      Must be at least 2 sacrificable tokens.\\n     * @param cycleIndex the number of the next cycle.\\n     * @param sacrificableTokens list of token addresses that participate in the next cycle.\\n     * @return True\\n     */\\n    function registerNextCycle(\\n        uint256 cycleIndex,\\n        address[] calldata sacrificableTokens\\n    )\\n        external\\n        onlyMemeAltar\\n        returns (bool)\\n    {\\n        Cycle storage previousCycle = cycles[lastCompletedCycle];\\n        if (\\n            cycleIndex != lastCompletedCycle + 1\\n                || previousCycle.cycleCompletedTimestamp != block.timestamp\\n                || sacrificableTokens.length < 2\\n        ) {\\n            revert Unsynchronized();\\n        }\\n        Cycle storage cycle = cycles[cycleIndex];\\n        if (cycle.sacrificableTokens.length > 0) {\\n            revert Unsynchronized();\\n        }\\n        cycle.sacrificableTokens = sacrificableTokens;\\n        emit CycleStarted(cycleIndex);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Method register the user reward for sacrificing and extra reward if\\n     *         user staked to be secured.\\n     * @param user address which is being rewarded.\\n     * @param _sacrificedToken address of a token that was sacrificed.\\n     * @param reward amount of the reward tokens `user` is getting for sacrificing.\\n     * @return True\\n     */\\n    function registerReward(\\n        address user,\\n        address _sacrificedToken,\\n        uint256 reward\\n    )\\n        external\\n        onlyMemeAltar\\n        returns (bool)\\n    {\\n        uint256 cycleNumber = lastCompletedCycle + 1;\\n        Cycle storage cycle = cycles[cycleNumber];\\n        uint256 stakeSacrificeRewards = rewards[user][cycleNumber][_sacrificedToken];\\n        uint256 stakedAmount = staked[user];\\n        if (stakedAmount != 0) {\\n            (uint256 stakeReward, uint256 sacrificeReward) =\\n                _unpackStakeSacrificeRewards(stakeSacrificeRewards);\\n            if (stakeReward < BONUS_PERCENTAGE * stakedAmount / HUNDRED) {\\n                if (reward + sacrificeReward >= stakedAmount) {\\n                    // storage write\\n                    cycle.totalStakeRewards +=\\n                        (BONUS_PERCENTAGE * stakedAmount / HUNDRED) - stakeReward;\\n                    stakeReward = BONUS_PERCENTAGE * stakedAmount / HUNDRED;\\n                } else {\\n                    // storage write\\n                    cycle.totalStakeRewards += BONUS_PERCENTAGE * reward / HUNDRED;\\n                    stakeReward += BONUS_PERCENTAGE * reward / HUNDRED;\\n                }\\n            }\\n            sacrificeReward += reward;\\n            stakeSacrificeRewards = _packStakeSacrificeRewards(stakeReward, sacrificeReward);\\n        } else {\\n            stakeSacrificeRewards += reward;\\n        }\\n        // storage write\\n        rewards[user][cycleNumber][_sacrificedToken] = stakeSacrificeRewards;\\n        // storage write\\n        cycle.totalSacrificeRewardsForToken[_sacrificedToken] += reward;\\n        emit Rewarded(user, cycleNumber, _sacrificedToken, reward);\\n        return true;\\n    }\\n\\n    function _unpackStakeSacrificeRewards(uint256 stakeSacrificeRewards)\\n        internal\\n        pure\\n        returns (uint256 stakeReward, uint256 sacrificeReward)\\n    {\\n        stakeReward = uint256(uint128(stakeSacrificeRewards >> 128));\\n        sacrificeReward = uint256(uint128(stakeSacrificeRewards));\\n    }\\n\\n    function _packStakeSacrificeRewards(\\n        uint256 stakeReward,\\n        uint256 sacrificeReward\\n    )\\n        internal\\n        pure\\n        returns (uint256 stakeSacrificeRewards)\\n    {\\n        stakeSacrificeRewards = (stakeReward << 128) + sacrificeReward;\\n    }\\n\\n    /**\\n     * @notice Method register cycle as a completed. Sets token coefficients\\n     *         to extra reward winner up to 25%. Mints reward tokens.\\n     * @dev IF we want to fight against inflation - here we can set losers\\n     *      coefficient as 0.5.\\n     * @param cycleIndex number of the cycle which is completed.\\n     * @param winnerToken address of a token which won cycle competition.\\n     * @return True\\n     */\\n    function registerCycleCompleted(\\n        uint256 cycleIndex,\\n        address winnerToken\\n    )\\n        external\\n        onlyMemeAltar\\n        returns (bool)\\n    {\\n        if (cycleIndex != lastCompletedCycle + 1) {\\n            revert Unsynchronized();\\n        }\\n        Cycle storage cycle = cycles[cycleIndex];\\n        uint256 numberOfSacrificables = cycle.sacrificableTokens.length;\\n        uint256 cycleTotalRewards;\\n        for (uint256 i = 0; i < numberOfSacrificables; i++) {\\n            address token = cycle.sacrificableTokens[i];\\n            // storage write\\n            cycle.coefficients[token] = DENOMINATOR;\\n            // storage read\\n            cycleTotalRewards += cycle.totalSacrificeRewardsForToken[token];\\n        }\\n\\n        // winner competition bonus\\n        if (cycleTotalRewards != 0 && winnerToken != address(0)) {\\n            uint256 minDominance = cycleTotalRewards / numberOfSacrificables;\\n            uint256 winnerCoefficient = (\\n                DENOMINATOR + (BONUS_PERCENTAGE * DENOMINATOR / HUNDRED)\\n            )\\n                - (\\n                    (cycle.totalSacrificeRewardsForToken[winnerToken] - minDominance)\\n                        * (BONUS_PERCENTAGE * DENOMINATOR / HUNDRED)\\n                        / (cycleTotalRewards - minDominance)\\n                );\\n            // storage rewrite\\n            cycle.coefficients[winnerToken] = winnerCoefficient;\\n            // add competition reward\\n            cycleTotalRewards += cycle.totalSacrificeRewardsForToken[winnerToken]\\n                * (winnerCoefficient - DENOMINATOR) / DENOMINATOR;\\n        }\\n\\n        // storage write\\n        cycle.totalSacrificeCompetitionRewards = uint224(cycleTotalRewards);\\n        // add stake rewards\\n        cycleTotalRewards += cycle.totalStakeRewards;\\n\\n        bloodline.mintBloodline(address(this), cycleTotalRewards);\\n        uint256 developerFee = cycleTotalRewards * DEVELOPER_PERCENTAGE / HUNDRED;\\n        bloodline.mintBloodline(devLiquidityHolder, developerFee);\\n        // storage write\\n        lastCompletedCycle += 1;\\n        // storage write\\n        cycle.cycleCompletedTimestamp = uint32(block.timestamp);\\n        emit CycleCompleted(cycleIndex, winnerToken, cycleTotalRewards);\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            STAKE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Method stakes tokens collected as rewards from `_cycles` cycles\\n     *         for sacrificing `_sacrificedTokens` tokens. Staking guarantees\\n     *         additional reward for sacrificing tokens in the next cycles -\\n     *         each sacrificed reward is doubled, if the same amount is staked.\\n     * @dev Should be called instead claim by long run users.\\n     * @param _cycles an array of cycle numbers (must be completed ones).\\n     * @param _sacrificedTokens an array of sacrificed token addresses.\\n     * @return stakedAmount amount of tokens which were staked.\\n     */\\n    function stakeToBeSecured(\\n        uint256[] memory _cycles,\\n        address[] memory _sacrificedTokens\\n    )\\n        external\\n        returns (uint256 stakedAmount)\\n    {\\n        stakedAmount = _getRewardForCyclesTokens(_cycles, _sacrificedTokens);\\n        staked[msg.sender] += stakedAmount;\\n        emit RewardStaked(msg.sender, lastCompletedCycle + 1, stakedAmount);\\n    }\\n\\n    /**\\n     * @notice Method stakes `amount` amount of `bloodline` tokens using permit,\\n     *         requires to sign EIP2612 approval for this contract. Staking guarantees\\n     *         additional reward for sacrificing tokens in the next cycles -\\n     *         each sacrificed reward is doubled, if the same amount is staked.\\n     * @dev Frontend must have ability to sign EIP2612 approval. Could be called by lucky price deep buyers.\\n     * @param amount of `bloodline` tokens which are staking.\\n     * @param deadline timestamp until permit is valid.\\n     * @param v secp256k1 signature field\\n     * @param r secp256k1 signature field\\n     * @param s secp256k1 signature field\\n     * @return stakedAmount amount of tokens which were staked.\\n     */\\n    function stakeToBeSecured(\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    )\\n        external\\n        returns (uint256 stakedAmount)\\n    {\\n        bloodline.permit(msg.sender, address(this), amount, deadline, v, r, s);\\n        stakedAmount = stakeToBeSecured(amount);\\n    }\\n\\n    /**\\n     * @notice Method stakes `amount` amount of `bloodline` tokens.\\n     *         Requires token preapproval for this contract. Staking guarantees\\n     *         additional reward for sacrificing tokens in the next cycles -\\n     *         each sacrificed reward is doubled, if the same amount is staked.\\n     * @dev Should be called after `bloodline` approve tx.\\n     * @param amount of `bloodline` tokens which are staking.\\n     * @return stakedAmount amount of tokens which were staked.\\n     */\\n    function stakeToBeSecured(uint256 amount) public returns (uint256 stakedAmount) {\\n        require(bloodline.transferFrom(msg.sender, address(this), amount));\\n        staked[msg.sender] += amount;\\n        stakedAmount = amount;\\n        emit RewardStaked(msg.sender, lastCompletedCycle + 1, stakedAmount);\\n    }\\n\\n    /**\\n     * @notice Method creates an order to unstake staked `bloodline` tokens.\\n     *         After method is called, tokens can be unstaked in the next cycle.\\n     * @dev Should be called before unstake.\\n     * @return unstakeCycle number of cycle, when tokens can be unstaked.\\n     */\\n    function orderUnstake() external returns (uint256 unstakeCycle) {\\n        unstakeCycle = lastCompletedCycle + 2;\\n        uint256 stakedAmount = staked[msg.sender];\\n        staked[msg.sender] = 0;\\n        unstakeOrdered[unstakeCycle][msg.sender] += stakedAmount;\\n        emit UnstakeOrdered(msg.sender, unstakeCycle, stakedAmount);\\n    }\\n\\n    /**\\n     * @notice Method unstakes staked `bloodline` tokens and transfers them to\\n     *         `msg.sender`, which were ordered to be unstaked in `unstakeCycle` cycle.\\n     * @dev Should be called after orderUnstake and cycle order was made is completed.\\n     * @param unstakeCycle number of the next cycle after cycle tokens were ordered to be unstaked.\\n     * @return unstakedAmount amount of tokens being unstaked.\\n     */\\n    function unstake(uint256 unstakeCycle) external returns (uint256 unstakedAmount) {\\n        if (unstakeCycle > lastCompletedCycle + 1) {\\n            revert TooEarlyToUnstake();\\n        }\\n        unstakedAmount = unstakeOrdered[unstakeCycle][msg.sender];\\n        unstakeOrdered[unstakeCycle][msg.sender] = 0;\\n        _transferReward(unstakedAmount);\\n        emit RewardUnstaked(msg.sender, unstakeCycle, unstakedAmount);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            CLAIM LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Method claims for specified `_cycles` cycles reward as `bloodline`\\n     *         tokens and transfers them to `msg.sender` user.\\n     * @dev Should be called by users, who sacrificed all sacrificable tokens.\\n     * @param _cycles an array of cycle numbers, for which rewards should be claimed.\\n     * @return claimedAmount amount of tokens are being claimed by 'msg.sender' user.\\n     */\\n    function claim(uint256[] memory _cycles) external returns (uint256 claimedAmount) {\\n        for (uint256 i = 0; i < _cycles.length; i++) {\\n            Cycle storage cycle = cycles[_cycles[i]];\\n            if (\\n                cycle.cycleCompletedTimestamp == 0\\n                    || cycle.cycleCompletedTimestamp >= block.timestamp\\n            ) {\\n                revert CycleIsNotCompletedYet();\\n            }\\n            for (uint256 k = 0; k < cycle.sacrificableTokens.length; k++) {\\n                address _sacrificedToken = cycle.sacrificableTokens[k];\\n                uint256 rewardAmount = _getReward(_cycles[i], cycle, _sacrificedToken);\\n                claimedAmount += rewardAmount;\\n            }\\n        }\\n        _transferReward(claimedAmount);\\n        emit ClaimedReward(msg.sender, claimedAmount);\\n    }\\n\\n    /**\\n     * @notice Method claims for specified `_cycles` cycles for specified\\n     *         sacrificable `_sacrificedTokens` tokens reward as `bloodline`\\n     *         tokens and transfers them to `msg.sender` user.\\n     * @dev Should be called by users, who sacrificed specific sacrificable tokens.\\n     * @param _cycles an array of cycle numbers, for which rewards should be claimed.\\n     * @param _sacrificedTokens an array of sacrificed token addresses, for which rewards should be claimed.\\n     * @return claimedAmount amount of tokens are being claimed by 'msg.sender' user.\\n     */\\n    function claim(\\n        uint256[] memory _cycles,\\n        address[] memory _sacrificedTokens\\n    )\\n        external\\n        returns (uint256 claimedAmount)\\n    {\\n        claimedAmount = _getRewardForCyclesTokens(_cycles, _sacrificedTokens);\\n        _transferReward(claimedAmount);\\n        emit ClaimedReward(msg.sender, claimedAmount);\\n    }\\n\\n    /**\\n     * @notice Method claims for specified `_cycles` cycles for specified\\n     *         sacrificable `_sacrificedToken` token reward as `bloodline`\\n     *         tokens and transfers them to `msg.sender` user.\\n     * @dev Should be called by users, who sacrificed specific sacrificable token.\\n     * @param _cycles an array of cycle numbers, for which rewards should be claimed.\\n     * @param _sacrificedToken an address of sacrificed token, for which rewards should be claimed.\\n     * @return claimedAmount amount of tokens are being claimed by 'msg.sender' user.\\n     */\\n    function claim(\\n        uint256[] memory _cycles,\\n        address _sacrificedToken\\n    )\\n        external\\n        returns (uint256 claimedAmount)\\n    {\\n        for (uint256 i = 0; i < _cycles.length; i++) {\\n            Cycle storage cycle = cycles[_cycles[i]];\\n            if (\\n                cycle.cycleCompletedTimestamp == 0\\n                    || cycle.cycleCompletedTimestamp >= block.timestamp\\n            ) {\\n                revert CycleIsNotCompletedYet();\\n            }\\n            uint256 rewardAmount = _getReward(_cycles[i], cycle, _sacrificedToken);\\n            claimedAmount += rewardAmount;\\n        }\\n        _transferReward(claimedAmount);\\n        emit ClaimedReward(msg.sender, claimedAmount);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      COMBINED STAKE AND CLAIM LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Method partially stakes tokens collected as rewards from `_cycles`\\n     *         cycles for sacrificing `_sacrificedTokens` tokens and partially\\n     *         claims them. Staking guarantees additional reward for sacrificing\\n     *         tokens in the next cycles - each sacrificed reward is doubled,\\n     *         if the same amount is staked.\\n     * @dev Should be called by those who wants to stake and claim at the same time.\\n     * @param stakeCoefficient is a value between 0 and 10000 that determines\\n     *                         the portion of totalRewardAmount to be staked.\\n     *                         The remaining percentage will be claimed.\\n     * @param _cycles an array of cycle numbers (must be completed ones).\\n     * @param _sacrificedTokens an array of sacrificed token addresses.\\n     * @return stakedAmount amount of tokens which were staked.\\n     * @return claimedAmount amount of tokens which were claimed.\\n     */\\n    function stakeAndClaim(\\n        uint256 stakeCoefficient,\\n        uint256[] memory _cycles,\\n        address[] memory _sacrificedTokens\\n    )\\n        external\\n        returns (uint256 stakedAmount, uint256 claimedAmount)\\n    {\\n        if (stakeCoefficient > DENOMINATOR) {\\n            revert StakePartMoreThan100Percent();\\n        }\\n        uint256 totalRewardAmount = _getRewardForCyclesTokens(_cycles, _sacrificedTokens);\\n        stakedAmount = totalRewardAmount * stakeCoefficient / DENOMINATOR;\\n        claimedAmount = totalRewardAmount - stakedAmount;\\n        staked[msg.sender] += stakedAmount;\\n        _transferReward(claimedAmount);\\n        emit RewardStaked(msg.sender, lastCompletedCycle + 1, stakedAmount);\\n        emit ClaimedReward(msg.sender, claimedAmount);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          VIEW FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getRewards(\\n        address user,\\n        uint256 cycleNumber,\\n        address sacrificedToken\\n    )\\n        public\\n        view\\n        returns (uint256 stakeReward, uint256 sacrificeReward)\\n    {\\n        uint256 stakeSacrificeRewards = rewards[user][cycleNumber][sacrificedToken];\\n        (stakeReward, sacrificeReward) = _unpackStakeSacrificeRewards(stakeSacrificeRewards);\\n    }\\n\\n    /**\\n     * @notice View method returns total amount of sacrifice and stake rewards\\n     *         `beneficiary` user has earned for `cycleNumbers` cycles.\\n     * @param beneficiary user address.\\n     * @param cycleNumbers an array of cycle numbers, user has participated in.\\n     * @return totalSacrificeRewards amount of tokens user has earned for sacrificing + competition reward (if token won).\\n     * @return totalStakeRewards amount of tokens user has earned by staking.\\n     */\\n    function getTotalRewardsOf(\\n        address beneficiary,\\n        uint256[] memory cycleNumbers\\n    )\\n        external\\n        view\\n        returns (uint256 totalSacrificeRewards, uint256 totalStakeRewards)\\n    {\\n        for (uint256 i = 0; i < cycleNumbers.length; i++) {\\n            uint256 cycleNumber = cycleNumbers[i];\\n            Cycle storage cycle = cycles[cycleNumber];\\n            for (uint256 k = 0; k < cycle.sacrificableTokens.length; k++) {\\n                address sacrificedToken = cycle.sacrificableTokens[k];\\n                uint256 coefficient = cycle.coefficients[sacrificedToken];\\n                (uint256 stakeReward, uint256 sacrificeReward) =\\n                    getRewards(beneficiary, cycleNumber, sacrificedToken);\\n                if (coefficient != 0) {\\n                    totalSacrificeRewards += sacrificeReward * coefficient / DENOMINATOR;\\n                } else {\\n                    totalSacrificeRewards += sacrificeReward;\\n                }\\n                totalStakeRewards += stakeReward;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice View method returns stake reward for sacrifice reward.\\n     * @param user user address.\\n     * @param sacrificedToken token address to get stake reward for.\\n     * @param reward sacrifice reward to get stake reward for.\\n     * @return stakeReward amount of tokens user has earned by staking.\\n     */\\n    function getStakeRewardForSacrificeReward(\\n        address user,\\n        address sacrificedToken,\\n        uint256 reward\\n    )\\n        external\\n        view\\n        returns (uint256 stakeReward)\\n    {\\n        uint256 cycleNumber = lastCompletedCycle + 1;\\n        uint256 stakeSacrificeRewards = rewards[user][cycleNumber][sacrificedToken];\\n        uint256 stakedAmount = staked[user];\\n        if (stakedAmount != 0) {\\n            uint256 sacrificeReward;\\n            (stakeReward, sacrificeReward) =\\n                _unpackStakeSacrificeRewards(stakeSacrificeRewards);\\n            if (stakeReward < BONUS_PERCENTAGE * stakedAmount / HUNDRED) {\\n                if (reward + sacrificeReward >= stakedAmount) {\\n                    stakeReward = (BONUS_PERCENTAGE * stakedAmount / HUNDRED) - stakeReward;\\n                } else {\\n                    stakeReward = BONUS_PERCENTAGE * reward / HUNDRED;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice View method returns an array of addresses, which are sacrificable\\n     *         tokens in a `cycleNumber` cycle.\\n     * @param cycleNumber number of a cycle, an array is requested for.\\n     * @return An array of addresses, which are sacrificable tokens.\\n     */\\n    function getSacrificableTokens(uint256 cycleNumber)\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        Cycle storage cycle = cycles[cycleNumber];\\n        return cycle.sacrificableTokens;\\n    }\\n\\n    /**\\n     * @notice View method returns a coefficient, which is applied as a multiplier\\n     *         for sacrifice rewards.\\n     * @dev Cycle winner token has coefficient bigger than cycle loser token, the\\n     *      maximimum coefficient is getting by winner after the closest competition possible.\\n     * @param cycleNumber number of a cycle, a coefficient is requested for.\\n     * @param sacrificedToken address of a token, a coefficient is requested for.\\n     * @return Returns number in a range from 1 to 1.25x with 10000 as a precision; 0, if cycle is not completed.\\n     */\\n    function getSacrificedTokenCoefficient(\\n        uint256 cycleNumber,\\n        address sacrificedToken\\n    )\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        Cycle storage cycle = cycles[cycleNumber];\\n        return cycle.coefficients[sacrificedToken];\\n    }\\n\\n    /**\\n     * @notice View method returns a totalSacrificeRewardsForToken\\n     *         for a sacrificed token in a `cycleNumber` cycle.\\n     * @param cycleNumber number of a cycle, a reward amounts are requested for.\\n     * @param sacrificedToken address of a token, a reward amounts are requested for.\\n     * @return totalSacrificeRewardsForToken total amount of default rewards for sacrificing `sacrificedToken` token.\\n     */\\n    function getTotalSacrificeRewardsForToken(\\n        uint256 cycleNumber,\\n        address sacrificedToken\\n    )\\n        external\\n        view\\n        returns (uint256 totalSacrificeRewardsForToken)\\n    {\\n        Cycle storage cycle = cycles[cycleNumber];\\n        totalSacrificeRewardsForToken = cycle.totalSacrificeRewardsForToken[sacrificedToken];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL CLAIM LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _getReward(\\n        uint256 cycleNumber,\\n        Cycle storage _cycle,\\n        address _sacrificedToken\\n    )\\n        internal\\n        returns (uint256 rewardAmount)\\n    {\\n        uint256 coefficient = _cycle.coefficients[_sacrificedToken];\\n        uint256 stakeSacrificeRewards = rewards[msg.sender][cycleNumber][_sacrificedToken];\\n        (uint256 stakeReward, uint256 sacrificeReward) =\\n            _unpackStakeSacrificeRewards(stakeSacrificeRewards);\\n        rewards[msg.sender][cycleNumber][_sacrificedToken] = 0;\\n        rewardAmount = (sacrificeReward * coefficient / DENOMINATOR) + stakeReward;\\n    }\\n\\n    function _getRewardForCyclesTokens(\\n        uint256[] memory _cycles,\\n        address[] memory _sacrificedTokens\\n    )\\n        internal\\n        returns (uint256 totalRewardAmount)\\n    {\\n        for (uint256 i = 0; i < _cycles.length; i++) {\\n            Cycle storage cycle = cycles[_cycles[i]];\\n            if (\\n                cycle.cycleCompletedTimestamp == 0\\n                    || cycle.cycleCompletedTimestamp >= block.timestamp\\n            ) {\\n                revert CycleIsNotCompletedYet();\\n            }\\n            for (uint256 k = 0; k < _sacrificedTokens.length; k++) {\\n                address _sacrificedToken = _sacrificedTokens[k];\\n                uint256 rewardAmount = _getReward(_cycles[i], cycle, _sacrificedToken);\\n                totalRewardAmount += rewardAmount;\\n            }\\n        }\\n    }\\n\\n    function _transferReward(uint256 amount) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n        bloodline.transfer(msg.sender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Bloodline.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/IPoolInitializer.sol\\\";\\n\\n/// Permission to mint tokens is not exist.\\nerror NotAllowedToMint();\\n\\n/**\\n * @title Bloodline - an ERC20 token that is allowed to be minted only by `rewardLocker`.\\n */\\ncontract Bloodline is ERC20 {\\n    /// @notice Contract which is allowed to mint tokens.\\n    address public rewardLocker;\\n    /// @notice Uniswap V3 pool with 1% fee, underlying tokens: WETH and this.\\n    address public uniV3Pool;\\n\\n    /**\\n     * @notice Constructor initialize solmate ERC20 and deploys Uniswap V3 pool.\\n     * @param _weth address of WETH9 contract.\\n     * @param _nfPositionManager address of NonfungiblePositionManager (Uniswap V3) contract.\\n     * @param _sqrtPricesX96 an array of 2 initial prices for Uniswap V3 pool:\\n     *                       first price is picked if WETH9 is token1,\\n     *                       second price is picked if WETH9 is token0.\\n     */\\n    constructor(\\n        address _rewardLocker,\\n        address _weth,\\n        address _nfPositionManager,\\n        uint160[2] memory _sqrtPricesX96\\n    )\\n        ERC20(\\\"Bloodline\\\", \\\"BLOOD\\\", uint8(18))\\n    {\\n        rewardLocker = _rewardLocker;\\n        if (address(this) < _weth) {\\n            uniV3Pool = IPoolInitializer(_nfPositionManager).createAndInitializePoolIfNecessary(\\n                address(this), _weth, uint24(10_000), _sqrtPricesX96[0]\\n            );\\n        } else {\\n            uniV3Pool = IPoolInitializer(_nfPositionManager).createAndInitializePoolIfNecessary(\\n                _weth, address(this), uint24(10_000), _sqrtPricesX96[1]\\n            );\\n        }\\n        require(uniV3Pool != address(0));\\n    }\\n\\n    /**\\n     * @notice Method mints tokens.\\n     * @dev Method could be called only by `rewardLocker`.\\n     * @param account address which should receive newly minted tokens.\\n     * @param amount of tokens which should be minted.\\n     */\\n    function mintBloodline(address account, uint256 amount) external {\\n        if (msg.sender != rewardLocker) {\\n            revert NotAllowedToMint();\\n        }\\n        _mint(account, amount);\\n    }\\n\\n    /**\\n     * @notice Method burns tokens.\\n     * @param amount of tokens which should be burned.\\n     */\\n    function burn(uint256 amount) external returns (bool) {\\n        _burn(msg.sender, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/v3-periphery/contracts/interfaces/IPoolInitializer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\n/// @title Creates and initializes V3 Pools\\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\\n/// require the pool to exist.\\ninterface IPoolInitializer {\\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\\n    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\\n    /// @param token0 The contract address of token0 of the pool\\n    /// @param token1 The contract address of token1 of the pool\\n    /// @param fee The fee amount of the v3 pool for the specified token pair\\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\\n    function createAndInitializePoolIfNecessary(\\n        address token0,\\n        address token1,\\n        uint24 fee,\\n        uint160 sqrtPriceX96\\n    ) external payable returns (address pool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@uniswap/v3-core/=lib/v3-core/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"abdk/=lib/abdk-libraries-solidity/\",\r\n      \"@uniswap/v2-core/=lib/v2-core/\",\r\n      \"abdk-libraries-solidity/=lib/abdk-libraries-solidity/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"v2-core/=lib/v2-core/contracts/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CycleIsNotCompletedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMemeAltar\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakePartMoreThan100Percent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooEarlyToUnstake\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unsynchronized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winnerToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"totalCycleRewards\",\"type\":\"uint256\"}],\"name\":\"CycleCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"CycleStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakedCycle\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"name\":\"RewardStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"unstaker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"unstakeCycle\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"unstakedAmount\",\"type\":\"uint256\"}],\"name\":\"RewardUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Rewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"unstaker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"unstakeCycle\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"unstakedAmount\",\"type\":\"uint256\"}],\"name\":\"UnstakeOrdered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bloodline\",\"outputs\":[{\"internalType\":\"contract Bloodline\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_cycles\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_sacrificedTokens\",\"type\":\"address[]\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_cycles\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_cycles\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_sacrificedToken\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cycles\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"cycleCompletedTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"totalSacrificeCompetitionRewards\",\"type\":\"uint224\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devLiquidityHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sacrificedToken\",\"type\":\"address\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sacrificeReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"}],\"name\":\"getSacrificableTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sacrificedToken\",\"type\":\"address\"}],\"name\":\"getSacrificedTokenCoefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sacrificedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"getStakeRewardForSacrificeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"cycleNumbers\",\"type\":\"uint256[]\"}],\"name\":\"getTotalRewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSacrificeRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sacrificedToken\",\"type\":\"address\"}],\"name\":\"getTotalSacrificeRewardsForToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSacrificeRewardsForToken\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_memeAltar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bloodline\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devLiquidityHolder\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCompletedCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"memeAltar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakeCycle\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winnerToken\",\"type\":\"address\"}],\"name\":\"registerCycleCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleIndex\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"sacrificableTokens\",\"type\":\"address[]\"}],\"name\":\"registerNextCycle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sacrificedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"registerReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeCoefficient\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_cycles\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_sacrificedTokens\",\"type\":\"address[]\"}],\"name\":\"stakeAndClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stakeToBeSecured\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_cycles\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_sacrificedTokens\",\"type\":\"address[]\"}],\"name\":\"stakeToBeSecured\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeToBeSecured\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakeCycle\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unstakeOrdered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RewardLocker", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}