{"SourceCode": "pragma solidity 0.5.12;\r\n\r\n/**\r\n* @author XchangeON.\r\n*/\r\n\r\n/**\r\n* @title IERC223Token\r\n* @dev ERC223 Contract Interface\r\n*/\r\ncontract IERC223Token {\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function balanceOf(address who)public view returns (uint);\r\n}\r\n\r\n/**\r\n* @title ForwarderContract\r\n* @dev Contract that will forward any incoming Ether & token to wallet\r\n*/\r\ncontract ForwarderContract {\r\n    \r\n    address payable public parentAddress;\r\n \r\n    event ForwarderDeposited(address from, uint value, bytes data);\r\n    event TokensFlushed(address forwarderAddress, uint value, address tokenContractAddress);\r\n\r\n    /**\r\n    * @dev Modifier that will execute internal code block only if the sender is the parent address\r\n    */\r\n    modifier onlyParent {\r\n        require(msg.sender == parentAddress);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev Create the contract, and sets the destination address to that of the creator\r\n    */\r\n    constructor() public{\r\n        parentAddress = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Default function; Gets called when Ether is deposited, and forwards it to the parent address.\r\n    *      Credit eth to contract creator.\r\n    */\r\n    function() external payable {\r\n        parentAddress.transfer(msg.value);\r\n        emit ForwarderDeposited(msg.sender, msg.value, msg.data);\r\n    }\r\n\r\n    /**\r\n    * @dev Execute a token transfer of the full balance from the forwarder contract to the parent address\r\n    * @param _tokenContractAddress the address of the erc20 token contract\r\n    */\r\n    function flushDeposit(address _tokenContractAddress) public onlyParent {\r\n        IERC223Token instance = IERC223Token(_tokenContractAddress);\r\n        uint forwarderBalance = instance.balanceOf(address(this));\r\n        require(forwarderBalance > 0);\r\n        require(instance.transfer(parentAddress, forwarderBalance));\r\n        emit TokensFlushed(address(this), forwarderBalance, _tokenContractAddress);\r\n    }\r\n  \r\n    /**\r\n    * @dev Execute a specified token transfer from the forwarder contract to the parent address.\r\n    * @param _from the address of the erc20 token contract.\r\n    * @param _value the amount of token.\r\n    */\r\n    function flushAmountToken(address _from, uint _value) external{\r\n        require(IERC223Token(_from).transfer(parentAddress, _value), \"instance error\");\r\n    }\r\n\r\n    /**\r\n    * @dev It is possible that funds were sent to this address before the contract was deployed.\r\n    *      We can flush those funds to the parent address.\r\n    */\r\n    function flush() public {\r\n        parentAddress.transfer(address(this).balance);\r\n    }\r\n}\r\n\r\n/**\r\n* @title XchangeONWallet\r\n*/\r\ncontract XchangeONWallet {\r\n    \r\n    address[] public signers;\r\n    bool public safeMode; \r\n    uint private forwarderCount;\r\n    uint private lastNounce;\r\n    \r\n    event Deposited(address from, uint value, bytes data);\r\n    event SafeModeActivated(address msgSender);\r\n    event SafeModeInActivated(address msgSender);\r\n    event ForwarderCreated(address forwarderAddress);\r\n    event Transacted(address msgSender, address otherSigner, bytes32 operation, address toAddress, uint value, bytes data);\r\n    event TokensTransfer(address tokenContractAddress, uint value);\r\n    \r\n    /**\r\n    * @dev Modifier that will execute internal code block only if the \r\n    *      sender is an authorized signer on this wallet\r\n    */\r\n    modifier onlySigner {\r\n        require(validateSigner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Set up a simple multi-sig wallet by specifying the signers allowed to be used on this wallet.\r\n    *      2 signers will be required to send a transaction from this wallet.\r\n    *      Note: The sender is NOT automatically added to the list of signers.\r\n    *      Signers CANNOT be changed once they are set\r\n    * @param allowedSigners An array of signers on the wallet\r\n    */\r\n    constructor(address[] memory allowedSigners) public {\r\n        require(allowedSigners.length == 3);\r\n        signers = allowedSigners;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets called when a transaction is received without calling a method\r\n    */\r\n    function() external payable {\r\n        if(msg.value > 0){\r\n            emit Deposited(msg.sender, msg.value, msg.data);\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev Determine if an address is a signer on this wallet\r\n    * @param signer address to check\r\n    * @return boolean indicating whether address is signer or not\r\n    */\r\n    function validateSigner(address signer) public view returns (bool) {\r\n        for (uint i = 0; i < signers.length; i++) {\r\n            if (signers[i] == signer) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev Irrevocably puts contract into safe mode. When in this mode, \r\n    *      transactions may only be sent to signing addresses.\r\n    */\r\n    function activateSafeMode() public onlySigner {\r\n        require(!safeMode);\r\n        safeMode = true;\r\n        emit SafeModeActivated(msg.sender);\r\n    }\r\n    \r\n    /**\r\n    * @dev Irrevocably puts out contract into safe mode.\r\n    */ \r\n    function deactivateSafeMode() public onlySigner {\r\n        require(safeMode);\r\n        safeMode = false;\r\n        emit SafeModeInActivated(msg.sender);\r\n    }\r\n    \r\n    /**\r\n    * @dev Generate a new contract (and also address) that forwards deposite to this contract\r\n    *      returns address of newly created forwarder address\r\n    */\r\n    function generateForwarder() public returns (address) {\r\n        ForwarderContract f = new ForwarderContract();\r\n        forwarderCount += 1;\r\n        emit ForwarderCreated(address(f));\r\n        return(address(f));\r\n    }\r\n    \r\n    /**\r\n    * @dev for return No of forwarder generated. \r\n    * @return total number of generated forwarder count.\r\n    */\r\n    function totalForwarderCount() public view returns(uint){\r\n        return forwarderCount;\r\n    }\r\n    \r\n    /**\r\n    * @dev Execute a flushDeposit from one of the forwarder addresses.\r\n    * @param forwarderAddress the contract address of the forwarder address to flush the tokens from\r\n    * @param tokenContractAddress the address of the erc20 token contract\r\n    */\r\n    function flushForwarderDeposit(address payable forwarderAddress, address tokenContractAddress) public onlySigner {\r\n        ForwarderContract forwarder = ForwarderContract(forwarderAddress);\r\n        forwarder.flushDeposit(tokenContractAddress);\r\n    }\r\n    \r\n    /**\r\n    * @dev Gets the next available nounce for signing when using executeAndConfirm\r\n    * @return the nounce one higher than the highest currently stored\r\n    */\r\n    function getNonce() public view returns (uint) {\r\n        return lastNounce+1;\r\n    }\r\n    \r\n    /** \r\n    * @dev generate the hash for transferMultiSigEther\r\n    *      same parameter as transferMultiSigEther\r\n    * @return the hash generated by parameters \r\n    */\r\n    function generateEtherHash(address toAddress, uint value, bytes memory data, uint expireTime, uint nounce)public pure returns (bytes32){\r\n        return keccak256(abi.encodePacked(\"ETHER\", toAddress, value, data, expireTime, nounce));\r\n    }\r\n\r\n    /**\r\n    * @dev Execute a multi-signature transaction from this wallet using 2 signers: \r\n    *      one from msg.sender and the other from ecrecover.\r\n    *      nonce are numbers starting from 1. They are used to prevent replay \r\n    *      attacks and may not be repeated.\r\n    * @param toAddress the destination address to send an outgoing transaction\r\n    * @param value the amount in Wei to be sent\r\n    * @param data the data to send to the toAddress when invoking the transaction\r\n    * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n    * @param nounce the unique nounce obtainable from getNonce\r\n    * @param signature see Data Formats\r\n    */\r\n    function transferMultiSigEther(address payable toAddress, uint value, bytes memory data, uint expireTime, uint nounce, bytes memory signature) public payable onlySigner {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"ETHER\", toAddress, value, data, expireTime, nounce));\r\n        address otherSigner = verifyMultiSig(toAddress, operationHash, signature, expireTime, nounce);\r\n        toAddress.transfer(value);\r\n        emit Transacted(msg.sender, otherSigner, operationHash, toAddress, value, data);\r\n    }\r\n    \r\n    /** \r\n    * @dev generate the hash for transferMultiSigTokens.\r\n    *      same parameter as transferMultiSigTokens.\r\n    * @return the hash generated by parameters \r\n    */\r\n    function generateTokenHash( address toAddress, uint value, address tokenContractAddress, uint expireTime, uint nounce) public pure returns (bytes32){\r\n        return keccak256(abi.encodePacked(\"ERC20\", toAddress, value, tokenContractAddress, expireTime, nounce));\r\n    }\r\n  \r\n    /**\r\n    * @dev Execute a multi-signature token transfer from this wallet using 2 signers: \r\n    *      one from msg.sender and the other from ecrecover.\r\n    *      nounce are numbers starting from 1. They are used to prevent replay \r\n    *      attacks and may not be repeated.\r\n    * @param toAddress the destination address to send an outgoing transaction\r\n    * @param value the amount in tokens to be sent\r\n    * @param tokenContractAddress the address of the erc20 token contract\r\n    * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n    * @param nounce the unique nounce obtainable from getNonce\r\n    * @param signature see Data Formats\r\n    */\r\n    function transferMultiSigTokens(address toAddress, uint value, address tokenContractAddress, uint expireTime, uint nounce, bytes memory signature) public onlySigner {\r\n        bytes32 operationHash = keccak256(abi.encodePacked(\"ERC20\", toAddress, value, tokenContractAddress, expireTime, nounce));\r\n        verifyMultiSig(toAddress, operationHash, signature, expireTime, nounce);\r\n        IERC223Token instance = IERC223Token(tokenContractAddress);\r\n        require(instance.balanceOf(address(this)) > 0);\r\n        require(instance.transfer(toAddress, value));\r\n        emit TokensTransfer(tokenContractAddress, value);\r\n    }\r\n    \r\n    /**\r\n    * @dev Gets signer's address using ecrecover\r\n    * @param operationHash see Data Formats\r\n    * @param signature see Data Formats\r\n    * @return address recovered from the signature\r\n    */\r\n    function recoverAddressFromSignature(bytes32 operationHash, bytes memory signature) private pure returns (address) {\r\n        require(signature.length == 65);\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n        if (v < 27) {\r\n            v += 27; \r\n        }\r\n        return ecrecover(operationHash, v, r, s);\r\n    }\r\n\r\n    /**\r\n    * @dev Verify that the nonce has not been used before and inserts it. Throws if the nonce was not accepted.\r\n    * @param nounce to insert into array of stored ids\r\n    */\r\n    function validateNonce(uint nounce) private onlySigner {\r\n        require(nounce > lastNounce && nounce <= (lastNounce+1000), \"Enter Valid Nounce\");\r\n        lastNounce=nounce;\r\n    }\r\n\r\n    /** \r\n    * @dev Do common multisig verification for both eth sends and erc20token transfers\r\n    * @param toAddress the destination address to send an outgoing transaction\r\n    * @param operationHash see Data Formats\r\n    * @param signature see Data Formats\r\n    * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n    * @param nounce the unique nounce obtainable from getNonce\r\n    * @return address that has created the signature\r\n    */\r\n    function verifyMultiSig(address toAddress, bytes32 operationHash, bytes memory signature, uint expireTime, uint nounce) private returns (address) {\r\n\r\n        address otherSigner = recoverAddressFromSignature(operationHash, signature);\r\n        if (safeMode && !validateSigner(toAddress)) {\r\n            revert(\"safemode error\");\r\n        }\r\n        require(validateSigner(otherSigner) && expireTime > now);\r\n        require(otherSigner != msg.sender);\r\n        validateNonce(nounce);\r\n        return otherSigner;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"allowedSigners\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"forwarderAddress\",\"type\":\"address\"}],\"name\":\"ForwarderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"}],\"name\":\"SafeModeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"}],\"name\":\"SafeModeInActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokensTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transacted\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateSafeMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deactivateSafeMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"forwarderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"flushForwarderDeposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"}],\"name\":\"generateEtherHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"generateForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"}],\"name\":\"generateTokenHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safeMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalForwarderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferMultiSigEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nounce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferMultiSigTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"validateSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "XchangeONWallet", "CompilerVersion": "v0.5.12+commit.7709ece9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000030000000000000000000000008bbb47982f614f4df64c885fe5ddda5c158e619800000000000000000000000052f34871704ee7c152c75ba10546a52c78537f8f00000000000000000000000016aad4901ea17a148219cb459e4b377611323802", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://db7e6c489ba4f7cd85e9e1316c3e9263cff74ec418b8884b7148d5e371413f71"}