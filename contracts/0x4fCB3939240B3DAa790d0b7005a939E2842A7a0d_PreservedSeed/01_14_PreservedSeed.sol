// SPDX-License-Identifier: MIT
//
//                                                   ,                            
//             ,▓                              ,╓╗#▓▓▓╬╬╗@╦                      , 
//             ██⌐                          ,╔▓▓╣╬▓▓╬╬╬╬╣╬╬▓▒                  ▄██ 
//            ▐██▌                       ╔╬@╬╣▓▓╬╣▓▓▓╬╣╬╬╣▓▓╬▌                ▓███ 
//            ▐███                     ╔╬╬╬╬╬╣▓▓╣▓▓▓╬▓▓▓▓╣▓▓▓╬╬             ▄████  
//             ███▓                  ╒╣╣╬╬╬╬╬╣█╣▓▓▓╬▓▓╣▓╣▓▓▓▓▓▌            █████   
//             ╙████                @╣╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓╣█▓▓▓▓▓▓▌          ▄▓████▀    
//              ╟████▄     "╗,     ▓╬╬╬╬╬╬╬╣▓█▓█▓▓▓▓▓█▓▓▓▓▓▓▀         ▄██████`     
//               ▀████▓       ╙▀▄ ,▓▓▓▓▓▓▓╬╬█▓█▓█▓▓▓██▓▓▓█▓╙      ,▄▓██████▀       
//                ╙█████▓,       ╙█▓╬╬╣▓╬▓█▓╬███▓█▓██▓▓██▀     ,▄████████╨         
//     ,╔εσφφφφφMεε╦▓▓█████▄      ╫▓╬╬╬╣╣█▓█▓▓▓▓███████▀   ▄▓█████████▀            
//  @╬╬▓φφφφφφφ░░░░░░╙╙╚╚╩╬╬╬▀╗,  ╣▓╬╣╣╬▓▓▓╬╬╬╬╬╬╬▀▀▀╬╔≡▀▓▓███████▀▀               
//  └╫╬╬▒φφφφφ╦φφφ░░▒▒▒╠╬▓▒╚φ▒▒▒╠▓▓╣╬╬╬╣╣▓▓╨╚╬▒░░φ╣╬▌φ╦╦▒░░╙╙╚╙╚╩▒▒▒δφφ≥╔╓,        
//   ╘╬╬╬▒░░░φφφφφφ╗╣╬▒▒╩╠▒╣▒▒╬╬▓▓╬╬╠╠╬╣▓▓▓▒φδ▓▓▒φ░░░░▒╗▄φ░╙╙╚╚#φφφ░;░░░░╙╚╬╬▓ε    
//       ║╬╬▄φφφφ5░╙╫╬▒▄╗▒φ░▒▒▒▓▓╬╬╠╠╠╬╣╬▓▓▌5φ╙╚▒╙╚▒▒╩╢╩╚φφ░░╙╙êφφφ░░╙╚╚▒▒╣╬▀╨     
//       └╣╬╬"`"╚▒▒φ▒╙╙╠╫╬╦φê░╫▓╬╬╬╬╠╬╬╬╬▓▓▌╚φ╣▓▒░░╙╣▒φ╦▒5φ╥░╙Σφ╦░░░░▒▒╣▒╣╬╝       
//               ║╬╣▌▒▒░░φφδ░▒▓▓╬╬╬╬╬╬╬╣╬▓▓▌░φ░╙φ░╙δφ░╚╚╠▒▒╦▒╙Σ╦▄▒╚╣▓╣╝╝╨          
//                  ╝╬╣╣╬╣▒╩╣╣▓╣╬╬╬╬╣╣╬╬╣▓▓▓▓▄╬▒▒▄░▒▒░╟╣▒╚╚╣╬╬"╣╬╣  ╙              
//                       ╙    ╟▓╬╬╬╬╬╣╣╬▓▓████╜ ╙╝⌐└╙ ╙▀▀  └▀╜                     
//                             ▀███▓▓▓███████╨└                                    
//                               ╙██████████                                       
//                             m▓▓   └ └   ╙▄                                      
//                            `Å▐          j█▀≈ 
//
// ▄═╗▄m╗╕▓█▌           ═▄▄══▄▀█▌                            ▄▄ÆW▄ j█▌     ▐█▌
// ╙ ╫█▌ └╟█▌Æ█▄ ▄▓▀█µ   ██ ▄└▐█▌ ▄█▀▄,%█▌'██ ¥∩▄█▀▓,▄▓▄▓█  ██─  ╙ ▄▄▌a▄█▄█▐█▌,▄▀%▄
//   ╫█▌  ╟█▌j██▐██▀▀▀   ██¬▀ ▐█▌╟█▌ ██ ██▄╙█▄▌▐██▀▀▀╞█▌    ██⌐╙██▀▐█▌ ██  ▐█▌╙████
//  *╝▀▀⌐ ╝▀▀ª▀▀ ╙▀▀▀└  ═▀▀═  ╝▀▀ ▀▀4▀└  ▀┘ ╚▀  ╙▀▀▀─╧▀▀⌐    ╙▀W╝▀ ╝▀▀∞▀▀═ ╝▀▀╜▀═╝▀
//
// Preserved seeds smart contract created by Ryan Meyers for The Flower Girls
// Twitter: @FlowerGirlsNFT  Web: https://flowergirlsnft.com
//
// Contract allows minting of semi-fungible Polygon seeds as non-fungible art on Ethereum
//
// Generosity attracts generosity.
//
// The world will be saved by beauty.
//
//
pragma solidity ^0.8.16;

import "IERC2981.sol";
import "draft-EIP712.sol";
import "ERC721.sol";
import "Ownable.sol";
import "ECDSA.sol";
import "Strings.sol";

interface NFTInterface {
  function balanceOf(address account) external view returns (uint256);
}

contract PreservedSeed is IERC2981, EIP712, ERC721, Ownable {

  
  struct MintKey {
    uint32 seed_id;
    address wallet;
    uint256 cost;
    uint256 expires;
  }
  
  struct MintKey9 {
    uint32 seed_id_0;
    uint32 seed_id_1;
    uint32 seed_id_2;
    uint32 seed_id_3;
    uint32 seed_id_4;
    uint32 seed_id_5;
    uint32 seed_id_6;
    uint32 seed_id_7;
    uint32 seed_id_8;
    
    address wallet;
    uint256 cost;
    uint256 expires;
  }

  address private FG_CONTRACT;

  bytes32 private constant MINTKEY_TYPE_HASH = keccak256("MintKey(uint32 seed_id,address wallet,uint256 cost,uint256 expires)");
  bytes32 private constant MINTKEY_MULTI_TYPE_HASH = keccak256("MintKey9(uint32 seed_id_0,uint32 seed_id_1,uint32 seed_id_2,uint32 seed_id_3,uint32 seed_id_4,uint32 seed_id_5,uint32 seed_id_6,uint32 seed_id_7,uint32 seed_id_8,address wallet,uint256 cost,uint256 expires)");
  uint16 private _totalSupply;
  uint16 private _royaltyBPS;
  address private _signer;
  address private _treasury;
  string private _baseTokenURI;
  uint256 private _currentPrice;
  uint256 private _reserved;
  
  mapping(address => uint256) private _numPreserved;


  constructor(
    string memory name,
    string memory symbol,
    address signer,
    address treasury,
    uint16 royaltyBPS,
    string memory baseTokenURI,
    address fgs_contract
  )
    ERC721(name, symbol)
    EIP712(name, "1")
  {
        _signer = signer;
        _treasury = treasury;
        _royaltyBPS = royaltyBPS;
        _baseTokenURI = baseTokenURI;
        _reserved = 100;
        FG_CONTRACT = fgs_contract;
  }

  function pricePer() public view returns (uint256) {
    // Seeds from the reserves don't count against the totalSupply for pricing
    return 10000000000000000 + (128000000000000 * (_totalSupply - (100 - _reserved)));
  }

  function totalCost(address wallet, uint256 number) public view returns (uint256) {
    require(number > 0, "Cannot calculate cost for zero");
    uint256 fgs = max(NFTInterface(FG_CONTRACT).balanceOf(wallet), NFTInterface(FG_CONTRACT).balanceOf(msg.sender)) ;
    unchecked{
      if(fgs > _numPreserved[wallet]){
        if(fgs > _numPreserved[wallet] + number){
          return 10000000000000000 * number;
        }
        return (10000000000000000 * ((_numPreserved[wallet] + number) - fgs)) + (pricePer() * (number - ((_numPreserved[wallet] + number) - fgs)));
      }
      return number * pricePer();
    }
  }


  function preserveSeed(bytes calldata signature, MintKey calldata mintKey) external payable {
    require(msg.value >= mintKey.cost, "SENT AMOUNT TOO LOW");
    
    if (mintKey.expires < block.timestamp){
      require(mintKey.cost >= totalCost(mintKey.wallet, 1), "EXPIRED MINT KEY");
    }
    
    require(!hasSeedBeenPreserved(mintKey.seed_id), "SEED ALREADY MINTED");
      _safeMint(mintKey.wallet, mintKey.seed_id);
      _totalSupply++;
    
    require(verify(signature, mintKey), "INVALID MINT KEY");

      _numPreserved[mintKey.wallet]++;
      if(mintKey.wallet != msg.sender) {
        _numPreserved[msg.sender]++;
      }
      
      require(payable(_treasury).send(msg.value));

  }

  function preserveSeeds(bytes calldata signature, MintKey9 calldata mintKey) external payable {
    // check validity of signed message

    require(msg.value >= mintKey.cost, "SENT AMOUNT TOO LOW");

    uint8 number = 0;
    
    if(mintKey.seed_id_0 > 0){
      require(!hasSeedBeenPreserved(mintKey.seed_id_0), "SEED ALREADY MINTED");
      _safeMint(mintKey.wallet, mintKey.seed_id_0);
      
      number++;
      if(mintKey.seed_id_1 > 0){
        require(!hasSeedBeenPreserved(mintKey.seed_id_1), "SEED ALREADY MINTED");
        _safeMint(mintKey.wallet, mintKey.seed_id_1);
        
        number++;
        if(mintKey.seed_id_2 > 0){
          require(!hasSeedBeenPreserved(mintKey.seed_id_2), "SEED ALREADY MINTED");
          _safeMint(mintKey.wallet, mintKey.seed_id_2);
          
          number++;
          if(mintKey.seed_id_3 > 0){
            require(!hasSeedBeenPreserved(mintKey.seed_id_3), "SEED ALREADY MINTED");
            _safeMint(mintKey.wallet, mintKey.seed_id_3);
            
            number++;
            if(mintKey.seed_id_4 > 0){
              require(!hasSeedBeenPreserved(mintKey.seed_id_4), "SEED ALREADY MINTED");
              _safeMint(mintKey.wallet, mintKey.seed_id_4);
              
              number++;
              if(mintKey.seed_id_5 > 0){
                require(!hasSeedBeenPreserved(mintKey.seed_id_5), "SEED ALREADY MINTED");
                _safeMint(mintKey.wallet, mintKey.seed_id_5);
                
                number++;
                if(mintKey.seed_id_6 > 0){
                  require(!hasSeedBeenPreserved(mintKey.seed_id_6), "SEED ALREADY MINTED");
                  _safeMint(mintKey.wallet, mintKey.seed_id_6);
                  
                  number++;
                  if(mintKey.seed_id_7 > 0){
                    require(!hasSeedBeenPreserved(mintKey.seed_id_7), "SEED ALREADY MINTED");
                    _safeMint(mintKey.wallet, mintKey.seed_id_7);
                    
                    number++;
                    if(mintKey.seed_id_8 > 0){
                      require(!hasSeedBeenPreserved(mintKey.seed_id_8), "SEED ALREADY MINTED");
                      _safeMint(mintKey.wallet, mintKey.seed_id_8);
                      
                      number++;

                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    _totalSupply+=number;

    
    if (mintKey.expires < block.timestamp){
      require(mintKey.cost >= totalCost(mintKey.wallet, number), "EXPIRED MINT KEY");
    }
    
    require(verify9(signature, mintKey), "INVALID MINT KEY");

    _numPreserved[mintKey.wallet]+=number;
    if(mintKey.wallet != msg.sender) {
      _numPreserved[msg.sender]+=number;
    }
    
    require(payable(_treasury).send(msg.value));
    
    
  }


  function preserveReservedSeeds(uint32[] calldata seed_ids) external onlyOwner {
    require(seed_ids.length > 0 && seed_ids.length <= _reserved, "NOT ENOUGH RESERVES REMAINING");

    for(uint256 i = 0; i < seed_ids.length; i++){
      require(!hasSeedBeenPreserved(seed_ids[i]), "SEED ALREADY MINTED");
      _safeMint(owner(), seed_ids[i]);
      _totalSupply++;
    }

    _reserved -= seed_ids.length;
  }

  function burnSeeds(uint32[] calldata seed_ids) external {
    for(uint256 i = 0; i < seed_ids.length; i++){
      require(_isApprovedOrOwner(msg.sender, seed_ids[i]), "NOT APPROVED FOR SEED ID");
      _burn(seed_ids[i]);
      _totalSupply--;
    }
  }

  
  function verify(bytes calldata signature, MintKey calldata mintKey) public view returns (bool) {
    bytes32 digest = _hashTypedDataV4(
        keccak256(
            abi.encode(
                MINTKEY_TYPE_HASH,
                mintKey.seed_id,
                mintKey.wallet,
                mintKey.cost,
                mintKey.expires
            )
        )
    );

    return ECDSA.recover(digest, signature) == _signer;
  }


  function verify9(bytes calldata signature, MintKey9 calldata mintKey) internal view returns (bool) {
    bytes32 digest = _hashTypedDataV4(
        keccak256(
            abi.encode(
                MINTKEY_MULTI_TYPE_HASH,
                mintKey.seed_id_0,
                mintKey.seed_id_1,
                mintKey.seed_id_2,
                mintKey.seed_id_3,
                mintKey.seed_id_4,
                mintKey.seed_id_5,
                mintKey.seed_id_6,
                mintKey.seed_id_7,
                mintKey.seed_id_8,
                mintKey.wallet,
                mintKey.cost,
                mintKey.expires
            )
        )
    );

    return ECDSA.recover(digest, signature) == _signer;
  }

  function hasSeedBeenPreserved(uint32 seed_id) public view returns (bool) {
    return _exists(seed_id);
  }

  function hasPreservedSeed(address wallet) public view returns (bool) {
    return _numPreserved[wallet] > 0;
  }

  function setBaseTokenURI(string calldata baseTokenURI) external onlyOwner {
      _baseTokenURI = baseTokenURI;
  }

  function totalSupply() public view returns (uint16) {
        return _totalSupply;
  }

  function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        return string(abi.encodePacked(_baseTokenURI, Strings.toString(tokenId), ".json"));
  }

  function supportsInterface(bytes4 _interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {
        return _interfaceId == type(IERC2981).interfaceId || super.supportsInterface(_interfaceId);
  }

  function setTreasury(address wallet) public onlyOwner {
    _treasury = wallet;
  }

  function setRoyaltyBPS(uint16 royaltyBPS_) public onlyOwner {
    _royaltyBPS = royaltyBPS_;
  }

  function royaltyInfo(uint256 /* _tokenId */, uint256 _salePrice) external view override returns (address, uint256) {
        return (_treasury, ((_salePrice * _royaltyBPS) / 10000));
  }

  function withdraw() public payable {
    require(payable(_treasury).send(address(this).balance));
  }

  function getChainId() external view returns (uint256) {
        return block.chainid;
  }

  function domainSeparator() external view returns (bytes32) {
        return _domainSeparatorV4();
  }

  function max(uint256 a, uint256 b) internal pure returns (uint256) {
    return a >= b ? a : b;
  }

  receive() external payable {
    if(msg.value > 0){
      require(payable(_treasury).send(msg.value));
    }
  }

  fallback() external payable {
    if(msg.value > 0){
      require(payable(_treasury).send(msg.value));
    }
  }

}