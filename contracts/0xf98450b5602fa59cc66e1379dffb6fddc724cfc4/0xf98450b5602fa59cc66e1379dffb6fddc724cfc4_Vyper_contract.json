{"SourceCode": "# @version 0.2.5\r\n\"\"\"\r\n@title Liquidity Gauge\r\n@author Curve Finance\r\n@license MIT\r\n@notice Used for measuring liquidity and insurance\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface CRV20:\r\n    def future_epoch_time_write() -> uint256: nonpayable\r\n    def rate() -> uint256: view\r\n\r\ninterface Controller:\r\n    def period() -> int128: view\r\n    def period_write() -> int128: nonpayable\r\n    def period_timestamp(p: int128) -> uint256: view\r\n    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\r\n    def voting_escrow() -> address: view\r\n    def checkpoint(): nonpayable\r\n    def checkpoint_gauge(addr: address): nonpayable\r\n\r\ninterface Minter:\r\n    def token() -> address: view\r\n    def controller() -> address: view\r\n    def minted(user: address, gauge: address) -> uint256: view\r\n\r\ninterface VotingEscrow:\r\n    def user_point_epoch(addr: address) -> uint256: view\r\n    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\r\n\r\n\r\nevent Deposit:\r\n    provider: indexed(address)\r\n    value: uint256\r\n\r\nevent Withdraw:\r\n    provider: indexed(address)\r\n    value: uint256\r\n\r\nevent UpdateLiquidityLimit:\r\n    user: address\r\n    original_balance: uint256\r\n    original_supply: uint256\r\n    working_balance: uint256\r\n    working_supply: uint256\r\n\r\nevent CommitOwnership:\r\n    admin: address\r\n\r\nevent ApplyOwnership:\r\n    admin: address\r\n\r\n\r\nTOKENLESS_PRODUCTION: constant(uint256) = 40\r\nBOOST_WARMUP: constant(uint256) = 2 * 7 * 86400\r\nWEEK: constant(uint256) = 604800\r\n\r\nminter: public(address)\r\ncrv_token: public(address)\r\nlp_token: public(address)\r\ncontroller: public(address)\r\nvoting_escrow: public(address)\r\nbalanceOf: public(HashMap[address, uint256])\r\ntotalSupply: public(uint256)\r\nfuture_epoch_time: public(uint256)\r\n\r\n# caller -> recipient -> can deposit?\r\napproved_to_deposit: public(HashMap[address, HashMap[address, bool]])\r\n\r\nworking_balances: public(HashMap[address, uint256])\r\nworking_supply: public(uint256)\r\n\r\n# The goal is to be able to calculate \u222b(rate * balance / totalSupply dt) from 0 till checkpoint\r\n# All values are kept in units of being multiplied by 1e18\r\nperiod: public(int128)\r\nperiod_timestamp: public(uint256[100000000000000000000000000000])\r\n\r\n# 1e18 * \u222b(rate(t) / totalSupply(t) dt) from 0 till checkpoint\r\nintegrate_inv_supply: public(uint256[100000000000000000000000000000])  # bump epoch when rate() changes\r\n\r\n# 1e18 * \u222b(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\r\nintegrate_inv_supply_of: public(HashMap[address, uint256])\r\nintegrate_checkpoint_of: public(HashMap[address, uint256])\r\n\r\n\r\n# \u222b(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\r\n# Units: rate * t = already number of coins per address to issue\r\nintegrate_fraction: public(HashMap[address, uint256])\r\n\r\ninflation_rate: public(uint256)\r\n\r\nadmin: public(address)\r\nfuture_admin: public(address)  # Can and will be a smart contract\r\nis_killed: public(bool)\r\n\r\n\r\n@external\r\ndef __init__(lp_addr: address, _minter: address, _admin: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param lp_addr Liquidity Pool contract address\r\n    @param _minter Minter contract address\r\n    @param _admin Admin who can kill the gauge\r\n    \"\"\"\r\n\r\n    assert lp_addr != ZERO_ADDRESS\r\n    assert _minter != ZERO_ADDRESS\r\n\r\n    self.lp_token = lp_addr\r\n    self.minter = _minter\r\n    crv_addr: address = Minter(_minter).token()\r\n    self.crv_token = crv_addr\r\n    controller_addr: address = Minter(_minter).controller()\r\n    self.controller = controller_addr\r\n    self.voting_escrow = Controller(controller_addr).voting_escrow()\r\n    self.period_timestamp[0] = block.timestamp\r\n    self.inflation_rate = CRV20(crv_addr).rate()\r\n    self.future_epoch_time = CRV20(crv_addr).future_epoch_time_write()\r\n    self.admin = _admin\r\n\r\n\r\n@internal\r\ndef _update_liquidity_limit(addr: address, l: uint256, L: uint256):\r\n    \"\"\"\r\n    @notice Calculate limits which depend on the amount of CRV token per-user.\r\n            Effectively it calculates working balances to apply amplification\r\n            of CRV production by CRV\r\n    @param addr User address\r\n    @param l User's amount of liquidity (LP tokens)\r\n    @param L Total amount of liquidity (LP tokens)\r\n    \"\"\"\r\n    # To be called after totalSupply is updated\r\n    _voting_escrow: address = self.voting_escrow\r\n    voting_balance: uint256 = ERC20(_voting_escrow).balanceOf(addr)\r\n    voting_total: uint256 = ERC20(_voting_escrow).totalSupply()\r\n\r\n    lim: uint256 = l * TOKENLESS_PRODUCTION / 100\r\n    if (voting_total > 0) and (block.timestamp > self.period_timestamp[0] + BOOST_WARMUP):\r\n        lim += L * voting_balance / voting_total * (100 - TOKENLESS_PRODUCTION) / 100\r\n\r\n    lim = min(l, lim)\r\n    old_bal: uint256 = self.working_balances[addr]\r\n    self.working_balances[addr] = lim\r\n    _working_supply: uint256 = self.working_supply + lim - old_bal\r\n    self.working_supply = _working_supply\r\n\r\n    log UpdateLiquidityLimit(addr, l, L, lim, _working_supply)\r\n\r\n\r\n@internal\r\ndef _checkpoint(addr: address):\r\n    \"\"\"\r\n    @notice Checkpoint for a user\r\n    @param addr User address\r\n    \"\"\"\r\n    _token: address = self.crv_token\r\n    _controller: address = self.controller\r\n    _period: int128 = self.period\r\n    _period_time: uint256 = self.period_timestamp[_period]\r\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\r\n    rate: uint256 = self.inflation_rate\r\n    new_rate: uint256 = rate\r\n    prev_future_epoch: uint256 = self.future_epoch_time\r\n    if prev_future_epoch >= _period_time:\r\n        self.future_epoch_time = CRV20(_token).future_epoch_time_write()\r\n        new_rate = CRV20(_token).rate()\r\n        self.inflation_rate = new_rate\r\n    Controller(_controller).checkpoint_gauge(self)\r\n\r\n    _working_balance: uint256 = self.working_balances[addr]\r\n    _working_supply: uint256 = self.working_supply\r\n\r\n    if self.is_killed:\r\n        # Stop distributing inflation as soon as killed\r\n        rate = 0\r\n\r\n    # Update integral of 1/supply\r\n    if block.timestamp > _period_time:\r\n        prev_week_time: uint256 = _period_time\r\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\r\n\r\n        for i in range(500):\r\n            dt: uint256 = week_time - prev_week_time\r\n            w: uint256 = Controller(_controller).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\r\n\r\n            if _working_supply > 0:\r\n                if prev_future_epoch >= prev_week_time and prev_future_epoch < week_time:\r\n                    # If we went across one or multiple epochs, apply the rate\r\n                    # of the first epoch until it ends, and then the rate of\r\n                    # the last epoch.\r\n                    # If more than one epoch is crossed - the gauge gets less,\r\n                    # but that'd meen it wasn't called for more than 1 year\r\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\r\n                    rate = new_rate\r\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\r\n                else:\r\n                    _integrate_inv_supply += rate * w * dt / _working_supply\r\n                # On precisions of the calculation\r\n                # rate ~= 10e18\r\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\r\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\r\n                # The largest loss is at dt = 1\r\n                # Loss is 1e-9 - acceptable\r\n\r\n            if week_time == block.timestamp:\r\n                break\r\n            prev_week_time = week_time\r\n            week_time = min(week_time + WEEK, block.timestamp)\r\n\r\n    _period += 1\r\n    self.period = _period\r\n    self.period_timestamp[_period] = block.timestamp\r\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\r\n\r\n    # Update user-specific integrals\r\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\r\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\r\n    self.integrate_checkpoint_of[addr] = block.timestamp\r\n\r\n\r\n@external\r\ndef user_checkpoint(addr: address) -> bool:\r\n    \"\"\"\r\n    @notice Record a checkpoint for `addr`\r\n    @param addr User address\r\n    @return bool success\r\n    \"\"\"\r\n    assert (msg.sender == addr) or (msg.sender == self.minter)  # dev: unauthorized\r\n    self._checkpoint(addr)\r\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\r\n    return True\r\n\r\n\r\n@external\r\ndef claimable_tokens(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the number of claimable tokens per user\r\n    @dev This function should be manually changed to \"view\" in the ABI\r\n    @return uint256 number of claimable tokens per user\r\n    \"\"\"\r\n    self._checkpoint(addr)\r\n    return self.integrate_fraction[addr] - Minter(self.minter).minted(addr, self)\r\n\r\n\r\n@external\r\ndef kick(addr: address):\r\n    \"\"\"\r\n    @notice Kick `addr` for abusing their boost\r\n    @dev Only if either they had another voting event, or their voting escrow lock expired\r\n    @param addr Address to kick\r\n    \"\"\"\r\n    _voting_escrow: address = self.voting_escrow\r\n    t_last: uint256 = self.integrate_checkpoint_of[addr]\r\n    t_ve: uint256 = VotingEscrow(_voting_escrow).user_point_history__ts(\r\n        addr, VotingEscrow(_voting_escrow).user_point_epoch(addr)\r\n    )\r\n    _balance: uint256 = self.balanceOf[addr]\r\n\r\n    assert ERC20(self.voting_escrow).balanceOf(addr) == 0 or t_ve > t_last # dev: kick not allowed\r\n    assert self.working_balances[addr] > _balance * TOKENLESS_PRODUCTION / 100  # dev: kick not needed\r\n\r\n    self._checkpoint(addr)\r\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\r\n\r\n\r\n@external\r\ndef set_approve_deposit(addr: address, can_deposit: bool):\r\n    \"\"\"\r\n    @notice Set whether `addr` can deposit tokens for `msg.sender`\r\n    @param addr Address to set approval on\r\n    @param can_deposit bool - can this account deposit for `msg.sender`?\r\n    \"\"\"\r\n    self.approved_to_deposit[addr][msg.sender] = can_deposit\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef deposit(_value: uint256, addr: address = msg.sender):\r\n    \"\"\"\r\n    @notice Deposit `_value` LP tokens\r\n    @param _value Number of tokens to deposit\r\n    @param addr Address to deposit for\r\n    \"\"\"\r\n    if addr != msg.sender:\r\n        assert self.approved_to_deposit[msg.sender][addr], \"Not approved\"\r\n\r\n    self._checkpoint(addr)\r\n\r\n    if _value != 0:\r\n        _balance: uint256 = self.balanceOf[addr] + _value\r\n        _supply: uint256 = self.totalSupply + _value\r\n        self.balanceOf[addr] = _balance\r\n        self.totalSupply = _supply\r\n\r\n        self._update_liquidity_limit(addr, _balance, _supply)\r\n\r\n        assert ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\r\n\r\n    log Deposit(addr, _value)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw(_value: uint256):\r\n    \"\"\"\r\n    @notice Withdraw `_value` LP tokens\r\n    @param _value Number of tokens to withdraw\r\n    \"\"\"\r\n    self._checkpoint(msg.sender)\r\n\r\n    _balance: uint256 = self.balanceOf[msg.sender] - _value\r\n    _supply: uint256 = self.totalSupply - _value\r\n    self.balanceOf[msg.sender] = _balance\r\n    self.totalSupply = _supply\r\n\r\n    self._update_liquidity_limit(msg.sender, _balance, _supply)\r\n\r\n    assert ERC20(self.lp_token).transfer(msg.sender, _value)\r\n\r\n    log Withdraw(msg.sender, _value)\r\n\r\n\r\n@external\r\n@view\r\ndef integrate_checkpoint() -> uint256:\r\n    return self.period_timestamp[self.period]\r\n\r\n\r\n@external\r\ndef kill_me():\r\n    assert msg.sender == self.admin\r\n    self.is_killed = not self.is_killed\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of GaugeController to `addr`\r\n    @param addr Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.future_admin = addr\r\n    log CommitOwnership(addr)\r\n\r\n\r\n@external\r\ndef apply_transfer_ownership():\r\n    \"\"\"\r\n    @notice Apply pending ownership transfer\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    _admin: address = self.future_admin\r\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\r\n    self.admin = _admin\r\n    log ApplyOwnership(_admin)", "ABI": "[{\"name\":\"Deposit\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"type\":\"address\",\"name\":\"provider\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateLiquidityLimit\",\"inputs\":[{\"type\":\"address\",\"name\":\"user\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"original_balance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"original_supply\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"working_balance\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"working_supply\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitOwnership\",\"inputs\":[{\"type\":\"address\",\"name\":\"admin\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyOwnership\",\"inputs\":[{\"type\":\"address\",\"name\":\"admin\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"lp_addr\"},{\"type\":\"address\",\"name\":\"_minter\"},{\"type\":\"address\",\"name\":\"_admin\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"user_checkpoint\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":2070408},{\"name\":\"claimable_tokens\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":1989612},{\"name\":\"kick\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":2075769},{\"name\":\"set_approve_deposit\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"},{\"type\":\"bool\",\"name\":\"can_deposit\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":35801},{\"name\":\"deposit\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"deposit\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_value\"},{\"type\":\"address\",\"name\":\"addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"name\":\"withdraw\",\"outputs\":[],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":2199513},{\"name\":\"integrate_checkpoint\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2207},{\"name\":\"kill_me\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37188},{\"name\":\"commit_transfer_ownership\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37868},{\"name\":\"apply_transfer_ownership\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38707},{\"name\":\"minter\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1421},{\"name\":\"crv_token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1451},{\"name\":\"lp_token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1481},{\"name\":\"controller\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1511},{\"name\":\"voting_escrow\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1541},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1786},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1601},{\"name\":\"future_epoch_time\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1631},{\"name\":\"approved_to_deposit\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"},{\"type\":\"address\",\"name\":\"arg1\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2091},{\"name\":\"working_balances\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1906},{\"name\":\"working_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1721},{\"name\":\"period\",\"outputs\":[{\"type\":\"int128\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1751},{\"name\":\"period_timestamp\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1890},{\"name\":\"integrate_inv_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1920},{\"name\":\"integrate_inv_supply_of\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2056},{\"name\":\"integrate_checkpoint_of\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2086},{\"name\":\"integrate_fraction\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2116},{\"name\":\"inflation_rate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1931},{\"name\":\"admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1961},{\"name\":\"future_admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1991},{\"name\":\"is_killed\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2021}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.2.5", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000d2967f45c4f384deea880f807be904762a3dea07000000000000000000000000d061d61a4d941c39e5453435b6345dc261c2fce00000000000000000000000007eeac6cddbd1d0b8af061742d41877d7f707289a", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}