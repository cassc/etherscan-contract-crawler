{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/settled-cash/CrossMarginCashMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {SafeCast} from \\\"openzeppelin/utils/math/SafeCast.sol\\\";\\nimport {UintArrayLib} from \\\"array-lib/UintArrayLib.sol\\\";\\nimport {IntArrayLib} from \\\"array-lib/IntArrayLib.sol\\\";\\nimport {QuickSort} from \\\"array-lib/sorting/QuickSort.sol\\\";\\n\\nimport {IGrappa} from \\\"grappa/interfaces/IGrappa.sol\\\";\\nimport {IOracle} from \\\"grappa/interfaces/IOracle.sol\\\";\\n\\nimport {BytesArrayUtil} from \\\"../libraries/BytesArrayUtil.sol\\\";\\n\\n// shard libraries\\nimport {NumberUtil} from \\\"grappa/libraries/NumberUtil.sol\\\";\\nimport {ProductIdUtil} from \\\"grappa/libraries/ProductIdUtil.sol\\\";\\nimport {TokenIdUtil} from \\\"grappa/libraries/TokenIdUtil.sol\\\";\\nimport {BalanceUtil} from \\\"grappa/libraries/BalanceUtil.sol\\\";\\n\\n// cross margin libraries\\nimport {AccountUtil} from \\\"../libraries/AccountUtil.sol\\\";\\n\\n// Cross margin types\\nimport \\\"./types.sol\\\";\\nimport \\\"../config/errors.sol\\\";\\n\\nimport {ProductDetails} from \\\"grappa/config/types.sol\\\";\\nimport \\\"grappa/config/constants.sol\\\";\\nimport \\\"grappa/config/enums.sol\\\";\\nimport \\\"grappa/config/errors.sol\\\";\\n\\n/**\\n * @title   CrossMarginCashMath\\n * @notice  this library is in charge of calculating the min collateral for a given cross margin account\\n * @dev     deployed as a separate contract to save space\\n */\\nlibrary CrossMarginCashMath {\\n    using BalanceUtil for Balance[];\\n    using AccountUtil for CrossMarginDetail[];\\n    using AccountUtil for Position[];\\n    using UintArrayLib for uint256[];\\n    using IntArrayLib for int256[];\\n    using QuickSort for uint256[];\\n    using SafeCast for int256;\\n    using SafeCast for uint256;\\n    using TokenIdUtil for uint256;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         Portfolio Margin Requirements\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice get minimum collateral for a given amount of shorts & longs\\n     * @dev typically used for calculating a portfolios margin requirements\\n     * @param grappa interface to query grappa contract\\n     * @param shorts is array of Position structs\\n     * @param longs is array of Position structs\\n     * @return amounts is an array of Balance struct representing full collateralization\\n     */\\n    function getMinCollateralForPositions(IGrappa grappa, Position[] calldata shorts, Position[] calldata longs)\\n        external\\n        view\\n        returns (Balance[] memory amounts)\\n    {\\n        // groups shorts and longs by underlying + strike + collateral + expiry\\n        CrossMarginDetail[] memory details = _getPositionDetails(grappa, shorts, longs);\\n\\n        // portfolio has no longs or shorts\\n        if (details.length == 0) return amounts;\\n\\n        bool found;\\n        uint256 index;\\n\\n        for (uint256 i; i < details.length;) {\\n            CrossMarginDetail memory detail = details[i];\\n\\n            // checks that the combination has positions, otherwise skips\\n            if (detail.callWeights.length != 0 || detail.putWeights.length != 0) {\\n                // gets the amount of numeraire and underlying needed\\n                (uint256 numeraireNeeded, uint256 underlyingNeeded) = getMinCollateral(detail);\\n\\n                if (numeraireNeeded > 0) {\\n                    (found, index) = amounts.indexOf(detail.numeraireId);\\n\\n                    if (found) amounts[index].amount += numeraireNeeded.toUint80();\\n                    else amounts = amounts.append(Balance(detail.numeraireId, numeraireNeeded.toUint80()));\\n                }\\n\\n                if (underlyingNeeded > 0) {\\n                    (found, index) = amounts.indexOf(detail.underlyingId);\\n\\n                    if (found) amounts[index].amount += underlyingNeeded.toUint80();\\n                    else amounts = amounts.append(Balance(detail.underlyingId, underlyingNeeded.toUint80()));\\n                }\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         Cross Margin Calculations\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice get minimum collateral\\n     * @dev detail is composed of positions with the same underlying + strike + expiry\\n     * @param _detail margin details\\n     * @return numeraireNeeded with {numeraire asset's} decimals\\n     * @return underlyingNeeded with {underlying asset's} decimals\\n     */\\n    function getMinCollateral(CrossMarginDetail memory _detail)\\n        public\\n        pure\\n        returns (uint256 numeraireNeeded, uint256 underlyingNeeded)\\n    {\\n        _verifyInputs(_detail);\\n\\n        (uint256[] memory scenarios, int256[] memory payouts) = _getScenariosAndPayouts(_detail);\\n\\n        (numeraireNeeded, underlyingNeeded) = _getCollateralNeeds(_detail, scenarios, payouts);\\n\\n        // if options collateralized in underlying, forcing numeraire to be converted to underlying\\n        // only applied to calls since puts cannot be collateralized in underlying\\n        if (numeraireNeeded > 0 && _detail.putStrikes.length == 0) {\\n            numeraireNeeded = 0;\\n\\n            underlyingNeeded = _convertCallNumeraireToUnderlying(scenarios, payouts, underlyingNeeded);\\n        } else {\\n            numeraireNeeded = NumberUtil.convertDecimals(numeraireNeeded, UNIT_DECIMALS, _detail.numeraireDecimals);\\n        }\\n\\n        underlyingNeeded = NumberUtil.convertDecimals(underlyingNeeded, UNIT_DECIMALS, _detail.underlyingDecimals);\\n    }\\n\\n    /**\\n     * @notice checks inputs for calculating margin, reverts if bad inputs\\n     * @param _detail margin details\\n     */\\n    function _verifyInputs(CrossMarginDetail memory _detail) internal pure {\\n        if (_detail.callStrikes.length != _detail.callWeights.length) revert CMM_InvalidCallLengths();\\n        if (_detail.putStrikes.length != _detail.putWeights.length) revert CMM_InvalidPutLengths();\\n\\n        uint256 i;\\n        for (i; i < _detail.putWeights.length;) {\\n            if (_detail.putWeights[i] == 0) revert CMM_InvalidPutWeight();\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        for (i = 0; i < _detail.callWeights.length;) {\\n            if (_detail.callWeights[i] == 0) revert CMM_InvalidCallWeight();\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice setting up values needed to calculate margin requirements\\n     * @param _detail margin details\\n     * @return scenarios array of all the strikes\\n     * @return payouts payouts for a given scenario\\n     */\\n    function _getScenariosAndPayouts(CrossMarginDetail memory _detail)\\n        internal\\n        pure\\n        returns (uint256[] memory scenarios, int256[] memory payouts)\\n    {\\n        bool hasPuts = _detail.putStrikes.length > 0;\\n        bool hasCalls = _detail.callStrikes.length > 0;\\n\\n        scenarios = _detail.putStrikes.concat(_detail.callStrikes);\\n        scenarios.sort(); // sort in memory\\n\\n        // payouts at each scenario (strike)\\n        payouts = new int256[](scenarios.length);\\n\\n        uint256 lastScenario;\\n\\n        for (uint256 i; i < scenarios.length;) {\\n            // deduping scenarios, leaving payout as 0\\n            if (scenarios[i] != lastScenario) {\\n                if (hasPuts) {\\n                    payouts[i] = _detail.putStrikes.subEachBy(scenarios[i]).maximum(0).dot(_detail.putWeights) / sUNIT;\\n                }\\n\\n                if (hasCalls) {\\n                    payouts[i] += _detail.callStrikes.subEachFrom(scenarios[i]).maximum(0).dot(_detail.callWeights) / sUNIT;\\n                }\\n\\n                lastScenario = scenarios[i];\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice get numeraire and underlying needed to fully collateralize\\n     * @dev calculates left side and right side of the payout profile\\n     * @param _detail margin details\\n     * @param scenarios of all the options\\n     * @param payouts are the payouts at a given scenario\\n     * @return numeraireNeeded with {numeraire asset's} decimals\\n     * @return underlyingNeeded with {underlying asset's} decimals\\n     */\\n    function _getCollateralNeeds(CrossMarginDetail memory _detail, uint256[] memory scenarios, int256[] memory payouts)\\n        internal\\n        pure\\n        returns (uint256 numeraireNeeded, uint256 underlyingNeeded)\\n    {\\n        bool hasPuts = _detail.putStrikes.length > 0;\\n        bool hasCalls = _detail.callStrikes.length > 0;\\n\\n        (int256 minPayout, uint256 minPayoutIndex) = payouts.minWithIndex();\\n\\n        // if put options exist, get amount of numeraire needed (left side of payout profile)\\n        if (hasPuts) numeraireNeeded = _getNumeraireNeeded(minPayout, _detail.putStrikes, _detail.putWeights);\\n\\n        // if call options exist, get amount of underlying needed (right side of payout profile)\\n        if (hasCalls) underlyingNeeded = _getUnderlyingNeeded(_detail.callWeights);\\n\\n        // crediting the numeraire if underlying has a positive payout\\n        numeraireNeeded =\\n            _getUnderlyingAdjustedNumeraireNeeded(scenarios, minPayout, minPayoutIndex, numeraireNeeded, underlyingNeeded);\\n    }\\n\\n    /**\\n     * @notice calculates the amount of numeraire is needed for put options\\n     * @dev only called if there are put options, usually denominated in cash\\n     * @param minPayout minimum payout across scenarios\\n     * @param putStrikes put option strikes\\n     * @param putWeights number of put options at a corresponding strike\\n     * @return numeraireNeeded amount of numeraire asset needed\\n     */\\n    function _getNumeraireNeeded(int256 minPayout, uint256[] memory putStrikes, int256[] memory putWeights)\\n        internal\\n        pure\\n        returns (uint256 numeraireNeeded)\\n    {\\n        int256 _numeraireNeeded = putStrikes.dot(putWeights) / sUNIT;\\n\\n        if (_numeraireNeeded > minPayout) _numeraireNeeded = minPayout;\\n\\n        if (_numeraireNeeded < 0) numeraireNeeded = uint256(-_numeraireNeeded);\\n    }\\n\\n    /**\\n     * @notice calculates the amount of underlying is needed for call options\\n     * @dev only called if there are call options\\n     * @param callWeights number of call options at a coorisponding strike\\n     * @return underlyingNeeded amount of underlying needed\\n     */\\n    function _getUnderlyingNeeded(int256[] memory callWeights) internal pure returns (uint256 underlyingNeeded) {\\n        int256 totalCalls = callWeights.sum();\\n\\n        if (totalCalls < 0) underlyingNeeded = uint256(-totalCalls);\\n    }\\n\\n    /**\\n     * @notice crediting the numeraire if underlying has a positive payout\\n     * @dev checks if subAccount has positive underlying value, if it does then cash requirements can be lowered\\n     * @param scenarios of all the options\\n     * @param minPayout minimum payout across scenarios\\n     * @param minPayoutIndex minimum payout across scenarios index\\n     * @param numeraireNeeded current numeraire needed\\n     * @param underlyingNeeded underlying needed\\n     * @return numeraireNeeded adjusted numeraire needed\\n     */\\n    function _getUnderlyingAdjustedNumeraireNeeded(\\n        uint256[] memory scenarios,\\n        int256 minPayout,\\n        uint256 minPayoutIndex,\\n        uint256 numeraireNeeded,\\n        uint256 underlyingNeeded\\n    ) internal pure returns (uint256) {\\n        // negating to focus on negative payouts which require positive collateral\\n        minPayout = -minPayout;\\n\\n        if (numeraireNeeded.toInt256() < minPayout) {\\n            uint256 underlyingPayoutAtMinStrike = (scenarios[minPayoutIndex] * underlyingNeeded) / UNIT;\\n\\n            if (underlyingPayoutAtMinStrike.toInt256() > minPayout) {\\n                numeraireNeeded = 0;\\n            } else {\\n                // check directly above means minPayout > underlyingPayoutAtMinStrike\\n                numeraireNeeded = uint256(minPayout) - underlyingPayoutAtMinStrike;\\n            }\\n        }\\n\\n        return numeraireNeeded;\\n    }\\n\\n    /**\\n     * @notice converts numeraire needed entirely in underlying\\n     * @dev only used if options collateralized in underlying\\n     * @param scenarios of all the options\\n     * @param payouts payouts at corresponding scenarios\\n     * @param underlyingNeeded current underlying needed\\n     * @return underlyingOnlyNeeded adjusted underlying needed\\n     */\\n    function _convertCallNumeraireToUnderlying(uint256[] memory scenarios, int256[] memory payouts, uint256 underlyingNeeded)\\n        internal\\n        pure\\n        returns (uint256 underlyingOnlyNeeded)\\n    {\\n        int256 maxPayoutsOverScenarios;\\n        int256[] memory payoutsOverScenarios = new int256[](scenarios.length);\\n\\n        for (uint256 i; i < scenarios.length;) {\\n            payoutsOverScenarios[i] = (-payouts[i] * sUNIT) / int256(scenarios[i]);\\n\\n            if (payoutsOverScenarios[i] > maxPayoutsOverScenarios) maxPayoutsOverScenarios = payoutsOverScenarios[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        underlyingOnlyNeeded = underlyingNeeded;\\n\\n        if (maxPayoutsOverScenarios > 0) underlyingOnlyNeeded += uint256(maxPayoutsOverScenarios);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         Setup CrossMarginDetail\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice  converts Position struct arrays to in-memory detail struct arrays\\n     */\\n    function _getPositionDetails(IGrappa grappa, Position[] calldata shorts, Position[] calldata longs)\\n        internal\\n        view\\n        returns (CrossMarginDetail[] memory details)\\n    {\\n        details = new CrossMarginDetail[](0);\\n\\n        // used to reference which detail struct should be updated for a given position\\n        bytes32[] memory usceLookUp = new bytes32[](0);\\n\\n        Position[] memory positions = shorts.concat(longs);\\n        uint256 shortLength = shorts.length;\\n\\n        // used to cache product detail during the loop to save gas when productIds are the same between iterations\\n        ProductDetails memory product;\\n        //  used to cache product id between loop iterations\\n        //  default value of 0 is not a valid productId so the first run will always set the cache\\n        uint40 lastUsedProductId;\\n\\n        unchecked {\\n            for (uint256 i; i < positions.length; ++i) {\\n                (, uint40 productId, uint64 expiry,,) = positions[i].tokenId.parseTokenId();\\n\\n                // cache product detail if a productId differs from a previous iteration\\n                if (productId != lastUsedProductId) {\\n                    product = _getProductDetails(grappa, productId);\\n\\n                    lastUsedProductId = productId;\\n                }\\n\\n                bytes32 pos = keccak256(abi.encode(product.underlyingId, product.strikeId, expiry));\\n\\n                (bool found, uint256 index) = BytesArrayUtil.indexOf(usceLookUp, pos);\\n\\n                CrossMarginDetail memory detail;\\n\\n                if (found) {\\n                    detail = details[index];\\n                } else {\\n                    usceLookUp = BytesArrayUtil.append(usceLookUp, pos);\\n\\n                    detail.underlyingId = product.underlyingId;\\n                    detail.underlyingDecimals = product.underlyingDecimals;\\n                    detail.numeraireId = product.strikeId;\\n                    detail.numeraireDecimals = product.strikeDecimals;\\n\\n                    detail.expiry = expiry;\\n\\n                    details = details.append(detail);\\n                }\\n\\n                int256 amount = int256(int64(positions[i].amount));\\n\\n                if (i < shortLength) amount = -amount;\\n\\n                _processDetailWithToken(detail, positions[i].tokenId, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice merges option and amounts into the set\\n     * @dev if weight turns into zero, we remove it from the set\\n     */\\n    function _processDetailWithToken(CrossMarginDetail memory detail, uint256 tokenId, int256 amount) internal pure {\\n        (TokenType tokenType,,, uint64 strike,) = tokenId.parseTokenId();\\n\\n        bool found;\\n        uint256 index;\\n\\n        // adjust or append to callStrikes array or callWeights array.\\n        if (tokenType == TokenType.CALL) {\\n            (found, index) = detail.callStrikes.indexOf(strike);\\n\\n            if (found) {\\n                detail.callWeights[index] += amount;\\n\\n                if (detail.callWeights[index] == 0) {\\n                    detail.callWeights = detail.callWeights.remove(index);\\n                    detail.callStrikes = detail.callStrikes.remove(index);\\n                }\\n            } else {\\n                detail.callStrikes = detail.callStrikes.append(strike);\\n                detail.callWeights = detail.callWeights.append(amount);\\n            }\\n        } else if (tokenType == TokenType.PUT) {\\n            // adjust or append to putStrikes array or putWeights array.\\n            (found, index) = detail.putStrikes.indexOf(strike);\\n\\n            if (found) {\\n                detail.putWeights[index] += amount;\\n\\n                if (detail.putWeights[index] == 0) {\\n                    detail.putWeights = detail.putWeights.remove(index);\\n                    detail.putStrikes = detail.putStrikes.remove(index);\\n                }\\n            } else {\\n                detail.putStrikes = detail.putStrikes.append(strike);\\n                detail.putWeights = detail.putWeights.append(amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice gets product asset specific details from grappa in one call\\n     */\\n    function _getProductDetails(IGrappa grappa, uint40 productId) internal view returns (ProductDetails memory info) {\\n        (,, uint8 underlyingId, uint8 strikeId,) = ProductIdUtil.parseProductId(productId);\\n\\n        (,, address underlying, uint8 underlyingDecimals, address strike, uint8 strikeDecimals,,) =\\n            grappa.getDetailFromProductId(productId);\\n\\n        info.underlying = underlying;\\n        info.underlyingId = underlyingId;\\n        info.underlyingDecimals = underlyingDecimals;\\n        info.strike = strike;\\n        info.strikeId = strikeId;\\n        info.strikeDecimals = strikeDecimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/array-lib/src/UintArrayLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SafeCast} from \\\"openzeppelin/utils/math/SafeCast.sol\\\";\\n\\nlibrary UintArrayLib {\\n    using SafeCast for uint256;\\n\\n    error IntegerOverflow();\\n\\n    /**\\n     * @dev Returns maximal element in array\\n     */\\n    function max(uint256[] memory x) internal pure returns (uint256 m) {\\n        m = x[0];\\n        for (uint256 i; i < x.length;) {\\n            if (x[i] > m) {\\n                m = x[i];\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns minimum element in array\\n     */\\n    function min(uint256[] memory x) internal pure returns (uint256 m) {\\n        m = x[0];\\n        for (uint256 i = 1; i < x.length;) {\\n            if (x[i] < m) {\\n                m = x[i];\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return the min and max for an array.\\n     */\\n    function minMax(uint256[] memory x) internal pure returns (uint256 min_, uint256 max_) {\\n        if (x.length == 1) return (x[0], x[0]);\\n        (min_, max_) = (x[0], x[0]);\\n\\n        for (uint256 i = 1; i < x.length;) {\\n            if (x[i] < min_) {\\n                min_ = x[i];\\n            } else if (x[i] > max_) {\\n                max_ = x[i];\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array that append element v at the end of array x\\n     */\\n    function append(uint256[] memory x, uint256 v) internal pure returns (uint256[] memory y) {\\n        y = new uint256[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    /**\\n     * @dev Return a new array that removes element at index z.\\n     * @return y new array\\n     */\\n    function remove(uint256[] memory x, uint256 z) internal pure returns (uint256[] memory y) {\\n        if (z >= x.length) return x;\\n        y = new uint256[](x.length - 1);\\n        for (uint256 i; i < x.length;) {\\n            unchecked {\\n                if (i < z) y[i] = x[i];\\n                else if (i > z) y[i - 1] = x[i];\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Return index of the first element in array x with value v\\n     * @return found set to true if found\\n     * @return i index in the array\\n     */\\n    function indexOf(uint256[] memory x, uint256 v) internal pure returns (bool, uint256) {\\n        for (uint256 i; i < x.length;) {\\n            if (x[i] == v) {\\n                return (true, i);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Compute sum of all elements\\n     * @return s sum\\n     */\\n    function sum(uint256[] memory x) internal pure returns (uint256 s) {\\n        require(x.length != 0);\\n        // Variable to implement the overflow logic\\n        uint256 j;\\n        assembly {\\n            // The Memory layout of input array looks like this\\n            // It has Consequent slots of 32 bytes each\\n            // {length of array}{x[0]}{x[1]}{x[2]}....\\n\\n            //Cache the pointer to end of the array to be used in for loop\\n            //First param to add() is a memory pointer to start of the first element slot\\n            //Second param to add() is a memory pointer to end of the last element slot\\n            let end := add(add(x, 0x20), shl(5, mload(x)))\\n\\n            // iszero(eq()) is cheaper than lt(i,n)\\n            // We increment i by 32 bytes\\n            for { let i := add(x, 0x20) } iszero(eq(i, end)) { i := add(i, 0x20) } {\\n                j := s\\n                s := add(s, mload(i))\\n                if lt(s, j) {\\n                    // Storing the 4byte selector of error IntegerOverflow()\\n                    // mstore()\\n                    mstore(0x00, 0xa5bd5d7f)\\n                    // revert(memory offset,size of return data)\\n                    // revert(28,4)\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array that's the result of concatting a and b\\n     */\\n    function concat(uint256[] memory a, uint256[] memory b) internal pure returns (uint256[] memory y) {\\n        y = new uint256[](a.length + b.length);\\n        uint256 v;\\n        uint256 i;\\n        for (i; i < a.length;) {\\n            y[v] = a[i];\\n\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n        for (i = 0; i < b.length;) {\\n            y[v] = b[i];\\n\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Populates array a with values from b\\n     * @dev modifies array a in place.\\n     */\\n    function populate(uint256[] memory a, uint256[] memory b) internal pure {\\n        for (uint256 i; i < a.length;) {\\n            a[i] = b[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return the element at index i\\n     *      if i is positive, it's the same as requesting x[i]\\n     *      if i is negative, return the value positioned at -i from the end\\n     * @param i can be positive or negative\\n     */\\n    function at(uint256[] memory x, int256 i) internal pure returns (uint256) {\\n        if (i >= 0) {\\n            // will revert with out of bound error if i is too large\\n            return x[uint256(i)];\\n        } else {\\n            // will revert with underflow error if i is too small\\n            return x[x.length - uint256(-i)];\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array y with y[i] = z - x[i]\\n     */\\n    function subEachFrom(uint256[] memory x, uint256 z) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length);\\n        int256 intZ = z.toInt256();\\n        for (uint256 i; i < x.length;) {\\n            y[i] = intZ - x[i].toInt256();\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array y with y[i] = x[i] - z\\n     */\\n    function subEachBy(uint256[] memory x, uint256 z) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length);\\n        int256 intZ = z.toInt256();\\n        for (uint256 i; i < x.length;) {\\n            y[i] = x[i].toInt256() - intZ;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return dot of 2 vectors\\n     *      will revert if 2 vectors has different length\\n     * @param a uint256 array\\n     * @param b uint256 array\\n     */\\n    function dot(uint256[] memory a, uint256[] memory b) internal pure returns (uint256 s) {\\n        for (uint256 i; i < a.length;) {\\n            s += a[i] * b[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return dot of 2 vectors\\n     *      will revert if 2 vectors has different length\\n     * @param a uint256 array\\n     * @param b int256 array\\n     */\\n    function dot(uint256[] memory a, int256[] memory b) internal pure returns (int256 s) {\\n        for (uint256 i; i < a.length;) {\\n            s += int256(a[i]) * b[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/array-lib/src/IntArrayLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SafeCast} from \\\"openzeppelin/utils/math/SafeCast.sol\\\";\\n\\nlibrary IntArrayLib {\\n    using SafeCast for int256;\\n    using SafeCast for uint256;\\n\\n    /**\\n     * @dev returns min value of aray x\\n     */\\n    function min(int256[] memory x) internal pure returns (int256 m) {\\n        m = x[0];\\n        for (uint256 i = 1; i < x.length;) {\\n            if (x[i] < m) {\\n                m = x[i];\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns maximal element in array\\n     */\\n    function max(int256[] memory x) internal pure returns (int256 m) {\\n        m = x[0];\\n        for (uint256 i = 1; i < x.length;) {\\n            if (x[i] > m) {\\n                m = x[i];\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev returns min value of aray x and its index\\n     */\\n    function minWithIndex(int256[] memory x) internal pure returns (int256 m, uint256 idx) {\\n        m = x[0];\\n        idx = 0;\\n        for (uint256 i = 1; i < x.length;) {\\n            if (x[i] < m) {\\n                m = x[i];\\n                idx = i;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns maximal elements compared to value z\\n     * @return y array\\n     */\\n    function maximum(int256[] memory x, int256 z) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length);\\n        for (uint256 i; i < x.length;) {\\n            if (x[i] > z) y[i] = x[i];\\n            else y[i] = z;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Return a new array that removes element at index z.\\n     * @return y new array\\n     */\\n    function remove(int256[] memory x, uint256 z) internal pure returns (int256[] memory y) {\\n        if (z >= x.length) return x;\\n        y = new int256[](x.length - 1);\\n        for (uint256 i; i < x.length;) {\\n            unchecked {\\n                if (i < z) y[i] = x[i];\\n                else if (i > z) y[i - 1] = x[i];\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns index of element\\n     * @return found\\n     * @return index\\n     */\\n    function indexOf(int256[] memory x, int256 v) internal pure returns (bool, uint256) {\\n        for (uint256 i; i < x.length;) {\\n            if (x[i] == v) {\\n                return (true, i);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    /**\\n     * @dev Compute sum of all elements\\n     */\\n    function sum(int256[] memory x) internal pure returns (int256 s) {\\n        for (uint256 i; i < x.length;) {\\n            s += x[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array which is sorted by indexes array\\n     * @param x original array\\n     * @param idxs indexes to sort based on.\\n     */\\n    function sortByIndexes(int256[] memory x, uint256[] memory idxs) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length);\\n        for (uint256 i; i < x.length;) {\\n            y[i] = x[idxs[i]];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array that append element v at the end of array x\\n     */\\n    function append(int256[] memory x, int256 v) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    /**\\n     * @dev return a new array that's the result of concatting a and b\\n     */\\n    function concat(int256[] memory a, int256[] memory b) internal pure returns (int256[] memory y) {\\n        y = new int256[](a.length + b.length);\\n        uint256 v;\\n        uint256 i;\\n        for (i; i < a.length;) {\\n            y[v] = a[i];\\n\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n        for (i = 0; i < b.length;) {\\n            y[v] = b[i];\\n\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Fills array x with value v in place.\\n     */\\n    function fill(int256[] memory x, int256 v) internal pure {\\n        for (uint256 i; i < x.length;) {\\n            x[i] = v;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev modifies memory a IN PLACE. Populates a starting at index z with values from b.\\n     */\\n    function populate(int256[] memory a, int256[] memory b) internal pure {\\n        for (uint256 i; i < a.length;) {\\n            a[i] = b[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return the element at index i\\n     *      if i is positive, it's the same as requesting x[i]\\n     *      if i is negative, return the value positioned at -i from the end\\n     * @param i can be positive or negative\\n     */\\n    function at(int256[] memory x, int256 i) internal pure returns (int256) {\\n        if (i >= 0) {\\n            // will revert with out of bound error if i is too large\\n            return x[uint256(i)];\\n        } else {\\n            // will revert with underflow error if i is too small\\n            return x[x.length - uint256(-i)];\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array contains the copy from x[start] to x[end]\\n     *      if i is positive, it's the same as requesting x[i]\\n     *      if i is negative, return the value positioned at -i from the end\\n     * @param x array to copy\\n     * @param _start starting index, can be negative\\n     * @param _start ending index, can be negative\\n     */\\n    function slice(int256[] memory x, int256 _start, int256 _end) internal pure returns (int256[] memory a) {\\n        int256 len = int256(x.length);\\n        if (_start < 0) _start = len + _start;\\n        if (_end <= 0) _end = len + _end;\\n        if (_end < _start) return new int256[](0);\\n\\n        uint256 start = uint256(_start);\\n        uint256 end = uint256(_end);\\n\\n        a = new int256[](end - start);\\n        uint256 y;\\n        for (uint256 i = start; i < end;) {\\n            a[y] = x[i];\\n\\n            unchecked {\\n                ++i;\\n                ++y;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return an array y as the sum of 2 same-length array\\n     *      y[i] = a[i] + b[i]\\n     */\\n    function add(int256[] memory a, int256[] memory b) internal pure returns (int256[] memory y) {\\n        y = new int256[](a.length);\\n        for (uint256 i; i < a.length;) {\\n            y[i] = a[i] + b[i];\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return an new array y with y[i] = x[i] + z\\n     */\\n    function addEachBy(int256[] memory x, int256 z) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length);\\n        for (uint256 i; i < x.length;) {\\n            y[i] = x[i] + z;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return a new array y with y[i] = x[i] - z\\n     */\\n    function subEachBy(int256[] memory x, int256 z) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length);\\n        for (uint256 i; i < x.length;) {\\n            y[i] = x[i] - z;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return dot of 2 vectors\\n     *      will revert if 2 vectors have different length\\n     */\\n    function dot(int256[] memory a, int256[] memory b) internal pure returns (int256 s) {\\n        for (uint256 i; i < a.length;) {\\n            s += a[i] * b[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/array-lib/src/sorting/QuickSort.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IntArrayLib.sol\\\";\\nimport \\\"../UintArrayLib.sol\\\";\\n\\n/**\\n * @author dsshap\\n */\\nlibrary QuickSort {\\n    /**\\n     * ----------------------- **\\n     *  |  Quick Sort For Int256[]  |\\n     * ----------------------- *\\n     */\\n\\n    /**\\n     * @dev get a new sorted array and index order used to sort.\\n     * @return y copy of x but sorted\\n     * @return idxs indexes of input array used for sorting.\\n     */\\n    function argSort(int256[] memory x) internal pure returns (int256[] memory y, uint256[] memory idxs) {\\n        idxs = new uint256[](x.length);\\n        // fill in index array\\n        for (uint256 i; i < x.length;) {\\n            idxs[i] = i;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        // initialize copy of x\\n        y = new int256[](x.length);\\n        IntArrayLib.populate(y, x);\\n        // sort\\n        quickSort(y, int256(0), int256(y.length - 1), idxs);\\n    }\\n\\n    /**\\n     * @dev return a new sorted copy of array x\\n     */\\n    function getSorted(int256[] memory x) internal pure returns (int256[] memory y) {\\n        y = new int256[](x.length);\\n        IntArrayLib.populate(y, x);\\n        quickSort(y, int256(0), int256(y.length - 1));\\n    }\\n\\n    /**\\n     * @dev sort array x in place with quick sort algorithm\\n     */\\n    function sort(int256[] memory x) internal pure {\\n        quickSort(x, int256(0), int256(x.length - 1));\\n    }\\n\\n    /**\\n     * @dev sort arr[left:right] in place with quick sort algorithm\\n     */\\n    function quickSort(int256[] memory arr, int256 left, int256 right) internal pure {\\n        if (left == right) return;\\n        int256 i = left;\\n        int256 j = right;\\n        unchecked {\\n            int256 pivot = arr[uint256((left + right) / 2)];\\n\\n            while (i <= j) {\\n                while (arr[uint256(i)] < pivot) {\\n                    ++i;\\n                }\\n                while (pivot < arr[uint256(j)]) {\\n                    --j;\\n                }\\n                if (i <= j) {\\n                    (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\\n                    ++i;\\n                    --j;\\n                }\\n            }\\n        }\\n        if (left < j) quickSort(arr, left, j);\\n        if (i < right) quickSort(arr, i, right);\\n    }\\n\\n    /**\\n     * @dev quicksort implementation with indexes, sorts arr and indexArray in place\\n     */\\n    function quickSort(int256[] memory arr, int256 left, int256 right, uint256[] memory indexArray) internal pure {\\n        if (left == right) return;\\n        int256 i = left;\\n        int256 j = right;\\n        unchecked {\\n            int256 pivot = arr[uint256((left + right) / 2)];\\n            while (i <= j) {\\n                while (arr[uint256(i)] < pivot) {\\n                    ++i;\\n                }\\n                while (pivot < arr[uint256(j)]) {\\n                    --j;\\n                }\\n                if (i <= j) {\\n                    (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\\n                    (indexArray[uint256(i)], indexArray[uint256(j)]) = (indexArray[uint256(j)], indexArray[uint256(i)]);\\n                    ++i;\\n                    --j;\\n                }\\n            }\\n        }\\n        if (left < j) quickSort(arr, left, j, indexArray);\\n        if (i < right) quickSort(arr, i, right, indexArray);\\n    }\\n\\n    /**\\n     * ----------------------- **\\n     *  |  Quick Sort For Uint256[] |\\n     * ----------------------- *\\n     */\\n\\n    /**\\n     * @dev get a new sorted array and index order used to sort.\\n     * @return y copy of x but sorted\\n     * @return idxs indexes of input array used for sorting.\\n     */\\n    function argSort(uint256[] memory x) internal pure returns (uint256[] memory y, uint256[] memory idxs) {\\n        idxs = new uint256[](x.length);\\n        // fill in index array\\n        for (uint256 i; i < x.length;) {\\n            idxs[i] = i;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        // initialize copy of x\\n        y = new uint256[](x.length);\\n        UintArrayLib.populate(y, x);\\n        // sort\\n        quickSort(y, int256(0), int256(y.length - 1), idxs);\\n    }\\n\\n    /**\\n     * @dev return a new sorted copy of array x\\n     */\\n    function getSorted(uint256[] memory x) internal pure returns (uint256[] memory y) {\\n        y = new uint256[](x.length);\\n        UintArrayLib.populate(y, x);\\n        quickSort(y, int256(0), int256(y.length - 1));\\n    }\\n\\n    /**\\n     * @dev sort array x in place with quick sort algorithm\\n     */\\n    function sort(uint256[] memory x) internal pure {\\n        quickSort(x, int256(0), int256(x.length - 1));\\n    }\\n\\n    /**\\n     * @dev sort arr[left:right] in place with quick sort algorithm\\n     */\\n    function quickSort(uint256[] memory arr, int256 left, int256 right) internal pure {\\n        if (left == right) return;\\n        int256 i = left;\\n        int256 j = right;\\n        unchecked {\\n            uint256 pivot = arr[uint256(left + right) / 2];\\n            while (i <= j) {\\n                while (arr[uint256(i)] < pivot) {\\n                    ++i;\\n                }\\n                while (pivot < arr[uint256(j)]) {\\n                    --j;\\n                }\\n                if (i <= j) {\\n                    (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\\n                    ++i;\\n                    --j;\\n                }\\n            }\\n        }\\n        if (left < j) quickSort(arr, left, j);\\n        if (i < right) quickSort(arr, i, right);\\n    }\\n\\n    /**\\n     * @dev quicksort implementation with indexes, sorts input arr and indexArray IN PLACE\\n     */\\n    function quickSort(uint256[] memory arr, int256 left, int256 right, uint256[] memory indexArray) internal pure {\\n        if (left == right) return;\\n        int256 i = left;\\n        int256 j = right;\\n        unchecked {\\n            uint256 pivot = arr[uint256((left + right) / 2)];\\n            while (i <= j) {\\n                while (arr[uint256(i)] < pivot) {\\n                    ++i;\\n                }\\n                while (pivot < arr[uint256(j)]) {\\n                    --j;\\n                }\\n                if (i <= j) {\\n                    (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\\n                    (indexArray[uint256(i)], indexArray[uint256(j)]) = (indexArray[uint256(j)], indexArray[uint256(i)]);\\n                    ++i;\\n                    --j;\\n                }\\n            }\\n            if (left < j) quickSort(arr, left, j, indexArray);\\n            if (i < right) quickSort(arr, i, right, indexArray);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/interfaces/IGrappa.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../config/types.sol\\\";\\n\\ninterface IGrappa {\\n    function getDetailFromProductId(uint40 _productId)\\n        external\\n        view\\n        returns (\\n            address oracle,\\n            address engine,\\n            address underlying,\\n            uint8 underlyingDecimals,\\n            address strike,\\n            uint8 strikeDecimals,\\n            address collateral,\\n            uint8 collateralDecimals\\n        );\\n\\n    function checkEngineAccess(uint256 _tokenId, address _engine) external view;\\n\\n    function checkEngineAccessAndTokenId(uint256 _tokenId, address _engine) external view;\\n\\n    function engineIds(address _engine) external view returns (uint8 id);\\n\\n    function assetIds(address _asset) external view returns (uint8 id);\\n\\n    function assets(uint8 _id) external view returns (address addr, uint8 decimals);\\n\\n    function engines(uint8 _id) external view returns (address engine);\\n\\n    function oracles(uint8 _id) external view returns (address oracle);\\n\\n    function getPayout(uint256 tokenId, uint64 amount)\\n        external\\n        view\\n        returns (address engine, address collateral, uint256 payout);\\n\\n    function getProductId(address oracle, address engine, address underlying, address strike, address collateral)\\n        external\\n        view\\n        returns (uint40 id);\\n\\n    function getTokenId(TokenType tokenType, uint40 productId, uint256 expiry, uint256 longStrike, uint256 shortStrike)\\n        external\\n        view\\n        returns (uint256 id);\\n\\n    /**\\n     * @notice burn option token and get out cash value at expiry\\n     * @param _account who to settle for\\n     * @param _tokenId  tokenId of option token to burn\\n     * @param _amount   amount to settle\\n     * @return payout amount paid out\\n     */\\n    function settleOption(address _account, uint256 _tokenId, uint256 _amount) external returns (uint256 payout);\\n\\n    /**\\n     * @notice burn array of option tokens and get out cash value at expiry\\n     * @param _account who to settle for\\n     * @param _tokenIds array of tokenIds to burn\\n     * @param _amounts   array of amounts to burn\\n     */\\n    function batchSettleOptions(address _account, uint256[] memory _tokenIds, uint256[] memory _amounts)\\n        external\\n        returns (Balance[] memory payouts);\\n\\n    function batchGetPayouts(uint256[] memory _tokenIds, uint256[] memory _amounts) external returns (Balance[] memory payouts);\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOracle {\\n    /**\\n     * @notice  get spot price of _base, denominated in _quote.\\n     * @param _base base asset. for ETH/USD price, ETH is the base asset\\n     * @param _quote quote asset. for ETH/USD price, USD is the quote asset\\n     * @return price with 6 decimals\\n     */\\n    function getSpotPrice(address _base, address _quote) external view returns (uint256);\\n\\n    /**\\n     * @dev get expiry price of underlying, denominated in strike asset.\\n     * @param _base base asset. for ETH/USD price, ETH is the base asset\\n     * @param _quote quote asset. for ETH/USD price, USD is the quote asset\\n     * @param _expiry expiry timestamp\\n     *\\n     * @return price with 6 decimals\\n     */\\n    function getPriceAtExpiry(address _base, address _quote, uint256 _expiry)\\n        external\\n        view\\n        returns (uint256 price, bool isFinalized);\\n\\n    /**\\n     * @dev return the maximum dispute period for the oracle\\n     * @dev this will only be checked during oracle registration, as a soft constraint on integrating oracles.\\n     */\\n    function maxDisputePeriod() external view returns (uint256 disputePeriod);\\n}\\n\"\r\n    },\r\n    \"src/libraries/BytesArrayUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SafeCast} from \\\"openzeppelin/utils/math/SafeCast.sol\\\";\\n\\nlibrary BytesArrayUtil {\\n    function indexOf(bytes32[] memory x, bytes32 v) internal pure returns (bool, uint256) {\\n        for (uint256 i; i < x.length;) {\\n            if (x[i] == v) {\\n                return (true, i);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    function append(bytes32[] memory x, bytes32 e) internal pure returns (bytes32[] memory y) {\\n        y = new bytes32[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = e;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/libraries/NumberUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary NumberUtil {\\n    /**\\n     * @dev use it in uncheck so overflow will still be checked.\\n     */\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) { revert(0, 0) }\\n        }\\n    }\\n\\n    /**\\n     * @notice convert decimals of an amount\\n     *\\n     * @param  amount      number to convert\\n     * @param fromDecimals the decimals amount has\\n     * @param toDecimals   the target decimals\\n     *\\n     * @return newAmount number with toDecimals decimals\\n     */\\n    function convertDecimals(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {\\n        if (fromDecimals == toDecimals) return amount;\\n\\n        if (fromDecimals > toDecimals) {\\n            uint8 diff;\\n            unchecked {\\n                diff = fromDecimals - toDecimals;\\n                // div cannot underflow because diff 10**diff != 0\\n                return amount / (10 ** diff);\\n            }\\n        } else {\\n            uint8 diff;\\n            unchecked {\\n                diff = toDecimals - fromDecimals;\\n            }\\n            return amount * (10 ** diff);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/libraries/ProductIdUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// solhint-disable max-line-length\\n\\n/**\\n * @title ProductIdUtil\\n * @dev used to parse and compose productId\\n * Product Id =\\n * * ----------------- | ----------------- | ---------------------- | ------------------ | ---------------------- *\\n * | oracleId (8 bits) | engineId (8 bits) | underlying ID (8 bits) | strike ID (8 bits) | collateral ID (8 bits) |\\n * * ----------------- | ----------------- | ---------------------- | ------------------ | ---------------------- *\\n *\\n */\\nlibrary ProductIdUtil {\\n    /**\\n     * @dev parse product id into composing asset ids\\n     *\\n     * productId (40 bits) =\\n     *\\n     * @param _productId product id\\n     */\\n    function parseProductId(uint40 _productId)\\n        internal\\n        pure\\n        returns (uint8 oracleId, uint8 engineId, uint8 underlyingId, uint8 strikeId, uint8 collateralId)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            oracleId := shr(32, _productId)\\n            engineId := shr(24, _productId)\\n            underlyingId := shr(16, _productId)\\n            strikeId := shr(8, _productId)\\n        }\\n        collateralId = uint8(_productId);\\n    }\\n\\n    /**\\n     * @dev parse collateral id from product Id.\\n     *      since collateral id is uint8 of the last 8 bits of productId, we can just cast to uint8\\n     */\\n    function getCollateralId(uint40 _productId) internal pure returns (uint8) {\\n        return uint8(_productId);\\n    }\\n\\n    /**\\n     * @notice    get product id from underlying, strike and collateral address\\n     * @dev       function will still return even if some of the assets are not registered\\n     * @param underlyingId  underlying id\\n     * @param strikeId      strike id\\n     * @param collateralId  collateral id\\n     */\\n    function getProductId(uint8 oracleId, uint8 engineId, uint8 underlyingId, uint8 strikeId, uint8 collateralId)\\n        internal\\n        pure\\n        returns (uint40 id)\\n    {\\n        unchecked {\\n            id = (uint40(oracleId) << 32) + (uint40(engineId) << 24) + (uint40(underlyingId) << 16) + (uint40(strikeId) << 8)\\n                + (uint40(collateralId));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/libraries/TokenIdUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable max-line-length\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../config/enums.sol\\\";\\nimport \\\"../config/errors.sol\\\";\\n\\n/**\\n * Token ID =\\n *\\n *  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n *  | tokenType (24 bits) | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | reserved    (64 bits) |\\n *  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n */\\n\\nlibrary TokenIdUtil {\\n    /**\\n     * @notice calculate ERC1155 token id for given option parameters. See table above for tokenId\\n     * @param tokenType TokenType enum\\n     * @param productId if of the product\\n     * @param expiry timestamp of option expiry\\n     * @param longStrike strike price of the long option, with 6 decimals\\n     * @param reserved strike price of the short (upper bond for call and lower bond for put) if this is a spread. 6 decimals\\n     * @return tokenId token id\\n     */\\n    function getTokenId(TokenType tokenType, uint40 productId, uint64 expiry, uint64 longStrike, uint64 reserved)\\n        internal\\n        pure\\n        returns (uint256 tokenId)\\n    {\\n        unchecked {\\n            tokenId = (uint256(tokenType) << 232) + (uint256(productId) << 192) + (uint256(expiry) << 128)\\n                + (uint256(longStrike) << 64) + uint256(reserved);\\n        }\\n    }\\n\\n    /**\\n     * @notice derive option, product, expiry and strike price from ERC1155 token id\\n     * @dev    See table above for tokenId composition\\n     * @param tokenId token id\\n     * @return tokenType TokenType enum\\n     * @return productId 32 bits product id\\n     * @return expiry timestamp of option expiry\\n     * @return longStrike strike price of the long option, with 6 decimals\\n     * @return reserved strike price of the short (upper bond for call and lower bond for put) if this is a spread. 6 decimals\\n     */\\n    function parseTokenId(uint256 tokenId)\\n        internal\\n        pure\\n        returns (TokenType tokenType, uint40 productId, uint64 expiry, uint64 longStrike, uint64 reserved)\\n    {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            tokenType := shr(232, tokenId)\\n            productId := shr(192, tokenId)\\n            expiry := shr(128, tokenId)\\n            longStrike := shr(64, tokenId)\\n            reserved := tokenId\\n        }\\n    }\\n\\n    /**\\n     * @notice parse collateral id from tokenId\\n     * @dev more efficient than parsing tokenId and than parse productId\\n     * @param tokenId token id\\n     * @return collateralId\\n     */\\n    function parseCollateralId(uint256 tokenId) internal pure returns (uint8 collateralId) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // collateralId is the last bits of productId\\n            collateralId := shr(192, tokenId)\\n        }\\n    }\\n\\n    /**\\n     * @notice parse engine id from tokenId\\n     * @dev more efficient than parsing tokenId and than parse productId\\n     * @param tokenId token id\\n     * @return engineId\\n     */\\n    function parseEngineId(uint256 tokenId) internal pure returns (uint8 engineId) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // collateralId is the last bits of productId\\n            engineId := shr(216, tokenId) // 192 to get product id, another 24 to get engineId\\n        }\\n    }\\n\\n    /**\\n     * @notice derive option type from ERC1155 token id\\n     * @param tokenId token id\\n     * @return tokenType TokenType enum\\n     */\\n    function parseTokenType(uint256 tokenId) internal pure returns (TokenType tokenType) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            tokenType := shr(232, tokenId)\\n        }\\n    }\\n\\n    /**\\n     * @notice derive if option is expired from ERC1155 token id\\n     * @param tokenId token id\\n     * @return expired bool\\n     */\\n    function isExpired(uint256 tokenId) internal view returns (bool expired) {\\n        uint64 expiry;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            expiry := shr(128, tokenId)\\n        }\\n\\n        expired = block.timestamp >= expiry;\\n    }\\n\\n    /**\\n     * @notice convert an spread tokenId back to put or call.\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   oldId =   | spread type (24 b)  | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | shortStrike (64 bits) |\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   newId =   | call or put type    | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | 0           (64 bits) |\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   this function will: override tokenType, remove shortStrike.\\n     * @param _tokenId token id to change\\n     */\\n    function convertToVanillaId(uint256 _tokenId) internal pure returns (uint256 newId) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            newId := shr(64, _tokenId) // step 1: >> 64 to wipe out shortStrike\\n            newId := shl(64, newId) // step 2: << 64 go back\\n\\n            newId := sub(newId, shl(232, 1)) // step 3: new tokenType = spread type - 1\\n        }\\n    }\\n\\n    /**\\n     * @notice convert an spread tokenId back to put or call.\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   oldId =   | call or put type    | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | 0           (64 bits) |\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     * @dev   newId =   | spread type         | productId (40 bits) | expiry (64 bits) | longStrike (64 bits) | shortStrike (64 bits) |\\n     *                  * ------------------- | ------------------- | ---------------- | -------------------- | --------------------- *\\n     *\\n     * this function convert put or call type to spread type, add shortStrike.\\n     * @param _tokenId token id to change\\n     * @param _shortStrike strike to add\\n     */\\n    function convertToSpreadId(uint256 _tokenId, uint256 _shortStrike) internal pure returns (uint256 newId) {\\n        // solhint-disable-next-line no-inline-assembly\\n        unchecked {\\n            newId = _tokenId + _shortStrike;\\n            return newId + (1 << 232); // new type (spread type) = old type + 1\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/libraries/BalanceUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Balance} from \\\"../config/types.sol\\\";\\n\\n/**\\n * Operations on Balance struct\\n */\\nlibrary BalanceUtil {\\n    /**\\n     * @dev create a new Balance array with 1 more element\\n     * @param x balance array\\n     * @param v new value to add\\n     * @return y new balance array\\n     */\\n    function append(Balance[] memory x, Balance memory v) internal pure returns (Balance[] memory y) {\\n        y = new Balance[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    /**\\n     * @dev check if a balance object for collateral id already exists\\n     * @param x balance array\\n     * @param v collateral id to search\\n     * @return f true if found\\n     * @return b Balance object\\n     * @return i index of the found entry\\n     */\\n    function find(Balance[] memory x, uint8 v) internal pure returns (bool f, Balance memory b, uint256 i) {\\n        for (i; i < x.length;) {\\n            if (x[i].collateralId == v) {\\n                b = x[i];\\n                f = true;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev return the index of an element balance array\\n     * @param x balance array\\n     * @param v collateral id to search\\n     * @return f true if found\\n     * @return i index of the found entry\\n     */\\n    function indexOf(Balance[] memory x, uint8 v) internal pure returns (bool f, uint256 i) {\\n        for (i; i < x.length;) {\\n            if (x[i].collateralId == v) {\\n                f = true;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev remove index y from balance array\\n     * @param x balance array\\n     * @param i index to remove\\n     */\\n    function remove(Balance[] storage x, uint256 i) internal {\\n        if (i >= x.length) return;\\n        x[i] = x[x.length - 1];\\n        x.pop();\\n    }\\n\\n    /**\\n     * @dev checks if balances are empty\\n     */\\n    function isEmpty(Balance[] memory x) internal pure returns (bool e) {\\n        e = true;\\n        for (uint256 i; i < x.length;) {\\n            if (x[i].amount > 0) {\\n                e = false;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/AccountUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// cross margin types\\nimport {CrossMarginDetail, Position} from \\\"../config/types.sol\\\";\\n\\nlibrary AccountUtil {\\n    function append(CrossMarginDetail[] memory x, CrossMarginDetail memory v)\\n        internal\\n        pure\\n        returns (CrossMarginDetail[] memory y)\\n    {\\n        y = new CrossMarginDetail[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    function append(Position[] memory x, Position memory v) internal pure returns (Position[] memory y) {\\n        y = new Position[](x.length + 1);\\n        uint256 i;\\n        for (i; i < x.length;) {\\n            y[i] = x[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        y[i] = v;\\n    }\\n\\n    function concat(Position[] memory a, Position[] memory b) internal pure returns (Position[] memory y) {\\n        y = new Position[](a.length + b.length);\\n        uint256 v;\\n        uint256 i;\\n        for (i; i < a.length;) {\\n            y[v] = a[i];\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n        for (i = 0; i < b.length;) {\\n            y[v] = b[i];\\n            unchecked {\\n                ++i;\\n                ++v;\\n            }\\n        }\\n    }\\n\\n    function find(Position[] memory x, uint256 v) internal pure returns (bool f, Position memory p, uint256 i) {\\n        for (i; i < x.length;) {\\n            if (x[i].tokenId == v) {\\n                p = x[i];\\n                f = true;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function indexOf(Position[] memory x, uint256 v) internal pure returns (bool f, uint256 i) {\\n        for (i; i < x.length;) {\\n            if (x[i].tokenId == v) {\\n                f = true;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function isEmpty(Position[] memory x) internal pure returns (bool e) {\\n        e = true;\\n        for (uint256 i; i < x.length;) {\\n            if (x[i].amount > 0) {\\n                e = false;\\n                break;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function removeAt(Position[] storage x, uint256 y) internal {\\n        if (y >= x.length) return;\\n        x[y] = x[x.length - 1];\\n        x.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/settled-cash/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../config/types.sol\\\";\\nimport {Balance} from \\\"grappa/config/types.sol\\\";\\n\\n/**\\n * @dev base unit of cross margin account. This is the data stored in the state\\n *      storage packing is utilized to save gas.\\n * @param shorts an array of short positions\\n * @param longs an array of long positions\\n * @param collaterals an array of collateral balances\\n */\\nstruct CrossMarginAccount {\\n    Position[] shorts;\\n    Position[] longs;\\n    Balance[] collaterals;\\n}\\n\"\r\n    },\r\n    \"src/config/errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/* --------------------- *\\n *  Cross Margin Errors\\n * --------------------- */\\n\\n/// @dev cross margin doesn't support this action\\nerror CM_UnsupportedAction();\\n\\n/// @dev cannot override a non-empty subaccount id\\nerror CM_AccountIsNotEmpty();\\n\\n/// @dev unsupported token type\\nerror CM_UnsupportedTokenType();\\n\\n/// @dev can only add long tokens that are not expired\\nerror CM_Token_Expired();\\n\\n/// @dev can only add long tokens from authorized engines\\nerror CM_Not_Authorized_Engine();\\n\\n/// @dev collateral id is wrong: the id doesn't match the existing collateral\\nerror CM_WrongCollateralId();\\n\\n/// @dev invalid collateral:\\nerror CM_CannotMintOptionWithThisCollateral();\\n\\n/// @dev invalid tokenId specify to mint / burn actions\\nerror CM_InvalidToken();\\n\\n//// @dev invalid signed message\\nerror CM_InvalidSignature();\\n\\n/* -------------------------- *\\n *  Cross Margin Math Errors\\n * -------------------------- */\\n\\n/// @dev invalid put length given strikes\\nerror CMM_InvalidPutLengths();\\n\\n/// @dev invalid call length given strikes\\nerror CMM_InvalidCallLengths();\\n\\n/// @dev invalid put length of zero\\nerror CMM_InvalidPutWeight();\\n\\n/// @dev invalid call length of zero\\nerror CMM_InvalidCallWeight();\\n\\n/* ------------------------ *\\n *  Cross Margin Lib Errors\\n * ------------------------ */\\n\\n/// @dev token not yet expired\\nerror CML_NotExpired();\\n\\nerror CML_ExceedsAmount();\\n\"\r\n    },\r\n    \"lib/core-cash/src/config/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./enums.sol\\\";\\n\\n/**\\n * @dev struct representing the current balance for a given collateral\\n * @param collateralId grappa asset id\\n * @param amount amount the asset\\n */\\nstruct Balance {\\n    uint8 collateralId;\\n    uint80 amount;\\n}\\n\\n/**\\n * @dev struct containing assets detail for an product\\n * @param underlying    underlying address\\n * @param strike        strike address\\n * @param collateral    collateral address\\n * @param collateralDecimals collateral asset decimals\\n */\\nstruct ProductDetails {\\n    address oracle;\\n    uint8 oracleId;\\n    address engine;\\n    uint8 engineId;\\n    address underlying;\\n    uint8 underlyingId;\\n    uint8 underlyingDecimals;\\n    address strike;\\n    uint8 strikeId;\\n    uint8 strikeDecimals;\\n    address collateral;\\n    uint8 collateralId;\\n    uint8 collateralDecimals;\\n}\\n\\n// todo: update doc\\nstruct ActionArgs {\\n    ActionType action;\\n    bytes data;\\n}\\n\\nstruct BatchExecute {\\n    address subAccount;\\n    ActionArgs[] actions;\\n}\\n\\n/**\\n * @dev asset detail stored per asset id\\n * @param addr address of the asset\\n * @param decimals token decimals\\n */\\nstruct AssetDetail {\\n    address addr;\\n    uint8 decimals;\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/config/constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n///@dev unit used for option amount and strike prices\\nuint8 constant UNIT_DECIMALS = 6;\\n\\n///@dev unit scaled used to convert amounts.\\nuint256 constant UNIT = 10 ** 6;\\n\\n///@dev int scaled used to convert amounts.\\nint256 constant sUNIT = int256(10 ** 6);\\n\\n///@dev basis point for 100%.\\nuint256 constant BPS = 10000;\\n\\n///@dev maximum dispute period for oracle\\nuint256 constant MAX_DISPUTE_PERIOD = 6 hours;\\n\"\r\n    },\r\n    \"lib/core-cash/src/config/enums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum TokenType {\\n    PUT,\\n    PUT_SPREAD,\\n    CALL,\\n    CALL_SPREAD\\n}\\n\\n/**\\n * @dev common action types on margin engines\\n */\\nenum ActionType {\\n    AddCollateral,\\n    RemoveCollateral,\\n    MintShort,\\n    BurnShort,\\n    MergeOptionToken, // These actions are defined in \\\"DebitSpread\\\"\\n    SplitOptionToken, // These actions are defined in \\\"DebitSpread\\\"\\n    AddLong,\\n    RemoveLong,\\n    SettleAccount,\\n    // actions that influence more than one subAccounts:\\n    // These actions are defined in \\\"OptionTransferable\\\"\\n    MintShortIntoAccount, // increase short (debt) position in one subAccount, increase long token directly to another subAccount\\n    TransferCollateral, // transfer collateral directly to another subAccount\\n    TransferLong, // transfer long directly to another subAccount\\n    TransferShort, // transfer short directly to another subAccount\\n    BurnShortInAccount // decreases short position in one subAccount, decreases long position in another\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/config/errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// for easier import\\nimport \\\"../core/oracles/errors.sol\\\";\\n\\n/* ------------------------ *\\n *      Shared Errors       *\\n * -----------------------  */\\n\\nerror NoAccess();\\n\\n/* ------------------------ *\\n *      Grappa Errors       *\\n * -----------------------  */\\n\\n/// @dev asset already registered\\nerror GP_AssetAlreadyRegistered();\\n\\n/// @dev margin engine already registered\\nerror GP_EngineAlreadyRegistered();\\n\\n/// @dev oracle already registered\\nerror GP_OracleAlreadyRegistered();\\n\\n/// @dev registring oracle doesn't comply with the max dispute period constraint.\\nerror GP_BadOracle();\\n\\n/// @dev amounts length speicified to batch settle doesn't match with tokenIds\\nerror GP_WrongArgumentLength();\\n\\n/// @dev cannot settle an unexpired option\\nerror GP_NotExpired();\\n\\n/// @dev settlement price is not finalized yet\\nerror GP_PriceNotFinalized();\\n\\n/// @dev cannot mint token after expiry\\nerror GP_InvalidExpiry();\\n\\n/// @dev put and call should not contain \\\"short stirkes\\\"\\nerror GP_BadStrikes();\\n\\n/// @dev burn or mint can only be called by corresponding engine.\\nerror GP_Not_Authorized_Engine();\\n\\n/* ---------------------------- *\\n *   Common BaseEngine Errors   *\\n * ---------------------------  */\\n\\n/// @dev can only merge subaccount with put or call.\\nerror BM_CannotMergeSpread();\\n\\n/// @dev only spread position can be split\\nerror BM_CanOnlySplitSpread();\\n\\n/// @dev type of existing short token doesn't match the incoming token\\nerror BM_MergeTypeMismatch();\\n\\n/// @dev product type of existing short token doesn't match the incoming token\\nerror BM_MergeProductMismatch();\\n\\n/// @dev expiry of existing short token doesn't match the incoming token\\nerror BM_MergeExpiryMismatch();\\n\\n/// @dev cannot merge type with the same strike. (should use burn instead)\\nerror BM_MergeWithSameStrike();\\n\\n/// @dev account is not healthy / account is underwater\\nerror BM_AccountUnderwater();\\n\\n/// @dev msg.sender is not authorized to ask margin account to pull token from {from} address\\nerror BM_InvalidFromAddress();\\n\"\r\n    },\r\n    \"src/config/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev struct used in memory to represent a cross margin account's option set\\n *      this is a grouping of like underlying, collateral, strike (asset), and expiry\\n *      used to calculate margin requirements\\n * @param putWeights            amount of put options held in account (shorts and longs)\\n * @param putStrikes            strikes of put options held in account (shorts and longs)\\n * @param callWeights           amount of call options held in account (shorts and longs)\\n * @param callStrikes           strikes of call options held in account (shorts and longs)\\n * @param underlyingId          pomace id for underlying asset\\n * @param underlyingDecimals    decimal points of underlying asset\\n * @param numeraireId           pomace id for numeraire (aka strike) asset\\n * @param numeraireDecimals     decimal points of numeraire (aka strike) asset\\n * @param expiry                expiry of the option\\n */\\nstruct CrossMarginDetail {\\n    int256[] putWeights;\\n    uint256[] putStrikes;\\n    int256[] callWeights;\\n    uint256[] callStrikes;\\n    uint8 underlyingId;\\n    uint8 underlyingDecimals;\\n    uint8 numeraireId;\\n    uint8 numeraireDecimals;\\n    uint256 expiry;\\n}\\n\\n/**\\n * @dev an uncompressed Position struct, expanding tokenId to uint256\\n * @param tokenId pomace option token id\\n * @param amount number option tokens\\n */\\nstruct Position {\\n    uint256 tokenId;\\n    uint64 amount;\\n}\\n\\nstruct SettlementTracker {\\n    uint64 issued;\\n    uint80 totalDebt;\\n    uint80 totalPaid;\\n}\\n\"\r\n    },\r\n    \"lib/core-cash/src/core/oracles/errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nerror OC_CannotReportForFuture();\\n\\nerror OC_PriceNotReported();\\n\\nerror OC_PriceReported();\\n\\n///@dev cannot dispute the settlement price after dispute period is over\\nerror OC_DisputePeriodOver();\\n\\n///@dev cannot force-set an settlement price until grace period is passed and no one has set the price.\\nerror OC_GracePeriodNotOver();\\n\\n///@dev already disputed\\nerror OC_PriceDisputed();\\n\\n///@dev owner trying to set a dispute period that is invalid\\nerror OC_InvalidDisputePeriod();\\n\\n// Chainlink oracle\\n\\nerror CL_AggregatorNotSet();\\n\\nerror CL_StaleAnswer();\\n\\nerror CL_RoundIdTooSmall();\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"array-lib/=lib/array-lib/src/\",\r\n      \"core-cash/=lib/core-cash/\",\r\n      \"core-physical/=lib/core-physical/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"grappa-test/=lib/core-cash/test/\",\r\n      \"grappa/=lib/core-cash/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"pomace-test/=lib/core-physical/test/\",\r\n      \"pomace/=lib/core-physical/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {\r\n      \"src/settled-cash/CrossMarginCashLib.sol\": {\r\n        \"CrossMarginCashLib\": \"0xe3db03a6a579b259061830746a6f2ac16f37f9c4\"\r\n      },\r\n      \"src/settled-cash/CrossMarginCashMath.sol\": {\r\n        \"CrossMarginCashMath\": \"0xeff65967227f0b84ea115bdb8be1d166c3f371d0\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"CMM_InvalidCallLengths\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CMM_InvalidCallWeight\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CMM_InvalidPutLengths\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CMM_InvalidPutWeight\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int256[]\",\"name\":\"putWeights\",\"type\":\"int256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"putStrikes\",\"type\":\"uint256[]\"},{\"internalType\":\"int256[]\",\"name\":\"callWeights\",\"type\":\"int256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"callStrikes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8\",\"name\":\"underlyingId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"underlyingDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"numeraireId\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"numeraireDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"internalType\":\"struct CrossMarginDetail\",\"name\":\"_detail\",\"type\":\"tuple\"}],\"name\":\"getMinCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numeraireNeeded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingNeeded\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGrappa\",\"name\":\"grappa\",\"type\":\"IGrappa\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"}],\"internalType\":\"struct Position[]\",\"name\":\"shorts\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"amount\",\"type\":\"uint64\"}],\"internalType\":\"struct Position[]\",\"name\":\"longs\",\"type\":\"tuple[]\"}],\"name\":\"getMinCollateralForPositions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"collateralId\",\"type\":\"uint8\"},{\"internalType\":\"uint80\",\"name\":\"amount\",\"type\":\"uint80\"}],\"internalType\":\"struct Balance[]\",\"name\":\"amounts\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CrossMarginCashMath", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}