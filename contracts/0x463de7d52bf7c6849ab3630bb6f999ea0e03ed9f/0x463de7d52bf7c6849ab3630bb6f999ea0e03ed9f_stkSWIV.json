{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >= 0.8.4;\r\n\r\ncontract ERC20 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                  EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     * @param s The spender\r\n     * @param a The amount increased\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n\r\n    function increaseAllowance(address s, uint256 a) public returns (bool) {\r\n        _approve(msg.sender, s, allowance[msg.sender][s] + a);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     * @param s The spender\r\n     * @param a The amount subtracted\r\n     * \r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address s, uint256 a) public returns (bool) {\r\n        uint256 currentAllowance = allowance[msg.sender][s];\r\n        require(currentAllowance >= a, \"erc20 decreased allowance below zero\");\r\n        _approve(msg.sender, s, currentAllowance - a);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function _approve(address holder, address spender, uint256 amount) internal {\r\n        allowance[holder][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n    }\r\n}\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\nlibrary SafeTransferLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                           ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function transferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 100 because the calldata length is 4 + 32 * 3.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function transfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function approve(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                         INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\r\n        assembly {\r\n            // Get how many bytes the call returned.\r\n            let returnDataSize := returndatasize()\r\n\r\n            // If the call reverted:\r\n            if iszero(callStatus) {\r\n                // Copy the revert message into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Revert with the same message.\r\n                revert(0, returnDataSize)\r\n            }\r\n\r\n            switch returnDataSize\r\n            case 32 {\r\n                // Copy the return data into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Set success to whether it returned true.\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                // There was no return data.\r\n                success := 1\r\n            }\r\n            default {\r\n                // It returned some malformed input.\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}\r\nlibrary FixedPointMathLib {\r\n    /*//////////////////////////////////////////////////////////////\r\n                    SIMPLIFIED FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\r\n\r\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\r\n\r\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\r\n    }\r\n\r\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\r\n    }\r\n\r\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\r\n    }\r\n\r\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    LOW LEVEL FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function mulDivDown(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\r\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // Divide x * y by the denominator.\r\n            z := div(mul(x, y), denominator)\r\n        }\r\n    }\r\n\r\n    function mulDivUp(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\r\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // If x * y modulo the denominator is strictly greater than 0,\r\n            // 1 is added to round up the division of x * y by the denominator.\r\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\r\n        }\r\n    }\r\n\r\n    function rpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 scalar\r\n    ) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    // 0 ** 0 = 1\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // 0 ** n = 0\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    // If n is even, store scalar in z for now.\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // If n is odd, store x in z for now.\r\n                    z := x\r\n                }\r\n\r\n                // Shifting right by 1 is like dividing by 2.\r\n                let half := shr(1, scalar)\r\n\r\n                for {\r\n                    // Shift n right by 1 before looping to halve it.\r\n                    n := shr(1, n)\r\n                } n {\r\n                    // Shift n right by 1 each iteration to halve it.\r\n                    n := shr(1, n)\r\n                } {\r\n                    // Revert immediately if x ** 2 would overflow.\r\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\r\n                    if shr(128, x) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Store x squared.\r\n                    let xx := mul(x, x)\r\n\r\n                    // Round to the nearest number.\r\n                    let xxRound := add(xx, half)\r\n\r\n                    // Revert if xx + half overflowed.\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Set x to scaled xxRound.\r\n                    x := div(xxRound, scalar)\r\n\r\n                    // If n is even:\r\n                    if mod(n, 2) {\r\n                        // Compute z * x.\r\n                        let zx := mul(z, x)\r\n\r\n                        // If z * x overflowed:\r\n                        if iszero(eq(div(zx, x), z)) {\r\n                            // Revert if x is non-zero.\r\n                            if iszero(iszero(x)) {\r\n                                revert(0, 0)\r\n                            }\r\n                        }\r\n\r\n                        // Round to the nearest number.\r\n                        let zxRound := add(zx, half)\r\n\r\n                        // Revert if zx + half overflowed.\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n\r\n                        // Return properly scaled zxRound.\r\n                        z := div(zxRound, scalar)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        GENERAL NUMBER UTILITIES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let y := x // We start y at x, which will help us make our initial estimate.\r\n\r\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\r\n\r\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\r\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\r\n\r\n            // We check y >= 2^(k + 8) but shift right by k bits\r\n            // each branch to ensure that if x >= 256, then y >= 256.\r\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\r\n                y := shr(128, y)\r\n                z := shl(64, z)\r\n            }\r\n            if iszero(lt(y, 0x1000000000000000000)) {\r\n                y := shr(64, y)\r\n                z := shl(32, z)\r\n            }\r\n            if iszero(lt(y, 0x10000000000)) {\r\n                y := shr(32, y)\r\n                z := shl(16, z)\r\n            }\r\n            if iszero(lt(y, 0x1000000)) {\r\n                y := shr(16, y)\r\n                z := shl(8, z)\r\n            }\r\n\r\n            // Goal was to get z*z*y within a small factor of x. More iterations could\r\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\r\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\r\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\r\n\r\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\r\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\r\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\r\n\r\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\r\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\r\n\r\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\r\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\r\n\r\n            // There is no overflow risk here since y < 2^136 after the first branch above.\r\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\r\n\r\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // If x+1 is a perfect square, the Babylonian method cycles between\r\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\r\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\r\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\r\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\r\n            z := sub(z, lt(div(x, z), z))\r\n        }\r\n    }\r\n\r\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Mod x by y. Note this will return\r\n            // 0 instead of reverting if y is zero.\r\n            z := mod(x, y)\r\n        }\r\n    }\r\n\r\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Divide x by y. Note this will return\r\n            // 0 instead of reverting if y is zero.\r\n            r := div(x, y)\r\n        }\r\n    }\r\n\r\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Add 1 to x * y if x % y > 0. Note this will\r\n            // return 0 instead of reverting if y is zero.\r\n            z := add(gt(mod(x, y), 0), div(x, y))\r\n        }\r\n    }\r\n}\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface IAuthentication {\r\n    /**\r\n     * @dev Returns the action identifier associated with the external function described by `selector`.\r\n     */\r\n    function getActionId(bytes4 selector) external view returns (bytes32);\r\n}\r\n\r\ninterface ISignaturesValidator {\r\n    /**\r\n     * @dev Returns the EIP712 domain separator.\r\n     */\r\n    function getDomainSeparator() external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Returns the next nonce used by an address to sign messages.\r\n     */\r\n    function getNextNonce(address user) external view returns (uint256);\r\n}\r\n\r\ninterface ITemporarilyPausable {\r\n    /**\r\n     * @dev Emitted every time the pause state changes by `_setPaused`.\r\n     */\r\n    event PausedStateChanged(bool paused);\r\n\r\n    /**\r\n     * @dev Returns the current paused state.\r\n     */\r\n    function getPausedState()\r\n        external\r\n        view\r\n        returns (\r\n            bool paused,\r\n            uint256 pauseWindowEndTime,\r\n            uint256 bufferPeriodEndTime\r\n        );\r\n}\r\n\r\ninterface IAsset {\r\n    // solhint-disable-previous-line no-empty-blocks\r\n}\r\n\r\ninterface IAuthorizer {\r\n    /**\r\n     * @dev Returns true if `account` can perform the action described by `actionId` in the contract `where`.\r\n     */\r\n    function canPerform(\r\n        bytes32 actionId,\r\n        address account,\r\n        address where\r\n    ) external view returns (bool);\r\n}\r\n\r\ninterface IFlashLoanRecipient {\r\n    /**\r\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\r\n     *\r\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\r\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\r\n     * Vault, or else the entire flash loan will revert.\r\n     *\r\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\r\n     */\r\n    function receiveFlashLoan(\r\n        IERC20[] memory tokens,\r\n        uint256[] memory amounts,\r\n        uint256[] memory feeAmounts,\r\n        bytes memory userData\r\n    ) external;\r\n}\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 amount) external;\r\n}\r\n\r\n\r\ninterface IProtocolFeesCollector {\r\n    event SwapFeePercentageChanged(uint256 newSwapFeePercentage);\r\n    event FlashLoanFeePercentageChanged(uint256 newFlashLoanFeePercentage);\r\n\r\n    function withdrawCollectedFees(\r\n        IERC20[] calldata tokens,\r\n        uint256[] calldata amounts,\r\n        address recipient\r\n    ) external;\r\n\r\n    function setSwapFeePercentage(uint256 newSwapFeePercentage) external;\r\n\r\n    function setFlashLoanFeePercentage(uint256 newFlashLoanFeePercentage) external;\r\n\r\n    function getSwapFeePercentage() external view returns (uint256);\r\n\r\n    function getFlashLoanFeePercentage() external view returns (uint256);\r\n\r\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts);\r\n\r\n    function getAuthorizer() external view returns (IAuthorizer);\r\n\r\n    function vault() external view returns (IVault);\r\n}\r\n\r\n/**\r\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\r\n * don't override one of these declarations.\r\n */\r\ninterface IVault is ISignaturesValidator, ITemporarilyPausable, IAuthentication {\r\n    // Generalities about the Vault:\r\n    //\r\n    // - Whenever documentation refers to 'tokens', it strictly refers to ERC20-compliant token contracts. Tokens are\r\n    // transferred out of the Vault by calling the `IERC20.transfer` function, and transferred in by calling\r\n    // `IERC20.transferFrom`. In these cases, the sender must have previously allowed the Vault to use their tokens by\r\n    // calling `IERC20.approve`. The only deviation from the ERC20 standard that is supported is functions not returning\r\n    // a boolean value: in these scenarios, a non-reverting call is assumed to be successful.\r\n    //\r\n    // - All non-view functions in the Vault are non-reentrant: calling them while another one is mid-execution (e.g.\r\n    // while execution control is transferred to a token contract during a swap) will result in a revert. View\r\n    // functions can be called in a re-reentrant way, but doing so might cause them to return inconsistent results.\r\n    // Contracts calling view functions in the Vault must make sure the Vault has not already been entered.\r\n    //\r\n    // - View functions revert if referring to either unregistered Pools, or unregistered tokens for registered Pools.\r\n\r\n    // Authorizer\r\n    //\r\n    // Some system actions are permissioned, like setting and collecting protocol fees. This permissioning system exists\r\n    // outside of the Vault in the Authorizer contract: the Vault simply calls the Authorizer to check if the caller\r\n    // can perform a given action.\r\n\r\n    /**\r\n     * @dev Returns the Vault's Authorizer.\r\n     */\r\n    function getAuthorizer() external view returns (IAuthorizer);\r\n\r\n    /**\r\n     * @dev Sets a new Authorizer for the Vault. The caller must be allowed by the current Authorizer to do this.\r\n     *\r\n     * Emits an `AuthorizerChanged` event.\r\n     */\r\n    function setAuthorizer(IAuthorizer newAuthorizer) external;\r\n\r\n    /**\r\n     * @dev Emitted when a new authorizer is set by `setAuthorizer`.\r\n     */\r\n    event AuthorizerChanged(IAuthorizer indexed newAuthorizer);\r\n\r\n    // Relayers\r\n    //\r\n    // Additionally, it is possible for an account to perform certain actions on behalf of another one, using their\r\n    // Vault ERC20 allowance and Internal Balance. These accounts are said to be 'relayers' for these Vault functions,\r\n    // and are expected to be smart contracts with sound authentication mechanisms. For an account to be able to wield\r\n    // this power, two things must occur:\r\n    //  - The Authorizer must grant the account the permission to be a relayer for the relevant Vault function. This\r\n    //    means that Balancer governance must approve each individual contract to act as a relayer for the intended\r\n    //    functions.\r\n    //  - Each user must approve the relayer to act on their behalf.\r\n    // This double protection means users cannot be tricked into approving malicious relayers (because they will not\r\n    // have been allowed by the Authorizer via governance), nor can malicious relayers approved by a compromised\r\n    // Authorizer or governance drain user funds, since they would also need to be approved by each individual user.\r\n\r\n    /**\r\n     * @dev Returns true if `user` has approved `relayer` to act as a relayer for them.\r\n     */\r\n    function hasApprovedRelayer(address user, address relayer) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Allows `relayer` to act as a relayer for `sender` if `approved` is true, and disallows it otherwise.\r\n     *\r\n     * Emits a `RelayerApprovalChanged` event.\r\n     */\r\n    function setRelayerApproval(\r\n        address sender,\r\n        address relayer,\r\n        bool approved\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Emitted every time a relayer is approved or disapproved by `setRelayerApproval`.\r\n     */\r\n    event RelayerApprovalChanged(address indexed relayer, address indexed sender, bool approved);\r\n\r\n    // Internal Balance\r\n    //\r\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\r\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\r\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\r\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\r\n    //\r\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\r\n    // operations of different kinds, with different senders and recipients, at once.\r\n\r\n    /**\r\n     * @dev Returns `user`'s Internal Balance for a set of tokens.\r\n     */\r\n    function getInternalBalance(address user, IERC20[] memory tokens) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\r\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\r\n     * it lets integrators reuse a user's Vault allowance.\r\n     *\r\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\r\n     */\r\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\r\n\r\n    /**\r\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\r\n     without manual WETH wrapping or unwrapping.\r\n     */\r\n    struct UserBalanceOp {\r\n        UserBalanceOpKind kind;\r\n        IAsset asset;\r\n        uint256 amount;\r\n        address sender;\r\n        address payable recipient;\r\n    }\r\n\r\n    // There are four possible operations in `manageUserBalance`:\r\n    //\r\n    // - DEPOSIT_INTERNAL\r\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\r\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\r\n    //\r\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\r\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\r\n    // relevant for relayers).\r\n    //\r\n    // Emits an `InternalBalanceChanged` event.\r\n    //\r\n    //\r\n    // - WITHDRAW_INTERNAL\r\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\r\n    //\r\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\r\n    // it to the recipient as ETH.\r\n    //\r\n    // Emits an `InternalBalanceChanged` event.\r\n    //\r\n    //\r\n    // - TRANSFER_INTERNAL\r\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\r\n    //\r\n    // Reverts if the ETH sentinel value is passed.\r\n    //\r\n    // Emits an `InternalBalanceChanged` event.\r\n    //\r\n    //\r\n    // - TRANSFER_EXTERNAL\r\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\r\n    // relayers, as it lets them reuse a user's Vault allowance.\r\n    //\r\n    // Reverts if the ETH sentinel value is passed.\r\n    //\r\n    // Emits an `ExternalBalanceTransfer` event.\r\n\r\n    enum UserBalanceOpKind { DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL }\r\n\r\n    /**\r\n     * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\r\n     * interacting with Pools using Internal Balance.\r\n     *\r\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\r\n     * address.\r\n     */\r\n    event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\r\n\r\n    /**\r\n     * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\r\n     */\r\n    event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\r\n\r\n    // Pools\r\n    //\r\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\r\n    // functionality:\r\n    //\r\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\r\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\r\n    // which increase with the number of registered tokens.\r\n    //\r\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\r\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\r\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\r\n    // independent of the number of registered tokens.\r\n    //\r\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\r\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\r\n\r\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\r\n\r\n    /**\r\n     * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\r\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\r\n     * changed.\r\n     *\r\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\r\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\r\n     *\r\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\r\n     * multiple Pools may share the same contract.\r\n     *\r\n     * Emits a `PoolRegistered` event.\r\n     */\r\n    function registerPool(PoolSpecialization specialization) external returns (bytes32);\r\n\r\n    /**\r\n     * @dev Emitted when a Pool is registered by calling `registerPool`.\r\n     */\r\n    event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\r\n\r\n    /**\r\n     * @dev Returns a Pool's contract address and specialization setting.\r\n     */\r\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\r\n\r\n    /**\r\n     * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\r\n     *\r\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\r\n     * exit by receiving registered tokens, and can only swap registered tokens.\r\n     *\r\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\r\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\r\n     * ascending order.\r\n     *\r\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\r\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\r\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\r\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\r\n     * Asset Manager should not be made lightly.\r\n     *\r\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\r\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\r\n     * different Asset Manager.\r\n     *\r\n     * Emits a `TokensRegistered` event.\r\n     */\r\n    function registerTokens(\r\n        bytes32 poolId,\r\n        IERC20[] memory tokens,\r\n        address[] memory assetManagers\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\r\n     */\r\n    event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\r\n\r\n    /**\r\n     * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\r\n     *\r\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\r\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\r\n     * must be deregistered in the same `deregisterTokens` call.\r\n     *\r\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\r\n     *\r\n     * Emits a `TokensDeregistered` event.\r\n     */\r\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens) external;\r\n\r\n    /**\r\n     * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\r\n     */\r\n    event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\r\n\r\n    /**\r\n     * @dev Returns detailed information for a Pool's registered token.\r\n     *\r\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\r\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\r\n     * equals the sum of `cash` and `managed`.\r\n     *\r\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\r\n     * `managed` or `total` balance to be greater than 2^112 - 1.\r\n     *\r\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\r\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\r\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\r\n     * change for this purpose, and will update `lastChangeBlock`.\r\n     *\r\n     * `assetManager` is the Pool's token Asset Manager.\r\n     */\r\n    function getPoolTokenInfo(bytes32 poolId, IERC20 token)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 cash,\r\n            uint256 managed,\r\n            uint256 lastChangeBlock,\r\n            address assetManager\r\n        );\r\n\r\n    /**\r\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\r\n     * the tokens' `balances` changed.\r\n     *\r\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\r\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\r\n     *\r\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\r\n     * order as passed to `registerTokens`.\r\n     *\r\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\r\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\r\n     * instead.\r\n     */\r\n    function getPoolTokens(bytes32 poolId)\r\n        external\r\n        view\r\n        returns (\r\n            IERC20[] memory tokens,\r\n            uint256[] memory balances,\r\n            uint256 lastChangeBlock\r\n        );\r\n\r\n    /**\r\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\r\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\r\n     * Pool shares.\r\n     *\r\n     * If the caller is not `sender`, it must be an authorized relayer for them.\r\n     *\r\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\r\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\r\n     * these maximums.\r\n     *\r\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\r\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\r\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\r\n     * back to the caller (not the sender, which is important for relayers).\r\n     *\r\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\r\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\r\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\r\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\r\n     *\r\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\r\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\r\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\r\n     *\r\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\r\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\r\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\r\n     * directly to the Pool's contract, as is `recipient`.\r\n     *\r\n     * Emits a `PoolBalanceChanged` event.\r\n     */\r\n    function joinPool(\r\n        bytes32 poolId,\r\n        address sender,\r\n        address recipient,\r\n        JoinPoolRequest memory request\r\n    ) external payable;\r\n\r\n    struct JoinPoolRequest {\r\n        IAsset[] assets;\r\n        uint256[] maxAmountsIn;\r\n        bytes userData;\r\n        bool fromInternalBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\r\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\r\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\r\n     * `getPoolTokenInfo`).\r\n     *\r\n     * If the caller is not `sender`, it must be an authorized relayer for them.\r\n     *\r\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\r\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\r\n     * it just enforces these minimums.\r\n     *\r\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\r\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\r\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\r\n     *\r\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\r\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\r\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\r\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\r\n     *\r\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\r\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\r\n     * do so will trigger a revert.\r\n     *\r\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\r\n     * `tokens` array. This array must match the Pool's registered tokens.\r\n     *\r\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\r\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\r\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\r\n     * passed directly to the Pool's contract.\r\n     *\r\n     * Emits a `PoolBalanceChanged` event.\r\n     */\r\n    function exitPool(\r\n        bytes32 poolId,\r\n        address sender,\r\n        address payable recipient,\r\n        ExitPoolRequest memory request\r\n    ) external;\r\n\r\n    struct ExitPoolRequest {\r\n        IAsset[] assets;\r\n        uint256[] minAmountsOut;\r\n        bytes userData;\r\n        bool toInternalBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\r\n     */\r\n    event PoolBalanceChanged(\r\n        bytes32 indexed poolId,\r\n        address indexed liquidityProvider,\r\n        IERC20[] tokens,\r\n        int256[] deltas,\r\n        uint256[] protocolFeeAmounts\r\n    );\r\n\r\n    enum PoolBalanceChangeKind { JOIN, EXIT }\r\n\r\n    // Swaps\r\n    //\r\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\r\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\r\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\r\n    //\r\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\r\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\r\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\r\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\r\n    // individual swaps.\r\n    //\r\n    // There are two swap kinds:\r\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\r\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\r\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\r\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\r\n    //\r\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\r\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\r\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\r\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\r\n    // the final intended token.\r\n    //\r\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\r\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\r\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\r\n    // much less gas than they would otherwise.\r\n    //\r\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\r\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\r\n    // updating the Pool's internal accounting).\r\n    //\r\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\r\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\r\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\r\n    //\r\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\r\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\r\n    //\r\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\r\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\r\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\r\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\r\n    //\r\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\r\n\r\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\r\n\r\n    /**\r\n     * @dev Performs a swap with a single Pool.\r\n     *\r\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\r\n     * taken from the Pool, which must be greater than or equal to `limit`.\r\n     *\r\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\r\n     * sent to the Pool, which must be less than or equal to `limit`.\r\n     *\r\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\r\n     *\r\n     * Emits a `Swap` event.\r\n     */\r\n    function swap(\r\n        SingleSwap memory singleSwap,\r\n        FundManagement memory funds,\r\n        uint256 limit,\r\n        uint256 deadline\r\n    ) external payable returns (uint256);\r\n\r\n    /**\r\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\r\n     * the `kind` value.\r\n     *\r\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\r\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\r\n     *\r\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\r\n     * used to extend swap behavior.\r\n     */\r\n    struct SingleSwap {\r\n        bytes32 poolId;\r\n        SwapKind kind;\r\n        IAsset assetIn;\r\n        IAsset assetOut;\r\n        uint256 amount;\r\n        bytes userData;\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\r\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\r\n     *\r\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\r\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\r\n     * the same index in the `assets` array.\r\n     *\r\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\r\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\r\n     * `amountOut` depending on the swap kind.\r\n     *\r\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\r\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\r\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\r\n     *\r\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\r\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\r\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\r\n     * or unwrapped from WETH by the Vault.\r\n     *\r\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\r\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\r\n     *\r\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\r\n     * equivalent `swap` call.\r\n     *\r\n     * Emits `Swap` events.\r\n     */\r\n    function batchSwap(\r\n        SwapKind kind,\r\n        BatchSwapStep[] memory swaps,\r\n        IAsset[] memory assets,\r\n        FundManagement memory funds,\r\n        int256[] memory limits,\r\n        uint256 deadline\r\n    ) external payable returns (int256[] memory);\r\n\r\n    /**\r\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\r\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\r\n     *\r\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\r\n     * from the previous swap, depending on the swap kind.\r\n     *\r\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\r\n     * used to extend swap behavior.\r\n     */\r\n    struct BatchSwapStep {\r\n        bytes32 poolId;\r\n        uint256 assetInIndex;\r\n        uint256 assetOutIndex;\r\n        uint256 amount;\r\n        bytes userData;\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\r\n     */\r\n    event Swap(\r\n        bytes32 indexed poolId,\r\n        IERC20 indexed tokenIn,\r\n        IERC20 indexed tokenOut,\r\n        uint256 amountIn,\r\n        uint256 amountOut\r\n    );\r\n\r\n    /**\r\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\r\n     * `recipient` account.\r\n     *\r\n     * If the caller is not `sender`, it must be an authorized relayer for them.\r\n     *\r\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\r\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\r\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\r\n     * `joinPool`.\r\n     *\r\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\r\n     * transferred. This matches the behavior of `exitPool`.\r\n     *\r\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\r\n     * revert.\r\n     */\r\n    struct FundManagement {\r\n        address sender;\r\n        bool fromInternalBalance;\r\n        address payable recipient;\r\n        bool toInternalBalance;\r\n    }\r\n\r\n    /**\r\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\r\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\r\n     *\r\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\r\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\r\n     * receives are the same that an equivalent `batchSwap` call would receive.\r\n     *\r\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\r\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\r\n     * approve them for the Vault, or even know a user's address.\r\n     *\r\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\r\n     * eth_call instead of eth_sendTransaction.\r\n     */\r\n    function queryBatchSwap(\r\n        SwapKind kind,\r\n        BatchSwapStep[] memory swaps,\r\n        IAsset[] memory assets,\r\n        FundManagement memory funds\r\n    ) external returns (int256[] memory assetDeltas);\r\n\r\n    // Flash Loans\r\n\r\n    /**\r\n     * @dev Performs a 'flash loan', sending tokens to `recipient`, executing the `receiveFlashLoan` hook on it,\r\n     * and then reverting unless the tokens plus a proportional protocol fee have been returned.\r\n     *\r\n     * The `tokens` and `amounts` arrays must have the same length, and each entry in these indicates the loan amount\r\n     * for each token contract. `tokens` must be sorted in ascending order.\r\n     *\r\n     * The 'userData' field is ignored by the Vault, and forwarded as-is to `recipient` as part of the\r\n     * `receiveFlashLoan` call.\r\n     *\r\n     * Emits `FlashLoan` events.\r\n     */\r\n    function flashLoan(\r\n        IFlashLoanRecipient recipient,\r\n        IERC20[] memory tokens,\r\n        uint256[] memory amounts,\r\n        bytes memory userData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Emitted for each individual flash loan performed by `flashLoan`.\r\n     */\r\n    event FlashLoan(IFlashLoanRecipient indexed recipient, IERC20 indexed token, uint256 amount, uint256 feeAmount);\r\n\r\n    // Asset Management\r\n    //\r\n    // Each token registered for a Pool can be assigned an Asset Manager, which is able to freely withdraw the Pool's\r\n    // tokens from the Vault, deposit them, or assign arbitrary values to its `managed` balance (see\r\n    // `getPoolTokenInfo`). This makes them extremely powerful and dangerous. Even if an Asset Manager only directly\r\n    // controls one of the tokens in a Pool, a malicious manager could set that token's balance to manipulate the\r\n    // prices of the other tokens, and then drain the Pool with swaps. The risk of using Asset Managers is therefore\r\n    // not constrained to the tokens they are managing, but extends to the entire Pool's holdings.\r\n    //\r\n    // However, a properly designed Asset Manager smart contract can be safely used for the Pool's benefit,\r\n    // for example by lending unused tokens out for interest, or using them to participate in voting protocols.\r\n    //\r\n    // This concept is unrelated to the IAsset interface.\r\n\r\n    /**\r\n     * @dev Performs a set of Pool balance operations, which may be either withdrawals, deposits or updates.\r\n     *\r\n     * Pool Balance management features batching, which means a single contract call can be used to perform multiple\r\n     * operations of different kinds, with different Pools and tokens, at once.\r\n     *\r\n     * For each operation, the caller must be registered as the Asset Manager for `token` in `poolId`.\r\n     */\r\n    function managePoolBalance(PoolBalanceOp[] memory ops) external;\r\n\r\n    struct PoolBalanceOp {\r\n        PoolBalanceOpKind kind;\r\n        bytes32 poolId;\r\n        IERC20 token;\r\n        uint256 amount;\r\n    }\r\n\r\n    /**\r\n     * Withdrawals decrease the Pool's cash, but increase its managed balance, leaving the total balance unchanged.\r\n     *\r\n     * Deposits increase the Pool's cash, but decrease its managed balance, leaving the total balance unchanged.\r\n     *\r\n     * Updates don't affect the Pool's cash balance, but because the managed balance changes, it does alter the total.\r\n     * The external amount can be either increased or decreased by this call (i.e., reporting a gain or a loss).\r\n     */\r\n    enum PoolBalanceOpKind { WITHDRAW, DEPOSIT, UPDATE }\r\n\r\n    /**\r\n     * @dev Emitted when a Pool's token Asset Manager alters its balance via `managePoolBalance`.\r\n     */\r\n    event PoolBalanceManaged(\r\n        bytes32 indexed poolId,\r\n        address indexed assetManager,\r\n        IERC20 indexed token,\r\n        int256 cashDelta,\r\n        int256 managedDelta\r\n    );\r\n\r\n    // Protocol Fees\r\n    //\r\n    // Some operations cause the Vault to collect tokens in the form of protocol fees, which can then be withdrawn by\r\n    // permissioned accounts.\r\n    //\r\n    // There are two kinds of protocol fees:\r\n    //\r\n    //  - flash loan fees: charged on all flash loans, as a percentage of the amounts lent.\r\n    //\r\n    //  - swap fees: a percentage of the fees charged by Pools when performing swaps. For a number of reasons, including\r\n    // swap gas costs and interface simplicity, protocol swap fees are not charged on each individual swap. Rather,\r\n    // Pools are expected to keep track of how much they have charged in swap fees, and pay any outstanding debts to the\r\n    // Vault when they are joined or exited. This prevents users from joining a Pool with unpaid debt, as well as\r\n    // exiting a Pool in debt without first paying their share.\r\n\r\n    /**\r\n     * @dev Returns the current protocol fee module.\r\n     */\r\n    function getProtocolFeesCollector() external view returns (IProtocolFeesCollector);\r\n\r\n    /**\r\n     * @dev Safety mechanism to pause most Vault operations in the event of an emergency - typically detection of an\r\n     * error in some part of the system.\r\n     *\r\n     * The Vault can only be paused during an initial time period, after which pausing is forever disabled.\r\n     *\r\n     * While the contract is paused, the following features are disabled:\r\n     * - depositing and transferring internal balance\r\n     * - transferring external balance (using the Vault's allowance)\r\n     * - swaps\r\n     * - joining Pools\r\n     * - Asset Manager interactions\r\n     *\r\n     * Internal Balance can still be withdrawn, and Pools exited.\r\n     */\r\n    function setPaused(bool paused) external;\r\n\r\n    /**\r\n     * @dev Returns the Vault's WETH instance.\r\n     */\r\n    function WETH() external view returns (IWETH);\r\n    // solhint-disable-previous-line func-name-mixedcase\r\n}\r\n\r\ninterface IQuery {\r\n\r\n    function queryJoin(\r\n            bytes32 poolId,\r\n            address sender,\r\n            address recipient,\r\n            IVault.JoinPoolRequest memory request) external returns (uint256 bptOut, uint256[] memory amountsIn);\r\n\r\n    function queryExit(\r\n        bytes32 poolId,\r\n        address sender,\r\n        address recipient,\r\n        IVault.ExitPoolRequest memory request) external returns (uint256 bptIn, uint256[] memory amountsOut);\r\n}\r\n\r\ninterface IBalancerMinter {\r\n    function mint(address gauge) external returns (uint256);\r\n}\r\n\r\ncontract stkSWIV is ERC20 {\r\n    using FixedPointMathLib for uint256;\r\n\r\n    // The Swivel Multisig (or should be)\r\n    address public admin;\r\n    // The Swivel Token\r\n    ERC20 immutable public SWIV;\r\n    // The Swivel/ETH balancer LP token\r\n    ERC20 immutable public balancerLPT;\r\n    // The Static Balancer Vault\r\n    IVault immutable public balancerVault;\r\n    // The Static Balancer Query Helper\r\n    IQuery immutable public balancerQuery;\r\n    // The Static Balancer Token ERC20\r\n    ERC20 immutable public balancerToken;\r\n    // The previous stkSWIV contract\r\n    address immutable public migratedSSM;\r\n    // The Balancer Pool ID\r\n    bytes32 public balancerPoolID;\r\n    // The withdrawal cooldown length\r\n    uint256 public cooldownLength = 2 weeks;\r\n    // The window to withdraw after cooldown\r\n    uint256 public withdrawalWindow = 1 weeks;\r\n    // Mapping of user address -> unix timestamp for cooldown\r\n    mapping (address => uint256) public cooldownTime;\r\n    // Mapping of user address -> amount of stkSWIV shares to be withdrawn\r\n    mapping (address => uint256) internal _cooldownAmount;\r\n    // Determines whether the contract is paused or not\r\n    bool public paused;\r\n    // The most recently withdrawn BPT timestamp in unix (only when paying out insurance)\r\n    uint256 public lastWithdrawnBPT;\r\n    // The queued emergency withdrawal time mapping\r\n    mapping (address => uint256) public withdrawalTime;\r\n    // The WETH address\r\n    IWETH immutable public WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n\r\n    event Donation(uint256 amount, address indexed donator);\r\n\r\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed caller,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    event Paused(bool);\r\n\r\n    event WithdrawalQueued(address indexed token, uint256 indexed timestamp);\r\n\r\n    error Exception(uint8, uint256, uint256, address, address);\r\n\r\n    constructor (ERC20 s, ERC20 b, bytes32 p, address previous) ERC20(\"Staked SWIV/ETH\", \"stkSWIV\", s.decimals() + 18) {\r\n        SWIV = s;\r\n        balancerVault = IVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\r\n        balancerLPT = b;\r\n        balancerPoolID = p;\r\n        balancerQuery = IQuery(0xE39B5e3B6D74016b2F6A9673D7d7493B6DF549d5);\r\n        balancerToken = ERC20(0xba100000625a3754423978a60c9317c58a424e3D);\r\n        admin = msg.sender;\r\n        SafeTransferLib.approve(SWIV, address(balancerVault), type(uint256).max);\r\n        SafeTransferLib.approve(ERC20(address(WETH)), address(balancerVault), type(uint256).max);\r\n        migratedSSM = previous;\r\n    }\r\n\r\n    function migrate(address[] calldata migrationOwners) external Authorized(admin) {\r\n        // Mint each migrationOwner their balanceOf prevStkSWIV\r\n        for (uint256 i = 0; i < migrationOwners.length; i++) {\r\n            _mint(migrationOwners[i], IERC20(migratedSSM).balanceOf(migrationOwners[i]));\r\n        }\r\n    }\r\n\r\n    fallback() external payable {\r\n    }\r\n\r\n    // @notice: If the user's cooldown window is passed, their cooldown amount is reset to 0\r\n    // @param: owner - address of the owner\r\n    // @returns: the cooldown amount\r\n    function cooldownAmount(address owner) public view returns(uint256){\r\n        if (cooldownTime[owner] + withdrawalWindow < block.timestamp) {\r\n            return 0;\r\n        }\r\n        return _cooldownAmount[owner];\r\n    }\r\n\r\n    function asset() public view returns (address) {\r\n        return (address(balancerLPT));\r\n    }\r\n\r\n    function totalAssets() public view returns (uint256 assets) {\r\n        return (balancerLPT.balanceOf(address(this)));\r\n    }\r\n\r\n    // The number of SWIV/ETH balancer shares owned / the stkSWIV total supply\r\n    // Conversion of 1 stkSWIV share to an amount of SWIV/ETH balancer shares (scaled to 1e18) (starts at 1:1e18)\r\n    // Buffered by 1e18 to avoid 4626 inflation attacks -- https://ethereum-magicians.org/t/address-eip-4626-inflation-attacks-with-virtual-shares-and-assets/12677\r\n    // @returns: the exchange rate\r\n    function exchangeRateCurrent() public view returns (uint256) {\r\n        return (this.totalSupply() + 1e18 / totalAssets() + 1);\r\n    }\r\n\r\n    // Conversion of amount of SWIV/ETH balancer assets to stkSWIV shares\r\n    // @param: assets - amount of SWIV/ETH balancer pool tokens\r\n    // @returns: the amount of stkSWIV shares\r\n    function convertToShares(uint256 assets) public view returns (uint256 shares) {\r\n        return (assets.mulDivDown(this.totalSupply() + 1e18, totalAssets() + 1));\r\n    }\r\n\r\n    // Conversion of amount of stkSWIV shares to SWIV/ETH balancer assets\r\n    // @param: shares - amount of stkSWIV shares\r\n    // @returns: the amount of SWIV/ETH balancer pool tokens\r\n    function convertToAssets(uint256 shares) public view returns (uint256 assets) {\r\n        return (shares.mulDivDown(totalAssets() + 1, this.totalSupply() + 1e18));\r\n    }\r\n\r\n    // Preview of the amount of balancerLPT required to mint `shares` of stkSWIV\r\n    // @param: shares - amount of stkSWIV shares\r\n    // @returns: assets the amount of balancerLPT tokens required\r\n    function previewMint(uint256 shares) public view virtual returns (uint256 assets) {\r\n        return (shares.mulDivUp(totalAssets() + 1, this.totalSupply() + 1e18));\r\n    }\r\n\r\n    // Preview of the amount of balancerLPT received from redeeming `shares` of stkSWIV\r\n    // @param: shares - amount of stkSWIV shares\r\n    // @returns: assets the amount of balancerLPT tokens received\r\n    function previewRedeem(uint256 shares) public view virtual returns (uint256 assets) {\r\n        return (convertToAssets(shares));\r\n    }\r\n\r\n    // Preview of the amount of stkSWIV received from depositing `assets` of balancerLPT\r\n    // @param: assets - amount of balancerLPT tokens\r\n    // @returns: shares the amount of stkSWIV shares received\r\n    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {\r\n        return (convertToShares(assets));\r\n    }\r\n\r\n    // Preview of the amount of stkSWIV required to withdraw `assets` of balancerLPT\r\n    // @param: assets - amount of balancerLPT tokens\r\n    // @returns: shares the amount of stkSWIV shares required\r\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256 shares) {\r\n        return (assets.mulDivUp(this.totalSupply() + 1e18, totalAssets() + 1));\r\n    }\r\n\r\n    // Maximum amount a given receiver can mint\r\n    // @param: receiver - address of the receiver\r\n    // @returns: the maximum amount of stkSWIV shares\r\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\r\n        return (type(uint256).max);\r\n    }\r\n\r\n    // Maximum amount a given owner can redeem\r\n    // @param: owner - address of the owner\r\n    // @returns: the maximum amount of stkSWIV shares\r\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\r\n        return (this.balanceOf(owner));\r\n    }\r\n\r\n    // Maximum amount a given owner can withdraw\r\n    // @param: owner - address of the owner\r\n    // @returns: the maximum amount of balancerLPT assets\r\n    function maxWithdraw(address owner) public view returns (uint256 maxAssets) {\r\n        return (convertToAssets(this.balanceOf(owner)));\r\n    }\r\n\r\n    // Maximum amount a given receiver can deposit\r\n    // @param: receiver - address of the receiver\r\n    // @returns: the maximum amount of balancerLPT assets\r\n    function maxDeposit(address receiver) public pure returns (uint256 maxAssets) {\r\n        return (type(uint256).max);\r\n    }\r\n\r\n    // Queues `amount` of stkSWIV shares to be withdrawn after the cooldown period\r\n    // @param: amount - amount of stkSWIV shares to be withdrawn\r\n    // @returns: the total amount of stkSWIV shares to be withdrawn\r\n    function cooldown(uint256 shares) public returns (uint256) {\r\n        // Require the total amount to be < balanceOf\r\n        if (cooldownAmount(msg.sender) + shares > balanceOf[msg.sender]) {\r\n            revert Exception(40, cooldownAmount(msg.sender) + shares, balanceOf[msg.sender], msg.sender, address(0));\r\n        }\r\n        // If cooldown window has passed, reset cooldownAmount + add, else add to current cooldownAmount\r\n        if (cooldownTime[msg.sender] + withdrawalWindow < block.timestamp) {\r\n            _cooldownAmount[msg.sender] = shares;\r\n        }\r\n        else {\r\n            _cooldownAmount[msg.sender] = _cooldownAmount[msg.sender] + shares;\r\n        }\r\n        // Reset cooldown time\r\n        cooldownTime[msg.sender] = block.timestamp + cooldownLength;\r\n\r\n        return(_cooldownAmount[msg.sender]);\r\n    }\r\n\r\n    // Mints `shares` to `receiver` and transfers `assets` of balancerLPT tokens from `msg.sender`\r\n    // @param: shares - amount of stkSWIV shares to mint\r\n    // @param: receiver - address of the receiver\r\n    // @returns: the amount of balancerLPT tokens deposited\r\n    function mint(uint256 shares, address receiver) public payable returns (uint256) {\r\n        // Convert shares to assets\r\n        uint256 assets = previewMint(shares);\r\n        // Transfer assets of balancer LP tokens from sender to this contract\r\n        SafeTransferLib.transferFrom(balancerLPT, msg.sender, address(this), assets);\r\n        // Mint shares to receiver\r\n        _mint(receiver, shares);\r\n        // Emit deposit event\r\n        emit Deposit(msg.sender, receiver, assets, shares);\r\n\r\n        return (assets);\r\n    }\r\n\r\n    // Redeems `shares` from `owner` and transfers `assets` of balancerLPT tokens to `receiver`\r\n    // @param: shares - amount of stkSWIV shares to redeem\r\n    // @param: receiver - address of the receiver\r\n    // @param: owner - address of the owner\r\n    // @returns: the amount of balancerLPT tokens withdrawn\r\n    function redeem(uint256 shares, address receiver, address owner) Unpaused() public returns (uint256) {\r\n        // Convert shares to assets\r\n        uint256 assets = previewRedeem(shares);\r\n        // Get the cooldown time\r\n        uint256 cTime = cooldownTime[msg.sender];\r\n        // If the sender is not the owner check allowances\r\n        if (msg.sender != owner) {\r\n            uint256 allowed = allowance[owner][msg.sender];\r\n            // If the allowance is not max, subtract the shares from the allowance, reverts on underflow if not enough allowance\r\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\r\n        }\r\n        // If the cooldown time is in the future or 0, revert\r\n        if (cTime > block.timestamp || cTime == 0 || cTime + withdrawalWindow < block.timestamp) {\r\n            revert Exception(41, cTime, block.timestamp, address(0), address(0));\r\n        }\r\n        // If the redeemed shares is greater than the cooldown amount, revert\r\n        uint256 cAmount = cooldownAmount(msg.sender);\r\n        if (shares > cAmount) {\r\n            revert Exception(40, cAmount, shares, address(0), address(0));\r\n        }\r\n        // If the shares are greater than the balance of the owner, revert\r\n        if (shares > this.balanceOf(owner)) {\r\n            revert Exception(42, shares, this.balanceOf(owner), address(0), address(0));\r\n        }\r\n        // Transfer the balancer LP tokens to the receiver\r\n        SafeTransferLib.transfer(balancerLPT, receiver, assets);\r\n        // Burn the shares\r\n        _burn(msg.sender, shares);\r\n        // Reset the cooldown amount\r\n        _cooldownAmount[msg.sender] = _cooldownAmount[msg.sender] - shares;\r\n        // Emit withdraw event\r\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\r\n\r\n        return (assets);\r\n    }\r\n\r\n    // Deposits `assets` of balancerLPT tokens from `msg.sender` and mints `shares` to `receiver`\r\n    // @param: assets - amount of balancerLPT tokens to deposit\r\n    // @param: receiver - address of the receiver\r\n    // @returns: the amount of stkSWIV shares minted\r\n    function deposit(uint256 assets, address receiver) public returns (uint256) {\r\n        // Convert assets to shares          \r\n        uint256 shares = previewDeposit(assets);\r\n        // Transfer assets of balancer LP tokens from sender to this contract\r\n        SafeTransferLib.transferFrom(balancerLPT, msg.sender, address(this), assets);        \r\n        // Mint shares to receiver\r\n        _mint(receiver, shares);\r\n        // Emit deposit event\r\n        emit Deposit(msg.sender, receiver, assets, shares);\r\n\r\n        return (shares);\r\n    }\r\n\r\n    // Withdraws `assets` of balancerLPT tokens to `receiver` and burns `shares` from `owner`\r\n    // @param: assets - amount of balancerLPT tokens to withdraw\r\n    // @param: receiver - address of the receiver\r\n    // @param: owner - address of the owner\r\n    // @returns: the amount of stkSWIV shares withdrawn\r\n    function withdraw(uint256 assets, address receiver, address owner) Unpaused()  public returns (uint256) {\r\n        // Convert assets to shares\r\n        uint256 shares = previewWithdraw(assets);\r\n        // Get the cooldown time\r\n        uint256 cTime = cooldownTime[msg.sender];\r\n        // If the sender is not the owner check allowances\r\n        if (msg.sender != owner) {\r\n            uint256 allowed = allowance[owner][msg.sender];\r\n            // If the allowance is not max, subtract the shares from the allowance, reverts on underflow if not enough allowance\r\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\r\n        }\r\n        // If the cooldown time is in the future or 0, revert\r\n        if (cTime > block.timestamp || cTime == 0 || cTime + withdrawalWindow < block.timestamp) {\r\n            revert Exception(41, cTime, block.timestamp, address(0), address(0));\r\n        }\r\n        // If the redeemed shares is greater than the cooldown amount, revert\r\n        uint256 cAmount = cooldownAmount(msg.sender);\r\n        if (shares > cAmount) {\r\n            revert Exception(40, cAmount, shares, address(0), address(0));\r\n        }\r\n        // If the shares are greater than the balance of the owner, revert\r\n        if (shares > this.balanceOf(owner)) {\r\n            revert Exception(42, shares, this.balanceOf(owner), address(0), address(0));\r\n        }\r\n        // Transfer the balancer LP tokens to the receiver\r\n        SafeTransferLib.transfer(balancerLPT, receiver, assets);\r\n        // Burn the shares   \r\n        _burn(msg.sender, shares);\r\n        // Reset the cooldown amount\r\n        _cooldownAmount[msg.sender] = _cooldownAmount[msg.sender] - shares;\r\n        // Emit withdraw event\r\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\r\n\r\n        return (shares);\r\n    }\r\n\r\n    //////////////////// ZAP METHODS ////////////////////\r\n\r\n    // Transfers a calculated amount of SWIV tokens from `msg.sender` while receiving `msg.value` of ETH\r\n    // Then joins the balancer pool with the SWIV and ETH before minting minBPT of shares to `receiver`\r\n    // Slippage is bound by the `shares` parameter and the calculated maximumSWIV\r\n    // @notice: The amounts transacted in this method are based on msg.value -- `shares` is the minimum amount of shares to mint\r\n    // @param: shares - minimum amount of stkSWIV shares to mint\r\n    // @param: receiver - address of the receiver\r\n    // @returns: assets the amount of SWIV tokens deposited\r\n    // @returns: sharesToMint the actual amount of shares minted\r\n    function mintZap(uint256 shares, address receiver, uint256 maximumSWIV) public payable returns (uint256 assets, uint256 sharesToMint, uint256[2] memory balancesSpent) {\r\n        // Get token info from vault\r\n        (,uint256[] memory balances,) = balancerVault.getPoolTokens(balancerPoolID);\r\n        // Calculate SWIV transfer amount from msg.value (expecting at least enough msg.value and SWIV available to cover `shares` minted)\r\n        uint256 swivAmount = msg.value * balances[0] / balances[1];\r\n        // If the SWIV amount is greater than the maximum SWIV, revert\r\n        if (swivAmount > maximumSWIV) {\r\n            revert Exception(43, swivAmount, maximumSWIV, address(0), address(0));\r\n        }\r\n        // Query the pool join to get the bpt out (assets)\r\n        (uint256 minBPT, uint256[] memory amountsIn) = queryBalancerJoin(1, [address(SWIV), address(WETH)], [swivAmount, msg.value], 0);\r\n        // Calculate expected shares to mint before transfering funds \r\n        sharesToMint = convertToShares(minBPT);\r\n        // Wrap msg.value into WETH\r\n        WETH.deposit{value: msg.value}();\r\n        // Transfer assets of SWIV tokens from sender to this contract\r\n        SafeTransferLib.transferFrom(SWIV, msg.sender, address(this), amountsIn[0]);\r\n        // Join the balancer pool\r\n        balancerJoin(1, [address(SWIV), address(WETH)], [amountsIn[0], amountsIn[1]], minBPT);\r\n        // If the shares to mint is less than the minimum shares, revert\r\n        if (sharesToMint < shares) {\r\n            revert Exception(44, sharesToMint, shares, address(0), address(0));\r\n        }\r\n        // Mint shares to receiver\r\n        _mint(receiver, sharesToMint);\r\n        {\r\n            // If there is any leftover SWIV, transfer it to the msg.sender\r\n            uint256 remainingSWIV = SWIV.balanceOf(address(this));\r\n            if (remainingSWIV > 0) {\r\n                // Transfer the SWIV to the receiver\r\n                SafeTransferLib.transfer(SWIV, msg.sender, remainingSWIV);\r\n            }\r\n            uint256 remainingWETH = WETH.balanceOf(address(this));\r\n            // If there is any leftover ETH, transfer it to the msg.sender\r\n            if (remainingWETH > 0) {\r\n                // Transfer the ETH to the receiver\r\n                WETH.withdraw(remainingWETH);\r\n                payable(msg.sender).transfer(remainingWETH);\r\n            }\r\n        }\r\n        // Emit deposit event\r\n        emit Deposit(msg.sender, receiver, minBPT, sharesToMint);\r\n\r\n        return (minBPT, sharesToMint, [amountsIn[0], amountsIn[1]]);\r\n    }\r\n\r\n    // Exits the balancer pool and transfers queried amounts of SWIV tokens and ETH to `receiver`\r\n    // Then burns `shares` from `owner`\r\n    // Slippage is bound by minimumETH and minimumSWIV\r\n    // @param: shares - amount of stkSWIV shares to redeem\r\n    // @param: receiver - address of the receiver\r\n    // @param: owner - address of the owner\r\n    // @returns: assets the amount of bpt withdrawn\r\n    // @returns: sharesBurnt the amount of stkSWIV shares burnt\r\n    function redeemZap(uint256 shares, address payable receiver, address owner, uint256 minimumETH, uint256 minimumSWIV) Unpaused()  public returns (uint256 assets, uint256 sharesBurnt, uint256[2] memory balancesReturned) {\r\n        // Convert shares to assets\r\n        assets = previewRedeem(shares);\r\n        {\r\n            // Get the cooldown time\r\n            uint256 cTime = cooldownTime[msg.sender];\r\n            // If the sender is not the owner check allowances\r\n            if (msg.sender != owner) {\r\n                uint256 allowed = allowance[owner][msg.sender];\r\n                // If the allowance is not max, subtract the shares from the allowance, reverts on underflow if not enough allowance\r\n                if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\r\n            }\r\n            // If the cooldown time is in the future or 0, revert\r\n            if (cTime > block.timestamp || cTime == 0 || cTime + withdrawalWindow < block.timestamp) {\r\n                revert Exception(41, cTime, block.timestamp, address(0), address(0));\r\n            }\r\n            {\r\n                // If the redeemed shares is greater than the cooldown amount, revert\r\n                uint256 cAmount = cooldownAmount(msg.sender);\r\n                if (shares > cAmount) {\r\n                    revert Exception(40, cAmount, shares, address(0), address(0));\r\n                }\r\n            }\r\n        }\r\n        // If the shares are greater than the balance of the owner, revert\r\n        if (shares > this.balanceOf(owner)) {\r\n            revert Exception(42, shares, this.balanceOf(owner), address(0), address(0));\r\n        }\r\n        // Query the pool exit to get the amounts out\r\n        (uint256 bptIn, uint256[] memory amountsOut) = queryBalancerExit([address(SWIV), address(WETH)], [minimumSWIV, minimumETH], assets);\r\n        // If bptIn isnt equivalent to assets, overwrite shares\r\n        if (bptIn != assets) {\r\n            shares = convertToShares(bptIn);\r\n            // Require the bptIn <= shares converted to assets (to account for slippage)\r\n            if (bptIn > convertToAssets(shares)) {\r\n                revert Exception(46, bptIn, convertToAssets(shares), address(0), address(0));\r\n            }\r\n        }\r\n        // If the eth or swiv out is less than the minimum, revert\r\n        if (amountsOut[0] < minimumSWIV || amountsOut[1] < minimumETH) {\r\n            revert Exception(47, amountsOut[0], minimumSWIV, address(0), address(0));\r\n        }\r\n        // Exit the balancer pool\r\n        balancerExit(1, [address(SWIV), address(WETH)], [amountsOut[0], amountsOut[1]], bptIn);\r\n        // Unwrap the WETH\r\n        WETH.withdraw(amountsOut[1]);\r\n        // Transfer the SWIV tokens to the receiver\r\n        SafeTransferLib.transfer(SWIV, receiver, amountsOut[0]);\r\n        // Transfer the ETH to the receiver\r\n        receiver.transfer(amountsOut[1]);\r\n        // Burn the shares\r\n        _burn(msg.sender, shares);\r\n        // // Reset the cooldown amount\r\n        _cooldownAmount[msg.sender] = _cooldownAmount[msg.sender] - shares;\r\n        // // Emit withdraw event\r\n        emit Withdraw(msg.sender, receiver, owner, bptIn, shares);\r\n\r\n        return (bptIn, shares, [amountsOut[0], amountsOut[1]]);\r\n    }\r\n\r\n    // Transfers `assets` of SWIV tokens from `msg.sender` while receiving `msg.value` of ETH\r\n    // Then joins the balancer pool with the SWIV and ETH before minting `shares` to `receiver`\r\n    // Slippage is bound by minimumBPT\r\n    // @param: assets - amount of SWIV tokens to deposit\r\n    // @param: receiver - address of the receiver\r\n    // @param: minimumBPT - minimum amount of balancerLPT tokens to mint\r\n    // @returns: the amount of stkSWIV shares minted\r\n    // @returns: the amount of swiv actually deposited\r\n    function depositZap(uint256 assets, address receiver, uint256 minimumBPT) public payable returns (uint256 sharesMinted, uint256 bptIn, uint256[2] memory balancesSpent) {\r\n        // Transfer assets of SWIV tokens from sender to this contract\r\n        SafeTransferLib.transferFrom(SWIV, msg.sender, address(this), assets);\r\n        // Wrap msg.value into WETH\r\n        WETH.deposit{value: msg.value}();\r\n        // Query the pool join to get the bpt out\r\n        (uint256 bptOut, uint256[] memory amountsIn) = queryBalancerJoin(1, [address(SWIV), address(WETH)], [assets, msg.value], minimumBPT);\r\n        // If the bptOut is less than the minimum bpt, revert (to account for slippage)\r\n        if (bptOut < minimumBPT) {\r\n            revert Exception(46, bptOut, minimumBPT, address(0), address(0));\r\n        }\r\n        //  Calculate shares to mint\r\n        sharesMinted = convertToShares(bptOut);\r\n        // Join the balancer pool\r\n        balancerJoin(1, [address(SWIV), address(WETH)], [amountsIn[0], amountsIn[1]], bptOut);\r\n        // // Mint shares to receiver\r\n        _mint(receiver, sharesMinted);\r\n        // If there is any leftover SWIV, transfer it to the msg.sender\r\n        uint256 swivBalance = SWIV.balanceOf(address(this));\r\n        if (swivBalance > 0) {\r\n            // Transfer the SWIV to the receiver\r\n            SafeTransferLib.transfer(SWIV, msg.sender, swivBalance);\r\n        }\r\n        // If there is any leftover ETH, transfer it to the msg.sender\r\n        if (WETH.balanceOf(address(this)) > 0) {\r\n            // Transfer the ETH to the receiver\r\n            uint256 wethAmount = WETH.balanceOf(address(this));\r\n            WETH.withdraw(wethAmount);\r\n            payable(msg.sender).transfer(wethAmount);\r\n        }\r\n        // Emit deposit event\r\n        emit Deposit(msg.sender, receiver, assets, sharesMinted);\r\n\r\n        return (sharesMinted, bptOut, [amountsIn[0], amountsIn[1]]);\r\n    }\r\n\r\n    // Exits the balancer pool and transfers `assets` of SWIV tokens and the current balance of ETH to `receiver`\r\n    // Then burns `shares` from `owner`\r\n    // Slippage is bound by maximumBPT\r\n    // @param: assets - amount of SWIV tokens to withdraw\r\n    // @param: receiver - address of the receiver\r\n    // @param: owner - address of the owner\r\n    // @param: maximumBPT - maximum amount of balancerLPT tokens to redeem\r\n    // @returns: the amount of stkSWIV shares burnt\r\n    function withdrawZap(uint256 assets, uint256 ethAssets, address payable receiver, address owner, uint256 maximumBPT) Unpaused() public returns (uint256 sharesRedeemed, uint256 bptOut, uint256[2] memory balancesReturned) {\r\n        // Get the cooldown time\r\n        uint256 cTime = cooldownTime[msg.sender];\r\n        // If the sender is not the owner check allowances\r\n        // If the cooldown time is in the future or 0, revert\r\n        if (cTime > block.timestamp || cTime + withdrawalWindow < block.timestamp) {\r\n            revert Exception(41, cTime, block.timestamp, address(0), address(0));\r\n        }\r\n        // Query the pool exit to get the amounts out\r\n        (uint256 bptOut, uint256[] memory amountsOut) = queryBalancerExit([address(SWIV), address(WETH)], [assets, ethAssets], maximumBPT);\r\n        // Require the bptOut to be less than the maximum bpt (to account for slippage)\r\n        if (bptOut > maximumBPT) {\r\n            revert Exception(46, bptOut, maximumBPT, address(0), address(0));\r\n        }\r\n        // Calculate shares to redeem\r\n        sharesRedeemed = convertToShares(bptOut);\r\n        // This method is unique in that we cannot check against cAmounts before calculating shares\r\n        // If the redeemed shares is greater than the cooldown amount, revert\r\n        {\r\n            uint256 cAmount = cooldownAmount(msg.sender);\r\n            if (sharesRedeemed > cAmount) {\r\n                revert Exception(40, cAmount, sharesRedeemed, address(0), address(0));\r\n            }\r\n        }\r\n        // If the shares are greater than the balance of the owner, revert\r\n        if (sharesRedeemed > this.balanceOf(owner)) {\r\n            revert Exception(2, sharesRedeemed, this.balanceOf(owner), address(0), address(0));\r\n        }\r\n        if (msg.sender != owner) {\r\n            uint256 allowed = allowance[owner][msg.sender];\r\n            // If the allowance is not max, subtract the shares from the allowance, reverts on underflow if not enough allowance\r\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - sharesRedeemed;\r\n        }\r\n        // Exit the balancer pool\r\n        balancerExit(2, [address(SWIV), address(WETH)], [amountsOut[0], amountsOut[1]], bptOut);\r\n        // Unwrap the WETH\r\n        WETH.withdraw(amountsOut[1]);\r\n        // Transfer the SWIV tokens to the receiver\r\n        SafeTransferLib.transfer(SWIV, receiver, amountsOut[0]);\r\n        // Transfer the ETH to the receiver\r\n        receiver.transfer(amountsOut[1]);\r\n        // Burn the shares\r\n        _burn(msg.sender, sharesRedeemed);\r\n        // Reset the cooldown amount\r\n        _cooldownAmount[msg.sender] = _cooldownAmount[msg.sender] - sharesRedeemed;\r\n        // Emit withdraw event\r\n        emit Withdraw(msg.sender, receiver, owner, bptOut, sharesRedeemed);\r\n\r\n        return (sharesRedeemed, bptOut, [amountsOut[0], amountsOut[1]]);\r\n    }\r\n\r\n     /////////////// INTERNAL BALANCER METHODS ////////////////////   \r\n    \r\n    // Queries the balancer pool to either get the tokens required for an amount of BPTs or the amount of BPTs required for an amount of tokens\r\n    // @notice: Only covers weighted pools\r\n    // @param: kind - type of join query (1 to get BPTs for precise token amounts, 3 to get precise token amounts from BPTs)\r\n    // @param: tokens - array of token addresses\r\n    // @param: amounts - array of token amounts (must be sorted in the same order as addresses)\r\n    // @param: minimumBPT - minimum amount of BPTs to be minted\r\n    // @returns: minBPT - the minimum amount of BPTs to be minted\r\n    // @returns: amountsIn - the amounts of tokens required to mint minBPT\r\n    function queryBalancerJoin(uint8 kind, address[2] memory tokens, uint256[2] memory amounts, uint256 minimumBPT) internal returns (uint256 minBPT, uint256[] memory amountsIn) {\r\n        // Instantiate balancer request struct using SWIV and ETH alongside the amounts sent\r\n        IAsset[] memory assetData = new IAsset[](2);\r\n        assetData[0] = IAsset(address(tokens[0]));\r\n        assetData[1] = IAsset(address(tokens[1]));\r\n\r\n        uint256[] memory amountData = new uint256[](2);\r\n\r\n        // If the minimumBPT is 0, query the balancer pool for the minimum amount of BPTs required for the given amounts of tokens\r\n        if (kind == 1) {\r\n            amountData[0] = amounts[0];\r\n            amountData[1] = amounts[1];\r\n            IVault.JoinPoolRequest memory requestData = IVault.JoinPoolRequest({\r\n                    assets: assetData,\r\n                    maxAmountsIn: amountData,\r\n                    userData: abi.encode(1, amountData, 0),\r\n                    fromInternalBalance: false\r\n                });\r\n            (minBPT, amountsIn) = balancerQuery.queryJoin(balancerPoolID, msg.sender, address(this), requestData);\r\n            return (minBPT, amountsIn);\r\n        }\r\n        // Else query the balancer pool for the maximum amount of tokens required for the given minimumBPT (Appears to be broken on balancers end for many pools)\r\n        else if (kind == 3) {\r\n            amountData[0] = type(uint256).max;\r\n            amountData[1] = type(uint256).max;\r\n            IVault.JoinPoolRequest memory requestData = IVault.JoinPoolRequest({\r\n                    assets: assetData,\r\n                    maxAmountsIn: amountData,\r\n                    userData: abi.encode(3, minimumBPT),\r\n                    fromInternalBalance: false\r\n                });\r\n            (minBPT, amountsIn) = balancerQuery.queryJoin(balancerPoolID, msg.sender, address(this), requestData);\r\n            return (minBPT, amountsIn);\r\n        }\r\n    }\r\n\r\n    // Queries the balancer pool to either get the tokens received for an amount of BPTs or the amount of BPTs received for an amount of tokens\r\n    // @notice: Only covers weighted pools\r\n    // @param: tokens - array of token addresses\r\n    // @param: amounts - array of token amounts (must be sorted in the same order as addresses)\r\n    // @param: maximumBPT - maximum amount of BPTs to be withdrawn\r\n    // @returns: maxBPT - the maximum amount of BPTs to be withdrawn\r\n    // @returns: amountsOut - the amounts of tokens received for maxBPT\r\n    function queryBalancerExit(address[2] memory tokens, uint256[2] memory amounts, uint256 maximumBPT) internal returns (uint256 maxBPT, uint256[] memory amountsOut) {\r\n        // Instantiate balancer request struct using SWIV and ETH alongside the amounts sent\r\n        IAsset[] memory assetData = new IAsset[](2);\r\n        assetData[0] = IAsset(address(tokens[0]));\r\n        assetData[1] = IAsset(address(tokens[1]));\r\n\r\n        uint256[] memory amountData = new uint256[](2);\r\n        // If the maximumBPT is max, query the balancer pool for the maximum amount of BPTs received for the given amounts of tokens\r\n        if (maximumBPT == type(uint256).max) {\r\n            amountData[0] = amounts[0];\r\n            amountData[1] = amounts[1];\r\n            IVault.ExitPoolRequest memory requestData = IVault.ExitPoolRequest({\r\n                assets: assetData,\r\n                minAmountsOut: amountData,\r\n                userData: abi.encode(2, amountData, maximumBPT),\r\n                toInternalBalance: false\r\n            });\r\n            (maxBPT, amountsOut) = balancerQuery.queryExit(balancerPoolID, msg.sender, address(this), requestData);\r\n            return (maxBPT, amountsOut);\r\n        }\r\n        // Else query the balancer pool for the minimum amount of tokens received for the given maximumBPT\r\n        else {\r\n            amountData[0] = amounts[0];\r\n            amountData[1] = amounts[1];\r\n            IVault.ExitPoolRequest memory requestData = IVault.ExitPoolRequest({\r\n                assets: assetData,\r\n                minAmountsOut: amountData,\r\n                userData: abi.encode(1, maximumBPT),\r\n                toInternalBalance: false\r\n            });\r\n            (maxBPT, amountsOut) = balancerQuery.queryExit(balancerPoolID, msg.sender, address(this), requestData);\r\n            return (maxBPT, amountsOut);\r\n        }\r\n    }\r\n\r\n    // Joins the balancer pool with the given tokens and amounts, minting at least minimumBPT (if relevant to the kind of join)\r\n    // @notice: Only covers weighted pools\r\n    // @param: kind - the kind of join (1 = exactTokensIn, 3 = exactBPTOut)\r\n    // @param: tokens - array of token addresses\r\n    // @param: amounts - array of token amounts (must be sorted in the same order as addresses)\r\n    // @param: minimumBPT - minimum amount of BPTs to be minted\r\n    function balancerJoin(uint8 kind, address[2] memory tokens, uint256[2] memory amounts, uint256 minimumBPT) internal {\r\n        // Instantiate balancer request struct using SWIV and ETH alongside the amounts sent\r\n        IAsset[] memory assetData = new IAsset[](2);\r\n        assetData[0] = IAsset(address(tokens[0]));\r\n        assetData[1] = IAsset(address(tokens[1]));\r\n\r\n        uint256[] memory amountData = new uint256[](2);\r\n        amountData[0] = amounts[0];\r\n        amountData[1] = amounts[1];\r\n        \r\n        if (kind == 1) {\r\n            IVault.JoinPoolRequest memory requestData = IVault.JoinPoolRequest({\r\n                assets: assetData,\r\n                maxAmountsIn: amountData,\r\n                userData: abi.encode(1, amountData, minimumBPT),\r\n                fromInternalBalance: false\r\n            });\r\n            IVault(balancerVault).joinPool(balancerPoolID, address(this), address(this), requestData);\r\n        }\r\n        else if (kind == 3) {\r\n            IVault.JoinPoolRequest memory requestData = IVault.JoinPoolRequest({\r\n                assets: assetData,\r\n                maxAmountsIn: amountData,\r\n                userData: abi.encode(3, minimumBPT),\r\n                fromInternalBalance: false\r\n            });\r\n            IVault(balancerVault).joinPool(balancerPoolID, address(this), address(this), requestData);\r\n        }\r\n    }\r\n\r\n    // Exits the balancer pool with the given tokens and amounts, burning at most maximumBPT (if relevant to the kind of exit)\r\n    // @notice: Only covers weighted pools\r\n    // @param: kind - the kind of exit (1 = exactBPTIn, 2 = exactTokensOut)\r\n    // @param: tokens - array of token addresses\r\n    // @param: amounts - array of token amounts (must be sorted in the same order as addresses)\r\n    // @param: maximumBPT - maximum amount of BPTs to be burnt\r\n    function balancerExit(uint8 kind, address[2] memory tokens, uint256[2] memory amounts, uint256 maximumBPT) internal {\r\n        // Instantiate balancer request struct using SWIV and ETH alongside the amounts sent\r\n        IAsset[] memory assetData = new IAsset[](2);\r\n        assetData[0] = IAsset(address(tokens[0]));\r\n        assetData[1] = IAsset(address(tokens[1]));\r\n\r\n        uint256[] memory amountData = new uint256[](2);\r\n        amountData[0] = amounts[0];\r\n        amountData[1] = amounts[1];\r\n        \r\n        if (kind == 1) {\r\n            IVault.ExitPoolRequest memory requestData = IVault.ExitPoolRequest({\r\n                assets: assetData,\r\n                minAmountsOut: amountData,\r\n                userData: abi.encode(1, maximumBPT),\r\n                toInternalBalance: false\r\n            });\r\n            IVault(balancerVault).exitPool(balancerPoolID, payable(address(this)), payable(address(this)), requestData);\r\n        }\r\n        else if (kind == 2) {\r\n            IVault.ExitPoolRequest memory requestData = IVault.ExitPoolRequest({\r\n                assets: assetData,\r\n                minAmountsOut: amountData,\r\n                userData: abi.encode(2, amountData, maximumBPT),\r\n                toInternalBalance: false\r\n            });\r\n            IVault(balancerVault).exitPool(balancerPoolID, payable(address(this)), payable(address(this)), requestData);\r\n        }\r\n    }\r\n\r\n    //////////////////// FEE DONATION ////////////////////\r\n\r\n    // Method to donate a BPT amount to the SSM\r\n    // @param: amount - amount of BPT to donate\r\n    // @returns: the amount of BPT donated\r\n    function donate(uint256 amount) public {\r\n        // Transfer the BPT to the SSM\r\n        SafeTransferLib.transferFrom(balancerLPT, msg.sender, address(this), amount);\r\n        // Emit donation event\r\n        emit Donation(amount, msg.sender);\r\n    }\r\n\r\n    //////////////////// ADMIN FUNCTIONS ////////////////////\r\n\r\n    // Method to redeem and withdraw BAL incentives or other stuck tokens / those needing recovery\r\n    // @param: token - address of the token to withdraw\r\n    // @param: receiver - address of the receiver\r\n    // @returns: the amount of tokens withdrawn\r\n    function adminWithdraw(address token, address payable receiver) Authorized(admin) public returns (uint256) {\r\n        if (token == address(0)) {\r\n            receiver.transfer(address(this).balance);\r\n            return (address(this).balance);\r\n        }\r\n        else {\r\n            // If the token is balancerBPT, transfer 30% of the held balancerBPT to receiver\r\n            if (token == address(balancerLPT)) {\r\n                // Require a week between bpt withdrawals\r\n                require(block.timestamp >= lastWithdrawnBPT + 1 weeks, \"Admin already withdrawn recently\");\r\n                // Calculate max balance that can be withdrawn\r\n                uint256 bptToTransfer = balancerLPT.balanceOf(address(this)) / 3;\r\n                // Transfer the balancer LP tokens to the receiver\r\n                SafeTransferLib.transfer(balancerLPT, receiver, bptToTransfer);\r\n                // Reset the last withdrawn timestamp\r\n                lastWithdrawnBPT = block.timestamp;\r\n                return (bptToTransfer);\r\n            }\r\n            else {\r\n                // Get the balance of the token\r\n                uint256 balance = IERC20(token).balanceOf(address(this));\r\n                // Transfer the token to the receiver\r\n                SafeTransferLib.transfer(ERC20(token), receiver, balance);\r\n                return (balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Method to queue the withdrawal of tokens in the event of an emergency\r\n    // @param: token - address of the token to withdraw\r\n    // @returns: the timestamp of the withdrawal\r\n    function queueWithdrawal(address token) Authorized(admin) public returns (uint256 timestamp){\r\n        timestamp = block.timestamp + 1 weeks;\r\n        withdrawalTime[token] = timestamp;\r\n        emit WithdrawalQueued(token, timestamp);\r\n        return (timestamp);\r\n    }\r\n\r\n    // Method to withdraw tokens in the event of an emergency\r\n    // @param: token - address of the token to withdraw\r\n    // @param: receiver - address of the receiver\r\n    // @returns: the amount of tokens withdrawn\r\n    function emergencyWithdraw(address token, address payable receiver) Authorized(admin) public returns (uint256 amount) {\r\n        // Require the current block.timestamp to be after the emergencyWithdrawal timestamp but before the emergencyWithdrawal timestamp + 1 week\r\n        if (block.timestamp < withdrawalTime[token] || block.timestamp > withdrawalTime[token] + 1 weeks) {\r\n            revert Exception(6, block.timestamp, withdrawalTime[token], address(0), address(0));\r\n        }\r\n        if (token == address(0)) {\r\n            amount = address(this).balance;\r\n            receiver.transfer(amount);\r\n            return (amount);\r\n        }\r\n        else {\r\n            // Get the balance of the token\r\n            uint256 balance = IERC20(token).balanceOf(address(this));\r\n            // Transfer the token to the receiver\r\n            SafeTransferLib.transfer(ERC20(token), receiver, balance);\r\n            return (balance);\r\n        }\r\n    }\r\n\r\n    // Method to redeem BAL incentives from a given balancer gauge\r\n    // @param: receiver - address of the receiver\r\n    // @param: gauge - address of the balancer gauge\r\n    // @returns: the amount of BAL withdrawn\r\n    function adminWithdrawBAL(address balancerMinter, address gauge, address receiver) Authorized(admin) public returns (uint256) {\r\n        // Mint BAL accrued on a given gauge\r\n        uint256 amount = IBalancerMinter(balancerMinter).mint(gauge);\r\n        // Transfer the tokens to the receiver\r\n        SafeTransferLib.transfer(balancerToken, receiver, amount);\r\n        return (amount);\r\n    }\r\n\r\n    // Sets a new admin address\r\n    // @param: _admin - address of the new admin\r\n    function setAdmin(address _admin) Authorized(admin) public {\r\n        admin = _admin;\r\n    }\r\n\r\n    // Pauses all withdrawing\r\n    function pause(bool b) Authorized(admin) public {\r\n        paused = b;\r\n    }\r\n\r\n    // Authorized modifier\r\n    modifier Authorized(address) {\r\n        require(msg.sender == admin || msg.sender == address(this), \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    // Unpaused modifier\r\n    modifier Unpaused() {\r\n        require(!paused, \"Paused\");\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"s\",\"type\":\"address\"},{\"internalType\":\"contract ERC20\",\"name\":\"b\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"p\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Exception\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"donator\",\"type\":\"address\"}],\"name\":\"Donation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"WithdrawalQueued\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWIV\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"adminWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"balancerMinter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"adminWithdrawBAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balancerLPT\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balancerPoolID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balancerQuery\",\"outputs\":[{\"internalType\":\"contract IQuery\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balancerToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balancerVault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"cooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"cooldownAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cooldownTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"s\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumBPT\",\"type\":\"uint256\"}],\"name\":\"depositZap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bptIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"balancesSpent\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"s\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastWithdrawnBPT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"maxMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxShares\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxShares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"maxWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxAssets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"migrationOwners\",\"type\":\"address[]\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migratedSSM\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumSWIV\",\"type\":\"uint256\"}],\"name\":\"mintZap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesToMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"balancesSpent\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"previewRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"previewWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"queueWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumSWIV\",\"type\":\"uint256\"}],\"name\":\"redeemZap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesBurnt\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"balancesReturned\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAssets\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumBPT\",\"type\":\"uint256\"}],\"name\":\"withdrawZap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesRedeemed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bptOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"balancesReturned\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawalTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "stkSWIV", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000bf30461210b37012783957d90dc26b95ce3b6f2d000000000000000000000000b209468fc8c99360657d48238e1a7cf0b13362b6b209468fc8c99360657d48238e1a7cf0b13362b60002000000000000000005f6000000000000000000000000971af299447c822dfa49968953026c424abbb8ad", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dbd3e103c07d54dd8ec02ec4f2be83435b11ff6513548b1dfb97e7199e1d1368"}