{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMetro.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n//                        888\\n//                        888\\n//                        888\\n// 88888b.d88b.   .d88b.  888888 888d888 .d88b.\\n// 888 \\\"888 \\\"88b d8P  Y8b 888    888P\\\"  d88\\\"\\\"88b\\n// 888  888  888 88888888 888    888    888  888\\n// 888  888  888 Y8b.     Y88b.  888    Y88..88P\\n// 888  888  888  \\\"Y8888   \\\"Y888 888     \\\"Y88P\\\"\\n\\n// 888                    d8b          888                          888\\n// 888                    Y8P          888                          888\\n// 888                                 888                          888\\n// 88888b.  888  888      888 88888b.  888888       8888b.  888d888 888888\\n// 888 \\\"88b 888  888      888 888 \\\"88b 888             \\\"88b 888P\\\"   888\\n// 888  888 888  888      888 888  888 888         .d888888 888     888\\n// 888 d88P Y88b 888      888 888  888 Y88b.       888  888 888     Y88b.\\n// 88888P\\\"   \\\"Y88888      888 888  888  \\\"Y888      \\\"Y888888 888      \\\"Y888\\n//               888\\n//          Y8b d88P\\n//           \\\"Y88P\\\"\\n\\nstruct MetroTokenProperties {\\n    uint256 mode; // 0: Curate, 1: Evolve, 2: Lock\\n    uint256 progress;\\n    uint256 maxProgress;\\n    uint256 progressSeedStep;\\n    uint256 curateCount;\\n    bytes32 seed;\\n    bytes32[] progressSeeds;\\n    uint256 seedSetDate;\\n}\\n\\ninterface IMetro {\\n    function mint(address target, uint256 count) external;\\n\\n    function getTokenProperties(\\n        uint256 tokenId\\n    ) external view returns (MetroTokenProperties memory);\\n}\\n\\nstruct MetroInternalTokenState {\\n    uint256 mode; // 0: Curate, 1: Evolve, 2: Lock\\n    uint256 baseSeedSetDate;\\n    uint256 lockStartDate;\\n    uint256 progressStartIndex;\\n    uint256 curateCount;\\n    bytes32 baseSeed;\\n}\\n\\ninterface IMetroV2 {\\n    function mint(address target, uint256 count) external;\\n\\n    function tokenStates(\\n        uint256 tokenId\\n    ) external view returns (MetroInternalTokenState memory);\\n\\n    function getTokenProperties(\\n        uint256 tokenId\\n    ) external view returns (MetroTokenProperties memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMetroMapGeneratorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n//                        888\\n//                        888\\n//                        888\\n// 88888b.d88b.   .d88b.  888888 888d888 .d88b.\\n// 888 \\\"888 \\\"88b d8P  Y8b 888    888P\\\"  d88\\\"\\\"88b\\n// 888  888  888 88888888 888    888    888  888\\n// 888  888  888 Y8b.     Y88b.  888    Y88..88P\\n// 888  888  888  \\\"Y8888   \\\"Y888 888     \\\"Y88P\\\"\\n\\n// 888                    d8b          888                          888\\n// 888                    Y8P          888                          888\\n// 888                                 888                          888\\n// 88888b.  888  888      888 88888b.  888888       8888b.  888d888 888888\\n// 888 \\\"88b 888  888      888 888 \\\"88b 888             \\\"88b 888P\\\"   888\\n// 888  888 888  888      888 888  888 888         .d888888 888     888\\n// 888 d88P Y88b 888      888 888  888 Y88b.       888  888 888     Y88b.\\n// 88888P\\\"   \\\"Y88888      888 888  888  \\\"Y888      \\\"Y888888 888      \\\"Y888\\n//               888\\n//          Y8b d88P\\n//           \\\"Y88P\\\"\\n\\nimport {MetroTokenProperties} from \\\"./IMetro.sol\\\";\\nimport {MetroThemeV2} from \\\"./IMetroThemeStorageV2.sol\\\";\\n\\nstruct MetroStop {\\n    uint256 x;\\n    uint256 y;\\n}\\n\\nstruct MetroLine {\\n    MetroStop[] stops;\\n    uint256[] stopDirections;\\n}\\n\\nstruct MetroLineGroup {\\n    MetroLine[] lines;\\n}\\n\\nstruct MetroMapResult {\\n    MetroLineGroup[] lineGroups;\\n    uint256 stopCount;\\n    uint256 lineCount;\\n    bytes svg;\\n}\\n\\n// mode: \\n//  0 - Only map data\\n//  1 - Only SVG\\ninterface IMetroMapGeneratorV2 {\\n    function generateMap(\\n        MetroTokenProperties memory tokenProperties,\\n        MetroThemeV2 memory theme,\\n        uint256 tokenId,\\n        uint256 mode\\n    ) external view returns (MetroMapResult memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMetroRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n//                        888\\n//                        888\\n//                        888\\n// 88888b.d88b.   .d88b.  888888 888d888 .d88b.\\n// 888 \\\"888 \\\"88b d8P  Y8b 888    888P\\\"  d88\\\"\\\"88b\\n// 888  888  888 88888888 888    888    888  888\\n// 888  888  888 Y8b.     Y88b.  888    Y88..88P\\n// 888  888  888  \\\"Y8888   \\\"Y888 888     \\\"Y88P\\\"\\n\\n// 888                    d8b          888                          888\\n// 888                    Y8P          888                          888\\n// 888                                 888                          888\\n// 88888b.  888  888      888 88888b.  888888       8888b.  888d888 888888\\n// 888 \\\"88b 888  888      888 888 \\\"88b 888             \\\"88b 888P\\\"   888\\n// 888  888 888  888      888 888  888 888         .d888888 888     888\\n// 888 d88P Y88b 888      888 888  888 Y88b.       888  888 888     Y88b.\\n// 88888P\\\"   \\\"Y88888      888 888  888  \\\"Y888      \\\"Y888888 888      \\\"Y888\\n//               888\\n//          Y8b d88P\\n//           \\\"Y88P\\\"\\n\\ninterface IMetroRenderer {\\n    function tokenURI(\\n        uint256 tokenId\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMetroThemeStorageV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n//                        888\\n//                        888\\n//                        888\\n// 88888b.d88b.   .d88b.  888888 888d888 .d88b.\\n// 888 \\\"888 \\\"88b d8P  Y8b 888    888P\\\"  d88\\\"\\\"88b\\n// 888  888  888 88888888 888    888    888  888\\n// 888  888  888 Y8b.     Y88b.  888    Y88..88P\\n// 888  888  888  \\\"Y8888   \\\"Y888 888     \\\"Y88P\\\"\\n\\n// 888                    d8b          888                          888\\n// 888                    Y8P          888                          888\\n// 888                                 888                          888\\n// 88888b.  888  888      888 88888b.  888888       8888b.  888d888 888888\\n// 888 \\\"88b 888  888      888 888 \\\"88b 888             \\\"88b 888P\\\"   888\\n// 888  888 888  888      888 888  888 888         .d888888 888     888\\n// 888 d88P Y88b 888      888 888  888 Y88b.       888  888 888     Y88b.\\n// 88888P\\\"   \\\"Y88888      888 888  888  \\\"Y888      \\\"Y888888 888      \\\"Y888\\n//               888\\n//          Y8b d88P\\n//           \\\"Y88P\\\"\\n\\nstruct MetroThemeV2 {\\n    uint256 pickChance;\\n    bytes pBackgroundColor;\\n    bytes mBackgroundColor;\\n    bytes mBorderColor;\\n    bytes mTextColor;\\n    bytes backgroundColor;\\n    bytes stopFillColor;\\n    bytes stopStrokeColor;\\n    bytes lineStrokeColor;\\n    bytes[] lineColors;\\n    bytes[] wagonColors;\\n    string name;\\n    string creator;\\n    uint256 addedDate;\\n}\\n\\ninterface IMetroThemeStorageV2 {\\n    function getRandomTheme(\\n        bytes32 seed,\\n        uint256 tokenId,\\n        bool shouldFilterByDate,\\n        uint256 beforeDate\\n    ) external view returns (MetroThemeV2 memory);\\n}\\n\"\r\n    },\r\n    \"contracts/MetroRendererV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n//                        888\\n//                        888\\n//                        888\\n// 88888b.d88b.   .d88b.  888888 888d888 .d88b.\\n// 888 \\\"888 \\\"88b d8P  Y8b 888    888P\\\"  d88\\\"\\\"88b\\n// 888  888  888 88888888 888    888    888  888\\n// 888  888  888 Y8b.     Y88b.  888    Y88..88P\\n// 888  888  888  \\\"Y8888   \\\"Y888 888     \\\"Y88P\\\"\\n\\n// 888                    d8b          888                          888\\n// 888                    Y8P          888                          888\\n// 888                                 888                          888\\n// 88888b.  888  888      888 88888b.  888888       8888b.  888d888 888888\\n// 888 \\\"88b 888  888      888 888 \\\"88b 888             \\\"88b 888P\\\"   888\\n// 888  888 888  888      888 888  888 888         .d888888 888     888\\n// 888 d88P Y88b 888      888 888  888 Y88b.       888  888 888     Y88b.\\n// 88888P\\\"   \\\"Y88888      888 888  888  \\\"Y888      \\\"Y888888 888      \\\"Y888\\n//               888\\n//          Y8b d88P\\n//           \\\"Y88P\\\"\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IMetroRenderer} from \\\"./interfaces/IMetroRenderer.sol\\\";\\n\\nimport {IMetroV2, MetroTokenProperties, MetroInternalTokenState} from \\\"./interfaces/IMetro.sol\\\";\\nimport {MetroThemeV2, IMetroThemeStorageV2} from \\\"./interfaces/IMetroThemeStorageV2.sol\\\";\\nimport {IMetroMapGeneratorV2, MetroMapResult} from \\\"./interfaces/IMetroMapGeneratorV2.sol\\\";\\nimport {IScriptyBuilder, InlineScriptRequest} from \\\"scripty.sol/contracts/scripty/IScriptyBuilder.sol\\\";\\n\\nimport {LibString} from \\\"solady/src/utils/LibString.sol\\\";\\nimport {Base64} from \\\"solady/src/utils/Base64.sol\\\";\\n\\nstruct MetroTokenState {\\n    uint256 mode; // 0: Curate, 1: Evolve, 2: Lock\\n    uint256 baseSeedSetDate;\\n    uint256 lockStartDate;\\n    uint256 progressStartIndex;\\n    uint256 curateCount;\\n    bytes32 baseSeed;\\n}\\n\\ncontract MetroRendererV3 is Ownable, IMetroRenderer {\\n    struct Trait {\\n        uint256 valueIndex;\\n        string typeName;\\n        string valueName;\\n    }\\n\\n    address public metroAddress;\\n    address public scriptyStorageAddress;\\n    IScriptyBuilder public scriptyBuilder;\\n    IMetroThemeStorageV2 public themeStorage;\\n    IMetroMapGeneratorV2 public mapGenerator;\\n\\n    uint256 public HTMLBufferAllocation;\\n\\n    constructor(\\n        address _metroAddress,\\n        address _mapGeneratorAddress,\\n        address _scriptyStorageAddress,\\n        address _scriptyBuilderAddress,\\n        address _metroThemeStorageAddress,\\n        uint256 _HTMLBufferAllocation\\n    ) {\\n        metroAddress = _metroAddress;\\n        mapGenerator = IMetroMapGeneratorV2(_mapGeneratorAddress);\\n        scriptyStorageAddress = _scriptyStorageAddress;\\n        scriptyBuilder = IScriptyBuilder(_scriptyBuilderAddress);\\n        themeStorage = IMetroThemeStorageV2(_metroThemeStorageAddress);\\n        HTMLBufferAllocation = _HTMLBufferAllocation;\\n    }\\n\\n    // MARK: - tokenURI\\n\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        return generateFullMetadataFor(tokenId);\\n    }\\n\\n    // MARK: - Map Data\\n\\n    function getMapData(\\n        uint256 tokenId\\n    ) public view returns (MetroMapResult memory) {\\n        (, , MetroMapResult memory mapResult) = generateAllMapDataFor(\\n            tokenId,\\n            0\\n        );\\n        return mapResult;\\n    }\\n\\n    function getMapSVG(uint256 tokenId) public view returns (string memory) {\\n        (, , MetroMapResult memory mapResult) = generateAllMapDataFor(\\n            tokenId,\\n            1\\n        );\\n        return string(mapResult.svg);\\n    }\\n\\n    function getTraits(uint256 tokenId) public view returns (Trait[] memory) {\\n        (\\n            MetroTokenProperties memory tokenProperties,\\n            MetroThemeV2 memory theme,\\n            MetroMapResult memory mapResult\\n        ) = generateAllMapDataFor(tokenId, 0);\\n\\n        return getAllTraits(tokenProperties, theme, mapResult);\\n    }\\n\\n    function getJSConfigJSON(\\n        uint256 tokenId\\n    ) public view returns (string memory) {\\n        (\\n            MetroTokenProperties memory tokenProperties,\\n            MetroThemeV2 memory theme,\\n            MetroMapResult memory mapResult\\n        ) = generateAllMapDataFor(tokenId, 1);\\n\\n        return generateJSConfigJSON(tokenProperties, theme, mapResult.svg);\\n    }\\n\\n    function getJSConfigJSONWithCustomTheme(\\n        uint256 tokenId,\\n        MetroThemeV2 memory theme\\n    ) public view returns (string memory) {\\n        MetroTokenProperties memory tokenProperties = IMetroV2(metroAddress)\\n            .getTokenProperties(tokenId);\\n\\n        MetroMapResult memory mapResult = IMetroMapGeneratorV2(mapGenerator)\\n            .generateMap(tokenProperties, theme, tokenId, 1);\\n\\n        return generateJSConfigJSON(tokenProperties, theme, mapResult.svg);\\n    }\\n\\n    // MARK: - Internal\\n\\n    function generateAllMapDataFor(\\n        uint256 tokenId,\\n        uint256 mode,\\n        MetroTokenProperties memory tokenProperties\\n    )\\n        internal\\n        view\\n        returns (\\n            MetroTokenProperties memory,\\n            MetroThemeV2 memory,\\n            MetroMapResult memory\\n        )\\n    {\\n        bool shouldFilterByDate;\\n        uint256 beforeDate;\\n        if (tokenProperties.mode == 0) {\\n            shouldFilterByDate = false;\\n            beforeDate = 0;\\n        } else {\\n            shouldFilterByDate = true;\\n            beforeDate = tokenProperties.seedSetDate;\\n        }\\n\\n        MetroThemeV2 memory theme = themeStorage.getRandomTheme(\\n            tokenProperties.seed,\\n            tokenId,\\n            shouldFilterByDate,\\n            beforeDate\\n        );\\n\\n        MetroMapResult memory mapResult = IMetroMapGeneratorV2(mapGenerator)\\n            .generateMap(tokenProperties, theme, tokenId, mode);\\n        return (tokenProperties, theme, mapResult);\\n    }\\n\\n    function generateAllMapDataFor(\\n        uint256 tokenId,\\n        uint256 mode\\n    )\\n        internal\\n        view\\n        returns (\\n            MetroTokenProperties memory,\\n            MetroThemeV2 memory,\\n            MetroMapResult memory\\n        )\\n    {\\n        MetroTokenProperties memory tokenProperties = IMetroV2(metroAddress)\\n            .getTokenProperties(tokenId);\\n        MetroInternalTokenState memory tokenState = IMetroV2(metroAddress)\\n            .tokenStates(tokenId);\\n\\n        tokenProperties.seedSetDate = tokenState.baseSeedSetDate;\\n\\n        return generateAllMapDataFor(tokenId, mode, tokenProperties);\\n    }\\n\\n    function generateFullMetadataFor(\\n        uint256 tokenId\\n    ) internal view returns (string memory) {\\n        (\\n            MetroTokenProperties memory tokenProperties,\\n            MetroThemeV2 memory theme,\\n            MetroMapResult memory mapResult\\n        ) = generateAllMapDataFor(tokenId, 1);\\n\\n        bytes memory svg = mapResult.svg;\\n\\n        Trait[] memory allTraits = getAllTraits(\\n            tokenProperties,\\n            theme,\\n            mapResult\\n        );\\n\\n        bytes memory metedataDescription = abi.encodePacked(\\n            \\\"an on-chain, evolving, interactive metro! Double click, use mouse wheel or pinch to zoom in. When zoomed in, tap and drag to explore the metro map.\\\",\\n            \\\" Theme by \\\",\\n            theme.creator\\n        );\\n\\n        bytes memory metadata = abi.encodePacked(\\n            '{\\\"name\\\":\\\"metro #',\\n            LibString.toString(tokenId),\\n            '\\\", \\\"description\\\": \\\"',\\n            metedataDescription,\\n            '\\\", \\\"image\\\":',\\n            '\\\"data:image/svg+xml;utf8,',\\n            svg,\\n            '\\\",\\\"animation_url\\\":\\\"',\\n            getAnimationURL(tokenProperties, theme, svg),\\n            '\\\",\\\"attributes\\\": [',\\n            getJSONAttributes(allTraits),\\n            \\\"]}\\\"\\n        );\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(metadata)\\n                )\\n            );\\n    }\\n\\n    function getAnimationURL(\\n        MetroTokenProperties memory tokenProperties,\\n        MetroThemeV2 memory theme,\\n        bytes memory rawSVG\\n    ) public view returns (bytes memory) {\\n        bytes memory controllerScript = abi.encodePacked(\\n            'let theMetroConfig={seed:\\\"',\\n            LibString.toHexString(uint256(tokenProperties.seed)),\\n            '\\\",svgData:\\\"',\\n            rawSVG,\\n            '\\\",theme:',\\n            getThemeJSObject(theme),\\n            \\\"};_sb.scripts.theMetro=theMetro(theMetroConfig);_sb.scripts.theMetro.start()\\\"\\n        );\\n\\n        InlineScriptRequest[] memory requests = new InlineScriptRequest[](4);\\n        requests[0].name = \\\"scriptyBase\\\";\\n        requests[0].contractAddress = scriptyStorageAddress;\\n\\n        requests[1].name = \\\"intart_random\\\";\\n        requests[1].contractAddress = scriptyStorageAddress;\\n\\n        requests[2].name = \\\"intart_the_metro_v2\\\";\\n        requests[2].contractAddress = scriptyStorageAddress;\\n\\n        requests[3].scriptContent = controllerScript;\\n\\n        return\\n            scriptyBuilder.getEncodedHTMLInline(\\n                requests,\\n                HTMLBufferAllocation + controllerScript.length\\n            );\\n    }\\n\\n    function generateJSConfigJSON(\\n        MetroTokenProperties memory tokenProperties,\\n        MetroThemeV2 memory theme,\\n        bytes memory rawSVG\\n    ) public pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '{\\\"seed\\\":\\\"',\\n                    LibString.toHexString(uint256(tokenProperties.seed)),\\n                    '\\\",\\\"svgData\\\":\\\"',\\n                    rawSVG,\\n                    '\\\",\\\"theme\\\":',\\n                    getThemeJSObject(theme),\\n                    \\\"}\\\"\\n                )\\n            );\\n    }\\n\\n    function getThemeJSObject(\\n        MetroThemeV2 memory theme\\n    ) public pure returns (string memory) {\\n        string memory memoryLineColors;\\n        for (uint256 i; i < theme.lineColors.length; i++) {\\n            memoryLineColors = string(\\n                abi.encodePacked(\\n                    memoryLineColors,\\n                    '[\\\"',\\n                    theme.lineColors[i],\\n                    '\\\",\\\"',\\n                    theme.wagonColors[i],\\n                    '\\\"]'\\n                )\\n            );\\n            if (i != theme.lineColors.length - 1) {\\n                memoryLineColors = string(\\n                    abi.encodePacked(memoryLineColors, \\\",\\\")\\n                );\\n            }\\n        }\\n        string memory themeObject = string(\\n            abi.encodePacked(\\n                '{\\\"b\\\": \\\"',\\n                theme.backgroundColor,\\n                '\\\", \\\"sf\\\": \\\"',\\n                theme.stopFillColor,\\n                '\\\", \\\"ss\\\": \\\"',\\n                theme.stopStrokeColor,\\n                '\\\", \\\"ls\\\": \\\"',\\n                theme.lineStrokeColor,\\n                '\\\",\\\"lineColors\\\":[',\\n                memoryLineColors,\\n                \\\"]}\\\"\\n            )\\n        );\\n        return themeObject;\\n    }\\n\\n    function getAllTraits(\\n        MetroTokenProperties memory tokenProperties,\\n        MetroThemeV2 memory theme,\\n        MetroMapResult memory mapResult\\n    ) internal pure returns (Trait[] memory) {\\n        Trait[] memory allTraits = new Trait[](6);\\n\\n        allTraits[0].typeName = \\\"Theme\\\";\\n        allTraits[0].valueName = theme.name;\\n\\n        if (tokenProperties.mode == 1) {\\n            if (tokenProperties.progress == tokenProperties.maxProgress) {\\n                allTraits[1].typeName = \\\"Mode\\\";\\n                allTraits[1].valueName = \\\"Complete\\\";\\n            } else {\\n                allTraits[1].typeName = \\\"Mode\\\";\\n                allTraits[1].valueName = \\\"Evolve\\\";\\n            }\\n        } else if (tokenProperties.mode == 2) {\\n            allTraits[1].typeName = \\\"Mode\\\";\\n            allTraits[1].valueName = \\\"Lock\\\";\\n        } else {\\n            allTraits[1].typeName = \\\"Mode\\\";\\n            allTraits[1].valueName = \\\"Curate\\\";\\n        }\\n\\n        if (tokenProperties.progress == 0) {\\n            allTraits[2].typeName = \\\"Progress\\\";\\n            allTraits[2].valueName = \\\"none\\\";\\n        } else {\\n            allTraits[2].typeName = \\\"Progress\\\";\\n            allTraits[2].valueName = LibString.toString(\\n                tokenProperties.progress\\n            );\\n        }\\n\\n        allTraits[3].typeName = \\\"Line Count\\\";\\n        allTraits[3].valueName = LibString.toString(mapResult.lineCount);\\n\\n        allTraits[4].typeName = \\\"Stop Count\\\";\\n        allTraits[4].valueName = LibString.toString(mapResult.stopCount);\\n\\n        allTraits[5].typeName = \\\"Curate Count\\\";\\n        allTraits[5].valueName = LibString.toString(\\n            tokenProperties.curateCount\\n        );\\n\\n        return allTraits;\\n    }\\n\\n    function getJSONAttributes(\\n        Trait[] memory allTraits\\n    ) internal pure returns (string memory) {\\n        string memory attributes;\\n        uint256 i;\\n        uint256 length = allTraits.length;\\n        unchecked {\\n            do {\\n                attributes = string(\\n                    abi.encodePacked(\\n                        attributes,\\n                        getJSONTraitItem(allTraits[i], i == length - 1)\\n                    )\\n                );\\n            } while (++i < length);\\n        }\\n        return attributes;\\n    }\\n\\n    function getJSONTraitItem(\\n        Trait memory trait,\\n        bool lastItem\\n    ) internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '{\\\"trait_type\\\": \\\"',\\n                    trait.typeName,\\n                    '\\\", \\\"value\\\": \\\"',\\n                    trait.valueName,\\n                    '\\\"}',\\n                    lastItem ? \\\"\\\" : \\\",\\\"\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"scripty.sol/contracts/scripty/IScriptyBuilder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n///////////////////////////////////////////////////////////\\n// \u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557 //\\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d //\\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2591\u2591\u255a\u2550\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591 //\\n// \u2591\u255a\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591 //\\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591 //\\n// \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591 //\\n///////////////////////////////////////////////////////////\\n\\n// =============================================================\\n//                            STRUCTS\\n// =============================================================\\n\\nstruct WrappedScriptRequest {\\n    string name;\\n    address contractAddress;\\n    bytes contractData;\\n    uint8 wrapType;\\n    bytes wrapPrefix;\\n    bytes wrapSuffix;\\n    bytes scriptContent;\\n}\\n\\nstruct InlineScriptRequest {\\n    string name;\\n    address contractAddress;\\n    bytes contractData;\\n    bytes scriptContent;\\n}\\n\\ninterface IScriptyBuilder {\\n\\n    // =============================================================\\n    //                            ERRORS\\n    // =============================================================\\n\\n    /**\\n     * @notice Error for, Invalid length of requests\\n     */\\n    error InvalidRequestsLength();\\n\\n    // =============================================================\\n    //                      RAW HTML GETTERS\\n    // =============================================================\\n\\n    /**\\n     * @notice Get requested scripts housed in <body> with custom wrappers\\n     * @dev Your requested scripts are returned in the following format:\\n     *      <html>\\n     *          <head></head>\\n     *          <body style='margin:0;'>\\n     *              [wrapPrefix[0]]{request[0]}[wrapSuffix[0]]\\n     *              [wrapPrefix[1]]{request[1]}[wrapSuffix[1]]\\n     *              ...\\n     *              [wrapPrefix[n]]{request[n]}[wrapSuffix[n]]\\n     *          </body>\\n     *      </html>\\n     * @param requests - Array of WrappedScriptRequests\\n     * @param bufferSize - Total buffer size of all requested scripts\\n     * @return Full html wrapped scripts\\n     */\\n    function getHTMLWrapped(\\n        WrappedScriptRequest[] calldata requests,\\n        uint256 bufferSize\\n    ) external view returns (bytes memory);\\n\\n    /**\\n     * @notice Get requested scripts housed in URL Safe wrappers\\n     * @dev Any wrapper type 0 scripts are converted to base64 and wrapped\\n     *      with <script src=\\\"data:text/javascript;base64,[SCRIPT]\\\"></script>\\n     *\\n     *      [WARNING]: Large non-base64 libraries that need base64 encoding\\n     *      carry a high risk of causing a gas out. Highly advised to use\\n     *      base64 encoded scripts where possible\\n     *\\n     *      Your requested scripts are returned in the following format:\\n     *      <html>\\n     *          <head></head>\\n     *          <body style='margin:0;'>\\n     *              [wrapPrefix[0]]{request[0]}[wrapSuffix[0]]\\n     *              [wrapPrefix[1]]{request[1]}[wrapSuffix[1]]\\n     *              ...\\n     *              [wrapPrefix[n]]{request[n]}[wrapSuffix[n]]\\n     *          </body>\\n     *      </html>\\n     * @param requests - Array of WrappedScriptRequests\\n     * @param bufferSize - Total buffer size of all requested scripts\\n     * @return Full URL Safe wrapped scripts\\n     */\\n    function getHTMLWrappedURLSafe(\\n        WrappedScriptRequest[] calldata requests,\\n        uint256 bufferSize\\n    ) external view returns (bytes memory);\\n\\n    /**\\n     * @notice Get requested scripts housed in <body> all wrapped in <script></script>\\n     * @dev Your requested scripts are returned in the following format:\\n     *      <html>\\n     *          <head></head>\\n     *          <body style='margin:0;'>\\n     *              <script>\\n     *                  {request[0]}\\n     *                  {request[1]}\\n     *                  ...\\n     *                  {request[n]}\\n     *              </script>\\n     *          </body>\\n     *      </html>\\n     * @param requests - Array of InlineScriptRequest\\n     * @param bufferSize - Total buffer size of all requested scripts\\n     * @return Full html wrapped scripts\\n     */\\n    function getHTMLInline(\\n        InlineScriptRequest[] calldata requests,\\n        uint256 bufferSize\\n    ) external view returns (bytes memory);\\n\\n    // =============================================================\\n    //                      ENCODED HTML GETTERS\\n    // =============================================================\\n\\n    /**\\n     * @notice Get {getHTMLWrapped} and base64 encode it\\n     * @param requests - Array of WrappedScriptRequests\\n     * @param bufferSize - Total buffer size of all requested scripts\\n     * @return Full html wrapped scripts, base64 encoded\\n     */\\n    function getEncodedHTMLWrapped(\\n        WrappedScriptRequest[] calldata requests,\\n        uint256 bufferSize\\n    ) external view returns (bytes memory);\\n\\n    /**\\n     * @notice Get {getHTMLInline} and base64 encode it\\n     * @param requests - Array of InlineScriptRequests\\n     * @param bufferSize - Total buffer size of all requested scripts\\n     * @return Full html wrapped scripts, base64 encoded\\n     */\\n    function getEncodedHTMLInline(\\n        InlineScriptRequest[] calldata requests,\\n        uint256 bufferSize\\n    ) external view returns (bytes memory);\\n\\n    // =============================================================\\n    //                      STRING UTILITIES\\n    // =============================================================\\n\\n    /**\\n     * @notice Convert {getHTMLWrapped} output to a string\\n     * @param requests - Array of WrappedScriptRequests\\n     * @param bufferSize - Total buffer size of all requested scripts\\n     * @return {getHTMLWrapped} as a string\\n     */\\n    function getHTMLWrappedString(\\n        WrappedScriptRequest[] calldata requests,\\n        uint256 bufferSize\\n    ) external view returns (string memory);\\n\\n    /**\\n     * @notice Convert {getHTMLInline} output to a string\\n     * @param requests - Array of InlineScriptRequests\\n     * @param bufferSize - Total buffer size of all requested scripts\\n     * @return {getHTMLInline} as a string\\n     */\\n    function getHTMLInlineString(\\n        InlineScriptRequest[] calldata requests,\\n        uint256 bufferSize\\n    ) external view returns (string memory);\\n\\n    /**\\n     * @notice Convert {getEncodedHTMLWrapped} output to a string\\n     * @param requests - Array of WrappedScriptRequests\\n     * @param bufferSize - Total buffer size of all requested scripts\\n     *                     before encoding.\\n     * @return {getEncodedHTMLWrapped} as a string\\n     */\\n    function getEncodedHTMLWrappedString(\\n        WrappedScriptRequest[] calldata requests,\\n        uint256 bufferSize\\n    ) external view returns (string memory);\\n\\n    /**\\n     * @notice Convert {getEncodedHTMLInline} output to a string\\n     * @param requests - Array of InlineScriptRequests\\n     * @param bufferSize - Total buffer size of all requested scripts\\n     *                     before encoding.\\n     * @return {getEncodedHTMLInline} as a string\\n     */\\n    function getEncodedHTMLInlineString(\\n        InlineScriptRequest[] calldata requests,\\n        uint256 bufferSize\\n    ) external view returns (string memory);\\n\\n    // =============================================================\\n    //                      OFF-CHAIN UTILITIES\\n    // =============================================================\\n\\n    /**\\n     * @notice Get the buffer size of a single inline requested code\\n     * @param request - InlineScriptRequest data for code\\n     * @return Buffer size as an unit256\\n     */\\n    function getInlineScriptSize(InlineScriptRequest memory request)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Get the buffer size of a single wrapped requested code\\n     * @param request - WrappedScriptRequest data for code\\n     * @return Buffer size as an unit256\\n     */\\n    function getWrappedScriptSize(WrappedScriptRequest memory request)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Get the buffer size of a single wrapped requested code\\n     * @dev If the script is of wrapper type 0, we get buffer size for\\n     *      base64 encoded version.\\n     * @param request - WrappedScriptRequest data for code\\n     * @return Buffer size as an unit256\\n     */\\n    function getURLSafeWrappedScriptSize(WrappedScriptRequest memory request)\\n    external\\n    view\\n    returns (uint256);\\n\\n    /**\\n     * @notice Get the buffer size of an array of html wrapped inline scripts\\n     * @param requests - InlineScriptRequests data for code\\n     * @return Buffer size as an unit256\\n     */\\n    function getBufferSizeForHTMLInline(InlineScriptRequest[] calldata requests)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Get the buffer size of an array of html wrapped, wrapped scripts\\n     * @param requests - WrappedScriptRequests data for code\\n     * @return Buffer size as an unit256\\n     */\\n    function getBufferSizeForHTMLWrapped(\\n        WrappedScriptRequest[] calldata requests\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the buffer size of an array of URL safe html wrapped scripts\\n     * @param requests - WrappedScriptRequests data for code\\n     * @return Buffer size as an unit256\\n     */\\n    function getBufferSizeForURLSafeHTMLWrapped(\\n        WrappedScriptRequest[] calldata requests\\n    ) external view returns (uint256);\\n    \\n    /**\\n     * @notice Get the buffer size for encoded HTML inline scripts\\n     * @param requests - InlineScriptRequests data for code\\n     * @return Buffer size as an unit256\\n     */\\n    function getBufferSizeForEncodedHTMLInline(\\n        InlineScriptRequest[] calldata requests\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @notice Get the buffer size for encoded HTML inline scripts\\n     * @param requests - InlineScriptRequests data for code\\n     * @return Buffer size as an unit256\\n     */\\n    function getBufferSizeForEncodedHTMLWrapped(\\n        WrappedScriptRequest[] calldata requests\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode strings in Base64.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(0x3f, sub(\\\"ghijklmnopqrstuvwxyz0123456789-_\\\", mul(iszero(fileSafe), 0x0230)))\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                // Run over the input, 3 bytes at a time.\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(ptr, mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr(6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(input, 0x3F)))\\n\\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n\\n                let r := mod(dataLength, 3)\\n\\n                switch noPadding\\n                case 0 {\\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n                    // Write the length of the string.\\n                    mstore(result, encodedLength)\\n                }\\n                default {\\n                    // Write the length of the string.\\n                    mstore(result, sub(encodedLength, add(iszero(iszero(r)), eq(r, 1))))\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(end, 31), not(31)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data) internal pure returns (string memory result) {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Encodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data) internal pure returns (bytes memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let end := add(data, dataLength)\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                switch and(dataLength, 3)\\n                case 0 {\\n                    // If padded.\\n                    // forgefmt: disable-next-item\\n                    decodedLength := sub(\\n                        decodedLength,\\n                        add(eq(and(mload(end), 0xFF), 0x3d), eq(and(mload(end), 0xFFFF), 0x3d3d))\\n                    )\\n                }\\n                default {\\n                    // If non-padded.\\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\\n                }\\n\\n                result := mload(0x40)\\n\\n                // Write the length of the string.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    // forgefmt: disable-next-item\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n\\n                    ptr := add(ptr, 3)\\n\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 32 + 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\\n\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solady/src/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                length := sub(length, 1)\\n                if iszero(length) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            let m := add(start, 0xa0)\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := sub(end, str)\\n            // Move the pointer and write the length.\\n            str := sub(str, 0x20)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksumed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Write the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Write the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            str := add(str, 2)\\n            mstore(str, 40)\\n\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0)\\n\\n            value := shl(96, value)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            // Zeroize the slot after the string.\\n            let last := add(add(result, 0x20), k)\\n            mstore(last, 0)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n            // Store the length of the result.\\n            mstore(result, k)\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    // `result = min(from, subjectLength)`.\\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(lt(subject, subjectSearchEnd)) { break }\\n\\n                if iszero(lt(searchLength, 32)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                let searchLength := mload(search)\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n                if iszero(mload(search)) {\\n                    result := from\\n                    break\\n                }\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\\n\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, subjectSearchEnd)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(subjectSearchEnd, 1))\\n                        break\\n                    }\\n                    subject := sub(subject, 1)\\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(output, 0)\\n                // Store the length.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(31)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 31), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), w)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(31)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 31), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 63), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(31)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(mload(a), 32), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, mload(a))\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 32), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), w))\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 67108863)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                // Restore the result.\\n                result := mload(0x40)\\n                // Stores the string length.\\n                mstore(result, length)\\n                // Zeroize the slot after the string.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, and(add(last, 31), not(31)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {\\n                let end := add(s, mload(s))\\n                result := add(mload(0x40), 0x20)\\n                // Store the bytes of the packed offsets and strides into the scratch space.\\n                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n                mstore(0x1f, 0x900094)\\n                mstore(0x08, 0xc0000000a6ab)\\n                // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            } iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 31)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Restore the result to the start of the free memory.\\n            result := mload(0x40)\\n            // Store the length of the result.\\n            mstore(result, sub(last, add(result, 0x20)))\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {\\n                let end := add(s, mload(s))\\n                result := add(mload(0x40), 0x20)\\n                // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n                // Store \\\"0123456789abcdef\\\" in scratch space.\\n                // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n                // into the scratch space.\\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n                // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            } iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            let last := result\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Restore the result to the start of the free memory.\\n            result := mload(0x40)\\n            // Store the length of the result.\\n            mstore(result, sub(last, add(result, 0x20)))\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes of `a` and `b`.\\n                    or(\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retSize), 0)\\n            // Store the return offset.\\n            mstore(retStart, 0x20)\\n            // End the transaction, returning the string.\\n            return(retStart, retSize)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000,\r\n      \"details\": {\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_metroAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mapGeneratorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_scriptyStorageAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_scriptyBuilderAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_metroThemeStorageAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_HTMLBufferAllocation\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HTMLBufferAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"progress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProgress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"progressSeedStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curateCount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"progressSeeds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"seedSetDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetroTokenProperties\",\"name\":\"tokenProperties\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pickChance\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"pBackgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mBackgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mBorderColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mTextColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"backgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stopFillColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stopStrokeColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"lineStrokeColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"lineColors\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"wagonColors\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"creator\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"addedDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetroThemeV2\",\"name\":\"theme\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"rawSVG\",\"type\":\"bytes\"}],\"name\":\"generateJSConfigJSON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"progress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProgress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"progressSeedStep\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"curateCount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"seed\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"progressSeeds\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"seedSetDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetroTokenProperties\",\"name\":\"tokenProperties\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pickChance\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"pBackgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mBackgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mBorderColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mTextColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"backgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stopFillColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stopStrokeColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"lineStrokeColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"lineColors\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"wagonColors\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"creator\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"addedDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetroThemeV2\",\"name\":\"theme\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"rawSVG\",\"type\":\"bytes\"}],\"name\":\"getAnimationURL\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getJSConfigJSON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pickChance\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"pBackgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mBackgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mBorderColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mTextColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"backgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stopFillColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stopStrokeColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"lineStrokeColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"lineColors\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"wagonColors\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"creator\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"addedDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetroThemeV2\",\"name\":\"theme\",\"type\":\"tuple\"}],\"name\":\"getJSConfigJSONWithCustomTheme\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMapData\",\"outputs\":[{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"internalType\":\"struct MetroStop[]\",\"name\":\"stops\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stopDirections\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MetroLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct MetroLineGroup[]\",\"name\":\"lineGroups\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"stopCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lineCount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"svg\",\"type\":\"bytes\"}],\"internalType\":\"struct MetroMapResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMapSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"pickChance\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"pBackgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mBackgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mBorderColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"mTextColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"backgroundColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stopFillColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"stopStrokeColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"lineStrokeColor\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"lineColors\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"wagonColors\",\"type\":\"bytes[]\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"creator\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"addedDate\",\"type\":\"uint256\"}],\"internalType\":\"struct MetroThemeV2\",\"name\":\"theme\",\"type\":\"tuple\"}],\"name\":\"getThemeJSObject\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTraits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"valueIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"typeName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"valueName\",\"type\":\"string\"}],\"internalType\":\"struct MetroRendererV3.Trait[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mapGenerator\",\"outputs\":[{\"internalType\":\"contract IMetroMapGeneratorV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metroAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scriptyBuilder\",\"outputs\":[{\"internalType\":\"contract IScriptyBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scriptyStorageAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"themeStorage\",\"outputs\":[{\"internalType\":\"contract IMetroThemeStorageV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MetroRendererV3", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000ca24e7d9e8a2ba3ada22383f5e2ad397b5677e250000000000000000000000006c73c14b02397fac4e6e1c3584aad6ffa3816f12000000000000000000000000096451f43800f207fc32b4ff86f286edaf736ee300000000000000000000000016b727a2fc9322c724f4bc562910c99a5eda50840000000000000000000000005d2c7f7834144e93ca4496be9e14f613cbd83f460000000000000000000000000000000000000000000000000000000000004b8b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}