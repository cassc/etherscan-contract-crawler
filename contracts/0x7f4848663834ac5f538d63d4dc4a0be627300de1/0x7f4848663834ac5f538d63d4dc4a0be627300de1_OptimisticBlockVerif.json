{"SourceCode": "// Sources flattened with hardhat v2.19.0 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: AML\r\n\r\n// File contracts/block/optimistic/OptimisticBlockVerifier1.sol\r\n\r\n// Original license: SPDX_License_Identifier: AML\r\n// \r\n// Copyright 2017 Christian Reitwiessner\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to\r\n// deal in the Software without restriction, including without limitation the\r\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n// sell copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n// IN THE SOFTWARE.\r\n\r\n// 2019 OKIMS\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary Pairing {\r\n\r\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n\r\n    struct G1Point {\r\n        uint256 X;\r\n        uint256 Y;\r\n    }\r\n\r\n    // Encoding of field elements is: X[0] * z + X[1]\r\n    struct G2Point {\r\n        uint256[2] X;\r\n        uint256[2] Y;\r\n    }\r\n\r\n    /*\r\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero. \r\n     */\r\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\r\n\r\n        // The prime q in the base field F_q for G1\r\n        if (p.X == 0 && p.Y == 0) {\r\n            return G1Point(0, 0);\r\n        } else {\r\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @return The sum of two points of G1\r\n     */\r\n    function plus(\r\n        G1Point memory p1,\r\n        G1Point memory p2\r\n    ) internal view returns (G1Point memory r) {\r\n\r\n        uint256[4] memory input;\r\n        input[0] = p1.X;\r\n        input[1] = p1.Y;\r\n        input[2] = p2.X;\r\n        input[3] = p2.Y;\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 { invalid() }\r\n        }\r\n\r\n        require(success,\"pairing-add-failed\");\r\n    }\r\n\r\n    /*\r\n     * @return The product of a point on G1 and a scalar, i.e.\r\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\r\n     *         points p.\r\n     */\r\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\r\n\r\n        uint256[3] memory input;\r\n        input[0] = p.X;\r\n        input[1] = p.Y;\r\n        input[2] = s;\r\n        bool success;\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 { invalid() }\r\n        }\r\n        require (success,\"pairing-mul-failed\");\r\n    }\r\n\r\n    /* @return The result of computing the pairing check\r\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\r\n     *         For example,\r\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\r\n     */\r\n    function pairing(\r\n        G1Point memory a1,\r\n        G2Point memory a2,\r\n        G1Point memory b1,\r\n        G2Point memory b2,\r\n        G1Point memory c1,\r\n        G2Point memory c2,\r\n        G1Point memory d1,\r\n        G2Point memory d2\r\n    ) internal view returns (bool) {\r\n\r\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\r\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\r\n        uint256 inputSize = 24;\r\n        uint256[] memory input = new uint256[](inputSize);\r\n\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            uint256 j = i * 6;\r\n            input[j + 0] = p1[i].X;\r\n            input[j + 1] = p1[i].Y;\r\n            input[j + 2] = p2[i].X[0];\r\n            input[j + 3] = p2[i].X[1];\r\n            input[j + 4] = p2[i].Y[0];\r\n            input[j + 5] = p2[i].Y[1];\r\n        }\r\n\r\n        uint256[1] memory out;\r\n        bool success;\r\n\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\r\n            // Use \"invalid\" to make gas estimation work\r\n            switch success case 0 { invalid() }\r\n        }\r\n\r\n        require(success,\"pairing-opcode-failed\");\r\n\r\n        return out[0] != 0;\r\n    }\r\n}\r\n\r\ncontract OptimisticBlockVerifier1 {\r\n\r\n    using Pairing for *;\r\n\r\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\r\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\r\n\r\n    struct VerifyingKey {\r\n        Pairing.G1Point alfa1;\r\n        Pairing.G2Point beta2;\r\n        Pairing.G2Point gamma2;\r\n        Pairing.G2Point delta2;\r\n        Pairing.G1Point[2] IC;\r\n    }\r\n\r\n    struct Proof {\r\n        Pairing.G1Point A;\r\n        Pairing.G2Point B;\r\n        Pairing.G1Point C;\r\n    }\r\n\r\n    function verifyingKey() internal pure returns (VerifyingKey memory vk) {\r\n        vk.alfa1 = Pairing.G1Point(uint256(8633181541561672850649656313391497767490414936996056156276613183733255032227), uint256(9617422104715064617230026287342551863885369926065419412017745282422961414102));\r\n        vk.beta2 = Pairing.G2Point([uint256(17816779668595756122674772877191686527776522084657359934816552155491555543718), uint256(20382097854276688600002103305301345977902886048371160787561193571131437635686)], [uint256(20734747929772264721298600391243659558596860643269702014348205473243418793332), uint256(19713324115933667268786553915007669854396811418179121917478344512061012642058)]);\r\n        vk.gamma2 = Pairing.G2Point([uint256(8534645035367112960761488909389462420496991028375163323339941411086308415769), uint256(15868213658120416656647962763425033223000656755243605754641894622093943761564)], [uint256(5216992483403112014367051978533059648889810308753190894830927066334931186491), uint256(21626113025240699323040006716689732349642168363012288019733391502876387118033)]);\r\n        vk.delta2 = Pairing.G2Point([uint256(21412096696999189932526548955503621615811205713734801136793890845082697321261), uint256(16603473609400174802765872517971851138253705097687818637661269873386925937208)], [uint256(16252698906944363009633767620890507187106510744023171929164917788900628691990), uint256(5974314699759284885257349649014220690512609867231857719879233823127427628206)]);   \r\n        vk.IC[0] = Pairing.G1Point(uint256(15934055864392922926659180513554487536826122080031369807640733617533884528307), uint256(8647710924812335285906830904376984420650689272450381401364926931159895041643));   \r\n        vk.IC[1] = Pairing.G1Point(uint256(18792472759091129666519291045580769937199305285692015103968856793980768883637), uint256(20639631867351285027653555772499138979554844975036548868070783718063454769319));\r\n    }\r\n    \r\n    /*\r\n     * @returns Whether the proof is valid given the hardcoded verifying key\r\n     *          above and the public inputs\r\n     */\r\n    function verifyProof(\r\n        uint256[2] memory a,\r\n        uint256[2][2] memory b,\r\n        uint256[2] memory c,\r\n        uint256[1] memory input\r\n    ) public view returns (bool r) {\r\n\r\n        Proof memory proof;\r\n        proof.A = Pairing.G1Point(a[0], a[1]);\r\n        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\r\n        proof.C = Pairing.G1Point(c[0], c[1]);\r\n\r\n        VerifyingKey memory vk = verifyingKey();\r\n\r\n        // Compute the linear combination vk_x\r\n        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);\r\n\r\n        // Make sure that proof.A, B, and C are each less than the prime q\r\n        require(proof.A.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\r\n        require(proof.A.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\r\n\r\n        require(proof.B.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\r\n        require(proof.B.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\r\n\r\n        require(proof.B.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\r\n        require(proof.B.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\r\n\r\n        require(proof.C.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\r\n        require(proof.C.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\r\n\r\n        // Make sure that every input is less than the snark scalar field\r\n        for (uint256 i = 0; i < input.length; i++) {\r\n            require(input[i] < SNARK_SCALAR_FIELD,\"verifier-gte-snark-scalar-field\");\r\n            vk_x = Pairing.plus(vk_x, Pairing.scalar_mul(vk.IC[i + 1], input[i]));\r\n        }\r\n\r\n        vk_x = Pairing.plus(vk_x, vk.IC[0]);\r\n\r\n        return Pairing.pairing(\r\n            Pairing.negate(proof.A),\r\n            proof.B,\r\n            vk.alfa1,\r\n            vk.beta2,\r\n            vk_x,\r\n            vk.gamma2,\r\n            proof.C,\r\n            vk.delta2\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[1]\",\"name\":\"input\",\"type\":\"uint256[1]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"r\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OptimisticBlockVerifier1", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d5474f4a34a7fccf25c266dd3d385c12aecd2a7137dce858d057c31a41f694b6"}