{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/facets/MarketplaceBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"../interfaces/IKreatorhoodERC721.sol\\\";\\nimport \\\"../interfaces/IMetaTransaction.sol\\\";\\nimport \\\"./../utils/ContextMixin.sol\\\";\\nimport { LibStructStorageV2 as StructStorage } from \\\"./../libraries/LibStructStorageV2.sol\\\";\\nimport { LibMarketplaceStorage as Storage } from \\\"../libraries/LibMarketplaceStorage.sol\\\";\\nimport { LibNativeMetaTransaction } from \\\"./../libraries/LibNativeMetaTransaction.sol\\\";\\nimport { LibAccessControlStorage } from \\\"./../libraries/LibAccessControlStorage.sol\\\";\\n\\nabstract contract MarketplaceBase is ContextMixin {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    function _hasRoleInline(bytes32 role, address account) internal view returns (bool) {\\n        LibAccessControlStorage.AccessControlStorage storage data = LibAccessControlStorage.getStorage();\\n        return data._roles[role].members.contains(account);\\n    }\\n\\n    function verifyMintDataSignature(StructStorage.MintData[] calldata mints, bytes calldata signature) internal view {\\n        (bool valid, address signer) = LibNativeMetaTransaction._tryRecoverMintDataSigner(mints, signature);\\n\\n        if (!valid) revert StructStorage.INVALID_SIGNATURE();\\n        if (!_hasRoleInline(StructStorage.OPERATOR_ROLE, signer)) revert StructStorage.MINTS_SIGNATURE(signature);\\n    }\\n\\n    function verifySplits(StructStorage.Splits calldata splitsInfo, bytes32 tradeDataHash) internal {\\n        Storage.MarketplaceStorage storage data = Storage.getStorage();\\n        if (splitsInfo.buyer == address(this)) revert StructStorage.SPLITS_FORBIDDEN_BUYER();\\n        if (!isAcceptedToken(splitsInfo.token)) revert StructStorage.PAYMENT_TOKEN_NOT_ACCEPTED(splitsInfo.token);\\n\\n        if (splitsInfo.actionExpiration <= block.timestamp) revert StructStorage.SPLITS_EXPIRED(splitsInfo.nonce);\\n        if (data.splitsNonces[splitsInfo.nonce]) revert StructStorage.SPLITS_NONCE_INVALID(splitsInfo.nonce);\\n        data.splitsNonces[splitsInfo.nonce] = true;\\n\\n        (bool valid, address signer) = LibNativeMetaTransaction._tryRecoverSplitsSigner(splitsInfo, tradeDataHash);\\n\\n        if (!valid) revert StructStorage.INVALID_SIGNATURE();\\n        if (!_hasRoleInline(StructStorage.OPERATOR_ROLE, signer))\\n            revert StructStorage.SPLITS_SIGNATURE(splitsInfo.nonce);\\n    }\\n\\n    function isAcceptedToken(address token) internal view returns (bool) {\\n        Storage.MarketplaceStorage storage data = Storage.getStorage();\\n\\n        return data.acceptedTokens.contains(token);\\n    }\\n\\n    function validateSale(StructStorage.SellDataV2 memory sale) internal {\\n        Storage.MarketplaceStorage storage data = Storage.getStorage();\\n        if (sale.expirationDate <= block.timestamp) revert StructStorage.SELL_DATA_EXPIRED(sale.sellNonce);\\n        if (data.sellNonces[sale.seller][sale.sellNonce]) revert StructStorage.SELL_NONCE_INVALID(sale.sellNonce);\\n        data.sellNonces[sale.seller][sale.sellNonce] = true;\\n    }\\n\\n    function createNFTs(\\n        address buyer,\\n        bytes calldata mintsSignature,\\n        StructStorage.MintData[] calldata mints\\n    ) internal returns (uint256[] memory) {\\n        verifyMintDataSignature(mints, mintsSignature);\\n        uint256 mintsNo = mints.length;\\n        uint256[] memory firstIndexes = new uint256[](mintsNo);\\n        for (uint i = 0; i < mintsNo; ) {\\n            firstIndexes[i] = mintNFT(mints[i], buyer);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return firstIndexes;\\n    }\\n\\n    function mintNFT(StructStorage.MintData calldata mintData, address buyer) private returns (uint) {\\n        Storage.MarketplaceStorage storage data = Storage.getStorage();\\n        uint256 totalNFTs;\\n        uint256 dropsNo = mintData.drops.length;\\n        for (uint i = 0; i < dropsNo; ) {\\n            totalNFTs += mintData.drops[i].mintEditions;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        IKreatorhoodERC721.MintInfo[] memory mintInfos = new IKreatorhoodERC721.MintInfo[](totalNFTs);\\n        IKreatorhoodERC721.DropInfo[] memory dropInfos = new IKreatorhoodERC721.DropInfo[](totalNFTs);\\n        IKreatorhoodERC721.CreatorInfo[] memory creatorInfos = new IKreatorhoodERC721.CreatorInfo[](totalNFTs);\\n        uint nftsMinted = 0;\\n        for (uint i = 0; i < dropsNo; ) {\\n            uint256 firstNewEditionId = data.editionsMinted[mintData.drops[i].dropId] + 1;\\n            // firstNewEditionId starts from 1 more than the #of minted editions so we subtract that from the sum\\n            if (firstNewEditionId + mintData.drops[i].mintEditions - 1 > mintData.drops[i].maxEditions)\\n                revert StructStorage.EDITION_LIMIT(mintData.drops[i].dropId);\\n            for (uint e = firstNewEditionId; e < firstNewEditionId + mintData.drops[i].mintEditions; ) {\\n                mintInfos[nftsMinted] = IKreatorhoodERC721.MintInfo(\\n                    mintData.drops[i].tokenUri,\\n                    // the tokenIds array starts at 0, but we're counting editions from editionId\\n                    getUtilityUri(mintData.drops[i].utilityIds[e - firstNewEditionId])\\n                );\\n                dropInfos[nftsMinted] = IKreatorhoodERC721.DropInfo(mintData.drops[i].dropId, e);\\n                creatorInfos[nftsMinted] = IKreatorhoodERC721.CreatorInfo(\\n                    mintData.drops[i].creatorAddress,\\n                    mintData.drops[i].royaltiesPercent\\n                );\\n                unchecked {\\n                    ++e;\\n                    ++nftsMinted;\\n                }\\n            }\\n            data.editionsMinted[mintData.drops[i].dropId] = firstNewEditionId + mintData.drops[i].mintEditions - 1;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        IKreatorhoodERC721(mintData.nftAddress).batchMint(\\n            buyer,\\n            totalNFTs,\\n            mintInfos,\\n            dropInfos,\\n            creatorInfos,\\n            new uint256[](totalNFTs),\\n            \\\"0x\\\"\\n        );\\n        return IKreatorhoodERC721(mintData.nftAddress).totalSupply() - nftsMinted + 1;\\n    }\\n\\n    function getUtilityUri(string calldata utilityId) private view returns (string memory utilityUri) {\\n        if (bytes(utilityId).length == 0) {\\n            utilityUri = utilityId;\\n        } else {\\n            Storage.MarketplaceStorage storage data = Storage.getStorage();\\n            utilityUri = string(abi.encodePacked(data.baseUtilityUri, utilityId));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/facets/MarketplaceFiatFacetV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"./MarketplaceBase.sol\\\";\\nimport \\\"./../interfaces/IAccessControl.sol\\\";\\nimport \\\"./../interfaces/IMarketplaceFiat.sol\\\";\\nimport \\\"./../utils/FacetInitializable.sol\\\";\\nimport { LibStructStorageV2 as StructStorage } from \\\"./../libraries/LibStructStorageV2.sol\\\";\\nimport { LibNativeMetaTransaction } from \\\"./../libraries/LibNativeMetaTransaction.sol\\\";\\n\\ncontract MarketplaceFiatFacetV2 is IMarketplaceFiat, MarketplaceBase, FacetInitializable {\\n    event PrimaryMarketBuyFiat(uint256 indexed externalId, uint256[] firstTokenIds);\\n\\n    event BuyFiat(uint256 indexed externalId, uint256[] firstTokenIds);\\n\\n    event SecondaryMarketBuyFiat(uint256 indexed externalId);\\n\\n    modifier onlyPolygon() {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        if (id != 80001 && id != 137) revert StructStorage.NOT_POLYGON(id);\\n        _;\\n    }\\n\\n    function buyNewFiatV2(\\n        address buyer,\\n        uint256 externalId,\\n        bytes calldata mintsSignature,\\n        StructStorage.MintData[] calldata mints\\n    ) external override onlyPolygon only(StructStorage.OPERATOR_ROLE) {\\n        verifyExternalId(externalId);\\n        emit PrimaryMarketBuyFiat(externalId, createNFTs(buyer, mintsSignature, mints));\\n    }\\n\\n    function buyFiatV2(\\n        address buyer,\\n        uint256 externalId,\\n        bytes calldata mintsSignature,\\n        StructStorage.MintData[] calldata mints,\\n        StructStorage.SellDTO calldata sellDTO\\n    ) external override onlyPolygon only(StructStorage.OPERATOR_ROLE) {\\n        verifyExternalId(externalId);\\n        uint256 length = sellDTO.sells.length;\\n        if (length != sellDTO.merkleTrees.length || length != sellDTO.sellerSignatures.length)\\n            revert StructStorage.INVALID_SELL_PARAMS();\\n        {\\n            for (uint256 i; i < length; ) {\\n                StructStorage.SellDataV2 memory sale = sellDTO.sells[i];\\n                if (length != sellDTO.merkleTrees.length || length != sellDTO.sellerSignatures.length)\\n                    revert StructStorage.INVALID_SELL_PARAMS();\\n                validateSale(sale);\\n                IERC721(sale.nftAddress).transferFrom(sale.seller, buyer, sale.tokenId);\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        emit BuyFiat(externalId, createNFTs(buyer, mintsSignature, mints));\\n    }\\n\\n    function buyListedFiatV2(\\n        address buyer,\\n        uint256 externalId,\\n        StructStorage.SellDTO calldata sellDTO\\n    ) external override onlyPolygon only(StructStorage.OPERATOR_ROLE) {\\n        verifyExternalId(externalId);\\n        uint256 length = sellDTO.sells.length;\\n        if (length != sellDTO.merkleTrees.length || length != sellDTO.sellerSignatures.length)\\n            revert StructStorage.INVALID_SELL_PARAMS();\\n\\n        for (uint256 i; i < length; ) {\\n            LibNativeMetaTransaction._tryRecoverIndividualMerkleProofOrSellDataSigner(\\n                sellDTO.sells[i],\\n                sellDTO.merkleTrees[i],\\n                sellDTO.sellerSignatures[i]\\n            );\\n            StructStorage.SellDataV2 memory sale = sellDTO.sells[i];\\n            validateSale(sale);\\n            IERC721(sale.nftAddress).transferFrom(sale.seller, buyer, sale.tokenId);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit SecondaryMarketBuyFiat(externalId);\\n    }\\n\\n    function verifyExternalId(uint256 externalId) internal {\\n        Storage.MarketplaceStorage storage data = Storage.getStorage();\\n\\n        if (data.externalIds[externalId]) revert StructStorage.EXTERNAL_ID_USED(externalId);\\n        data.externalIds[externalId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/interfaces/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IAccessControl {\\n    function initializeAccessControl(address fundsAdmin) external;\\n\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n\\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\\n\\n    function setDiamondOwner(address newOwner) external;\\n\\n    function getDiamondOwner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/platform/interfaces/IFundsAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { LibStructStorageV2 as StructStorage } from \\\"../libraries/LibStructStorageV2.sol\\\";\\n\\ninterface IFundsAdmin {\\n    function initializeFundsAdmin(uint _referenceBlockNumber, uint _blocksPerDay) external;\\n\\n    function withdrawPlatformFees(address withdrawer, address token, uint256 amount) external;\\n\\n    function referenceBlockNumber() external view returns (uint);\\n\\n    function blocksPerDay() external view returns (uint);\\n\\n    function setReferenceBlockNumber(uint _referenceBlockNumber) external;\\n\\n    function setBlocksPerDay(uint _blocksPerDay) external;\\n}\\n\"\r\n    },\r\n    \"contracts/platform/interfaces/IKreatorhoodERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IKreatorhoodERC721 {\\n    struct DropInfo {\\n        uint256 dropId;\\n        uint256 editionId;\\n    }\\n\\n    struct CreatorInfo {\\n        address creator;\\n        uint16 royalties;\\n    }\\n\\n    struct MintInfo {\\n        string tokenUri;\\n        string utilityUri;\\n    }\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function batchMint(\\n        address to,\\n        uint256 amount,\\n        MintInfo[] calldata mintInfos,\\n        DropInfo[] calldata dropInfos_,\\n        CreatorInfo[] calldata creatorInfos_,\\n        uint256[] calldata lockTimes_,\\n        bytes memory _data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/platform/interfaces/IMarketplaceFiat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { LibStructStorageV2 as StructStorage } from \\\"../libraries/LibStructStorageV2.sol\\\";\\n\\ninterface IMarketplaceFiat {\\n    function buyNewFiatV2(\\n        address buyer,\\n        uint256 externalId,\\n        bytes calldata mintsSignature,\\n        StructStorage.MintData[] calldata mints\\n    ) external;\\n\\n    function buyListedFiatV2(address buyer, uint256 externalId, StructStorage.SellDTO calldata sellDTO) external;\\n\\n    function buyFiatV2(\\n        address buyer,\\n        uint256 externalId,\\n        bytes calldata mintsSignature,\\n        StructStorage.MintData[] calldata mints,\\n        StructStorage.SellDTO calldata sellDTO\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/platform/interfaces/IMetaTransaction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { LibStructStorageV2 as StructStorage } from \\\"./../libraries/LibStructStorageV2.sol\\\";\\n\\ninterface IMetaTransaction {\\n    struct MetaTransaction {\\n        uint256 nonce;\\n        address from;\\n        bytes functionSignature;\\n    }\\n\\n    function initializeMetaTransaction() external;\\n\\n    function tryRecoverSplitsSigner(\\n        StructStorage.Splits calldata splits,\\n        bytes32 tradeDataHash\\n    ) external view returns (bool valid, address signer);\\n\\n    function tryRecoverMintDataSigner(\\n        StructStorage.MintData[] calldata dropData,\\n        bytes calldata mintsSignature\\n    ) external view returns (bool valid, address signer);\\n\\n    function tryRecoverMerkleProofOrSellDataSignerV2(StructStorage.SellDTO calldata sellDTO) external view;\\n\\n    function tryRecoverMerkleProofOrCollectionOffersSigner(\\n        StructStorage.CollectionOffer[] calldata collectionOffers,\\n        bytes[] calldata buyersSignatures,\\n        StructStorage.MerkleTree[] calldata merkleTrees\\n    ) external view;\\n\\n    function executeMetaTransaction(\\n        address userAddress,\\n        bytes calldata functionSignature,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    ) external payable returns (bytes memory);\\n\\n    function getNonce(address user) external view returns (uint256 nonce);\\n\\n    function hashPayment(StructStorage.Payment calldata payment) external pure returns (bytes32);\\n\\n    function hashSplits(StructStorage.Splits calldata splits, bytes32 tradeDataHash) external pure returns (bytes32);\\n\\n    function hashMints(StructStorage.MintData[] calldata mints) external pure returns (bytes32);\\n\\n    function hashMintData(StructStorage.MintData calldata mintData) external pure returns (bytes32);\\n\\n    function hashDropData(StructStorage.DropData calldata dropData) external pure returns (bytes32);\\n\\n    function hashSellDataV2(StructStorage.SellDataV2 calldata sellData) external pure returns (bytes32);\\n\\n    function hashCollectionOffer(\\n        StructStorage.CollectionOffer calldata collectionOffer\\n    ) external pure returns (bytes32);\\n\\n    function computeNonceV2(StructStorage.SellDataV2 calldata sellData) external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/platform/libraries/LibAccessControlStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport { LibStructStorageV2 as StructStorage } from \\\"../libraries/LibStructStorageV2.sol\\\";\\n\\nlibrary LibAccessControlStorage {\\n    bytes32 internal constant ACCESS_CONTROL_STORAGE_SLOT = keccak256(\\\"KTHD.ACCESSCONTROL.STORAGE\\\");\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    struct AccessControlStorage {\\n        StructStorage.InitFlag inited;\\n        string _revertMsg;\\n        mapping(bytes32 => RoleData) _roles;\\n    }\\n\\n    function getStorage() internal pure returns (AccessControlStorage storage storageStruct) {\\n        bytes32 position = ACCESS_CONTROL_STORAGE_SLOT;\\n        assembly {\\n            storageStruct.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/libraries/LibCollectionOffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { LibStructStorageV2 as StructStorage } from \\\"./../libraries/LibStructStorageV2.sol\\\";\\n\\nlibrary LibCollectionOffer {\\n    bytes internal constant COLLECTION_OFFER_TYPE =\\n        \\\"CollectionOffer(address buyer,address nftAddress,uint256 tokenId,uint256 nftsNumber,uint256 expirationDate,uint256 paymentAmount,address paymentTokenAddress)\\\";\\n\\n    bytes32 internal constant COLLECTION_OFFER_TYPEHASH = keccak256(COLLECTION_OFFER_TYPE);\\n\\n    //function to hash a collectionOffer\\n    function hashCollectionOffer(StructStorage.CollectionOffer memory collectionOffer) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    COLLECTION_OFFER_TYPEHASH,\\n                    collectionOffer.buyer,\\n                    collectionOffer.nftAddress,\\n                    collectionOffer.tokenId,\\n                    collectionOffer.nftsNumber,\\n                    collectionOffer.expirationDate,\\n                    collectionOffer.paymentAmount,\\n                    collectionOffer.paymentTokenAddress\\n                )\\n            );\\n    }\\n\\n    function hashBatchCollectionOffer(\\n        bytes32 root,\\n        uint256 proofLength\\n    ) internal pure returns (bytes32 batchCollectionOfferHash) {\\n        batchCollectionOfferHash = keccak256(abi.encode(_getBatchCollectionOfferTypehash(proofLength), root));\\n    }\\n\\n    /**\\n     * @dev It looks like this for each height:\\n     *      height == n: BatchCollectionOffer(CollectionOffer[2]...[2] tree)CollectionOffer(address buyer,address nftAddress,uint256 tokenId,uint256 nftsNumber,uint256 expirationDate,uint256 paymentAmount,address paymentTokenAddress)\\n     */\\n    function _getBatchCollectionOfferTypehash(uint256 height) internal pure returns (bytes32 typehash) {\\n        if (height == 1) {\\n            typehash = hex\\\"8dc60957eda1ad84949c003699b42df2814f24c9ba491a0a9c4bc8d62397ed4a\\\";\\n        } else if (height == 2) {\\n            typehash = hex\\\"13d360b9073d265423ca08b98ad27c4125c8c9598c20549162ceb1a2bc9217be\\\";\\n        } else if (height == 3) {\\n            typehash = hex\\\"fd1ed9e5ed635456c9fcefdd6a5d3a3d53235b8af6297d8e286c46f566590593\\\";\\n        } else if (height == 4) {\\n            typehash = hex\\\"bb8887fcce519e733b8dd4c8afb508e15855628d04bf9ca9ed162ef91b38d9c7\\\";\\n        } else if (height == 5) {\\n            typehash = hex\\\"ca639ce19305e7c16f9ab3c6495bcf701ce8894f867eed72a92c97a1a23335c9\\\";\\n        } else if (height == 6) {\\n            typehash = hex\\\"45b1b558eba9b04bb31fdf6c58613de6f37dc64ae634ae1954aca6a40d97be48\\\";\\n        } else if (height == 7) {\\n            typehash = hex\\\"c366c9fcbf70365d35bd07f2f051f90ed5f9aa694a8b2e68915801eeafdd49f4\\\";\\n        } else if (height == 8) {\\n            typehash = hex\\\"ff6e1aa75a5c9b21c3a98ce2631d68de33135476ef994e3fd1f6436a0f46201a\\\";\\n        } else if (height == 9) {\\n            typehash = hex\\\"b0e757511ba6b3f4f1f189ac3704f27816d8d66f438e184ab98d3898d0683dff\\\";\\n        } else if (height == 10) {\\n            typehash = hex\\\"1aff615be02a9ce8e3441fa9b0ba8e6b2f8f9400ac43142de7515087a8e6bfde\\\";\\n        } else {\\n            revert StructStorage.INVALID_PROOF_HEIGHT(height);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/libraries/LibMarketplaceStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport { LibStructStorageV2 as StructStorage } from \\\"../libraries/LibStructStorageV2.sol\\\";\\n\\nlibrary LibMarketplaceStorage {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    bytes32 internal constant MARKETPLACE_STORAGE_SLOT = keccak256(\\\"KTHD.MARKETPLACE.STORAGE\\\");\\n    /**\\n     * @dev Storage slot with the address of the current dummy-implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1\\n     * bytes32(uint(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1)\\n     */\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    struct MarketplaceStorage {\\n        StructStorage.InitFlag inited;\\n        // Mapping used to ensure that a payments payload is used only once\\n        mapping(uint256 => bool) splitsNonces;\\n        // Mapping used to ensure that a sell payload is used only once for a seller\\n        mapping(address => mapping(uint256 => bool)) sellNonces;\\n        // Backend number used for processing logs efficiently\\n        mapping(uint256 => bool) externalIds;\\n        // Mapping used for limiting the edition number for a drop (dropId => number of editions minted\\n        mapping(uint256 => uint) editionsMinted;\\n        // Set used for accepted payment tokens\\n        EnumerableSet.AddressSet acceptedTokens;\\n        // String used for computing utility URI for the NFTs with utility associated\\n        string baseUtilityUri;\\n        // Mapping from a CollectionOffer hash to the number of NFT sold (set to max to cancel an offer)\\n        mapping(bytes32 => uint256) collectionOffers;\\n    }\\n\\n    struct ImplementationStorage {\\n        // Address used for visibility of the Diamond in Etherscan\\n        address dummyImplementation;\\n    }\\n\\n    function getStorage() internal pure returns (MarketplaceStorage storage storageStruct) {\\n        bytes32 position = MARKETPLACE_STORAGE_SLOT;\\n        assembly {\\n            storageStruct.slot := position\\n        }\\n    }\\n\\n    function getImplementationStorage() internal pure returns (ImplementationStorage storage storageStruct) {\\n        bytes32 position = IMPLEMENTATION_SLOT;\\n        assembly {\\n            storageStruct.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/libraries/LibMetaTransactionStorageV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport { LibStructStorageV2 as StructStorage } from \\\"../libraries/LibStructStorageV2.sol\\\";\\n\\nlibrary LibMetaTransactionStorageV2 {\\n    bytes32 internal constant METATRANSACTION_STORAGE_SLOT = keccak256(\\\"KTHD.NATIVEMETATRANSACTION.STORAGE\\\");\\n\\n    bytes internal constant PAYMENT_TYPE = \\\"Payment(uint256 amount,address recipient)\\\";\\n\\n    bytes internal constant SPLITS_TYPE =\\n        \\\"Splits(address buyer,Payment[] payments,uint256 actionExpiration,uint256 nonce,address token,bytes32 tradeDataHash)\\\";\\n\\n    bytes internal constant DROP_DATA_TYPE =\\n        \\\"DropData(uint256 dropId,uint256 maxEditions,uint256 mintEditions,uint16 royaltiesPercent,address creatorAddress,string tokenUri,string[] utilityIds)\\\";\\n\\n    bytes internal constant MINT_DATA_TYPE = \\\"MintData(address nftAddress,DropData[] drops)\\\";\\n\\n    bytes internal constant SELL_DATA_TYPE =\\n        \\\"SellData(address seller,address nftAddress,uint256 tokenId,uint256 sellNonce,uint256 expirationDate,uint256 paymentAmount,address paymentTokenAddress)\\\";\\n\\n    bytes32 internal constant META_TRANSACTION_TYPEHASH =\\n        keccak256(\\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\");\\n\\n    bytes32 internal constant PAYMENT_TYPEHASH = keccak256(PAYMENT_TYPE);\\n\\n    bytes32 internal constant SPLITS_TYPEHASH = keccak256(abi.encodePacked(SPLITS_TYPE, PAYMENT_TYPE));\\n\\n    bytes32 internal constant DROP_DATA_TYPEHASH = keccak256(DROP_DATA_TYPE);\\n\\n    bytes32 internal constant MINT_DATA_TYPEHASH = keccak256(abi.encodePacked(MINT_DATA_TYPE, DROP_DATA_TYPE));\\n\\n    bytes32 internal constant MINTS_TYPEHASH =\\n        keccak256(abi.encodePacked(\\\"Mints(MintData[] mints)\\\", DROP_DATA_TYPE, MINT_DATA_TYPE));\\n\\n    bytes32 internal constant SELL_DATA_TYPEHASH = keccak256(SELL_DATA_TYPE);\\n\\n    struct MetaTransactionStorage {\\n        StructStorage.InitFlag inited;\\n        bytes32 domainSeparator;\\n        mapping(address => uint256) nonces;\\n    }\\n\\n    function getStorage() internal pure returns (MetaTransactionStorage storage storageStruct) {\\n        bytes32 position = METATRANSACTION_STORAGE_SLOT;\\n        assembly {\\n            storageStruct.slot := position\\n        }\\n    }\\n\\n    function hashBatchSellData(bytes32 root, uint256 proofLength) internal pure returns (bytes32 batchOrderHash) {\\n        batchOrderHash = keccak256(abi.encode(_getBatchSellDataTypehash(proofLength), root));\\n    }\\n\\n    /**\\n     * @dev It looks like this for each height:\\n     *      height == n: BatchSellData(SellData[2]...[2] tree)SellData(address seller,address nftAddress,uint256 tokenId,uint256 sellNonce,uint256 expirationDate,uint256 paymentAmount,address paymentTokenAddress)\\n     */\\n    function _getBatchSellDataTypehash(uint256 height) internal pure returns (bytes32 typehash) {\\n        if (height == 1) {\\n            typehash = hex\\\"3b59bc634f98a1c0ab5de79ea8518b4217927e608e0c223e2d3db40d1b544b96\\\";\\n        } else if (height == 2) {\\n            typehash = hex\\\"7c3bd446bbb715a2a0dd99c9fb3d75cf49c36ffa5da7967cf9876bfea41aa414\\\";\\n        } else if (height == 3) {\\n            typehash = hex\\\"ee9f75a53c9ef2f96f86e3c19809643a2c0b0b766aaed9e2be69b5d32fce6928\\\";\\n        } else if (height == 4) {\\n            typehash = hex\\\"faeaa9eefca019bef6f80ebaa1c1416a9f74e64d025f6b61042f09143a17cfff\\\";\\n        } else if (height == 5) {\\n            typehash = hex\\\"5fc91cacfb246f3b853c3c493c4033cfbd0162d028ffe824fccd22f00c19d645\\\";\\n        } else if (height == 6) {\\n            typehash = hex\\\"d26b6e285de8afc1e9f78500dad200a8cc2adfcde3cd5ceec68633f9da14d173\\\";\\n        } else if (height == 7) {\\n            typehash = hex\\\"2572d33e571ad5293c206df943f7fe022a228a27656800dae4ac9804564d54b7\\\";\\n        } else if (height == 8) {\\n            typehash = hex\\\"d18f36406625ee2f7d5ad659c7dac4658670ea4e04d0047bfffb8f5cd621b3c2\\\";\\n        } else if (height == 9) {\\n            typehash = hex\\\"df5de40f9d18f532960fee22beede443c8289d75a592e3f7382c2339bd70b333\\\";\\n        } else if (height == 10) {\\n            typehash = hex\\\"ddee52af9809f47dc8a466de83096853a997d98a59473cbbe9c3dd5c5dacd91e\\\";\\n        } else {\\n            revert StructStorage.INVALID_PROOF_HEIGHT(height);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/libraries/LibNativeMetaTransaction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"./../utils/FacetInitializable.sol\\\";\\nimport \\\"./../interfaces/IMetaTransaction.sol\\\";\\nimport \\\"./../interfaces/IFundsAdmin.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport { LibStructStorageV2 as StructStorage } from \\\"./../libraries/LibStructStorageV2.sol\\\";\\nimport { LibMetaTransactionStorageV2 as Storage } from \\\"./../libraries/LibMetaTransactionStorageV2.sol\\\";\\nimport { LibMerkleProof } from \\\"./../libraries/merkle/LibMerkleProof.sol\\\";\\nimport { LibCollectionOffer } from \\\"./../libraries/LibCollectionOffer.sol\\\";\\n\\nlibrary LibNativeMetaTransaction {\\n    string internal constant ERC712_VERSION = \\\"1\\\";\\n\\n    bytes32 internal constant ERC712_VERSION_HASH = keccak256(bytes(ERC712_VERSION));\\n\\n    bytes32 internal constant ERC712_NAME_HASH = keccak256(bytes(\\\"KreatorhoodMarketplace\\\"));\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"));\\n\\n    function _getDomainSeparator() internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(EIP712_DOMAIN_TYPEHASH, ERC712_NAME_HASH, ERC712_VERSION_HASH, _getChainId(), address(this))\\n            );\\n    }\\n\\n    function _toTypedMessageHash(bytes32 messageHash) internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _getDomainSeparator(), messageHash));\\n    }\\n\\n    function _hashMetaTransaction(IMetaTransaction.MetaTransaction memory metaTx) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    Storage.META_TRANSACTION_TYPEHASH,\\n                    metaTx.nonce,\\n                    metaTx.from,\\n                    keccak256(metaTx.functionSignature)\\n                )\\n            );\\n    }\\n\\n    function _hashPayment(StructStorage.Payment calldata payment) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(Storage.PAYMENT_TYPEHASH, payment.amount, payment.recipient));\\n    }\\n\\n    function _hashSplits(StructStorage.Splits calldata splits, bytes32 tradeDataHash) internal pure returns (bytes32) {\\n        uint256 paymentsLength = splits.payments.length;\\n        bytes32[] memory paymentsHashes = new bytes32[](paymentsLength);\\n        unchecked {\\n            for (uint256 i; i < paymentsLength; ++i) {\\n                // Hash the payment and place the result into memory.\\n                paymentsHashes[i] = _hashPayment(splits.payments[i]);\\n            }\\n        }\\n\\n        return\\n            keccak256(\\n                abi.encode(\\n                    Storage.SPLITS_TYPEHASH,\\n                    splits.buyer,\\n                    keccak256(abi.encodePacked(paymentsHashes)),\\n                    splits.actionExpiration,\\n                    splits.nonce,\\n                    splits.token,\\n                    tradeDataHash\\n                )\\n            );\\n    }\\n\\n    function _hashMints(StructStorage.MintData[] calldata mints) internal pure returns (bytes32) {\\n        uint256 mintsLength = mints.length;\\n        bytes32[] memory mintsHashes = new bytes32[](mintsLength);\\n        unchecked {\\n            for (uint256 i; i < mintsLength; ++i) {\\n                mintsHashes[i] = _hashMintData(mints[i]);\\n            }\\n        }\\n        return keccak256(abi.encode(Storage.MINTS_TYPEHASH, keccak256(abi.encodePacked(mintsHashes))));\\n    }\\n\\n    function _hashMintData(StructStorage.MintData calldata mintData) internal pure returns (bytes32) {\\n        uint256 dropsLength = mintData.drops.length;\\n        bytes32[] memory drops = new bytes32[](dropsLength);\\n        // not unchecked because the whole method is unchecked when called from hashMints\\n        for (uint256 i; i < dropsLength; ++i) {\\n            drops[i] = _hashDropData(mintData.drops[i]);\\n        }\\n        return\\n            keccak256(abi.encode(Storage.MINT_DATA_TYPEHASH, mintData.nftAddress, keccak256(abi.encodePacked(drops))));\\n    }\\n\\n    function _hashDropData(StructStorage.DropData calldata dropData) internal pure returns (bytes32) {\\n        if (dropData.royaltiesPercent > 10000)\\n            revert StructStorage.ROYALTIES_PERCENT_INVALID(dropData.royaltiesPercent);\\n        uint256 utilityIdsLength = dropData.utilityIds.length;\\n        bytes32[] memory utilityIdsHashes = new bytes32[](utilityIdsLength);\\n        for (uint256 i; i < utilityIdsLength; ++i) {\\n            utilityIdsHashes[i] = keccak256(bytes(dropData.utilityIds[i]));\\n        }\\n        return\\n            keccak256(\\n                abi.encode(\\n                    Storage.DROP_DATA_TYPEHASH,\\n                    dropData.dropId,\\n                    dropData.maxEditions,\\n                    dropData.mintEditions,\\n                    dropData.royaltiesPercent,\\n                    dropData.creatorAddress,\\n                    keccak256(bytes(dropData.tokenUri)),\\n                    keccak256(abi.encodePacked(utilityIdsHashes))\\n                )\\n            );\\n    }\\n\\n    function _hashSellDataV2(StructStorage.SellDataV2 memory sellData) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    Storage.SELL_DATA_TYPEHASH,\\n                    sellData.seller,\\n                    sellData.nftAddress,\\n                    sellData.tokenId,\\n                    sellData.sellNonce,\\n                    sellData.expirationDate,\\n                    sellData.paymentAmount,\\n                    sellData.paymentTokenAddress\\n                )\\n            );\\n    }\\n\\n    function _getChainId() internal view returns (uint256) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    function _computeNonceV2(StructStorage.SellDataV2 memory sellData) internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    sellData.seller,\\n                    sellData.expirationDate,\\n                    sellData.nftAddress,\\n                    sellData.tokenId,\\n                    address(this),\\n                    _getChainId(),\\n                    sellData.paymentAmount,\\n                    sellData.paymentTokenAddress\\n                )\\n            );\\n    }\\n\\n    function _tryRecoverIndividualMerkleProofOrSellDataSigner(\\n        StructStorage.SellDataV2 memory sale,\\n        StructStorage.MerkleTree calldata tree,\\n        bytes calldata signature\\n    ) internal view {\\n        bytes32 computedNonce = _computeNonceV2(sale);\\n        if (computedNonce != bytes32(sale.sellNonce)) {\\n            revert StructStorage.SELL_NONCE_INVALID(sale.sellNonce);\\n        }\\n        bytes32 sellDataHash = _hashSellDataV2(sale);\\n        uint256 proofLength = tree.proof.length;\\n\\n        if (proofLength != 0) {\\n            if (proofLength > StructStorage.MAX_CALLDATA_PROOF_LENGTH) {\\n                revert StructStorage.MERKLE_PROOF_TOO_LARGE(sale.sellNonce, proofLength);\\n            }\\n            if (!LibMerkleProof.verifyProof(tree.proof, tree.root, sellDataHash)) {\\n                revert StructStorage.MERKLE_PROOF_INVALID(sale.sellNonce);\\n            }\\n\\n            sellDataHash = Storage.hashBatchSellData(tree.root, proofLength);\\n        }\\n        (address signer, ECDSA.RecoverError err) = ECDSA.tryRecover(_toTypedMessageHash(sellDataHash), signature);\\n\\n        if (err != ECDSA.RecoverError.NoError) revert StructStorage.INVALID_SIGNATURE();\\n        if (sale.seller != signer) revert StructStorage.SELL_SIGNATURE(sale.sellNonce, signer);\\n    }\\n\\n    function _tryRecoverMerkleProofOrCollectionOffersSigner(\\n        StructStorage.CollectionOffer[] calldata collectionOffers,\\n        bytes[] calldata buyersSignatures,\\n        StructStorage.MerkleTree[] calldata merkleTrees\\n    ) internal view {\\n        uint256 length = collectionOffers.length;\\n        if (length != merkleTrees.length || length != buyersSignatures.length)\\n            revert StructStorage.INVALID_COLLECTION_OFFER_PARAMS();\\n        for (uint256 i; i < length; ) {\\n            bytes32 collectionOfferHash = LibCollectionOffer.hashCollectionOffer(collectionOffers[i]);\\n            uint256 proofLength = merkleTrees[i].proof.length;\\n\\n            if (proofLength != 0) {\\n                if (proofLength > StructStorage.MAX_CALLDATA_PROOF_LENGTH) {\\n                    revert StructStorage.MERKLE_PROOF_TOO_LARGE(uint256(collectionOfferHash), proofLength);\\n                }\\n\\n                if (!LibMerkleProof.verifyProof(merkleTrees[i].proof, merkleTrees[i].root, collectionOfferHash)) {\\n                    revert StructStorage.MERKLE_PROOF_INVALID(uint256(collectionOfferHash));\\n                }\\n\\n                collectionOfferHash = LibCollectionOffer.hashBatchCollectionOffer(merkleTrees[i].root, proofLength);\\n            }\\n            (address signer, ECDSA.RecoverError err) = ECDSA.tryRecover(\\n                _toTypedMessageHash(collectionOfferHash),\\n                buyersSignatures[i]\\n            );\\n\\n            if (err != ECDSA.RecoverError.NoError) revert StructStorage.INVALID_SIGNATURE();\\n            if (collectionOffers[i].buyer != signer)\\n                revert StructStorage.COLLECTION_OFFER_SIGNATURE(collectionOfferHash, signer);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _tryRecoverSplitsSigner(\\n        StructStorage.Splits calldata splits,\\n        bytes32 tradeDataHash\\n    ) internal view returns (bool valid, address signer) {\\n        (address signer_, ECDSA.RecoverError err) = ECDSA.tryRecover(\\n            _toTypedMessageHash(_hashSplits(splits, tradeDataHash)),\\n            splits.signature\\n        );\\n        return (err == ECDSA.RecoverError.NoError, signer_);\\n    }\\n\\n    function _tryRecoverMintDataSigner(\\n        StructStorage.MintData[] calldata mintData,\\n        bytes calldata mintsSignature\\n    ) internal view returns (bool valid, address signer) {\\n        (address signer_, ECDSA.RecoverError err) = ECDSA.tryRecover(\\n            _toTypedMessageHash(_hashMints(mintData)),\\n            mintsSignature\\n        );\\n        return (err == ECDSA.RecoverError.NoError, signer_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/libraries/LibStructStorageV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nlibrary LibStructStorageV2 {\\n    //encoded roles\\n    bytes32 internal constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n    bytes32 internal constant FUNDS_ADMIN_ROLE = keccak256(\\\"FUNDS_ADMIN_ROLE\\\");\\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    //numeric constants\\n    uint256 internal constant MAX_CALLDATA_PROOF_LENGTH = 10;\\n\\n    //general\\n    error INVALID_SIGNATURE(); //0xa3402a38\\n    error INVALID_SIGNER();\\n    error EXTERNAL_ID_USED(uint256 externalId); //0xcf1823bf\\n    error PAYMENT_TOKEN_NOT_ACCEPTED(address tokenAddress); //0xb31d0d90\\n    error INVALID_ARRAY_LENGTH(); //0xc6a335ff\\n    error NOT_POLYGON(uint256 chainId); //0x15eee51b\\n\\n    //meta\\n    error META_CALL_ERROR(bytes error);\\n    error META_FORBIDDEN_FUNCTION(bytes4 selector);\\n\\n    //merkle proof\\n    error MERKLE_PROOF_TOO_LARGE(uint256 sellNonce, uint256 length); //0xc4ebf85a\\n    error MERKLE_PROOF_INVALID(uint256 sellNonce); //0x2e218f81\\n    error INVALID_PROOF_HEIGHT(uint256 height); //0x56e0614d\\n\\n    //primary market\\n    error EDITION_LIMIT(uint256 dropId); //0x452a12bb\\n    error MINTS_SIGNATURE(bytes signature); //0x670079be\\n    error ROYALTIES_PERCENT_INVALID(uint256 royaltiesPercent); //0x493c86c4\\n\\n    //funds facet\\n    error FA_NATIVE_TRANSFER(); //0xe9dd4fbc\\n    error FA_DISTRIBUTOR_CALLER_TRANSFER(); //0x81522ab7\\n\\n\\n    //splits\\n    error SPLITS_EXPIRED(uint256 splitsNonce); //0x2eed249c\\n    error SPLITS_NONCE_INVALID(uint256 splitsNonce); //0x4cb00050\\n    error SPLITS_SIGNATURE(uint256 splitsNonce); //0xe9a2746d\\n    error SPLITS_FORBIDDEN_BUYER(); //0xe56753e5\\n    error SPLITS_TOKEN_ADDRESS_INVALID(); //0x9035ff63\\n    error SPLITS_AMOUNT_TOTAL_INVALID(uint256 amount, uint256 total); //0x66769945\\n    error SPLITS_AMOUNT_TOTAL_INVALID_FOR_COLLECTION_OFFER(\\n        uint256 sellAmount,\\n        uint256 collectionOfferAmount,\\n        uint256 total\\n    ); //0xa01838c9\\n    error NATIVE_TRANSFER(); //14c6051c\\n    error ETH_VALUE_MISMATCH(uint256 valueSent, uint256 paymentTotal); //0x17ff203c\\n    error INCOMPATIBLE_ARRAYS(); //0x1d82e7bf\\n    error NATIVE_NOT_ALLOWED(); //0x9cc7706b\\n\\n    //sell and delist\\n    error INVALID_SELL_PARAMS(); //0x7dbc3a6b\\n    error SELL_NONCE_INVALID(uint256 sellNonce); //0x4d7b9199\\n    error SELL_DATA_EXPIRED(uint256 sellNonce); //0x209878c5\\n    error SELL_SIGNATURE(uint256 sellNonce, address signer); //0x05812a15\\n    error SELL_NONCE_ALREADY_CANCELED(uint256 sellNonce); //0x69df89fa\\n    error CALLER_NOT_SELLER(uint256 sellNonce); //0xd41a96f4\\n    error CALLER_NOT_BUYER(address caller, address splitsBuyer); //0x85e6de20\\n\\n    //collection offer\\n    error INVALID_COLLECTION_OFFER_PARAMS(); //0x7be73079\\n    error INVALID_COLLECTION_ADDRESS(address saleNftAddress, address collectionOfferNftAddress); //0x5f6d53b3\\n    error INVALID_TOKEN_ID(uint256 saleTokenId, uint256 collectionOfferTokenId); //0x20860b4a\\n    error COLLECTION_OFFER_EXPIRED(bytes32 collectionOfferHash); //0xb3b7635e\\n    error COLLECTION_OFFER_INVALID(bytes32 collectionOfferHash); //0xb3b7635e\\n    error COLLECTION_OFFER_SIGNATURE(bytes32 collectionOfferHash, address signer); //0x2882461f\\n\\n    //role\\n    error MISSING_ROLE(bytes32 role); //0x6a9d0f78\\n\\n    bytes4 internal constant IERC721_INTERFACE = 0x80ac58cd;\\n\\n    enum MerkleNodePosition {\\n        Left,\\n        Right\\n    }\\n\\n    struct MerkleNode {\\n        bytes32 value;\\n        MerkleNodePosition position;\\n    }\\n\\n    struct MerkleTree {\\n        bytes32 root;\\n        MerkleNode[] proof;\\n    }\\n\\n    struct SellDataV2 {\\n        address seller;\\n        address nftAddress;\\n        uint256 tokenId;\\n        uint256 sellNonce;\\n        uint256 expirationDate;\\n        uint256 paymentAmount;\\n        address paymentTokenAddress;\\n    }\\n\\n    struct SellDTO {\\n        SellDataV2[] sells;\\n        bytes[] sellerSignatures;\\n        MerkleTree[] merkleTrees;\\n    }\\n\\n    struct CollectionOffer {\\n        address buyer;\\n        address nftAddress;\\n        uint256 tokenId; // 0 -> for global collection offers\\n        uint256 nftsNumber;\\n        uint256 expirationDate;\\n        uint256 paymentAmount;\\n        address paymentTokenAddress;\\n    }\\n\\n    struct CollectionOfferDTO {\\n        SellDTO sellDTO;\\n        CollectionOffer[] collectionOffers;\\n        bytes[] buyersSignatures;\\n        MerkleTree[] merkleTrees;\\n    }\\n\\n    struct Payment {\\n        uint256 amount;\\n        address recipient;\\n    }\\n\\n    struct Splits {\\n        address buyer;\\n        Payment[] payments;\\n        uint256 actionExpiration;\\n        address token;\\n        uint256 nonce;\\n        bytes signature;\\n    }\\n\\n    struct AcceptCollectionOfferDTO {\\n        CollectionOfferDTO collectionOfferDTO;\\n        Splits splitsInfo;\\n    }\\n\\n    struct SellAndSplitsDTO {\\n        SellDTO sellDTO;\\n        Splits splitsInfo;\\n    }\\n\\n    struct DropData {\\n        uint dropId;\\n        uint maxEditions;\\n        uint mintEditions;\\n        uint16 royaltiesPercent;\\n        address creatorAddress;\\n        string tokenUri;\\n        string[] utilityIds;\\n    }\\n\\n    struct MintData {\\n        address nftAddress;\\n        DropData[] drops;\\n    }\\n\\n    /*\\n        @dev: DO NOT modify struct; doing so will break the diamond storage layout\\n    */\\n    struct InitFlag {\\n        bool inited;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/libraries/merkle/LibMerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n// Libraries\\nimport { LibStructStorageV2 as StructStorage } from \\\"../LibStructStorageV2.sol\\\";\\n\\n/**\\n * @title LibMerkleProof\\n * @notice This library is adjusted from the work of OpenZeppelin\\n */\\nlibrary LibMerkleProof {\\n    /**\\n     * @notice This returns true if a `leaf` can be proved to be a part of a Merkle tree defined by `root`.\\n     *         For this, a `proof` must be provided, containing sibling hashes on the branch from the leaf to the\\n     *         root of the tree. Each pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verifyProof(\\n        StructStorage.MerkleNode[] calldata proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @notice This returns the rebuilt hash obtained by traversing a Merkle tree up from `leaf` using `proof`.\\n     *         A `proof` is valid if and only if the rebuilt hash matches the root of the tree.\\n     *         When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.\\n     */\\n    function processProofCalldata(\\n        StructStorage.MerkleNode[] calldata proof,\\n        bytes32 leaf\\n    ) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        uint256 length = proof.length;\\n\\n        for (uint256 i = 0; i < length; ) {\\n            if (proof[i].position == StructStorage.MerkleNodePosition.Left) {\\n                computedHash = _efficientHash(proof[i].value, computedHash);\\n            } else {\\n                computedHash = _efficientHash(computedHash, proof[i].value);\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/utils/ContextMixin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nabstract contract ContextMixin {\\n    function _msgSender() internal view returns (address payable sender) {\\n        if (msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            if (index < 24) revert(\\\"ContextMixin: Invalid msg data length\\\");\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n            }\\n        } else {\\n            sender = payable(msg.sender);\\n        }\\n        return sender;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/platform/utils/FacetInitializable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"./../utils/ContextMixin.sol\\\";\\nimport \\\"./../interfaces/IAccessControl.sol\\\";\\nimport { LibStructStorageV2 as StructStorage } from \\\"../libraries/LibStructStorageV2.sol\\\";\\n\\nabstract contract FacetInitializable is ContextMixin {\\n    modifier initializer(StructStorage.InitFlag storage flag) {\\n        require(!flag.inited, \\\"already inited\\\");\\n        _;\\n        flag.inited = true;\\n    }\\n\\n    modifier only(bytes32 role) {\\n        if (!IAccessControl(address(this)).hasRole(role, msg.sender)) {\\n            revert StructStorage.MISSING_ROLE(role);\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"EDITION_LIMIT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"externalId\",\"type\":\"uint256\"}],\"name\":\"EXTERNAL_ID_USED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"}],\"name\":\"INVALID_PROOF_HEIGHT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_SELL_PARAMS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_SIGNATURE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellNonce\",\"type\":\"uint256\"}],\"name\":\"MERKLE_PROOF_INVALID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"MERKLE_PROOF_TOO_LARGE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"MINTS_SIGNATURE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"MISSING_ROLE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"NOT_POLYGON\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"royaltiesPercent\",\"type\":\"uint256\"}],\"name\":\"ROYALTIES_PERCENT_INVALID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellNonce\",\"type\":\"uint256\"}],\"name\":\"SELL_DATA_EXPIRED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellNonce\",\"type\":\"uint256\"}],\"name\":\"SELL_NONCE_INVALID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellNonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"SELL_SIGNATURE\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"externalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"firstTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"BuyFiat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"externalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"firstTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"PrimaryMarketBuyFiat\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"externalId\",\"type\":\"uint256\"}],\"name\":\"SecondaryMarketBuyFiat\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"externalId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"mintsSignature\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxEditions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintEditions\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"royaltiesPercent\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenUri\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"utilityIds\",\"type\":\"string[]\"}],\"internalType\":\"struct LibStructStorageV2.DropData[]\",\"name\":\"drops\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LibStructStorageV2.MintData[]\",\"name\":\"mints\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"}],\"internalType\":\"struct LibStructStorageV2.SellDataV2[]\",\"name\":\"sells\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"sellerSignatures\",\"type\":\"bytes[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"},{\"internalType\":\"enum LibStructStorageV2.MerkleNodePosition\",\"name\":\"position\",\"type\":\"uint8\"}],\"internalType\":\"struct LibStructStorageV2.MerkleNode[]\",\"name\":\"proof\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LibStructStorageV2.MerkleTree[]\",\"name\":\"merkleTrees\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LibStructStorageV2.SellDTO\",\"name\":\"sellDTO\",\"type\":\"tuple\"}],\"name\":\"buyFiatV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"externalId\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"}],\"internalType\":\"struct LibStructStorageV2.SellDataV2[]\",\"name\":\"sells\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes[]\",\"name\":\"sellerSignatures\",\"type\":\"bytes[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"},{\"internalType\":\"enum LibStructStorageV2.MerkleNodePosition\",\"name\":\"position\",\"type\":\"uint8\"}],\"internalType\":\"struct LibStructStorageV2.MerkleNode[]\",\"name\":\"proof\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LibStructStorageV2.MerkleTree[]\",\"name\":\"merkleTrees\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LibStructStorageV2.SellDTO\",\"name\":\"sellDTO\",\"type\":\"tuple\"}],\"name\":\"buyListedFiatV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"externalId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"mintsSignature\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxEditions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintEditions\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"royaltiesPercent\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"creatorAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenUri\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"utilityIds\",\"type\":\"string[]\"}],\"internalType\":\"struct LibStructStorageV2.DropData[]\",\"name\":\"drops\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LibStructStorageV2.MintData[]\",\"name\":\"mints\",\"type\":\"tuple[]\"}],\"name\":\"buyNewFiatV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MarketplaceFiatFacetV2", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}