{"SourceCode": "// Sources flattened with hardhat v2.17.2 https://hardhat.org\n\n// SPDX-License-Identifier: GPL-3.0-or-later AND MIT\n\n// File lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n\n// File lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    _transferOwnership(_msgSender());\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    _checkOwner();\n    _;\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if the sender is not the owner.\n   */\n  function _checkOwner() internal view virtual {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby disabling any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n\n// File lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\n\n// Original license: SPDX_License_Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\n// File src/timelocks/interface/ITimelockedDelegator.sol\n\n// Original license: SPDX_License_Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\ninterface IDelegatable is IERC20 {\n  function delegate(address delegatee) external;\n}\n\n/// @title TimelockedDelegator interface\n/// @author Fei Protocol\n/// @dev Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/ITimelockedDelegator.sol\ninterface ITimelockedDelegator {\n  // ----------- Events -----------\n\n  event Delegate(address indexed _delegatee, uint256 _amount);\n\n  event Undelegate(address indexed _delegatee, uint256 _amount);\n\n  // ----------- Beneficiary only state changing api -----------\n\n  function delegate(address delegatee, uint256 amount) external;\n\n  function undelegate(address delegatee) external returns (uint256);\n\n  // ----------- Getters -----------\n\n  function delegateContract(address delegatee) external view returns (address);\n\n  function delegateAmount(address delegatee) external view returns (uint256);\n\n  function totalDelegated() external view returns (uint256);\n\n  function token() external view returns (IDelegatable);\n}\n\n// File src/timelocks/interface/ITokenTimelock.sol\n\n// Original license: SPDX_License_Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n/// @title TokenTimelock interface\n/// @author Fei Protocol\n/// @dev Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/ITokenTimelock.sol\ninterface ITokenTimelock {\n  // ----------- Events -----------\n\n  event Release(address indexed _beneficiary, address indexed _recipient, uint256 _amount);\n  event BeneficiaryUpdate(address indexed _beneficiary);\n  event PendingBeneficiaryUpdate(address indexed _pendingBeneficiary);\n\n  // ----------- State changing api -----------\n\n  function release(address to, uint256 amount) external;\n\n  function releaseMax(address to) external;\n\n  function setPendingBeneficiary(address _pendingBeneficiary) external;\n\n  function acceptBeneficiary() external;\n\n  // ----------- Getters -----------\n\n  function lockedToken() external view returns (IERC20);\n\n  function beneficiary() external view returns (address);\n\n  function pendingBeneficiary() external view returns (address);\n\n  function initialBalance() external view returns (uint256);\n\n  function availableForRelease() external view returns (uint256);\n\n  function totalToken() external view returns (uint256);\n\n  function alreadyReleasedAmount() external view returns (uint256);\n}\n\n// File src/timelocks/Timed.sol\n\n// Original license: SPDX_License_Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n/// @title an abstract contract for timed events\n/// @author Fei Protocol\n/// @dev Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/utils/Timed.sol\nabstract contract Timed {\n  /// @notice the start timestamp of the timed period\n  uint256 public startTime;\n\n  /// @notice the duration of the timed period\n  uint256 public duration;\n\n  event DurationUpdate(uint256 oldDuration, uint256 newDuration);\n\n  event TimerReset(uint256 startTime);\n\n  constructor(uint256 _duration) {\n    _setDuration(_duration);\n  }\n\n  modifier duringTime() {\n    require(isTimeStarted(), \"Timed: time not started\");\n    require(!isTimeEnded(), \"Timed: time ended\");\n    _;\n  }\n\n  modifier afterTime() {\n    require(isTimeEnded(), \"Timed: time not ended\");\n    _;\n  }\n\n  /// @notice return true if time period has ended\n  function isTimeEnded() public view returns (bool) {\n    return remainingTime() == 0;\n  }\n\n  /// @notice number of seconds remaining until time is up\n  /// @return remaining\n  function remainingTime() public view returns (uint256) {\n    return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\n  }\n\n  /// @notice number of seconds since contract was initialized\n  /// @return timestamp\n  /// @dev will be less than or equal to duration\n  function timeSinceStart() public view returns (uint256) {\n    if (!isTimeStarted()) {\n      return 0; // uninitialized\n    }\n    uint256 _duration = duration;\n    uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\n    return timePassed > _duration ? _duration : timePassed;\n  }\n\n  function isTimeStarted() public view returns (bool) {\n    return startTime != 0;\n  }\n\n  function _initTimed() internal {\n    startTime = block.timestamp;\n\n    emit TimerReset(block.timestamp);\n  }\n\n  function _setDuration(uint256 newDuration) internal {\n    require(newDuration != 0, \"Timed: zero duration\");\n\n    uint256 oldDuration = duration;\n    duration = newDuration;\n    emit DurationUpdate(oldDuration, newDuration);\n  }\n}\n\n// File src/timelocks/TokenTimelock.sol\n\n// Original license: SPDX_License_Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n// Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/TokenTimelock.sol\n\n// Inspired by OpenZeppelin TokenTimelock contract\n// Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/TokenTimelock.sol\n\nabstract contract TokenTimelock is ITokenTimelock, Timed {\n  /// @notice ERC20 basic token contract being held in timelock\n  IERC20 public override lockedToken;\n\n  /// @notice beneficiary of tokens after they are released\n  address public override beneficiary;\n\n  /// @notice pending beneficiary appointed by current beneficiary\n  address public override pendingBeneficiary;\n\n  /// @notice initial balance of lockedToken\n  uint256 public override initialBalance;\n\n  uint256 internal lastBalance;\n\n  /// @notice number of seconds before releasing is allowed\n  uint256 public immutable cliffSeconds;\n\n  address public immutable clawbackAdmin;\n\n  constructor(\n    address _beneficiary,\n    uint256 _duration,\n    uint256 _cliffSeconds,\n    address _lockedToken,\n    address _clawbackAdmin\n  ) Timed(_duration) {\n    require(_duration != 0, \"TokenTimelock: duration is 0\");\n    require(_beneficiary != address(0), \"TokenTimelock: Beneficiary must not be 0 address\");\n\n    beneficiary = _beneficiary;\n    _initTimed();\n\n    _setLockedToken(_lockedToken);\n\n    cliffSeconds = _cliffSeconds;\n\n    clawbackAdmin = _clawbackAdmin;\n  }\n\n  // Prevents incoming LP tokens from messing up calculations\n  modifier balanceCheck() {\n    if (totalToken() > lastBalance) {\n      uint256 delta = totalToken() - lastBalance;\n      initialBalance = initialBalance + delta;\n    }\n    _;\n    lastBalance = totalToken();\n  }\n\n  modifier onlyBeneficiary() {\n    require(msg.sender == beneficiary, \"TokenTimelock: Caller is not a beneficiary\");\n    _;\n  }\n\n  /// @notice releases `amount` unlocked tokens to address `to`\n  function release(address to, uint256 amount) external override onlyBeneficiary balanceCheck {\n    require(amount != 0, \"TokenTimelock: no amount desired\");\n    require(passedCliff(), \"TokenTimelock: Cliff not passed\");\n\n    uint256 available = availableForRelease();\n    require(amount <= available, \"TokenTimelock: not enough released tokens\");\n\n    _release(to, amount);\n  }\n\n  /// @notice releases maximum unlocked tokens to address `to`\n  function releaseMax(address to) external override onlyBeneficiary balanceCheck {\n    require(passedCliff(), \"TokenTimelock: Cliff not passed\");\n    _release(to, availableForRelease());\n  }\n\n  /// @notice the total amount of tokens held by timelock\n  function totalToken() public view virtual override returns (uint256) {\n    return lockedToken.balanceOf(address(this));\n  }\n\n  /// @notice amount of tokens released to beneficiary\n  function alreadyReleasedAmount() public view override returns (uint256) {\n    return initialBalance == 0 ? 0 : initialBalance - totalToken();\n  }\n\n  /// @notice amount of held tokens unlocked and available for release\n  function availableForRelease() public view override returns (uint256) {\n    uint256 elapsed = timeSinceStart();\n\n    uint256 totalAvailable = _proportionAvailable(initialBalance, elapsed, duration);\n    uint256 netAvailable = totalAvailable - alreadyReleasedAmount();\n    return netAvailable;\n  }\n\n  /// @notice current beneficiary can appoint new beneficiary, which must be accepted\n  function setPendingBeneficiary(address _pendingBeneficiary) public override onlyBeneficiary {\n    pendingBeneficiary = _pendingBeneficiary;\n    emit PendingBeneficiaryUpdate(_pendingBeneficiary);\n  }\n\n  /// @notice pending beneficiary accepts new beneficiary\n  function acceptBeneficiary() public virtual override {\n    _setBeneficiary(msg.sender);\n  }\n\n  function clawback() public balanceCheck {\n    require(msg.sender == clawbackAdmin, \"TokenTimelock: Only clawbackAdmin\");\n    if (passedCliff()) {\n      _release(beneficiary, availableForRelease());\n    }\n    _release(clawbackAdmin, totalToken());\n  }\n\n  function passedCliff() public view returns (bool) {\n    return timeSinceStart() >= cliffSeconds;\n  }\n\n  function _proportionAvailable(\n    uint256 initialBalance,\n    uint256 elapsed,\n    uint256 duration\n  ) internal pure virtual returns (uint256);\n\n  function _setBeneficiary(address newBeneficiary) internal {\n    require(newBeneficiary == pendingBeneficiary, \"TokenTimelock: Caller is not pending beneficiary\");\n    beneficiary = newBeneficiary;\n    emit BeneficiaryUpdate(newBeneficiary);\n    pendingBeneficiary = address(0);\n  }\n\n  function _setLockedToken(address tokenAddress) internal {\n    lockedToken = IERC20(tokenAddress);\n  }\n\n  function _release(address to, uint256 amount) internal {\n    lockedToken.transfer(to, amount);\n    emit Release(beneficiary, to, amount);\n  }\n}\n\n// File src/timelocks/LinearTokenTimelock.sol\n\n// Original license: SPDX_License_Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n/// Modified from: https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/LinearTokenTimelock.sol\n/// @author Fei Protocol\ncontract LinearTokenTimelock is TokenTimelock {\n  constructor(\n    address _beneficiary,\n    uint256 _duration,\n    address _lockedToken,\n    uint256 _cliffDuration,\n    address _clawbackAdmin,\n    uint256 _startTime\n  ) TokenTimelock(_beneficiary, _duration, _cliffDuration, _lockedToken, _clawbackAdmin) {\n    if (_startTime != 0) {\n      startTime = _startTime;\n    }\n  }\n\n  function _proportionAvailable(\n    uint256 initialBalance,\n    uint256 elapsed,\n    uint256 duration\n  ) internal pure override returns (uint256) {\n    return (initialBalance * elapsed) / duration;\n  }\n}\n\n// File src/timelocks/TimelockedDelegator.sol\n\n// Original license: SPDX_License_Identifier: GPL-3.0-or-later\npragma solidity 0.8.19;\n\n/// @title a proxy delegate contract for token\n/// @author Fei Protocol, modified by Connext. Fei reference:\n///         https://github.com/fei-protocol/fei-protocol-core/blob/develop/contracts/timelocks/LinearTimelockedDelegator.sol\n/// @dev https://eips.ethereum.org/EIPS/eip-4758 -> inclusion seems likely within\n///      the next 4 years, so selfdestruct was removed from withdraw()\n/// @dev\ncontract Delegatee is Ownable {\n  IDelegatable public token;\n\n  /// @notice Delegatee constructor\n  /// @param _delegatee the address to delegate token to\n  /// @param _token the delegatable token address\n  constructor(address _delegatee, address _token) {\n    token = IDelegatable(_token);\n    token.delegate(_delegatee);\n  }\n\n  /// @notice send token back to timelock\n  function withdraw() public onlyOwner {\n    IDelegatable _token = token;\n    uint256 balance = _token.balanceOf(address(this));\n    _token.transfer(owner(), balance);\n  }\n}\n\n/// @title a timelock for token allowing for sub-delegation\n/// @author Fei Protocol\n/// @notice allows the timelocked token to be delegated by the beneficiary while locked\ncontract TimelockedDelegator is ITimelockedDelegator, LinearTokenTimelock {\n  /// @notice associated delegate proxy contract for a delegatee\n  mapping(address => address) public override delegateContract;\n\n  /// @notice associated delegated amount of token for a delegatee\n  /// @dev Using as source of truth to prevent accounting errors by transferring to Delegate contracts\n  mapping(address => uint256) public override delegateAmount;\n\n  /// @notice the token contract\n  IDelegatable public override token;\n\n  /// @notice the total delegated amount of token\n  uint256 public override totalDelegated;\n\n  /// @notice Delegatee constructor\n  /// @param _token the token address\n  /// @param _beneficiary default delegate, admin, and timelock beneficiary\n  /// @param _clawbackAdmin who can withdraw unclaimed tokens if timelock halted. use address(0) if there\n  ///        shouldn't be clawbacks for this contract\n  /// @param _cliffDuration cliff of unlock, in seconds. Use 0 for no cliff.\n  /// @param _startTime start time of unlock period, in seconds. Use 0 for now.\n  /// @param _duration duration of the token timelock window\n  constructor(\n    address _token,\n    address _beneficiary,\n    address _clawbackAdmin,\n    uint256 _cliffDuration,\n    uint256 _startTime,\n    uint256 _duration\n  ) LinearTokenTimelock(_beneficiary, _duration, _token, _cliffDuration, _clawbackAdmin, _startTime) {\n    token = IDelegatable(_token);\n    token.delegate(_beneficiary);\n  }\n\n  /// @notice delegate locked token to a delegatee\n  /// @param delegatee the target address to delegate to\n  /// @param amount the amount of token to delegate. Will increment existing delegated token\n  function delegate(address delegatee, uint256 amount) public override onlyBeneficiary {\n    require(amount <= _tokenBalance(), \"TimelockedDelegator: Not enough balance\");\n\n    // withdraw and include an existing delegation\n    if (delegateContract[delegatee] != address(0)) {\n      amount = amount + undelegate(delegatee);\n    }\n\n    IDelegatable _token = token;\n    address _delegateContract = address(new Delegatee(delegatee, address(_token)));\n    delegateContract[delegatee] = _delegateContract;\n\n    delegateAmount[delegatee] = amount;\n    totalDelegated = totalDelegated + amount;\n\n    _token.transfer(_delegateContract, amount);\n\n    emit Delegate(delegatee, amount);\n  }\n\n  /// @notice return delegated token to the timelock\n  /// @param delegatee the target address to undelegate from\n  /// @return the amount of token returned\n  function undelegate(address delegatee) public override onlyBeneficiary returns (uint256) {\n    address _delegateContract = delegateContract[delegatee];\n    require(_delegateContract != address(0), \"TimelockedDelegator: Delegate contract nonexistent\");\n\n    Delegatee(_delegateContract).withdraw();\n\n    uint256 amount = delegateAmount[delegatee];\n    totalDelegated = totalDelegated - amount;\n\n    delegateContract[delegatee] = address(0);\n    delegateAmount[delegatee] = 0;\n\n    emit Undelegate(delegatee, amount);\n\n    return amount;\n  }\n\n  /// @notice calculate total token held plus delegated\n  /// @dev used by LinearTokenTimelock to determine the released amount\n  function totalToken() public view override returns (uint256) {\n    return _tokenBalance() + totalDelegated;\n  }\n\n  /// @notice accept beneficiary role over timelocked token. Delegates all held (non-subdelegated) token to beneficiary\n  function acceptBeneficiary() public override {\n    _setBeneficiary(msg.sender);\n    token.delegate(msg.sender);\n  }\n\n  function _tokenBalance() internal view returns (uint256) {\n    return token.balanceOf(address(this));\n  }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_clawbackAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cliffDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_delegatee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"DurationUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pendingBeneficiary\",\"type\":\"address\"}],\"name\":\"PendingBeneficiaryUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"TimerReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_delegatee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Undelegate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alreadyReleasedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableForRelease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clawback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clawbackAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cliffSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegateAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegateContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimeEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimeStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"passedCliff\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"releaseMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pendingBeneficiary\",\"type\":\"address\"}],\"name\":\"setPendingBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeSinceStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IDelegatable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDelegated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"undelegate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TimelockedDelegator", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fe67a4450907459c3e1fff623aa927dd4e28c67a00000000000000000000000090d49e70bfa2964637a35a9d0f4bf363086d3d32000000000000000000000000d7fb335fee222825ef5684fd9e9a924ab29e563f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066d9ab500000000000000000000000000000000000000000000000000000000001e187e0", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}