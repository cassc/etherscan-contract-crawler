{"SourceCode": "// SPDX-License-Identifier:UNLICENSED\r\npragma solidity ^0.8.4;\r\n\r\nlibrary Strings {\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\nlibrary EnumerableMap {\r\n\r\n    struct MapEntry {\r\n        bytes32 _key;\r\n        bytes32 _value;\r\n    }\r\n\r\n    struct Map {\r\n        MapEntry[] _entries;\r\n\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\r\n        uint256 keyIndex = map._indexes[key];\r\n\r\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\r\n            map._entries.push(MapEntry({ _key: key, _value: value }));\r\n            map._indexes[key] = map._entries.length;\r\n            return true;\r\n        } else {\r\n            map._entries[keyIndex - 1]._value = value;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\r\n        uint256 keyIndex = map._indexes[key];\r\n\r\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\r\n            uint256 toDeleteIndex = keyIndex - 1;\r\n            uint256 lastIndex = map._entries.length - 1;\r\n            MapEntry storage lastEntry = map._entries[lastIndex];\r\n\r\n            map._entries[toDeleteIndex] = lastEntry;\r\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            map._entries.pop();\r\n\r\n            delete map._indexes[key];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\r\n        return map._indexes[key] != 0;\r\n    }\r\n\r\n    function _length(Map storage map) private view returns (uint256) {\r\n        return map._entries.length;\r\n    }\r\n\r\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\r\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\r\n\r\n        MapEntry storage entry = map._entries[index];\r\n        return (entry._key, entry._value);\r\n    }\r\n\r\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\r\n        uint256 keyIndex = map._indexes[key];\r\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\r\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\r\n    }\r\n\r\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\r\n        uint256 keyIndex = map._indexes[key];\r\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\r\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\r\n    }\r\n\r\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\r\n        uint256 keyIndex = map._indexes[key];\r\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\r\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\r\n    }\r\n\r\n    struct UintToAddressMap {\r\n        Map _inner;\r\n    }\r\n\r\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\r\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\r\n        return _remove(map._inner, bytes32(key));\r\n    }\r\n\r\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\r\n        return _contains(map._inner, bytes32(key));\r\n    }\r\n\r\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\r\n        return _length(map._inner);\r\n    }\r\n\r\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\r\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\r\n        return (uint256(key), address(uint160(uint256(value))));\r\n    }\r\n\r\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\r\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\r\n        return (success, address(uint160(uint256(value))));\r\n    }\r\n\r\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\r\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\r\n    }\r\n\r\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\r\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\r\n    }\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            set._values.pop();\r\n\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */ \r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155 is IERC165 {\r\n\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    event tokenBaseURI(string value);\r\n\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function royaltyFee(uint256 tokenId) external view returns(uint256);\r\n    function getCreator(uint256 tokenId) external view returns(address);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n}\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal virtual {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n*/\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer modulo of two numbers, truncating the remainder.\r\n    */\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Strings for uint256;\r\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping (uint256 => address) private creators;\r\n    mapping (uint256 => uint256) private _royaltyFee;\r\n    mapping (uint256 => mapping(address => uint256)) private _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\r\n    string public tokenURIPrefix;\r\n\r\n    // Optional mapping for token URIs\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    EnumerableMap.UintToAddressMap private _tokenOwners;\r\n\r\n    string private _name;\r\n\r\n    string private _symbol;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n\r\n        _registerInterface(_INTERFACE_ID_ERC1155);\r\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n        * @dev Internal function to set the token URI for a given token.\r\n        * Reverts if the token ID does not exist.\r\n        * @param tokenId uint256 ID of the token to set its URI\r\n        * @param uri string URI to assign\r\n    */    \r\n\r\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\r\n        _tokenURIs[tokenId] = uri;\r\n    }\r\n\r\n    /**\r\n        @notice Get the royalty associated with tokenID.\r\n        @param tokenId     ID of the Token.\r\n        @return        royaltyFee of given ID.\r\n     */\r\n\r\n    function royaltyFee(uint256 tokenId) public view override returns(uint256) {\r\n        return _royaltyFee[tokenId];\r\n    }\r\n\r\n    /**\r\n        @notice Get the creator of given tokenID.\r\n        @param tokenId     ID of the Token.\r\n        @return        creator of given ID.\r\n     */    \r\n\r\n    function getCreator(uint256 tokenId) public view virtual override returns(address) {\r\n        return creators[tokenId];\r\n    }\r\n\r\n    /**\r\n        * @dev Internal function to set the token URI for all the tokens.\r\n        * @param _tokenURIPrefix string memory _tokenURIPrefix of the tokens.\r\n    */   \r\n\r\n    function _setTokenURIPrefix(string memory _tokenURIPrefix) internal {\r\n        tokenURIPrefix = _tokenURIPrefix;\r\n        emit tokenBaseURI(_tokenURIPrefix);\r\n    }\r\n\r\n    /**\r\n        * @dev Returns an URI for a given token ID.\r\n        * Throws if the token ID does not exist. May return an empty string.\r\n        * @param tokenId uint256 ID of the token to query\r\n    */    \r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC1155Metadata: URI query for nonexistent token\");\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = tokenURIPrefix;\r\n\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n        return string(abi.encodePacked(base, tokenId.toString()));\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _tokenOwners.contains(tokenId);\r\n    }\r\n\r\n    /**\r\n        @notice Get the balance of an account's Tokens.\r\n        @param account  The address of the token holder\r\n        @param tokenId     ID of the Token\r\n        @return        The owner's balance of the Token type requested\r\n     */\r\n\r\n    function balanceOf(address account, uint256 tokenId) public view override returns (uint256) {\r\n        require(_exists(tokenId), \"ERC1155Metadata: balance query for nonexistent token\");\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[tokenId][account];\r\n    }\r\n\r\n\r\n    /**\r\n        @notice Get the balance of multiple account/token pairs\r\n        @param accounts The addresses of the token holders\r\n        @param ids    ID of the Tokens\r\n        @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\r\n     */\r\n\r\n    function balanceOfBatch(\r\n        address[] memory accounts,\r\n        uint256[] memory ids\r\n    )\r\n        public\r\n        view\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\r\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n        @dev MUST emit the ApprovalForAll event on success.\r\n        @param operator  Address to add to the set of authorized operators\r\n        @param approved  True if the operator is approved, false to revoke approval\r\n    */\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n        @notice Queries the approval status of an operator for a given owner.\r\n        @param account     The owner of the Tokens\r\n        @param operator  Address of authorized operator\r\n        @return           True if the operator is approved, false if not\r\n    */\r\n\r\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\r\n        MUST revert on any other error.\r\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param from    Source address\r\n        @param to      Target address\r\n        @param tokenId      ID of the token type\r\n        @param amount   Transfer amount\r\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\r\n    */    \r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 amount,\r\n        bytes memory data\r\n    )\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(tokenId), _asSingletonArray(amount), data);\r\n\r\n        _balances[tokenId][from] = _balances[tokenId][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\r\n        _balances[tokenId][to] = _balances[tokenId][to].add(amount);\r\n\r\n        emit TransferSingle(operator, from, to, tokenId, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, tokenId, amount, data);\r\n    }\r\n\r\n    /**\r\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if length of `_ids` is not the same as length of `_values`.\r\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\r\n        MUST revert on any other error.\r\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\r\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).\r\n        @param from    Source address\r\n        @param to      Target address\r\n        @param tokenIds     IDs of each token type (order and length must match _values array)\r\n        @param amounts  Transfer amounts per token type (order and length must match _ids array)\r\n        @param data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\r\n    */\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory tokenIds,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, tokenIds, amounts, data);\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\r\n            uint256 tokenId = tokenIds[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            _balances[tokenId][from] = _balances[tokenId][from].sub(\r\n                amount,\r\n                \"ERC1155: insufficient balance for transfer\"\r\n            );\r\n            _balances[tokenId][to] = _balances[tokenId][to].add(amount);\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, tokenIds, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, tokenIds, amounts, data);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n        * @dev Internal function to mint a new token.\r\n        * Reverts if the given token ID already exists.\r\n        * @param tokenId uint256 ID of the token to be minted\r\n        * @param _supply uint256 supply of the token to be minted\r\n        * @param _uri string memory URI of the token to be minted\r\n        * @param _fee uint256 royalty of the token to be minted\r\n    */\r\n\r\n    function _mint(uint256 tokenId, uint256 _supply, string memory _uri, uint256 _fee) internal {\r\n        require(!_exists(tokenId), \"ERC1155: token already minted\");\r\n        require(_supply != 0, \"Supply should be positive\");\r\n        require(bytes(_uri).length > 0, \"uri should be set\");\r\n\r\n        creators[tokenId] = msg.sender;\r\n        _tokenOwners.set(tokenId, msg.sender);\r\n        _royaltyFee[tokenId] = _fee;\r\n        _balances[tokenId][msg.sender] = _supply;\r\n        _setTokenURI(tokenId, _uri);\r\n\r\n        emit TransferSingle(msg.sender, address(0x0), msg.sender, tokenId, _supply);\r\n        emit URI(_uri, tokenId);\r\n    }\r\n\r\n    /**\r\n        * @dev version of {_mint}.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenIds` and `amounts` must have the same length.\r\n    */\r\n\r\n    function _mintBatch(address to, uint256[] memory tokenIds, uint256[] memory amounts, bytes memory data) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, tokenIds, amounts, data);\r\n\r\n        for (uint i = 0; i < tokenIds.length; i++) {\r\n            _balances[tokenIds[i]][to] = amounts[i].add(_balances[tokenIds[i]][to]);\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, tokenIds, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, tokenIds, amounts, data);\r\n    }\r\n\r\n    /**\r\n        * @dev Internal function to burn a specific token.\r\n        * Reverts if the token does not exist.\r\n        * Deprecated, use {ERC721-_burn} instead.\r\n        * @param account owner of the token to burn\r\n        * @param tokenId uint256 ID of the token being burned\r\n        * @param amount uint256 amount of supply being burned\r\n    */    \r\n\r\n    function _burn(address account, uint256 tokenId, uint256 amount) internal virtual {\r\n        require(_exists(tokenId), \"ERC1155Metadata: burn query for nonexistent token\");\r\n        require(account != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(tokenId), _asSingletonArray(amount), \"\");\r\n\r\n        _balances[tokenId][account] = _balances[tokenId][account].sub(\r\n            amount,\r\n            \"ERC_holderTokens1155: burn amount exceeds balance\"\r\n        );\r\n\r\n\r\n        emit TransferSingle(operator, account, address(0), tokenId, amount);\r\n    }\r\n\r\n\r\n    /**\r\n        * @dev version of {_burn}.\r\n        * Requirements:\r\n        * - `ids` and `amounts` must have the same length.\r\n    */\r\n\r\n    function _burnBatch(address account, uint256[] memory tokenIds, uint256[] memory amounts) internal virtual {\r\n        require(account != address(0), \"ERC1155: burn from the zero address\");\r\n        require(tokenIds.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, account, address(0), tokenIds, amounts, \"\");\r\n\r\n        for (uint i = 0; i < tokenIds.length; i++) {\r\n            _balances[tokenIds[i]][account] = _balances[tokenIds[i]][account].sub(\r\n                amounts[i],\r\n                \"ERC1155: burn amount exceeds balance\"\r\n            );\r\n        }\r\n\r\n        emit TransferBatch(operator, account, address(0), tokenIds, amounts);\r\n    }\r\n\r\n\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory tokenIds,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        internal virtual\r\n    { }\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 amount,\r\n        bytes memory data\r\n    )\r\n        private\r\n    {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, tokenId, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory tokenIds,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    )\r\n        private\r\n    {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, tokenIds, amounts, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n}\r\n\r\ncontract MadHatterNFTX is ERC1155 {\r\n\r\n    uint256 newItemId = 1;\r\n    address public owner;\r\n\r\n    event OwnershipTransfered(address indexed newOwner, address indexed owner);\r\n\r\n    struct Sign {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    constructor (string memory name, string memory symbol, string memory tokenURIPrefix) ERC1155 (name, symbol) {\r\n        owner = msg.sender;\r\n        _setTokenURIPrefix(tokenURIPrefix);\r\n\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /** @dev change the Ownership from current owner to newOwner address\r\n        @param newOwner : newOwner address */    \r\n\r\n    function ownerTransfership(address newOwner) public onlyOwner returns(bool){\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransfered(newOwner, owner);\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n\r\n    /** @dev verify the tokenURI that should be verified by owner of the contract.\r\n        *requirements: signer must be owner of the contract\r\n        @param tokenURI string memory URI of token to be minted.\r\n        @param sign struct combination of uint8, bytes32, bytes 32 are v, r, s.\r\n        note : sign value must be in the order of v, r, s.\r\n\r\n    */\r\n\r\n    function verifySign(string memory tokenURI, address caller, Sign memory sign) internal view {\r\n        bytes32 hash = keccak256(abi.encodePacked(this, caller, tokenURI));\r\n        require(owner == ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)), sign.v, sign.r, sign.s), \"Owner sign verification failed\");\r\n    }\r\n\r\n    function mint(string memory uri, uint256 supply, uint256 fee, Sign memory sign)  public {\r\n        verifySign(uri, msg.sender, sign);\r\n        _mint(newItemId, supply, uri,fee);\r\n        newItemId = newItemId+1;\r\n    }\r\n\r\n    function setBaseURI(string memory _baseURI) public onlyOwner{\r\n         _setTokenURIPrefix(_baseURI);\r\n    }\r\n\r\n    function burn(uint256 tokenId, uint256 supply) public {\r\n        _burn(msg.sender, tokenId, supply);\r\n    }\r\n\r\n    function burnBatch(uint256[] memory tokenIds, uint256[] memory amounts) public {\r\n        _burnBatch(msg.sender, tokenIds, amounts);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenURIPrefix\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"tokenBaseURI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct MadHatterNFTX.Sign\",\"name\":\"sign\",\"type\":\"tuple\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerTransfership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"royaltyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenURIPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MadHatterNFTX", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000000f4d616420486174746572204e465458000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044e46545800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002268747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732f000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d4b0a21ee268fb72d54a576a99d8d3b0cc86839c52690e2d66dbb070d6a72528"}