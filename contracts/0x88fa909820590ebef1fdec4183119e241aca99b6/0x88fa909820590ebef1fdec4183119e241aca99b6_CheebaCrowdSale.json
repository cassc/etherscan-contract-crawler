{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Flattened/CheebaCrowdSale_Flattened.sol\": {\r\n      \"content\": \"\\n// File: @thirdweb-dev/contracts/extension/interface/IContractMetadata.sol\\n\\n\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\n/**\\n *  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\\n *  for you contract.\\n *\\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\\n */\\n\\ninterface IContractMetadata {\\n    /// @dev Returns the metadata URI of the contract.\\n    function contractURI() external view returns (string memory);\\n\\n    /**\\n     *  @dev Sets contract URI for the storefront-level metadata of the contract.\\n     *       Only module admin can call this function.\\n     */\\n    function setContractURI(string calldata _uri) external;\\n\\n    /// @dev Emitted when the contract URI is updated.\\n    event ContractURIUpdated(string prevURI, string newURI);\\n}\\n\\n// File: @thirdweb-dev/contracts/extension/ContractMetadata.sol\\n\\n\\npragma solidity ^0.8.0;\\n\\n/// @author thirdweb\\n\\n\\n/**\\n *  @title   Contract Metadata\\n *  @notice  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\\n *           for you contract.\\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\\n */\\n\\nabstract contract ContractMetadata is IContractMetadata {\\n    /// @dev The sender is not authorized to perform the action\\n    error ContractMetadataUnauthorized();\\n\\n    /// @notice Returns the contract metadata URI.\\n    string public override contractURI;\\n\\n    /**\\n     *  @notice         Lets a contract admin set the URI for contract-level metadata.\\n     *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\\n     *                  See {_canSetContractURI}.\\n     *                  Emits {ContractURIUpdated Event}.\\n     *\\n     *  @param _uri     keccak256 hash of the role. e.g. keccak256(\\\"TRANSFER_ROLE\\\")\\n     */\\n    function setContractURI(string memory _uri) external override {\\n        if (!_canSetContractURI()) {\\n            revert ContractMetadataUnauthorized();\\n        }\\n\\n        _setupContractURI(_uri);\\n    }\\n\\n    /// @dev Lets a contract admin set the URI for contract-level metadata.\\n    function _setupContractURI(string memory _uri) internal {\\n        string memory prevURI = contractURI;\\n        contractURI = _uri;\\n\\n        emit ContractURIUpdated(prevURI, _uri);\\n    }\\n\\n    /// @dev Returns whether contract metadata can be set in the given execution context.\\n    function _canSetContractURI() internal view virtual returns (bool);\\n}\\n\\n// File: contracts/ICheebaNFTToken.sol\\n\\n\\npragma experimental ABIEncoderV2;\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract.\\n */\\ninterface ICheebaNFTToken {\\n\\n\\n    function mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) external;\\n\\n    function mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) external;\\n\\n    function renounceMinter() external;\\n\\n}\\n// File: @openzeppelin/contracts/utils/Context.sol\\n\\n\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\n// File: @openzeppelin/contracts/access/Ownable.sol\\n\\n\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\n// File: contracts/roles/Roles.sol\\n\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping(address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(\\n        Role storage role,\\n        address account\\n    ) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\\n// File: contracts/roles/MinterRole.sol\\n\\n\\npragma solidity ^0.8.20;\\n\\n\\n\\nabstract contract MinterRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    constructor () {\\n        _addMinter(_msgSender());\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(_msgSender()), \\\"MinterRole: caller does not have the Minter role\\\");\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(_msgSender());\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n}\\n// File: contracts/CheebaCrowdSale.sol\\n\\n\\npragma solidity ^0.8.20;\\n\\n\\n\\n\\n\\ncontract CheebaCrowdSale is Ownable, MinterRole, ContractMetadata {\\n\\n    // Sale start times\\n    uint256 public allowlistSaleStartTime;\\n    uint256 public publicSaleStartTime;\\n\\n    // Sale prices in USD (Equivalent to ETH)\\n    uint256 public allowlistSalePrice = 0.024 ether; // 0.024\\n    uint256 public publicSalePrice = 0.03 ether; // 0.03\\n\\n    // Sale limits per character\\n    uint16 public allowlistSaleLimit = 84;\\n    uint16 public publicSaleLimit = 315;\\n\\n    // Mapping to keep track of the amount minted against a particular ID\\n    mapping(uint256 => uint256) private mintedAmount;\\n    mapping(uint256 => uint256) private mintedAmountInPublicSale;\\n    mapping(uint256 => uint256) private mintedAmountInAllowlistSale;\\n\\n    event AddedToAllowlistSale(address[] indexed addr);\\n    event RemovedFromAllowlistSale(address[] indexed addr);\\n    event BuyToken(\\n        address callee,\\n        address indexed buyer,\\n        uint256[] indexed tokenId,\\n        uint256[] tokenQuantity\\n    );\\n\\n    address public deployer;\\n     // Token contract reference\\n    ICheebaNFTToken private tokenAddress;\\n\\n    modifier onlyAfterAllowlistSaleStart() {\\n        require(\\n            block.timestamp >= allowlistSaleStartTime,\\n            \\\"Sale is not started yet\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        ICheebaNFTToken _token,\\n        uint256 _allowlistSaleStartTime,\\n        uint256 _publicSaleStartTime\\n    ) Ownable(msg.sender) {\\n        deployer = msg.sender;\\n        tokenAddress = _token;\\n        allowlistSaleStartTime = _allowlistSaleStartTime;\\n        publicSaleStartTime = _publicSaleStartTime;\\n    }\\n\\n    function buyTokens(\\n        uint256[] memory tokenId,\\n        uint256[] memory amount,\\n        address buyerAddress\\n    ) external payable onlyAfterAllowlistSaleStart {\\n        // Check if each tokenId is within the valid range (1 to 10) and validate amount is valid or not\\n        for (uint256 i = 0; i < tokenId.length; i++) {\\n            require(tokenId[i] >= 1 && tokenId[i] <= 10, \\\"Invalid tokenId\\\");\\n        }\\n\\n        // Validate minting limit for the entire batch\\n        require(validateMintLimit(tokenId, amount), \\\"Minting limit exceeded\\\");\\n\\n        uint256 price = getCurrentSalePrice();\\n        uint256 totalPrice = price * calculateTotalAmount(amount);\\n        require(msg.value >= totalPrice, \\\"Insufficient funds\\\");\\n\\n        if (tokenId.length == 1) {\\n            // Single token minting\\n            tokenAddress.mint(buyerAddress, tokenId[0], amount[0]);\\n            mintedAmount[tokenId[0]] += amount[0];\\n            incrementMintedTokens(tokenId[0], amount[0]);\\n        } else {\\n            // Batch minting\\n            tokenAddress.mintBatch(buyerAddress, tokenId, amount);\\n            for (uint256 i = 0; i < tokenId.length; i++) {\\n                mintedAmount[tokenId[i]] += amount[i];\\n                incrementMintedTokens(tokenId[i], amount[i]);\\n            }\\n        }\\n\\n        payable(owner()).transfer(totalPrice);\\n        emit BuyToken(msg.sender, buyerAddress, tokenId, amount);\\n    }\\n\\n    // Function to get the current sale price according to the sale time\\n    function getCurrentSalePrice() public view returns (uint256) {\\n        if (block.timestamp < publicSaleStartTime) {\\n            return allowlistSalePrice;\\n        } else {\\n            return publicSalePrice;\\n        }\\n    }\\n\\n    // Function to get the amount minted against a particular ID\\n    function getMintedAmount(uint256 tokenId) external view returns (uint256) {\\n        return mintedAmount[tokenId];\\n    }\\n\\n    function calculateTotalAmount(\\n        uint256[] memory amounts\\n    ) private pure returns (uint256 totalAmount) {\\n        for (uint256 i = 0; i < amounts.length; i++) {\\n            totalAmount += amounts[i];\\n        }\\n        return totalAmount;\\n    }\\n\\n    // Function to validate minting limit\\n    function validateMintLimit(\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal view returns (bool) {\\n        require(ids.length == amounts.length, \\\"Array length mismatch\\\");\\n\\n        uint256 totalMinted = 0;\\n        uint256 mintingLimit = block.timestamp < publicSaleStartTime\\n            ? allowlistSaleLimit\\n            : 399;\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            totalMinted += mintedAmount[ids[i]] + amounts[i];\\n\\n            if (totalMinted <= mintingLimit) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    // Function to get the current stage start time and sale stage\\n    function getCurrentStageInfo()\\n        external\\n        view\\n        returns (uint256 nextSaleStartTime, string memory saleStage)\\n    {\\n        if (block.timestamp < allowlistSaleStartTime) {\\n            nextSaleStartTime = allowlistSaleStartTime;\\n            saleStage = \\\"Sale not started yet\\\";\\n        } else if (block.timestamp < publicSaleStartTime) {\\n            nextSaleStartTime = publicSaleStartTime;\\n            saleStage = \\\"Allowlist Sale\\\";\\n        } else {\\n            nextSaleStartTime = 0;\\n            saleStage = \\\"Public Sale\\\";\\n        }\\n    }\\n\\n    function incrementMintedTokens(uint256 tokenId, uint256 amount) internal {\\n        if (block.timestamp < publicSaleStartTime) {\\n            mintedAmountInAllowlistSale[tokenId] += amount;\\n        } else {\\n            mintedAmountInPublicSale[tokenId] += amount;\\n        }\\n    }\\n\\n    // Function to get the token minted amount in Allowlist Sale\\n    function getAllowlistSaleMintedAmount(\\n        uint256 tokenId\\n    ) external view returns (uint256) {\\n        return mintedAmountInAllowlistSale[tokenId];\\n    }\\n\\n    // Function to get the token minted amount in Public Sale\\n    function getPublicSaleMintedAmount(\\n        uint256 tokenId\\n    ) external view returns (uint256) {\\n        return mintedAmountInPublicSale[tokenId];\\n    }\\n\\n    // @dev enables token transfers, called when owner calls finalize()\\n    function finalization() public onlyOwner {\\n        tokenAddress.renounceMinter();\\n    }\\n\\n    function _canSetContractURI()\\n        internal\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return msg.sender == deployer;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ICheebaNFTToken\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allowlistSaleStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_publicSaleStartTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ContractMetadataUnauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"}],\"name\":\"AddedToAllowlistSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"callee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenQuantity\",\"type\":\"uint256[]\"}],\"name\":\"BuyToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"prevURI\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"}],\"name\":\"ContractURIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"}],\"name\":\"RemovedFromAllowlistSale\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowlistSaleLimit\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowlistSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowlistSaleStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"buyerAddress\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getAllowlistSaleMintedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentStageInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextSaleStartTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"saleStage\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMintedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPublicSaleMintedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSaleLimit\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSaleStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CheebaCrowdSale", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000dab4f0ec046b986f9fde245d20668ce1fee6da500000000000000000000000000000000000000000000000000000000661d74680000000000000000000000000000000000000000000000000000000066244da0", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}