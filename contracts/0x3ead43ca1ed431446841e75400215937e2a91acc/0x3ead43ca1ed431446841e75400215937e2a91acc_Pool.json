{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/Color.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nabstract contract Color {\\n    function getColor()\\n        external view virtual\\n        returns (bytes32);\\n}\\n\\ncontract Bronze is Color {\\n    function getColor()\\n        external view override\\n        returns (bytes32) {\\n            return bytes32(\\\"BRONZE\\\");\\n        }\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/Const.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Color.sol\\\";\\n\\ncontract Const is Bronze {\\n    uint public constant BONE              = 10**18;\\n    int public constant  iBONE             = int(BONE);\\n\\n    uint public constant MIN_POW_BASE      = 1 wei;\\n    uint public constant MAX_POW_BASE      = (2 * BONE) - 1 wei;\\n    uint public constant POW_PRECISION     = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/IDynamicFee.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface IDynamicFee {\\n\\n    function calc(\\n        int[3] calldata _inRecord,\\n        int[3] calldata _outRecord,\\n        int _baseFee,\\n        int _feeAmp,\\n        int _maxFee\\n    )\\n    external\\n    returns(int fee, int expStart);\\n\\n    function calcSpotFee(\\n        int _expStart,\\n        uint _baseFee,\\n        uint _feeAmp,\\n        uint _maxFee\\n    )\\n    external\\n    returns(uint);\\n}\\n\\n\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/IVault.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./libs/complifi/IDerivativeSpecification.sol\\\";\\n\\n/// @title Derivative implementation Vault\\n/// @notice A smart contract that references derivative specification and enables users to mint and redeem the derivative\\ninterface IVault {\\n    enum State { Created, Live, Settled }\\n\\n    /// @notice start of live period\\n    function liveTime() external view returns (uint256);\\n\\n    /// @notice end of live period\\n    function settleTime() external view returns (uint256);\\n\\n    /// @notice redeem function can only be called after the end of the Live period + delay\\n    function settlementDelay() external view returns (uint256);\\n\\n    /// @notice underlying value at the start of live period\\n    function underlyingStarts(uint256 index) external view returns (int256);\\n\\n    /// @notice underlying value at the end of live period\\n    function underlyingEnds(uint256 index) external view returns (int256);\\n\\n    /// @notice primary token conversion rate multiplied by 10 ^ 12\\n    function primaryConversion() external view returns (uint256);\\n\\n    /// @notice complement token conversion rate multiplied by 10 ^ 12\\n    function complementConversion() external view returns (uint256);\\n\\n    /// @notice protocol fee multiplied by 10 ^ 12\\n    function protocolFee() external view returns (uint256);\\n\\n    /// @notice limit on author fee multiplied by 10 ^ 12\\n    function authorFeeLimit() external view returns (uint256);\\n\\n    // @notice protocol's fee receiving wallet\\n    function feeWallet() external view returns (address);\\n\\n    // @notice current state of the vault\\n    function state() external view returns (State);\\n\\n    // @notice derivative specification address\\n    function derivativeSpecification()\\n        external\\n        view\\n        returns (IDerivativeSpecification);\\n\\n    // @notice collateral token address\\n    function collateralToken() external view returns (address);\\n\\n    // @notice oracle address\\n    function oracles(uint256 index) external view returns (address);\\n\\n    function oracleIterators(uint256 index) external view returns (address);\\n\\n    // @notice collateral split address\\n    function collateralSplit() external view returns (address);\\n\\n    // @notice derivative's token builder strategy address\\n    function tokenBuilder() external view returns (address);\\n\\n    function feeLogger() external view returns (address);\\n\\n    // @notice primary token address\\n    function primaryToken() external view returns (address);\\n\\n    // @notice complement token address\\n    function complementToken() external view returns (address);\\n\\n    /// @notice Switch to Settled state if appropriate time threshold is passed and\\n    /// set underlyingStarts value and set underlyingEnds value,\\n    /// calculate primaryConversion and complementConversion params\\n    /// @dev Reverts if underlyingStart or underlyingEnd are not available\\n    /// Vault cannot settle when it paused\\n    function settle(uint256[] calldata _underlyingEndRoundHints) external;\\n\\n    function mintTo(address _recipient, uint256 _collateralAmount) external;\\n\\n    /// @notice Mints primary and complement derivative tokens\\n    /// @dev Checks and switches to the right state and does nothing if vault is not in Live state\\n    function mint(uint256 _collateralAmount) external;\\n\\n    /// @notice Refund equal amounts of derivative tokens for collateral at any time\\n    function refund(uint256 _tokenAmount) external;\\n\\n    function refundTo(address _recipient, uint256 _tokenAmount) external;\\n\\n    function redeemTo(\\n        address _recipient,\\n        uint256 _primaryTokenAmount,\\n        uint256 _complementTokenAmount,\\n        uint256[] calldata _underlyingEndRoundHints\\n    ) external;\\n\\n    /// @notice Redeems unequal amounts previously calculated conversions if the vault is in Settled state\\n    function redeem(\\n        uint256 _primaryTokenAmount,\\n        uint256 _complementTokenAmount,\\n        uint256[] calldata _underlyingEndRoundHints\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/Math.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Num.sol\\\";\\n\\ncontract Math is Bronze, Const, Num {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                 bI          1                                         //\\n    // bO = tokenBalanceOut         sP =  ----  *  ----------                                    //\\n    // sF = swapFee                        bO      ( 1 - sF )                                    //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenBalanceOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint spotPrice)\\n    {\\n        uint ratio = div(tokenBalanceIn, tokenBalanceOut);\\n        uint scale = div(BONE, sub(BONE, swapFee));\\n        spotPrice = mul(ratio, scale);\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\   \\\\                 //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  |  |                 //\\n    // sF = swapFee                     \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /   /                 //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint tokenBalanceIn,\\n        uint tokenBalanceOut,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint adjustedIn = sub(BONE, swapFee);\\n        adjustedIn = mul(tokenAmountIn, adjustedIn);\\n        uint y = div(tokenBalanceIn, add(tokenBalanceIn, adjustedIn));\\n        uint bar = sub(BONE, y);\\n        tokenAmountOut = mul(tokenBalanceOut, bar);\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\       \\\\                             //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | - 1  |                             //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /       /                             //\\n    // sF = swapFee                 --------------------------------                             //\\n    //                                              ( 1 - sF )                                   //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint tokenBalanceIn,\\n        uint tokenBalanceOut,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint diff = sub(tokenBalanceOut, tokenAmountOut);\\n        uint y = div(tokenBalanceOut, diff);\\n        uint foo = sub(y, BONE);\\n        tokenAmountIn = sub(BONE, swapFee);\\n        tokenAmountIn = div(mul(tokenBalanceIn, foo), tokenAmountIn);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/Num.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Const.sol\\\";\\n\\ncontract Num is Const {\\n\\n    function toi(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function floor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return toi(a) * BONE;\\n    }\\n\\n    function add(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        c = a + b;\\n        require(c >= a, \\\"ADD_OVERFLOW\\\");\\n    }\\n\\n    function sub(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        bool flag;\\n        (c, flag) = subSign(a, b);\\n        require(!flag, \\\"SUB_UNDERFLOW\\\");\\n    }\\n\\n    function subSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function mul(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"MUL_OVERFLOW\\\");\\n        c = c1 / BONE;\\n    }\\n\\n    function div(uint a, uint b)\\n        internal pure\\n        returns (uint c)\\n    {\\n        require(b != 0, \\\"DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"DIV_INTERNAL\\\"); // mul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"DIV_INTERNAL\\\"); //  add require\\n        c = c1 / b;\\n    }\\n\\n    // DSMath.wpow\\n    function powi(uint a, uint n)\\n        internal pure\\n        returns (uint z)\\n    {\\n        z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = mul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = mul(z, a);\\n            }\\n        }\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `powi` for `b^e` and `powK` for k iterations\\n    // of approximation of b^0.w\\n    function pow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_POW_BASE, \\\"POW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_POW_BASE, \\\"POW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = floor(exp);\\n        uint remain = sub(exp, whole);\\n\\n        uint wholePow = powi(base, toi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = powApprox(base, remain, POW_PRECISION);\\n        return mul(wholePow, partialResult);\\n    }\\n\\n    function powApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint sum)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = subSign(base, BONE);\\n        uint term = BONE;\\n        sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom\\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = subSign(a, sub(bigK, BONE));\\n            term = mul(term, mul(c, x));\\n            term = div(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = sub(sum, term);\\n            } else {\\n                sum = add(sum, term);\\n            }\\n        }\\n    }\\n\\n    function min(uint first, uint second)\\n        internal pure\\n        returns (uint)\\n    {\\n        if(first < second) {\\n            return first;\\n        }\\n        return second;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/Pool.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport \\\"./libs/complifi/tokens/IERC20Metadata.sol\\\";\\nimport \\\"./libs/complifi/tokens/EIP20NonStandardInterface.sol\\\";\\nimport \\\"./libs/complifi/tokens/TokenMetadataGenerator.sol\\\";\\n\\nimport \\\"./Token.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./repricers/IRepricer.sol\\\";\\nimport \\\"./IDynamicFee.sol\\\";\\nimport \\\"./IVault.sol\\\";\\n\\ncontract Pool is Ownable, Pausable, Bronze, Token, Math, TokenMetadataGenerator {\\n\\n    struct Record {\\n        uint leverage;\\n        uint balance;\\n    }\\n\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256         tokenAmountIn,\\n        uint256         tokenAmountOut,\\n        uint256         fee,\\n        uint256         tokenBalanceIn,\\n        uint256         tokenBalanceOut,\\n        uint256         tokenLeverageIn,\\n        uint256         tokenLeverageOut\\n    );\\n\\n    event LOG_JOIN(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256         tokenAmountIn\\n    );\\n\\n    event LOG_EXIT(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_REPRICE(\\n        uint256         repricingBlock,\\n        uint256         balancePrimary,\\n        uint256         balanceComplement,\\n        uint256         leveragePrimary,\\n        uint256         leverageComplement,\\n        uint256         newLeveragePrimary,\\n        uint256         newLeverageComplement,\\n        int256          estPricePrimary,\\n        int256          estPriceComplement,\\n        int256          liveUnderlingValue\\n    );\\n\\n    event LOG_CALL(\\n        bytes4  indexed sig,\\n        address indexed caller,\\n        bytes           data\\n    ) anonymous;\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    modifier _lock_() {\\n        requireLock();\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        requireLock();\\n        _;\\n    }\\n\\n    modifier onlyFinalized() {\\n        require(_finalized, \\\"NOT_FINALIZED\\\");\\n        _;\\n    }\\n\\n    modifier onlyLiveDerivative() {\\n        require(\\n            block.timestamp < derivativeVault.settleTime(),\\n            \\\"SETTLED\\\"\\n        );\\n        _;\\n    }\\n\\n    function requireLock() internal view\\n    {\\n        require(!_mutex, \\\"REENTRY\\\");\\n    }\\n\\n    bool private _mutex;\\n\\n    address private controller; // has CONTROL role\\n\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    bool private _finalized;\\n\\n    uint public constant BOUND_TOKENS  = 2;\\n    address[BOUND_TOKENS] private _tokens;\\n    mapping(address => Record) internal _records;\\n\\n    uint public repricingBlock;\\n\\n    uint public baseFee;\\n    uint public feeAmp;\\n    uint public maxFee;\\n\\n    uint public pMin;\\n    uint public qMin;\\n    uint public exposureLimit;\\n    uint public volatility;\\n\\n    IVault public derivativeVault;\\n    IDynamicFee public dynamicFee;\\n    IRepricer public repricer;\\n\\n    constructor(\\n        address _derivativeVault,\\n        address _dynamicFee,\\n        address _repricer,\\n        uint _baseFee,\\n        uint _maxFee,\\n        uint _feeAmp,\\n        address _controller\\n    )\\n        public\\n    {\\n        require(_derivativeVault != address(0), \\\"NOT_D_VAULT\\\");\\n        derivativeVault = IVault(_derivativeVault);\\n\\n        require(_dynamicFee != address(0), \\\"NOT_FEE\\\");\\n        dynamicFee = IDynamicFee(_dynamicFee);\\n\\n        require(_repricer != address(0), \\\"NOT_REPRICER\\\");\\n        repricer = IRepricer(_repricer);\\n\\n        baseFee = _baseFee;\\n        feeAmp = _feeAmp;\\n        maxFee = _maxFee;\\n\\n        require(_controller != address(0), \\\"NOT_CONTROLLER\\\");\\n        controller = _controller;\\n\\n        string memory settlementDate = formatDate(derivativeVault.settleTime());\\n\\n        setName(makeTokenName(derivativeVault.derivativeSpecification().name(), settlementDate, \\\" LP\\\"));\\n        setSymbol(makeTokenSymbol(derivativeVault.derivativeSpecification().symbol(), settlementDate, \\\"-LP\\\"));\\n    }\\n\\n    function pause() external onlyOwner\\n    {\\n        _pause();\\n    }\\n    function unpause() external onlyOwner\\n    {\\n        _unpause();\\n    }\\n\\n    function isFinalized()\\n        external view\\n        returns (bool)\\n    {\\n        return _finalized;\\n    }\\n\\n    function getTokens()\\n        external view _viewlock_\\n        returns (address[BOUND_TOKENS] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    function getLeverage(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        return _records[token].leverage;\\n    }\\n\\n    function getBalance(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        return _records[token].balance;\\n    }\\n\\n    function finalize(\\n        uint _primaryBalance,\\n        uint _primaryLeverage,\\n        uint _complementBalance,\\n        uint _complementLeverage,\\n        uint _exposureLimit,\\n        uint _volatility,\\n        uint _pMin,\\n        uint _qMin\\n    )\\n        external\\n        _logs_\\n        _lock_\\n        onlyLiveDerivative\\n    {\\n        require(!_finalized, \\\"IS_FINALIZED\\\");\\n        require(msg.sender == controller, \\\"NOT_CONTROLLER\\\");\\n\\n        require(_primaryBalance == _complementBalance, \\\"NOT_SYMMETRIC\\\");\\n\\n        pMin = _pMin;\\n        qMin = _qMin;\\n        exposureLimit = _exposureLimit;\\n        volatility = _volatility;\\n\\n        _finalized = true;\\n\\n        bind(0, address(derivativeVault.primaryToken()), _primaryBalance, _primaryLeverage);\\n        bind(1, address(derivativeVault.complementToken()), _complementBalance, _complementLeverage);\\n\\n        uint initPoolSupply = getDerivativeDenomination() * _primaryBalance;\\n\\n        uint collateralDecimals = uint(IERC20Metadata(address(derivativeVault.collateralToken())).decimals());\\n        if(collateralDecimals >= 0 && collateralDecimals < 18) {\\n            initPoolSupply = initPoolSupply * (10 ** (18 - collateralDecimals));\\n        }\\n\\n        _mintPoolShare(initPoolSupply);\\n        _pushPoolShare(msg.sender, initPoolSupply);\\n    }\\n\\n    function bind(uint index, address token, uint balance, uint leverage)\\n    internal\\n    {\\n        require(balance >= qMin, \\\"MIN_BALANCE\\\");\\n        require(leverage > 0, \\\"ZERO_LEVERAGE\\\");\\n\\n        _records[token] = Record({\\n            leverage: leverage,\\n            balance: balance\\n        });\\n\\n        _tokens[index] = token;\\n\\n        _pullUnderlying(token, msg.sender, balance);\\n    }\\n\\n    function joinPool(uint poolAmountOut, uint[2] calldata maxAmountsIn)\\n        external\\n        _logs_\\n        _lock_\\n        onlyFinalized\\n    {\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = div(poolAmountOut, poolTotal);\\n        require(ratio != 0, \\\"MATH_APPROX\\\");\\n\\n        for (uint i = 0; i < BOUND_TOKENS; i++) {\\n            address token = _tokens[i];\\n            uint bal = _records[token].balance;\\n            require(bal > 0, \\\"NO_BALANCE\\\");\\n            uint tokenAmountIn = mul(ratio, bal);\\n            require(tokenAmountIn <= maxAmountsIn[i], \\\"LIMIT_IN\\\");\\n            _records[token].balance = add(_records[token].balance, tokenAmountIn);\\n            emit LOG_JOIN(msg.sender, token, tokenAmountIn);\\n            _pullUnderlying(token, msg.sender, tokenAmountIn);\\n        }\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n    }\\n\\n    function exitPool(uint poolAmountIn, uint[2] calldata minAmountsOut)\\n        external\\n        _logs_\\n        _lock_\\n        onlyFinalized\\n    {\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = div(poolAmountIn, poolTotal);\\n        require(ratio != 0, \\\"MATH_APPROX\\\");\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(poolAmountIn);\\n\\n        for (uint i = 0; i < BOUND_TOKENS; i++) {\\n            address token = _tokens[i];\\n            uint bal = _records[token].balance;\\n            require(bal > 0, \\\"NO_BALANCE\\\");\\n            uint tokenAmountOut = mul(ratio, bal);\\n            require(tokenAmountOut >= minAmountsOut[i], \\\"LIMIT_OUT\\\");\\n            _records[token].balance = sub(_records[token].balance, tokenAmountOut);\\n            emit LOG_EXIT(msg.sender, token, tokenAmountOut);\\n            _pushUnderlying(token, msg.sender, tokenAmountOut);\\n        }\\n    }\\n\\n    function reprice()\\n        internal virtual\\n    {\\n        if(repricingBlock == block.number) return;\\n        repricingBlock = block.number;\\n\\n        Record storage primaryRecord = _records[_getPrimaryDerivativeAddress()];\\n        Record storage complementRecord = _records[_getComplementDerivativeAddress()];\\n\\n        uint256[2] memory primaryParams = [primaryRecord.balance, primaryRecord.leverage];\\n        uint256[2] memory complementParams = [complementRecord.balance, complementRecord.leverage];\\n\\n        (\\n            uint newPrimaryLeverage,\\n            uint newComplementLeverage,\\n            int estPricePrimary,\\n            int estPriceComplement\\n        ) = repricer.reprice(\\n            pMin,\\n            int(volatility),\\n            derivativeVault,\\n            primaryParams,\\n            complementParams,\\n            derivativeVault.underlyingStarts(0)\\n        );\\n\\n        emit LOG_REPRICE(\\n            repricingBlock,\\n            primaryParams[0],\\n            complementParams[0],\\n            primaryParams[1],\\n            complementParams[1],\\n            newPrimaryLeverage,\\n            newComplementLeverage,\\n            estPricePrimary,\\n            estPriceComplement,\\n            derivativeVault.underlyingStarts(0)\\n        );\\n\\n        primaryRecord.leverage = newPrimaryLeverage;\\n        complementRecord.leverage = newComplementLeverage;\\n    }\\n\\n    function calcFee(\\n        Record memory inRecord,\\n        uint tokenAmountIn,\\n        Record memory outRecord,\\n        uint tokenAmountOut\\n    )\\n    internal\\n    returns (uint fee, int expStart)\\n    {\\n        int ifee;\\n        (ifee, expStart) = dynamicFee.calc(\\n            [int(inRecord.balance), int(inRecord.leverage), int(tokenAmountIn)],\\n            [int(outRecord.balance), int(outRecord.leverage), int(tokenAmountOut)],\\n            int(baseFee),\\n            int(feeAmp),\\n            int(maxFee)\\n        );\\n        require(ifee > 0, \\\"BAD_FEE\\\");\\n        fee = uint(ifee);\\n    }\\n\\n    function calcExpStart(\\n        int _inBalance,\\n        int _outBalance\\n    )\\n    internal pure\\n    returns(int) {\\n        return (_inBalance - _outBalance) * iBONE / (_inBalance + _outBalance);\\n    }\\n\\n    function performSwap(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint tokenAmountOut,\\n        uint spotPriceBefore,\\n        uint fee\\n    )\\n    internal returns(uint spotPriceAfter)\\n    {\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n\\n        requireBoundaryConditions(inRecord, tokenAmountIn, outRecord, tokenAmountOut);\\n\\n        updateLeverages(inRecord, tokenAmountIn, outRecord, tokenAmountOut);\\n\\n        inRecord.balance = add(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = sub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n            getLeveragedBalance(inRecord),\\n            getLeveragedBalance(outRecord),\\n            dynamicFee.calcSpotFee(\\n                calcExpStart(\\n                    int(inRecord.balance),\\n                    int(outRecord.balance)\\n                ),\\n                baseFee,\\n                feeAmp,\\n                maxFee\\n            )\\n        );\\n\\n        require(spotPriceAfter >= spotPriceBefore, \\\"MATH_APPROX\\\");\\n        require(spotPriceBefore <= div(tokenAmountIn, tokenAmountOut), \\\"MATH_APPROX_OTHER\\\");\\n\\n        emit LOG_SWAP(\\n            msg.sender,\\n            tokenIn,\\n            tokenOut,\\n            tokenAmountIn,\\n            tokenAmountOut,\\n            fee,\\n            inRecord.balance,\\n            outRecord.balance,\\n            inRecord.leverage,\\n            outRecord.leverage\\n        );\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n    }\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut\\n    )\\n        external\\n        _logs_\\n        _lock_\\n        whenNotPaused\\n        onlyFinalized\\n        onlyLiveDerivative\\n        returns (uint tokenAmountOut, uint spotPriceAfter)\\n    {\\n\\n        require(tokenIn != tokenOut, \\\"SAME_TOKEN\\\");\\n        require(tokenAmountIn >= qMin, \\\"MIN_TOKEN_IN\\\");\\n\\n        reprice();\\n\\n        Record memory inRecord = _records[tokenIn];\\n        Record memory outRecord = _records[tokenOut];\\n\\n        require(tokenAmountIn <= mul(min(getLeveragedBalance(inRecord), inRecord.balance), MAX_IN_RATIO), \\\"MAX_IN_RATIO\\\");\\n\\n        tokenAmountOut = calcOutGivenIn(\\n            getLeveragedBalance(inRecord),\\n            getLeveragedBalance(outRecord),\\n            tokenAmountIn,\\n            0\\n        );\\n\\n        uint fee;\\n        int expStart;\\n        (fee, expStart) = calcFee(\\n            inRecord,\\n            tokenAmountIn,\\n            outRecord,\\n            tokenAmountOut\\n        );\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    getLeveragedBalance(inRecord),\\n                                    getLeveragedBalance(outRecord),\\n                                    dynamicFee.calcSpotFee(expStart, baseFee, feeAmp, maxFee)\\n                                );\\n\\n        tokenAmountOut = calcOutGivenIn(\\n                            getLeveragedBalance(inRecord),\\n                            getLeveragedBalance(outRecord),\\n                            tokenAmountIn,\\n                            fee\\n                        );\\n        require(tokenAmountOut >= minAmountOut, \\\"LIMIT_OUT\\\");\\n\\n        spotPriceAfter = performSwap(\\n            tokenIn,\\n            tokenAmountIn,\\n            tokenOut,\\n            tokenAmountOut,\\n            spotPriceBefore,\\n            fee\\n        );\\n    }\\n\\n    // Method temporary is not available for external usage.\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint maxAmountIn,\\n        address tokenOut,\\n        uint tokenAmountOut\\n    )\\n        private\\n        _logs_\\n        _lock_\\n        whenNotPaused\\n        onlyFinalized\\n        onlyLiveDerivative\\n        returns (uint tokenAmountIn, uint spotPriceAfter)\\n    {\\n        require(tokenIn != tokenOut, \\\"SAME_TOKEN\\\");\\n        require(tokenAmountOut >= qMin, \\\"MIN_TOKEN_OUT\\\");\\n\\n        reprice();\\n\\n        Record memory inRecord = _records[tokenIn];\\n        Record memory outRecord = _records[tokenOut];\\n\\n        require(tokenAmountOut <= mul(min(getLeveragedBalance(outRecord), outRecord.balance), MAX_OUT_RATIO), \\\"MAX_OUT_RATIO\\\");\\n\\n        tokenAmountIn = calcInGivenOut(\\n            getLeveragedBalance(inRecord),\\n            getLeveragedBalance(outRecord),\\n            tokenAmountOut,\\n            0\\n        );\\n\\n        uint fee;\\n        int expStart;\\n        (fee, expStart) = calcFee(\\n            inRecord,\\n            tokenAmountIn,\\n            outRecord,\\n            tokenAmountOut\\n        );\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    getLeveragedBalance(inRecord),\\n                                    getLeveragedBalance(outRecord),\\n                                    dynamicFee.calcSpotFee(expStart, baseFee, feeAmp, maxFee)\\n                                );\\n\\n        tokenAmountIn = calcInGivenOut(\\n                            getLeveragedBalance(inRecord),\\n                            getLeveragedBalance(outRecord),\\n                            tokenAmountOut,\\n                            fee\\n                        );\\n\\n        require(tokenAmountIn <= maxAmountIn, \\\"LIMIT_IN\\\");\\n\\n        spotPriceAfter = performSwap(\\n            tokenIn,\\n            tokenAmountIn,\\n            tokenOut,\\n            tokenAmountOut,\\n            spotPriceBefore,\\n            fee\\n        );\\n    }\\n\\n    function getLeveragedBalance(\\n        Record memory r\\n    )\\n    internal pure\\n    returns(uint)\\n    {\\n        return mul(r.balance, r.leverage);\\n    }\\n\\n    function requireBoundaryConditions(\\n        Record storage inToken,\\n        uint tokenAmountIn,\\n        Record storage outToken,\\n        uint tokenAmountOut\\n    )\\n    internal view\\n    {\\n\\n        require( sub(getLeveragedBalance(outToken), tokenAmountOut) > qMin, \\\"BOUNDARY_LEVERAGED\\\");\\n        require( sub(outToken.balance, tokenAmountOut) > qMin, \\\"BOUNDARY_NON_LEVERAGED\\\");\\n\\n        uint denomination = getDerivativeDenomination() * BONE;\\n        uint lowerBound = div(pMin, sub(denomination, pMin));\\n        uint upperBound = div(sub(denomination, pMin), pMin);\\n        uint value = div(add(getLeveragedBalance(inToken), tokenAmountIn), sub(getLeveragedBalance(outToken), tokenAmountOut));\\n\\n        require(lowerBound < value, \\\"BOUNDARY_LOWER\\\");\\n        require(value < upperBound, \\\"BOUNDARY_UPPER\\\");\\n\\n        uint numerator;\\n        (numerator,) = subSign(add(add(inToken.balance, tokenAmountIn), tokenAmountOut), outToken.balance);\\n\\n        uint denominator = sub(add(add(inToken.balance, tokenAmountIn), outToken.balance), tokenAmountOut);\\n        require(div(numerator, denominator) < exposureLimit, \\\"BOUNDARY_EXPOSURE\\\");\\n    }\\n\\n    function updateLeverages(\\n        Record storage inToken,\\n        uint tokenAmountIn,\\n        Record storage outToken,\\n        uint tokenAmountOut\\n    )\\n    internal\\n    {\\n        outToken.leverage = div(\\n            sub(getLeveragedBalance(outToken), tokenAmountOut),\\n            sub(outToken.balance, tokenAmountOut)\\n        );\\n        require(outToken.leverage > 0, \\\"ZERO_OUT_LEVERAGE\\\");\\n\\n        inToken.leverage = div(\\n            add(getLeveragedBalance(inToken), tokenAmountIn),\\n            add(inToken.balance, tokenAmountIn)\\n        );\\n        require(inToken.leverage > 0, \\\"ZERO_IN_LEVERAGE\\\");\\n    }\\n\\n    function getDerivativeDenomination()\\n    internal view\\n    returns(uint denomination)\\n    {\\n        denomination =\\n            derivativeVault.derivativeSpecification().primaryNominalValue() +\\n            derivativeVault.derivativeSpecification().complementNominalValue();\\n    }\\n\\n    function _getPrimaryDerivativeAddress()\\n    internal view\\n    returns(address)\\n    {\\n        return _tokens[0];\\n    }\\n\\n    function _getComplementDerivativeAddress()\\n    internal view\\n    returns(address)\\n    {\\n        return _tokens[1];\\n    }\\n\\n    // ==\\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n\\n    function _pullPoolShare(address from, uint amount)\\n        internal\\n    {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount)\\n        internal\\n    {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint amount)\\n        internal\\n    {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint amount)\\n        internal\\n    {\\n        _burn(amount);\\n    }\\n\\n    /// @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\\n    /// This will revert due to insufficient balance or insufficient allowance.\\n    /// This function returns the actual amount received,\\n    /// which may be less than `amount` if there is a fee attached to the transfer.\\n    /// @notice This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n    /// See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n    function _pullUnderlying(address erc20, address from, uint256 amount)\\n    internal\\n    returns (uint256)\\n    {\\n        uint256 balanceBefore = IERC20(erc20).balanceOf(address(this));\\n        EIP20NonStandardInterface(erc20).transferFrom(\\n            from,\\n            address(this),\\n            amount\\n        );\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n            case 0 {\\n            // This is a non-standard ERC-20\\n                success := not(0) // set success to true\\n            }\\n            case 32 {\\n            // This is a compliant ERC-20\\n                returndatacopy(0, 0, 32)\\n                success := mload(0) // Set `success = returndata` of external call\\n            }\\n            default {\\n            // This is an excessively non-compliant ERC-20, revert.\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_IN_FAILED\\\");\\n\\n        // Calculate the amount that was *actually* transferred\\n        uint256 balanceAfter = IERC20(erc20).balanceOf(address(this));\\n        require(balanceAfter >= balanceBefore, \\\"TOKEN_TRANSFER_IN_OVERFLOW\\\");\\n        return balanceAfter - balanceBefore; // underflow already checked above, just subtract\\n    }\\n\\n    /// @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\\n    /// error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\\n    /// insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\\n    /// it is >= amount, this should not revert in normal conditions.\\n    /// @notice This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\\n    /// See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n    function _pushUnderlying(address erc20, address to, uint256 amount) internal {\\n        EIP20NonStandardInterface(erc20).transfer(\\n            to,\\n            amount\\n        );\\n\\n        bool success;\\n        assembly {\\n            switch returndatasize()\\n            case 0 {\\n            // This is a non-standard ERC-20\\n                success := not(0) // set success to true\\n            }\\n            case 32 {\\n            // This is a complaint ERC-20\\n                returndatacopy(0, 0, 32)\\n                success := mload(0) // Set `success = returndata` of external call\\n            }\\n            default {\\n            // This is an excessively non-compliant ERC-20, revert.\\n                revert(0, 0)\\n            }\\n        }\\n        require(success, \\\"TOKEN_TRANSFER_OUT_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/Token.sol\": {\r\n      \"content\": \"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"./Num.sol\\\";\\n\\n// Highly opinionated token implementation\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address whom) external view returns (uint);\\n    function allowance(address src, address dst) external view returns (uint);\\n\\n    function approve(address dst, uint amt) external returns (bool);\\n    function transfer(address dst, uint amt) external returns (bool);\\n    function transferFrom(\\n        address src, address dst, uint amt\\n    ) external returns (bool);\\n}\\n\\ncontract TokenBase is Num {\\n\\n    mapping(address => uint)                   internal _balance;\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = add(_balance[address(this)], amt);\\n        _totalSupply = add(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] >= amt, \\\"INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = sub(_balance[address(this)], amt);\\n        _totalSupply = sub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] >= amt, \\\"INSUFFICIENT_BAL\\\");\\n        _balance[src] = sub(_balance[src], amt);\\n        _balance[dst] = add(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract Token is TokenBase, IERC20 {\\n\\n    string  private _name;\\n    string  private _symbol;\\n    uint8   private constant _decimals = 18;\\n\\n    function setName(string memory name) internal {\\n        _name = name;\\n    }\\n\\n    function setSymbol(string memory symbol) internal {\\n        _symbol = symbol;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns(uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external view override returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view override returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view override returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external override returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = add(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = sub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external override returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\\n        uint oldValue = _allowance[src][msg.sender];\\n        require(msg.sender == src || amt <= oldValue, \\\"TOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src && oldValue != uint256(-1)) {\\n            _allowance[src][msg.sender] = sub(oldValue, amt);\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/libs/complifi/IDerivativeSpecification.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title Derivative Specification interface\\n/// @notice Immutable collection of derivative attributes\\n/// @dev Created by the derivative's author and published to the DerivativeSpecificationRegistry\\ninterface IDerivativeSpecification {\\n    /// @notice Proof of a derivative specification\\n    /// @dev Verifies that contract is a derivative specification\\n    /// @return true if contract is a derivative specification\\n    function isDerivativeSpecification() external pure returns (bool);\\n\\n    /// @notice Set of oracles that are relied upon to measure changes in the state of the world\\n    /// between the start and the end of the Live period\\n    /// @dev Should be resolved through OracleRegistry contract\\n    /// @return oracle symbols\\n    function oracleSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Algorithm that, for the type of oracle used by the derivative,\\n    /// finds the value closest to a given timestamp\\n    /// @dev Should be resolved through OracleIteratorRegistry contract\\n    /// @return oracle iterator symbols\\n    function oracleIteratorSymbols() external view returns (bytes32[] memory);\\n\\n    /// @notice Type of collateral that users submit to mint the derivative\\n    /// @dev Should be resolved through CollateralTokenRegistry contract\\n    /// @return collateral token symbol\\n    function collateralTokenSymbol() external view returns (bytes32);\\n\\n    /// @notice Mapping from the change in the underlying variable (as defined by the oracle)\\n    /// and the initial collateral split to the final collateral split\\n    /// @dev Should be resolved through CollateralSplitRegistry contract\\n    /// @return collateral split symbol\\n    function collateralSplitSymbol() external view returns (bytes32);\\n\\n    /// @notice Lifecycle parameter that define the length of the derivative's Live period.\\n    /// @dev Set in seconds\\n    /// @return live period value\\n    function livePeriod() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of primary asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of primary asset\\n    /// @return primary nominal value\\n    function primaryNominalValue() external view returns (uint256);\\n\\n    /// @notice Parameter that determines starting nominal value of complement asset\\n    /// @dev Units of collateral theoretically swappable for 1 unit of complement asset\\n    /// @return complement nominal value\\n    function complementNominalValue() external view returns (uint256);\\n\\n    /// @notice Minting fee rate due to the author of the derivative specification.\\n    /// @dev Percentage fee multiplied by 10 ^ 12\\n    /// @return author fee\\n    function authorFee() external view returns (uint256);\\n\\n    /// @notice Symbol of the derivative\\n    /// @dev Should be resolved through DerivativeSpecificationRegistry contract\\n    /// @return derivative specification symbol\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Return optional long name of the derivative\\n    /// @dev Isn't used directly in the protocol\\n    /// @return long name\\n    function name() external view returns (string memory);\\n\\n    /// @notice Optional URI to the derivative specs\\n    /// @dev Isn't used directly in the protocol\\n    /// @return URI to the derivative specs\\n    function baseURI() external view returns (string memory);\\n\\n    /// @notice Derivative spec author\\n    /// @dev Used to set and receive author's fee\\n    /// @return address of the author\\n    function author() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/libs/complifi/libs/BokkyPooBahsDateTimeLibrary/BokkyPooBahsDateTimeLibrary.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.0;\\n\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's DateTime Library v1.01\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary BokkyPooBahsDateTimeLibrary {\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 constant SECONDS_PER_MINUTE = 60;\\n    int256 constant OFFSET19700101 = 2440588;\\n\\n    uint256 constant DOW_MON = 1;\\n    uint256 constant DOW_TUE = 2;\\n    uint256 constant DOW_WED = 3;\\n    uint256 constant DOW_THU = 4;\\n    uint256 constant DOW_FRI = 5;\\n    uint256 constant DOW_SAT = 6;\\n    uint256 constant DOW_SUN = 7;\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // days = day\\n    //      - 32075\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n    //      - offset\\n    // ------------------------------------------------------------------------\\n    function _daysFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 _days) {\\n        require(year >= 1970);\\n        int256 _year = int256(year);\\n        int256 _month = int256(month);\\n        int256 _day = int256(day);\\n\\n        int256 __days =\\n            _day -\\n                32075 +\\n                (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n                4 +\\n                (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n                12 -\\n                (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n                4 -\\n                OFFSET19700101;\\n\\n        _days = uint256(__days);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n\\n    function timestampFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 timestamp) {\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\n    }\\n\\n    function timestampFromDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (uint256 timestamp) {\\n        timestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            hour *\\n            SECONDS_PER_HOUR +\\n            minute *\\n            SECONDS_PER_MINUTE +\\n            second;\\n    }\\n\\n    function timestampToDate(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function timestampToDateTime(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day,\\n            uint256 hour,\\n            uint256 minute,\\n            uint256 second\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint256 secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n        secs = secs % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n        second = secs % SECONDS_PER_MINUTE;\\n    }\\n\\n    function isValidDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (bool valid) {\\n        if (year >= 1970 && month > 0 && month <= 12) {\\n            uint256 daysInMonth = _getDaysInMonth(year, month);\\n            if (day > 0 && day <= daysInMonth) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isValidDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (bool valid) {\\n        if (isValidDate(year, month, day)) {\\n            if (hour < 24 && minute < 60 && second < 60) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isLeapYear(uint256 timestamp)\\n        internal\\n        pure\\n        returns (bool leapYear)\\n    {\\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        leapYear = _isLeapYear(year);\\n    }\\n\\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n    }\\n\\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\\n    }\\n\\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\\n    }\\n\\n    function getDaysInMonth(uint256 timestamp)\\n        internal\\n        pure\\n        returns (uint256 daysInMonth)\\n    {\\n        (uint256 year, uint256 month, ) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        daysInMonth = _getDaysInMonth(year, month);\\n    }\\n\\n    function _getDaysInMonth(uint256 year, uint256 month)\\n        internal\\n        pure\\n        returns (uint256 daysInMonth)\\n    {\\n        if (\\n            month == 1 ||\\n            month == 3 ||\\n            month == 5 ||\\n            month == 7 ||\\n            month == 8 ||\\n            month == 10 ||\\n            month == 12\\n        ) {\\n            daysInMonth = 31;\\n        } else if (month != 2) {\\n            daysInMonth = 30;\\n        } else {\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\n        }\\n    }\\n\\n    // 1 = Monday, 7 = Sunday\\n    function getDayOfWeek(uint256 timestamp)\\n        internal\\n        pure\\n        returns (uint256 dayOfWeek)\\n    {\\n        uint256 _days = timestamp / SECONDS_PER_DAY;\\n        dayOfWeek = ((_days + 3) % 7) + 1;\\n    }\\n\\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\\n        uint256 secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n    }\\n\\n    function getMinute(uint256 timestamp)\\n        internal\\n        pure\\n        returns (uint256 minute)\\n    {\\n        uint256 secs = timestamp % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n    }\\n\\n    function getSecond(uint256 timestamp)\\n        internal\\n        pure\\n        returns (uint256 second)\\n    {\\n        second = timestamp % SECONDS_PER_MINUTE;\\n    }\\n\\n    function addYears(uint256 timestamp, uint256 _years)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        (uint256 year, uint256 month, uint256 day) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year += _years;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMonths(uint256 timestamp, uint256 _months)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        (uint256 year, uint256 month, uint256 day) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        month += _months;\\n        year += (month - 1) / 12;\\n        month = ((month - 1) % 12) + 1;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addDays(uint256 timestamp, uint256 _days)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addHours(uint256 timestamp, uint256 _hours)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMinutes(uint256 timestamp, uint256 _minutes)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addSeconds(uint256 timestamp, uint256 _seconds)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp + _seconds;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function subYears(uint256 timestamp, uint256 _years)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        (uint256 year, uint256 month, uint256 day) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year -= _years;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMonths(uint256 timestamp, uint256 _months)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        (uint256 year, uint256 month, uint256 day) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint256 yearMonth = year * 12 + (month - 1) - _months;\\n        year = yearMonth / 12;\\n        month = (yearMonth % 12) + 1;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subDays(uint256 timestamp, uint256 _days)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subHours(uint256 timestamp, uint256 _hours)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMinutes(uint256 timestamp, uint256 _minutes)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subSeconds(uint256 timestamp, uint256 _seconds)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp - _seconds;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _years)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _years = toYear - fromYear;\\n    }\\n\\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _months)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint256 fromYear, uint256 fromMonth, ) =\\n            _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint256 toYear, uint256 toMonth, ) =\\n            _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n    }\\n\\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _days)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\n    }\\n\\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _hours)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\n    }\\n\\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _minutes)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\n    }\\n\\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _seconds)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        _seconds = toTimestamp - fromTimestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/libs/complifi/tokens/EIP20NonStandardInterface.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\n/// @title EIP20NonStandardInterface\\n/// @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n/// See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\ninterface EIP20NonStandardInterface {\\n    /// @notice Get the total number of tokens in circulation\\n    /// @return The supply of tokens\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Gets the balance of the specified address\\n    /// @param owner The address from which the balance will be retrieved\\n    /// @return balance The balance\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    //\\n    // !!!!!!!!!!!!!!\\n    // !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    // !!!!!!!!!!!!!!\\n    //\\n\\n    /// @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n    /// @param dst The address of the destination account\\n    /// @param amount The number of tokens to transfer\\n    function transfer(address dst, uint256 amount) external;\\n\\n    //\\n    // !!!!!!!!!!!!!!\\n    // !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    // !!!!!!!!!!!!!!\\n    //\\n\\n    /// @notice Transfer `amount` tokens from `src` to `dst`\\n    /// @param src The address of the source account\\n    /// @param dst The address of the destination account\\n    /// @param amount The number of tokens to transfer\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external;\\n\\n    /// @notice Approve `spender` to transfer up to `amount` from `src`\\n    /// @dev This will overwrite the approval amount for `spender`\\n    ///  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n    /// @param spender The address of the account which may transfer tokens\\n    /// @param amount The number of tokens that are approved\\n    /// @return success Whether or not the approval succeeded\\n    function approve(address spender, uint256 amount)\\n        external\\n        returns (bool success);\\n\\n    /// @notice Get the current allowance from `owner` for `spender`\\n    /// @param owner The address of the account which owns the tokens to be spent\\n    /// @param spender The address of the account which may transfer tokens\\n    /// @return remaining The number of tokens allowed to be spent\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/libs/complifi/tokens/IERC20Metadata.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\ninterface IERC20Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/libs/complifi/tokens/TokenMetadataGenerator.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GPL-3.0-or-later\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../libs/BokkyPooBahsDateTimeLibrary/BokkyPooBahsDateTimeLibrary.sol\\\";\\n\\ncontract TokenMetadataGenerator {\\n    function formatDate(uint256 _posixDate)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        uint256 year;\\n        uint256 month;\\n        uint256 day;\\n        (year, month, day) = BokkyPooBahsDateTimeLibrary.timestampToDate(\\n            _posixDate\\n        );\\n\\n        return\\n            concat(\\n                uint2str(day),\\n                concat(\\n                    getMonthShortName(month),\\n                    uint2str(getCenturyYears(year))\\n                )\\n            );\\n    }\\n\\n    function formatMeta(\\n        string memory _prefix,\\n        string memory _concatenator,\\n        string memory _date,\\n        string memory _postfix\\n    ) internal pure returns (string memory) {\\n        return concat(_prefix, concat(_concatenator, concat(_date, _postfix)));\\n    }\\n\\n    function makeTokenName(\\n        string memory _baseName,\\n        string memory _date,\\n        string memory _postfix\\n    ) internal pure returns (string memory) {\\n        return formatMeta(_baseName, \\\" \\\", _date, _postfix);\\n    }\\n\\n    function makeTokenSymbol(\\n        string memory _baseName,\\n        string memory _date,\\n        string memory _postfix\\n    ) internal pure returns (string memory) {\\n        return formatMeta(_baseName, \\\"-\\\", _date, _postfix);\\n    }\\n\\n    function getCenturyYears(uint256 _year) internal pure returns (uint256) {\\n        return _year % 100;\\n    }\\n\\n    function concat(string memory _a, string memory _b)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string(abi.encodePacked(bytes(_a), bytes(_b)));\\n    }\\n\\n    function uint2str(uint256 _i)\\n        internal\\n        pure\\n        returns (string memory _uintAsString)\\n    {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    function getMonthShortName(uint256 _month)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if (_month == 1) {\\n            return \\\"Jan\\\";\\n        }\\n        if (_month == 2) {\\n            return \\\"Feb\\\";\\n        }\\n        if (_month == 3) {\\n            return \\\"Mar\\\";\\n        }\\n        if (_month == 4) {\\n            return \\\"Arp\\\";\\n        }\\n        if (_month == 5) {\\n            return \\\"May\\\";\\n        }\\n        if (_month == 6) {\\n            return \\\"Jun\\\";\\n        }\\n        if (_month == 7) {\\n            return \\\"Jul\\\";\\n        }\\n        if (_month == 8) {\\n            return \\\"Aug\\\";\\n        }\\n        if (_month == 9) {\\n            return \\\"Sep\\\";\\n        }\\n        if (_month == 10) {\\n            return \\\"Oct\\\";\\n        }\\n        if (_month == 11) {\\n            return \\\"Nov\\\";\\n        }\\n        if (_month == 12) {\\n            return \\\"Dec\\\";\\n        }\\n        return \\\"NaN\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/miogreen/Development/complifi/src/complifi-amm-internal/contracts/repricers/IRepricer.sol\": {\r\n      \"content\": \"// \\\"SPDX-License-Identifier: GNU General Public License v3.0\\\"\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"../IVault.sol\\\";\\n\\ninterface IRepricer {\\n\\n    function isRepricer() external pure returns(bool);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function reprice(\\n        uint _pMin,\\n        int _volatility,\\n        IVault _vault,\\n        uint[2] memory _primary,\\n        uint[2] memory _complement,\\n        int _liveUnderlingValue\\n    )\\n    external view returns(\\n        uint newPrimaryLeverage, uint newComplementLeverage, int estPricePrimary, int estPriceComplement\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_derivativeVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dynamicFee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_repricer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_baseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repricingBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balancePrimary\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balanceComplement\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leveragePrimary\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverageComplement\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLeveragePrimary\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLeverageComplement\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"estPricePrimary\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"estPriceComplement\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"liveUnderlingValue\",\"type\":\"int256\"}],\"name\":\"LOG_REPRICE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenLeverageIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenLeverageOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_POW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_POW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"derivativeVault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicFee\",\"outputs\":[{\"internalType\":\"contract IDynamicFee\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[2]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exposureLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAmp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_primaryBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_primaryLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_complementBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_complementLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_exposureLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_volatility\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_qMin\",\"type\":\"uint256\"}],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLeverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[2]\",\"name\":\"tokens\",\"type\":\"address[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iBONE\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[2]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"qMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repricer\",\"outputs\":[{\"internalType\":\"contract IRepricer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repricingBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volatility\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Pool", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000d6f361320e61d0a912acf10c53e2d5c43aa79dc2000000000000000000000000db635eebaedef9801653f559e2c859aa81ac1ff4000000000000000000000000ee981eb86df4569b6368d9cb2172ff971bf453de0000000000000000000000000000000000000000000000000011c37937e0800000000000000000000000000000000000000000000000000003782dace9d90000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a596c2d3e0f390a212a8ed47308cf621b5e949c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}