{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Auctions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n//                            _.-^-._    .--.\\n//                         .-'   _   '-. |__|\\n//                        /     |_|     \\\\|  |\\n//                       /               \\\\  |\\n//                      /|     _____     |\\\\ |\\n//                       |    |==|==|    |  |\\n//   |---|---|---|---|---|    |--|--|    |  |\\n//   |---|---|---|---|---|    |==|==|    |  |\\n//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n//  _______  Harvest.art v3 (Auctions) _________\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"solady/src/auth/Ownable.sol\\\";\\nimport \\\"./IBidTicket.sol\\\";\\n\\nenum Status {\\n    Active,\\n    Claimed,\\n    Refunded,\\n    Abandoned,\\n    Withdrawn\\n}\\n\\nstruct Auction {\\n    uint8 auctionType;\\n    address tokenAddress;\\n    uint64 endTime;\\n    uint8 tokenCount;\\n    Status status;\\n    address highestBidder;\\n    uint256 highestBid;\\n    mapping(uint256 => uint256) tokenIds;\\n    mapping(uint256 => uint256) amounts;\\n}\\n\\ncontract Auctions is Ownable {\\n    uint8 private constant AUCTION_TYPE_ERC721 = 0;\\n    uint8 private constant AUCTION_TYPE_ERC1155 = 1;\\n\\n    IBidTicket public bidTicket;\\n\\n    address public theBarn;\\n    uint256 public bidTicketTokenId = 1;\\n    uint256 public bidTicketCostStart = 5;\\n    uint256 public bidTicketCostBid = 1;\\n    uint256 public maxTokens = 10;\\n    uint256 public nextAuctionId = 1;\\n    uint256 public minStartingBid = 0.05 ether;\\n    uint256 public minBidIncrement = 0.01 ether;\\n    uint256 public auctionDuration = 7 days;\\n    uint256 public settlementDuration = 7 days;\\n\\n    uint256 public constant ABANDONMENT_FEE_PERCENT = 20;\\n\\n    mapping(uint256 => Auction) public auctions;\\n    mapping(address => mapping(uint256 => bool)) public auctionTokensERC721;\\n    mapping(address => mapping(uint256 => uint256)) public auctionTokensERC1155;\\n\\n    error AuctionAbandoned();\\n    error AuctionActive();\\n    error AuctionClaimed();\\n    error AuctionEnded();\\n    error AuctionIsApproved();\\n    error AuctionNotClaimed();\\n    error AuctionNotEnded();\\n    error AuctionRefunded();\\n    error AuctionWithdrawn();\\n    error BidTooLow();\\n    error InvalidLengthOfAmounts();\\n    error InvalidLengthOfTokenIds();\\n    error MaxTokensPerTxReached();\\n    error NotEnoughTokensInSupply();\\n    error NotHighestBidder();\\n    error SettlementPeriodNotExpired();\\n    error SettlementPeriodEnded();\\n    error StartPriceTooLow();\\n    error TokenAlreadyInAuction();\\n    error TokenNotOwned();\\n    error TransferFailed();\\n\\n    event Abandoned(uint256 indexed auctionId, address indexed bidder, uint256 indexed fee);\\n    event AuctionStarted(address indexed bidder, address indexed tokenAddress, uint256[] indexed tokenIds);\\n    event Claimed(uint256 indexed auctionId, address indexed winner);\\n    event NewBid(uint256 indexed auctionId, address indexed bidder, uint256 indexed value);\\n    event Refunded(uint256 indexed auctionId, address indexed bidder, uint256 indexed value);\\n    event Withdrawn(uint256 indexed auctionId, address indexed bidder, uint256 indexed value);\\n\\n    constructor(address theBarn_, address bidTicket_) {\\n        _initializeOwner(msg.sender);\\n        theBarn = theBarn_;\\n        bidTicket = IBidTicket(bidTicket_);\\n    }\\n\\n    /**\\n     *\\n     * startAuction - Starts an auction for a given token\\n     *\\n     * @param tokenAddress - The address of the token contract\\n     * @param tokenIds - The token ids to auction\\n     *\\n     */\\n\\n    function startAuctionERC721(address tokenAddress, uint256[] calldata tokenIds) external payable {\\n        if (msg.value < minStartingBid) {\\n            revert StartPriceTooLow();\\n        }\\n\\n        bidTicket.burn(msg.sender, bidTicketTokenId, bidTicketCostStart);\\n\\n        _validateAuctionTokensERC721(tokenAddress, tokenIds);\\n\\n        Auction storage auction = auctions[nextAuctionId];\\n\\n        auction.auctionType = AUCTION_TYPE_ERC721;\\n        auction.tokenAddress = tokenAddress;\\n        auction.endTime = uint64(block.timestamp + auctionDuration);\\n        auction.highestBidder = msg.sender;\\n        auction.highestBid = msg.value;\\n        auction.tokenCount = uint8(tokenIds.length);\\n\\n        mapping(uint256 => uint256) storage tokenMap = auction.tokenIds;\\n\\n        for (uint256 i; i < tokenIds.length;) {\\n            tokenMap[i] = tokenIds[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        unchecked {\\n            ++nextAuctionId;\\n        }\\n\\n        emit AuctionStarted(msg.sender, tokenAddress, tokenIds);\\n    }\\n\\n    /**\\n     *\\n     * startAuction - Starts an auction for a given token\\n     *\\n     * @param tokenAddress - The address of the token contract\\n     * @param tokenIds - The token ids to auction\\n     * @param amounts - The amounts of each token to auction\\n     *\\n     */\\n\\n    function startAuctionERC1155(address tokenAddress, uint256[] calldata tokenIds, uint256[] calldata amounts)\\n        external\\n        payable\\n    {\\n        if (msg.value < minStartingBid) {\\n            revert StartPriceTooLow();\\n        }\\n\\n        bidTicket.burn(msg.sender, bidTicketTokenId, bidTicketCostStart);\\n\\n        _validateAuctionTokensERC1155(tokenAddress, tokenIds, amounts);\\n\\n        Auction storage auction = auctions[nextAuctionId];\\n\\n        auction.auctionType = AUCTION_TYPE_ERC1155;\\n        auction.tokenAddress = tokenAddress;\\n        auction.endTime = uint64(block.timestamp + auctionDuration);\\n        auction.highestBidder = msg.sender;\\n        auction.highestBid = msg.value;\\n        auction.tokenCount = uint8(tokenIds.length);\\n\\n        mapping(uint256 => uint256) storage tokenMap = auction.tokenIds;\\n        mapping(uint256 => uint256) storage amountMap = auction.amounts;\\n\\n        for (uint256 i; i < tokenIds.length;) {\\n            tokenMap[i] = tokenIds[i];\\n            amountMap[i] = amounts[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        unchecked {\\n            ++nextAuctionId;\\n        }\\n\\n        emit AuctionStarted(msg.sender, tokenAddress, tokenIds);\\n    }\\n\\n    /**\\n     * bid - Places a bid on an auction\\n     *\\n     * @param auctionId - The id of the auction to bid on\\n     *\\n     */\\n\\n    function bid(uint256 auctionId) external payable {\\n        Auction storage auction = auctions[auctionId];\\n\\n        if (block.timestamp > auction.endTime) {\\n            revert AuctionEnded();\\n        }\\n\\n        if (block.timestamp >= auction.endTime - 1 hours) {\\n            auction.endTime += 1 hours;\\n        }\\n\\n        if (msg.value < auction.highestBid + minBidIncrement) {\\n            revert BidTooLow();\\n        }\\n\\n        address prevHighestBidder = auction.highestBidder;\\n        uint256 prevHighestBid = auction.highestBid;\\n\\n        auction.highestBidder = msg.sender;\\n        auction.highestBid = msg.value;\\n\\n        bidTicket.burn(msg.sender, bidTicketTokenId, bidTicketCostBid);\\n\\n        if (prevHighestBidder != address(0)) {\\n            (bool success,) = payable(prevHighestBidder).call{value: prevHighestBid}(\\\"\\\");\\n            if (!success) revert TransferFailed();\\n        }\\n\\n        emit NewBid(auctionId, msg.sender, msg.value);\\n    }\\n\\n    /**\\n     * claim - Claims the tokens from an auction\\n     *\\n     * @param auctionId - The id of the auction to claim\\n     *\\n     */\\n\\n    function claim(uint256 auctionId) external {\\n        Auction storage auction = auctions[auctionId];\\n\\n        if (block.timestamp < auction.endTime) {\\n            revert AuctionNotEnded();\\n        }\\n\\n        if (msg.sender != auction.highestBidder) {\\n            revert NotHighestBidder();\\n        }\\n\\n        if (auction.status != Status.Active) {\\n            if (auction.status == Status.Refunded) {\\n                revert AuctionRefunded();\\n            } else if (auction.status == Status.Claimed) {\\n                revert AuctionClaimed();\\n            } else if (auction.status == Status.Abandoned) {\\n                revert AuctionAbandoned();\\n            }\\n        }\\n\\n        auction.status = Status.Claimed;\\n\\n        if (auction.auctionType == AUCTION_TYPE_ERC721) {\\n            _transferERC721s(auction);\\n        } else {\\n            _transferERC1155s(auction);\\n        }\\n\\n        emit Claimed(auctionId, msg.sender);\\n    }\\n\\n    /**\\n     * refund - Refunds are available during the settlement period if The Barn has not yet approved the collection\\n     *\\n     * @param auctionId - The id of the auction to refund\\n     *\\n     */\\n    function refund(uint256 auctionId) external {\\n        Auction storage auction = auctions[auctionId];\\n        uint256 highestBid = auction.highestBid;\\n        uint256 endTime = auction.endTime;\\n\\n        if (block.timestamp < endTime) {\\n            revert AuctionActive();\\n        }\\n\\n        if (block.timestamp > endTime + settlementDuration) {\\n            revert SettlementPeriodEnded();\\n        }\\n\\n        if (msg.sender != auction.highestBidder) {\\n            revert NotHighestBidder();\\n        }\\n\\n        if (auction.status != Status.Active) {\\n            if (auction.status == Status.Refunded) {\\n                revert AuctionRefunded();\\n            } else if (auction.status == Status.Claimed) {\\n                revert AuctionClaimed();\\n            } else if (auction.status == Status.Withdrawn) {\\n                revert AuctionWithdrawn();\\n            }\\n        }\\n\\n        if (auction.auctionType == AUCTION_TYPE_ERC721) {\\n            _checkAndResetERC721s(auction);\\n        } else {\\n            _checkAndResetERC1155s(auction);\\n        }\\n\\n        auction.status = Status.Refunded;\\n\\n        (bool success,) = payable(msg.sender).call{value: highestBid}(\\\"\\\");\\n        if (!success) revert TransferFailed();\\n\\n        emit Refunded(auctionId, msg.sender, highestBid);\\n    }\\n\\n    /**\\n     *\\n     * abandon - Mark unclaimed auctions as abandoned after the settlement period\\n     *\\n     * @param auctionId - The id of the auction to abandon\\n     *\\n     */\\n    function abandon(uint256 auctionId) external onlyOwner {\\n        Auction storage auction = auctions[auctionId];\\n        address highestBidder = auction.highestBidder;\\n        uint256 highestBid = auction.highestBid;\\n\\n        if (block.timestamp < auction.endTime + settlementDuration) {\\n            revert SettlementPeriodNotExpired();\\n        }\\n\\n        if (auction.status != Status.Active) {\\n            if (auction.status == Status.Abandoned) {\\n                revert AuctionAbandoned();\\n            } else if (auction.status == Status.Refunded) {\\n                revert AuctionRefunded();\\n            } else if (auction.status == Status.Claimed) {\\n                revert AuctionClaimed();\\n            }\\n        }\\n\\n        auction.status = Status.Abandoned;\\n\\n        if (auction.auctionType == AUCTION_TYPE_ERC721) {\\n            _resetERC721s(auction);\\n        } else {\\n            _resetERC1155s(auction);\\n        }\\n\\n        uint256 fee = highestBid * ABANDONMENT_FEE_PERCENT / 100;\\n\\n        (bool success,) = payable(highestBidder).call{value: highestBid - fee}(\\\"\\\");\\n        if (!success) revert TransferFailed();\\n\\n        (success,) = payable(msg.sender).call{value: fee}(\\\"\\\");\\n        if (!success) revert TransferFailed();\\n\\n        emit Abandoned(auctionId, highestBidder, fee);\\n    }\\n\\n    /**\\n     * withdraw - Withdraws the highest bid from claimed auctions\\n     *\\n     * @param auctionIds - The ids of the auctions to withdraw from\\n     *\\n     * @notice - Auctions can only be withdrawn after the settlement period has ended.\\n     *\\n     */\\n\\n    function withdraw(uint256[] calldata auctionIds) external onlyOwner {\\n        uint256 totalAmount;\\n\\n        for (uint256 i; i < auctionIds.length;) {\\n            Auction storage auction = auctions[auctionIds[i]];\\n\\n            if (auction.status != Status.Claimed) {\\n                revert AuctionNotClaimed();\\n            }\\n\\n            totalAmount += auction.highestBid;\\n            auction.status = Status.Withdrawn;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        (bool success,) = payable(msg.sender).call{value: totalAmount}(\\\"\\\");\\n        if (!success) revert TransferFailed();\\n    }\\n\\n    /**\\n     *\\n     * Getters & Setters\\n     *\\n     */\\n\\n    function getAuctionTokens(uint256 auctionId) external view returns (uint256[] memory, uint256[] memory) {\\n        Auction storage auction = auctions[auctionId];\\n\\n        uint256[] memory tokenIds = new uint256[](auction.tokenCount);\\n        uint256[] memory amounts = new uint256[](auction.tokenCount);\\n\\n        uint256 tokenCount = auction.tokenCount;\\n\\n        for (uint256 i; i < tokenCount;) {\\n            tokenIds[i] = auction.tokenIds[i];\\n            if (auction.auctionType == AUCTION_TYPE_ERC721) {\\n                amounts[i] = 1;\\n            } else {\\n                amounts[i] = auction.amounts[i];\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return (tokenIds, amounts);\\n    }\\n\\n    function setBarnAddress(address theBarn_) external onlyOwner {\\n        theBarn = theBarn_;\\n    }\\n\\n    function setBidTicketAddress(address bidTicket_) external onlyOwner {\\n        bidTicket = IBidTicket(bidTicket_);\\n    }\\n\\n    function setBidTicketTokenId(uint256 bidTicketTokenId_) external onlyOwner {\\n        bidTicketTokenId = bidTicketTokenId_;\\n    }\\n\\n    function setMaxTokens(uint256 maxTokens_) external onlyOwner {\\n        maxTokens = maxTokens_;\\n    }\\n\\n    function setMinStartingBid(uint256 minStartingBid_) external onlyOwner {\\n        minStartingBid = minStartingBid_;\\n    }\\n\\n    function setMinBidIncrement(uint256 minBidIncrement_) external onlyOwner {\\n        minBidIncrement = minBidIncrement_;\\n    }\\n\\n    function setAuctionDuration(uint256 auctionDuration_) external onlyOwner {\\n        auctionDuration = auctionDuration_;\\n    }\\n\\n    function setSettlementDuration(uint256 settlementDuration_) external onlyOwner {\\n        settlementDuration = settlementDuration_;\\n    }\\n\\n    /**\\n     *\\n     * Internal Functions\\n     *\\n     */\\n\\n    function _validateAuctionTokensERC721(address tokenAddress, uint256[] calldata tokenIds) internal {\\n        if (tokenIds.length == 0) {\\n            revert InvalidLengthOfTokenIds();\\n        }\\n\\n        IERC721 erc721Contract = IERC721(tokenAddress);\\n\\n        if (tokenIds.length > maxTokens) {\\n            revert MaxTokensPerTxReached();\\n        }\\n\\n        mapping(uint256 => bool) storage auctionTokens = auctionTokensERC721[tokenAddress];\\n\\n        for (uint256 i; i < tokenIds.length;) {\\n            uint256 tokenId = tokenIds[i];\\n\\n            if (auctionTokens[tokenId]) {\\n                revert TokenAlreadyInAuction();\\n            }\\n\\n            auctionTokens[tokenId] = true;\\n\\n            if (erc721Contract.ownerOf(tokenId) != theBarn) {\\n                revert TokenNotOwned();\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _validateAuctionTokensERC1155(\\n        address tokenAddress,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata amounts\\n    ) internal {\\n        if (tokenIds.length == 0) {\\n            revert InvalidLengthOfTokenIds();\\n        }\\n\\n        if (tokenIds.length != amounts.length) {\\n            revert InvalidLengthOfAmounts();\\n        }\\n\\n        IERC1155 erc1155Contract = IERC1155(tokenAddress);\\n        uint256 totalTokens;\\n        uint256 totalNeeded;\\n        uint256 balance;\\n        uint256 tokenId;\\n        uint256 amount;\\n\\n        mapping(uint256 => uint256) storage auctionTokens = auctionTokensERC1155[tokenAddress];\\n\\n        for (uint256 i; i < tokenIds.length;) {\\n            tokenId = tokenIds[i];\\n            amount = amounts[i];\\n\\n            totalTokens += amount;\\n            totalNeeded = auctionTokens[tokenId] + amount;\\n            balance = erc1155Contract.balanceOf(theBarn, tokenId);\\n\\n            if (totalNeeded > balance) {\\n                revert NotEnoughTokensInSupply();\\n            }\\n\\n            unchecked {\\n                auctionTokens[tokenId] += amount;\\n                ++i;\\n            }\\n        }\\n\\n        if (totalTokens > maxTokens) {\\n            revert MaxTokensPerTxReached();\\n        }\\n    }\\n\\n    function _transferERC721s(Auction storage auction) internal {\\n        address tokenAddress = auction.tokenAddress;\\n        uint256 tokenCount = auction.tokenCount;\\n        address highestBidder = auction.highestBidder;\\n        IERC721 erc721Contract = IERC721(tokenAddress);\\n\\n        mapping(uint256 => uint256) storage tokenMap = auction.tokenIds;\\n        mapping(uint256 => bool) storage auctionTokens = auctionTokensERC721[tokenAddress];\\n\\n        for (uint256 i; i < tokenCount;) {\\n            uint256 tokenId = tokenMap[i];\\n            auctionTokens[tokenId] = false;\\n            erc721Contract.transferFrom(theBarn, highestBidder, tokenId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _transferERC1155s(Auction storage auction) internal {\\n        address tokenAddress = auction.tokenAddress;\\n        IERC1155 erc1155Contract = IERC1155(tokenAddress);\\n        uint256 tokenCount = auction.tokenCount;\\n        uint256[] memory tokenIds = new uint256[](tokenCount);\\n        uint256[] memory amounts = new uint256[](tokenCount);\\n\\n        mapping(uint256 => uint256) storage tokenMap = auction.tokenIds;\\n        mapping(uint256 => uint256) storage amountMap = auction.amounts;\\n        mapping(uint256 => uint256) storage auctionTokens = auctionTokensERC1155[tokenAddress];\\n\\n        for (uint256 i; i < tokenCount;) {\\n            uint256 tokenId = tokenMap[i];\\n            uint256 amount = amountMap[i];\\n\\n            tokenIds[i] = tokenId;\\n            amounts[i] = amount;\\n            auctionTokens[tokenId] -= amount;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        erc1155Contract.safeBatchTransferFrom(theBarn, auction.highestBidder, tokenIds, amounts, \\\"\\\");\\n    }\\n\\n    function _resetERC721s(Auction storage auction) internal {\\n        address tokenAddress = auction.tokenAddress;\\n        uint256 tokenCount = auction.tokenCount;\\n\\n        mapping(uint256 => uint256) storage tokenMap = auction.tokenIds;\\n        mapping(uint256 => bool) storage auctionTokens = auctionTokensERC721[tokenAddress];\\n\\n        for (uint256 i; i < tokenCount;) {\\n            uint256 tokenId = tokenMap[i];\\n            auctionTokens[tokenId] = false;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _resetERC1155s(Auction storage auction) internal {\\n        address tokenAddress = auction.tokenAddress;\\n        uint256 tokenCount = auction.tokenCount;\\n        uint256[] memory tokenIds = new uint256[](tokenCount);\\n        uint256[] memory amounts = new uint256[](tokenCount);\\n\\n        mapping(uint256 => uint256) storage tokenMap = auction.tokenIds;\\n        mapping(uint256 => uint256) storage amountMap = auction.amounts;\\n        mapping(uint256 => uint256) storage auctionTokens = auctionTokensERC1155[tokenAddress];\\n\\n        for (uint256 i; i < tokenCount;) {\\n            uint256 tokenId = tokenMap[i];\\n            uint256 amount = amountMap[i];\\n\\n            tokenIds[i] = tokenId;\\n            amounts[i] = amount;\\n            auctionTokens[tokenId] -= amount;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _checkAndResetERC721s(Auction storage auction) internal {\\n        address tokenAddress = auction.tokenAddress;\\n        uint256 tokenCount = auction.tokenCount;\\n\\n        mapping(uint256 => uint256) storage tokenMap = auction.tokenIds;\\n        mapping(uint256 => bool) storage auctionTokens = auctionTokensERC721[tokenAddress];\\n\\n        bool notRefundable = IERC721(tokenAddress).isApprovedForAll(theBarn, address(this));\\n\\n        for (uint256 i; i < tokenCount;) {\\n            uint256 tokenId = tokenMap[i];\\n            auctionTokens[tokenId] = false;\\n\\n            notRefundable = notRefundable && (IERC721(tokenAddress).ownerOf(tokenId) == theBarn);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (notRefundable) {\\n            revert AuctionIsApproved();\\n        }\\n    }\\n\\n    function _checkAndResetERC1155s(Auction storage auction) internal {\\n        address tokenAddress = auction.tokenAddress;\\n        uint256 tokenCount = auction.tokenCount;\\n        uint256[] memory tokenIds = new uint256[](tokenCount);\\n        uint256[] memory amounts = new uint256[](tokenCount);\\n\\n        mapping(uint256 => uint256) storage tokenMap = auction.tokenIds;\\n        mapping(uint256 => uint256) storage amountMap = auction.amounts;\\n        mapping(uint256 => uint256) storage auctionTokens = auctionTokensERC1155[tokenAddress];\\n\\n        bool notRefundable = IERC1155(tokenAddress).isApprovedForAll(theBarn, address(this));\\n\\n        for (uint256 i; i < tokenCount;) {\\n            uint256 tokenId = tokenMap[i];\\n            uint256 amount = amountMap[i];\\n\\n            tokenIds[i] = tokenId;\\n            amounts[i] = amount;\\n            auctionTokens[tokenId] -= amount;\\n\\n            notRefundable = notRefundable && (IERC1155(tokenAddress).balanceOf(theBarn, tokenId) >= amount);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (notRefundable) {\\n            revert AuctionIsApproved();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IBidTicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"ERC1155P/contracts/IERC1155P.sol\\\";\\n\\ninterface IBidTicket is IERC1155P {\\n    function setURI(uint256 tokenId, string calldata tokenURI) external;\\n\\n    function mint(address to, uint256 id, uint256 amount) external;\\n    function mintBatch(address to, uint256[] calldata ids, uint256[] calldata amounts) external;\\n\\n    function burn(address from, uint256 id, uint256 amount) external;\\n    function burnBatch(address from, uint256[] calldata ids, uint256[] calldata amounts) external;\\n\\n    function setHarvestContract(address harvestContract_) external;\\n    function setAuctionsContract(address auctionsContract_) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/ERC1155P/contracts/IERC1155P.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721P Contracts v1.1\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155P {\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Arrays cannot be different lengths.\\n     */\\n    error ArrayLengthMismatch();\\n\\n    /**\\n     * Cannot burn from the zero address.\\n     */\\n    error BurnFromZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The quantity of tokens minted must be more than zero.\\n     */\\n    error MintZeroQuantity();\\n\\n    /**\\n     * The quantity of tokens being burned is greater than account balance.\\n     */\\n    error BurnExceedsBalance();\\n\\n    /**\\n     * The quantity of tokens being transferred is greater than account balance.\\n     */\\n    error TransferExceedsBalance();\\n\\n    /**\\n     * The resulting token balance exceeds the maximum storable by ERC1155P\\n     */\\n    error ExceedsMaximumBalance();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the\\n     * ERC1155Receiver interface.\\n     */\\n    error TransferToNonERC1155ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * Exceeds max token ID\\n     */\\n    error ExceedsMaximumTokenId();\\n    \\n    // =============================================================\\n    //                            IERC165\\n    // =============================================================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"ERC1155P/=lib/ERC1155P/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solady/=lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"theBarn_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bidTicket_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AuctionAbandoned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionIsApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionNotClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionNotEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionRefunded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionWithdrawn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BidTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLengthOfAmounts\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLengthOfTokenIds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxTokensPerTxReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughTokensInSupply\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotHighestBidder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SettlementPeriodEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SettlementPeriodNotExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StartPriceTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAlreadyInAuction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotOwned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Abandoned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"AuctionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ABANDONMENT_FEE_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"abandon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionTokensERC1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctionTokensERC721\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"auctionType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"tokenCount\",\"type\":\"uint8\"},{\"internalType\":\"enum Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"highestBid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bidTicket\",\"outputs\":[{\"internalType\":\"contract IBidTicket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bidTicketCostBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bidTicketCostStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bidTicketTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getAuctionTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBidIncrement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStartingBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextAuctionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionDuration_\",\"type\":\"uint256\"}],\"name\":\"setAuctionDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"theBarn_\",\"type\":\"address\"}],\"name\":\"setBarnAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bidTicket_\",\"type\":\"address\"}],\"name\":\"setBidTicketAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bidTicketTokenId_\",\"type\":\"uint256\"}],\"name\":\"setBidTicketTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTokens_\",\"type\":\"uint256\"}],\"name\":\"setMaxTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minBidIncrement_\",\"type\":\"uint256\"}],\"name\":\"setMinBidIncrement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minStartingBid_\",\"type\":\"uint256\"}],\"name\":\"setMinStartingBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"settlementDuration_\",\"type\":\"uint256\"}],\"name\":\"setSettlementDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"startAuctionERC1155\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"startAuctionERC721\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"theBarn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"auctionIds\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Auctions", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000996e1d4ce3e1e558889832832004b2466153adbe00000000000000000000000062613aa9594d0116b5ca23acd37dddac90c67e5c", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}