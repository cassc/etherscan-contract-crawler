{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/CSetter.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./CStorage.sol\\\";\\r\\nimport \\\"./PoolToken.sol\\\";\\r\\nimport \\\"./interfaces/IFactory.sol\\\";\\r\\nimport \\\"./interfaces/ISimpleUniswapOracle.sol\\\";\\r\\n\\r\\ncontract CSetter is PoolToken, CStorage {\\r\\n\\r\\n\\tuint public constant SAFETY_MARGIN_SQRT_MIN = 1.00e18; //safetyMargin: 100%\\r\\n\\tuint public constant SAFETY_MARGIN_SQRT_MAX = 1.58113884e18; //safetyMargin: 250%\\r\\n\\tuint public constant LIQUIDATION_INCENTIVE_MIN = 1.00e18; //100%\\r\\n\\tuint public constant LIQUIDATION_INCENTIVE_MAX = 1.05e18; //105%\\r\\n\\r\\n\\tevent NewSafetyMargin(uint newSafetyMarginSqrt);\\r\\n\\tevent NewLiquidationIncentive(uint newLiquidationIncentive);\\r\\n\\t\\r\\n\\t// called once by the factory at the time of deployment\\r\\n\\tfunction _initialize (\\r\\n\\t\\tstring calldata _name,\\r\\n\\t\\tstring calldata _symbol,\\r\\n\\t\\taddress _underlying, \\r\\n\\t\\taddress _borrowable0, \\r\\n\\t\\taddress _borrowable1\\r\\n\\t) external {\\r\\n\\t\\trequire(msg.sender == factory, \\\"Impermax: UNAUTHORIZED\\\"); // sufficient check\\r\\n\\t\\t_setName(_name, _symbol);\\r\\n\\t\\tunderlying = _underlying;\\r\\n\\t\\tborrowable0 = _borrowable0;\\r\\n\\t\\tborrowable1 = _borrowable1;\\r\\n\\t\\tsimpleUniswapOracle = IFactory(factory).simpleUniswapOracle();\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setSafetyMarginSqrt(uint newSafetyMarginSqrt) external nonReentrant {\\r\\n\\t\\t_checkSetting(newSafetyMarginSqrt, SAFETY_MARGIN_SQRT_MIN, SAFETY_MARGIN_SQRT_MAX);\\r\\n\\t\\tsafetyMarginSqrt = newSafetyMarginSqrt;\\r\\n\\t\\temit NewSafetyMargin(newSafetyMarginSqrt);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setLiquidationIncentive(uint newLiquidationIncentive) external nonReentrant {\\r\\n\\t\\t_checkSetting(newLiquidationIncentive, LIQUIDATION_INCENTIVE_MIN, LIQUIDATION_INCENTIVE_MAX);\\r\\n\\t\\tliquidationIncentive = newLiquidationIncentive;\\r\\n\\t\\temit NewLiquidationIncentive(newLiquidationIncentive);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _checkSetting(uint parameter, uint min, uint max) internal view {\\r\\n\\t\\t_checkAdmin();\\r\\n\\t\\trequire(parameter >= min, \\\"Impermax: INVALID_SETTING\\\");\\r\\n\\t\\trequire(parameter <= max, \\\"Impermax: INVALID_SETTING\\\");\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _checkAdmin() internal view {\\r\\n\\t\\trequire(msg.sender == IFactory(factory).admin(), \\\"Impermax: UNAUTHORIZED\\\");\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/CStorage.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\n\\r\\ncontract CStorage {\\r\\n\\taddress public borrowable0;\\r\\n\\taddress public borrowable1;\\r\\n\\taddress public simpleUniswapOracle;\\r\\n\\tuint public safetyMarginSqrt = 1.58113883e18; //safetyMargin: 250%\\r\\n\\tuint public liquidationIncentive = 1.04e18; //4%\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/Collateral.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./PoolToken.sol\\\";\\r\\nimport \\\"./CStorage.sol\\\";\\r\\nimport \\\"./CSetter.sol\\\";\\r\\nimport \\\"./interfaces/IBorrowable.sol\\\";\\r\\nimport \\\"./interfaces/ICollateral.sol\\\";\\r\\nimport \\\"./interfaces/IFactory.sol\\\";\\r\\nimport \\\"./interfaces/ISimpleUniswapOracle.sol\\\";\\r\\nimport \\\"./interfaces/IImpermaxCallee.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./libraries/UQ112x112.sol\\\";\\r\\nimport \\\"./libraries/Math.sol\\\";\\r\\n\\r\\ncontract Collateral is ICollateral, PoolToken, CStorage, CSetter {\\r\\n    using UQ112x112 for uint224;\\r\\n\\t\\r\\n\\tconstructor() public {}\\r\\n\\t\\r\\n\\t/*** Collateralization Model ***/\\r\\n\\r\\n\\t// returns the prices of borrowable0's and borrowable1's underlyings with collateral's underlying as denom\\r\\n\\tfunction getPrices() public returns (uint price0, uint price1) {\\r\\n\\t\\t(uint224 twapPrice112x112,) = ISimpleUniswapOracle(simpleUniswapOracle).getResult(underlying);\\r\\n\\t\\t(uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(underlying).getReserves();\\r\\n\\t\\tuint256 collateralTotalSupply = IUniswapV2Pair(underlying).totalSupply();\\r\\n\\t\\t\\r\\n\\t\\tuint224 currentPrice112x112 = UQ112x112.encode(reserve1).uqdiv(reserve0);\\r\\n\\t\\tuint256 adjustmentSquared = uint256(twapPrice112x112).mul(2**32).div(currentPrice112x112);\\r\\n\\t\\tuint256 adjustment = Math.sqrt(adjustmentSquared.mul(2**32));\\r\\n\\r\\n\\t\\tuint256 currentBorrowable0Price = uint256(collateralTotalSupply).mul(1e18).div(reserve0*2);\\r\\n\\t\\tuint256 currentBorrowable1Price = uint256(collateralTotalSupply).mul(1e18).div(reserve1*2);\\r\\n\\t\\t\\r\\n\\t\\tprice0 = currentBorrowable0Price.mul(adjustment).div(2**32);\\r\\n\\t\\tprice1 = currentBorrowable1Price.mul(2**32).div(adjustment);\\r\\n\\t\\t\\r\\n\\t\\t/*\\r\\n\\t\\t * Price calculation errors may happen in some edge pairs where\\r\\n\\t\\t * reserve0 / reserve1 is close to 2**112 or 1/2**112\\r\\n\\t\\t * We're going to prevent users from using pairs at risk from the UI\\r\\n\\t\\t */\\r\\n\\t\\trequire(price0 > 100, \\\"Impermax: PRICE_CALCULATION_ERROR\\\");\\r\\n\\t\\trequire(price1 > 100, \\\"Impermax: PRICE_CALCULATION_ERROR\\\");\\r\\n\\t}\\r\\n\\t\\r\\n\\t// returns liquidity in  collateral's underlying\\r\\n\\tfunction _calculateLiquidity(uint amountCollateral, uint amount0, uint amount1) internal returns (uint liquidity, uint shortfall) {\\r\\n\\t\\tuint _safetyMarginSqrt = safetyMarginSqrt;\\r\\n\\t\\t(uint price0, uint price1) = getPrices();\\r\\n\\t\\t\\r\\n\\t\\tuint a = amount0.mul(price0).div(1e18);\\r\\n\\t\\tuint b = amount1.mul(price1).div(1e18);\\r\\n\\t\\tif(a < b) (a, b) = (b, a);\\r\\n\\t\\ta = a.mul(_safetyMarginSqrt).div(1e18);\\r\\n\\t\\tb = b.mul(1e18).div(_safetyMarginSqrt);\\r\\n\\t\\tuint collateralNeeded = a.add(b).mul(liquidationIncentive).div(1e18);\\t\\t\\r\\n\\r\\n\\t\\tif(amountCollateral >= collateralNeeded){\\r\\n\\t\\t\\treturn (amountCollateral - collateralNeeded, 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn (0, collateralNeeded - amountCollateral);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/*** ERC20 ***/\\r\\n\\t\\r\\n\\tfunction _transfer(address from, address to, uint value) internal {\\r\\n\\t\\trequire(tokensUnlocked(from, value), \\\"Impermax: INSUFFICIENT_LIQUIDITY\\\");\\r\\n\\t\\tsuper._transfer(from, to, value);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction tokensUnlocked(address from, uint value) public returns (bool) {\\r\\n\\t\\tuint _balance = balanceOf[from];\\r\\n\\t\\tif (value > _balance) return false;\\r\\n\\t\\tuint finalBalance = _balance - value;\\r\\n\\t\\tuint amountCollateral = finalBalance.mul(exchangeRate()).div(1e18);\\r\\n\\t\\tuint amount0 = IBorrowable(borrowable0).borrowBalance(from);\\r\\n\\t\\tuint amount1 = IBorrowable(borrowable1).borrowBalance(from);\\r\\n\\t\\t(, uint shortfall) = _calculateLiquidity(amountCollateral, amount0, amount1);\\r\\n\\t\\treturn shortfall == 0;\\r\\n\\t}\\r\\n\\t\\r\\n\\t/*** Collateral ***/\\r\\n\\t\\r\\n\\tfunction accountLiquidityAmounts(address borrower, uint amount0, uint amount1) public returns (uint liquidity, uint shortfall) {\\r\\n\\t\\tif (amount0 == uint(-1)) amount0 = IBorrowable(borrowable0).borrowBalance(borrower);\\r\\n\\t\\tif (amount1 == uint(-1)) amount1 = IBorrowable(borrowable1).borrowBalance(borrower);\\r\\n\\t\\tuint amountCollateral = balanceOf[borrower].mul(exchangeRate()).div(1e18);\\r\\n\\t\\treturn _calculateLiquidity(amountCollateral, amount0, amount1);\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction accountLiquidity(address borrower) public returns (uint liquidity, uint shortfall) {\\r\\n\\t\\treturn accountLiquidityAmounts(borrower, uint(-1), uint(-1));\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction canBorrow(address borrower, address borrowable, uint accountBorrows) public returns (bool) {\\r\\n\\t\\taddress _borrowable0 = borrowable0;\\r\\n\\t\\taddress _borrowable1 = borrowable1;\\r\\n\\t\\trequire(borrowable == _borrowable0 || borrowable == _borrowable1, \\\"Impermax: INVALID_BORROWABLE\\\" );\\r\\n\\t\\tuint amount0 = borrowable == _borrowable0 ? accountBorrows : uint(-1);\\r\\n\\t\\tuint amount1 = borrowable == _borrowable1 ? accountBorrows : uint(-1);\\r\\n\\t\\t(, uint shortfall) = accountLiquidityAmounts(borrower, amount0, amount1);\\r\\n\\t\\treturn shortfall == 0;\\r\\n\\t}\\r\\n\\t\\r\\n\\t// this function must be called from borrowable0 or borrowable1\\r\\n\\tfunction seize(address liquidator, address borrower, uint repayAmount) external returns (uint seizeTokens) {\\r\\n\\t\\trequire(msg.sender == borrowable0 || msg.sender == borrowable1, \\\"Impermax: UNAUTHORIZED\\\");\\r\\n\\t\\t\\r\\n\\t\\t(, uint shortfall) = accountLiquidity(borrower);\\r\\n\\t\\trequire(shortfall > 0, \\\"Impermax: INSUFFICIENT_SHORTFALL\\\");\\r\\n\\t\\t\\r\\n\\t\\tuint price;\\r\\n\\t\\tif (msg.sender == borrowable0) (price, ) = getPrices();\\r\\n\\t\\telse  (, price) = getPrices();\\r\\n\\t\\t\\r\\n\\t\\tseizeTokens = repayAmount.mul(liquidationIncentive).div(1e18).mul(price).div( exchangeRate() );\\r\\n\\t\\t\\r\\n\\t\\tbalanceOf[borrower] = balanceOf[borrower].sub(seizeTokens, \\\"Impermax: LIQUIDATING_TOO_MUCH\\\");\\r\\n\\t\\tbalanceOf[liquidator] = balanceOf[liquidator].add(seizeTokens);\\r\\n\\t\\temit Transfer(borrower, liquidator, seizeTokens);\\r\\n\\t}\\r\\n\\r\\n\\t// this low-level function should be called from another contract\\r\\n\\tfunction flashRedeem(address redeemer, uint redeemAmount, bytes calldata data) external nonReentrant update {\\r\\n\\t\\trequire(redeemAmount <= totalBalance, \\\"Impermax: INSUFFICIENT_CASH\\\");\\r\\n\\t\\t\\r\\n\\t\\t// optimistically transfer funds\\r\\n\\t\\t_safeTransfer(redeemer, redeemAmount);\\r\\n\\t\\tif (data.length > 0) IImpermaxCallee(redeemer).impermaxRedeem(msg.sender, redeemAmount, data);\\r\\n\\t\\t\\r\\n\\t\\tuint redeemTokens = balanceOf[address(this)];\\r\\n\\t\\tuint declaredRedeemTokens = redeemAmount.mul(1e18).div( exchangeRate() ).add(1); // rounded up\\r\\n\\t\\trequire(redeemTokens >= declaredRedeemTokens, \\\"Impermax: INSUFFICIENT_REDEEM_TOKENS\\\");\\r\\n\\t\\t\\r\\n\\t\\t_burn(address(this), redeemTokens);\\r\\n\\t\\temit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/ImpermaxERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\n\\r\\n// This contract is basically UniswapV2ERC20 with small modifications\\r\\n// src: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol\\r\\n\\r\\ncontract ImpermaxERC20 {\\r\\n\\tusing SafeMath for uint;\\r\\n\\t\\r\\n\\tstring public name;\\r\\n\\tstring public symbol;\\r\\n\\tuint8 public decimals = 18;\\r\\n\\tuint public totalSupply;\\r\\n\\tmapping(address => uint) public balanceOf;\\r\\n\\tmapping(address => mapping(address => uint)) public allowance;\\r\\n\\t\\r\\n\\tbytes32 public DOMAIN_SEPARATOR;\\r\\n\\tmapping(address => uint) public nonces;\\r\\n\\t\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\r\\n\\r\\n\\tconstructor() public {}\\t\\r\\n\\t\\r\\n\\tfunction _setName(string memory _name, string memory _symbol) internal {\\r\\n\\t\\tname = _name;\\r\\n\\t\\tsymbol = _symbol;\\r\\n\\t\\tuint chainId;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tchainId := chainid\\r\\n\\t\\t}\\r\\n\\t\\tDOMAIN_SEPARATOR = keccak256(\\r\\n\\t\\t\\tabi.encode(\\r\\n\\t\\t\\t\\tkeccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\r\\n\\t\\t\\t\\tkeccak256(bytes(_name)),\\r\\n\\t\\t\\t\\tkeccak256(bytes(\\\"1\\\")),\\r\\n\\t\\t\\t\\tchainId,\\r\\n\\t\\t\\t\\taddress(this)\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _mint(address to, uint value) internal {\\r\\n\\t\\ttotalSupply = totalSupply.add(value);\\r\\n\\t\\tbalanceOf[to] = balanceOf[to].add(value);\\r\\n\\t\\temit Transfer(address(0), to, value);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _burn(address from, uint value) internal {\\r\\n\\t\\tbalanceOf[from] = balanceOf[from].sub(value);\\r\\n\\t\\ttotalSupply = totalSupply.sub(value);\\r\\n\\t\\temit Transfer(from, address(0), value);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _approve(address owner, address spender, uint value) private {\\r\\n\\t\\tallowance[owner][spender] = value;\\r\\n\\t\\temit Approval(owner, spender, value);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _transfer(address from, address to, uint value) internal {\\r\\n\\t\\tbalanceOf[from] = balanceOf[from].sub(value, \\\"Impermax: TRANSFER_TOO_HIGH\\\");\\r\\n\\t\\tbalanceOf[to] = balanceOf[to].add(value);\\r\\n\\t\\temit Transfer(from, to, value);\\r\\n\\t}\\r\\n\\r\\n\\tfunction approve(address spender, uint value) external returns (bool) {\\r\\n\\t\\t_approve(msg.sender, spender, value);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\tfunction transfer(address to, uint value) external returns (bool) {\\r\\n\\t\\t_transfer(msg.sender, to, value);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool) {\\r\\n\\t\\tif (allowance[from][msg.sender] != uint(-1)) {\\r\\n\\t\\t\\tallowance[from][msg.sender] = allowance[from][msg.sender].sub(value, \\\"Impermax: TRANSFER_NOT_ALLOWED\\\");\\r\\n\\t\\t}\\r\\n\\t\\t_transfer(from, to, value);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\t\\r\\n\\tfunction _checkSignature(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s, bytes32 typehash) internal {\\r\\n\\t\\trequire(deadline >= block.timestamp, \\\"Impermax: EXPIRED\\\");\\r\\n\\t\\tbytes32 digest = keccak256(\\r\\n\\t\\t\\tabi.encodePacked(\\r\\n\\t\\t\\t\\t'\\\\x19\\\\x01',\\r\\n\\t\\t\\t\\tDOMAIN_SEPARATOR,\\r\\n\\t\\t\\t\\tkeccak256(abi.encode(typehash, owner, spender, value, nonces[owner]++, deadline))\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t\\taddress recoveredAddress = ecrecover(digest, v, r, s);\\r\\n\\t\\trequire(recoveredAddress != address(0) && recoveredAddress == owner, \\\"Impermax: INVALID_SIGNATURE\\\");\\t\\r\\n\\t}\\r\\n\\r\\n\\t// keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\r\\n\\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\r\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\r\\n\\t\\t_checkSignature(owner, spender, value, deadline, v, r, s, PERMIT_TYPEHASH);\\r\\n\\t\\t_approve(owner, spender, value);\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/PoolToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\r\\n\\r\\nimport \\\"./ImpermaxERC20.sol\\\";\\r\\nimport \\\"./interfaces/IERC20.sol\\\";\\r\\nimport \\\"./interfaces/IPoolToken.sol\\\";\\r\\nimport \\\"./libraries/SafeMath.sol\\\";\\r\\n\\r\\ncontract PoolToken is IPoolToken, ImpermaxERC20 {\\r\\n   \\tuint internal constant initialExchangeRate = 1e18;\\r\\n\\taddress public underlying;\\r\\n\\taddress public factory;\\r\\n\\tuint public totalBalance;\\r\\n\\tuint public constant MINIMUM_LIQUIDITY = 1000;\\r\\n\\t\\r\\n\\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\\r\\n\\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\\r\\n\\tevent Sync(uint totalBalance);\\r\\n\\t\\r\\n\\t/*** Initialize ***/\\r\\n\\t\\r\\n\\t// called once by the factory\\r\\n\\tfunction _setFactory() external {\\r\\n\\t\\trequire(factory == address(0), \\\"Impermax: FACTORY_ALREADY_SET\\\");\\r\\n\\t\\tfactory = msg.sender;\\r\\n\\t}\\r\\n\\t\\r\\n\\t/*** PoolToken ***/\\r\\n\\t\\r\\n\\tfunction _update() internal {\\r\\n\\t\\ttotalBalance = IERC20(underlying).balanceOf(address(this));\\r\\n\\t\\temit Sync(totalBalance);\\r\\n\\t}\\r\\n\\r\\n\\tfunction exchangeRate() public returns (uint) \\r\\n\\t{\\r\\n\\t\\tuint _totalSupply = totalSupply; // gas savings\\r\\n\\t\\tuint _totalBalance = totalBalance; // gas savings\\r\\n\\t\\tif (_totalSupply == 0 || _totalBalance == 0) return initialExchangeRate;\\r\\n\\t\\treturn _totalBalance.mul(1e18).div(_totalSupply);\\r\\n\\t}\\r\\n\\t\\r\\n\\t// this low-level function should be called from another contract\\r\\n\\tfunction mint(address minter) external nonReentrant update returns (uint mintTokens) {\\r\\n\\t\\tuint balance = IERC20(underlying).balanceOf(address(this));\\r\\n\\t\\tuint mintAmount = balance.sub(totalBalance);\\r\\n\\t\\tmintTokens = mintAmount.mul(1e18).div(exchangeRate());\\r\\n\\r\\n\\t\\tif(totalSupply == 0) {\\r\\n\\t\\t\\t// permanently lock the first MINIMUM_LIQUIDITY tokens\\r\\n\\t\\t\\tmintTokens = mintTokens.sub(MINIMUM_LIQUIDITY);\\r\\n\\t\\t\\t_mint(address(0), MINIMUM_LIQUIDITY);\\r\\n\\t\\t}\\r\\n\\t\\trequire(mintTokens > 0, \\\"Impermax: MINT_AMOUNT_ZERO\\\");\\r\\n\\t\\t_mint(minter, mintTokens);\\r\\n\\t\\temit Mint(msg.sender, minter, mintAmount, mintTokens);\\r\\n\\t}\\r\\n\\r\\n\\t// this low-level function should be called from another contract\\r\\n\\tfunction redeem(address redeemer) external nonReentrant update returns (uint redeemAmount) {\\r\\n\\t\\tuint redeemTokens = balanceOf[address(this)];\\r\\n\\t\\tredeemAmount = redeemTokens.mul(exchangeRate()).div(1e18);\\r\\n\\r\\n\\t\\trequire(redeemAmount > 0, \\\"Impermax: REDEEM_AMOUNT_ZERO\\\");\\r\\n\\t\\trequire(redeemAmount <= totalBalance, \\\"Impermax: INSUFFICIENT_CASH\\\");\\r\\n\\t\\t_burn(address(this), redeemTokens);\\r\\n\\t\\t_safeTransfer(redeemer, redeemAmount);\\r\\n\\t\\temit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\\t\\t\\r\\n\\t}\\r\\n\\r\\n\\t// force real balance to match totalBalance\\r\\n\\tfunction skim(address to) external nonReentrant {\\r\\n\\t\\t_safeTransfer(to, IERC20(underlying).balanceOf(address(this)).sub(totalBalance));\\r\\n\\t}\\r\\n\\r\\n\\t// force totalBalance to match real balance\\r\\n\\tfunction sync() external nonReentrant update {}\\r\\n\\t\\r\\n\\t/*** Utilities ***/\\r\\n\\t\\r\\n\\t// same safe transfer function used by UniSwapV2 (with fixed underlying)\\r\\n\\tbytes4 private constant SELECTOR = bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\r\\n\\tfunction _safeTransfer(address to, uint amount) internal {\\r\\n\\t\\t(bool success, bytes memory data) = underlying.call(abi.encodeWithSelector(SELECTOR, to, amount));\\r\\n\\t\\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \\\"Impermax: TRANSFER_FAILED\\\");\\r\\n\\t}\\r\\n\\t\\r\\n\\t// prevents a contract from calling itself, directly or indirectly.\\r\\n\\tbool internal _notEntered = true;\\r\\n\\tmodifier nonReentrant() {\\r\\n\\t\\trequire(_notEntered, \\\"Impermax: REENTERED\\\");\\r\\n\\t\\t_notEntered = false;\\r\\n\\t\\t_;\\r\\n\\t\\t_notEntered = true;\\r\\n\\t}\\r\\n\\t\\r\\n\\t// update totalBalance with current balance\\r\\n\\tmodifier update() {\\r\\n\\t\\t_;\\r\\n\\t\\t_update();\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/interfaces/IBorrowable.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface IBorrowable {\\r\\n\\r\\n\\t/*** Impermax ERC20 ***/\\r\\n\\t\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\r\\n\\t\\r\\n\\tfunction name() external pure returns (string memory);\\r\\n\\tfunction symbol() external pure returns (string memory);\\r\\n\\tfunction decimals() external pure returns (uint8);\\r\\n\\tfunction totalSupply() external view returns (uint);\\r\\n\\tfunction balanceOf(address owner) external view returns (uint);\\r\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\r\\n\\tfunction approve(address spender, uint value) external returns (bool);\\r\\n\\tfunction transfer(address to, uint value) external returns (bool);\\r\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\t\\r\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\tfunction nonces(address owner) external view returns (uint);\\r\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\t\\r\\n\\t/*** Pool Token ***/\\r\\n\\t\\r\\n\\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\\r\\n\\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\\r\\n\\tevent Sync(uint totalBalance);\\r\\n\\t\\r\\n\\tfunction underlying() external view returns (address);\\r\\n\\tfunction factory() external view returns (address);\\r\\n\\tfunction totalBalance() external view returns (uint);\\r\\n\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n\\r\\n\\tfunction exchangeRate() external returns (uint);\\r\\n\\tfunction mint(address minter) external returns (uint mintTokens);\\r\\n\\tfunction redeem(address redeemer) external returns (uint redeemAmount);\\r\\n\\tfunction skim(address to) external;\\r\\n\\tfunction sync() external;\\r\\n\\t\\r\\n\\tfunction _setFactory() external;\\r\\n\\t\\r\\n\\t/*** Borrowable ***/\\r\\n\\r\\n\\tevent BorrowApproval(address indexed owner, address indexed spender, uint value);\\r\\n\\tevent Borrow(address indexed sender, address indexed borrower, address indexed receiver, uint borrowAmount, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\\r\\n\\tevent Liquidate(address indexed sender, address indexed borrower, address indexed liquidator, uint seizeTokens, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\\r\\n\\t\\r\\n\\tfunction BORROW_FEE() external pure returns (uint);\\r\\n\\tfunction collateral() external view returns (address);\\r\\n\\tfunction reserveFactor() external view returns (uint);\\r\\n\\tfunction exchangeRateLast() external view returns (uint);\\r\\n\\tfunction borrowIndex() external view returns (uint);\\r\\n\\tfunction totalBorrows() external view returns (uint);\\r\\n\\tfunction borrowAllowance(address owner, address spender) external view returns (uint);\\r\\n\\tfunction borrowBalance(address borrower) external view returns (uint);\\t\\r\\n\\tfunction borrowTracker() external view returns (address);\\r\\n\\t\\r\\n\\tfunction BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\tfunction borrowApprove(address spender, uint256 value) external returns (bool);\\r\\n\\tfunction borrowPermit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\tfunction borrow(address borrower, address receiver, uint borrowAmount, bytes calldata data) external;\\r\\n\\tfunction liquidate(address borrower, address liquidator) external returns (uint seizeTokens);\\r\\n\\tfunction trackBorrow(address borrower) external;\\r\\n\\t\\r\\n\\t/*** Borrowable Interest Rate Model ***/\\r\\n\\r\\n\\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\r\\n\\tevent CalculateKink(uint kinkRate);\\r\\n\\tevent CalculateBorrowRate(uint borrowRate);\\r\\n\\t\\r\\n\\tfunction KINK_BORROW_RATE_MAX() external pure returns (uint);\\r\\n\\tfunction KINK_BORROW_RATE_MIN() external pure returns (uint);\\r\\n\\tfunction KINK_MULTIPLIER() external pure returns (uint);\\r\\n\\tfunction borrowRate() external view returns (uint);\\r\\n\\tfunction kinkBorrowRate() external view returns (uint);\\r\\n\\tfunction kinkUtilizationRate() external view returns (uint);\\r\\n\\tfunction adjustSpeed() external view returns (uint);\\r\\n\\tfunction rateUpdateTimestamp() external view returns (uint32);\\r\\n\\tfunction accrualTimestamp() external view returns (uint32);\\r\\n\\t\\r\\n\\tfunction accrueInterest() external;\\r\\n\\t\\r\\n\\t/*** Borrowable Setter ***/\\r\\n\\r\\n\\tevent NewReserveFactor(uint newReserveFactor);\\r\\n\\tevent NewKinkUtilizationRate(uint newKinkUtilizationRate);\\r\\n\\tevent NewAdjustSpeed(uint newAdjustSpeed);\\r\\n\\tevent NewBorrowTracker(address newBorrowTracker);\\r\\n\\r\\n\\tfunction RESERVE_FACTOR_MAX() external pure returns (uint);\\r\\n\\tfunction KINK_UR_MIN() external pure returns (uint);\\r\\n\\tfunction KINK_UR_MAX() external pure returns (uint);\\r\\n\\tfunction ADJUST_SPEED_MIN() external pure returns (uint);\\r\\n\\tfunction ADJUST_SPEED_MAX() external pure returns (uint);\\r\\n\\t\\r\\n\\tfunction _initialize (\\r\\n\\t\\tstring calldata _name, \\r\\n\\t\\tstring calldata _symbol,\\r\\n\\t\\taddress _underlying, \\r\\n\\t\\taddress _collateral\\r\\n\\t) external;\\r\\n\\tfunction _setReserveFactor(uint newReserveFactor) external;\\r\\n\\tfunction _setKinkUtilizationRate(uint newKinkUtilizationRate) external;\\r\\n\\tfunction _setAdjustSpeed(uint newAdjustSpeed) external;\\r\\n\\tfunction _setBorrowTracker(address newBorrowTracker) external;\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/interfaces/ICollateral.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface ICollateral {\\r\\n\\r\\n\\t/*** Impermax ERC20 ***/\\r\\n\\t\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\r\\n\\t\\r\\n\\tfunction name() external pure returns (string memory);\\r\\n\\tfunction symbol() external pure returns (string memory);\\r\\n\\tfunction decimals() external pure returns (uint8);\\r\\n\\tfunction totalSupply() external view returns (uint);\\r\\n\\tfunction balanceOf(address owner) external view returns (uint);\\r\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\r\\n\\tfunction approve(address spender, uint value) external returns (bool);\\r\\n\\tfunction transfer(address to, uint value) external returns (bool);\\r\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\t\\r\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\tfunction nonces(address owner) external view returns (uint);\\r\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\t\\r\\n\\t/*** Pool Token ***/\\r\\n\\t\\r\\n\\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\\r\\n\\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\\r\\n\\tevent Sync(uint totalBalance);\\r\\n\\t\\r\\n\\tfunction underlying() external view returns (address);\\r\\n\\tfunction factory() external view returns (address);\\r\\n\\tfunction totalBalance() external view returns (uint);\\r\\n\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n\\r\\n\\tfunction exchangeRate() external returns (uint);\\r\\n\\tfunction mint(address minter) external returns (uint mintTokens);\\r\\n\\tfunction redeem(address redeemer) external returns (uint redeemAmount);\\r\\n\\tfunction skim(address to) external;\\r\\n\\tfunction sync() external;\\r\\n\\t\\r\\n\\tfunction _setFactory() external;\\r\\n\\t\\r\\n\\t/*** Collateral ***/\\r\\n\\t\\r\\n\\tfunction borrowable0() external view returns (address);\\r\\n\\tfunction borrowable1() external view returns (address);\\r\\n\\tfunction simpleUniswapOracle() external view returns (address);\\r\\n\\tfunction safetyMarginSqrt() external view returns (uint);\\r\\n\\tfunction liquidationIncentive() external view returns (uint);\\r\\n\\t\\r\\n\\tfunction getPrices() external returns (uint price0, uint price1);\\r\\n\\tfunction tokensUnlocked(address from, uint value) external returns (bool);\\r\\n\\tfunction accountLiquidityAmounts(address account, uint amount0, uint amount1) external returns (uint liquidity, uint shortfall);\\r\\n\\tfunction accountLiquidity(address account) external returns (uint liquidity, uint shortfall);\\r\\n\\tfunction canBorrow(address account, address borrowable, uint accountBorrows) external returns (bool);\\r\\n\\tfunction seize(address liquidator, address borrower, uint repayAmount) external returns (uint seizeTokens);\\r\\n\\tfunction flashRedeem(address redeemer, uint redeemAmount, bytes calldata data) external;\\r\\n\\t\\r\\n\\t/*** Collateral Setter ***/\\r\\n\\t\\r\\n\\tevent NewSafetyMargin(uint newSafetyMarginSqrt);\\r\\n\\tevent NewLiquidationIncentive(uint newLiquidationIncentive);\\r\\n\\r\\n\\tfunction SAFETY_MARGIN_SQRT_MIN() external pure returns (uint);\\r\\n\\tfunction SAFETY_MARGIN_SQRT_MAX() external pure returns (uint);\\r\\n\\tfunction LIQUIDATION_INCENTIVE_MIN() external pure returns (uint);\\r\\n\\tfunction LIQUIDATION_INCENTIVE_MAX() external pure returns (uint);\\r\\n\\t\\r\\n\\tfunction _initialize (\\r\\n\\t\\tstring calldata _name, \\r\\n\\t\\tstring calldata _symbol,\\r\\n\\t\\taddress _underlying, \\r\\n\\t\\taddress _borrowable0, \\r\\n\\t\\taddress _borrowable1\\r\\n\\t) external;\\r\\n\\tfunction _setSafetyMarginSqrt(uint newSafetyMarginSqrt) external;\\r\\n\\tfunction _setLiquidationIncentive(uint newLiquidationIncentive) external;\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/interfaces/IFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface IFactory {\\r\\n\\tevent LendingPoolInitialized(address indexed uniswapV2Pair, address indexed token0, address indexed token1,\\r\\n\\t\\taddress collateral, address borrowable0, address borrowable1, uint lendingPoolId);\\r\\n\\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\r\\n\\tevent NewAdmin(address oldAdmin, address newAdmin);\\r\\n\\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\\r\\n\\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\\r\\n\\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\\r\\n\\t\\r\\n\\tfunction admin() external view returns (address);\\r\\n\\tfunction pendingAdmin() external view returns (address);\\r\\n\\tfunction reservesAdmin() external view returns (address);\\r\\n\\tfunction reservesPendingAdmin() external view returns (address);\\r\\n\\tfunction reservesManager() external view returns (address);\\r\\n\\r\\n\\tfunction getLendingPool(address uniswapV2Pair) external view returns (\\r\\n\\t\\tbool initialized, \\r\\n\\t\\tuint24 lendingPoolId, \\r\\n\\t\\taddress collateral, \\r\\n\\t\\taddress borrowable0, \\r\\n\\t\\taddress borrowable1\\r\\n\\t);\\r\\n\\tfunction allLendingPools(uint) external view returns (address uniswapV2Pair);\\r\\n\\tfunction allLendingPoolsLength() external view returns (uint);\\r\\n\\t\\r\\n\\tfunction bDeployer() external view returns (address);\\r\\n\\tfunction cDeployer() external view returns (address);\\r\\n\\tfunction uniswapV2Factory() external view returns (address);\\r\\n\\tfunction simpleUniswapOracle() external view returns (address);\\r\\n\\r\\n\\tfunction createCollateral(address uniswapV2Pair) external returns (address collateral);\\r\\n\\tfunction createBorrowable0(address uniswapV2Pair) external returns (address borrowable0);\\r\\n\\tfunction createBorrowable1(address uniswapV2Pair) external returns (address borrowable1);\\r\\n\\tfunction initializeLendingPool(address uniswapV2Pair) external;\\r\\n\\r\\n\\tfunction _setPendingAdmin(address newPendingAdmin) external;\\r\\n\\tfunction _acceptAdmin() external;\\r\\n\\tfunction _setReservesPendingAdmin(address newPendingAdmin) external;\\r\\n\\tfunction _acceptReservesAdmin() external;\\r\\n\\tfunction _setReservesManager(address newReservesManager) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/interfaces/IImpermaxCallee.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface IImpermaxCallee {\\r\\n    function impermaxBorrow(address sender, address borrower, uint borrowAmount, bytes calldata data) external;\\r\\n    function impermaxRedeem(address sender, uint redeemAmount, bytes calldata data) external;\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/interfaces/IPoolToken.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface IPoolToken {\\r\\n\\r\\n\\t/*** Impermax ERC20 ***/\\r\\n\\t\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\r\\n\\t\\r\\n\\tfunction name() external pure returns (string memory);\\r\\n\\tfunction symbol() external pure returns (string memory);\\r\\n\\tfunction decimals() external pure returns (uint8);\\r\\n\\tfunction totalSupply() external view returns (uint);\\r\\n\\tfunction balanceOf(address owner) external view returns (uint);\\r\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\r\\n\\tfunction approve(address spender, uint value) external returns (bool);\\r\\n\\tfunction transfer(address to, uint value) external returns (bool);\\r\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\t\\r\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\tfunction nonces(address owner) external view returns (uint);\\r\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\t\\r\\n\\t/*** Pool Token ***/\\r\\n\\t\\r\\n\\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\\r\\n\\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\\r\\n\\tevent Sync(uint totalBalance);\\r\\n\\t\\r\\n\\tfunction underlying() external view returns (address);\\r\\n\\tfunction factory() external view returns (address);\\r\\n\\tfunction totalBalance() external view returns (uint);\\r\\n\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n\\r\\n\\tfunction exchangeRate() external returns (uint);\\r\\n\\tfunction mint(address minter) external returns (uint mintTokens);\\r\\n\\tfunction redeem(address redeemer) external returns (uint redeemAmount);\\r\\n\\tfunction skim(address to) external;\\r\\n\\tfunction sync() external;\\r\\n\\t\\r\\n\\tfunction _setFactory() external;\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/interfaces/ISimpleUniswapOracle.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\r\\n\\r\\ninterface ISimpleUniswapOracle {\\r\\n\\tevent PriceUpdate(address indexed pair, uint256 priceCumulative, uint32 blockTimestamp, bool lastIsA);\\r\\n\\tfunction MIN_T() external pure returns (uint32);\\r\\n\\tfunction getBlockTimestamp() external view returns (uint32);\\r\\n\\tfunction getPair(address uniswapV2Pair) external view returns (\\r\\n\\t\\tuint256 priceCumulativeA,\\r\\n\\t\\tuint256 priceCumulativeB,\\r\\n\\t\\tuint32 updateA,\\r\\n\\t\\tuint32 updateB,\\r\\n\\t\\tbool lastIsA,\\r\\n\\t\\tbool initialized\\r\\n\\t);\\r\\n\\tfunction initialize(address uniswapV2Pair) external;\\r\\n\\tfunction getResult(address uniswapV2Pair) external returns (uint224 price, uint32 T);\\r\\n}\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\t\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function price0CumulativeLast() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for performing various math operations\\n// forked from: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/C/Users/simor/Desktop/impermax-x-uniswapv2-periphery/test/Contracts/imx-univ2-core/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n// src: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/UQ112x112.sol\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidationIncentive\",\"type\":\"uint256\"}],\"name\":\"NewLiquidationIncentive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSafetyMarginSqrt\",\"type\":\"uint256\"}],\"name\":\"NewSafetyMargin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDATION_INCENTIVE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LIQUIDATION_INCENTIVE_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAFETY_MARGIN_SQRT_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SAFETY_MARGIN_SQRT_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowable0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_borrowable1\",\"type\":\"address\"}],\"name\":\"_initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_setFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLiquidationIncentive\",\"type\":\"uint256\"}],\"name\":\"_setLiquidationIncentive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSafetyMarginSqrt\",\"type\":\"uint256\"}],\"name\":\"_setSafetyMarginSqrt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"accountLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfall\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"accountLiquidityAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfall\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowable0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowable1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"}],\"name\":\"canBorrow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashRedeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidationIncentive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safetyMarginSqrt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"}],\"name\":\"seize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"simpleUniswapOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"tokensUnlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Collateral", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}