{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2022-11-01\r\n*/\r\n\r\n// Sources flattened with hardhat v2.9.9 https://hardhat.org\r\n\r\n// File lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File src/base/ErrorMessages.sol\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice An error used to indicate that an argument passed to a function is illegal or\r\n///         inappropriate.\r\n///\r\n/// @param message The error message.\r\nerror IllegalArgument(string message);\r\n\r\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\r\n///\r\n/// @param message The error message.\r\nerror IllegalState(string message);\r\n\r\n/// @notice An error used to indicate that an operation is unsupported.\r\n///\r\n/// @param message The error message.\r\nerror UnsupportedOperation(string message);\r\n\r\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\r\n///\r\n/// @param message The error message.\r\nerror Unauthorized(string message);\r\n\r\n\r\n// File src/base/MutexLock.sol\r\n\r\npragma solidity 0.8.13;\r\n\r\n/// @title  Mutex\r\n/// @author Alchemix Finance\r\n///\r\n/// @notice Provides a mutual exclusion lock for implementing contracts.\r\nabstract contract MutexLock {\r\n    enum State {\r\n        RESERVED,\r\n        UNLOCKED,\r\n        LOCKED\r\n    }\r\n\r\n    /// @notice The lock state.\r\n    State private _lockState = State.UNLOCKED;\r\n\r\n    /// @dev A modifier which acquires the mutex.\r\n    modifier lock() {\r\n        _claimLock();\r\n\r\n        _;\r\n\r\n        _freeLock();\r\n    }\r\n\r\n    /// @dev Gets if the mutex is locked.\r\n    ///\r\n    /// @return if the mutex is locked.\r\n    function _isLocked() internal view returns (bool) {\r\n        return _lockState == State.LOCKED;\r\n    }\r\n\r\n    /// @dev Claims the lock. If the lock is already claimed, then this will revert.\r\n    function _claimLock() internal {\r\n        // Check that the lock has not been claimed yet.\r\n        if (_lockState != State.UNLOCKED) {\r\n            revert IllegalState(\"Lock already claimed\");\r\n        }\r\n\r\n        // Claim the lock.\r\n        _lockState = State.LOCKED;\r\n    }\r\n\r\n    /// @dev Frees the lock.\r\n    function _freeLock() internal {\r\n        _lockState = State.UNLOCKED;\r\n    }\r\n}\r\n\r\n\r\n// File src/interfaces/IERC20Metadata.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/// @title  IERC20Metadata\r\n/// @author Alchemix Finance\r\ninterface IERC20Metadata {\r\n    /// @notice Gets the name of the token.\r\n    ///\r\n    /// @return The name.\r\n    function name() external view returns (string memory);\r\n\r\n    /// @notice Gets the symbol of the token.\r\n    ///\r\n    /// @return The symbol.\r\n    function symbol() external view returns (string memory);\r\n\r\n    /// @notice Gets the number of decimals that the token has.\r\n    ///\r\n    /// @return The number of decimals.\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File src/libraries/SafeERC20.sol\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @title  SafeERC20\r\n/// @author Alchemix Finance\r\nlibrary SafeERC20 {\r\n    /// @notice An error used to indicate that a call to an ERC20 contract failed.\r\n    ///\r\n    /// @param target  The target address.\r\n    /// @param success If the call to the token was a success.\r\n    /// @param data    The resulting data from the call. This is error data when the call was not a\r\n    ///                success. Otherwise, this is malformed data when the call was a success.\r\n    error ERC20CallFailed(address target, bool success, bytes data);\r\n\r\n    /// @dev A safe function to get the decimals of an ERC20 token.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token The target token.\r\n    ///\r\n    /// @return The amount of decimals of the token.\r\n    function expectDecimals(address token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = token.staticcall(\r\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\r\n        );\r\n\r\n        if (!success || data.length < 32) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n\r\n        return abi.decode(data, (uint8));\r\n    }\r\n\r\n    /// @dev Transfers tokens to another address.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer failed or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token     The token to transfer.\r\n    /// @param recipient The address of the recipient.\r\n    /// @param amount    The amount of tokens to transfer.\r\n    function safeTransfer(address token, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, recipient, amount)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n\r\n    /// @dev Approves tokens for the smart contract.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the approval fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token   The token to approve.\r\n    /// @param spender The contract to spend the tokens.\r\n    /// @param value   The amount of tokens to approve.\r\n    function safeApprove(address token, address spender, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, spender, value)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another address.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token     The token to transfer.\r\n    /// @param owner     The address of the owner.\r\n    /// @param recipient The address of the recipient.\r\n    /// @param amount    The amount of tokens to transfer.\r\n    function safeTransferFrom(address token, address owner, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transferFrom.selector, owner, recipient, amount)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File src/interfaces/ITokenAdapter.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/// @title  ITokenAdapter\r\n/// @author Alchemix Finance\r\ninterface ITokenAdapter {\r\n    /// @notice Gets the current version.\r\n    ///\r\n    /// @return The version.\r\n    function version() external view returns (string memory);\r\n\r\n    /// @notice Gets the address of the yield token that this adapter supports.\r\n    ///\r\n    /// @return The address of the yield token.\r\n    function token() external view returns (address);\r\n\r\n    /// @notice Gets the address of the underlying token that the yield token wraps.\r\n    ///\r\n    /// @return The address of the underlying token.\r\n    function underlyingToken() external view returns (address);\r\n\r\n    /// @notice Gets the number of underlying tokens that a single whole yield token is redeemable\r\n    ///         for.\r\n    ///\r\n    /// @return The price.\r\n    function price() external view returns (uint256);\r\n\r\n    /// @notice Wraps `amount` underlying tokens into the yield token.\r\n    ///\r\n    /// @param amount    The amount of the underlying token to wrap.\r\n    /// @param recipient The address which will receive the yield tokens.\r\n    ///\r\n    /// @return amountYieldTokens The amount of yield tokens minted to `recipient`.\r\n    function wrap(uint256 amount, address recipient)\r\n        external\r\n        returns (uint256 amountYieldTokens);\r\n\r\n    /// @notice Unwraps `amount` yield tokens into the underlying token.\r\n    ///\r\n    /// @param amount    The amount of yield-tokens to redeem.\r\n    /// @param recipient The recipient of the resulting underlying-tokens.\r\n    ///\r\n    /// @return amountUnderlyingTokens The amount of underlying tokens unwrapped to `recipient`.\r\n    function unwrap(uint256 amount, address recipient)\r\n        external\r\n        returns (uint256 amountUnderlyingTokens);\r\n}\r\n\r\n\r\n// File src/interfaces/external/IWETH9.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/// @title IWETH9\r\ninterface IWETH9 is IERC20, IERC20Metadata {\r\n  /// @notice Deposits `msg.value` ethereum into the contract and mints `msg.value` tokens.\r\n  function deposit() external payable;\r\n\r\n  /// @notice Burns `amount` tokens to retrieve `amount` ethereum from the contract.\r\n  ///\r\n  /// @dev This version of WETH utilizes the `transfer` function which hard codes the amount of gas\r\n  ///      that is allowed to be utilized to be exactly 2300 when receiving ethereum.\r\n  ///\r\n  /// @param amount The amount of tokens to burn.\r\n  function withdraw(uint256 amount) external;\r\n}\r\n\r\n\r\n// File src/interfaces/external/vesper/IVesperPool.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IVesperPool is IERC20 {\r\n    function deposit() external payable;\r\n\r\n    function deposit(uint256 _share) external;\r\n\r\n    function governor() external returns (address);\r\n\r\n    function keepers() external returns (address);\r\n\r\n    function multiTransfer(address[] memory _recipients, uint256[] memory _amounts)\r\n        external\r\n        returns (bool);\r\n\r\n    function excessDebt(address _strategy) external view returns (uint256);\r\n\r\n    function permit(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        uint8,\r\n        bytes32,\r\n        bytes32\r\n    ) external;\r\n\r\n    function reportEarning(\r\n        uint256 _profit,\r\n        uint256 _loss,\r\n        uint256 _payback\r\n    ) external;\r\n\r\n    function resetApproval() external;\r\n\r\n    function sweepERC20(address _fromToken) external;\r\n\r\n    function withdraw(uint256 _amount) external;\r\n\r\n    function withdrawETH(uint256 _amount) external;\r\n\r\n    function whitelistedWithdraw(uint256 _amount) external;\r\n\r\n    function feeCollector() external view returns (address);\r\n\r\n    function pricePerShare() external view returns (uint256);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function tokensHere() external view returns (uint256);\r\n\r\n    function totalDebtOf(address _strategy) external view returns (uint256);\r\n\r\n    function totalValue() external view returns (uint256);\r\n\r\n    function withdrawFee() external view returns (uint256);\r\n\r\n    function poolRewards() external view returns (address);\r\n\r\n    function getStrategies() external view returns (address[] memory);\r\n}\r\n\r\n\r\n// File src/interfaces/external/vesper/IVesperRewards.sol\r\n\r\n\r\npragma solidity >=0.6.12;\r\n\r\ninterface IVesperRewards {\r\n    function claimReward(address) external;\r\n\r\n    function claimable(address) external view returns (address[] memory, uint256[] memory);\r\n\r\n    function rewardTokens(uint256) external view returns (address);\r\n}\r\n\r\n\r\n// File src/adapters/vesper/VesperAdapterV1.sol\r\n\r\npragma solidity 0.8.13;\r\n\r\n\r\n\r\n\r\nstruct InitializationParams {\r\n    address alchemist;\r\n    address token;\r\n    address underlyingToken;\r\n}\r\n\r\ncontract VesperAdapterV1 is ITokenAdapter, MutexLock {\r\n\r\n    string public override version = \"1.0.0\";\r\n\r\n    address public immutable alchemist;\r\n    address public immutable override token;\r\n    address public immutable override underlyingToken;\r\n\r\n    constructor(InitializationParams memory params) {\r\n        alchemist       = params.alchemist;\r\n        token           = params.token;\r\n        underlyingToken = params.underlyingToken;\r\n    }\r\n\r\n    /// @dev Checks that the message sender is the alchemist that the adapter is bound to.\r\n    modifier onlyAlchemist() {\r\n        if (msg.sender != alchemist) {\r\n            revert Unauthorized(\"Not alchemist\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc ITokenAdapter\r\n    function price() external view returns (uint256) {\r\n        return IVesperPool(token).pricePerShare();\r\n    }\r\n\r\n    /// @inheritdoc ITokenAdapter\r\n    function wrap(\r\n        uint256 amount,\r\n        address recipient\r\n    ) external onlyAlchemist returns (uint256) {\r\n        // Transfer the underlying tokens from the message sender.\r\n        SafeERC20.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\r\n        SafeERC20.safeApprove(underlyingToken, token, amount);\r\n\r\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\r\n\r\n        // Vesper deposit does not accept a recipient argument and does not return mint amount\r\n        IVesperPool(token).deposit(amount);\r\n\r\n        uint256 balanceAfter = IERC20(token).balanceOf(address(this));\r\n\r\n        uint256 minted = balanceAfter - balanceBefore;\r\n\r\n        // We must transfer to recipient after and use IERC20.balanceOf() for amount\r\n        SafeERC20.safeTransfer(token, recipient, minted);\r\n\r\n        return minted;\r\n    }\r\n\r\n    // @inheritdoc ITokenAdapter\r\n    function unwrap(\r\n        uint256 amount,\r\n        address recipient\r\n    ) external lock onlyAlchemist returns (uint256) {\r\n        // Transfer the tokens from the message sender.\r\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amount);\r\n\r\n        uint256 balanceBeforeUnderlying = IERC20(underlyingToken).balanceOf(address(this));\r\n        uint256 balanceBeforeYieldToken = IERC20(token).balanceOf(address(this));\r\n        \r\n        // Vesper withdraw does not accept a recipient argument and does not return withdrawn amount\r\n        IVesperPool(token).withdraw(amount);\r\n\r\n        uint256 balanceAfterUnderlying = IERC20(underlyingToken).balanceOf(address(this));\r\n        uint256 balanceAfterYieldToken = IERC20(token).balanceOf(address(this));\r\n\r\n        uint256 withdrawn = balanceAfterUnderlying - balanceBeforeUnderlying;\r\n\r\n        if (balanceBeforeYieldToken - balanceAfterYieldToken != amount) {\r\n            revert IllegalState(\"Not all shares were burned\");\r\n        }\r\n\r\n        // We must transfer to recipient after and use IERC20.balanceOf() for amount\r\n        SafeERC20.safeTransfer(underlyingToken, recipient, withdrawn);\r\n\r\n        return withdrawn;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"alchemist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"}],\"internalType\":\"struct InitializationParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC20CallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"alchemist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"wrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "VesperAdapterV1", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005c6374a2ac4ebc38dea0fc1f8716e5ea1add94dd0000000000000000000000000538c8bac84e95a9df8ac10aad17dbe81b9e36ee0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://480f45b5735c2551f27cb5c0f41f61d83f1c5fcc4b7e841b6f7daa29f33dedf7"}