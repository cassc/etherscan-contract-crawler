{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/actions/ActionGuards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {StorageLayoutV1} from \\\"../../global/StorageLayoutV1.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {nTokenHandler} from \\\"../../internal/nToken/nTokenHandler.sol\\\";\\n\\nabstract contract ActionGuards is StorageLayoutV1 {\\n    uint256 internal constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    function initializeReentrancyGuard() internal {\\n        require(reentrancyStatus == 0);\\n\\n        // Initialize the guard to a non-zero value, see the OZ reentrancy guard\\n        // description for why this is more gas efficient:\\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol\\n        reentrancyStatus = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancyStatus != _ENTERED); // dev: reentered\\n\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancyStatus = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        reentrancyStatus = _NOT_ENTERED;\\n    }\\n\\n    // These accounts cannot receive deposits, transfers, fCash or any other\\n    // types of value transfers.\\n    function requireValidAccount(address account) internal view {\\n        require(account != address(0));\\n        require(account != Constants.FEE_RESERVE);\\n        require(account != Constants.SETTLEMENT_RESERVE);\\n        require(account != address(this));\\n        (\\n            uint256 isNToken,\\n            /* incentiveAnnualEmissionRate */,\\n            /* lastInitializedTime */,\\n            /* assetArrayLength */,\\n            /* parameters */\\n        ) = nTokenHandler.getNTokenContext(account);\\n        require(isNToken == 0);\\n\\n        // NOTE: we do not check the pCash proxy here. Unlike the nToken, the pCash proxy\\n        // is a pure proxy and does not actually hold any assets. Any assets transferred\\n        // to the pCash proxy will be lost.\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function _checkValidCurrency(uint16 currencyId) internal view {\\n        require(0 < currencyId && currencyId <= maxCurrencyId, \\\"Invalid currency id\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/external/actions/LiquidatefCashAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    AccountContext,\\n    PrimeRate,\\n    LiquidationFactors\\n} from \\\"../../global/Types.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\n\\nimport {ActionGuards} from \\\"./ActionGuards.sol\\\";\\nimport {AccountContextHandler} from \\\"../../internal/AccountContextHandler.sol\\\";\\nimport {LiquidatefCash} from \\\"../../internal/liquidation/LiquidatefCash.sol\\\";\\nimport {LiquidationHelpers} from \\\"../../internal/liquidation/LiquidationHelpers.sol\\\";\\nimport {BalanceHandler} from \\\"../../internal/balances/BalanceHandler.sol\\\";\\nimport {PrimeRateLib} from \\\"../../internal/pCash/PrimeRateLib.sol\\\";\\n\\nimport {FreeCollateralExternal} from \\\"../FreeCollateralExternal.sol\\\";\\nimport {SettleAssetsExternal} from \\\"../SettleAssetsExternal.sol\\\";\\n\\ncontract LiquidatefCashAction is ActionGuards {\\n    using AccountContextHandler for AccountContext;\\n    using PrimeRateLib for PrimeRate;\\n    using SafeInt256 for int256;\\n\\n    /// @notice Calculates fCash local liquidation amounts, may settle account so this can be called off\\n    // chain using a static call\\n    /// @param liquidateAccount account to liquidate\\n    /// @param localCurrency local currency to liquidate\\n    /// @param fCashMaturities array of fCash maturities in the local currency to purchase, must be\\n    /// ordered descending\\n    /// @param maxfCashLiquidateAmounts max notional of fCash to liquidate in corresponding maturity,\\n    /// zero will represent no maximum\\n    /// @return an array of the notional amounts of fCash to transfer, corresponding to fCashMaturities\\n    /// @return amount of local currency required from the liquidator\\n    function calculatefCashLocalLiquidation(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts\\n    ) external nonReentrant returns (int256[] memory, int256) {\\n        uint256 blockTime = block.timestamp;\\n        LiquidatefCash.fCashContext memory c =\\n            _liquidateLocal(\\n                liquidateAccount,\\n                localCurrency,\\n                fCashMaturities,\\n                maxfCashLiquidateAmounts,\\n                blockTime\\n            );\\n\\n        return (c.fCashNotionalTransfers, c.localPrimeCashFromLiquidator);\\n    }\\n\\n    /// @notice Liquidates fCash using local currency\\n    /// @param liquidateAccount account to liquidate\\n    /// @param localCurrency local currency to liquidate\\n    /// @param fCashMaturities array of fCash maturities in the local currency to purchase, must be ordered\\n    /// descending\\n    /// @param maxfCashLiquidateAmounts max notional of fCash to liquidate in corresponding maturity,\\n    /// zero will represent no maximum\\n    /// @return an array of the notional amounts of fCash to transfer, corresponding to fCashMaturities\\n    /// @return amount of local currency required from the liquidator\\n    function liquidatefCashLocal(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts\\n    ) external payable nonReentrant returns (int256[] memory, int256) {\\n        require(fCashMaturities.length > 0);\\n        uint256 blockTime = block.timestamp;\\n        LiquidatefCash.fCashContext memory c =\\n            _liquidateLocal(\\n                liquidateAccount,\\n                localCurrency,\\n                fCashMaturities,\\n                maxfCashLiquidateAmounts,\\n                blockTime\\n            );\\n\\n        LiquidatefCash.finalizefCashLiquidation(\\n            liquidateAccount,\\n            msg.sender,\\n            localCurrency,\\n            localCurrency,\\n            fCashMaturities,\\n            c\\n        );\\n\\n        return (c.fCashNotionalTransfers, c.localPrimeCashFromLiquidator);\\n    }\\n\\n    /// @notice Calculates fCash cross currency liquidation, can be called via staticcall off chain\\n    /// @param liquidateAccount account to liquidate\\n    /// @param localCurrency local currency to liquidate\\n    /// @param fCashCurrency currency of fCash to purchase\\n    /// @param fCashMaturities array of fCash maturities in the local currency to purchase, must be ordered\\n    /// descending\\n    /// @param maxfCashLiquidateAmounts max notional of fCash to liquidate in corresponding maturity, zero\\n    /// will represent no maximum\\n    /// @return an array of the notional amounts of fCash to transfer, corresponding to fCashMaturities\\n    /// @return amount of local currency required from the liquidator\\n    function calculatefCashCrossCurrencyLiquidation(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint16 fCashCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts\\n    ) external nonReentrant returns (int256[] memory, int256) {\\n        uint256 blockTime = block.timestamp;\\n        LiquidatefCash.fCashContext memory c =\\n            _liquidateCrossCurrency(\\n                liquidateAccount,\\n                localCurrency,\\n                fCashCurrency,\\n                fCashMaturities,\\n                maxfCashLiquidateAmounts,\\n                blockTime\\n            );\\n\\n        return (c.fCashNotionalTransfers, c.localPrimeCashFromLiquidator);\\n    }\\n\\n    /// @notice Liquidates fCash across local to collateral currency\\n    /// @param liquidateAccount account to liquidate\\n    /// @param localCurrency local currency to liquidate\\n    /// @param fCashCurrency currency of fCash to purchase\\n    /// @param fCashMaturities array of fCash maturities in the local currency to purchase, must be ordered\\n    /// descending\\n    /// @param maxfCashLiquidateAmounts max notional of fCash to liquidate in corresponding maturity, zero\\n    /// will represent no maximum\\n    /// @return an array of the notional amounts of fCash to transfer, corresponding to fCashMaturities\\n    /// @return amount of local currency required from the liquidator\\n    function liquidatefCashCrossCurrency(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint16 fCashCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts\\n    ) external payable nonReentrant returns (int256[] memory, int256) {\\n        require(fCashMaturities.length > 0);\\n        uint256 blockTime = block.timestamp;\\n\\n        LiquidatefCash.fCashContext memory c =\\n            _liquidateCrossCurrency(\\n                liquidateAccount,\\n                localCurrency,\\n                fCashCurrency,\\n                fCashMaturities,\\n                maxfCashLiquidateAmounts,\\n                blockTime\\n            );\\n\\n        LiquidatefCash.finalizefCashLiquidation(\\n            liquidateAccount,\\n            msg.sender,\\n            localCurrency,\\n            fCashCurrency,\\n            fCashMaturities,\\n            c\\n        );\\n\\n        return (c.fCashNotionalTransfers, c.localPrimeCashFromLiquidator);\\n    }\\n\\n    function _liquidateLocal(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts,\\n        uint256 blockTime\\n    ) private returns (LiquidatefCash.fCashContext memory) {\\n        require(fCashMaturities.length == maxfCashLiquidateAmounts.length);\\n        LiquidatefCash.fCashContext memory c;\\n        (c.accountContext, c.factors, c.portfolio) = LiquidationHelpers.preLiquidationActions(\\n            liquidateAccount,\\n            localCurrency,\\n            0\\n        );\\n\\n        // prettier-ignore\\n        (\\n            int256 cashBalance,\\n            /* int256 nTokenBalance */,\\n            /* uint256 lastClaimTime */,\\n            /* uint256 accountIncentiveDebt */\\n        ) = BalanceHandler.getBalanceStorage(liquidateAccount, localCurrency, c.factors.localPrimeRate);\\n        // Cash balance is used if liquidating negative fCash\\n        c.localCashBalanceUnderlying = c.factors.localPrimeRate.convertToUnderlying(cashBalance);\\n        c.fCashNotionalTransfers = new int256[](fCashMaturities.length);\\n\\n        LiquidatefCash.liquidatefCashLocal(\\n            liquidateAccount,\\n            localCurrency,\\n            fCashMaturities,\\n            maxfCashLiquidateAmounts,\\n            c,\\n            blockTime\\n        );\\n\\n        return c;\\n    }\\n\\n    function _liquidateCrossCurrency(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint16 fCashCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts,\\n        uint256 blockTime\\n    ) private returns (LiquidatefCash.fCashContext memory) {\\n        require(fCashMaturities.length == maxfCashLiquidateAmounts.length); // dev: fcash maturity length mismatch\\n        LiquidatefCash.fCashContext memory c;\\n        (c.accountContext, c.factors, c.portfolio) = LiquidationHelpers.preLiquidationActions(\\n            liquidateAccount,\\n            localCurrency,\\n            fCashCurrency\\n        );\\n        c.fCashNotionalTransfers = new int256[](fCashMaturities.length);\\n\\n        LiquidatefCash.liquidatefCashCrossCurrency(\\n            liquidateAccount,\\n            fCashCurrency,\\n            fCashMaturities,\\n            maxfCashLiquidateAmounts,\\n            c,\\n            blockTime\\n        );\\n\\n        return c;\\n    }\\n\\n    /// @notice Get a list of deployed library addresses (sorted by library name)\\n    function getLibInfo() external pure returns (address, address) {\\n        return (address(FreeCollateralExternal), address(SettleAssetsExternal));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/FreeCollateralExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../global/Deployments.sol\\\";\\nimport \\\"../external/SettleAssetsExternal.sol\\\";\\nimport \\\"../internal/AccountContextHandler.sol\\\";\\nimport \\\"../internal/valuation/FreeCollateral.sol\\\";\\n\\n/// @title Externally deployed library for free collateral calculations\\nlibrary FreeCollateralExternal {\\n    using AccountContextHandler for AccountContext;\\n    // Grace period after a sequencer downtime has occurred\\n    uint256 internal constant SEQUENCER_UPTIME_GRACE_PERIOD = 1 hours;\\n\\n    function _checkSequencer() private view {\\n        // See: https://docs.chain.link/data-feeds/l2-sequencer-feeds/\\n        if (address(Deployments.SEQUENCER_UPTIME_ORACLE) != address(0)) {\\n            (\\n                /*uint80 roundID*/,\\n                int256 answer,\\n                uint256 startedAt,\\n                /*uint256 updatedAt*/,\\n                /*uint80 answeredInRound*/\\n            ) = Deployments.SEQUENCER_UPTIME_ORACLE.latestRoundData();\\n            require(answer == 0, \\\"Sequencer Down\\\");\\n            require(SEQUENCER_UPTIME_GRACE_PERIOD < block.timestamp - startedAt, \\\"Sequencer Grace Period\\\");\\n        }\\n    }\\n\\n    /// @notice Returns the ETH denominated free collateral of an account, represents the amount of\\n    /// debt that the account can incur before liquidation. If an account's assets need to be settled this\\n    /// will revert, either settle the account or use the off chain SDK to calculate free collateral.\\n    /// @dev Called via the Views.sol method to return an account's free collateral. Does not work\\n    /// for the nToken, the nToken does not have an account context.\\n    /// @param account account to calculate free collateral for\\n    /// @return total free collateral in ETH w/ 8 decimal places\\n    /// @return array of net local values in asset values ordered by currency id\\n    function getFreeCollateralView(address account)\\n        external\\n        view\\n        returns (int256, int256[] memory)\\n    {\\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\\n        // The internal free collateral function does not account for settled assets. The Notional SDK\\n        // can calculate the free collateral off chain if required at this point.\\n        require(!accountContext.mustSettleAssets(), \\\"Assets not settled\\\");\\n        return FreeCollateral.getFreeCollateralView(account, accountContext, block.timestamp);\\n    }\\n\\n    /// @notice Calculates free collateral and will revert if it falls below zero. If the account context\\n    /// must be updated due to changes in debt settings, will update. Cannot check free collateral if assets\\n    /// need to be settled first.\\n    /// @dev Cannot be called directly by users, used during various actions that require an FC check. Must be\\n    /// called before the end of any transaction for accounts where FC can decrease.\\n    /// @param account account to calculate free collateral for\\n    function checkFreeCollateralAndRevert(address account) external {\\n        // Prevents new debt positions from being initiated if the sequencer is down, only applies to L2 environments\\n        // like Arbitrum and Optimism where this is a concern. Accounts with no risk do not get a free\\n        // collateral check and will bypass this check.\\n        _checkSequencer();\\n\\n        AccountContext memory accountContext = AccountContextHandler.getAccountContext(account);\\n        require(!accountContext.mustSettleAssets(), \\\"Assets not settled\\\");\\n\\n        (int256 ethDenominatedFC, bool updateContext) =\\n            FreeCollateral.getFreeCollateralStateful(account, accountContext, block.timestamp);\\n\\n        if (updateContext) {\\n            accountContext.setAccountContext(account);\\n        }\\n\\n        require(ethDenominatedFC >= 0, \\\"Insufficient free collateral\\\");\\n    }\\n\\n    /// @notice Calculates liquidation factors for an account\\n    /// @dev Only called internally by liquidation actions, does some initial validation of currencies. If a currency is\\n    /// specified that the account does not have, a asset available figure of zero will be returned. If this is the case then\\n    /// liquidation actions will revert.\\n    /// @dev an ntoken account will return 0 FC and revert if called\\n    /// @param account account to liquidate\\n    /// @param localCurrencyId currency that the debts are denominated in\\n    /// @param collateralCurrencyId collateral currency to liquidate against, set to zero in the case of local currency liquidation\\n    /// @return accountContext the accountContext of the liquidated account\\n    /// @return factors struct of relevant factors for liquidation\\n    /// @return portfolio the portfolio array of the account (bitmap accounts will return an empty array)\\n    function getLiquidationFactors(\\n        address account,\\n        uint256 localCurrencyId,\\n        uint256 collateralCurrencyId\\n    )\\n        external\\n        returns (\\n            AccountContext memory accountContext,\\n            LiquidationFactors memory factors,\\n            PortfolioAsset[] memory portfolio\\n        )\\n    {\\n        // Prevents new liquidations from being initiated if the sequencer is down, only applies to L2 environments\\n        // like Arbitrum and Optimism where this is a concern.\\n        _checkSequencer();\\n\\n        accountContext = AccountContextHandler.getAccountContext(account);\\n        if (accountContext.mustSettleAssets()) {\\n            accountContext = SettleAssetsExternal.settleAccount(account, accountContext);\\n        }\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            // A bitmap currency can only ever hold debt in this currency\\n            require(localCurrencyId == accountContext.bitmapCurrencyId);\\n        }\\n\\n        (factors, portfolio) = FreeCollateral.getLiquidationFactors(\\n            account,\\n            accountContext,\\n            block.timestamp,\\n            localCurrencyId,\\n            collateralCurrencyId\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/proxies/BaseERC4626Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {Deployments} from \\\"../../global/Deployments.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\n\\nimport {IERC4626} from \\\"../../../interfaces/IERC4626.sol\\\";\\nimport {NotionalProxy} from \\\"../../../interfaces/notional/NotionalProxy.sol\\\";\\nimport {IERC20 as IERC20WithDecimals} from \\\"../../../interfaces/IERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts/proxy/Initializable.sol\\\";\\n\\ninterface ITransferEmitter {\\n    function emitTransfer(address from, address to, uint256 amount) external;\\n    function emitMintOrBurn(address account, int256 netBalance) external;\\n    function emitMintTransferBurn(\\n        address minter, address burner, uint256 mintAmount, uint256 transferAndBurnAmount\\n    ) external;\\n    function emitfCashTradeTransfers(\\n        address account, address nToken, int256 accountToNToken, uint256 cashToReserve\\n    ) external;\\n}\\n\\n/// @notice Each nToken will have its own proxy contract that forwards calls to the main Notional\\n/// proxy where all the storage is located. There are two types of nToken proxies: regular nToken\\n/// and staked nToken proxies which both implement ERC20 standards. Each nToken proxy is an upgradeable\\n/// beacon contract so that methods they proxy can be extended in the future.\\n/// @dev The first four nTokens deployed (ETH, DAI, USDC, WBTC) have non-upgradeable nToken proxy\\n/// contracts and are not easily upgraded. This may change in the future but requires a lot of testing\\n/// and may break backwards compatibility with integrations.\\nabstract contract BaseERC4626Proxy is IERC20, IERC4626, Initializable, ITransferEmitter {\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n\\n    event ProxyRenamed();\\n\\n    /*** IMMUTABLES [SET ON IMPLEMENTATION] ***/\\n    \\n    /// @notice Inherits from Constants.INTERNAL_TOKEN_PRECISION\\n    uint8 public constant decimals = 8;\\n\\n    /// @notice Precision for exchangeRate()\\n    uint256 public constant EXCHANGE_RATE_PRECISION = 1e18;\\n\\n    /// @notice Address of the notional proxy, proxies only have access to a subset of the methods\\n    NotionalProxy public immutable NOTIONAL;\\n\\n    /*** STORAGE SLOTS [SET ONCE ON EACH PROXY] ***/\\n\\n    /// @notice Will be \\\"[Staked] nToken {Underlying Token}.name()\\\", therefore \\\"USD Coin\\\" will be\\n    /// \\\"nToken USD Coin\\\" for the regular nToken and \\\"Staked nToken USD Coin\\\" for the staked version.\\n    string public name;\\n\\n    /// @notice Will be \\\"[s]n{Underlying Token}.symbol()\\\", therefore \\\"USDC\\\" will be \\\"nUSDC\\\"\\n    string public symbol;\\n\\n    /// @notice Currency id that this nToken refers to\\n    uint16 public currencyId;\\n\\n    /// @notice Native underlying decimal places\\n    uint8 public nativeDecimals;\\n\\n    /// @notice ERC20 underlying token referred to as the \\\"asset\\\" in IERC4626\\n    address public underlying;\\n\\n    /*** END STORAGE SLOTS ***/\\n\\n    constructor(NotionalProxy notional_\\n    // Initializer modifier is used here to prevent attackers from re-initializing the\\n    // implementation. No real attack vector here since there is no ownership modification\\n    // on the implementation but this is best practice.\\n    ) initializer { \\n        NOTIONAL = notional_;\\n    }\\n\\n    modifier onlyNotional() {\\n        require(msg.sender == address(NOTIONAL), \\\"Unauthorized\\\");\\n        _;\\n    }\\n\\n    function initialize(\\n        uint16 currencyId_,\\n        address underlying_,\\n        string memory underlyingName_,\\n        string memory underlyingSymbol_\\n    ) external onlyNotional initializer {\\n        currencyId = currencyId_;\\n\\n        (string memory namePrefix, string memory nameSuffix, string memory symbolPrefix) = _getPrefixes();\\n        name = string(abi.encodePacked(namePrefix, \\\" \\\", underlyingName_, nameSuffix));\\n        symbol = string(abi.encodePacked(symbolPrefix, underlyingSymbol_));\\n\\n        if (underlying_ == Constants.ETH_ADDRESS) {\\n            // Use WETH for underlying in the case of ETH, no approval to Notional is\\n            // necessary since WETH is redeemed here\\n            underlying = address(Deployments.WETH);\\n        } else {\\n            underlying = underlying_;\\n            // Allows Notional to transfer from proxy\\n            SafeERC20.safeApprove(IERC20(underlying), address(NOTIONAL), type(uint256).max);\\n        }\\n\\n        nativeDecimals = IERC20WithDecimals(underlying).decimals();\\n        require(nativeDecimals < 36);\\n    }\\n\\n    function rename(\\n        string memory underlyingName_,\\n        string memory underlyingSymbol_\\n    ) external {\\n        require(msg.sender == NOTIONAL.owner());\\n        (string memory namePrefix, string memory nameSuffix, string memory symbolPrefix) = _getPrefixes();\\n        name = string(abi.encodePacked(namePrefix, \\\" \\\", underlyingName_, nameSuffix));\\n        symbol = string(abi.encodePacked(symbolPrefix, underlyingSymbol_));\\n        emit ProxyRenamed();\\n    }\\n\\n    /// @notice Allows ERC20 transfer events to be emitted from the proper address so that\\n    /// wallet tools can properly track balances.\\n    function emitTransfer(address from, address to, uint256 amount) external override onlyNotional {\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    /// @notice Convenience method for minting and burning\\n    function emitMintOrBurn(address account, int256 netBalance) external override onlyNotional {\\n        if (netBalance < 0) {\\n            // Burn\\n            emit Transfer(account, address(0), uint256(netBalance.neg()));\\n        } else {\\n            // Mint\\n            emit Transfer(address(0), account, uint256(netBalance));\\n        }\\n    }\\n\\n    /// @notice Convenience method for mint, transfer and burn. Used in vaults to record margin deposits and\\n    /// withdraws.\\n    function emitMintTransferBurn(\\n        address minter, address burner, uint256 mintAmount, uint256 transferAndBurnAmount\\n    ) external override onlyNotional {\\n        emit Transfer(address(0), minter, mintAmount);\\n        emit Transfer(minter, burner, transferAndBurnAmount);\\n        emit Transfer(burner, address(0), transferAndBurnAmount);\\n    }\\n\\n    /// @notice Only used on pCash when fCash is traded.\\n    function emitfCashTradeTransfers(\\n        address account, address nToken, int256 accountToNToken, uint256 cashToReserve\\n    ) external override onlyNotional {\\n        if (accountToNToken < 0) {\\n            emit Transfer(account, nToken, uint256(accountToNToken.abs()));\\n        } else {\\n            emit Transfer(nToken, account, uint256(accountToNToken));\\n        }\\n        emit Transfer(account, Constants.FEE_RESERVE, cashToReserve);\\n    }\\n\\n    /// @notice Returns the asset token reference by IERC4626, uses the underlying token as the asset\\n    /// for ERC4626 so that it is compatible with more use cases.\\n    function asset() external override view returns (address) { return underlying; }\\n\\n    /// @notice Returns the total present value of the assets held in native underlying token precision\\n    function totalAssets() public override view returns (uint256 totalManagedAssets) {\\n        totalManagedAssets = _getTotalValueExternal();\\n    }\\n\\n    function convertToShares(uint256 assets) public override view returns (uint256 shares) {\\n        return assets.mul(EXCHANGE_RATE_PRECISION).div(exchangeRate());\\n    }\\n\\n    function convertToAssets(uint256 shares) public override view returns (uint256 assets) {\\n        // Notional truncates balances below the 8th decimal place if they exist, so truncate\\n        // those balances here as well.\\n        uint256 truncate = 10 ** (nativeDecimals < 8 ? 0 : nativeDecimals - 8);\\n        return shares.mul(exchangeRate()).div(EXCHANGE_RATE_PRECISION)\\n            .div(truncate).mul(truncate);\\n    }\\n\\n    /// @notice Gets the max underlying supply\\n    function maxDeposit(address /*receiver*/) public override view returns (uint256 maxAssets) {\\n        // Both nTokens and pCash tokens are limited by the max underlying supply\\n        (\\n            /* */,\\n            /* */,\\n            uint256 maxUnderlyingSupply,\\n            uint256 currentUnderlyingSupply,\\n            /* */,\\n            /* */\\n        ) = NOTIONAL.getPrimeFactors(currencyId, block.timestamp);\\n\\n        if (maxUnderlyingSupply == 0) {\\n            return type(uint256).max;\\n        } else if (maxUnderlyingSupply <= currentUnderlyingSupply) {\\n            return 0;\\n        } else {\\n            // No overflow here\\n            return (maxUnderlyingSupply - currentUnderlyingSupply)\\n                .mul(10 ** nativeDecimals)\\n                .div(uint256(Constants.INTERNAL_TOKEN_PRECISION));\\n        }\\n    }\\n\\n    /// @notice Gets the max underlying supply and converts it to shares\\n    function maxMint(address /*receiver*/) external override view returns (uint256 maxShares) {\\n        uint256 maxAssets = maxDeposit(address(0));\\n        if (maxAssets == type(uint256).max) return maxAssets;\\n\\n        return convertToShares(maxAssets);\\n    }\\n\\n    function maxRedeem(address owner) external override view returns (uint256 maxShares) {\\n        return _balanceOf(owner);\\n    }\\n\\n    function maxWithdraw(address owner) external override view returns (uint256 maxAssets) {\\n        return convertToAssets(_balanceOf(owner));\\n    }\\n\\n    /// @notice Deposits are based on the conversion rate assets to shares.\\n    /// @dev Will round down inside convertToShares. Deposits more closely match how\\n    /// Notional processes minting within the protocol.\\n    function previewDeposit(uint256 assets) external override view returns (uint256 shares) {\\n        // Rounds down so that the account receives less shares than assets. This calculation\\n        // is only used as a view method.\\n        return convertToShares(assets);\\n    }\\n\\n    /// @notice Mints are based on the conversion rate from shares to assets.\\n    /// @dev Will be called during `mint` to calculate how much assets to transfer. Therefore,\\n    /// there may be some rounding errors when the number of shares minted does not match what\\n    /// is requested.\\n    function previewMint(uint256 shares) public override view returns (uint256 assets) {\\n        // convertToAssets will also convert the decimal basis to 8 decimal places. To round up,\\n        // add one to the value with a smaller decimal basis.\\n        return nativeDecimals < 8 ?\\n            convertToAssets(shares).add(1) :\\n            convertToAssets(shares.add(1));\\n    }\\n\\n    /// @notice Calculates how much assets will be returned when redeeming the given amount\\n    /// of shares.\\n    function previewRedeem(uint256 shares) external view override returns (uint256 assets) {\\n        // Rounds down so that the account receives less shares than assets. This calculation\\n        // is only used as a view method.\\n        return convertToAssets(shares);\\n    }\\n\\n    /// @notice Calculates how many shares need to be redeemed to receive the specified amount\\n    /// of assets.\\n    function previewWithdraw(uint256 assets) public view override returns (uint256 shares) {\\n        // convertToShares will also convert the decimal basis to 8 decimal places. To round up,\\n        // add one to the value with a larger decimal basis.\\n        return nativeDecimals < 8 ?\\n            convertToShares(assets.add(1)) :\\n            convertToShares(assets).add(1);\\n    }\\n\\n    /// @notice Deposits assets into Notional and mints either prime cash or nTokens. Unlike the wrapped fCash\\n    /// proxy this will not hold prime cash assets on the contract and wrap them, the assets will be deposited\\n    /// directly into the user's account and may be used as collateral.\\n    /// @dev The proxy contract will first transfer the assets to the contract and then transfer them\\n    /// to Notional.\\n    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {\\n        uint256 msgValue;\\n        (assets, msgValue) = _transferAssets(assets);\\n        shares = _mint(assets, msgValue, receiver);\\n\\n        emit Transfer(address(0), receiver, shares);\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n    }\\n\\n    /// @notice Similar to deposit, however the amount of shares are specified instead.\\n    function mint(uint256 shares, address receiver) external override returns (uint256 assets) {\\n        uint256 msgValue;\\n        assets = previewMint(shares);\\n        (assets, msgValue) = _transferAssets(assets);\\n        \\n        uint256 shares_ = _mint(assets, msgValue, receiver);\\n\\n        emit Transfer(address(0), receiver, shares_);\\n        emit Deposit(msg.sender, receiver, assets, shares_);\\n    }\\n\\n    function _transferAssets(uint256 assets) private returns (uint256 assetsActual, uint256 msgValue) {\\n        // NOTE: this results in double transfer of assets from the msg.sender to the proxy,\\n        // then from the proxy to Notional\\n        uint256 balanceBefore = IERC20(underlying).balanceOf(address(this));\\n        SafeERC20.safeTransferFrom(IERC20(underlying), msg.sender, address(this), assets);\\n        uint256 balanceAfter = IERC20(underlying).balanceOf(address(this));\\n\\n        // Get the most accurate accounting of the assets transferred\\n        assetsActual = balanceAfter.sub(balanceBefore);\\n\\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\\n            // Unwrap WETH and set the msgValue\\n            Deployments.WETH.withdraw(assetsActual);\\n            msgValue = assetsActual;\\n        } else {\\n            msgValue = 0;\\n        }\\n    }\\n\\n    /// @notice Withdraws the asset from Notional and they will be transferred to the receiver.\\n    function withdraw(uint256 assets, address receiver, address owner) external override returns (uint256 shares) {\\n        // NOTE: this will return an under-estimated amount for assets so the end amount of assets redeemed will\\n        // be less than specified.\\n        shares = previewWithdraw(assets);\\n        uint256 balance = _balanceOf(owner);\\n        if (shares > balance) revert(\\\"Insufficient Balance\\\");\\n\\n        // Allowance checks when receiver != owner are done on the Notional proxy\\n        uint256 assetsFinal = _redeem(shares, receiver, owner);\\n        emit Transfer(owner, address(0), shares);\\n\\n        // NOTE: the assets emitted here will be the correct value, but will not match what was provided.\\n        emit Withdraw(msg.sender, receiver, owner, assetsFinal, shares);\\n    }\\n\\n    /// @notice Redeems the asset from Notional and they will be transferred to the receiver.\\n    function redeem(uint256 shares, address receiver, address owner) external override returns (uint256 assets) {\\n        // Allowance checks when receiver != owner are done on the Notional proxy\\n        uint256 assetsFinal = _redeem(shares, receiver, owner);\\n        emit Transfer(owner, address(0), shares);\\n        emit Withdraw(msg.sender, receiver, owner, assetsFinal, shares);\\n\\n        return assetsFinal;\\n    }\\n\\n    function exchangeRate() public view returns (uint256 rate) {\\n        uint256 totalValueExternal = _getTotalValueExternal();\\n        uint256 supply = _totalSupply();\\n        // Exchange Rate from token to Underlying in EXCHANGE_RATE_PRECISION is:\\n        // 1 token = totalValueExternal * EXCHANGE_RATE_PRECISION / totalSupply\\n        rate = totalValueExternal.mul(EXCHANGE_RATE_PRECISION).div(supply);\\n    }\\n\\n    /** Required ERC20 Methods */\\n    function balanceOf(address account) external view override returns (uint256) {\\n        return _balanceOf(account);\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply();\\n    }\\n\\n    function allowance(address account, address spender) external view override returns (uint256) {\\n        return _allowance(account, spender);\\n    }\\n\\n    function approve(address spender, uint256 amount) external override returns (bool ret) {\\n        ret = _approve(spender, amount);\\n        if (ret) emit Approval(msg.sender, spender, amount);\\n    }\\n\\n    function transfer(address to, uint256 amount) external override returns (bool ret) {\\n        // Emit transfer preemptively for Emitter parsing logic.\\n        emit Transfer(msg.sender, to, amount);\\n        ret = _transfer(to, amount);\\n        require(ret);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) external override returns (bool ret) {\\n        // Emit transfer preemptively for Emitter parsing logic.\\n        emit Transfer(from, to, amount);\\n        ret = _transferFrom(from, to, amount);\\n        require(ret);\\n    }\\n\\n    /** Virtual methods **/\\n    function _balanceOf(address account) internal view virtual returns (uint256 balance);\\n    function _totalSupply() internal view virtual returns (uint256 supply);\\n    function _allowance(address account, address spender) internal view virtual returns (uint256);\\n    function _approve(address spender, uint256 amount) internal virtual returns (bool);\\n    function _transfer(address to, uint256 amount) internal virtual returns (bool);\\n    function _transferFrom(address from, address to, uint256 amount) internal virtual returns (bool);\\n\\n    /// @notice Hardcoded prefixes for the token name\\n    function _getPrefixes() internal pure virtual returns (string memory namePrefix, string memory nameSuffix, string memory symbolPrefix);\\n    function _getTotalValueExternal() internal view virtual returns (uint256 totalValueExternal);\\n    function _mint(uint256 assets, uint256 msgValue, address receiver) internal virtual returns (uint256 tokensMinted);\\n    function _redeem(uint256 shares, address receiver, address owner) internal virtual returns (uint256 assets);\\n\\n    // This is here for safety, but inheriting contracts should never declare storage anyway\\n    uint256[40] __gap;\\n}\"\r\n    },\r\n    \"contracts/external/SettleAssetsExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    AccountContext,\\n    PrimeRate,\\n    PortfolioAsset,\\n    PortfolioState,\\n    SettleAmount\\n} from \\\"../global/Types.sol\\\";\\nimport {Constants} from \\\"../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../math/SafeInt256.sol\\\";\\n\\nimport {Emitter} from \\\"../internal/Emitter.sol\\\";\\nimport {AccountContextHandler} from \\\"../internal/AccountContextHandler.sol\\\";\\nimport {PortfolioHandler} from \\\"../internal/portfolio/PortfolioHandler.sol\\\";\\nimport {TransferAssets} from \\\"../internal/portfolio/TransferAssets.sol\\\";\\nimport {BalanceHandler} from \\\"../internal/balances/BalanceHandler.sol\\\";\\nimport {SettlePortfolioAssets} from \\\"../internal/settlement/SettlePortfolioAssets.sol\\\";\\nimport {SettleBitmapAssets} from \\\"../internal/settlement/SettleBitmapAssets.sol\\\";\\nimport {PrimeRateLib} from \\\"../internal/pCash/PrimeRateLib.sol\\\";\\n\\n/// @notice External library for settling assets and portfolio management\\nlibrary SettleAssetsExternal {\\n    using SafeInt256 for int256;\\n    using PortfolioHandler for PortfolioState;\\n    using AccountContextHandler for AccountContext;\\n\\n    event AccountSettled(address indexed account);\\n\\n    /// @notice Settles an account, returns the new account context object after settlement.\\n    /// @dev The memory location of the account context object is not the same as the one returned.\\n    function settleAccount(\\n        address account,\\n        AccountContext memory accountContext\\n    ) external returns (AccountContext memory) {\\n        // Defensive check to ensure that this is a valid settlement\\n        require(accountContext.mustSettleAssets());\\n        return _settleAccount(account, accountContext);\\n    }\\n\\n    /// @notice Transfers a set of assets from one account to the other.\\n    /// @dev This method does not check free collateral, even though it may be required. The calling\\n    /// method is responsible for ensuring that free collateral is checked.\\n    /// @dev Called from LiquidatefCash#_transferAssets, ERC1155Action#_transfer\\n    function transferAssets(\\n        address fromAccount,\\n        address toAccount,\\n        AccountContext memory fromContextBefore,\\n        AccountContext memory toContextBefore,\\n        PortfolioAsset[] memory assets\\n    ) external returns (\\n        AccountContext memory fromContextAfter,\\n        AccountContext memory toContextAfter\\n    ) {\\n        // Emit events before notional amounts are inverted in place\\n        Emitter.emitBatchTransferfCash(fromAccount, toAccount, assets);\\n\\n        toContextAfter = _settleAndPlaceAssets(toAccount, toContextBefore, assets);\\n\\n        // Will flip the sign of notional in the assets array in memory\\n        TransferAssets.invertNotionalAmountsInPlace(assets);\\n\\n        fromContextAfter = _settleAndPlaceAssets(fromAccount, fromContextBefore, assets);\\n    }\\n\\n    /// @notice Places the assets in the account whether it is holding a bitmap or\\n    /// normal array type portfolio. Will revert if account has not been settled.\\n    /// @dev Called from AccountAction#nTokenRedeem\\n    function placeAssetsInAccount(\\n        address account,\\n        address fromAccount,\\n        AccountContext memory accountContext,\\n        PortfolioAsset[] memory assets\\n    ) external returns (AccountContext memory) {\\n        Emitter.emitBatchTransferfCash(fromAccount, account, assets);\\n        return TransferAssets.placeAssetsInAccount(account, accountContext, assets);\\n    }\\n\\n    /// @notice Stores a portfolio state and returns the updated context\\n    /// @dev Called from BatchAction\\n    function storeAssetsInPortfolioState(\\n        address account,\\n        AccountContext memory accountContext,\\n        PortfolioState memory state\\n    ) external returns (AccountContext memory) {\\n        accountContext.storeAssetsAndUpdateContext(account, state);\\n        // NOTE: this account context returned is in a different memory location than\\n        // the one passed in.\\n        return accountContext;\\n    }\\n\\n    /// @notice Transfers cash from a vault account to a vault liquidator\\n    /// @dev Called from VaultLiquidationAction#liquidateVaultCashBalance\\n    /// @return true if free collateral must be checked on the liquidator\\n    function transferCashToVaultLiquidator(\\n        address liquidator,\\n        address vault,\\n        address account,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 fCashToVault,\\n        int256 cashToLiquidator\\n    ) external returns (bool) {\\n        AccountContext memory context = AccountContextHandler.getAccountContext(liquidator);\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](1);\\n        assets[0].currencyId = currencyId;\\n        assets[0].maturity = maturity;\\n        assets[0].assetType = Constants.FCASH_ASSET_TYPE;\\n        assets[0].notional = fCashToVault.neg();\\n\\n        context = _settleAndPlaceAssets(liquidator, context, assets);\\n\\n        BalanceHandler.setBalanceStorageForfCashLiquidation(\\n            liquidator,\\n            context,\\n            currencyId,\\n            cashToLiquidator,\\n            PrimeRateLib.buildPrimeRateStateful(currencyId)\\n        );\\n\\n        context.setAccountContext(liquidator);\\n\\n        // The vault is transferring prime cash to the liquidator in exchange for cash.\\n        Emitter.emitTransferPrimeCash(vault, liquidator, currencyId, cashToLiquidator);\\n        // fCashToVault is positive here. The liquidator will transfer fCash to the vault\\n        // and the vault will burn it to repay negative fCash debt.\\n        Emitter.emitTransferfCash(liquidator, vault, currencyId, maturity, fCashToVault);\\n        // The account will burn its debt and vault cash\\n        Emitter.emitVaultAccountCashBurn(\\n            account, vault, currencyId, maturity, fCashToVault, cashToLiquidator\\n        );\\n        \\n        // A free collateral check is required here because the liquidator is receiving cash\\n        // and transferring out fCash. It's possible that the collateral value of the fCash\\n        // is larger than the cash transferred in. Cannot check debt in this library since it\\n        // creates a circular dependency with FreeCollateralExternal. Done in VaultLiquidationAction\\n        return context.hasDebt != 0x00;\\n    }\\n\\n    function _settleAccount(\\n        address account,\\n        AccountContext memory accountContext\\n    ) private returns (AccountContext memory) {\\n        SettleAmount[] memory settleAmounts;\\n        PortfolioState memory portfolioState;\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            PrimeRate memory presentPrimeRate = PrimeRateLib\\n                .buildPrimeRateStateful(accountContext.bitmapCurrencyId);\\n\\n            (int256 positiveSettledCash, int256 negativeSettledCash, uint256 blockTimeUTC0) =\\n                SettleBitmapAssets.settleBitmappedCashGroup(\\n                    account,\\n                    accountContext.bitmapCurrencyId,\\n                    accountContext.nextSettleTime,\\n                    block.timestamp,\\n                    presentPrimeRate\\n                );\\n            require(blockTimeUTC0 < type(uint40).max); // dev: block time utc0 overflow\\n            accountContext.nextSettleTime = uint40(blockTimeUTC0);\\n\\n            settleAmounts = new SettleAmount[](1);\\n            settleAmounts[0] = SettleAmount({\\n                currencyId: accountContext.bitmapCurrencyId,\\n                positiveSettledCash: positiveSettledCash,\\n                negativeSettledCash: negativeSettledCash,\\n                presentPrimeRate: presentPrimeRate\\n            });\\n        } else {\\n            portfolioState = PortfolioHandler.buildPortfolioState(\\n                account, accountContext.assetArrayLength, 0\\n            );\\n            settleAmounts = SettlePortfolioAssets.settlePortfolio(account, portfolioState, block.timestamp);\\n            accountContext.storeAssetsAndUpdateContextForSettlement(\\n                account, portfolioState\\n            );\\n        }\\n\\n        BalanceHandler.finalizeSettleAmounts(account, accountContext, settleAmounts);\\n\\n        emit AccountSettled(account);\\n\\n        return accountContext;\\n    }\\n\\n    function _settleAndPlaceAssets(\\n        address account,\\n        AccountContext memory context,\\n        PortfolioAsset[] memory assets\\n    ) private returns (AccountContext memory) {\\n        if (context.mustSettleAssets()) {\\n            context = _settleAccount(account, context);\\n        }\\n\\n        return TransferAssets.placeAssetsInAccount(account, context, assets);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/global/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\n\\n/// @title All shared constants for the Notional system should be declared here.\\nlibrary Constants {\\n    uint8 internal constant CETH_DECIMAL_PLACES = 8;\\n\\n    // Token precision used for all internal balances, TokenHandler library ensures that we\\n    // limit the dust amount caused by precision mismatches\\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\\n    uint256 internal constant INCENTIVE_ACCUMULATION_PRECISION = 1e18;\\n\\n    // ETH will be initialized as the first currency\\n    uint256 internal constant ETH_CURRENCY_ID = 1;\\n    uint8 internal constant ETH_DECIMAL_PLACES = 18;\\n    int256 internal constant ETH_DECIMALS = 1e18;\\n    address internal constant ETH_ADDRESS = address(0);\\n    // Used to prevent overflow when converting decimal places to decimal precision values via\\n    // 10**decimalPlaces. This is a safe value for int256 and uint256 variables. We apply this\\n    // constraint when storing decimal places in governance.\\n    uint256 internal constant MAX_DECIMAL_PLACES = 36;\\n\\n    // Address of the account where fees are collected\\n    address internal constant FEE_RESERVE = 0x0000000000000000000000000000000000000FEE;\\n    // Address of the account where settlement funds are collected, this is only\\n    // used for off chain event tracking.\\n    address internal constant SETTLEMENT_RESERVE = 0x00000000000000000000000000000000000005e7;\\n\\n    // Most significant bit\\n    bytes32 internal constant MSB =\\n        0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n    // Each bit set in this mask marks where an active market should be in the bitmap\\n    // if the first bit refers to the reference time. Used to detect idiosyncratic\\n    // fcash in the nToken accounts\\n    bytes32 internal constant ACTIVE_MARKETS_MASK = (\\n        MSB >> ( 90 - 1) | // 3 month\\n        MSB >> (105 - 1) | // 6 month\\n        MSB >> (135 - 1) | // 1 year\\n        MSB >> (147 - 1) | // 2 year\\n        MSB >> (183 - 1) | // 5 year\\n        MSB >> (211 - 1) | // 10 year\\n        MSB >> (251 - 1)   // 20 year\\n    );\\n\\n    // Basis for percentages\\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\\n    // Min Buffer Scale and Buffer Scale are used in ExchangeRate to increase the maximum\\n    // possible buffer values at the higher end of the uint8 range.\\n    int256 internal constant MIN_BUFFER_SCALE = 150;\\n    int256 internal constant BUFFER_SCALE = 10;\\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\\n    // for a bitmap portfolio\\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\\n    uint256 internal constant FIVE_MINUTES = 300;\\n\\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\\n    uint256 internal constant DAY = 86400;\\n    // We use six day weeks to ensure that all time references divide evenly\\n    uint256 internal constant WEEK = DAY * 6;\\n    uint256 internal constant MONTH = WEEK * 5;\\n    uint256 internal constant QUARTER = MONTH * 3;\\n    uint256 internal constant YEAR = QUARTER * 4;\\n    \\n    // These constants are used in DateTime.sol\\n    uint256 internal constant DAYS_IN_WEEK = 6;\\n    uint256 internal constant DAYS_IN_MONTH = 30;\\n    uint256 internal constant DAYS_IN_QUARTER = 90;\\n\\n    // Offsets for each time chunk denominated in days\\n    uint256 internal constant MAX_DAY_OFFSET = 90;\\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\\n\\n    // Offsets for each time chunk denominated in bits\\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\\n\\n    // Number of decimal places that rates are stored in, equals 100%\\n    int256 internal constant RATE_PRECISION = 1e9;\\n    // Used for prime cash scalars\\n    uint256 internal constant SCALAR_PRECISION = 1e18;\\n    // Used in prime rate lib\\n    int256 internal constant DOUBLE_SCALAR_PRECISION = 1e36;\\n    // One basis point in RATE_PRECISION terms\\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\\n    uint256 internal constant DELEVERAGE_BUFFER = 300 * BASIS_POINT;\\n    // Used for scaling cash group factors\\n    uint256 internal constant FIVE_BASIS_POINTS = 5 * BASIS_POINT;\\n    // Used for residual purchase incentive and cash withholding buffer\\n    uint256 internal constant TEN_BASIS_POINTS = 10 * BASIS_POINT;\\n    // Used for max oracle rate\\n    uint256 internal constant FIFTEEN_BASIS_POINTS = 15 * BASIS_POINT;\\n    // Used in max rate calculations\\n    uint256 internal constant MAX_LOWER_INCREMENT = 150;\\n    uint256 internal constant MAX_LOWER_INCREMENT_VALUE = 150 * 25 * BASIS_POINT;\\n    uint256 internal constant TWENTY_FIVE_BASIS_POINTS = 25 * BASIS_POINT;\\n    uint256 internal constant ONE_HUNDRED_FIFTY_BASIS_POINTS = 150 * BASIS_POINT;\\n\\n    // This is the ABDK64x64 representation of RATE_PRECISION\\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\\n\\n    uint8 internal constant FCASH_ASSET_TYPE          = 1;\\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\\n    uint8 internal constant VAULT_SHARE_ASSET_TYPE    = 9;\\n    uint8 internal constant VAULT_DEBT_ASSET_TYPE     = 10;\\n    uint8 internal constant VAULT_CASH_ASSET_TYPE     = 11;\\n    // Used for tracking legacy nToken assets\\n    uint8 internal constant LEGACY_NTOKEN_ASSET_TYPE  = 12;\\n\\n    // Account context flags\\n    bytes1 internal constant HAS_ASSET_DEBT           = 0x01;\\n    bytes1 internal constant HAS_CASH_DEBT            = 0x02;\\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO      = 0x8000;\\n    bytes2 internal constant ACTIVE_IN_BALANCES       = 0x4000;\\n    bytes2 internal constant UNMASK_FLAGS             = 0x3FFF;\\n    uint16 internal constant MAX_CURRENCIES           = uint16(UNMASK_FLAGS);\\n\\n    // Equal to 100% of all deposit amounts for nToken liquidity across fCash markets.\\n    int256 internal constant DEPOSIT_PERCENT_BASIS    = 1e8;\\n\\n    // nToken Parameters: there are offsets in the nTokenParameters bytes6 variable returned\\n    // in nTokenHandler. Each constant represents a position in the byte array.\\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\\n    uint8 internal constant MAX_MINT_DEVIATION_LIMIT = 5;\\n\\n    // Liquidation parameters\\n    // Default percentage of collateral that a liquidator is allowed to liquidate, will be higher if the account\\n    // requires more collateral to be liquidated\\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\\n    // Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 30;\\n\\n    // Pause Router liquidation enabled states\\n    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;\\n    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;\\n    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;\\n    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;\\n\\n    // Requires vault accounts to enter a position for a minimum of 1 min\\n    // to mitigate strange behavior where accounts may enter and exit using\\n    // flash loans or other MEV type behavior.\\n    uint256 internal constant VAULT_ACCOUNT_MIN_TIME = 1 minutes;\\n\\n    // Placeholder constant to mark the variable rate prime cash maturity\\n    uint40 internal constant PRIME_CASH_VAULT_MATURITY = type(uint40).max;\\n\\n    // This represents the maximum percent change allowed before and after \\n    // a rebalancing. 100_000 represents a 0.01% change\\n    // as a result of rebalancing. We should expect to never lose value as\\n    // a result of rebalancing, but some rounding errors may exist as a result\\n    // of redemption and deposit.\\n    int256 internal constant REBALANCING_UNDERLYING_DELTA_PERCENT = 100_000;\\n\\n    // Ensures that the minimum total underlying held by the contract continues\\n    // to accrue interest so that money market oracle rates are properly updated\\n    // between rebalancing. With a minimum rebalancing cool down time of 6 hours\\n    // we would be able to detect at least 1 unit of accrual at 8 decimal precision\\n    // at an interest rate of 2.8 basis points (0.0288%) with 0.05e8 minimum balance\\n    // held in a given token.\\n    //\\n    //                          MIN_ACCRUAL * (86400 / REBALANCING_COOL_DOWN_HOURS)\\n    // MINIMUM_INTEREST_RATE =  ---------------------------------------------------\\n    //                                     MINIMUM_UNDERLYING_BALANCE\\n    int256 internal constant MIN_TOTAL_UNDERLYING_VALUE = 0.05e8;\\n}\\n\"\r\n    },\r\n    \"contracts/global/Deployments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\n\\nimport {WETH9} from \\\"../../interfaces/WETH9.sol\\\";\\nimport {IUpgradeableBeacon} from \\\"../proxy/beacon/IBeacon.sol\\\";\\nimport {AggregatorV2V3Interface} from \\\"../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\n\\n/// @title Hardcoded deployed contracts are listed here. These are hardcoded to reduce\\n/// gas costs for immutable addresses. They must be updated per environment that Notional\\n/// is deployed to.\\nlibrary Deployments {\\n    uint256 internal constant MAINNET = 1;\\n    uint256 internal constant ARBITRUM_ONE = 42161;\\n    uint256 internal constant LOCAL = 1337;\\n\\n    // MAINNET: 0xCFEAead4947f0705A14ec42aC3D44129E1Ef3eD5\\n    address internal constant NOTE_TOKEN_ADDRESS = 0xCFEAead4947f0705A14ec42aC3D44129E1Ef3eD5;\\n    // ARBITRUM: 0x019bE259BC299F3F653688c7655C87F998Bc7bC1\\n    // address internal constant NOTE_TOKEN_ADDRESS = 0x019bE259BC299F3F653688c7655C87F998Bc7bC1;\\n\\n    // MAINNET: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\\n    WETH9 internal constant WETH = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n    // ARBITRUM: 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\\n    // WETH9 internal constant WETH = WETH9(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);\\n    // OPTIMISM: 0x4200000000000000000000000000000000000006\\n\\n    // Chainlink L2 Sequencer Uptime: https://docs.chain.link/data-feeds/l2-sequencer-feeds/\\n    // MAINNET: NOT SET\\n    AggregatorV2V3Interface internal constant SEQUENCER_UPTIME_ORACLE = AggregatorV2V3Interface(address(0));\\n    // ARBITRUM: 0xFdB631F5EE196F0ed6FAa767959853A9F217697D\\n    // AggregatorV2V3Interface internal constant SEQUENCER_UPTIME_ORACLE = AggregatorV2V3Interface(0xFdB631F5EE196F0ed6FAa767959853A9F217697D);\\n\\n    enum BeaconType {\\n        NTOKEN,\\n        PCASH,\\n        PDEBT,\\n        WRAPPED_FCASH\\n    }\\n\\n    // NOTE: these are temporary Beacon addresses\\n    IUpgradeableBeacon internal constant NTOKEN_BEACON = IUpgradeableBeacon(0xc4FD259b816d081C8bdd22D6bbd3495DB1573DB7);\\n    IUpgradeableBeacon internal constant PCASH_BEACON = IUpgradeableBeacon(0x1F681977aF5392d9Ca5572FB394BC4D12939A6A9);\\n    IUpgradeableBeacon internal constant PDEBT_BEACON = IUpgradeableBeacon(0xDF08039c0af34E34660aC7c2705C0Da953247640);\\n    // ARB:\\n    // IUpgradeableBeacon internal constant WRAPPED_FCASH_BEACON = IUpgradeableBeacon(0xD676d720E4e8B14F545F9116F0CAD47aF32329DD);\\n    IUpgradeableBeacon internal constant WRAPPED_FCASH_BEACON = IUpgradeableBeacon(0xEBe1BF1653d55d31F6ED38B1A4CcFE2A92338f66);\\n    \\n\\n    // TODO: this will be set to the timestamp of the final settlement time in notional v2,\\n    // no assets can be settled prior to this date once the notional v3 upgrade is enabled.\\n    uint256 internal constant NOTIONAL_V2_FINAL_SETTLEMENT = 0;\\n}\\n\"\r\n    },\r\n    \"contracts/global/LibStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./Types.sol\\\";\\nimport \\\"./Constants.sol\\\";\\nimport \\\"../../interfaces/notional/IRewarder.sol\\\";\\nimport \\\"../../interfaces/aave/ILendingPool.sol\\\";\\n\\nlibrary LibStorage {\\n\\n    /// @dev Offset for the initial slot in lib storage, gives us this number of storage slots\\n    /// available in StorageLayoutV1 and all subsequent storage layouts that inherit from it.\\n    uint256 private constant STORAGE_SLOT_BASE = 1000000;\\n    /// @dev Set to MAX_TRADED_MARKET_INDEX * 2, Solidity does not allow assigning constants from imported values\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\n    /// @dev Maximum limit for portfolio asset array, this has been reduced from 16 in the previous version. No\\n    /// account has hit the theoretical limit and it would not possible for them to since accounts do not hold\\n    /// liquidity tokens (only the nToken does).\\n    uint256 internal constant MAX_PORTFOLIO_ASSETS = 8;\\n\\n    /// @dev Storage IDs for storage buckets. Each id maps to an internal storage\\n    /// slot used for a particular mapping\\n    ///     WARNING: APPEND ONLY\\n    enum StorageId {\\n        Unused,\\n        AccountStorage,\\n        nTokenContext,\\n        nTokenAddress,\\n        nTokenDeposit,\\n        nTokenInitialization,\\n        Balance,\\n        Token,\\n        SettlementRate_deprecated,\\n        CashGroup,\\n        Market,\\n        AssetsBitmap,\\n        ifCashBitmap,\\n        PortfolioArray,\\n        // WARNING: this nTokenTotalSupply storage object was used for a buggy version\\n        // of the incentives calculation. It should only be used for accounts who have\\n        // not claimed before the migration\\n        nTokenTotalSupply_deprecated,\\n        AssetRate_deprecated,\\n        ExchangeRate,\\n        nTokenTotalSupply,\\n        SecondaryIncentiveRewarder,\\n        LendingPool,\\n        VaultConfig,\\n        VaultState,\\n        VaultAccount,\\n        VaultBorrowCapacity,\\n        VaultSecondaryBorrow,\\n        // With the upgrade to prime cash vaults, settled assets is no longer required\\n        // for the vault calculation. Do not remove this or other storage slots will be\\n        // broken.\\n        VaultSettledAssets_deprecated,\\n        VaultAccountSecondaryDebtShare,\\n        ActiveInterestRateParameters,\\n        NextInterestRateParameters,\\n        PrimeCashFactors,\\n        PrimeSettlementRates,\\n        PrimeCashHoldingsOracles,\\n        TotalfCashDebtOutstanding,\\n        pCashAddress,\\n        pDebtAddress,\\n        pCashTransferAllowance,\\n        RebalancingTargets,\\n        RebalancingContext,\\n        StoredTokenBalances\\n    }\\n\\n    /// @dev Mapping from an account address to account context\\n    function getAccountStorage() internal pure \\n        returns (mapping(address => AccountContext) storage store) \\n    {\\n        uint256 slot = _getStorageSlot(StorageId.AccountStorage);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from an nToken address to nTokenContext\\n    function getNTokenContextStorage() internal pure\\n        returns (mapping(address => nTokenContext) storage store) \\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenContext);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to nTokenAddress\\n    function getNTokenAddressStorage() internal pure\\n        returns (mapping(uint256 => address) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenAddress);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to uint32 fixed length array of\\n    /// deposit factors. Deposit shares and leverage thresholds are stored striped to\\n    /// reduce the number of storage reads.\\n    function getNTokenDepositStorage() internal pure\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenDeposit);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to fixed length array of initialization factors,\\n    /// stored striped like deposit shares.\\n    function getNTokenInitStorage() internal pure\\n        returns (mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenInitialization);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to currencyId to it's balance storage for that currency\\n    function getBalanceStorage() internal pure\\n        returns (mapping(address => mapping(uint256 => BalanceStorage)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.Balance);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to a boolean for underlying or asset token to\\n    /// the TokenStorage\\n    function getTokenStorage() internal pure\\n        returns (mapping(uint256 => mapping(bool => TokenStorage)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.Token);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to maturity to its corresponding SettlementRate\\n    function getSettlementRateStorage_deprecated() internal pure\\n        returns (mapping(uint256 => mapping(uint256 => SettlementRateStorage)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.SettlementRate_deprecated);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to maturity to its tightly packed cash group parameters\\n    function getCashGroupStorage() internal pure\\n        returns (mapping(uint256 => bytes32) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.CashGroup);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from currency id to maturity to settlement date for a market\\n    function getMarketStorage() internal pure\\n        returns (mapping(uint256 => mapping(uint256 => mapping(uint256 => MarketStorage))) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.Market);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to currency id to its assets bitmap\\n    function getAssetsBitmapStorage() internal pure\\n        returns (mapping(address => mapping(uint256 => bytes32)) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.AssetsBitmap);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to currency id to its maturity to its corresponding ifCash balance\\n    function getifCashBitmapStorage() internal pure\\n        returns (mapping(address => mapping(uint256 => mapping(uint256 => ifCashStorage))) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.ifCashBitmap);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from account to its fixed length array of portfolio assets\\n    function getPortfolioArrayStorage() internal pure\\n        returns (mapping(address => PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.PortfolioArray);\\n        assembly { store.slot := slot }\\n    }\\n\\n    function getDeprecatedNTokenTotalSupplyStorage() internal pure\\n        returns (mapping(address => nTokenTotalSupplyStorage_deprecated) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenTotalSupply_deprecated);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Mapping from nToken address to its total supply values\\n    function getNTokenTotalSupplyStorage() internal pure\\n        returns (mapping(address => nTokenTotalSupplyStorage) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.nTokenTotalSupply);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the exchange rate between an underlying currency and asset for trading\\n    /// and free collateral. Mapping is from currency id to rate storage object.\\n    function getAssetRateStorage_deprecated() internal pure\\n        returns (mapping(uint256 => AssetRateStorage) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.AssetRate_deprecated);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the exchange rate between an underlying currency and ETH for free\\n    /// collateral purposes. Mapping is from currency id to rate storage object.\\n    function getExchangeRateStorage() internal pure\\n        returns (mapping(uint256 => ETHRateStorage) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.ExchangeRate);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the address of a secondary incentive rewarder for an nToken if it exists\\n    function getSecondaryIncentiveRewarder() internal pure\\n        returns (mapping(address => IRewarder) storage store)\\n    {\\n        uint256 slot = _getStorageSlot(StorageId.SecondaryIncentiveRewarder);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns the address of the lending pool\\n    function getLendingPool() internal pure returns (LendingPoolStorage storage store) {\\n        uint256 slot = _getStorageSlot(StorageId.LendingPool);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultConfig, mapping is from vault address to VaultConfig object\\n    function getVaultConfig() internal pure returns (\\n        mapping(address => VaultConfigStorage) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultConfig);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultState, mapping is from vault address to maturity to VaultState object\\n    function getVaultState() internal pure returns (\\n        mapping(address => mapping(uint256 => VaultStateStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultState);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultAccount, mapping is from account address to vault address to VaultAccount object\\n    function getVaultAccount() internal pure returns (\\n        mapping(address => mapping(address => VaultAccountStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultAccount);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for a VaultBorrowCapacity, mapping is from vault address to currency to BorrowCapacity object\\n    function getVaultBorrowCapacity() internal pure returns (\\n        mapping(address => mapping(uint256 => VaultBorrowCapacityStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultBorrowCapacity);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultAccount, mapping is from account address to vault address to maturity to\\n    /// currencyId to VaultStateStorage object, only totalDebt, totalPrimeCash, and isSettled are used for\\n    /// vault secondary borrows, but this allows code to be shared.\\n    function getVaultSecondaryBorrow() internal pure returns (\\n        mapping(address => mapping(uint256 => mapping(uint256 => VaultStateStorage))) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultSecondaryBorrow);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for an VaultAccount, mapping is from account address to vault address\\n    function getVaultAccountSecondaryDebtShare() internal pure returns (\\n        mapping(address => mapping(address => VaultAccountSecondaryDebtShareStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.VaultAccountSecondaryDebtShare);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for currently active InterestRateParameters,\\n    /// mapping is from a currency id to a bytes32[2] array of parameters\\n    function getActiveInterestRateParameters() internal pure returns (\\n        mapping(uint256 => bytes32[2]) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.ActiveInterestRateParameters);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns object for the next set of InterestRateParameters,\\n    /// mapping is from a currency id to a bytes32[2] array of parameters\\n    function getNextInterestRateParameters() internal pure returns (\\n        mapping(uint256 => bytes32[2]) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.NextInterestRateParameters);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns mapping from currency id to PrimeCashFactors\\n    function getPrimeCashFactors() internal pure returns (\\n        mapping(uint256 => PrimeCashFactorsStorage) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.PrimeCashFactors);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns mapping from currency to maturity to PrimeSettlementRates\\n    function getPrimeSettlementRates() internal pure returns (\\n        mapping(uint256 => mapping(uint256 => PrimeSettlementRateStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.PrimeSettlementRates);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns mapping from currency to an external oracle that reports the\\n    /// total underlying value for prime cash\\n    function getPrimeCashHoldingsOracle() internal pure returns (\\n        mapping(uint256 => PrimeCashHoldingsOracle) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.PrimeCashHoldingsOracles);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns mapping from currency to maturity to total fCash debt outstanding figure.\\n    function getTotalfCashDebtOutstanding() internal pure returns (\\n        mapping(uint256 => mapping(uint256 => TotalfCashDebtStorage)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.TotalfCashDebtOutstanding);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns mapping from currency to pCash proxy address\\n    function getPCashAddressStorage() internal pure returns (\\n        mapping(uint256 => address) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.pCashAddress);\\n        assembly { store.slot := slot }\\n    }\\n\\n    function getPDebtAddressStorage() internal pure returns (\\n        mapping(uint256 => address) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.pDebtAddress);\\n        assembly { store.slot := slot }\\n    }\\n\\n    /// @dev Returns mapping for pCash ERC20 transfer allowances\\n    function getPCashTransferAllowance() internal pure returns (\\n        // owner => spender => currencyId => transferAllowance\\n        mapping(address => mapping(address => mapping(uint16 => uint256))) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.pCashTransferAllowance);\\n        assembly { store.slot := slot }\\n    }\\n\\n    function getRebalancingTargets() internal pure returns (\\n        mapping(uint16 => mapping(address => RebalancingTargetData)) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.RebalancingTargets);\\n        assembly { store.slot := slot }\\n    }\\n\\n    function getRebalancingContext() internal pure returns (\\n        mapping(uint16 => RebalancingContextStorage) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.RebalancingContext);\\n        assembly { store.slot := slot }\\n    }\\n\\n    function getStoredTokenBalances() internal pure returns (\\n        mapping(address => uint256) storage store\\n    ) {\\n        uint256 slot = _getStorageSlot(StorageId.StoredTokenBalances);\\n        assembly { store.slot := slot }        \\n    }\\n\\n    /// @dev Get the storage slot given a storage ID.\\n    /// @param storageId An entry in `StorageId`\\n    /// @return slot The storage slot.\\n    function _getStorageSlot(StorageId storageId)\\n        private\\n        pure\\n        returns (uint256 slot)\\n    {\\n        // This should never overflow with a reasonable `STORAGE_SLOT_EXP`\\n        // because Solidity will do a range check on `storageId` during the cast.\\n        return uint256(storageId) + STORAGE_SLOT_BASE;\\n    }\\n}\"\r\n    },\r\n    \"contracts/global/StorageLayoutV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\n/**\\n * @notice Storage layout for the system. Do not change this file once deployed, future storage\\n * layouts must inherit this and increment the version number.\\n */\\ncontract StorageLayoutV1 {\\n    // The current maximum currency id\\n    uint16 internal maxCurrencyId;\\n    // Sets the state of liquidations being enabled during a paused state. Each of the four lower\\n    // bits can be turned on to represent one of the liquidation types being enabled.\\n    bytes1 internal liquidationEnabledState;\\n    // Set to true once the system has been initialized\\n    bool internal hasInitialized;\\n\\n    /* Authentication Mappings */\\n    // This is set to the timelock contract to execute governance functions\\n    address public owner;\\n    // This is set to an address of a router that can only call governance actions\\n    address public pauseRouter;\\n    // This is set to an address of a router that can only call governance actions\\n    address public pauseGuardian;\\n    // On upgrades this is set in the case that the pause router is used to pass the rollback check\\n    address internal rollbackRouterImplementation;\\n\\n    // A blanket allowance for a spender to transfer any of an account's nTokens. This would allow a user\\n    // to set an allowance on all nTokens for a particular integrating contract system.\\n    // owner => spender => transferAllowance\\n    mapping(address => mapping(address => uint256)) internal nTokenWhitelist;\\n    // Individual transfer allowances for nTokens used for ERC20\\n    // owner => spender => currencyId => transferAllowance\\n    mapping(address => mapping(address => mapping(uint16 => uint256))) internal nTokenAllowance;\\n\\n    // Transfer operators\\n    // Mapping from a global ERC1155 transfer operator contract to an approval value for it\\n    mapping(address => bool) internal globalTransferOperator;\\n    // Mapping from an account => operator => approval status for that operator. This is a specific\\n    // approval between two addresses for ERC1155 transfers.\\n    mapping(address => mapping(address => bool)) internal accountAuthorizedTransferOperator;\\n    // Approval for a specific contract to use the `batchBalanceAndTradeActionWithCallback` method in\\n    // BatchAction.sol, can only be set by governance\\n    mapping(address => bool) internal authorizedCallbackContract;\\n\\n    // Reverse mapping from token addresses to currency ids, only used for referencing in views\\n    // and checking for duplicate token listings.\\n    mapping(address => uint16) internal tokenAddressToCurrencyId;\\n\\n    // Reentrancy guard\\n    uint256 internal reentrancyStatus;\\n}\\n\"\r\n    },\r\n    \"contracts/global/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\nimport \\\"../../interfaces/notional/IPrimeCashHoldingsOracle.sol\\\";\\nimport \\\"../../interfaces/notional/AssetRateAdapter.sol\\\";\\n\\n/// @notice Different types of internal tokens\\n///  - UnderlyingToken: underlying asset for a cToken (except for Ether)\\n///  - cToken: Compound interest bearing token\\n///  - cETH: Special handling for cETH tokens\\n///  - Ether: the one and only\\n///  - NonMintable: tokens that do not have an underlying (therefore not cTokens)\\n///  - aToken: Aave interest bearing tokens\\nenum TokenType {\\n    UnderlyingToken,\\n    cToken,\\n    cETH,\\n    Ether,\\n    NonMintable,\\n    aToken\\n}\\n\\n/// @notice Specifies the different trade action types in the system. Each trade action type is\\n/// encoded in a tightly packed bytes32 object. Trade action type is the first big endian byte of the\\n/// 32 byte trade action object. The schemas for each trade action type are defined below.\\nenum TradeActionType {\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 minImpliedRate, uint120 unused)\\n    Lend,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 fCashAmount, uint32 maxImpliedRate, uint128 unused)\\n    Borrow,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 primeCashAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\n    AddLiquidity,\\n    // (uint8 TradeActionType, uint8 MarketIndex, uint88 tokenAmount, uint32 minImpliedRate, uint32 maxImpliedRate, uint88 unused)\\n    RemoveLiquidity,\\n    // (uint8 TradeActionType, uint32 Maturity, int88 fCashResidualAmount, uint128 unused)\\n    PurchaseNTokenResidual,\\n    // (uint8 TradeActionType, address CounterpartyAddress, int88 fCashAmountToSettle)\\n    SettleCashDebt\\n}\\n\\n/// @notice Specifies different deposit actions that can occur during BalanceAction or BalanceActionWithTrades\\nenum DepositActionType {\\n    // No deposit action\\n    None,\\n    // Deposit asset cash, depositActionAmount is specified in asset cash external precision\\n    DepositAsset,\\n    // Deposit underlying tokens that are mintable to asset cash, depositActionAmount is specified in underlying token\\n    // external precision\\n    DepositUnderlying,\\n    // Deposits specified asset cash external precision amount into an nToken and mints the corresponding amount of\\n    // nTokens into the account\\n    DepositAssetAndMintNToken,\\n    // Deposits specified underlying in external precision, mints asset cash, and uses that asset cash to mint nTokens\\n    DepositUnderlyingAndMintNToken,\\n    // Redeems an nToken balance to asset cash. depositActionAmount is specified in nToken precision. Considered a deposit action\\n    // because it deposits asset cash into an account. If there are fCash residuals that cannot be sold off, will revert.\\n    RedeemNToken,\\n    // Converts specified amount of asset cash balance already in Notional to nTokens. depositActionAmount is specified in\\n    // Notional internal 8 decimal precision.\\n    ConvertCashToNToken\\n}\\n\\n/// @notice Used internally for PortfolioHandler state\\nenum AssetStorageState {\\n    NoChange,\\n    Update,\\n    Delete,\\n    RevertIfStored\\n}\\n\\n/****** Calldata objects ******/\\n\\n/// @notice Defines a batch lending action\\nstruct BatchLend {\\n    uint16 currencyId;\\n    // True if the contract should try to transfer underlying tokens instead of asset tokens\\n    bool depositUnderlying;\\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\\n    bytes32[] trades;\\n}\\n\\n/// @notice Defines a balance action for batchAction\\nstruct BalanceAction {\\n    // Deposit action to take (if any)\\n    DepositActionType actionType;\\n    uint16 currencyId;\\n    // Deposit action amount must correspond to the depositActionType, see documentation above.\\n    uint256 depositActionAmount;\\n    // Withdraw an amount of asset cash specified in Notional internal 8 decimal precision\\n    uint256 withdrawAmountInternalPrecision;\\n    // If set to true, will withdraw entire cash balance. Useful if there may be an unknown amount of asset cash\\n    // residual left from trading.\\n    bool withdrawEntireCashBalance;\\n    // If set to true, will redeem asset cash to the underlying token on withdraw.\\n    bool redeemToUnderlying;\\n}\\n\\n/// @notice Defines a balance action with a set of trades to do as well\\nstruct BalanceActionWithTrades {\\n    DepositActionType actionType;\\n    uint16 currencyId;\\n    uint256 depositActionAmount;\\n    uint256 withdrawAmountInternalPrecision;\\n    bool withdrawEntireCashBalance;\\n    bool redeemToUnderlying;\\n    // Array of tightly packed 32 byte objects that represent trades. See TradeActionType documentation\\n    bytes32[] trades;\\n}\\n\\n/****** In memory objects ******/\\n/// @notice Internal object that represents settled cash balances\\nstruct SettleAmount {\\n    uint16 currencyId;\\n    int256 positiveSettledCash;\\n    int256 negativeSettledCash;\\n    PrimeRate presentPrimeRate;\\n}\\n\\n/// @notice Internal object that represents a token\\nstruct Token {\\n    address tokenAddress;\\n    bool hasTransferFee;\\n    int256 decimals;\\n    TokenType tokenType;\\n    uint256 deprecated_maxCollateralBalance;\\n}\\n\\n/// @notice Internal object that represents an nToken portfolio\\nstruct nTokenPortfolio {\\n    CashGroupParameters cashGroup;\\n    PortfolioState portfolioState;\\n    int256 totalSupply;\\n    int256 cashBalance;\\n    uint256 lastInitializedTime;\\n    bytes6 parameters;\\n    address tokenAddress;\\n}\\n\\n/// @notice Internal object used during liquidation\\nstruct LiquidationFactors {\\n    address account;\\n    // Aggregate free collateral of the account denominated in ETH underlying, 8 decimal precision\\n    int256 netETHValue;\\n    // Amount of net local currency asset cash before haircuts and buffers available\\n    int256 localPrimeAvailable;\\n    // Amount of net collateral currency asset cash before haircuts and buffers available\\n    int256 collateralAssetAvailable;\\n    // Haircut value of nToken holdings denominated in asset cash, will be local or collateral nTokens based\\n    // on liquidation type\\n    int256 nTokenHaircutPrimeValue;\\n    // nToken parameters for calculating liquidation amount\\n    bytes6 nTokenParameters;\\n    // ETH exchange rate from local currency to ETH\\n    ETHRate localETHRate;\\n    // ETH exchange rate from collateral currency to ETH\\n    ETHRate collateralETHRate;\\n    // Asset rate for the local currency, used in cross currency calculations to calculate local asset cash required\\n    PrimeRate localPrimeRate;\\n    // Used during currency liquidations if the account has liquidity tokens\\n    CashGroupParameters collateralCashGroup;\\n    // Used during currency liquidations if it is only a calculation, defaults to false\\n    bool isCalculation;\\n}\\n\\n/// @notice Internal asset array portfolio state\\nstruct PortfolioState {\\n    // Array of currently stored assets\\n    PortfolioAsset[] storedAssets;\\n    // Array of new assets to add\\n    PortfolioAsset[] newAssets;\\n    uint256 lastNewAssetIndex;\\n    // Holds the length of stored assets after accounting for deleted assets\\n    uint256 storedAssetLength;\\n}\\n\\n/// @notice In memory ETH exchange rate used during free collateral calculation.\\nstruct ETHRate {\\n    // The decimals (i.e. 10^rateDecimalPlaces) of the exchange rate, defined by the rate oracle\\n    int256 rateDecimals;\\n    // The exchange rate from base to ETH (if rate invert is required it is already done)\\n    int256 rate;\\n    // Amount of buffer as a multiple with a basis of 100 applied to negative balances.\\n    int256 buffer;\\n    // Amount of haircut as a multiple with a basis of 100 applied to positive balances\\n    int256 haircut;\\n    // Liquidation discount as a multiple with a basis of 100 applied to the exchange rate\\n    // as an incentive given to liquidators.\\n    int256 liquidationDiscount;\\n}\\n\\n/// @notice Internal object used to handle balance state during a transaction\\nstruct BalanceState {\\n    uint16 currencyId;\\n    // Cash balance stored in balance state at the beginning of the transaction\\n    int256 storedCashBalance;\\n    // nToken balance stored at the beginning of the transaction\\n    int256 storedNTokenBalance;\\n    // The net cash change as a result of asset settlement or trading\\n    int256 netCashChange;\\n    // Amount of prime cash to redeem and withdraw from the system\\n    int256 primeCashWithdraw;\\n    // Net token transfers into or out of the account\\n    int256 netNTokenTransfer;\\n    // Net token supply change from minting or redeeming\\n    int256 netNTokenSupplyChange;\\n    // The last time incentives were claimed for this currency\\n    uint256 lastClaimTime;\\n    // Accumulator for incentives that the account no longer has a claim over\\n    uint256 accountIncentiveDebt;\\n    // Prime rate for converting prime cash balances\\n    PrimeRate primeRate;\\n}\\n\\n/// @dev Asset rate used to convert between underlying cash and asset cash\\nstruct Deprecated_AssetRateParameters {\\n    // Address of the asset rate oracle\\n    AssetRateAdapter rateOracle;\\n    // The exchange rate from base to quote (if invert is required it is already done)\\n    int256 rate;\\n    // The decimals of the underlying, the rate converts to the underlying decimals\\n    int256 underlyingDecimals;\\n}\\n\\n/// @dev Cash group when loaded into memory\\nstruct CashGroupParameters {\\n    uint16 currencyId;\\n    uint256 maxMarketIndex;\\n    PrimeRate primeRate;\\n    bytes32 data;\\n}\\n\\n/// @dev A portfolio asset when loaded in memory\\nstruct PortfolioAsset {\\n    // Asset currency id\\n    uint16 currencyId;\\n    uint256 maturity;\\n    // Asset type, fCash or liquidity token.\\n    uint256 assetType;\\n    // fCash amount or liquidity token amount\\n    int256 notional;\\n    // Used for managing portfolio asset state\\n    uint256 storageSlot;\\n    // The state of the asset for when it is written to storage\\n    AssetStorageState storageState;\\n}\\n\\n/// @dev Market object as represented in memory\\nstruct MarketParameters {\\n    bytes32 storageSlot;\\n    uint256 maturity;\\n    // Total amount of fCash available for purchase in the market.\\n    int256 totalfCash;\\n    // Total amount of cash available for purchase in the market.\\n    int256 totalPrimeCash;\\n    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\\n    int256 totalLiquidity;\\n    // This is the previous annualized interest rate in RATE_PRECISION that the market traded\\n    // at. This is used to calculate the rate anchor to smooth interest rates over time.\\n    uint256 lastImpliedRate;\\n    // Time lagged version of lastImpliedRate, used to value fCash assets at market rates while\\n    // remaining resistent to flash loan attacks.\\n    uint256 oracleRate;\\n    // This is the timestamp of the previous trade\\n    uint256 previousTradeTime;\\n}\\n\\n/****** Storage objects ******/\\n\\n/// @dev Token object in storage:\\n///  20 bytes for token address\\n///  1 byte for hasTransferFee\\n///  1 byte for tokenType\\n///  1 byte for tokenDecimals\\n///  9 bytes for maxCollateralBalance (may not always be set)\\nstruct TokenStorage {\\n    // Address of the token\\n    address tokenAddress;\\n    // Transfer fees will change token deposit behavior\\n    bool hasTransferFee;\\n    TokenType tokenType;\\n    uint8 decimalPlaces;\\n    uint72 deprecated_maxCollateralBalance;\\n}\\n\\n/// @dev Exchange rate object as it is represented in storage, total storage is 25 bytes.\\nstruct ETHRateStorage {\\n    // Address of the rate oracle\\n    AggregatorV2V3Interface rateOracle;\\n    // The decimal places of precision that the rate oracle uses\\n    uint8 rateDecimalPlaces;\\n    // True of the exchange rate must be inverted\\n    bool mustInvert;\\n    // NOTE: both of these governance values are set with BUFFER_DECIMALS precision\\n    // Amount of buffer to apply to the exchange rate for negative balances.\\n    uint8 buffer;\\n    // Amount of haircut to apply to the exchange rate for positive balances\\n    uint8 haircut;\\n    // Liquidation discount in percentage point terms, 106 means a 6% discount\\n    uint8 liquidationDiscount;\\n}\\n\\n/// @dev Asset rate oracle object as it is represented in storage, total storage is 21 bytes.\\nstruct AssetRateStorage {\\n    // Address of the rate oracle\\n    AssetRateAdapter rateOracle;\\n    // The decimal places of the underlying asset\\n    uint8 underlyingDecimalPlaces;\\n}\\n\\n/// @dev Governance parameters for a cash group, total storage is 9 bytes + 7 bytes for liquidity token haircuts\\n/// and 7 bytes for rate scalars, total of 23 bytes. Note that this is stored packed in the storage slot so there\\n/// are no indexes stored for liquidityTokenHaircuts or rateScalars, maxMarketIndex is used instead to determine the\\n/// length.\\nstruct CashGroupSettings {\\n    // Index of the AMMs on chain that will be made available. Idiosyncratic fCash\\n    // that is dated less than the longest AMM will be tradable.\\n    uint8 maxMarketIndex;\\n    // Time window in 5 minute increments that the rate oracle will be averaged over\\n    uint8 rateOracleTimeWindow5Min;\\n    // Absolute maximum discount factor as a discount from 1e9, specified in five basis points\\n    // subtracted from 1e9\\n    uint8 maxDiscountFactor5BPS;\\n    // Share of the fees given to the protocol, denominated in percentage\\n    uint8 reserveFeeShare;\\n    // Debt buffer specified in 5 BPS increments\\n    uint8 debtBuffer25BPS;\\n    // fCash haircut specified in 5 BPS increments\\n    uint8 fCashHaircut25BPS;\\n    // Minimum oracle interest rates for fCash per market, specified in 25 bps increments\\n    uint8 minOracleRate25BPS;\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\n    uint8 liquidationfCashHaircut25BPS;\\n    // If an account has fCash that is being liquidated, this is the discount that the liquidator can purchase it for\\n    uint8 liquidationDebtBuffer25BPS;\\n    // Max oracle rate specified in 25bps increments as a discount from the max rate in the market.\\n    uint8 maxOracleRate25BPS;\\n}\\n\\n/// @dev Holds account level context information used to determine settlement and\\n/// free collateral actions. Total storage is 28 bytes\\nstruct AccountContext {\\n    // Used to check when settlement must be triggered on an account\\n    uint40 nextSettleTime;\\n    // For lenders that never incur debt, we use this flag to skip the free collateral check.\\n    bytes1 hasDebt;\\n    // Length of the account's asset array\\n    uint8 assetArrayLength;\\n    // If this account has bitmaps set, this is the corresponding currency id\\n    uint16 bitmapCurrencyId;\\n    // 9 total active currencies possible (2 bytes each)\\n    bytes18 activeCurrencies;\\n    // If this is set to true, the account can borrow variable prime cash and incur\\n    // negative cash balances inside BatchAction. This does not impact the settlement\\n    // of negative fCash to prime cash which will happen regardless of this setting. This\\n    // exists here mainly as a safety setting to ensure that accounts do not accidentally\\n    // incur negative cash balances.\\n    bool allowPrimeBorrow;\\n}\\n\\n/// @dev Holds nToken context information mapped via the nToken address, total storage is\\n/// 16 bytes\\nstruct nTokenContext {\\n    // Currency id that the nToken represents\\n    uint16 currencyId;\\n    // Annual incentive emission rate denominated in WHOLE TOKENS (multiply by\\n    // INTERNAL_TOKEN_PRECISION to get the actual rate)\\n    uint32 incentiveAnnualEmissionRate;\\n    // The last block time at utc0 that the nToken was initialized at, zero if it\\n    // has never been initialized\\n    uint32 lastInitializedTime;\\n    // Length of the asset array, refers to the number of liquidity tokens an nToken\\n    // currently holds\\n    uint8 assetArrayLength;\\n    // Each byte is a specific nToken parameter\\n    bytes6 nTokenParameters;\\n    // Reserved bytes for future usage\\n    bytes14 _unused;\\n    // Set to true if a secondary rewarder is set\\n    bool hasSecondaryRewarder;\\n}\\n\\n/// @dev Holds account balance information, total storage 32 bytes\\nstruct BalanceStorage {\\n    // Number of nTokens held by the account\\n    uint80 nTokenBalance;\\n    // Last time the account claimed their nTokens\\n    uint32 lastClaimTime;\\n    // Incentives that the account no longer has a claim over\\n    uint56 accountIncentiveDebt;\\n    // Cash balance of the account\\n    int88 cashBalance;\\n}\\n\\n/// @dev Holds information about a settlement rate, total storage 25 bytes\\nstruct SettlementRateStorage {\\n    uint40 blockTime;\\n    uint128 settlementRate;\\n    uint8 underlyingDecimalPlaces;\\n}\\n\\n/// @dev Holds information about a market, total storage is 42 bytes so this spans\\n/// two storage words\\nstruct MarketStorage {\\n    // Total fCash in the market\\n    uint80 totalfCash;\\n    // Total asset cash in the market\\n    uint80 totalPrimeCash;\\n    // Last annualized interest rate the market traded at\\n    uint32 lastImpliedRate;\\n    // Last recorded oracle rate for the market\\n    uint32 oracleRate;\\n    // Last time a trade was made\\n    uint32 previousTradeTime;\\n    // This is stored in slot + 1\\n    uint80 totalLiquidity;\\n}\\n\\nstruct InterestRateParameters {\\n    // First kink for the utilization rate in RATE_PRECISION\\n    uint256 kinkUtilization1;\\n    // Second kink for the utilization rate in RATE_PRECISION\\n    uint256 kinkUtilization2;\\n    // First kink interest rate in RATE_PRECISION\\n    uint256 kinkRate1;\\n    // Second kink interest rate in RATE_PRECISION\\n    uint256 kinkRate2;\\n    // Max interest rate in RATE_PRECISION\\n    uint256 maxRate;\\n    // Minimum fee charged in RATE_PRECISION\\n    uint256 minFeeRate;\\n    // Maximum fee charged in RATE_PRECISION\\n    uint256 maxFeeRate;\\n    // Percentage of the interest rate that will be applied as a fee\\n    uint256 feeRatePercent;\\n}\\n\\n// Specific interest rate curve settings for each market\\nstruct InterestRateCurveSettings {\\n    // First kink for the utilization rate, specified as a percentage\\n    // between 1-100\\n    uint8 kinkUtilization1;\\n    // Second kink for the utilization rate, specified as a percentage\\n    // between 1-100\\n    uint8 kinkUtilization2;\\n    // Interest rate at the first kink, set as 1/256 units from the kink\\n    // rate max\\n    uint8 kinkRate1;\\n    // Interest rate at the second kink, set as 1/256 units from the kink\\n    // rate max\\n    uint8 kinkRate2;\\n    // Max interest rate, set in units in 25bps increments less than or equal to 150\\n    // and 150bps increments from 151 to 255.\\n    uint8 maxRateUnits;\\n    // Minimum fee charged in basis points\\n    uint8 minFeeRate5BPS;\\n    // Maximum fee charged in basis points\\n    uint8 maxFeeRate25BPS;\\n    // Percentage of the interest rate that will be applied as a fee\\n    uint8 feeRatePercent;\\n}\\n\\nstruct ifCashStorage {\\n    // Notional amount of fCash at the slot, limited to int128 to allow for\\n    // future expansion\\n    int128 notional;\\n}\\n\\n/// @dev A single portfolio asset in storage, total storage of 19 bytes\\nstruct PortfolioAssetStorage {\\n    // Currency Id for the asset\\n    uint16 currencyId;\\n    // Maturity of the asset\\n    uint40 maturity;\\n    // Asset type (fCash or Liquidity Token marker)\\n    uint8 assetType;\\n    // Notional\\n    int88 notional;\\n}\\n\\n/// @dev nToken total supply factors for the nToken, includes factors related\\n/// to claiming incentives, total storage 32 bytes. This is the deprecated version\\nstruct nTokenTotalSupplyStorage_deprecated {\\n    // Total supply of the nToken\\n    uint96 totalSupply;\\n    // Integral of the total supply used for calculating the average total supply\\n    uint128 integralTotalSupply;\\n    // Last timestamp the supply value changed, used for calculating the integralTotalSupply\\n    uint32 lastSupplyChangeTime;\\n}\\n\\n/// @dev nToken total supply factors for the nToken, includes factors related\\n/// to claiming incentives, total storage 32 bytes.\\nstruct nTokenTotalSupplyStorage {\\n    // Total supply of the nToken\\n    uint96 totalSupply;\\n    // How many NOTE incentives should be issued per nToken in 1e18 precision\\n    uint128 accumulatedNOTEPerNToken;\\n    // Last timestamp when the accumulation happened\\n    uint32 lastAccumulatedTime;\\n}\\n\\n/// @dev Used in view methods to return account balances in a developer friendly manner\\nstruct AccountBalance {\\n    uint16 currencyId;\\n    int256 cashBalance;\\n    int256 nTokenBalance;\\n    uint256 lastClaimTime;\\n    uint256 accountIncentiveDebt;\\n}\\n\\nstruct VaultConfigParams {\\n    uint16 flags;\\n    uint16 borrowCurrencyId;\\n    uint256 minAccountBorrowSize;\\n    uint16 minCollateralRatioBPS;\\n    uint8 feeRate5BPS;\\n    uint8 liquidationRate;\\n    uint8 reserveFeeShare;\\n    uint8 maxBorrowMarketIndex;\\n    uint16 maxDeleverageCollateralRatioBPS;\\n    uint16[2] secondaryBorrowCurrencies;\\n    uint16 maxRequiredAccountCollateralRatioBPS;\\n    uint256[2] minAccountSecondaryBorrow;\\n    uint8 excessCashLiquidationBonus;\\n}\\n\\nstruct VaultConfigStorage {\\n    // Vault Flags (documented in VaultConfiguration.sol)\\n    uint16 flags;\\n    // Primary currency the vault borrows in\\n    uint16 borrowCurrencyId;\\n    // Specified in whole tokens in 1e8 precision, allows a 4.2 billion min borrow size\\n    uint32 minAccountBorrowSize;\\n    // Minimum collateral ratio for a vault specified in basis points, valid values are greater than 10_000\\n    // where the largest minimum collateral ratio is 65_536 which is much higher than anything reasonable.\\n    uint16 minCollateralRatioBPS;\\n    // Allows up to a 12.75% annualized fee\\n    uint8 feeRate5BPS;\\n    // A percentage that represents the share of the cash raised that will go to the liquidator\\n    uint8 liquidationRate;\\n    // A percentage of the fee given to the protocol\\n    uint8 reserveFeeShare;\\n    // Maximum market index where a vault can borrow from\\n    uint8 maxBorrowMarketIndex;\\n    // Maximum collateral ratio that a liquidator can push a an account to during deleveraging\\n    uint16 maxDeleverageCollateralRatioBPS;\\n    // An optional list of secondary borrow currencies\\n    uint16[2] secondaryBorrowCurrencies;\\n    // Required collateral ratio for accounts to stay inside a vault, prevents accounts\\n    // from \\\"free riding\\\" on vaults. Enforced on entry and exit, not on deleverage.\\n    uint16 maxRequiredAccountCollateralRatioBPS;\\n    // Specified in whole tokens in 1e8 precision, allows a 4.2 billion min borrow size\\n    uint32[2] minAccountSecondaryBorrow;\\n    // Specified as a percent discount off the exchange rate of the excess cash that will be paid to\\n    // the liquidator during liquidateExcessVaultCash\\n    uint8 excessCashLiquidationBonus;\\n    // 8 bytes left\\n}\\n\\nstruct VaultBorrowCapacityStorage {\\n    // Total fCash across all maturities that caps the borrow capacity\\n    uint80 maxBorrowCapacity;\\n    // Total fCash debt across all maturities\\n    uint80 totalfCashDebt;\\n}\\n\\nstruct VaultAccountSecondaryDebtShareStorage {\\n    // Maturity for the account's secondary borrows. This is stored separately from\\n    // the vault account maturity to ensure that we have access to the proper state\\n    // during a roll borrow position. It should never be allowed to deviate from the\\n    // vaultAccount.maturity value (unless it is cleared to zero).\\n    uint40 maturity;\\n    // Account debt for the first secondary currency in either fCash or pCash denomination\\n    uint80 accountDebtOne;\\n    // Account debt for the second secondary currency in either fCash or pCash denomination\\n    uint80 accountDebtTwo;\\n}\\n\\nstruct VaultConfig {\\n    address vault;\\n    uint16 flags;\\n    uint16 borrowCurrencyId;\\n    int256 minAccountBorrowSize;\\n    int256 feeRate;\\n    int256 minCollateralRatio;\\n    int256 liquidationRate;\\n    int256 reserveFeeShare;\\n    uint256 maxBorrowMarketIndex;\\n    int256 maxDeleverageCollateralRatio;\\n    uint16[2] secondaryBorrowCurrencies;\\n    PrimeRate primeRate;\\n    int256 maxRequiredAccountCollateralRatio;\\n    int256[2] minAccountSecondaryBorrow;\\n    int256 excessCashLiquidationBonus;\\n}\\n\\n/// @notice Represents a Vault's current borrow and collateral state\\nstruct VaultStateStorage {\\n    // This represents the total amount of borrowing in the vault for the current\\n    // vault term. If the vault state is the prime cash maturity, this is stored in\\n    // prime cash debt denomination, if fCash then it is stored in internal underlying.\\n    uint80 totalDebt;\\n    // The total amount of prime cash in the pool held as a result of emergency settlement\\n    uint80 deprecated_totalPrimeCash;\\n    // Total vault shares in this maturity\\n    uint80 totalVaultShares;\\n    // Set to true if a vault's debt position has been migrated to the prime cash vault\\n    bool isSettled;\\n    // NOTE: 8 bits left\\n    // ----- This breaks into a new storage slot -------    \\n    // The total amount of strategy tokens held in the pool\\n    uint80 deprecated_totalStrategyTokens;\\n    // Valuation of a strategy token at settlement\\n    int80 deprecated_settlementStrategyTokenValue;\\n    // NOTE: 96 bits left\\n}\\n\\n/// @notice Represents the remaining assets in a vault post settlement\\nstruct Deprecated_VaultSettledAssetsStorage {\\n    // Remaining strategy tokens that have not been withdrawn\\n    uint80 remainingStrategyTokens;\\n    // Remaining asset cash that has not been withdrawn\\n    int80 remainingPrimeCash;\\n}\\n\\nstruct VaultState {\\n    uint256 maturity;\\n    // Total debt is always denominated in underlying on the stack\\n    int256 totalDebtUnderlying;\\n    uint256 totalVaultShares;\\n    bool isSettled;\\n}\\n\\n/// @notice Represents an account's position within an individual vault\\nstruct VaultAccountStorage {\\n    // Total amount of debt for the account in the primary borrowed currency.\\n    // If the account is borrowing prime cash, this is stored in prime cash debt\\n    // denomination, if fCash then it is stored in internal underlying.\\n    uint80 accountDebt;\\n    // Vault shares that the account holds\\n    uint80 vaultShares;\\n    // Maturity when the vault shares and fCash will mature\\n    uint40 maturity;\\n    // Last time when a vault was entered or exited, used to ensure that vault accounts do not\\n    // flash enter/exit. While there is no specified attack vector here, we can use it to prevent\\n    // an entire class of attacks from happening without reducing UX.\\n    // NOTE: in the original version this value was set to the block.number, however, in this\\n    // version it is being changed to time based. On ETH mainnet block heights are much smaller\\n    // than block times, accounts that migrate from lastEntryBlockHeight => lastUpdateBlockTime\\n    // will not see any issues with entering / exiting the protocol.\\n    uint32 lastUpdateBlockTime;\\n    // ----------------  Second Storage Slot ----------------------\\n    // Cash balances held by the vault account as a result of lending at zero interest or due\\n    // to deleveraging (liquidation). In the previous version of leveraged vaults, accounts would\\n    // simply lend at zero interest which was not a problem. However, with vaults being able to\\n    // discount fCash to present value, lending at zero percent interest may have an adverse effect\\n    // on the account's collateral position (i.e. lending at zero puts them further into danger).\\n    // Holding cash against debt will eliminate that risk, making vault liquidation more similar to\\n    // regular Notional liquidation.\\n    uint80 primaryCash;\\n    uint80 secondaryCashOne;\\n    uint80 secondaryCashTwo;\\n}\\n\\nstruct VaultAccount {\\n    // On the stack, account debts are always in underlying\\n    int256 accountDebtUnderlying;\\n    uint256 maturity;\\n    uint256 vaultShares;\\n    address account;\\n    // This cash balance is used just within a transaction to track deposits\\n    // and withdraws for an account. Must be zeroed by the time we store the account\\n    int256 tempCashBalance;\\n    uint256 lastUpdateBlockTime;\\n}\\n\\n// Used to hold vault account liquidation factors in memory\\nstruct VaultAccountHealthFactors {\\n    // Account's calculated collateral ratio\\n    int256 collateralRatio;\\n    // Total outstanding debt across all borrowed currencies in primary\\n    int256 totalDebtOutstandingInPrimary;\\n    // Total value of vault shares in underlying denomination\\n    int256 vaultShareValueUnderlying;\\n    // Debt outstanding in local currency denomination after present value and\\n    // account cash held netting applied. Can be positive if the account holds cash\\n    // in excess of debt.\\n    int256[3] netDebtOutstanding;\\n}\\n\\n// PrimeCashInterestRateParameters take up 16 bytes, this takes up 32 bytes so we\\n// can expand another 16 bytes to increase the storage slots a bit....\\nstruct PrimeCashFactorsStorage {\\n    // Storage slot 1 [Prime Supply Factors, 248 bytes]\\n    uint40 lastAccrueTime;\\n    uint88 totalPrimeSupply;\\n    uint88 lastTotalUnderlyingValue;\\n    // Overflows at 429% interest using RATE_PRECISION\\n    uint32 oracleSupplyRate;\\n    bool allowDebt;\\n\\n    // Storage slot 2 [Prime Debt Factors, 256 bytes]\\n    uint88 totalPrimeDebt;\\n    // Each one of these values below is stored as a FloatingPoint32 value which\\n    // gives us approx 7 digits of precision for each value. Because these are used\\n    // to maintain supply and borrow caps, they are not required to be exact.\\n    uint32 maxUnderlyingSupply;\\n    // The maximum utilization that prime debt is allowed to reach by users borrowing prime\\n    // debt via the markets directly. This cap is not applied to liquidations and settlement.\\n    uint8 maxPrimeDebtUtilization;\\n    uint120 _reserved;\\n    // Reserving the next 128 bytes for future use in case we decide to implement debt\\n    // caps on a currency. In that case, we will need to track the total fcash overall\\n    // and subtract the total debt held in vaults.\\n    // uint32 maxUnderlyingDebt;\\n    // uint32 totalfCashDebtOverall;\\n    // uint32 totalfCashDebtInVaults;\\n    // uint32 totalPrimeDebtInVaults;\\n    // 8 bytes left\\n    \\n    // Storage slot 3 [Prime Scalars, 240 bytes]\\n    // Scalars are stored in 18 decimal precision (i.e. double rate precision) and uint80\\n    // maxes out at approx 1,210,000e18\\n    // ln(1,210,000) = rate * years = 14\\n    // Approx 46 years at 30% interest\\n    // Approx 233 years at 6% interest\\n    uint80 underlyingScalar;\\n    uint80 supplyScalar;\\n    uint80 debtScalar;\\n    // The time window in 5 min increments that the rate oracle will be averaged over\\n    uint8 rateOracleTimeWindow5Min;\\n    // 8 bytes left\\n}\\n\\nstruct PrimeCashFactors {\\n    uint256 lastAccrueTime;\\n    uint256 totalPrimeSupply;\\n    uint256 totalPrimeDebt;\\n    uint256 oracleSupplyRate;\\n    uint256 lastTotalUnderlyingValue;\\n    uint256 underlyingScalar;\\n    uint256 supplyScalar;\\n    uint256 debtScalar;\\n    uint256 rateOracleTimeWindow;\\n}\\n\\nstruct PrimeRate {\\n    int256 supplyFactor;\\n    int256 debtFactor;\\n    uint256 oracleSupplyRate;\\n}\\n\\nstruct PrimeSettlementRateStorage {\\n    uint80 supplyScalar;\\n    uint80 debtScalar;\\n    uint80 underlyingScalar;\\n    bool isSet;\\n}\\n\\nstruct PrimeCashHoldingsOracle {\\n   IPrimeCashHoldingsOracle oracle; \\n}\\n\\n// Per currency rebalancing context\\nstruct RebalancingContextStorage {\\n    // Holds the previous supply factor to calculate the oracle money market rate\\n    uint128 previousSupplyFactorAtRebalance;\\n    // Rebalancing has a cool down period that sets the time averaging of the oracle money market rate\\n    uint40 rebalancingCooldownInSeconds;\\n    uint40 lastRebalanceTimestampInSeconds;\\n    // 48 bytes left\\n}\\n\\nstruct TotalfCashDebtStorage {\\n    uint80 totalfCashDebt;\\n    // These two variables are used to track fCash lend at zero\\n    // edge conditions for leveraged vaults.\\n    uint80 fCashDebtHeldInSettlementReserve;\\n    uint80 primeCashHeldInSettlementReserve;\\n}\\n\\nstruct RebalancingTargetData {\\n    uint8 targetUtilization;\\n    uint16 externalWithdrawThreshold;\\n}\"\r\n    },\r\n    \"contracts/internal/AccountContextHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {AccountContext, LibStorage} from \\\"../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../global/Constants.sol\\\";\\nimport {PortfolioState, PortfolioAsset} from \\\"../global/Types.sol\\\";\\nimport {DateTime} from \\\"./markets/DateTime.sol\\\";\\nimport {PrimeCashExchangeRate} from \\\"./pCash/PrimeCashExchangeRate.sol\\\";\\nimport {PortfolioHandler} from \\\"./portfolio/PortfolioHandler.sol\\\";\\nimport {SafeInt256} from \\\"../math/SafeInt256.sol\\\";\\n\\nlibrary AccountContextHandler {\\n    using SafeInt256 for int256;\\n    using PortfolioHandler for PortfolioState;\\n\\n    bytes18 private constant TURN_OFF_PORTFOLIO_FLAGS = 0x7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF7FFF;\\n    event AccountContextUpdate(address indexed account);\\n\\n    /// @notice Returns the account context of a given account\\n    function getAccountContext(address account) internal view returns (AccountContext memory) {\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\n        return store[account];\\n    }\\n\\n    /// @notice Sets the account context of a given account\\n    function setAccountContext(AccountContext memory accountContext, address account) internal {\\n        mapping(address => AccountContext) storage store = LibStorage.getAccountStorage();\\n        store[account] = accountContext;\\n        emit AccountContextUpdate(account);\\n    }\\n\\n    function isBitmapEnabled(AccountContext memory accountContext) internal pure returns (bool) {\\n        return accountContext.bitmapCurrencyId != 0;\\n    }\\n\\n    /// @notice Enables a bitmap type portfolio for an account. A bitmap type portfolio allows\\n    /// an account to hold more fCash than a normal portfolio, except only in a single currency.\\n    /// Once enabled, it cannot be disabled or changed. An account can only enable a bitmap if\\n    /// it has no assets or debt so that we ensure no assets are left stranded.\\n    /// @param accountContext refers to the account where the bitmap will be enabled\\n    /// @param currencyId the id of the currency to enable\\n    /// @param blockTime the current block time to set the next settle time\\n    function enableBitmapForAccount(\\n        AccountContext memory accountContext,\\n        uint16 currencyId,\\n        uint256 blockTime\\n    ) internal pure {\\n        require(!isBitmapEnabled(accountContext), \\\"Cannot change bitmap\\\");\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES, \\\"Invalid currency id\\\");\\n\\n        // Account cannot have assets or debts\\n        require(accountContext.assetArrayLength == 0, \\\"Cannot have assets\\\");\\n        require(accountContext.hasDebt == 0x00, \\\"Cannot have debt\\\");\\n\\n        // Ensure that the active currency is set to false in the array so that there is no double\\n        // counting during FreeCollateral\\n        setActiveCurrency(accountContext, currencyId, false, Constants.ACTIVE_IN_BALANCES);\\n        accountContext.bitmapCurrencyId = currencyId;\\n\\n        // Setting this is required to initialize the assets bitmap\\n        uint256 nextSettleTime = DateTime.getTimeUTC0(blockTime);\\n        require(nextSettleTime < type(uint40).max); // dev: blockTime overflow\\n        accountContext.nextSettleTime = uint40(nextSettleTime);\\n    }\\n\\n    /// @notice Returns true if the context needs to settle\\n    function mustSettleAssets(AccountContext memory accountContext) internal view returns (bool) {\\n        uint256 blockTime = block.timestamp;\\n\\n        if (isBitmapEnabled(accountContext)) {\\n            // nextSettleTime will be set to utc0 after settlement so we\\n            // settle if this is strictly less than utc0\\n            return accountContext.nextSettleTime < DateTime.getTimeUTC0(blockTime);\\n        } else {\\n            // 0 value occurs on an uninitialized account\\n            // Assets mature exactly on the blockTime (not one second past) so in this\\n            // case we settle on the block timestamp\\n            return 0 < accountContext.nextSettleTime && accountContext.nextSettleTime <= blockTime;\\n        }\\n    }\\n\\n    /// @notice Checks if a currency id (uint16 max) is in the 9 slots in the account\\n    /// context active currencies list.\\n    /// @dev NOTE: this may be more efficient as a binary search since we know that the array\\n    /// is sorted\\n    function isActiveInBalances(AccountContext memory accountContext, uint256 currencyId)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        require(currencyId != 0 && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\n        bytes18 currencies = accountContext.activeCurrencies;\\n\\n        if (accountContext.bitmapCurrencyId == currencyId) return true;\\n\\n        while (currencies != 0x00) {\\n            uint256 cid = uint16(bytes2(currencies) & Constants.UNMASK_FLAGS);\\n            if (cid == currencyId) {\\n                // Currency found, return if it is active in balances or not\\n                return bytes2(currencies) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES;\\n            }\\n\\n            currencies = currencies << 16;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Iterates through the active currency list and removes, inserts or does nothing\\n    /// to ensure that the active currency list is an ordered byte array of uint16 currency ids\\n    /// that refer to the currencies that an account is active in.\\n    ///\\n    /// This is called to ensure that currencies are active when the account has a non zero cash balance,\\n    /// a non zero nToken balance or a portfolio asset.\\n    function setActiveCurrency(\\n        AccountContext memory accountContext,\\n        uint256 currencyId,\\n        bool isActive,\\n        bytes2 flags\\n    ) internal pure {\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\n\\n        // If the bitmapped currency is already set then return here. Turning off the bitmap currency\\n        // id requires other logical handling so we will do it elsewhere.\\n        if (isActive && accountContext.bitmapCurrencyId == currencyId) return;\\n\\n        bytes18 prefix;\\n        bytes18 suffix = accountContext.activeCurrencies;\\n        uint256 shifts;\\n\\n        /// There are six possible outcomes from this search:\\n        /// 1. The currency id is in the list\\n        ///      - it must be set to active, do nothing\\n        ///      - it must be set to inactive, shift suffix and concatenate\\n        /// 2. The current id is greater than the one in the search:\\n        ///      - it must be set to active, append to prefix and then concatenate the suffix,\\n        ///        ensure that we do not lose the last 2 bytes if set.\\n        ///      - it must be set to inactive, it is not in the list, do nothing\\n        /// 3. Reached the end of the list:\\n        ///      - it must be set to active, check that the last two bytes are not set and then\\n        ///        append to the prefix\\n        ///      - it must be set to inactive, do nothing\\n        while (suffix != 0x00) {\\n            uint256 cid = uint256(uint16(bytes2(suffix) & Constants.UNMASK_FLAGS));\\n            // if matches and isActive then return, already in list\\n            if (cid == currencyId && isActive) {\\n                // set flag and return\\n                accountContext.activeCurrencies =\\n                    accountContext.activeCurrencies |\\n                    (bytes18(flags) >> (shifts * 16));\\n                return;\\n            }\\n\\n            // if matches and not active then shift suffix to remove\\n            if (cid == currencyId && !isActive) {\\n                // turn off flag, if both flags are off then remove\\n                suffix = suffix & ~bytes18(flags);\\n                if (bytes2(suffix) & ~Constants.UNMASK_FLAGS == 0x0000) suffix = suffix << 16;\\n                accountContext.activeCurrencies = prefix | (suffix >> (shifts * 16));\\n                return;\\n            }\\n\\n            // if greater than and isActive then insert into prefix\\n            if (cid > currencyId && isActive) {\\n                prefix = prefix | (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\n                // check that the total length is not greater than 9, meaning that the last\\n                // two bytes of the active currencies array should be zero\\n                require((accountContext.activeCurrencies << 128) == 0x00); // dev: AC: too many currencies\\n\\n                // append the suffix\\n                accountContext.activeCurrencies = prefix | (suffix >> ((shifts + 1) * 16));\\n                return;\\n            }\\n\\n            // if past the point of the currency id and not active, not in list\\n            if (cid > currencyId && !isActive) return;\\n\\n            prefix = prefix | (bytes18(bytes2(suffix)) >> (shifts * 16));\\n            suffix = suffix << 16;\\n            shifts += 1;\\n        }\\n\\n        // If reached this point and not active then return\\n        if (!isActive) return;\\n\\n        // if end and isActive then insert into suffix, check max length\\n        require(shifts < 9); // dev: AC: too many currencies\\n        accountContext.activeCurrencies =\\n            prefix |\\n            (bytes18(bytes2(uint16(currencyId)) | flags) >> (shifts * 16));\\n    }\\n\\n    function _clearPortfolioActiveFlags(bytes18 activeCurrencies) internal pure returns (bytes18) {\\n        bytes18 result;\\n        // This is required to clear the suffix as we append below\\n        bytes18 suffix = activeCurrencies & TURN_OFF_PORTFOLIO_FLAGS;\\n        uint256 shifts;\\n\\n        // This loop will append all currencies that are active in balances into the result.\\n        while (suffix != 0x00) {\\n            if (bytes2(suffix) & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {\\n                // If any flags are active, then append.\\n                result = result | (bytes18(bytes2(suffix)) >> shifts);\\n                shifts += 16;\\n            }\\n            suffix = suffix << 16;\\n        }\\n\\n        return result;\\n    }\\n\\n    function storeAssetsAndUpdateContextForSettlement(\\n        AccountContext memory accountContext,\\n        address account,\\n        PortfolioState memory portfolioState\\n    ) internal {\\n        // During settlement, we do not update fCash debt outstanding\\n        _storeAssetsAndUpdateContext(accountContext, account, portfolioState);\\n    }\\n\\n    function storeAssetsAndUpdateContext(\\n        AccountContext memory accountContext,\\n        address account,\\n        PortfolioState memory portfolioState\\n    ) internal {\\n        (\\n            PortfolioAsset[] memory initialPortfolio,\\n            uint256[] memory initialIds\\n        ) = PortfolioHandler.getSortedPortfolioWithIds(\\n            account,\\n            accountContext.assetArrayLength\\n        );\\n\\n        _storeAssetsAndUpdateContext(accountContext, account, portfolioState);\\n\\n        (\\n            PortfolioAsset[] memory finalPortfolio,\\n            uint256[] memory finalIds\\n        ) = PortfolioHandler.getSortedPortfolioWithIds(\\n            account,\\n            accountContext.assetArrayLength\\n        );\\n\\n        uint256 i = 0; // initial counter\\n        uint256 f = 0; // final counter\\n        while (i < initialPortfolio.length || f < finalPortfolio.length) {\\n            // Use uint256.max to signify that the end of the array has been reached. The max\\n            // id space is much less than this, so any elements in the other array will trigger\\n            // the proper if condition. Based on the while condition above, one of iID or fID\\n            // will be a valid portfolio id.\\n            uint256 iID = i < initialIds.length ? initialIds[i] : type(uint256).max;\\n            uint256 fID = f < finalIds.length ? finalIds[f] : type(uint256).max;\\n\\n            // Inside this loop, it is guaranteed that there are no duplicate ids within\\n            // initialIds and finalIds. Therefore, we are looking for one of three possibilities:\\n            //  - iID == fID\\n            //  - iID is not in finalIds (deleted)\\n            //  - fID is not in initialIds (added)\\n            if (iID == fID) {\\n                // if id[i] == id[j] and both fCash, compare debt\\n                if (initialPortfolio[i].assetType == Constants.FCASH_ASSET_TYPE) {\\n                    PrimeCashExchangeRate.updateTotalfCashDebtOutstanding(\\n                        account,\\n                        initialPortfolio[i].currencyId,\\n                        initialPortfolio[i].maturity,\\n                        initialPortfolio[i].notional,\\n                        finalPortfolio[f].notional\\n                    );\\n                }\\n                i = i == initialIds.length ? i : i + 1;\\n                f = f == finalIds.length ? f : f + 1;\\n            } else if (iID < fID) {\\n                // Initial asset deleted\\n                if (initialPortfolio[i].assetType == Constants.FCASH_ASSET_TYPE) {\\n                    PrimeCashExchangeRate.updateTotalfCashDebtOutstanding(\\n                        account,\\n                        initialPortfolio[i].currencyId,\\n                        initialPortfolio[i].maturity,\\n                        initialPortfolio[i].notional,\\n                        0 // asset deleted, final notional is zero\\n                    );\\n                }\\n                i = i == initialIds.length ? i : i + 1;\\n            } else if (fID < iID) {\\n                // Final asset added\\n                if (finalPortfolio[f].assetType == Constants.FCASH_ASSET_TYPE) {\\n                    PrimeCashExchangeRate.updateTotalfCashDebtOutstanding(\\n                        account,\\n                        finalPortfolio[f].currencyId,\\n                        finalPortfolio[f].maturity,\\n                        0, // asset added, initial notional is zero\\n                        finalPortfolio[f].notional\\n                    );\\n                }\\n                f = f == finalIds.length ? f : f + 1;\\n            }\\n        }\\n    }\\n\\n    /// @notice Stores a portfolio array and updates the account context information, this method should\\n    /// be used whenever updating a portfolio array except in the case of nTokens\\n    function _storeAssetsAndUpdateContext(\\n        AccountContext memory accountContext,\\n        address account,\\n        PortfolioState memory portfolioState\\n    ) private {\\n        // Each of these parameters is recalculated based on the entire array of assets in store assets,\\n        // regardless of whether or not they have been updated.\\n        (bool hasDebt, bytes32 portfolioCurrencies, uint8 assetArrayLength, uint40 nextSettleTime) =\\n            portfolioState.storeAssets(account);\\n        accountContext.nextSettleTime = nextSettleTime;\\n        require(mustSettleAssets(accountContext) == false); // dev: cannot store matured assets\\n        accountContext.assetArrayLength = assetArrayLength;\\n        require(assetArrayLength <= uint8(LibStorage.MAX_PORTFOLIO_ASSETS)); // dev: max assets allowed\\n\\n        // Sets the hasDebt flag properly based on whether or not portfolio has asset debt, meaning\\n        // a negative fCash balance.\\n        if (hasDebt) {\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\n        } else {\\n            // Turns off the ASSET_DEBT flag\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_ASSET_DEBT;\\n        }\\n\\n        // Clear the active portfolio active flags and they will be recalculated in the next step\\n        accountContext.activeCurrencies = _clearPortfolioActiveFlags(accountContext.activeCurrencies);\\n\\n        uint256 lastCurrency;\\n        while (portfolioCurrencies != 0) {\\n            // Portfolio currencies will not have flags, it is just an byte array of all the currencies found\\n            // in a portfolio. They are appended in a sorted order so we can compare to the previous currency\\n            // and only set it if they are different.\\n            uint256 currencyId = uint16(bytes2(portfolioCurrencies));\\n            if (currencyId != lastCurrency) {\\n                setActiveCurrency(accountContext, currencyId, true, Constants.ACTIVE_IN_PORTFOLIO);\\n            }\\n            lastCurrency = currencyId;\\n\\n            portfolioCurrencies = portfolioCurrencies << 16;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/balances/BalanceHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    BalanceState,\\n    BalanceStorage,\\n    SettleAmount,\\n    TokenType,\\n    AccountContext,\\n    PrimeRate,\\n    Token\\n} from \\\"../../global/Types.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {FloatingPoint} from \\\"../../math/FloatingPoint.sol\\\";\\n\\nimport {Emitter} from \\\"../Emitter.sol\\\";\\nimport {nTokenHandler} from \\\"../nToken/nTokenHandler.sol\\\";\\nimport {AccountContextHandler} from \\\"../AccountContextHandler.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {PrimeSupplyCap} from \\\"../pCash/PrimeSupplyCap.sol\\\";\\nimport {PrimeCashExchangeRate} from \\\"../pCash/PrimeCashExchangeRate.sol\\\";\\n\\nimport {TokenHandler} from \\\"./TokenHandler.sol\\\";\\nimport {Incentives} from \\\"./Incentives.sol\\\";\\n\\nlibrary BalanceHandler {\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n    using TokenHandler for Token;\\n    using AccountContextHandler for AccountContext;\\n    using PrimeRateLib for PrimeRate;\\n    using PrimeSupplyCap for PrimeRate;\\n\\n    /// @notice Emitted when reserve balance is updated\\n    event ReserveBalanceUpdated(uint16 indexed currencyId, int256 newBalance);\\n    /// @notice Emitted when reserve balance is harvested\\n    event ExcessReserveBalanceHarvested(uint16 indexed currencyId, int256 harvestAmount);\\n\\n    /// @notice Exists to maintain compatibility for asset token deposits that existed before\\n    /// prime cash. After prime cash, Notional will no longer list new asset cash tokens. Asset\\n    /// cash listed prior to the prime cash migration will be redeemed immediately to underlying\\n    /// and this method will return how much underlying that represents.\\n    function depositDeprecatedAssetToken(\\n        BalanceState memory balanceState,\\n        address account,\\n        int256 assetAmountExternal\\n    ) internal returns (int256 primeCashDeposited) {\\n        if (assetAmountExternal == 0) return 0;\\n        require(assetAmountExternal > 0); // dev: deposit asset token amount negative\\n        Token memory assetToken = TokenHandler.getDeprecatedAssetToken(balanceState.currencyId);\\n        require(assetToken.tokenAddress != address(0));\\n\\n        // Aave tokens will not be listed prior to the prime cash migration, if NonMintable tokens\\n        // are minted then assetTokenTransferred is the underlying.\\n        if (\\n            assetToken.tokenType == TokenType.cToken ||\\n            assetToken.tokenType == TokenType.cETH\\n        ) {\\n            primeCashDeposited = assetToken.depositDeprecatedAssetToken(\\n                balanceState.currencyId,\\n                // Overflow checked above\\n                uint256(assetAmountExternal),\\n                account,\\n                balanceState.primeRate\\n            );\\n            balanceState.netCashChange = balanceState.netCashChange.add(primeCashDeposited);\\n        } else if (assetToken.tokenType == TokenType.NonMintable) {\\n            // In this case, no redemption is necessary and the non mintable token maps\\n            // 1-1 with the underlying token. Deprecated non-mintable tokens will never be ETH so\\n            // the returnExcessWrapped flag is set to false.\\n            primeCashDeposited = depositUnderlyingToken(balanceState, account, assetAmountExternal, false);\\n        } else {\\n            revert();\\n        }\\n    }\\n\\n    /// @notice Marks some amount of underlying token to be transferred. Transfers will be\\n    /// finalized inside _finalizeTransfer unless forceTransfer is set to true\\n    function depositUnderlyingToken(\\n        BalanceState memory balanceState,\\n        address account,\\n        int256 underlyingAmountExternal,\\n        bool returnExcessWrapped\\n    ) internal returns (int256 primeCashDeposited) {\\n        if (underlyingAmountExternal == 0) return 0;\\n        require(underlyingAmountExternal > 0); // dev: deposit underlying token negative\\n\\n        // Transfer the tokens and credit the balance state with the\\n        // amount of prime cash deposited.\\n        (/* actualTransfer */, primeCashDeposited) = TokenHandler.depositUnderlyingExternal(\\n            account,\\n            balanceState.currencyId,\\n            underlyingAmountExternal,\\n            balanceState.primeRate,\\n            returnExcessWrapped // if true, returns any excess ETH as WETH\\n        );\\n        balanceState.netCashChange = balanceState.netCashChange.add(primeCashDeposited);\\n    }\\n\\n    /// @notice Finalize collateral liquidation, checkAllowPrimeBorrow is set to false to force\\n    /// a negative collateral cash balance if required.\\n    function finalizeCollateralLiquidation(\\n        BalanceState memory balanceState,\\n        address account,\\n        AccountContext memory accountContext\\n    ) internal {\\n        require(balanceState.primeCashWithdraw == 0);\\n        _finalize(balanceState, account, account, accountContext, false, false);\\n    }\\n\\n    /// @notice Calls finalize without any withdraws. Allows the withdrawWrapped flag to be hardcoded to false.\\n    function finalizeNoWithdraw(\\n        BalanceState memory balanceState,\\n        address account,\\n        AccountContext memory accountContext\\n    ) internal {\\n        require(balanceState.primeCashWithdraw == 0);\\n        _finalize(balanceState, account, account, accountContext, false, true);\\n    }\\n\\n    /// @notice Finalizes an account's balances with withdraws, returns the actual amount of underlying tokens transferred\\n    /// back to the account\\n    function finalizeWithWithdraw(\\n        BalanceState memory balanceState,\\n        address account,\\n        AccountContext memory accountContext,\\n        bool withdrawWrapped\\n    ) internal returns (int256 transferAmountExternal) {\\n        return _finalize(balanceState, account, account, accountContext, withdrawWrapped, true);\\n    }\\n\\n    /// @notice Finalizes an account's balances with withdraws, returns the actual amount of underlying tokens transferred\\n    /// back to the account\\n    function finalizeWithWithdrawReceiver(\\n        BalanceState memory balanceState,\\n        address account,\\n        address receiver,\\n        AccountContext memory accountContext,\\n        bool withdrawWrapped\\n    ) internal returns (int256 transferAmountExternal) {\\n        return _finalize(balanceState, account, receiver, accountContext, withdrawWrapped, true);\\n    }\\n\\n    /// @notice Finalizes an account's balances, handling any transfer logic required\\n    /// @dev This method SHOULD NOT be used for nToken accounts, for that use setBalanceStorageForNToken\\n    /// as the nToken is limited in what types of balances it can hold.\\n    function  _finalize(\\n        BalanceState memory balanceState,\\n        address account,\\n        address receiver,\\n        AccountContext memory accountContext,\\n        bool withdrawWrapped,\\n        bool checkAllowPrimeBorrow\\n    ) private returns (int256 transferAmountExternal) {\\n        bool mustUpdate;\\n        bool checkDebtCap;\\n\\n        // Transfer amount is checked inside finalize transfers in case when converting to external we\\n        // round down to zero. This returns the actual net transfer in internal precision as well.\\n        transferAmountExternal = TokenHandler.withdrawPrimeCash(\\n            account,\\n            receiver,\\n            balanceState.currencyId,\\n            balanceState.primeCashWithdraw,\\n            balanceState.primeRate,\\n            withdrawWrapped // if true, withdraws ETH as WETH\\n        );\\n\\n        {\\n            // No changes to total cash after this point\\n            int256 totalCashChange = balanceState.netCashChange.add(balanceState.primeCashWithdraw);\\n\\n            if (\\n                checkAllowPrimeBorrow &&\\n                totalCashChange < 0 &&\\n                balanceState.storedCashBalance.add(totalCashChange) < 0\\n            ) {\\n                // If the total cash change is negative and it causes the stored cash balance to become negative,\\n                // the account must allow prime debt. This is a safety check to ensure that accounts do not\\n                // accidentally borrow variable through a withdraw or a batch transaction.\\n                \\n                // Accounts can still incur negative cash during fCash settlement, that will bypass this check.\\n                \\n                // During liquidation, liquidated accounts can have a negative cash balance during negative local fCash\\n                // liquidation and a collateral liquidation and forces an interest rate swap. In the first case, \\n                // setBalanceStorageForfCashLiquidation is called instead of this method. In the second, this method\\n                // is called but checkAllowPrimeBorrow is set to false.\\n\\n                // During liquidation, liquidators may have negative net cash change a token has transfer fees, however, in\\n                // LiquidationHelpers.finalizeLiquidatorLocal they are not allowed to go into debt.\\n                require(accountContext.allowPrimeBorrow, \\\"No Prime Borrow\\\");\\n                checkDebtCap = true;\\n            }\\n\\n\\n            if (totalCashChange != 0) {\\n                balanceState.storedCashBalance = balanceState.storedCashBalance.add(totalCashChange);\\n                mustUpdate = true;\\n            }\\n        }\\n\\n        if (balanceState.netNTokenTransfer != 0 || balanceState.netNTokenSupplyChange != 0) {\\n            // Final nToken balance is used to calculate the account incentive debt\\n            int256 finalNTokenBalance = balanceState.storedNTokenBalance\\n                .add(balanceState.netNTokenTransfer)\\n                .add(balanceState.netNTokenSupplyChange);\\n            // Ensure that nToken balances never become negative\\n            require(finalNTokenBalance >= 0, \\\"Neg nToken\\\");\\n\\n            // overflow checked above\\n            Incentives.claimIncentives(balanceState, account, uint256(finalNTokenBalance));\\n            balanceState.storedNTokenBalance = finalNTokenBalance;\\n            mustUpdate = true;\\n        }\\n\\n        if (mustUpdate) {\\n            _setBalanceStorage(\\n                account,\\n                balanceState.currencyId,\\n                balanceState.storedCashBalance,\\n                balanceState.storedNTokenBalance,\\n                balanceState.lastClaimTime,\\n                balanceState.accountIncentiveDebt,\\n                balanceState.primeRate\\n            );\\n        }\\n\\n        accountContext.setActiveCurrency(\\n            balanceState.currencyId,\\n            // Set active currency to true if either balance is non-zero\\n            balanceState.storedCashBalance != 0 || balanceState.storedNTokenBalance != 0,\\n            Constants.ACTIVE_IN_BALANCES\\n        );\\n\\n        if (balanceState.storedCashBalance < 0) {\\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check where all balances\\n            // are examined\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\n        }\\n\\n        if (checkDebtCap) balanceState.primeRate.checkDebtCap(balanceState.currencyId);\\n    }\\n\\n    /**\\n     * @notice A special balance storage method for fCash liquidation to reduce the bytecode size.\\n     */\\n    function setBalanceStorageForfCashLiquidation(\\n        address account,\\n        AccountContext memory accountContext,\\n        uint16 currencyId,\\n        int256 netPrimeCashChange,\\n        PrimeRate memory primeRate\\n    ) internal {\\n        (int256 cashBalance, int256 nTokenBalance, uint256 lastClaimTime, uint256 accountIncentiveDebt) =\\n            getBalanceStorage(account, currencyId, primeRate);\\n\\n        int256 newCashBalance = cashBalance.add(netPrimeCashChange);\\n        // If a cash balance is negative already we cannot put an account further into debt. In this case\\n        // the netCashChange must be positive so that it is coming out of debt.\\n        if (newCashBalance < 0) {\\n            require(netPrimeCashChange > 0, \\\"Neg Cash\\\");\\n            // NOTE: HAS_CASH_DEBT cannot be extinguished except by a free collateral check\\n            // where all balances are examined. In this case the has cash debt flag should\\n            // already be set (cash balances cannot get more negative) but we do it again\\n            // here just to be safe.\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\n        }\\n\\n        bool isActive = newCashBalance != 0 || nTokenBalance != 0;\\n        accountContext.setActiveCurrency(currencyId, isActive, Constants.ACTIVE_IN_BALANCES);\\n\\n        _setBalanceStorage(\\n            account,\\n            currencyId,\\n            newCashBalance,\\n            nTokenBalance,\\n            lastClaimTime,\\n            accountIncentiveDebt,\\n            primeRate\\n        );\\n    }\\n\\n    /// @notice Helper method for settling the output of the SettleAssets method\\n    function finalizeSettleAmounts(\\n        address account,\\n        AccountContext memory accountContext,\\n        SettleAmount[] memory settleAmounts\\n    ) internal {\\n        // Mapping from account to its various currency stores\\n        mapping(uint256 => BalanceStorage) storage store = LibStorage.getBalanceStorage()[account];\\n\\n        for (uint256 i = 0; i < settleAmounts.length; i++) {\\n            SettleAmount memory amt = settleAmounts[i];\\n            if (amt.positiveSettledCash == 0 && amt.negativeSettledCash == 0) continue;\\n\\n            PrimeRate memory pr = settleAmounts[i].presentPrimeRate;\\n            BalanceStorage storage balanceStorage = store[amt.currencyId];\\n\\n            int256 previousCashBalance = pr.convertFromStorage(balanceStorage.cashBalance);\\n            int256 nTokenBalance = balanceStorage.nTokenBalance;\\n\\n            int256 newStoredCashBalance = pr.convertToStorageInSettlement(\\n                account,\\n                amt.currencyId,\\n                previousCashBalance,\\n                amt.positiveSettledCash,\\n                amt.negativeSettledCash\\n            );\\n            balanceStorage.cashBalance = newStoredCashBalance.toInt88();\\n\\n            accountContext.setActiveCurrency(\\n                amt.currencyId,\\n                newStoredCashBalance != 0 || nTokenBalance != 0,\\n                Constants.ACTIVE_IN_BALANCES\\n            );\\n\\n            if (newStoredCashBalance < 0) {\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_CASH_DEBT;\\n            }\\n        }\\n    }\\n\\n    /// @notice Special method for setting balance storage for nToken\\n    function setBalanceStorageForNToken(\\n        address nTokenAddress,\\n        uint16 currencyId,\\n        int256 cashBalance\\n    ) internal {\\n        _setPositiveCashBalance(nTokenAddress, currencyId, cashBalance);\\n    }\\n\\n    /// @notice Asses a fee or a refund to the nToken for leveraged vaults\\n    function incrementVaultFeeToNToken(uint16 currencyId, int256 fee) internal {\\n        require(fee >= 0); // dev: invalid fee\\n        address nTokenAddress = nTokenHandler.nTokenAddress(currencyId);\\n        int256 cashBalance = getPositiveCashBalance(nTokenAddress, currencyId);\\n        cashBalance = cashBalance.add(fee);\\n        _setPositiveCashBalance(nTokenAddress, currencyId, cashBalance);\\n    }\\n\\n    /// @notice increments fees to the reserve\\n    function incrementFeeToReserve(uint16 currencyId, int256 fee) internal {\\n        require(fee >= 0); // dev: invalid fee\\n        // prettier-ignore\\n        int256 totalReserve = getPositiveCashBalance(Constants.FEE_RESERVE, currencyId);\\n        totalReserve = totalReserve.add(fee);\\n        _setPositiveCashBalance(Constants.FEE_RESERVE, currencyId, totalReserve);\\n    }\\n\\n    /// @notice harvests excess reserve balance\\n    function harvestExcessReserveBalance(uint16 currencyId, int256 reserve, int256 assetInternalRedeemAmount) internal {\\n        // parameters are validated by the caller\\n        reserve = reserve.subNoNeg(assetInternalRedeemAmount);\\n        _setPositiveCashBalance(Constants.FEE_RESERVE, currencyId, reserve);\\n        // Transfer event is emitted in Treasury Action\\n        emit ExcessReserveBalanceHarvested(currencyId, assetInternalRedeemAmount);\\n    }\\n\\n    /// @notice sets the reserve balance, see TreasuryAction.setReserveCashBalance\\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance) internal {\\n        require(newBalance >= 0); // dev: invalid balance\\n        int256 previousBalance = getPositiveCashBalance(Constants.FEE_RESERVE, currencyId);\\n        _setPositiveCashBalance(Constants.FEE_RESERVE, currencyId, newBalance);\\n        Emitter.emitMintOrBurnPrimeCash(Constants.FEE_RESERVE, currencyId, newBalance.sub(previousBalance));\\n    }\\n\\n    function getPositiveCashBalance(\\n        address account,\\n        uint16 currencyId\\n    ) internal view returns (int256 cashBalance) {\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\n        cashBalance = balanceStorage.cashBalance;\\n        // Positive cash balances do not require prime rate conversion\\n        require(cashBalance >= 0);\\n    }\\n\\n    /// @notice Sets cash balances for special system accounts that can only ever have positive\\n    /// cash balances (and nothing else). Because positive prime cash balances do not require any\\n    /// adjustments this does not require a PrimeRate object\\n    function _setPositiveCashBalance(address account, uint16 currencyId, int256 newCashBalance) internal {\\n        require(newCashBalance >= 0); // dev: invalid balance\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\n        balanceStorage.cashBalance = newCashBalance.toInt88();\\n    }\\n\\n    /// @notice Sets internal balance storage.\\n    function _setBalanceStorage(\\n        address account,\\n        uint16 currencyId,\\n        int256 cashBalance,\\n        int256 nTokenBalance,\\n        uint256 lastClaimTime,\\n        uint256 accountIncentiveDebt,\\n        PrimeRate memory pr\\n    ) internal {\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\n\\n        if (lastClaimTime == 0) {\\n            // In this case the account has migrated and we set the accountIncentiveDebt\\n            // The maximum NOTE supply is 100_000_000e8 (1e16) which is less than 2^56 (7.2e16) so we should never\\n            // encounter an overflow for accountIncentiveDebt\\n            require(accountIncentiveDebt <= type(uint56).max); // dev: account incentive debt overflow\\n            balanceStorage.accountIncentiveDebt = uint56(accountIncentiveDebt);\\n        } else {\\n            // In this case the last claim time has not changed and we do not update the last integral supply\\n            // (stored in the accountIncentiveDebt position)\\n            require(lastClaimTime == balanceStorage.lastClaimTime);\\n        }\\n\\n        balanceStorage.lastClaimTime = lastClaimTime.toUint32();\\n        balanceStorage.nTokenBalance = nTokenBalance.toUint().toUint80();\\n\\n        balanceStorage.cashBalance = pr.convertToStorageNonSettlementNonVault(\\n            account,\\n            currencyId,\\n            balanceStorage.cashBalance, // previous stored value\\n            cashBalance // signed cash balance\\n        ).toInt88();\\n    }\\n\\n    /// @notice Gets internal balance storage, nTokens are stored alongside cash balances\\n    function getBalanceStorage(\\n        address account,\\n        uint16 currencyId,\\n        PrimeRate memory pr\\n    ) internal view returns (\\n        int256 cashBalance,\\n        int256 nTokenBalance,\\n        uint256 lastClaimTime,\\n        uint256 accountIncentiveDebt\\n    ) {\\n        mapping(address => mapping(uint256 => BalanceStorage)) storage store = LibStorage.getBalanceStorage();\\n        BalanceStorage storage balanceStorage = store[account][currencyId];\\n\\n        nTokenBalance = balanceStorage.nTokenBalance;\\n        lastClaimTime = balanceStorage.lastClaimTime;\\n        if (lastClaimTime > 0) {\\n            // NOTE: this is only necessary to support the deprecated integral supply values, which are stored\\n            // in the accountIncentiveDebt slot\\n            accountIncentiveDebt = FloatingPoint.unpackFromBits(balanceStorage.accountIncentiveDebt);\\n        } else {\\n            accountIncentiveDebt = balanceStorage.accountIncentiveDebt;\\n        }\\n\\n        cashBalance = pr.convertFromStorage(balanceStorage.cashBalance);\\n    }\\n        \\n    /// @notice Loads a balance state memory object\\n    /// @dev Balance state objects occupy a lot of memory slots, so this method allows\\n    /// us to reuse them if possible\\n    function _loadBalanceState(\\n        BalanceState memory balanceState,\\n        address account,\\n        uint16 currencyId,\\n        AccountContext memory accountContext\\n    ) private view {\\n        require(0 < currencyId && currencyId <= Constants.MAX_CURRENCIES); // dev: invalid currency id\\n        balanceState.currencyId = currencyId;\\n\\n        if (accountContext.isActiveInBalances(currencyId)) {\\n            (\\n                balanceState.storedCashBalance,\\n                balanceState.storedNTokenBalance,\\n                balanceState.lastClaimTime,\\n                balanceState.accountIncentiveDebt\\n            ) = getBalanceStorage(account, currencyId, balanceState.primeRate);\\n        } else {\\n            balanceState.storedCashBalance = 0;\\n            balanceState.storedNTokenBalance = 0;\\n            balanceState.lastClaimTime = 0;\\n            balanceState.accountIncentiveDebt = 0;\\n        }\\n\\n        balanceState.netCashChange = 0;\\n        balanceState.primeCashWithdraw = 0;\\n        balanceState.netNTokenTransfer = 0;\\n        balanceState.netNTokenSupplyChange = 0;\\n    }\\n\\n    /// @notice Used when manually claiming incentives in nTokenAction. Also sets the balance state\\n    /// to storage to update the accountIncentiveDebt. lastClaimTime will be set to zero as accounts\\n    /// are migrated to the new incentive calculation\\n    function claimIncentivesManual(BalanceState memory balanceState, address account)\\n        internal\\n        returns (uint256 incentivesClaimed)\\n    {\\n        incentivesClaimed = Incentives.claimIncentives(\\n            balanceState,\\n            account,\\n            balanceState.storedNTokenBalance.toUint()\\n        );\\n\\n        _setBalanceStorage(\\n            account,\\n            balanceState.currencyId,\\n            balanceState.storedCashBalance,\\n            balanceState.storedNTokenBalance,\\n            balanceState.lastClaimTime,\\n            balanceState.accountIncentiveDebt,\\n            balanceState.primeRate\\n        );\\n    }\\n\\n    function loadBalanceState(\\n        BalanceState memory balanceState,\\n        address account,\\n        uint16 currencyId,\\n        AccountContext memory accountContext\\n    ) internal {\\n        balanceState.primeRate = PrimeRateLib.buildPrimeRateStateful(currencyId);\\n        _loadBalanceState(balanceState, account, currencyId, accountContext);\\n    }\\n\\n    function loadBalanceStateView(\\n        BalanceState memory balanceState,\\n        address account,\\n        uint16 currencyId,\\n        AccountContext memory accountContext\\n    ) internal view {\\n        (balanceState.primeRate, /* */) = PrimeCashExchangeRate.getPrimeCashRateView(currencyId, block.timestamp);\\n        _loadBalanceState(balanceState, account, currencyId, accountContext);\\n    }\\n\\n    function getBalanceStorageView(\\n        address account,\\n        uint16 currencyId,\\n        uint256 blockTime\\n    ) internal view returns (\\n        int256 cashBalance,\\n        int256 nTokenBalance,\\n        uint256 lastClaimTime,\\n        uint256 accountIncentiveDebt\\n    ) {\\n        (PrimeRate memory pr, /* */) = PrimeCashExchangeRate.getPrimeCashRateView(currencyId, blockTime);\\n        return getBalanceStorage(account, currencyId, pr);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/internal/balances/ExternalLending.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    Token,\\n    PrimeRate,\\n    PrimeCashFactors,\\n    RebalancingTargetData\\n} from \\\"../../global/Types.sol\\\";\\nimport {\\n    IPrimeCashHoldingsOracle,\\n    OracleData,\\n    RedeemData,\\n    DepositData\\n} from \\\"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\\\";\\nimport {TokenHandler} from \\\"./TokenHandler.sol\\\";\\n\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {IERC20} from \\\"../../../interfaces/IERC20.sol\\\";\\n\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {PrimeCashExchangeRate} from \\\"../pCash/PrimeCashExchangeRate.sol\\\";\\nimport {GenericToken} from \\\"./protocols/GenericToken.sol\\\";\\n\\n\\nlibrary ExternalLending {\\n    using PrimeRateLib for PrimeRate;\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n    using TokenHandler for Token;\\n\\n    function getTargetExternalLendingAmount(\\n        Token memory underlyingToken,\\n        PrimeCashFactors memory factors,\\n        RebalancingTargetData memory rebalancingTargetData,\\n        OracleData memory oracleData,\\n        PrimeRate memory pr\\n    ) internal pure returns (uint256 targetAmount) {\\n        int256 totalPrimeCashInUnderlying = pr.convertToUnderlying(int256(factors.totalPrimeSupply));\\n        int256 totalPrimeDebtInUnderlying = pr.convertDebtStorageToUnderlying(int256(factors.totalPrimeDebt).neg()).abs();\\n        // The target amount to lend is based on a target \\\"utilization\\\" of the total prime supply. For example, for\\n        // a target utilization of 80%, if the prime cash utilization is 70% (totalPrimeSupply / totalPrimeDebt) then\\n        // we want to lend 10% of the total prime supply. This ensures that 20% of the totalPrimeSupply will not be held\\n        // in external money markets which run the risk of becoming unredeemable.\\n        int256 targetExternalUnderlyingLend = totalPrimeCashInUnderlying\\n            .mul(rebalancingTargetData.targetUtilization)\\n            .div(Constants.PERCENTAGE_DECIMALS)\\n            .sub(totalPrimeDebtInUnderlying);\\n        // Floor this value at zero. This will be negative above the target utilization. We do not want to be lending at\\n        // all above the target.\\n        if (targetExternalUnderlyingLend < 0) targetExternalUnderlyingLend = 0;\\n\\n        // To ensure redeemability of Notional\u2019s funds on external lending markets,\\n        // Notional requires there to be redeemable funds on the external lending market\\n        // that are a multiple of the funds that Notional has lent on that market itself.\\n        //\\n        // The max amount that Notional can lend on that market is a function\\n        // of the excess redeemable funds on that market\\n        // (funds that are redeemable in excess of Notional\u2019s own funds on that market)\\n        // and the externalWithdrawThreshold.\\n        //\\n        // excessFunds = externalUnderlyingAvailableForWithdraw - currentExternalUnderlyingLend\\n        //\\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) = maxExternalUnderlyingLend + excessFunds\\n        //\\n        // maxExternalUnderlyingLend * (externalWithdrawThreshold + 1) - maxExternalUnderlyingLend = excessFunds\\n        //\\n        // maxExternalUnderlyingLend * externalWithdrawThreshold = excessFunds\\n        //\\n        // maxExternalUnderlyingLend = excessFunds / externalWithdrawThreshold\\n        uint256 maxExternalUnderlyingLend;\\n        if (\\n            (oracleData.currentExternalUnderlyingLend < oracleData.externalUnderlyingAvailableForWithdraw) &&\\n            (rebalancingTargetData.externalWithdrawThreshold != 0)\\n        ) {\\n            // T as the externalWithdrawThreshold\\n            // L as the currentExternalUnderlyingLend\\n            // W as the externalUnderlyingAvailableForWithdraw\\n            // D as the Deposit (the variable we want to solve for)\\n            // T / 100 = (W + D) / (L + D)\\n            // D = (100 * W - L * T) / (T - 100)\\n            maxExternalUnderlyingLend = oracleData.externalUnderlyingAvailableForWithdraw\\n                .mul(uint256(Constants.PERCENTAGE_DECIMALS))\\n                .sub(oracleData.currentExternalUnderlyingLend.mul(rebalancingTargetData.externalWithdrawThreshold))\\n                // underflow is checked when externalWithdrawThreshold is set\\n                .div(uint256(rebalancingTargetData.externalWithdrawThreshold));\\n        } else {\\n            maxExternalUnderlyingLend = 0;\\n        }\\n\\n        targetAmount = SafeUint256.min(\\n            // totalPrimeCashInUnderlying and totalPrimeDebtInUnderlying are in 8 decimals, convert it to native\\n            // token precision here for accurate comparison. No underflow possible since targetExternalUnderlyingLend\\n            // is floored at zero.\\n            uint256(underlyingToken.convertToExternal(targetExternalUnderlyingLend)),\\n            // maxExternalUnderlyingLend is limit enforced by setting externalWithdrawThreshold\\n            maxExternalUnderlyingLend\\n        );\\n        // in case of redemption, make sure there is enough to withdraw, important for health check so that\\n        // it does not trigger rebalances (redemptions) when there is nothing to redeem\\n        if (targetAmount < oracleData.currentExternalUnderlyingLend) {\\n            uint256 forRedemption = oracleData.currentExternalUnderlyingLend - targetAmount;\\n            if (oracleData.externalUnderlyingAvailableForWithdraw < forRedemption) {\\n                // adapt target amount so that redemptions amount match externalUnderlyingAvailableForWithdraw\\n                // unchecked - is safe here, overflow is not possible due to above if conditionals\\n                targetAmount = oracleData.currentExternalUnderlyingLend - oracleData.externalUnderlyingAvailableForWithdraw;\\n            }\\n        } else if (oracleData.currentExternalUnderlyingLend < targetAmount) {\\n            // in case of deposit , check maxExternalDeposit (limit due to the supply cap on external pools)\\n            // underflow not possible due to above if conditional\\n            uint256 forDeposit = targetAmount - oracleData.currentExternalUnderlyingLend;\\n            if (oracleData.maxExternalDeposit < forDeposit) {\\n                // adapt target amount so we don't hit supply cap on external pools\\n                // overflow not possible due to above if conditional\\n                targetAmount = oracleData.currentExternalUnderlyingLend + oracleData.maxExternalDeposit;\\n            }\\n        }\\n    }\\n\\n    /// @notice Prime cash holdings may be in underlying tokens or they may be held in other money market\\n    /// protocols like Compound, Aave or Euler. If there is insufficient underlying tokens to withdraw on\\n    /// the contract, this method will redeem money market tokens in order to gain sufficient underlying\\n    /// to withdraw from the contract.\\n    /// @param currencyId associated currency id\\n    /// @param underlying underlying token information\\n    /// @param withdrawAmountExternal amount of underlying to withdraw in external token precision\\n    function redeemMoneyMarketIfRequired(\\n        uint16 currencyId,\\n        Token memory underlying,\\n        uint256 withdrawAmountExternal\\n    ) internal {\\n        // If there is sufficient balance of the underlying to withdraw from the contract\\n        // immediately, just return.\\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\\n        uint256 currentBalance = store[underlying.tokenAddress];\\n        if (withdrawAmountExternal <= currentBalance) return;\\n\\n        IPrimeCashHoldingsOracle oracle = PrimeCashExchangeRate.getPrimeCashHoldingsOracle(currencyId);\\n        // Redemption data returns an array of contract calls to make from the Notional proxy (which\\n        // is holding all of the money market tokens).\\n        (RedeemData[] memory data) = oracle.getRedemptionCalldata(withdrawAmountExternal - currentBalance);\\n\\n        // This is the total expected underlying that we should redeem after all redemption calls\\n        // are executed.\\n        uint256 totalUnderlyingRedeemed = executeMoneyMarketRedemptions(underlying, data);\\n\\n        // Ensure that we have sufficient funds before we exit\\n        require(withdrawAmountExternal <= currentBalance.add(totalUnderlyingRedeemed)); // dev: insufficient redeem\\n    }\\n\\n    /// @notice It is critical that this method measures and records the balanceOf changes before and after\\n    /// every token change. If not, then external donations can affect the valuation of pCash and pDebt\\n    /// tokens which may be exploitable.\\n    /// @param redeemData parameters from the prime cash holding oracle\\n    function executeMoneyMarketRedemptions(\\n        Token memory underlyingToken,\\n        RedeemData[] memory redeemData\\n    ) internal returns (uint256 totalUnderlyingRedeemed) {\\n        for (uint256 i; i < redeemData.length; i++) {\\n            RedeemData memory data = redeemData[i];\\n            // Measure the token balance change if the `assetToken` value is set in the\\n            // current redemption data struct. \\n            uint256 oldAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\\n\\n            // Measure the underlying balance change before and after the call.\\n            uint256 oldUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\\n\\n            // Some asset tokens may require multiple calls to redeem if there is an unstake\\n            // or redemption from WETH involved. We only measure the asset token balance change\\n            // on the final redemption call, as dictated by the prime cash holdings oracle.\\n            for (uint256 j; j < data.targets.length; j++) {\\n                GenericToken.executeLowLevelCall(data.targets[j], 0, data.callData[j]);\\n            }\\n\\n            // Ensure that we get sufficient underlying on every redemption\\n            uint256 newUnderlyingBalance = TokenHandler.balanceOf(underlyingToken, address(this));\\n            uint256 underlyingBalanceChange = newUnderlyingBalance.sub(oldUnderlyingBalance);\\n            // If the call is not the final redemption, then expectedUnderlying should\\n            // be set to zero.\\n            require(data.expectedUnderlying <= underlyingBalanceChange);\\n\\n            // Measure and update the asset token\\n            uint256 newAssetBalance = IERC20(data.assetToken).balanceOf(address(this));\\n            require(newAssetBalance <= oldAssetBalance);\\n\\n            if (\\n                (data.rebasingTokenBalanceAdjustment != 0) &&\\n                // This equation only makes sense when the \\\"asset token\\\" is a rebasing token\\n                // in the same denomination as the underlying token. This will only be reached\\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\\n                (underlyingBalanceChange != oldAssetBalance.sub(newAssetBalance))\\n            ) {\\n                newAssetBalance = newAssetBalance.add(data.rebasingTokenBalanceAdjustment);\\n            }\\n\\n            TokenHandler.updateStoredTokenBalance(data.assetToken, oldAssetBalance, newAssetBalance);\\n\\n            // Update the total value with the net change\\n            totalUnderlyingRedeemed = totalUnderlyingRedeemed.add(underlyingBalanceChange);\\n\\n            // totalUnderlyingRedeemed is always positive or zero.\\n            TokenHandler.updateStoredTokenBalance(underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance);\\n        }\\n    }\\n\\n    /// @notice Executes deposits to an external lending protocol. Only called during a rebalance executed\\n    /// by the TreasuryAction contract.\\n    function executeDeposits(Token memory underlyingToken, DepositData[] memory deposits) internal {\\n        for (uint256 i; i < deposits.length; i++) {\\n            DepositData memory depositData = deposits[i];\\n            // Measure the token balance change if the `assetToken` value is set in the\\n            // current deposit data struct.\\n            uint256 oldAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\\n\\n            // Measure the underlying balance change before and after the call.\\n            uint256 oldUnderlyingBalance = underlyingToken.balanceOf(address(this));\\n\\n            for (uint256 j; j < depositData.targets.length; ++j) {\\n                GenericToken.executeLowLevelCall(\\n                    depositData.targets[j],\\n                    depositData.msgValue[j],\\n                    depositData.callData[j]\\n                );\\n            }\\n\\n            // Ensure that the underlying balance change matches the deposit amount\\n            uint256 newUnderlyingBalance = underlyingToken.balanceOf(address(this));\\n            uint256 underlyingBalanceChange = oldUnderlyingBalance.sub(newUnderlyingBalance);\\n            // Ensure that only the specified amount of underlying has left the protocol\\n            require(underlyingBalanceChange <= depositData.underlyingDepositAmount);\\n\\n            // Measure and update the asset token\\n            uint256 newAssetBalance = IERC20(depositData.assetToken).balanceOf(address(this));\\n            require(oldAssetBalance <= newAssetBalance);\\n\\n            if (\\n                (depositData.rebasingTokenBalanceAdjustment != 0) &&\\n                // This equation only makes sense when the \\\"asset token\\\" is a rebasing token\\n                // in the same denomination as the underlying token. This will only be reached\\n                // if the rebasingTokenBalanceAdjustment is set to a non-zero value\\n                (underlyingBalanceChange != newAssetBalance.sub(oldAssetBalance))\\n            ) {\\n                newAssetBalance = newAssetBalance.add(depositData.rebasingTokenBalanceAdjustment);\\n            }\\n\\n            TokenHandler.updateStoredTokenBalance(depositData.assetToken, oldAssetBalance, newAssetBalance);\\n            TokenHandler.updateStoredTokenBalance(\\n                underlyingToken.tokenAddress, oldUnderlyingBalance, newUnderlyingBalance\\n            );\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/internal/balances/Incentives.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    BalanceState\\n} from \\\"../../global/Types.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\n\\nimport {TokenHandler} from \\\"./TokenHandler.sol\\\";\\nimport {nTokenHandler} from \\\"../nToken/nTokenHandler.sol\\\";\\nimport {nTokenSupply} from \\\"../nToken/nTokenSupply.sol\\\";\\n\\nimport {IRewarder} from \\\"../../../interfaces/notional/IRewarder.sol\\\";\\n\\nlibrary Incentives {\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n\\n    /// @notice Calculates the total incentives to claim including those claimed under the previous\\n    /// less accurate calculation. Once an account is migrated it will only claim incentives under\\n    /// the more accurate regime\\n    function calculateIncentivesToClaim(\\n        BalanceState memory balanceState,\\n        address tokenAddress,\\n        uint256 accumulatedNOTEPerNToken,\\n        uint256 finalNTokenBalance\\n    ) internal view returns (uint256 incentivesToClaim) {\\n        require(balanceState.lastClaimTime == 0);\\n\\n        // If an account was migrated then they have no accountIncentivesDebt and should accumulate\\n        // incentives based on their share since the new regime calculation started.\\n        // If an account is just initiating their nToken balance then storedNTokenBalance will be zero\\n        // and they will have no incentives to claim.\\n        // This calculation uses storedNTokenBalance which is the balance of the account up until this point,\\n        // this is important to ensure that the account does not claim for nTokens that they will mint or\\n        // redeem on a going forward basis.\\n\\n        // The calculation below has the following precision:\\n        //   storedNTokenBalance (INTERNAL_TOKEN_PRECISION)\\n        //   MUL accumulatedNOTEPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\\n        //   DIV INCENTIVE_ACCUMULATION_PRECISION\\n        //  = INTERNAL_TOKEN_PRECISION - (accountIncentivesDebt) INTERNAL_TOKEN_PRECISION\\n        incentivesToClaim = incentivesToClaim.add(\\n            balanceState.storedNTokenBalance.toUint()\\n                .mul(accumulatedNOTEPerNToken)\\n                .div(Constants.INCENTIVE_ACCUMULATION_PRECISION)\\n                .sub(balanceState.accountIncentiveDebt)\\n        );\\n\\n        // Update accountIncentivesDebt denominated in INTERNAL_TOKEN_PRECISION which marks the portion\\n        // of the accumulatedNOTE that the account no longer has a claim over. Use the finalNTokenBalance\\n        // here instead of storedNTokenBalance to mark the overall incentives claim that the account\\n        // does not have a claim over. We do not aggregate this value with the previous accountIncentiveDebt\\n        // because accumulatedNOTEPerNToken is already an aggregated value.\\n\\n        // The calculation below has the following precision:\\n        //   finalNTokenBalance (INTERNAL_TOKEN_PRECISION)\\n        //   MUL accumulatedNOTEPerNToken (INCENTIVE_ACCUMULATION_PRECISION)\\n        //   DIV INCENTIVE_ACCUMULATION_PRECISION\\n        //   = INTERNAL_TOKEN_PRECISION\\n        balanceState.accountIncentiveDebt = finalNTokenBalance\\n            .mul(accumulatedNOTEPerNToken)\\n            .div(Constants.INCENTIVE_ACCUMULATION_PRECISION);\\n    }\\n\\n    /// @notice Incentives must be claimed every time nToken balance changes.\\n    /// @dev BalanceState.accountIncentiveDebt is updated in place here\\n    function claimIncentives(\\n        BalanceState memory balanceState,\\n        address account,\\n        uint256 finalNTokenBalance\\n    ) internal returns (uint256 incentivesToClaim) {\\n        uint256 blockTime = block.timestamp;\\n        address tokenAddress = nTokenHandler.nTokenAddress(balanceState.currencyId);\\n        (uint256 priorNTokenSupply, /* */, /* */) = nTokenSupply.getStoredNTokenSupplyFactors(tokenAddress);\\n        // This will updated the nToken storage and return what the accumulatedNOTEPerNToken\\n        // is up until this current block time in 1e18 precision\\n        uint256 accumulatedNOTEPerNToken = nTokenSupply.changeNTokenSupply(\\n            tokenAddress,\\n            balanceState.netNTokenSupplyChange,\\n            blockTime\\n        );\\n\\n        incentivesToClaim = calculateIncentivesToClaim(\\n            balanceState,\\n            tokenAddress,\\n            accumulatedNOTEPerNToken,\\n            finalNTokenBalance\\n        );\\n\\n        // If a secondary incentive rewarder is set, then call it\\n        IRewarder rewarder = nTokenHandler.getSecondaryRewarder(tokenAddress);\\n        if (address(rewarder) != address(0)) {\\n            rewarder.claimRewards(\\n                account,\\n                balanceState.currencyId,\\n                // When this method is called from finalize, the storedNTokenBalance has not\\n                // been updated to finalNTokenBalance yet so this is the balance before the change.\\n                balanceState.storedNTokenBalance.toUint(),\\n                finalNTokenBalance,\\n                priorNTokenSupply\\n            );\\n        }\\n\\n        if (incentivesToClaim > 0) TokenHandler.transferIncentive(account, incentivesToClaim);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/balances/protocols/CompoundHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {Token} from \\\"../../../global/Types.sol\\\";\\nimport {SafeUint256} from \\\"../../../math/SafeUint256.sol\\\";\\n\\nimport {GenericToken} from \\\"./GenericToken.sol\\\";\\n\\nimport {CErc20Interface} from \\\"../../../../interfaces/compound/CErc20Interface.sol\\\";\\nimport {CEtherInterface} from \\\"../../../../interfaces/compound/CEtherInterface.sol\\\";\\nimport {IERC20} from \\\"../../../../interfaces/IERC20.sol\\\";\\n\\nlibrary CompoundHandler {\\n    using SafeUint256 for uint256;\\n\\n    // Return code for cTokens that represents no error\\n    uint256 internal constant COMPOUND_RETURN_CODE_NO_ERROR = 0;\\n\\n    function redeemCETH(\\n        Token memory assetToken,\\n        uint256 assetAmountExternal\\n    ) internal returns (uint256 underlyingAmountExternal) {\\n        uint256 startingBalance = address(this).balance;\\n\\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\\n        require(success == COMPOUND_RETURN_CODE_NO_ERROR, \\\"Redeem\\\");\\n\\n        uint256 endingBalance = address(this).balance;\\n\\n        underlyingAmountExternal = endingBalance.sub(startingBalance);\\n    }\\n\\n    function redeem(\\n        Token memory assetToken,\\n        Token memory underlyingToken,\\n        uint256 assetAmountExternal\\n    ) internal returns (uint256 underlyingAmountExternal) {\\n        uint256 startingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\\n\\n        uint256 success = CErc20Interface(assetToken.tokenAddress).redeem(assetAmountExternal);\\n        require(success == COMPOUND_RETURN_CODE_NO_ERROR, \\\"Redeem\\\");\\n\\n        uint256 endingBalance = IERC20(underlyingToken.tokenAddress).balanceOf(address(this));\\n\\n        underlyingAmountExternal = endingBalance.sub(startingBalance);\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/balances/protocols/GenericToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\n\\nimport {Deployments} from \\\"../../../global/Deployments.sol\\\";\\nimport {IEIP20NonStandard} from \\\"../../../../interfaces/IEIP20NonStandard.sol\\\";\\nimport {SafeUint256} from \\\"../../../math/SafeUint256.sol\\\";\\n\\nlibrary GenericToken {\\n    using SafeUint256 for uint256;\\n\\n    event LowLevelCallFailed(address indexed target, uint256 msgValue, bytes callData, string revertMessage);\\n\\n    function transferNativeTokenOut(\\n        address account,\\n        uint256 amount,\\n        bool withdrawWrapped\\n    ) internal {\\n        // Native token withdraws are processed using .transfer() which is may not work\\n        // for certain contracts that do not implement receive() with minimal gas requirements.\\n        // Prior to the prime cash upgrade, these contracts could withdraw cETH, however, post\\n        // upgrade they no longer have this option. For these contracts, wrap the Native token\\n        // (i.e. WETH) and transfer that as an ERC20 instead.\\n        if (withdrawWrapped) {\\n            Deployments.WETH.deposit{value: amount}();\\n            safeTransferOut(address(Deployments.WETH), account, amount);\\n        } else {\\n            // TODO: consider using .call with a manual amount of gas forwarding\\n            payable(account).transfer(amount);\\n        }\\n    }\\n\\n    function safeTransferOut(\\n        address token,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        IEIP20NonStandard(token).transfer(account, amount);\\n        checkReturnCode();\\n    }\\n\\n    function safeTransferIn(\\n        address token,\\n        address account,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        uint256 startingBalance = IEIP20NonStandard(token).balanceOf(address(this));\\n\\n        IEIP20NonStandard(token).transferFrom(account, address(this), amount);\\n        checkReturnCode();\\n\\n        uint256 endingBalance = IEIP20NonStandard(token).balanceOf(address(this));\\n\\n        return endingBalance.sub(startingBalance);\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        IEIP20NonStandard(token).transferFrom(from, to, amount);\\n        checkReturnCode();\\n    }\\n\\n    function executeLowLevelCall(\\n        address target,\\n        uint256 msgValue,\\n        bytes memory callData\\n    ) internal  {\\n        (bool status, bytes memory returnData) = target.call{value: msgValue}(callData);\\n        require(status, checkRevertMessage(returnData));\\n    }\\n\\n    function checkRevertMessage(bytes memory returnData) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (returnData.length < 68) return \\\"Silent Revert\\\";\\n\\n        assembly {\\n            // Slice the sighash.\\n            returnData := add(returnData, 0x04)\\n        }\\n        return abi.decode(returnData, (string)); // All that remains is the revert string\\n    }\\n\\n    function checkReturnCode() internal pure {\\n        bool success;\\n        uint256[1] memory result;\\n        assembly {\\n            switch returndatasize()\\n                case 0 {\\n                    // This is a non-standard ERC-20\\n                    success := 1 // set success to true\\n                }\\n                case 32 {\\n                    // This is a compliant ERC-20\\n                    returndatacopy(result, 0, 32)\\n                    success := mload(result) // Set `success = returndata` of external call\\n                }\\n                default {\\n                    // This is an excessively non-compliant ERC-20, revert.\\n                    revert(0, 0)\\n                }\\n        }\\n\\n        require(success, \\\"ERC20\\\");\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/internal/balances/TokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    Token,\\n    TokenType,\\n    TokenStorage,\\n    PrimeRate\\n} from \\\"../../global/Types.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {Deployments} from \\\"../../global/Deployments.sol\\\";\\n\\nimport {Emitter} from \\\"../Emitter.sol\\\";\\nimport {PrimeCashExchangeRate} from \\\"../pCash/PrimeCashExchangeRate.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\n\\nimport {ExternalLending} from \\\"./ExternalLending.sol\\\";\\nimport {CompoundHandler} from \\\"./protocols/CompoundHandler.sol\\\";\\nimport {GenericToken} from \\\"./protocols/GenericToken.sol\\\";\\n\\nimport {IERC20} from \\\"../../../interfaces/IERC20.sol\\\";\\n\\n/// @notice Handles all external token transfers and events\\nlibrary TokenHandler {\\n    using SafeInt256 for int256;\\n    using SafeUint256 for uint256;\\n    using PrimeRateLib for PrimeRate;\\n\\n    function getDeprecatedAssetToken(uint256 currencyId) internal view returns (Token memory) {\\n        return _getToken(currencyId, false);\\n    }\\n\\n    function getUnderlyingToken(uint256 currencyId) internal view returns (Token memory) {\\n        return _getToken(currencyId, true);\\n    }\\n\\n    /// @notice Gets token data for a particular currency id, if underlying is set to true then returns\\n    /// the underlying token. (These may not always exist)\\n    function _getToken(uint256 currencyId, bool underlying) private view returns (Token memory) {\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\n        TokenStorage storage tokenStorage = store[currencyId][underlying];\\n\\n        return\\n            Token({\\n                tokenAddress: tokenStorage.tokenAddress,\\n                hasTransferFee: tokenStorage.hasTransferFee,\\n                // No overflow, restricted on storage\\n                decimals: int256(10**tokenStorage.decimalPlaces),\\n                tokenType: tokenStorage.tokenType,\\n                deprecated_maxCollateralBalance: 0\\n            });\\n    }\\n\\n    /// @notice Sets a token for a currency id. After the prime cash migration, only\\n    /// underlying tokens may be set by this method.\\n    function setToken(uint256 currencyId, TokenStorage memory tokenStorage) internal {\\n        mapping(uint256 => mapping(bool => TokenStorage)) storage store = LibStorage.getTokenStorage();\\n\\n        if (tokenStorage.tokenType == TokenType.Ether && currencyId == Constants.ETH_CURRENCY_ID) {\\n            // Hardcoded parameters for ETH just to make sure we don't get it wrong.\\n            TokenStorage storage ts = store[currencyId][true];\\n            ts.tokenAddress = address(0);\\n            ts.hasTransferFee = false;\\n            ts.tokenType = TokenType.Ether;\\n            ts.decimalPlaces = Constants.ETH_DECIMAL_PLACES;\\n\\n            return;\\n        }\\n\\n        // Check token address\\n        require(tokenStorage.tokenAddress != address(0));\\n        // Once a token is set we cannot override it. In the case that we do need to do change a token address\\n        // then we should explicitly upgrade this method to allow for a token to be changed.\\n        Token memory token = _getToken(currencyId, true);\\n        require(token.tokenAddress == tokenStorage.tokenAddress || token.tokenAddress == address(0));\\n\\n        require(0 < tokenStorage.decimalPlaces && tokenStorage.decimalPlaces <= Constants.MAX_DECIMAL_PLACES);\\n\\n        // Validate token type\\n        require(tokenStorage.tokenType != TokenType.Ether); // dev: ether can only be set once\\n        // Only underlying tokens allowed after migration\\n        require(tokenStorage.tokenType == TokenType.UnderlyingToken); // dev: only underlying token\\n\\n        // Underlying is always true.\\n        store[currencyId][true] = tokenStorage;\\n    }\\n\\n    /**\\n     * @notice Transfers a deprecated asset token into Notional and redeems it for underlying,\\n     * updates prime cash supply and returns the total prime cash to add to the account.\\n     * @param assetToken asset token to redeem\\n     * @param currencyId the currency id of the token\\n     * @param assetAmountExternal the amount to transfer in asset token denomination and external precision\\n     * @param primeRate the prime rate for the given currency\\n     * @param account the address of the account to transfer from\\n     * @return primeCashDeposited the amount of prime cash to mint back to the account\\n     */\\n    function depositDeprecatedAssetToken(\\n        Token memory assetToken,\\n        uint16 currencyId,\\n        uint256 assetAmountExternal,\\n        address account,\\n        PrimeRate memory primeRate\\n    ) internal returns (int256 primeCashDeposited) {\\n        // Transfer the asset token into the contract\\n        assetAmountExternal = GenericToken.safeTransferIn(\\n            assetToken.tokenAddress, account, assetAmountExternal\\n        );\\n\\n        Token memory underlyingToken = getUnderlyingToken(currencyId);\\n        int256 underlyingExternalAmount;\\n        // Only cTokens will be listed at the time of the migration. Redeem\\n        // those cTokens to underlying (to be held by the Notional contract)\\n        // and then run the post transfer update\\n        if (assetToken.tokenType == TokenType.cETH) {\\n            underlyingExternalAmount = CompoundHandler.redeemCETH(\\n                assetToken, assetAmountExternal\\n            ).toInt();\\n        } else if (assetToken.tokenType == TokenType.cToken) {\\n            underlyingExternalAmount = CompoundHandler.redeem(\\n                assetToken, underlyingToken, assetAmountExternal\\n            ).toInt();\\n        } else {\\n            // No other asset token variants can be called here.\\n            revert();\\n        }\\n        \\n        primeCashDeposited = _postTransferPrimeCashUpdate(\\n            account, currencyId, underlyingExternalAmount, underlyingToken, primeRate\\n        );\\n    }\\n\\n    /// @notice Deposits an exact amount of underlying tokens to mint the specified amount of prime cash.\\n    /// @param account account to transfer tokens from\\n    /// @param currencyId the associated currency id\\n    /// @param primeCashToMint the amount of prime cash to mint\\n    /// @param primeRate the current accrued prime rate\\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\\n    function depositExactToMintPrimeCash(\\n        address account,\\n        uint16 currencyId,\\n        int256 primeCashToMint,\\n        PrimeRate memory primeRate,\\n        bool returnNativeTokenWrapped\\n    ) internal returns (int256 actualTransferExternal) {\\n        if (primeCashToMint == 0) return 0;\\n        require(primeCashToMint > 0);\\n        Token memory underlying = getUnderlyingToken(currencyId);\\n        int256 netTransferExternal = convertToUnderlyingExternalWithAdjustment(\\n            underlying, \\n            primeRate.convertToUnderlying(primeCashToMint) \\n        );\\n\\n        int256 netPrimeSupplyChange;\\n        (actualTransferExternal, netPrimeSupplyChange) = depositUnderlyingExternal(\\n            account, currencyId, netTransferExternal, primeRate, returnNativeTokenWrapped\\n        );\\n\\n        // Ensures that the prime cash minted is positive and always greater than\\n        // the amount of prime cash that will be credited to the depositor. Any dust\\n        // amounts here will accrue to the protocol. primeCashToMint is asserted to be\\n        // positive so if netPrimeSupplyChange is negative (which it should never be),\\n        // then this will revert as well.\\n        int256 diff = netPrimeSupplyChange - primeCashToMint;\\n        require(0 <= diff); // dev: diff above zero\\n    }\\n\\n    /// @notice Deposits an amount of underlying tokens to mint prime cash\\n    /// @param account account to transfer tokens from\\n    /// @param currencyId the associated currency id\\n    /// @param _underlyingExternalDeposit the amount of underlying tokens to deposit\\n    /// @param primeRate the current accrued prime rate\\n    /// @param returnNativeTokenWrapped if true, return excess msg.value ETH payments as WETH\\n    /// @return actualTransferExternal the actual amount of tokens transferred in external precision\\n    /// @return netPrimeSupplyChange the amount of prime supply created\\n    function depositUnderlyingExternal(\\n        address account,\\n        uint16 currencyId,\\n        int256 _underlyingExternalDeposit,\\n        PrimeRate memory primeRate,\\n        bool returnNativeTokenWrapped\\n    ) internal returns (int256 actualTransferExternal, int256 netPrimeSupplyChange) {\\n        uint256 underlyingExternalDeposit = _underlyingExternalDeposit.toUint();\\n        if (underlyingExternalDeposit == 0) return (0, 0);\\n\\n        Token memory underlying = getUnderlyingToken(currencyId);\\n        if (underlying.tokenType == TokenType.Ether) {\\n            // Underflow checked above\\n            if (underlyingExternalDeposit < msg.value) {\\n                // Transfer any excess ETH back to the account\\n                GenericToken.transferNativeTokenOut(\\n                    account, msg.value - underlyingExternalDeposit, returnNativeTokenWrapped\\n                );\\n            } else {\\n                require(underlyingExternalDeposit == msg.value, \\\"ETH Balance\\\");\\n            }\\n\\n            actualTransferExternal = _underlyingExternalDeposit;\\n        } else {\\n            // In the case of deposits, we use a balance before and after check\\n            // to ensure that we record the proper balance change.\\n            actualTransferExternal = GenericToken.safeTransferIn(\\n                underlying.tokenAddress, account, underlyingExternalDeposit\\n            ).toInt();\\n        }\\n\\n        netPrimeSupplyChange = _postTransferPrimeCashUpdate(\\n            account, currencyId, actualTransferExternal, underlying, primeRate\\n        );\\n    }\\n\\n    /// @notice Withdraws an amount of prime cash and returns it to the account as underlying tokens\\n    /// @param account account to transfer tokens to\\n    /// @param currencyId the associated currency id\\n    /// @param primeCashToWithdraw the amount of prime cash to burn\\n    /// @param primeRate the current accrued prime rate\\n    /// @param withdrawWrappedNativeToken if true, return ETH as WETH\\n    /// @return netTransferExternal the amount of underlying tokens withdrawn in native precision, this is\\n    /// negative to signify that tokens have left the protocol\\n    function withdrawPrimeCash(\\n        address account,\\n        address receiver,\\n        uint16 currencyId,\\n        int256 primeCashToWithdraw,\\n        PrimeRate memory primeRate,\\n        bool withdrawWrappedNativeToken\\n    ) internal returns (int256 netTransferExternal) {\\n        if (primeCashToWithdraw == 0) return 0;\\n        require(primeCashToWithdraw < 0);\\n\\n        Token memory underlying = getUnderlyingToken(currencyId);\\n        netTransferExternal = convertToExternal(\\n            underlying, \\n            primeRate.convertToUnderlying(primeCashToWithdraw) \\n        );\\n\\n        // Overflow not possible due to int256\\n        uint256 withdrawAmount = uint256(netTransferExternal.neg());\\n        ExternalLending.redeemMoneyMarketIfRequired(currencyId, underlying, withdrawAmount);\\n\\n        if (underlying.tokenType == TokenType.Ether) {\\n            GenericToken.transferNativeTokenOut(receiver, withdrawAmount, withdrawWrappedNativeToken);\\n        } else {\\n            GenericToken.safeTransferOut(underlying.tokenAddress, receiver, withdrawAmount);\\n        }\\n\\n        _postTransferPrimeCashUpdate(account, currencyId, netTransferExternal, underlying, primeRate);\\n    }\\n\\n    /// @notice Every time tokens are transferred into or out of the protocol, the prime supply\\n    /// and total underlying held must be updated.\\n    function _postTransferPrimeCashUpdate(\\n        address account,\\n        uint16 currencyId,\\n        int256 netTransferUnderlyingExternal,\\n        Token memory underlyingToken,\\n        PrimeRate memory primeRate\\n    ) private returns (int256 netPrimeSupplyChange) {\\n        int256 netUnderlyingChange = convertToInternal(underlyingToken, netTransferUnderlyingExternal);\\n\\n        netPrimeSupplyChange = primeRate.convertFromUnderlying(netUnderlyingChange);\\n\\n        Emitter.emitMintOrBurnPrimeCash(account, currencyId, netPrimeSupplyChange);\\n        PrimeCashExchangeRate.updateTotalPrimeSupply(currencyId, netPrimeSupplyChange, netUnderlyingChange);\\n\\n        _updateNetStoredTokenBalance(underlyingToken.tokenAddress, netTransferUnderlyingExternal);\\n    }\\n\\n    function convertToInternal(Token memory token, int256 amount) internal pure returns (int256) {\\n        // If token decimals > INTERNAL_TOKEN_PRECISION:\\n        //  on deposit: resulting dust will accumulate to protocol\\n        //  on withdraw: protocol may lose dust amount. However, withdraws are only calculated based\\n        //    on a conversion from internal token precision to external token precision so therefore dust\\n        //    amounts cannot be specified for withdraws.\\n        // If token decimals < INTERNAL_TOKEN_PRECISION then this will add zeros to the\\n        // end of amount and will not result in dust.\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\n        return amount.mul(Constants.INTERNAL_TOKEN_PRECISION).div(token.decimals);\\n    }\\n\\n    function convertToExternal(Token memory token, int256 amount) internal pure returns (int256) {\\n        if (token.decimals == Constants.INTERNAL_TOKEN_PRECISION) return amount;\\n        // If token decimals > INTERNAL_TOKEN_PRECISION then this will increase amount\\n        // by adding a number of zeros to the end and will not result in dust.\\n        // If token decimals < INTERNAL_TOKEN_PRECISION:\\n        //  on deposit: Deposits are specified in external token precision and there is no loss of precision when\\n        //      tokens are converted from external to internal precision\\n        //  on withdraw: this calculation will round down such that the protocol retains the residual cash balance\\n        return amount.mul(token.decimals).div(Constants.INTERNAL_TOKEN_PRECISION);\\n    }\\n\\n    /// @notice Converts a token to an underlying external amount with adjustments for rounding errors when depositing\\n    function convertToUnderlyingExternalWithAdjustment(\\n        Token memory token,\\n        int256 underlyingInternalAmount\\n    ) internal pure returns (int256 underlyingExternalAmount) {\\n        if (token.decimals < Constants.INTERNAL_TOKEN_PRECISION) {\\n            // If external < 8, we could truncate down and cause an off by one error, for example we need\\n            // 1.00000011 cash and we deposit only 1.000000, missing 11 units. Therefore, we add a unit at the\\n            // lower precision (external) to get around off by one errors\\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount).add(1);\\n        } else {\\n            // If external > 8, we may not mint enough asset tokens because in the case of 1e18 precision \\n            // an off by 1 error at 1e8 precision is 1e10 units of the underlying token. In this case we\\n            // add 1 at the internal precision which has the effect of rounding up by 1e10\\n            underlyingExternalAmount = convertToExternal(token, underlyingInternalAmount.add(1));\\n        }\\n    }\\n\\n    /// @notice Convenience method for getting the balance using a token object\\n    function balanceOf(Token memory token, address account) internal view returns (uint256) {\\n        if (token.tokenType == TokenType.Ether) {\\n            return account.balance;\\n        } else {\\n            return IERC20(token.tokenAddress).balanceOf(account);\\n        }\\n    }\\n\\n    function transferIncentive(address account, uint256 tokensToTransfer) internal {\\n        GenericToken.safeTransferOut(Deployments.NOTE_TOKEN_ADDRESS, account, tokensToTransfer);\\n    }\\n\\n    function updateStoredTokenBalance(address token, uint256 oldBalance, uint256 newBalance) internal {\\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\\n        uint256 storedBalance = store[token];\\n        // The stored balance must always be less than or equal to the previous balance of. oldBalance\\n        // will be larger in the case when there is a donation or dust value present. If stored balance somehow\\n        // goes above the oldBalance then there is a critical issue in the protocol.\\n        require(storedBalance <= oldBalance);\\n        int256 netBalanceChange = newBalance.toInt().sub(oldBalance.toInt());\\n        store[token] = int256(storedBalance).add(netBalanceChange).toUint();\\n    }\\n\\n    function _updateNetStoredTokenBalance(address token, int256 netBalanceChange) private {\\n        mapping(address => uint256) storage store = LibStorage.getStoredTokenBalances();\\n        uint256 storedBalance = store[token];\\n        store[token] = int256(storedBalance).add(netBalanceChange).toUint();\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/Emitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    PortfolioAsset,\\n    VaultAccount,\\n    VaultConfig,\\n    VaultAccountStorage,\\n    PrimeRate\\n} from \\\"../global/Types.sol\\\";\\nimport {Constants} from \\\"../global/Constants.sol\\\";\\nimport {LibStorage} from \\\"../global/LibStorage.sol\\\";\\n\\nimport {PrimeRateLib} from \\\"./pCash/PrimeRateLib.sol\\\";\\nimport {SafeInt256} from \\\"../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../math/SafeUint256.sol\\\";\\n\\nimport {ITransferEmitter} from \\\"../external/proxies/BaseERC4626Proxy.sol\\\";\\n\\n/**\\n * @notice Controls all event emissions for the protocol so that off chain block explorers can properly\\n * index Notional internal accounting. Notional V3 will emit events for these tokens:\\n * \\n * ERC20 (emits Transfer via proxy):\\n *  - nToken (one nToken contract per currency that has fCash enabled)\\n *  - pCash (one pCash contract per listed underlying token)\\n *  - pDebt (one pDebt contract per pCash token that allows debt)\\n *\\n * ERC1155 (emitted from address(this)):\\n *  - Positive fCash (represents a positive fCash balance)\\n *      ID: [bytes23(0), uint8(0), uint16(currencyId), uint40(maturity), uint8(FCASH_ASSET_TYPE)]\\n *  - Negative fCash (v3, represents a negative fCash balance)\\n *      ID: [bytes23(0), uint8(1), uint16(currencyId), uint40(maturity), uint8(FCASH_ASSET_TYPE)]\\n *  - Vault Share Units (v3, represents a share of a leveraged vault)\\n *      ID: [bytes5(0), bytes20(vaultAddress), uint16(currencyId), uint40(maturity), uint8(VAULT_SHARE_ASSET_TYPE)]\\n *  - Vault Debt Units (v3, represents debt owed to a leveraged vault)\\n *      ID: [bytes5(0), bytes20(vaultAddress), uint16(currencyId), uint40(maturity), uint8(VAULT_DEBT_ASSET_TYPE)]\\n *  - Vault Cash Units (v3, represents cash held on a leveraged vault account after liquidation)\\n *      ID: [bytes5(0), bytes20(vaultAddress), uint16(currencyId), uint40(maturity), uint8(VAULT_CASH_ASSET_TYPE)]\\n *  - Legacy nToken (v3, emitted for legacy nToken transfers)\\n *      ID: [bytes23(0), uint8(0), uint16(currencyId), uint40(0), uint8(LEGACY_NTOKEN_ASSET_TYPE)]\\n *\\n *  - NOTE: Liquidity Token ids are not valid within the Notional V3 schema since they are only held by the nToken\\n *    and never transferred.\\n */\\nlibrary Emitter {\\n    using SafeInt256 for int256;\\n    using SafeUint256 for uint256;\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    uint256 private constant MATURITY_OFFSET        = 8;\\n    uint256 private constant CURRENCY_OFFSET        = 48;\\n    uint256 private constant VAULT_ADDRESS_OFFSET   = 64;\\n\\n    uint256 private constant FCASH_FLAG_OFFSET      = 64;\\n    uint256 private constant NEGATIVE_FCASH_MASK    = 1 << 64;\\n\\n    function decodeCurrencyId(uint256 id) internal pure returns (uint16) {\\n        return uint16(id >> CURRENCY_OFFSET);\\n    }\\n\\n    function isfCash(uint256 id) internal pure returns (bool) {\\n        return uint8(id) == Constants.FCASH_ASSET_TYPE;\\n    }\\n\\n    function encodeId(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        address vaultAddress,\\n        bool isfCashDebt\\n    ) internal pure returns (uint256 id) {\\n        if (assetType == Constants.FCASH_ASSET_TYPE) {\\n            return encodefCashId(currencyId, maturity, isfCashDebt ? int256(-1) : int256(1));\\n        } else if (\\n            assetType == Constants.VAULT_CASH_ASSET_TYPE ||\\n            assetType == Constants.VAULT_SHARE_ASSET_TYPE ||\\n            assetType == Constants.VAULT_DEBT_ASSET_TYPE\\n        ) {\\n            return _encodeVaultId(vaultAddress, currencyId, maturity, assetType);\\n        } else if (assetType == Constants.LEGACY_NTOKEN_ASSET_TYPE) {\\n            return _legacyNTokenId(currencyId);\\n        }\\n\\n        revert();\\n    }\\n\\n    function decodeId(uint256 id) internal pure returns (\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        address vaultAddress,\\n        bool isfCashDebt\\n    ) {\\n        assetType   = uint8(id);\\n        maturity    = uint40(id >> MATURITY_OFFSET);\\n        currencyId  = uint16(id >> CURRENCY_OFFSET);\\n\\n        if (assetType == Constants.FCASH_ASSET_TYPE) {\\n            isfCashDebt = uint8(id >> FCASH_FLAG_OFFSET) == 1;\\n        } else {\\n            vaultAddress = address(id >> VAULT_ADDRESS_OFFSET);\\n        }\\n    }\\n\\n    function encodefCashId(uint16 currencyId, uint256 maturity, int256 amount) internal pure returns (uint256 id) {\\n        require(currencyId <= Constants.MAX_CURRENCIES);\\n        require(maturity <= type(uint40).max);\\n        id = _posfCashId(currencyId, maturity);\\n        if (amount < 0) id = id | NEGATIVE_FCASH_MASK;\\n    }\\n\\n    function decodefCashId(uint256 id) internal pure returns (uint16 currencyId, uint256 maturity, bool isfCashDebt) {\\n        // If the id is not of an fCash asset type, return zeros\\n        if (uint8(id) != Constants.FCASH_ASSET_TYPE) return (0, 0, false);\\n\\n        maturity    = uint40(id >> MATURITY_OFFSET);\\n        currencyId  = uint16(id >> CURRENCY_OFFSET);\\n        isfCashDebt   = uint8(id >> FCASH_FLAG_OFFSET) == 1;\\n    }\\n\\n    function _encodeVaultId(\\n        address vault,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 assetType\\n    ) private pure returns (uint256 id) {\\n        return uint256(\\n            (bytes32(uint256(vault)) << VAULT_ADDRESS_OFFSET) |\\n            (bytes32(uint256(currencyId)) << CURRENCY_OFFSET) |\\n            (bytes32(maturity) << MATURITY_OFFSET)            |\\n            (bytes32(assetType))\\n        );\\n    }\\n\\n    function decodeVaultId(uint256 id) internal pure returns (\\n        uint256 assetType,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        address vaultAddress\\n    ) {\\n        assetType   = uint8(id);\\n        // If the asset type is below this it is not a valid vault asset id\\n        if (assetType < Constants.VAULT_SHARE_ASSET_TYPE) return (0, 0, 0, address(0));\\n\\n        maturity    = uint40(id >> MATURITY_OFFSET);\\n        currencyId  = uint16(id >> CURRENCY_OFFSET);\\n        vaultAddress = address(id >> VAULT_ADDRESS_OFFSET);\\n    }\\n\\n\\n    function _posfCashId(uint16 currencyId, uint256 maturity) internal pure returns (uint256 id) {\\n        return uint256(\\n            (bytes32(uint256(currencyId)) << CURRENCY_OFFSET) |\\n            (bytes32(maturity) << MATURITY_OFFSET)            |\\n            (bytes32(uint256(Constants.FCASH_ASSET_TYPE)))\\n        );\\n    }\\n\\n    function _legacyNTokenId(uint16 currencyId) internal pure returns (uint256 id) {\\n        return uint256(\\n            (bytes32(uint256(currencyId)) << CURRENCY_OFFSET) |\\n            (bytes32(uint256(Constants.LEGACY_NTOKEN_ASSET_TYPE)))\\n        );\\n    }\\n\\n    function _isLegacyNToken(uint16 currencyId) internal pure returns (bool) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n\\n        // The first four currencies on mainnet are legacy nTokens.\\n        return id == 1 && currencyId <= 4;\\n    }\\n\\n    function _getPrimeProxy(bool isDebt, uint16 currencyId) private view returns (ITransferEmitter) {\\n        return isDebt ? \\n            ITransferEmitter(LibStorage.getPDebtAddressStorage()[currencyId]) :\\n            ITransferEmitter(LibStorage.getPCashAddressStorage()[currencyId]);\\n    }\\n\\n    function _fCashPair(\\n        uint16 currencyId, uint256 maturity, int256 amount\\n    ) private pure returns (uint256[] memory, uint256[] memory) {\\n        uint256[] memory ids = new uint256[](2);\\n        uint256 id = _posfCashId(currencyId, maturity);\\n        ids[0] = id;\\n        ids[1] = id | NEGATIVE_FCASH_MASK;\\n\\n        uint256[] memory values = new uint256[](2);\\n        values[0] = uint256(amount.abs());\\n        values[1] = uint256(amount.abs());\\n\\n        return (ids, values);\\n    }\\n\\n    /// @notice Emits a pair of fCash mints. fCash is only ever created or destroyed via these pairs and then\\n    /// the positive side is bought or sold.\\n    function emitChangefCashLiquidity(\\n        address account, uint16 currencyId, uint256 maturity, int256 netDebtChange\\n    ) internal {\\n        (uint256[] memory ids, uint256[] memory values) = _fCashPair(currencyId, maturity, netDebtChange);\\n        address from; address to;\\n        if (netDebtChange < 0) from = account; // burning\\n        else to = account; // minting\\n        emit TransferBatch(msg.sender, from, to, ids, values);\\n    }\\n\\n    /// @notice Transfers positive fCash between accounts\\n    function emitTransferfCash(\\n        address from, address to, uint16 currencyId, uint256 maturity, int256 amount\\n    ) internal {\\n        if (amount == 0) return;\\n        uint256 id = _posfCashId(currencyId, maturity);\\n        // If the amount is negative, then swap the direction of the transfer. We only ever emit\\n        // transfers of positive fCash. Negative fCash is minted on an account and never transferred.\\n        if (amount < 0) (from, to) = (to, from);\\n\\n        emit TransferSingle(msg.sender, from, to, id, uint256(amount.abs()));\\n    }\\n\\n    function emitBatchTransferfCash(\\n        address from, address to, PortfolioAsset[] memory assets\\n    ) internal {\\n        uint256 len = assets.length;\\n        // Emit single events since it's unknown if all of the notional values are positive or negative.\\n        for (uint256 i; i < len; i++) {\\n            emitTransferfCash(from, to, assets[i].currencyId, assets[i].maturity, assets[i].notional);\\n        }\\n    }\\n\\n    /// @notice When fCash is settled, cash or debt is transferred from the \\\"settlement reserve\\\" to the account\\n    /// and the settled fCash is burned.\\n    function emitSettlefCash(\\n        address account, uint16 currencyId, uint256 maturity, int256 fCashSettled, int256 pCashOrDebtValue\\n    ) internal {\\n        // Settlement is the only time when negative fCash is burned directly without destroying the\\n        // opposing positive fCash pair.\\n        uint256 id = _posfCashId(currencyId, maturity);\\n        if (fCashSettled < 0) id = id | NEGATIVE_FCASH_MASK;\\n        emit TransferSingle(msg.sender, account, address(0), id, uint256(fCashSettled.abs()));\\n\\n        // NOTE: zero values will emit a pCash event\\n        ITransferEmitter proxy = _getPrimeProxy(pCashOrDebtValue < 0, currencyId);\\n        proxy.emitTransfer(Constants.SETTLEMENT_RESERVE, account, uint256(pCashOrDebtValue.abs()));\\n    }\\n\\n    /// @notice Emits events to reconcile off chain accounting for the edge condition when\\n    /// leveraged vaults lend at zero interest.\\n    function emitSettlefCashDebtInReserve(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 fCashDebtInReserve,\\n        int256 settledPrimeCash,\\n        int256 excessCash\\n    ) internal {\\n        uint256 id = _posfCashId(currencyId, maturity) | NEGATIVE_FCASH_MASK;\\n        emit TransferSingle(msg.sender, Constants.SETTLEMENT_RESERVE, address(0), id, uint256(fCashDebtInReserve.abs()));\\n        // The settled prime debt doesn't exist in this case since we don't add the debt to the\\n        // total prime debt so we just \\\"burn\\\" the prime cash that only exists in an off chain accounting context.\\n        emitMintOrBurnPrimeCash(Constants.SETTLEMENT_RESERVE, currencyId, settledPrimeCash);\\n        if (excessCash > 0) {\\n            // Any excess prime cash in reserve is \\\"transferred\\\" to the fee reserve\\n            emitTransferPrimeCash(Constants.SETTLEMENT_RESERVE, Constants.FEE_RESERVE, currencyId, excessCash);\\n        }\\n    }\\n\\n    /// @notice During an fCash trade, cash is transferred between the account and then nToken. When borrowing,\\n    /// cash is transferred from the nToken to the account. During lending, the opposite happens. The fee reserve\\n    /// always accrues a positive amount of cash.\\n    function emitfCashMarketTrade(\\n        address account,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 fCashPurchased,\\n        int256 cashToAccount,\\n        int256 cashToReserve\\n    ) internal {\\n        ITransferEmitter cashProxy = ITransferEmitter(LibStorage.getPCashAddressStorage()[currencyId]);\\n        address nToken = LibStorage.getNTokenAddressStorage()[currencyId];\\n        // If account == nToken then this is a lending transaction when the account is\\n        // over leveraged. Still emit the transfer so we can record how much the lending cost and how\\n        // much fCash was purchased.\\n\\n        // Do this calculation so it properly represents that the account is paying the fee to the\\n        // reserve. When borrowing, the account will receive the full cash balance and then transfer\\n        // some amount to the reserve. When lending, the account will transfer the cash to reserve and\\n        // the remainder will be transferred to the nToken.\\n        int256 accountToNToken = cashToAccount.add(cashToReserve);\\n        cashProxy.emitfCashTradeTransfers(account, nToken, accountToNToken, cashToReserve.toUint());\\n\\n        // When lending (fCashPurchased > 0), the nToken transfers positive fCash to the\\n        // account. When the borrowing (fCashPurchased < 0), the account transfers positive fCash to the\\n        // nToken. emitTransferfCash will flip the from and to accordingly.\\n        emitTransferfCash(nToken, account, currencyId, maturity, fCashPurchased);\\n    }\\n\\n    /// @notice When underlying tokens are deposited, prime cash is minted. When underlying tokens are\\n    /// withdrawn, prime cash is burned.\\n    function emitMintOrBurnPrimeCash(\\n        address account, uint16 currencyId, int256 netPrimeCash\\n    ) internal {\\n        ITransferEmitter cashProxy = ITransferEmitter(LibStorage.getPCashAddressStorage()[currencyId]);\\n        cashProxy.emitMintOrBurn(account, netPrimeCash);\\n    }\\n\\n    function emitTransferPrimeCash(\\n        address from, address to, uint16 currencyId, int256 primeCashTransfer\\n    ) internal {\\n        ITransferEmitter cashProxy = ITransferEmitter(LibStorage.getPCashAddressStorage()[currencyId]);\\n        // This can happen during fCash liquidation where the liquidator receives cash for negative fCash\\n        if (primeCashTransfer < 0) (to, from) = (from, to);\\n        cashProxy.emitTransfer(from, to, uint256(primeCashTransfer.abs()));\\n    }\\n\\n    function emitTransferNToken(\\n        address from, address to, uint16 currencyId, int256 netNTokenTransfer\\n    ) internal {\\n        address nToken = LibStorage.getNTokenAddressStorage()[currencyId];\\n        // No scenario where this occurs, but have it here just in case\\n        if (netNTokenTransfer < 0) (to, from) = (from, to);\\n        uint256 value = uint256(netNTokenTransfer.abs());\\n        if (_isLegacyNToken(currencyId)) {\\n            // Legacy nToken contracts do not have an emit method so use an ERC1155 instead\\n            emit TransferSingle(msg.sender, from, to, _legacyNTokenId(currencyId), value);\\n        } else {\\n            ITransferEmitter(nToken).emitTransfer(from, to, value);\\n        }\\n    }\\n\\n    /// @notice When prime debt is created, an offsetting pair of prime cash and prime debt tokens are\\n    /// created (similar to fCash liquidity) and the prime cash tokens are burned (withdrawn) or transferred\\n    /// in exchange for nTokens or fCash. The opposite occurs when prime debt is repaid. Prime cash is burned\\n    /// in order to repay prime debt.\\n    function emitBorrowOrRepayPrimeDebt(\\n        address account, uint16 currencyId, int256 netPrimeSupplyChange, int256 netPrimeDebtChange\\n    ) internal {\\n        ITransferEmitter cashProxy = ITransferEmitter(LibStorage.getPCashAddressStorage()[currencyId]);\\n        ITransferEmitter debtProxy = ITransferEmitter(LibStorage.getPDebtAddressStorage()[currencyId]);\\n        debtProxy.emitMintOrBurn(account, netPrimeDebtChange);\\n        cashProxy.emitMintOrBurn(account, netPrimeSupplyChange);\\n    }\\n\\n    /// @notice Some amount of prime cash is deposited in order to mint nTokens.\\n    function emitNTokenMint(\\n        address account, address nToken, uint16 currencyId, int256 primeCashDeposit, int256 tokensToMint\\n    ) internal {\\n        ITransferEmitter cashProxy = ITransferEmitter(LibStorage.getPCashAddressStorage()[currencyId]);\\n        if (tokensToMint > 0 && primeCashDeposit > 0) {\\n            cashProxy.emitTransfer(account, nToken, uint256(primeCashDeposit));\\n            if (_isLegacyNToken(currencyId)) {\\n                // Legacy nToken contracts do not have an emit method so use an ERC1155 instead\\n                emit TransferSingle(msg.sender, address(0), account, _legacyNTokenId(currencyId), tokensToMint.toUint());\\n            } else {\\n                ITransferEmitter(nToken).emitMintOrBurn(account, tokensToMint);\\n            }\\n        }\\n    }\\n\\n    /// @notice Some amount of prime cash is transferred to the account in exchange for nTokens burned.\\n    /// fCash may also be transferred to the account but that is handled in a different method.\\n    function emitNTokenBurn(\\n        address account, uint16 currencyId, int256 primeCashRedeemed, int256 tokensToBurn\\n    ) internal {\\n        ITransferEmitter cashProxy = ITransferEmitter(LibStorage.getPCashAddressStorage()[currencyId]);\\n        address nToken = LibStorage.getNTokenAddressStorage()[currencyId];\\n\\n        if (primeCashRedeemed > 0 && tokensToBurn > 0) {\\n            cashProxy.emitTransfer(nToken, account, uint256(primeCashRedeemed));\\n            if (_isLegacyNToken(currencyId)) {\\n                // Legacy nToken contracts do not have an emit method so use an ERC1155 instead\\n                emit TransferSingle(msg.sender, account, address(0), _legacyNTokenId(currencyId), tokensToBurn.abs().toUint());\\n            } else {\\n                ITransferEmitter(nToken).emitMintOrBurn(account, tokensToBurn.neg());\\n            }\\n        }\\n    }\\n\\n    function emitVaultFeeTransfers(\\n        address vault, uint16 currencyId, int256 nTokenFee, int256 reserveFee\\n    ) internal{\\n        ITransferEmitter cashProxy = ITransferEmitter(LibStorage.getPCashAddressStorage()[currencyId]);\\n        address nToken = LibStorage.getNTokenAddressStorage()[currencyId];\\n        // These are emitted in the reverse order from the fCash trade transfers so that we can identify it as\\n        // vault fee transfers off chain.\\n        cashProxy.emitTransfer(vault, Constants.FEE_RESERVE, reserveFee.toUint());\\n        cashProxy.emitTransfer(vault, address(nToken), nTokenFee.toUint());\\n    }\\n\\n    /// @notice Detects changes to a vault account and properly emits vault debt, vault shares and vault cash events.\\n    function emitVaultAccountChanges(\\n        VaultAccount memory vaultAccount,\\n        VaultConfig memory vaultConfig,\\n        VaultAccountStorage memory prior,\\n        uint256 newDebtStorageValue\\n    ) internal {\\n        uint256[] memory ids = new uint256[](2);\\n        uint256[] memory values = new uint256[](2);\\n        uint256 baseId = _encodeVaultId(vaultConfig.vault, vaultConfig.borrowCurrencyId, prior.maturity, 0);\\n        ids[0] = baseId | Constants.VAULT_DEBT_ASSET_TYPE;\\n        ids[1] = baseId | Constants.VAULT_SHARE_ASSET_TYPE;\\n\\n        if (vaultAccount.maturity == 0 || (prior.maturity != 0 && prior.maturity != vaultAccount.maturity)) {\\n            // Account has been closed, settled or rolled to a new maturity. Emit burn events for the prior maturity's data.\\n            values[0] = prior.accountDebt;\\n            values[1] = prior.vaultShares;\\n            emit TransferBatch(msg.sender, vaultAccount.account, address(0), ids, values);\\n        } else if (vaultAccount.maturity == prior.maturity) {\\n            // Majority of the time, vault accounts will either burn or mint vault shares and debt at the same time. However,\\n            // when an account sells vault shares to pay down a secondary debt without paying down any primary\\n            // debt in the prime maturity, the debt may increase while the vault shares decreases. In this case, two TransferBatch\\n            // events will be fired. One will be the burn of the vault shares and the second will be the mint of the vault debt.\\n            bool isBurn = newDebtStorageValue < prior.accountDebt || vaultAccount.vaultShares < prior.vaultShares;\\n            if (isBurn) {\\n                values[0] = newDebtStorageValue < uint256(prior.accountDebt) ? prior.accountDebt - newDebtStorageValue : 0;\\n                values[1] = uint256(prior.vaultShares).sub(vaultAccount.vaultShares);\\n                emit TransferBatch(msg.sender, vaultAccount.account, address(0), ids, values);\\n            }\\n\\n            if (!isBurn || prior.accountDebt < newDebtStorageValue) {\\n                values[0] = newDebtStorageValue.sub(prior.accountDebt);\\n                values[1] = prior.vaultShares < vaultAccount.vaultShares ? vaultAccount.vaultShares.sub(prior.vaultShares) : 0;\\n                emit TransferBatch(msg.sender, address(0), vaultAccount.account, ids, values);\\n            }\\n        }\\n\\n        if (vaultAccount.maturity != 0 && prior.maturity != vaultAccount.maturity) {\\n            // Need to mint the shares for the new vault maturity, this may be a new entrant into\\n            // the vault or the vault account rolling to a new maturity\\n            uint256 newBaseId = _encodeVaultId(vaultConfig.vault, vaultConfig.borrowCurrencyId, vaultAccount.maturity, 0);\\n            ids[0] = newBaseId | Constants.VAULT_DEBT_ASSET_TYPE;\\n            ids[1] = newBaseId | Constants.VAULT_SHARE_ASSET_TYPE;\\n            values[0] = newDebtStorageValue;\\n            values[1] = vaultAccount.vaultShares;\\n            emit TransferBatch(msg.sender, address(0), vaultAccount.account, ids, values);\\n        }\\n\\n        if (prior.primaryCash != 0) {\\n            // Cash must always be burned in this method from the prior maturity\\n            emit TransferSingle(\\n                msg.sender,\\n                vaultAccount.account,\\n                address(0),\\n                baseId | Constants.VAULT_CASH_ASSET_TYPE,\\n                prior.primaryCash\\n            );\\n        }\\n\\n    }\\n\\n    /// @notice Emits events during a vault deleverage, where a vault account receives cash and loses\\n    /// vault shares as a result.\\n    function emitVaultDeleverageDebt(\\n        address liquidator,\\n        address account,\\n        address vault,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 depositAmountPrimeCash,\\n        PrimeRate memory pr\\n    ) internal {\\n        // Liquidator transfer prime cash to vault\\n        emitTransferPrimeCash(liquidator, vault, currencyId, depositAmountPrimeCash);\\n        uint256 baseId = _encodeVaultId(vault, currencyId, maturity, 0);\\n        \\n        // Mints vault cash to the account in the same amount as prime cash if it is\\n        // an fCash maturity\\n        if (maturity == Constants.PRIME_CASH_VAULT_MATURITY) {\\n            // Convert this to prime debt basis\\n            int256 primeDebtStorage = PrimeRateLib.convertToStorageValue(pr, depositAmountPrimeCash.neg()).neg();\\n            if (primeDebtStorage == -1) primeDebtStorage = 0;\\n\\n            emit TransferSingle(\\n                msg.sender,\\n                account,\\n                address(0),\\n                baseId | Constants.VAULT_DEBT_ASSET_TYPE,\\n                primeDebtStorage.toUint()\\n            );\\n        } else {\\n            emit TransferSingle(\\n                msg.sender,\\n                address(0),\\n                account,\\n                baseId | Constants.VAULT_CASH_ASSET_TYPE,\\n                depositAmountPrimeCash.toUint()\\n            );\\n        }\\n    }\\n\\n    function emitTransferVaultShares(\\n        address liquidator,\\n        address account,\\n        address vault,\\n        uint16 vaultSharesCurrencyId,\\n        uint256 maturity,\\n        uint256 vaultSharesToLiquidator\\n    ) internal {\\n        // Transfer vault shares to the liquidator\\n        uint256 vaultSharesId = _encodeVaultId(\\n            vault, vaultSharesCurrencyId, maturity, Constants.VAULT_SHARE_ASSET_TYPE\\n        );\\n        emit TransferSingle(\\n            msg.sender, account, liquidator, vaultSharesId, vaultSharesToLiquidator\\n        );\\n    }\\n\\n    /// @notice Emits events for primary cash burned on a vault account.\\n    function emitVaultAccountCashBurn(\\n        address account,\\n        address vault,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 fCash,\\n        int256 vaultCash\\n    ) internal {\\n        uint256 baseId = _encodeVaultId(vault, currencyId, maturity, 0);\\n        uint256[] memory ids = new uint256[](2);\\n        uint256[] memory values = new uint256[](2);\\n        ids[0] = baseId | Constants.VAULT_DEBT_ASSET_TYPE;\\n        ids[1] = baseId | Constants.VAULT_CASH_ASSET_TYPE;\\n        values[0] = fCash.toUint();\\n        values[1] = vaultCash.toUint();\\n        emit TransferBatch(msg.sender, account, address(0), ids, values);\\n    }\\n\\n    /// @notice A set of spurious events to record a direct transfer between vaults and an account\\n    /// during entering and exiting vaults.\\n    function emitVaultMintTransferBurn(\\n        address minter, address burner, uint16 currencyId, uint256 mintAmount, uint256 transferAndBurnAmount\\n    ) internal{\\n        ITransferEmitter cashProxy = ITransferEmitter(LibStorage.getPCashAddressStorage()[currencyId]);\\n        // During vault entry, the account (minter) will deposit mint amount and transfer the\\n        // entirety of it to the vault (burner) who will then withdraw it all into the strategy (burn).\\n\\n        // During vault exit, the vault (minter) will \\\"receive\\\" sufficient cash to repay debt and\\n        // some additional profits to the account. The vault will \\\"transferAndBurn\\\" the profits\\n        // to the account. The cash for repayment to Notional will be transferred into fCash markets\\n        // or used to burn prime supply debt. These events will be emitted separately.\\n\\n        cashProxy.emitMintTransferBurn(minter, burner, mintAmount, transferAndBurnAmount);\\n    }\\n\\n    function emitVaultMintOrBurnCash(\\n        address account,\\n        address vault,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 netVaultCash\\n    ) internal {\\n        if (netVaultCash == 0) return;\\n        uint256 id = _encodeVaultId(vault, currencyId, maturity, Constants.VAULT_CASH_ASSET_TYPE);\\n        address from; address to;\\n        if (netVaultCash < 0) {\\n            // Burn\\n            from = account; to = address(0);\\n        } else {\\n            // Mint\\n            from = address(0); to = account;\\n        }\\n\\n        uint256 value = uint256(netVaultCash.abs());\\n        emit TransferSingle(msg.sender, from, to, id, value);\\n    }\\n\\n    /// @notice Emits an event where the vault borrows or repays secondary debt\\n    function emitVaultSecondaryDebt(\\n        address account,\\n        address vault,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 vaultDebtAmount\\n    ) internal {\\n        if (vaultDebtAmount == 0) return;\\n        address from;\\n        address to;\\n        uint256 id = _encodeVaultId(vault, currencyId, maturity, Constants.VAULT_DEBT_ASSET_TYPE);\\n\\n        if (vaultDebtAmount > 0) {\\n            // Debt amounts are negative, burning when positive\\n            from = account; to = address(0);\\n         } else {\\n            // Minting when negative\\n            from = address(0); to = account;\\n         }\\n\\n        emit TransferSingle(msg.sender, from, to, id, uint256(vaultDebtAmount.abs()));\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/liquidation/LiquidatefCash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    ETHRate,\\n    PortfolioAsset,\\n    CashGroupParameters,\\n    PortfolioState,\\n    Token,\\n    AccountContext,\\n    PrimeRate,\\n    LiquidationFactors\\n} from \\\"../../global/Types.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\n\\nimport {Emitter} from \\\"../Emitter.sol\\\";\\nimport {AssetHandler} from \\\"../valuation/AssetHandler.sol\\\";\\nimport {CashGroup} from \\\"../markets/CashGroup.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {TokenHandler} from \\\"../balances/TokenHandler.sol\\\";\\nimport {BalanceHandler} from \\\"../balances/BalanceHandler.sol\\\";\\nimport {ExchangeRate} from \\\"../valuation/ExchangeRate.sol\\\";\\nimport {PortfolioHandler} from \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport {BitmapAssetsHandler} from \\\"../portfolio/BitmapAssetsHandler.sol\\\";\\n\\nimport {AccountContextHandler} from \\\"../AccountContextHandler.sol\\\";\\nimport {LiquidationHelpers} from \\\"./LiquidationHelpers.sol\\\";\\n\\nimport {FreeCollateralExternal} from \\\"../../external/FreeCollateralExternal.sol\\\";\\nimport {SettleAssetsExternal} from \\\"../../external/SettleAssetsExternal.sol\\\";\\n\\nlibrary LiquidatefCash {\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n    using ExchangeRate for ETHRate;\\n    using AssetHandler for PortfolioAsset;\\n    using CashGroup for CashGroupParameters;\\n    using PrimeRateLib for PrimeRate;\\n    using AccountContextHandler for AccountContext;\\n    using TokenHandler for Token;\\n\\n    event LiquidatefCashEvent(\\n        address indexed liquidated,\\n        address indexed liquidator,\\n        uint16 localCurrencyId,\\n        uint16 fCashCurrency,\\n        int256 netLocalFromLiquidator,\\n        uint256[] fCashMaturities,\\n        int256[] fCashNotionalTransfer\\n    );\\n\\n    /// @notice Calculates the risk adjusted and liquidation discount factors used when liquidating fCash. The\\n    /// The risk adjusted discount factor is used to value fCash, the liquidation discount factor is used to \\n    /// calculate the price of the fCash asset at a discount to the risk adjusted factor.\\n    /// @dev During local fCash liquidation, collateralCashGroup will be set to the local currency cash group\\n    function _calculatefCashDiscounts(\\n        LiquidationFactors memory factors,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        bool isNotionalPositive\\n    ) private view returns (int256 riskAdjustedDiscountFactor, int256 liquidationDiscountFactor) {\\n        uint256 oracleRate = factors.collateralCashGroup.calculateOracleRate(maturity, blockTime);\\n\\n        if (isNotionalPositive) {\\n            // This is the discount factor used to calculate the fCash present value during free collateral\\n            riskAdjustedDiscountFactor = AssetHandler.getRiskAdjustedfCashDiscount(\\n                factors.collateralCashGroup, maturity, blockTime\\n            );\\n\\n            // This is the discount factor that liquidators get to purchase fCash at, will be larger than\\n            // the risk adjusted discount factor.\\n            liquidationDiscountFactor = AssetHandler.getDiscountFactor(\\n                maturity.sub(blockTime),\\n                oracleRate.add(factors.collateralCashGroup.getLiquidationfCashHaircut())\\n            );\\n        } else {\\n            riskAdjustedDiscountFactor = AssetHandler.getRiskAdjustedDebtDiscount(\\n                factors.collateralCashGroup, maturity, blockTime\\n            );\\n\\n            uint256 buffer = factors.collateralCashGroup.getLiquidationDebtBuffer();\\n            liquidationDiscountFactor = AssetHandler.getDiscountFactor(\\n                maturity.sub(blockTime),\\n                oracleRate < buffer ? 0 : oracleRate.sub(buffer)\\n            );\\n        }\\n    }\\n\\n    /// @notice Returns the fCashNotional for a given account, currency and maturity.\\n    /// @return the notional amount\\n    function _getfCashNotional(\\n        address liquidateAccount,\\n        fCashContext memory context,\\n        uint256 currencyId,\\n        uint256 maturity\\n    ) private view returns (int256) {\\n        if (context.accountContext.bitmapCurrencyId == currencyId) {\\n            return\\n                BitmapAssetsHandler.getifCashNotional(liquidateAccount, currencyId, maturity);\\n        }\\n\\n        PortfolioAsset[] memory portfolio = context.portfolio.storedAssets;\\n        // Loop backwards through the portfolio since we require fCash maturities to be sorted\\n        // descending\\n        for (uint256 i = portfolio.length; (i--) > 0;) {\\n            PortfolioAsset memory asset = portfolio[i];\\n            if (\\n                asset.currencyId == currencyId &&\\n                asset.assetType == Constants.FCASH_ASSET_TYPE &&\\n                asset.maturity == maturity\\n            ) {\\n                return asset.notional;\\n            }\\n        }\\n\\n        // If asset is not found then we return zero instead of failing in the case that a previous\\n        // liquidation has already liquidated the specified fCash asset. This liquidation can continue\\n        // to the next specified fCash asset.\\n        return 0;\\n    }\\n\\n    struct fCashContext {\\n        AccountContext accountContext;\\n        LiquidationFactors factors;\\n        PortfolioState portfolio;\\n        int256 localCashBalanceUnderlying;\\n        int256 underlyingBenefitRequired;\\n        int256 localPrimeCashFromLiquidator;\\n        int256 liquidationDiscount;\\n        int256[] fCashNotionalTransfers;\\n    }\\n\\n    /// @notice Allows the liquidator to purchase fCash in the same currency that a debt is denominated in. It's\\n    /// also possible that there is no debt in the local currency, in that case the liquidated account will gain the\\n    /// benefit of the difference between the discounted fCash value and the cash\\n    function liquidatefCashLocal(\\n        address liquidateAccount,\\n        uint256 localCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts,\\n        fCashContext memory c,\\n        uint256 blockTime\\n    ) internal view {\\n        // If local asset available == 0 then there is nothing that this liquidation can do.\\n        require(c.factors.localPrimeAvailable != 0);\\n\\n        // If local available is positive then we can trade fCash to cash to increase the total free\\n        // collateral of the account. Local available will always increase due to the removal of the haircut\\n        // on fCash assets as they are converted to cash. The increase will be the difference between the\\n        // risk adjusted haircut value and the liquidation value. Note that negative fCash assets can also be\\n        // liquidated via this method, the liquidator will receive negative fCash and cash as a result -- in effect\\n        // they will be borrowing at a discount to the oracle rate.\\n        c.underlyingBenefitRequired = LiquidationHelpers.calculateLocalLiquidationUnderlyingRequired(\\n            c.factors.localPrimeAvailable,\\n            c.factors.netETHValue,\\n            c.factors.localETHRate\\n        );\\n\\n        for (uint256 i = 0; i < fCashMaturities.length; i++) {\\n            // Require that fCash maturities are sorted descending. This ensures that a maturity can only\\n            // be specified exactly once. It also ensures that the longest dated assets (most risky) are\\n            // liquidated first.\\n            if (i > 0) require(fCashMaturities[i - 1] > fCashMaturities[i]);\\n\\n            int256 notional =\\n                _getfCashNotional(liquidateAccount, c, localCurrency, fCashMaturities[i]);\\n            // If a notional balance is negative, ensure that there is some local cash balance to\\n            // purchase for the liquidation. Allow a zero cash balance so that the loop continues even if\\n            // all of the cash balance has been transferred.\\n            if (notional < 0) require(c.localCashBalanceUnderlying >= 0); // dev: insufficient cash balance\\n            if (notional == 0) continue;\\n\\n            // If notional > 0 then liquidation discount > risk adjusted discount\\n            //    this is because the liquidation oracle rate < risk adjusted oracle rate\\n            // If notional < 0 then liquidation discount < risk adjusted discount\\n            //    this is because the liquidation oracle rate > risk adjusted oracle rate\\n            (int256 riskAdjustedDiscountFactor, int256 liquidationDiscountFactor) =\\n                _calculatefCashDiscounts(c.factors, fCashMaturities[i], blockTime, notional > 0);\\n\\n            // The benefit to the liquidated account is the difference between the liquidation discount factor\\n            // and the risk adjusted discount factor:\\n            // localCurrencyBenefit = fCash * (liquidationDiscountFactor - riskAdjustedDiscountFactor)\\n            // fCash = localCurrencyBenefit / (liquidationDiscountFactor - riskAdjustedDiscountFactor)\\n            // abs is used here to ensure positive values\\n            c.fCashNotionalTransfers[i] = c.underlyingBenefitRequired\\n            // NOTE: Governance should be set such that these discount factors are unlikely to be zero. It's\\n            // possible that the interest rates are so low or that the fCash asset is very close to maturity\\n            // that this situation can occur. In this case, there would be almost zero benefit to liquidating\\n            // the particular fCash asset.\\n                .divInRatePrecision(liquidationDiscountFactor.sub(riskAdjustedDiscountFactor).abs());\\n\\n            // fCashNotionalTransfers[i] is always positive at this point. The max liquidate amount is\\n            // calculated using the absolute value of the notional amount to ensure that the inequalities\\n            // operate properly inside calculateLiquidationAmount.\\n            c.fCashNotionalTransfers[i] = LiquidationHelpers.calculateLiquidationAmount(\\n                c.fCashNotionalTransfers[i], // liquidate amount required\\n                notional.abs(), // max total balance\\n                SafeInt256.toInt(maxfCashLiquidateAmounts[i]) // user specified maximum\\n            );\\n\\n            // This is the price the liquidator pays of the fCash that has been liquidated\\n            int256 fCashLiquidationValueUnderlying =\\n                c.fCashNotionalTransfers[i].mulInRatePrecision(liquidationDiscountFactor);\\n\\n            if (notional < 0) {\\n                // In the case of negative notional amounts, limit the amount of liquidation to the local cash\\n                // balance in underlying so that the liquidated account does not incur a negative cash balance.\\n                if (fCashLiquidationValueUnderlying > c.localCashBalanceUnderlying) {\\n                    // We know that all these values are positive at this point.\\n                    c.fCashNotionalTransfers[i] = c.fCashNotionalTransfers[i]\\n                        .mul(c.localCashBalanceUnderlying)\\n                        .div(fCashLiquidationValueUnderlying);\\n                    fCashLiquidationValueUnderlying = c.localCashBalanceUnderlying;\\n                }\\n\\n                // Flip the sign when the notional is negative\\n                c.fCashNotionalTransfers[i] = c.fCashNotionalTransfers[i].neg();\\n                // When the notional is negative, cash balance will be transferred to the liquidator instead of\\n                // being provided by the liquidator.\\n                fCashLiquidationValueUnderlying = fCashLiquidationValueUnderlying.neg();\\n            }\\n\\n            // NOTE: localPrimeCashFromLiquidator is actually in underlying terms during this loop, it is converted to asset terms just once\\n            // at the end of the loop to limit loss of precision\\n            c.localPrimeCashFromLiquidator = c.localPrimeCashFromLiquidator.add(\\n                fCashLiquidationValueUnderlying\\n            );\\n            c.localCashBalanceUnderlying = c.localCashBalanceUnderlying.add(\\n                fCashLiquidationValueUnderlying\\n            );\\n\\n            // Deduct the total benefit gained from liquidating this fCash position\\n            c.underlyingBenefitRequired = c.underlyingBenefitRequired.sub(\\n                c.fCashNotionalTransfers[i]\\n                    .mulInRatePrecision(liquidationDiscountFactor.sub(riskAdjustedDiscountFactor))\\n                    .abs()\\n            );\\n\\n            // Once the underlying benefit is reduced below zero then we have liquidated a sufficient amount\\n            if (c.underlyingBenefitRequired <= 0) break;\\n        }\\n\\n        // Convert local to purchase to asset terms for transfers\\n        c.localPrimeCashFromLiquidator = c.factors.localPrimeRate.convertFromUnderlying(\\n            c.localPrimeCashFromLiquidator\\n        );\\n    }\\n\\n    /// @notice Allows the liquidator to purchase fCash in a different currency that a debt is denominated in.\\n    function liquidatefCashCrossCurrency(\\n        address liquidateAccount,\\n        uint256 collateralCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts,\\n        fCashContext memory c,\\n        uint256 blockTime\\n    ) internal view {\\n        require(c.factors.localPrimeAvailable < 0); // dev: no local debt\\n        require(c.factors.collateralAssetAvailable > 0); // dev: no collateral assets\\n\\n        {\\n            // NOTE: underlying benefit is return in asset terms from this function, convert it to underlying\\n            // for the purposes of this method. The underlyingBenefitRequired is denominated in collateral currency\\n            // and equivalent to convertToCollateral(netETHValue.neg()).\\n            (c.underlyingBenefitRequired, c.liquidationDiscount) = LiquidationHelpers\\n                .calculateCrossCurrencyFactors(c.factors);\\n            c.underlyingBenefitRequired = c.factors.collateralCashGroup.primeRate.convertToUnderlying(\\n                c.underlyingBenefitRequired\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < fCashMaturities.length; i++) {\\n            // Require that fCash maturities are sorted descending. This ensures that a maturity can only\\n            // be specified exactly once. It also ensures that the longest dated assets (most risky) are\\n            // liquidated first.\\n            if (i > 0) require(fCashMaturities[i - 1] > fCashMaturities[i]);\\n\\n            int256 notional =\\n                _getfCashNotional(liquidateAccount, c, collateralCurrency, fCashMaturities[i]);\\n            if (notional == 0) continue;\\n            require(notional > 0); // dev: invalid fcash asset\\n\\n            c.fCashNotionalTransfers[i] = _calculateCrossCurrencyfCashToLiquidate(\\n                c,\\n                fCashMaturities[i],\\n                blockTime,\\n                SafeInt256.toInt(maxfCashLiquidateAmounts[i]),\\n                notional\\n            );\\n\\n            if (\\n                c.underlyingBenefitRequired <= 0 ||\\n                // These two factors will be capped and floored at zero inside `_limitPurchaseByAvailableAmounts`\\n                c.factors.collateralAssetAvailable == 0 ||\\n                c.factors.localPrimeAvailable == 0\\n            ) break;\\n        }\\n    }\\n\\n    function _calculateCrossCurrencyfCashToLiquidate(\\n        fCashContext memory c,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        int256 maxfCashLiquidateAmount,\\n        int256 notional\\n    ) private view returns (int256) {\\n        (int256 riskAdjustedDiscountFactor, int256 liquidationDiscountFactor) =\\n            _calculatefCashDiscounts(c.factors, maturity, blockTime, true);\\n\\n        // collateralPurchased = fCashToLiquidate * fCashDiscountFactor\\n        // (see: _calculateCollateralToRaise)\\n        // collateralBenefit = collateralPurchased * (localBuffer / liquidationDiscount - collateralHaircut)\\n        // totalBenefit = fCashBenefit + collateralBenefit\\n        // totalBenefit = fCashToLiquidate * (liquidationDiscountFactor - riskAdjustedDiscountFactor) +\\n        //      fCashToLiquidate * liquidationDiscountFactor * (localBuffer / liquidationDiscount - collateralHaircut)\\n        // totalBenefit = fCashToLiquidate * [\\n        //      (liquidationDiscountFactor - riskAdjustedDiscountFactor) +\\n        //      (liquidationDiscountFactor * (localBuffer / liquidationDiscount - collateralHaircut))\\n        // ]\\n        // fCashToLiquidate = totalBenefit / [\\n        //      (liquidationDiscountFactor - riskAdjustedDiscountFactor) +\\n        //      (liquidationDiscountFactor * (localBuffer / liquidationDiscount - collateralHaircut))\\n        // ]\\n        int256 benefitDivisor;\\n        {\\n            // prettier-ignore\\n            int256 termTwo = (\\n                    c.factors.localETHRate.buffer.mul(Constants.PERCENTAGE_DECIMALS).div(\\n                        c.liquidationDiscount\\n                    )\\n                ).sub(c.factors.collateralETHRate.haircut);\\n            termTwo = liquidationDiscountFactor.mul(termTwo).div(Constants.PERCENTAGE_DECIMALS);\\n            int256 termOne = liquidationDiscountFactor.sub(riskAdjustedDiscountFactor);\\n            benefitDivisor = termOne.add(termTwo);\\n        }\\n\\n        int256 fCashToLiquidate =\\n            c.underlyingBenefitRequired.divInRatePrecision(benefitDivisor);\\n\\n        fCashToLiquidate = LiquidationHelpers.calculateLiquidationAmount(\\n            fCashToLiquidate,\\n            notional,\\n            maxfCashLiquidateAmount\\n        );\\n\\n        // Ensures that local available does not go above zero and collateral available does not go below zero\\n        int256 localPrimeCashFromLiquidator;\\n        (fCashToLiquidate, localPrimeCashFromLiquidator) = _limitPurchaseByAvailableAmounts(\\n            c,\\n            liquidationDiscountFactor,\\n            riskAdjustedDiscountFactor,\\n            fCashToLiquidate\\n        );\\n\\n        // inverse of initial fCashToLiquidate calculation above\\n        // totalBenefit = fCashToLiquidate * [\\n        //      (liquidationDiscountFactor - riskAdjustedDiscountFactor) +\\n        //      (liquidationDiscountFactor * (localBuffer / liquidationDiscount - collateralHaircut))\\n        // ]\\n        int256 benefitGainedUnderlying = fCashToLiquidate.mulInRatePrecision(benefitDivisor);\\n\\n        c.underlyingBenefitRequired = c.underlyingBenefitRequired.sub(benefitGainedUnderlying);\\n        c.localPrimeCashFromLiquidator = c.localPrimeCashFromLiquidator.add(\\n            localPrimeCashFromLiquidator\\n        );\\n\\n        return fCashToLiquidate;\\n    }\\n\\n    /// @dev Limits the fCash purchase to ensure that collateral available and local available do not go below zero,\\n    /// in both those cases the liquidated account would incur debt\\n    function _limitPurchaseByAvailableAmounts(\\n        fCashContext memory c,\\n        int256 liquidationDiscountFactor,\\n        int256 riskAdjustedDiscountFactor,\\n        int256 fCashToLiquidate\\n    ) private pure returns (int256, int256) {\\n        // The collateral value of the fCash is discounted back to PV given the liquidation discount factor,\\n        // this is the discounted value that the liquidator will purchase it at.\\n        int256 fCashLiquidationUnderlyingPV = fCashToLiquidate.mulInRatePrecision(liquidationDiscountFactor);\\n        int256 fCashRiskAdjustedUnderlyingPV = fCashToLiquidate.mulInRatePrecision(riskAdjustedDiscountFactor);\\n\\n        // Ensures that collateralAssetAvailable does not go below zero\\n        int256 collateralUnderlyingAvailable =\\n            c.factors.collateralCashGroup.primeRate.convertToUnderlying(c.factors.collateralAssetAvailable);\\n        if (fCashRiskAdjustedUnderlyingPV > collateralUnderlyingAvailable) {\\n            // If inside this if statement then all collateralAssetAvailable should be coming from fCashRiskAdjustedPV\\n            // collateralAssetAvailable = fCashRiskAdjustedPV\\n            // collateralAssetAvailable = fCashToLiquidate * riskAdjustedDiscountFactor\\n            // fCashToLiquidate = collateralAssetAvailable / riskAdjustedDiscountFactor\\n            fCashToLiquidate = collateralUnderlyingAvailable.divInRatePrecision(riskAdjustedDiscountFactor);\\n\\n            fCashRiskAdjustedUnderlyingPV = collateralUnderlyingAvailable;\\n\\n            // Recalculate the PV at the new liquidation amount\\n            fCashLiquidationUnderlyingPV = fCashToLiquidate.mulInRatePrecision(liquidationDiscountFactor);\\n        }\\n\\n        int256 localPrimeCashFromLiquidator;\\n        (fCashToLiquidate, localPrimeCashFromLiquidator) = LiquidationHelpers.calculateLocalToPurchase(\\n            c.factors,\\n            c.liquidationDiscount,\\n            fCashLiquidationUnderlyingPV,\\n            fCashToLiquidate\\n        );\\n\\n        // As we liquidate here the local available and collateral available will change. Update values accordingly so\\n        // that the limits will be hit on subsequent iterations.\\n        c.factors.collateralAssetAvailable = c.factors.collateralAssetAvailable.subNoNeg(\\n            c.factors.collateralCashGroup.primeRate.convertFromUnderlying(fCashRiskAdjustedUnderlyingPV)\\n        );\\n        // Cannot have a negative value here, local asset available should always increase as a result of\\n        // cross currency liquidation.\\n        require(localPrimeCashFromLiquidator >= 0);\\n        c.factors.localPrimeAvailable = c.factors.localPrimeAvailable.add(\\n            localPrimeCashFromLiquidator\\n        );\\n\\n        return (fCashToLiquidate, localPrimeCashFromLiquidator);\\n    }\\n\\n    /**\\n     * @notice Finalizes fCash liquidation for both local and cross currency liquidation.\\n     * @dev Since fCash liquidation only ever results in transfers of cash and fCash we\\n     * don't use BalanceHandler.finalize here to save some bytecode space (desperately\\n     * needed for this particular contract.) We use a special function just for fCash\\n     * liquidation to update the cash balance on the liquidated account.\\n     */\\n    function finalizefCashLiquidation(\\n        address liquidateAccount,\\n        address liquidator,\\n        uint16 localCurrency,\\n        uint16 fCashCurrency,\\n        uint256[] calldata fCashMaturities,\\n        fCashContext memory c\\n    ) internal returns (int256[] memory, int256) {\\n        Token memory token = TokenHandler.getUnderlyingToken(localCurrency);\\n        AccountContext memory liquidatorContext = AccountContextHandler.getAccountContext(liquidator);\\n        int256 netLocalFromLiquidator = c.localPrimeCashFromLiquidator;\\n        PrimeRate memory primeRate = PrimeRateLib.buildPrimeRateStateful(localCurrency);\\n\\n        if (token.hasTransferFee && netLocalFromLiquidator > 0) {\\n            // If a token has a transfer fee then it must have been deposited prior to the liquidation\\n            // or else we won't be able to net off the correct amount. We also require that the account\\n            // does not have debt so that we do not have to run a free collateral check here\\n            require(liquidatorContext.hasDebt == 0x00, \\\"Has debt\\\"); // dev: token has transfer fee, no liquidator balance\\n\\n            // Net off the cash balance for the liquidator. If the cash balance goes negative here then it will revert.\\n            BalanceHandler.setBalanceStorageForfCashLiquidation(\\n                liquidator,\\n                liquidatorContext,\\n                localCurrency,\\n                netLocalFromLiquidator.neg(),\\n                primeRate\\n            );\\n        } else if (netLocalFromLiquidator > 0) {\\n            // In any other case, do a token transfer for the liquidator (either into or out of Notional)\\n            // and do not credit any cash balance. That will be done just for the liquidated account.\\n            TokenHandler.depositExactToMintPrimeCash(\\n                liquidator,\\n                localCurrency,\\n                netLocalFromLiquidator,\\n                primeRate,\\n                false // ETH will be returned natively to the liquidator\\n            );\\n        } else {\\n            // In negative fCash liquidation, netLocalFromLiquidator < 0, meaning the liquidator is paid\\n            // cash and will receive it in their cash balance. This ensures that there is greater likelihood\\n            // of passing a free collateral check. Negative fCash liquidation is profitable from a PnL perspective\\n            // but will not necessarily increase the free collateral of the liquidator due to fCash discounts\\n            // and haircuts.\\n            BalanceHandler.setBalanceStorageForfCashLiquidation(\\n                liquidator,\\n                liquidatorContext,\\n                localCurrency,\\n                netLocalFromLiquidator.neg(),\\n                primeRate\\n            );\\n        }\\n\\n        // If netLocalFromLiquidator < 0, will flip the from and to addresses\\n        Emitter.emitTransferPrimeCash(liquidator, liquidateAccount, localCurrency, netLocalFromLiquidator);\\n\\n        BalanceHandler.setBalanceStorageForfCashLiquidation(\\n            liquidateAccount,\\n            c.accountContext,\\n            localCurrency,\\n            netLocalFromLiquidator,\\n            primeRate\\n        );\\n\\n        bool liquidatorIncursDebt;\\n        (liquidatorIncursDebt, liquidatorContext) =\\n            _transferAssets(\\n                liquidateAccount,\\n                liquidator,\\n                liquidatorContext,\\n                fCashCurrency,\\n                fCashMaturities,\\n                c\\n            );\\n\\n        emit LiquidatefCashEvent(\\n            liquidateAccount,\\n            liquidator,\\n            localCurrency,\\n            fCashCurrency,\\n            c.localPrimeCashFromLiquidator,\\n            fCashMaturities,\\n            c.fCashNotionalTransfers\\n        );\\n\\n        liquidatorContext.setAccountContext(liquidator);\\n        c.accountContext.setAccountContext(liquidateAccount);\\n\\n        // If the liquidator takes on debt as a result of the liquidation and has debt in their portfolio\\n        // then they must have a free collateral check. It's possible for the liquidator to skip this if the\\n        // negative fCash incurred from the liquidation nets off against an existing fCash position.\\n        if (liquidatorIncursDebt && liquidatorContext.hasDebt != 0x00) {\\n            FreeCollateralExternal.checkFreeCollateralAndRevert(liquidator);\\n        }\\n\\n        return (c.fCashNotionalTransfers, c.localPrimeCashFromLiquidator);\\n    }\\n\\n    function _transferAssets(\\n        address liquidateAccount,\\n        address liquidator,\\n        AccountContext memory liquidatorContext,\\n        uint16 fCashCurrency,\\n        uint256[] calldata fCashMaturities,\\n        fCashContext memory c\\n    ) private returns (bool, AccountContext memory) {\\n        (PortfolioAsset[] memory assets, bool liquidatorIncursDebt) =\\n            _makeAssetArray(fCashCurrency, fCashMaturities, c.fCashNotionalTransfers);\\n\\n        (c.accountContext, liquidatorContext) = SettleAssetsExternal.transferAssets(\\n            liquidateAccount,\\n            liquidator,\\n            c.accountContext,\\n            liquidatorContext,\\n            assets\\n        );\\n\\n        return (liquidatorIncursDebt, liquidatorContext);\\n    }\\n\\n    function _makeAssetArray(\\n        uint16 fCashCurrency,\\n        uint256[] calldata fCashMaturities,\\n        int256[] memory fCashNotionalTransfers\\n    ) private pure returns (PortfolioAsset[] memory, bool) {\\n        require(fCashMaturities.length == fCashNotionalTransfers.length);\\n\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](fCashMaturities.length);\\n        bool liquidatorIncursDebt = false;\\n        for (uint256 i = 0; i < fCashMaturities.length; i++) {\\n            PortfolioAsset memory asset = assets[i];\\n            asset.currencyId = fCashCurrency;\\n            asset.assetType = Constants.FCASH_ASSET_TYPE;\\n            asset.notional = fCashNotionalTransfers[i];\\n            asset.maturity = fCashMaturities[i];\\n\\n            if (asset.notional < 0) liquidatorIncursDebt = true;\\n        }\\n\\n        return (assets, liquidatorIncursDebt);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/liquidation/LiquidationHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    ETHRate,\\n    BalanceState,\\n    PrimeRate,\\n    AccountContext,\\n    Token,\\n    PortfolioAsset,\\n    LiquidationFactors,\\n    PortfolioState\\n} from \\\"../../global/Types.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\n\\nimport {Emitter} from \\\"../Emitter.sol\\\";\\nimport {AccountContextHandler} from \\\"../AccountContextHandler.sol\\\";\\nimport {ExchangeRate} from \\\"../valuation/ExchangeRate.sol\\\";\\nimport {BalanceHandler} from \\\"../balances/BalanceHandler.sol\\\";\\nimport {TokenHandler} from \\\"../balances/TokenHandler.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {FreeCollateralExternal} from \\\"../../external/FreeCollateralExternal.sol\\\";\\n\\nlibrary LiquidationHelpers {\\n    using SafeInt256 for int256;\\n    using ExchangeRate for ETHRate;\\n    using BalanceHandler for BalanceState;\\n    using PrimeRateLib for PrimeRate;\\n    using AccountContextHandler for AccountContext;\\n    using TokenHandler for Token;\\n\\n    /// @notice Settles accounts and returns liquidation factors for all of the liquidation actions. Also\\n    /// returns the account context and portfolio state post settlement. All liquidation actions will start\\n    /// here to get their required preconditions met.\\n    function preLiquidationActions(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint16 collateralCurrency\\n    )\\n        internal\\n        returns (\\n            AccountContext memory,\\n            LiquidationFactors memory,\\n            PortfolioState memory\\n        )\\n    {\\n        // Cannot liquidate yourself\\n        require(msg.sender != liquidateAccount);\\n        require(localCurrency != 0);\\n        // Collateral currency must be unset or not equal to the local currency\\n        require(collateralCurrency != localCurrency);\\n        (\\n            AccountContext memory accountContext,\\n            LiquidationFactors memory factors,\\n            PortfolioAsset[] memory portfolio\\n        ) =\\n            FreeCollateralExternal.getLiquidationFactors(\\n                liquidateAccount,\\n                localCurrency,\\n                collateralCurrency\\n            );\\n        // Set the account context here to ensure that the context is up to date during\\n        // calculation methods\\n        accountContext.setAccountContext(liquidateAccount);\\n\\n        PortfolioState memory portfolioState =\\n            PortfolioState({\\n                storedAssets: portfolio,\\n                newAssets: new PortfolioAsset[](0),\\n                lastNewAssetIndex: 0,\\n                storedAssetLength: portfolio.length\\n            });\\n\\n        return (accountContext, factors, portfolioState);\\n    }\\n\\n    /// @notice We allow liquidators to purchase up to Constants.DEFAULT_LIQUIDATION_PORTION percentage of collateral\\n    /// assets during liquidation to recollateralize an account as long as it does not also put the account\\n    /// further into negative free collateral (i.e. constraints on local available and collateral available).\\n    /// Additionally, we allow the liquidator to specify a maximum amount of collateral they would like to\\n    /// purchase so we also enforce that limit here.\\n    /// @param liquidateAmountRequired this is the amount required by liquidation to get back to positive free collateral\\n    /// @param maxTotalBalance the maximum total balance of the asset the account has\\n    /// @param userSpecifiedMaximum the maximum amount the liquidator is willing to purchase\\n    function calculateLiquidationAmount(\\n        int256 liquidateAmountRequired,\\n        int256 maxTotalBalance,\\n        int256 userSpecifiedMaximum\\n    ) internal pure returns (int256) {\\n        // By default, the liquidator is allowed to purchase at least to `defaultAllowedAmount`\\n        // if `liquidateAmountRequired` is less than `defaultAllowedAmount`.\\n        int256 defaultAllowedAmount =\\n            maxTotalBalance.mul(Constants.DEFAULT_LIQUIDATION_PORTION).div(\\n                Constants.PERCENTAGE_DECIMALS\\n            );\\n\\n        int256 result = liquidateAmountRequired;\\n\\n        // Limit the purchase amount by the max total balance, we cannot purchase\\n        // more than what is available.\\n        if (liquidateAmountRequired > maxTotalBalance) {\\n            result = maxTotalBalance;\\n        }\\n\\n        // Allow the liquidator to go up to the default allowed amount which is always\\n        // less than the maxTotalBalance\\n        if (liquidateAmountRequired < defaultAllowedAmount) {\\n            result = defaultAllowedAmount;\\n        }\\n\\n        if (userSpecifiedMaximum > 0 && result > userSpecifiedMaximum) {\\n            // Do not allow liquidation above the user specified maximum\\n            result = userSpecifiedMaximum;\\n        }\\n\\n        return result;\\n    }\\n\\n    /// @notice Calculates the amount of underlying benefit required for local currency and fCash\\n    /// liquidations. Uses the netETHValue converted back to local currency to maximize the benefit\\n    /// gained from local liquidations.\\n    /// @return the amount of underlying asset required\\n    function calculateLocalLiquidationUnderlyingRequired(\\n        int256 localPrimeAvailable,\\n        int256 netETHValue,\\n        ETHRate memory localETHRate\\n    ) internal pure returns (int256) {\\n            // Formula in both cases requires dividing by the haircut or buffer:\\n            // convertToLocal(netFCShortfallInETH) = localRequired * haircut\\n            // convertToLocal(netFCShortfallInETH) / haircut = localRequired\\n            //\\n            // convertToLocal(netFCShortfallInETH) = localRequired * buffer\\n            // convertToLocal(netFCShortfallInETH) / buffer = localRequired\\n            int256 multiple = localPrimeAvailable > 0 ? localETHRate.haircut : localETHRate.buffer;\\n\\n            // Multiple will equal zero when the haircut is zero, in this case localAvailable > 0 but\\n            // liquidating a currency that is haircut to zero will have no effect on the netETHValue.\\n            require(multiple > 0); // dev: cannot liquidate haircut asset\\n\\n            // netETHValue must be negative to be inside liquidation\\n            return localETHRate.convertETHTo(netETHValue.neg())\\n                    .mul(Constants.PERCENTAGE_DECIMALS)\\n                    .div(multiple);\\n    }\\n\\n    /// @dev Calculates factors when liquidating across two currencies\\n    function calculateCrossCurrencyFactors(LiquidationFactors memory factors)\\n        internal\\n        pure\\n        returns (int256 collateralDenominatedFC, int256 liquidationDiscount)\\n    {\\n        collateralDenominatedFC = factors.collateralCashGroup.primeRate.convertFromUnderlying(\\n            factors\\n                .collateralETHRate\\n                // netETHValue must be negative to be in liquidation\\n                .convertETHTo(factors.netETHValue.neg())\\n        );\\n\\n        liquidationDiscount = SafeInt256.max(\\n            factors.collateralETHRate.liquidationDiscount,\\n            factors.localETHRate.liquidationDiscount\\n        );\\n    }\\n\\n    /// @notice Calculates the local to purchase in cross currency liquidations. Ensures that local to purchase\\n    /// is not so large that the account is put further into debt.\\n    /// @return\\n    ///     collateralBalanceToSell: the amount of collateral balance to be sold to the liquidator (it can either\\n    ///     be asset cash in the case of currency liquidations or fcash in the case of cross currency fcash liquidation,\\n    ///     this is scaled by a unitless proportion in the method).\\n    ///     localAssetFromLiquidator: the amount of asset cash from the liquidator\\n    function calculateLocalToPurchase(\\n        LiquidationFactors memory factors,\\n        int256 liquidationDiscount,\\n        int256 collateralUnderlyingPresentValue,\\n        int256 collateralBalanceToSell\\n    ) internal pure returns (int256, int256) {\\n        // Converts collateral present value to the local amount along with the liquidation discount.\\n        // localPurchased = collateralToSell / (exchangeRate * liquidationDiscount)\\n        int256 localUnderlyingFromLiquidator =\\n            collateralUnderlyingPresentValue\\n                .mul(Constants.PERCENTAGE_DECIMALS)\\n                .mul(factors.localETHRate.rateDecimals)\\n                .div(ExchangeRate.exchangeRate(factors.localETHRate, factors.collateralETHRate))\\n                .div(liquidationDiscount);\\n\\n        int256 localAssetFromLiquidator =\\n            factors.localPrimeRate.convertFromUnderlying(localUnderlyingFromLiquidator);\\n        // localPrimeAvailable must be negative in cross currency liquidations\\n        int256 maxLocalAsset = factors.localPrimeAvailable.neg();\\n\\n        if (localAssetFromLiquidator > maxLocalAsset) {\\n            // If the local to purchase will flip the sign of localPrimeAvailable then the calculations\\n            // for the collateral purchase amounts will be thrown off. The positive portion of localPrimeAvailable\\n            // has to have a haircut applied. If this haircut reduces the localPrimeAvailable value below\\n            // the collateralAssetValue then this may actually decrease overall free collateral.\\n            collateralBalanceToSell = collateralBalanceToSell\\n                .mul(maxLocalAsset)\\n                .div(localAssetFromLiquidator);\\n\\n            localAssetFromLiquidator = maxLocalAsset;\\n        }\\n\\n        return (collateralBalanceToSell, localAssetFromLiquidator);\\n    }\\n\\n    function finalizeLiquidatorLocal(\\n        address liquidator,\\n        address liquidateAccount,\\n        uint16 localCurrencyId,\\n        int256 netLocalFromLiquidator,\\n        int256 netLocalNTokens\\n    ) internal returns (AccountContext memory) {\\n        // Liquidator must deposit netLocalFromLiquidator, in the case of a repo discount then the\\n        // liquidator will receive some positive amount\\n        Token memory token = TokenHandler.getUnderlyingToken(localCurrencyId);\\n        AccountContext memory liquidatorContext =\\n            AccountContextHandler.getAccountContext(liquidator);\\n        BalanceState memory liquidatorLocalBalance;\\n        liquidatorLocalBalance.loadBalanceState(liquidator, localCurrencyId, liquidatorContext);\\n        // netLocalFromLiquidator is always positive. Liquidity token liquidation allows for a negative\\n        // netLocalFromLiquidator, but we do not allow regular accounts to hold liquidity tokens so those\\n        // liquidations are not possible.\\n        require(netLocalFromLiquidator > 0);\\n\\n        if (token.hasTransferFee) {\\n            // If a token has a transfer fee then it must have been deposited prior to the liquidation\\n            // or else we won't be able to net off the correct amount. We also require that the account\\n            // does not have debt so that we do not have to run a free collateral check here\\n            require(\\n                liquidatorLocalBalance.storedCashBalance >= netLocalFromLiquidator &&\\n                    liquidatorContext.hasDebt == 0x00,\\n                \\\"No cash\\\"\\n            ); // dev: token has transfer fee, no liquidator balance\\n            liquidatorLocalBalance.netCashChange = netLocalFromLiquidator.neg();\\n        } else {\\n            TokenHandler.depositExactToMintPrimeCash(\\n                liquidator,\\n                localCurrencyId,\\n                netLocalFromLiquidator,\\n                liquidatorLocalBalance.primeRate,\\n                false // excess ETH is returned to liquidator natively\\n            );\\n        }\\n\\n        Emitter.emitTransferPrimeCash(liquidator, liquidateAccount, localCurrencyId, netLocalFromLiquidator);\\n        if (netLocalNTokens > 0) Emitter.emitTransferNToken(liquidateAccount, liquidator, localCurrencyId, netLocalNTokens);\\n\\n        liquidatorLocalBalance.netNTokenTransfer = netLocalNTokens;\\n        liquidatorLocalBalance.finalizeNoWithdraw(liquidator, liquidatorContext);\\n\\n        return liquidatorContext;\\n    }\\n\\n    function finalizeLiquidatorCollateral(\\n        address liquidator,\\n        AccountContext memory liquidatorContext,\\n        address liquidateAccount,\\n        uint16 collateralCurrencyId,\\n        int256 netCollateralToLiquidator,\\n        int256 netCollateralNTokens,\\n        bool withdrawCollateral,\\n        bool redeemToUnderlying\\n    ) internal returns (AccountContext memory) {\\n        require(redeemToUnderlying, \\\"Deprecated: Redeem to cToken\\\");\\n        BalanceState memory balance;\\n        balance.loadBalanceState(liquidator, collateralCurrencyId, liquidatorContext);\\n        balance.netCashChange = netCollateralToLiquidator;\\n\\n        if (netCollateralToLiquidator != 0) Emitter.emitTransferPrimeCash(liquidateAccount, liquidator, collateralCurrencyId, netCollateralToLiquidator);\\n        if (netCollateralNTokens != 0) Emitter.emitTransferNToken(liquidateAccount, liquidator, collateralCurrencyId, netCollateralNTokens);\\n\\n        if (withdrawCollateral) {\\n            // This will net off the cash balance\\n            balance.primeCashWithdraw = netCollateralToLiquidator.neg();\\n        }\\n\\n        balance.netNTokenTransfer = netCollateralNTokens;\\n        // Liquidator will always receive native ETH\\n        balance.finalizeWithWithdraw(liquidator, liquidatorContext, false);\\n\\n        return liquidatorContext;\\n    }\\n\\n    function finalizeLiquidatedLocalBalance(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        AccountContext memory accountContext,\\n        int256 netLocalFromLiquidator\\n    ) internal {\\n        BalanceState memory balance;\\n        balance.loadBalanceState(liquidateAccount, localCurrency, accountContext);\\n        balance.netCashChange = netLocalFromLiquidator;\\n        balance.finalizeNoWithdraw(liquidateAccount, accountContext);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/CashGroup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    CashGroupParameters,\\n    CashGroupSettings,\\n    MarketParameters,\\n    PrimeRate\\n} from \\\"../../global/Types.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\n\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {PrimeCashExchangeRate} from \\\"../pCash/PrimeCashExchangeRate.sol\\\";\\nimport {Market} from \\\"./Market.sol\\\";\\nimport {DateTime} from \\\"./DateTime.sol\\\";\\n\\nlibrary CashGroup {\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n    using Market for MarketParameters;\\n\\n    // Bit number references for each parameter in the 32 byte word (0-indexed)\\n    uint256 private constant MARKET_INDEX_BIT = 31;\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW_BIT = 30;\\n    uint256 private constant MAX_DISCOUNT_FACTOR_BIT = 29;\\n    uint256 private constant RESERVE_FEE_SHARE_BIT = 28;\\n    uint256 private constant DEBT_BUFFER_BIT = 27;\\n    uint256 private constant FCASH_HAIRCUT_BIT = 26;\\n    uint256 private constant MIN_ORACLE_RATE_BIT = 25;\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT_BIT = 24;\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER_BIT = 23;\\n    uint256 private constant MAX_ORACLE_RATE_BIT = 22;\\n\\n    // Offsets for the bytes of the different parameters\\n    uint256 private constant MARKET_INDEX = (31 - MARKET_INDEX_BIT) * 8;\\n    uint256 private constant RATE_ORACLE_TIME_WINDOW = (31 - RATE_ORACLE_TIME_WINDOW_BIT) * 8;\\n    uint256 private constant MAX_DISCOUNT_FACTOR = (31 - MAX_DISCOUNT_FACTOR_BIT) * 8;\\n    uint256 private constant RESERVE_FEE_SHARE = (31 - RESERVE_FEE_SHARE_BIT) * 8;\\n    uint256 private constant DEBT_BUFFER = (31 - DEBT_BUFFER_BIT) * 8;\\n    uint256 private constant FCASH_HAIRCUT = (31 - FCASH_HAIRCUT_BIT) * 8;\\n    uint256 private constant MIN_ORACLE_RATE = (31 - MIN_ORACLE_RATE_BIT) * 8;\\n    uint256 private constant LIQUIDATION_FCASH_HAIRCUT = (31 - LIQUIDATION_FCASH_HAIRCUT_BIT) * 8;\\n    uint256 private constant LIQUIDATION_DEBT_BUFFER = (31 - LIQUIDATION_DEBT_BUFFER_BIT) * 8;\\n    uint256 private constant MAX_ORACLE_RATE = (31 - MAX_ORACLE_RATE_BIT) * 8;\\n\\n    function _get25BPSValue(CashGroupParameters memory cashGroup, uint256 offset) private pure returns (uint256) {\\n        return uint256(uint8(uint256(cashGroup.data >> offset))) * Constants.TWENTY_FIVE_BASIS_POINTS;\\n    }\\n\\n    function getMinOracleRate(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return _get25BPSValue(cashGroup, MIN_ORACLE_RATE);\\n    }\\n\\n    function getMaxOracleRate(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return _get25BPSValue(cashGroup, MAX_ORACLE_RATE);\\n    }\\n\\n    /// @notice fCash haircut for valuation denominated in rate precision with five basis point increments\\n    function getfCashHaircut(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return _get25BPSValue(cashGroup, FCASH_HAIRCUT);\\n    }\\n\\n    /// @notice fCash debt buffer for valuation denominated in rate precision with five basis point increments\\n    function getDebtBuffer(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return _get25BPSValue(cashGroup, DEBT_BUFFER);\\n    }\\n\\n    /// @notice Haircut for positive fCash during liquidation denominated rate precision\\n    function getLiquidationfCashHaircut(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return _get25BPSValue(cashGroup, LIQUIDATION_FCASH_HAIRCUT);\\n    }\\n\\n    /// @notice Haircut for negative fCash during liquidation denominated rate precision\\n    function getLiquidationDebtBuffer(CashGroupParameters memory cashGroup) internal pure returns (uint256) {\\n        return _get25BPSValue(cashGroup, LIQUIDATION_DEBT_BUFFER);\\n    }\\n\\n    function getMaxDiscountFactor(CashGroupParameters memory cashGroup)\\n        internal pure returns (int256)\\n    {\\n        uint256 maxDiscountFactor = uint256(uint8(uint256(cashGroup.data >> MAX_DISCOUNT_FACTOR))) * Constants.FIVE_BASIS_POINTS;\\n        // Overflow/Underflow is not possible due to storage size limits\\n        return Constants.RATE_PRECISION - int256(maxDiscountFactor);\\n    }\\n\\n    /// @notice Percentage of the total trading fee that goes to the reserve\\n    function getReserveFeeShare(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return uint8(uint256(cashGroup.data >> RESERVE_FEE_SHARE));\\n    }\\n\\n    /// @notice Time window factor for the rate oracle denominated in seconds with five minute increments.\\n    function getRateOracleTimeWindow(CashGroupParameters memory cashGroup)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        // This is denominated in 5 minute increments in storage\\n        return uint256(uint8(uint256(cashGroup.data >> RATE_ORACLE_TIME_WINDOW))) * Constants.FIVE_MINUTES;\\n    }\\n\\n    function loadMarket(\\n        CashGroupParameters memory cashGroup,\\n        MarketParameters memory market,\\n        uint256 marketIndex,\\n        bool needsLiquidity,\\n        uint256 blockTime\\n    ) internal view {\\n        require(1 <= marketIndex && marketIndex <= cashGroup.maxMarketIndex, \\\"Invalid market\\\");\\n        uint256 maturity =\\n            DateTime.getReferenceTime(blockTime).add(DateTime.getTradedMarket(marketIndex));\\n\\n        market.loadMarket(\\n            cashGroup.currencyId,\\n            maturity,\\n            blockTime,\\n            needsLiquidity,\\n            getRateOracleTimeWindow(cashGroup)\\n        );\\n    }\\n\\n    /// @notice Returns the linear interpolation between two market rates. The formula is\\n    /// slope = (longMarket.oracleRate - shortMarket.oracleRate) / (longMarket.maturity - shortMarket.maturity)\\n    /// interpolatedRate = slope * (assetMaturity - shortMarket.maturity) + shortMarket.oracleRate\\n    function interpolateOracleRate(\\n        uint256 shortMaturity,\\n        uint256 longMaturity,\\n        uint256 shortRate,\\n        uint256 longRate,\\n        uint256 assetMaturity\\n    ) internal pure returns (uint256) {\\n        require(shortMaturity < assetMaturity); // dev: cash group interpolation error, short maturity\\n        require(assetMaturity < longMaturity); // dev: cash group interpolation error, long maturity\\n\\n        // It's possible that the rates are inverted where the short market rate > long market rate and\\n        // we will get an underflow here so we check for that\\n        if (longRate >= shortRate) {\\n            return\\n                (longRate - shortRate)\\n                    .mul(assetMaturity - shortMaturity)\\n                // No underflow here, checked above\\n                    .div(longMaturity - shortMaturity)\\n                    .add(shortRate);\\n        } else {\\n            // In this case the slope is negative so:\\n            // interpolatedRate = shortMarket.oracleRate - slope * (assetMaturity - shortMarket.maturity)\\n            // NOTE: this subtraction should never overflow, the linear interpolation between two points above zero\\n            // cannot go below zero\\n            return\\n                shortRate.sub(\\n                    // This is reversed to keep it it positive\\n                    (shortRate - longRate)\\n                        .mul(assetMaturity - shortMaturity)\\n                    // No underflow here, checked above\\n                        .div(longMaturity - shortMaturity)\\n                );\\n        }\\n    }\\n\\n    function calculateRiskAdjustedfCashOracleRate(\\n        CashGroupParameters memory cashGroup,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal view returns (uint256 oracleRate) {\\n        oracleRate = calculateOracleRate(cashGroup, maturity, blockTime);\\n\\n        oracleRate = oracleRate.add(getfCashHaircut(cashGroup));\\n        uint256 minOracleRate = getMinOracleRate(cashGroup);\\n\\n        if (oracleRate < minOracleRate) oracleRate = minOracleRate;\\n    }\\n\\n    function calculateRiskAdjustedDebtOracleRate(\\n        CashGroupParameters memory cashGroup,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal view returns (uint256 oracleRate) {\\n        oracleRate = calculateOracleRate(cashGroup, maturity, blockTime);\\n\\n        uint256 debtBuffer = getDebtBuffer(cashGroup);\\n        // If the adjustment exceeds the oracle rate we floor the oracle rate at zero,\\n        // We don't want to require the account to hold more than absolutely required.\\n        if (oracleRate <= debtBuffer) return 0;\\n\\n        oracleRate = oracleRate - debtBuffer;\\n        uint256 maxOracleRate = getMaxOracleRate(cashGroup);\\n\\n        if (maxOracleRate < oracleRate) oracleRate = maxOracleRate;\\n    }\\n    \\n    function calculateOracleRate(\\n        CashGroupParameters memory cashGroup,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal view returns (uint256 oracleRate) {\\n        (uint256 marketIndex, bool idiosyncratic) =\\n            DateTime.getMarketIndex(cashGroup.maxMarketIndex, maturity, blockTime);\\n        uint256 timeWindow = getRateOracleTimeWindow(cashGroup);\\n\\n        if (!idiosyncratic) {\\n            oracleRate = Market.getOracleRate(cashGroup.currencyId, maturity, timeWindow, blockTime);\\n        } else {\\n            uint256 referenceTime = DateTime.getReferenceTime(blockTime);\\n            // DateTime.getMarketIndex returns the market that is past the maturity if idiosyncratic\\n            uint256 longMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex));\\n            uint256 longRate =\\n                Market.getOracleRate(cashGroup.currencyId, longMaturity, timeWindow, blockTime);\\n\\n            uint256 shortRate;\\n            uint256 shortMaturity;\\n            if (marketIndex == 1) {\\n                // In this case the short market is the annualized asset supply rate\\n                shortMaturity = blockTime;\\n                shortRate = cashGroup.primeRate.oracleSupplyRate;\\n            } else {\\n                // Minimum value for marketIndex here is 2\\n                shortMaturity = referenceTime.add(DateTime.getTradedMarket(marketIndex - 1));\\n\\n                shortRate = Market.getOracleRate(\\n                    cashGroup.currencyId,\\n                    shortMaturity,\\n                    timeWindow,\\n                    blockTime\\n                );\\n            }\\n\\n            oracleRate = interpolateOracleRate(shortMaturity, longMaturity, shortRate, longRate, maturity);\\n        }\\n    }\\n\\n    function _getCashGroupStorageBytes(uint256 currencyId) private view returns (bytes32 data) {\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\n        return store[currencyId];\\n    }\\n\\n    /// @dev Helper method for validating maturities in ERC1155Action\\n    function getMaxMarketIndex(uint256 currencyId) internal view returns (uint8) {\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\n        return uint8(data[MARKET_INDEX_BIT]);\\n    }\\n\\n    /// @notice Checks all cash group settings for invalid values and sets them into storage\\n    function setCashGroupStorage(uint256 currencyId, CashGroupSettings memory cashGroup)\\n        internal\\n    {\\n        // Due to the requirements of the yield curve we do not allow a cash group to have solely a 3 month market.\\n        // The reason is that borrowers will not have a further maturity to roll from their 3 month fixed to a 6 month\\n        // fixed. It also complicates the logic in the nToken initialization method. Additionally, we cannot have cash\\n        // groups with 0 market index, it has no effect.\\n        require(2 <= cashGroup.maxMarketIndex && cashGroup.maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX);\\n        require(cashGroup.reserveFeeShare <= Constants.PERCENTAGE_DECIMALS);\\n        // Max discount factor must be set to a non-zero value\\n        require(0 < cashGroup.maxDiscountFactor5BPS);\\n        require(cashGroup.minOracleRate25BPS < cashGroup.maxOracleRate25BPS);\\n        // This is required so that fCash liquidation can proceed correctly\\n        require(cashGroup.liquidationfCashHaircut25BPS < cashGroup.fCashHaircut25BPS);\\n        require(cashGroup.liquidationDebtBuffer25BPS < cashGroup.debtBuffer25BPS);\\n\\n        // Market indexes cannot decrease or they will leave fCash assets stranded in the future with no valuation curve\\n        uint8 previousMaxMarketIndex = getMaxMarketIndex(currencyId);\\n        require(previousMaxMarketIndex <= cashGroup.maxMarketIndex);\\n\\n        // Per cash group settings\\n        bytes32 data =\\n            (bytes32(uint256(cashGroup.maxMarketIndex)) |\\n                (bytes32(uint256(cashGroup.rateOracleTimeWindow5Min)) << RATE_ORACLE_TIME_WINDOW) |\\n                (bytes32(uint256(cashGroup.maxDiscountFactor5BPS)) << MAX_DISCOUNT_FACTOR) |\\n                (bytes32(uint256(cashGroup.reserveFeeShare)) << RESERVE_FEE_SHARE) |\\n                (bytes32(uint256(cashGroup.debtBuffer25BPS)) << DEBT_BUFFER) |\\n                (bytes32(uint256(cashGroup.fCashHaircut25BPS)) << FCASH_HAIRCUT) |\\n                (bytes32(uint256(cashGroup.minOracleRate25BPS)) << MIN_ORACLE_RATE) |\\n                (bytes32(uint256(cashGroup.liquidationfCashHaircut25BPS)) << LIQUIDATION_FCASH_HAIRCUT) |\\n                (bytes32(uint256(cashGroup.liquidationDebtBuffer25BPS)) << LIQUIDATION_DEBT_BUFFER) |\\n                (bytes32(uint256(cashGroup.maxOracleRate25BPS)) << MAX_ORACLE_RATE)\\n        );\\n\\n        mapping(uint256 => bytes32) storage store = LibStorage.getCashGroupStorage();\\n        store[currencyId] = data;\\n    }\\n\\n    /// @notice Deserialize the cash group storage bytes into a user friendly object\\n    function deserializeCashGroupStorage(uint256 currencyId)\\n        internal\\n        view\\n        returns (CashGroupSettings memory)\\n    {\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\n        uint8 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\n\\n        return\\n            CashGroupSettings({\\n                maxMarketIndex: maxMarketIndex,\\n                rateOracleTimeWindow5Min: uint8(data[RATE_ORACLE_TIME_WINDOW_BIT]),\\n                maxDiscountFactor5BPS: uint8(data[MAX_DISCOUNT_FACTOR_BIT]),\\n                reserveFeeShare: uint8(data[RESERVE_FEE_SHARE_BIT]),\\n                debtBuffer25BPS: uint8(data[DEBT_BUFFER_BIT]),\\n                fCashHaircut25BPS: uint8(data[FCASH_HAIRCUT_BIT]),\\n                minOracleRate25BPS: uint8(data[MIN_ORACLE_RATE_BIT]),\\n                liquidationfCashHaircut25BPS: uint8(data[LIQUIDATION_FCASH_HAIRCUT_BIT]),\\n                liquidationDebtBuffer25BPS: uint8(data[LIQUIDATION_DEBT_BUFFER_BIT]),\\n                maxOracleRate25BPS: uint8(data[MAX_ORACLE_RATE_BIT])\\n            });\\n    }\\n\\n    function buildCashGroup(uint16 currencyId, PrimeRate memory primeRate)\\n        internal view returns (CashGroupParameters memory) \\n    {\\n        bytes32 data = _getCashGroupStorageBytes(currencyId);\\n        uint256 maxMarketIndex = uint8(data[MARKET_INDEX_BIT]);\\n\\n        return\\n            CashGroupParameters({\\n                currencyId: currencyId,\\n                maxMarketIndex: maxMarketIndex,\\n                primeRate: primeRate,\\n                data: data\\n            });\\n    }\\n\\n    /// @notice Builds a cash group using a view version of the asset rate\\n    function buildCashGroupView(uint16 currencyId)\\n        internal\\n        view\\n        returns (CashGroupParameters memory)\\n    {\\n        (PrimeRate memory primeRate, /* */) = PrimeCashExchangeRate.getPrimeCashRateView(currencyId, block.timestamp);\\n        return buildCashGroup(currencyId, primeRate);\\n    }\\n\\n    /// @notice Builds a cash group using a stateful version of the asset rate\\n    function buildCashGroupStateful(uint16 currencyId)\\n        internal\\n        returns (CashGroupParameters memory)\\n    {\\n        PrimeRate memory primeRate = PrimeRateLib.buildPrimeRateStateful(currencyId);\\n        return buildCashGroup(currencyId, primeRate);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\n\\nlibrary DateTime {\\n    using SafeUint256 for uint256;\\n\\n    /// @notice Returns the current reference time which is how all the AMM dates are calculated.\\n    function getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\\n        require(blockTime >= Constants.QUARTER);\\n        return blockTime - (blockTime % Constants.QUARTER);\\n    }\\n\\n    /// @notice Truncates a date to midnight UTC time\\n    function getTimeUTC0(uint256 time) internal pure returns (uint256) {\\n        require(time >= Constants.DAY);\\n        return time - (time % Constants.DAY);\\n    }\\n\\n    /// @notice These are the predetermined market offsets for trading\\n    /// @dev Markets are 1-indexed because the 0 index means that no markets are listed for the cash group.\\n    function getTradedMarket(uint256 index) internal pure returns (uint256) {\\n        if (index == 1) return Constants.QUARTER;\\n        if (index == 2) return 2 * Constants.QUARTER;\\n        if (index == 3) return Constants.YEAR;\\n        if (index == 4) return 2 * Constants.YEAR;\\n        if (index == 5) return 5 * Constants.YEAR;\\n        if (index == 6) return 10 * Constants.YEAR;\\n        if (index == 7) return 20 * Constants.YEAR;\\n\\n        revert(\\\"Invalid index\\\");\\n    }\\n\\n    /// @notice Determines if the maturity falls on one of the valid on chain market dates.\\n    function isValidMarketMaturity(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (bool) {\\n        require(maxMarketIndex > 0, \\\"CG: no markets listed\\\");\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX, \\\"CG: market index bound\\\");\\n\\n        if (maturity % Constants.QUARTER != 0) return false;\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\n            if (maturity == tRef.add(DateTime.getTradedMarket(i))) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Determines if an idiosyncratic maturity is valid and returns the bit reference that is the case.\\n    function isValidMaturity(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (bool) {\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n        uint256 maxMaturity = tRef.add(DateTime.getTradedMarket(maxMarketIndex));\\n        // Cannot trade past max maturity\\n        if (maturity > maxMaturity) return false;\\n\\n        // prettier-ignore\\n        (/* */, bool isValid) = DateTime.getBitNumFromMaturity(blockTime, maturity);\\n        return isValid;\\n    }\\n\\n    /// @notice Returns the market index for a given maturity, if the maturity is idiosyncratic\\n    /// will return the nearest market index that is larger than the maturity.\\n    /// @return uint marketIndex, bool isIdiosyncratic\\n    function getMarketIndex(\\n        uint256 maxMarketIndex,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal pure returns (uint256, bool) {\\n        require(maxMarketIndex > 0);\\n        require(maxMarketIndex <= Constants.MAX_TRADED_MARKET_INDEX);\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n\\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\\n            uint256 marketMaturity = tRef.add(DateTime.getTradedMarket(i));\\n            // If market matches then is not idiosyncratic\\n            if (marketMaturity == maturity) return (i, false);\\n            // Returns the market that is immediately greater than the maturity\\n            if (marketMaturity > maturity) return (i, true);\\n        }\\n\\n        revert();\\n    }\\n\\n    /// @notice Given a bit number and the reference time of the first bit, returns the bit number\\n    /// of a given maturity.\\n    /// @return bitNum and a true or false if the maturity falls on the exact bit\\n    function getBitNumFromMaturity(uint256 blockTime, uint256 maturity)\\n        internal\\n        pure\\n        returns (uint256, bool)\\n    {\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\n\\n        // Maturities must always divide days evenly\\n        if (maturity % Constants.DAY != 0) return (0, false);\\n        // Maturity cannot be in the past\\n        if (blockTimeUTC0 >= maturity) return (0, false);\\n\\n        // Overflow check done above\\n        // daysOffset has no remainders, checked above\\n        uint256 daysOffset = (maturity - blockTimeUTC0) / Constants.DAY;\\n\\n        // These if statements need to fall through to the next one\\n        if (daysOffset <= Constants.MAX_DAY_OFFSET) {\\n            return (daysOffset, true);\\n        } else if (daysOffset <= Constants.MAX_WEEK_OFFSET) {\\n            // (daysOffset - MAX_DAY_OFFSET) is the days overflow into the week portion, must be > 0\\n            // (blockTimeUTC0 % WEEK) / DAY is the offset into the week portion\\n            // This returns the offset from the previous max offset in days\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_DAY_OFFSET +\\n                    (blockTimeUTC0 % Constants.WEEK) /\\n                    Constants.DAY;\\n            \\n            return (\\n                // This converts the offset in days to its corresponding bit position, truncating down\\n                // if it does not divide evenly into DAYS_IN_WEEK\\n                Constants.WEEK_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_WEEK,\\n                (offsetInDays % Constants.DAYS_IN_WEEK) == 0\\n            );\\n        } else if (daysOffset <= Constants.MAX_MONTH_OFFSET) {\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_WEEK_OFFSET +\\n                    (blockTimeUTC0 % Constants.MONTH) /\\n                    Constants.DAY;\\n\\n            return (\\n                Constants.MONTH_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_MONTH,\\n                (offsetInDays % Constants.DAYS_IN_MONTH) == 0\\n            );\\n        } else if (daysOffset <= Constants.MAX_QUARTER_OFFSET) {\\n            uint256 offsetInDays =\\n                daysOffset -\\n                    Constants.MAX_MONTH_OFFSET +\\n                    (blockTimeUTC0 % Constants.QUARTER) /\\n                    Constants.DAY;\\n\\n            return (\\n                Constants.QUARTER_BIT_OFFSET + offsetInDays / Constants.DAYS_IN_QUARTER,\\n                (offsetInDays % Constants.DAYS_IN_QUARTER) == 0\\n            );\\n        }\\n\\n        // This is the maximum 1-indexed bit num, it is never valid because it is beyond the 20\\n        // year max maturity\\n        return (256, false);\\n    }\\n\\n    /// @notice Given a bit number and a block time returns the maturity that the bit number\\n    /// should reference. Bit numbers are one indexed.\\n    function getMaturityFromBitNum(uint256 blockTime, uint256 bitNum)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(bitNum != 0); // dev: cash group get maturity from bit num is zero\\n        require(bitNum <= 256); // dev: cash group get maturity from bit num overflow\\n        uint256 blockTimeUTC0 = getTimeUTC0(blockTime);\\n        uint256 firstBit;\\n\\n        if (bitNum <= Constants.WEEK_BIT_OFFSET) {\\n            return blockTimeUTC0 + bitNum * Constants.DAY;\\n        } else if (bitNum <= Constants.MONTH_BIT_OFFSET) {\\n            firstBit =\\n                blockTimeUTC0 +\\n                Constants.MAX_DAY_OFFSET * Constants.DAY -\\n                // This backs up to the day that is divisible by a week\\n                (blockTimeUTC0 % Constants.WEEK);\\n            return firstBit + (bitNum - Constants.WEEK_BIT_OFFSET) * Constants.WEEK;\\n        } else if (bitNum <= Constants.QUARTER_BIT_OFFSET) {\\n            firstBit =\\n                blockTimeUTC0 +\\n                Constants.MAX_WEEK_OFFSET * Constants.DAY -\\n                (blockTimeUTC0 % Constants.MONTH);\\n            return firstBit + (bitNum - Constants.MONTH_BIT_OFFSET) * Constants.MONTH;\\n        } else {\\n            firstBit =\\n                blockTimeUTC0 +\\n                Constants.MAX_MONTH_OFFSET * Constants.DAY -\\n                (blockTimeUTC0 % Constants.QUARTER);\\n            return firstBit + (bitNum - Constants.QUARTER_BIT_OFFSET) * Constants.QUARTER;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/markets/InterestRateCurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {\\n    InterestRateCurveSettings,\\n    InterestRateParameters,\\n    CashGroupParameters,\\n    MarketParameters,\\n    PrimeRate\\n} from \\\"../../global/Types.sol\\\";\\nimport {CashGroup} from \\\"./CashGroup.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {ABDKMath64x64} from \\\"../../math/ABDKMath64x64.sol\\\";\\n\\nlibrary InterestRateCurve {\\n    using SafeInt256 for int256;\\n    using SafeUint256 for uint256;\\n    using CashGroup for CashGroupParameters;\\n    using PrimeRateLib for PrimeRate;\\n\\n    uint8 private constant PRIME_CASH_OFFSET = 0;\\n    uint8 private constant PRIME_CASH_SHIFT = 192;\\n\\n    uint256 private constant KINK_UTILIZATION_1_BYTE = 0;\\n    uint256 private constant KINK_UTILIZATION_2_BYTE = 1;\\n    uint256 private constant MAX_RATE_BYTE           = 2;\\n    uint256 private constant KINK_RATE_1_BYTE        = 3;\\n    uint256 private constant KINK_RATE_2_BYTE        = 4;\\n    uint256 private constant MIN_FEE_RATE_BYTE       = 5;\\n    uint256 private constant MAX_FEE_RATE_BYTE       = 6;\\n    uint256 private constant FEE_RATE_PERCENT_BYTE   = 7;\\n\\n    uint256 private constant KINK_UTILIZATION_1_BIT = KINK_UTILIZATION_1_BYTE * 8;\\n    uint256 private constant KINK_UTILIZATION_2_BIT = KINK_UTILIZATION_2_BYTE * 8;\\n    uint256 private constant MAX_RATE_BIT           = MAX_RATE_BYTE * 8;\\n    uint256 private constant KINK_RATE_1_BIT        = KINK_RATE_1_BYTE * 8;\\n    uint256 private constant KINK_RATE_2_BIT        = KINK_RATE_2_BYTE * 8;\\n    uint256 private constant MIN_FEE_RATE_BIT       = MIN_FEE_RATE_BYTE * 8;\\n    uint256 private constant MAX_FEE_RATE_BIT       = MAX_FEE_RATE_BYTE * 8;\\n    uint256 private constant FEE_RATE_PERCENT_BIT   = FEE_RATE_PERCENT_BYTE * 8;\\n\\n    /// @notice Returns the marketIndex byte offset.\\n    /// @dev marketIndex = 0 is unused for fCash markets (they are 1-indexed). In the storage\\n    /// slot the marketIndex = 0 space is reserved for the prime cash borrow curve\\n    function _getMarketIndexOffset(uint256 marketIndex) private pure returns (uint8 offset) {\\n        require(0 < marketIndex);\\n        require(marketIndex <= Constants.MAX_TRADED_MARKET_INDEX);\\n        offset = uint8(marketIndex < 4 ? marketIndex : marketIndex - 4) * 8;\\n    }\\n\\n    function _getfCashInterestRateParams(\\n        uint16 currencyId,\\n        uint256 marketIndex,\\n        mapping(uint256 => bytes32[2]) storage store\\n    ) private view returns (InterestRateParameters memory i) {\\n        uint8 offset = _getMarketIndexOffset(marketIndex);\\n        bytes32 data = store[currencyId][marketIndex < 4 ? 0 : 1];\\n        return unpackInterestRateParams(offset, data);\\n    }\\n\\n    function calculateMaxRate(uint8 maxRateByte) internal pure returns (uint256) {\\n        // Max rate values are in 25 bps increments up to 150 units. Above 150 they are in 150 bps\\n        // increments. This results in a max rate of 195%. This allows more precision at lower max\\n        // rate values and a higher range for large max rate values.\\n        return Constants.MAX_LOWER_INCREMENT < maxRateByte ?\\n            (Constants.MAX_LOWER_INCREMENT_VALUE +\\n                (maxRateByte - Constants.MAX_LOWER_INCREMENT) * Constants.ONE_HUNDRED_FIFTY_BASIS_POINTS) :\\n            maxRateByte * Constants.TWENTY_FIVE_BASIS_POINTS;\\n    }\\n\\n    function unpackInterestRateParams(\\n        uint8 offset,\\n        bytes32 data\\n    ) internal pure returns (InterestRateParameters memory i) {\\n        // Kink utilization is stored as a value less than 100 and on the stack it is\\n        // in RATE_PRECISION where RATE_PRECISION = 100\\n        i.kinkUtilization1 = uint256(uint8(data[offset + KINK_UTILIZATION_1_BYTE])) * uint256(Constants.RATE_PRECISION)\\n            / uint256(Constants.PERCENTAGE_DECIMALS);\\n        i.kinkUtilization2 = uint256(uint8(data[offset + KINK_UTILIZATION_2_BYTE])) * uint256(Constants.RATE_PRECISION)\\n            / uint256(Constants.PERCENTAGE_DECIMALS);\\n        i.maxRate = calculateMaxRate(uint8(data[offset + MAX_RATE_BYTE]));\\n        // Kink Rates are stored as 1/256 increments of maxRate, this allows governance\\n        // to set more precise kink rates relative to how how interest rates can go\\n        i.kinkRate1 = uint256(uint8(data[offset + KINK_RATE_1_BYTE])) * i.maxRate / 256;\\n        i.kinkRate2 = uint256(uint8(data[offset + KINK_RATE_2_BYTE])) * i.maxRate / 256;\\n\\n        // Fee rates are stored in basis points\\n        i.minFeeRate = uint256(uint8(data[offset + MIN_FEE_RATE_BYTE])) * uint256(Constants.FIVE_BASIS_POINTS);\\n        i.maxFeeRate = uint256(uint8(data[offset + MAX_FEE_RATE_BYTE])) * uint256(Constants.TWENTY_FIVE_BASIS_POINTS);\\n        i.feeRatePercent = uint256(uint8(data[offset + FEE_RATE_PERCENT_BYTE]));\\n    }\\n\\n    function packInterestRateParams(InterestRateCurveSettings memory settings) internal pure returns (bytes32) {\\n        require(settings.kinkUtilization1 < settings.kinkUtilization2);\\n        require(settings.kinkUtilization2 <= 100);\\n        require(settings.kinkRate1 < settings.kinkRate2);\\n        require(settings.minFeeRate5BPS * Constants.FIVE_BASIS_POINTS <= settings.maxFeeRate25BPS * Constants.TWENTY_FIVE_BASIS_POINTS);\\n        require(settings.feeRatePercent < 100);\\n\\n        return (\\n            bytes32(uint256(settings.kinkUtilization1)) << 56 - KINK_UTILIZATION_1_BIT |\\n            bytes32(uint256(settings.kinkUtilization2)) << 56 - KINK_UTILIZATION_2_BIT |\\n            bytes32(uint256(settings.maxRateUnits))     << 56 - MAX_RATE_BIT           |\\n            bytes32(uint256(settings.kinkRate1))        << 56 - KINK_RATE_1_BIT        |\\n            bytes32(uint256(settings.kinkRate2))        << 56 - KINK_RATE_2_BIT        |\\n            bytes32(uint256(settings.minFeeRate5BPS))   << 56 - MIN_FEE_RATE_BIT       |\\n            bytes32(uint256(settings.maxFeeRate25BPS))  << 56 - MAX_FEE_RATE_BIT       |\\n            bytes32(uint256(settings.feeRatePercent))   << 56 - FEE_RATE_PERCENT_BIT\\n        );\\n    }\\n\\n    function _setInterestRateParameters(\\n        bytes32 data,\\n        uint8 offset,\\n        InterestRateCurveSettings memory settings\\n    ) internal pure returns (bytes32) {\\n        // Does checks against interest rate params inside\\n        bytes32 packedSettings = packInterestRateParams(settings);\\n        packedSettings = (packedSettings << offset);\\n\\n        // Use the mask to clear the previous settings\\n        bytes32 mask = ~(bytes32(uint256(type(uint64).max)) << offset);\\n        return (data & mask) | packedSettings;\\n    }\\n\\n    function setNextInterestRateParameters(\\n        uint16 currencyId,\\n        uint256 marketIndex,\\n        InterestRateCurveSettings memory settings\\n    ) internal {\\n        bytes32[2] storage nextStorage = LibStorage.getNextInterestRateParameters()[currencyId];\\n        // 256 - 64 bits puts the offset at 192 bits (64 bits is how wide each set of interest\\n        // rate parameters is)\\n        uint8 shift = PRIME_CASH_SHIFT - _getMarketIndexOffset(marketIndex) * 8;\\n        uint8 slot = marketIndex < 4 ? 0 : 1;\\n\\n        nextStorage[slot] = _setInterestRateParameters(nextStorage[slot], shift, settings);\\n    }\\n\\n    function getActiveInterestRateParameters(\\n        uint16 currencyId,\\n        uint256 marketIndex\\n    ) internal view returns (InterestRateParameters memory i) {\\n        return _getfCashInterestRateParams(\\n            currencyId,\\n            marketIndex,\\n            LibStorage.getActiveInterestRateParameters()\\n        );\\n    }\\n\\n    function getNextInterestRateParameters(\\n        uint16 currencyId,\\n        uint256 marketIndex\\n    ) internal view returns (InterestRateParameters memory i) {\\n        return _getfCashInterestRateParams(\\n            currencyId,\\n            marketIndex,\\n            LibStorage.getNextInterestRateParameters()\\n        );\\n    }\\n\\n    function getPrimeCashInterestRateParameters(\\n        uint16 currencyId\\n    ) internal view returns (InterestRateParameters memory i) {\\n        bytes32 data = LibStorage.getActiveInterestRateParameters()[currencyId][0];\\n        return unpackInterestRateParams(PRIME_CASH_OFFSET, data);\\n    }\\n\\n    /// @notice Sets prime cash interest rate parameters, which are always in active storage\\n    /// at left most bytes8 slot. This corresponds to marketIndex = 0 which is unused by fCash\\n    /// markets.\\n    function setPrimeCashInterestRateParameters(\\n        uint16 currencyId,\\n        InterestRateCurveSettings memory settings\\n    ) internal {\\n        bytes32[2] storage activeStorage = LibStorage.getActiveInterestRateParameters()[currencyId];\\n        bytes32[2] storage nextStorage = LibStorage.getNextInterestRateParameters()[currencyId];\\n        // Set the settings in both active and next. On the next market roll the prime cash parameters\\n        // will be preserved\\n        activeStorage[0] = _setInterestRateParameters(activeStorage[0], PRIME_CASH_SHIFT, settings);\\n        nextStorage[0] = _setInterestRateParameters(nextStorage[0], PRIME_CASH_SHIFT, settings);\\n    }\\n\\n    function setActiveInterestRateParameters(uint16 currencyId) internal {\\n        // Whenever we set the active interest rate parameters, we just copy the next\\n        // values into the active storage values.\\n        bytes32[2] storage nextStorage = LibStorage.getNextInterestRateParameters()[currencyId];\\n        bytes32[2] storage activeStorage = LibStorage.getActiveInterestRateParameters()[currencyId];\\n        activeStorage[0] = nextStorage[0];\\n        activeStorage[1] = nextStorage[1];\\n    }\\n\\n    /// @notice Oracle rate protects against short term price manipulation. Time window will be set to a value\\n    /// on the order of minutes to hours. This is to protect fCash valuations from market manipulation. For example,\\n    /// a trader could use a flash loan to dump a large amount of cash into the market and depress interest rates.\\n    /// Since we value fCash in portfolios based on these rates, portfolio values will decrease and they may then\\n    /// be liquidated.\\n    ///\\n    /// Oracle rates are calculated when the values are loaded from storage.\\n    ///\\n    /// The oracle rate is a lagged weighted average over a short term price window. If we are past\\n    /// the short term window then we just set the rate to the lastImpliedRate, otherwise we take the\\n    /// weighted average:\\n    ///     lastInterestRatePreTrade * (currentTs - previousTs) / timeWindow +\\n    ///         oracleRatePrevious * (1 - (currentTs - previousTs) / timeWindow)\\n    function updateRateOracle(\\n        uint256 lastUpdateTime,\\n        uint256 lastInterestRate,\\n        uint256 oracleRate,\\n        uint256 rateOracleTimeWindow,\\n        uint256 blockTime\\n    ) internal pure returns (uint256 newOracleRate) {\\n        require(rateOracleTimeWindow > 0); // dev: update rate oracle, time window zero\\n\\n        // This can occur when using a view function get to a market state in the past\\n        if (lastUpdateTime > blockTime) return lastInterestRate;\\n\\n        uint256 timeDiff = blockTime.sub(lastUpdateTime);\\n        // If past the time window just return the lastInterestRate\\n        if (timeDiff > rateOracleTimeWindow) return lastInterestRate;\\n\\n        // (currentTs - previousTs) / timeWindow\\n        uint256 lastTradeWeight = timeDiff.divInRatePrecision(rateOracleTimeWindow);\\n\\n        // 1 - (currentTs - previousTs) / timeWindow\\n        uint256 oracleWeight = uint256(Constants.RATE_PRECISION).sub(lastTradeWeight);\\n\\n        // lastInterestRatePreTrade * lastTradeWeight + oracleRatePrevious * oracleWeight\\n        newOracleRate =\\n            (lastInterestRate.mul(lastTradeWeight).add(oracleRate.mul(oracleWeight)))\\n                .div(uint256(Constants.RATE_PRECISION));\\n    }\\n\\n    /// @notice Returns the utilization for an fCash market:\\n    /// (totalfCash +/- fCashToAccount) / (totalfCash + totalCash)\\n    function getfCashUtilization(\\n        int256 fCashToAccount,\\n        int256 totalfCash,\\n        int256 totalCashUnderlying\\n    ) internal pure returns (uint256 utilization) {\\n        require(totalfCash >= 0);\\n        require(totalCashUnderlying >= 0);\\n        utilization = totalfCash.subNoNeg(fCashToAccount)\\n            .divInRatePrecision(totalCashUnderlying.add(totalfCash))\\n            .toUint();\\n    }\\n\\n    /// @notice Returns the preFeeInterestRate given interest rate parameters and utilization\\n    function getInterestRate(\\n        InterestRateParameters memory irParams,\\n        uint256 utilization\\n    ) internal pure returns (uint256 preFeeInterestRate) {\\n        // If this is not set, then assume that the rate parameters have not been initialized\\n        // and revert.\\n        require(irParams.maxRate > 0);\\n        // Do not allow trading past 100% utilization, revert for safety here to prevent\\n        // underflows, however in calculatefCashTrade we check this explicitly to prevent\\n        // a revert. nToken redemption relies on the behavior that calculateTrade returns 0\\n        // during an unsuccessful trade.\\n        require(utilization <= uint256(Constants.RATE_PRECISION));\\n\\n        if (utilization <= irParams.kinkUtilization1) {\\n            // utilization * kinkRate1 / kinkUtilization1\\n            preFeeInterestRate = utilization\\n                .mul(irParams.kinkRate1)\\n                .div(irParams.kinkUtilization1);\\n        } else if (utilization <= irParams.kinkUtilization2) {\\n            // (utilization - kinkUtilization1) * (kinkRate2 - kinkRate1) \\n            // ---------------------------------------------------------- + kinkRate1\\n            //            (kinkUtilization2 - kinkUtilization1)\\n            preFeeInterestRate = (utilization - irParams.kinkUtilization1) // underflow checked\\n                .mul(irParams.kinkRate2 - irParams.kinkRate1) // underflow checked by definition\\n                .div(irParams.kinkUtilization2 - irParams.kinkUtilization1) // underflow checked by definition\\n                .add(irParams.kinkRate1);\\n        } else {\\n            // (utilization - kinkUtilization2) * (maxRate - kinkRate2) \\n            // ---------------------------------------------------------- + kinkRate2\\n            //                  (1 - kinkUtilization2)\\n            preFeeInterestRate = (utilization - irParams.kinkUtilization2) // underflow checked\\n                .mul(irParams.maxRate - irParams.kinkRate2) // underflow checked by definition\\n                .div(uint256(Constants.RATE_PRECISION) - irParams.kinkUtilization2) // underflow checked by definition\\n                .add(irParams.kinkRate2);\\n        }\\n    }\\n\\n    /// @notice Calculates a market utilization via the interest rate, is the\\n    /// inverse of getInterestRate\\n    function getUtilizationFromInterestRate(\\n        InterestRateParameters memory irParams,\\n        uint256 interestRate\\n    ) internal pure returns (uint256 utilization) {\\n        // If this is not set, then assume that the rate parameters have not been initialized\\n        // and revert.\\n        require(irParams.maxRate > 0);\\n\\n        if (interestRate <= irParams.kinkRate1) {\\n            // interestRate * kinkUtilization1 / kinkRate1\\n            utilization = interestRate\\n                .mul(irParams.kinkUtilization1)\\n                .div(irParams.kinkRate1);\\n        } else if (interestRate <= irParams.kinkRate2) {\\n            // (interestRate - kinkRate1) * (kinkUtilization2 - kinkUtilization1) \\n            // ------------------------------------------------------------------   + kinkUtilization1\\n            //                  (kinkRate2 - kinkRate1)\\n            utilization = (interestRate - irParams.kinkRate1) // underflow checked\\n                .mul(irParams.kinkUtilization2 - irParams.kinkUtilization1) // underflow checked by definition\\n                .div(irParams.kinkRate2 - irParams.kinkRate1) // underflow checked by definition\\n                .add(irParams.kinkUtilization1);\\n        } else {\\n            // NOTE: in this else block, it is possible for interestRate > maxRate and therefore this\\n            // method will return a utilization greater than 100%. During initialize markets, if this condition\\n            // exists then the utilization will be marked down to the leverage threshold which is by definition\\n            // less than 100% utilization.\\n\\n            // (interestRate - kinkRate2) * (1 - kinkUtilization2)\\n            // -----------------------------------------------------  + kinkUtilization2\\n            //                  (maxRate - kinkRate2)\\n            utilization = (interestRate - irParams.kinkRate2) // underflow checked\\n                .mul(uint256(Constants.RATE_PRECISION) - irParams.kinkUtilization2) // underflow checked by definition\\n                .div(irParams.maxRate - irParams.kinkRate2) // underflow checked by definition\\n                .add(irParams.kinkUtilization2);\\n        }\\n    }\\n\\n    /// @notice Applies fees to an interest rate\\n    /// @param irParams contains the relevant fee parameters\\n    /// @param preFeeInterestRate the interest rate before the fee\\n    /// @param isBorrow if true, the fee increases the rate, else it decreases the rate\\n    /// @return postFeeInterestRate the interest rate with a fee applied, floored at zero\\n    function getPostFeeInterestRate(\\n        InterestRateParameters memory irParams,\\n        uint256 preFeeInterestRate,\\n        bool isBorrow\\n    ) internal pure returns (uint256 postFeeInterestRate) {\\n        uint256 feeRate = preFeeInterestRate.mul(irParams.feeRatePercent).div(uint256(Constants.PERCENTAGE_DECIMALS));\\n        if (feeRate < irParams.minFeeRate) feeRate = irParams.minFeeRate;\\n        if (feeRate > irParams.maxFeeRate) feeRate = irParams.maxFeeRate;\\n\\n        if (isBorrow) {\\n            // Borrows increase the interest rate, it is ok for the feeRate to exceed the maxRate here.\\n            postFeeInterestRate = preFeeInterestRate.add(feeRate);\\n        } else {\\n            // Lending decreases the interest rate, do not allow the postFeeInterestRate to underflow\\n            postFeeInterestRate = feeRate > preFeeInterestRate ? 0 : (preFeeInterestRate - feeRate);\\n        }\\n    }\\n\\n    /// @notice Calculates the asset cash amount the results from trading fCashToAccount with the market. A positive\\n    /// fCashToAccount is equivalent of lending, a negative is borrowing. Updates the market state in memory.\\n    /// @param market the current market state\\n    /// @param cashGroup cash group configuration parameters\\n    /// @param fCashToAccount the fCash amount that will be deposited into the user's portfolio. The net change\\n    /// to the market is in the opposite direction.\\n    /// @param timeToMaturity number of seconds until maturity\\n    /// @param marketIndex the relevant tenor of the market to trade on\\n    /// @return netPrimeCashToAccount amount of asset cash to credit or debit to an account\\n    /// @return primeCashToReserve amount of cash to credit to the reserve (always positive)\\n    /// @return postFeeInterestRate\\n    function calculatefCashTrade(\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity,\\n        uint256 marketIndex\\n    ) internal view returns (int256 netPrimeCashToAccount, int256 primeCashToReserve, uint256 postFeeInterestRate) {\\n        // Market index must be greater than zero\\n        require(marketIndex > 0);\\n        // We return false if there is not enough fCash to support this trade.\\n        // if fCashToAccount > 0 and totalfCash - fCashToAccount <= 0 then the trade will fail\\n        // if fCashToAccount < 0 and totalfCash > 0 then this will always pass\\n        if (market.totalfCash <= fCashToAccount) return (0, 0, 0);\\n\\n        InterestRateParameters memory irParams = getActiveInterestRateParameters(cashGroup.currencyId, marketIndex);\\n        int256 totalCashUnderlying = cashGroup.primeRate.convertToUnderlying(market.totalPrimeCash);\\n\\n        // returns the net cash amounts to apply to each of the three relevant balances.\\n        int256 netUnderlyingToAccount;\\n        int256 netUnderlyingToMarket;\\n        int256 netUnderlyingToReserve;\\n        (\\n            netUnderlyingToAccount,\\n            netUnderlyingToMarket,\\n            netUnderlyingToReserve,\\n            postFeeInterestRate\\n        ) = _getNetCashAmountsUnderlying(\\n            irParams,\\n            market,\\n            cashGroup,\\n            totalCashUnderlying,\\n            fCashToAccount,\\n            timeToMaturity\\n        );\\n\\n        // Signifies a failed net cash amount calculation\\n        if (netUnderlyingToAccount == 0) return (0, 0, 0);\\n\\n        {\\n            // Do not allow utilization to go above 100 on trading, calculate the utilization after\\n            // the trade has taken effect, meaning that fCash changes and cash changes are applied to\\n            // the market totals.\\n            market.totalfCash = market.totalfCash.subNoNeg(fCashToAccount);\\n            totalCashUnderlying = totalCashUnderlying.add(netUnderlyingToMarket);\\n\\n            uint256 utilization = getfCashUtilization(0, market.totalfCash, totalCashUnderlying);\\n            if (utilization > uint256(Constants.RATE_PRECISION)) return (0, 0, 0);\\n\\n            uint256 newPreFeeImpliedRate = getInterestRate(irParams, utilization);\\n\\n            // It's technically possible that the implied rate is actually exactly zero we will still\\n            // fail in this case. If this does happen we may assume that markets are not initialized.\\n            if (newPreFeeImpliedRate == 0) return (0, 0, 0);\\n\\n            // Saves the preFeeInterestRate and fCash\\n            market.lastImpliedRate = newPreFeeImpliedRate;\\n        }\\n\\n        (netPrimeCashToAccount, primeCashToReserve) = _setNewMarketState(\\n            market,\\n            cashGroup.primeRate,\\n            netUnderlyingToAccount,\\n            netUnderlyingToMarket,\\n            netUnderlyingToReserve\\n        );\\n    }\\n\\n    /// @notice Returns net underlying cash amounts to the account, the market and the reserve.\\n    /// @return postFeeCashToAccount this is a positive or negative amount of cash change to the account\\n    /// @return netUnderlyingToMarket this is a positive or negative amount of cash change in the market\\n    /// @return cashToReserve this is always a positive amount of cash accrued to the reserve\\n    function _getNetCashAmountsUnderlying(\\n        InterestRateParameters memory irParams,\\n        MarketParameters memory market,\\n        CashGroupParameters memory cashGroup,\\n        int256 totalCashUnderlying,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity\\n    ) private pure returns (\\n        int256 postFeeCashToAccount,\\n        int256 netUnderlyingToMarket,\\n        int256 cashToReserve,\\n        uint256 postFeeInterestRate\\n    ) {\\n        uint256 utilization = getfCashUtilization(fCashToAccount, market.totalfCash, totalCashUnderlying);\\n        // Do not allow utilization to go above 100 on trading\\n        if (utilization > uint256(Constants.RATE_PRECISION)) return (0, 0, 0, 0);\\n        uint256 preFeeInterestRate = getInterestRate(irParams, utilization);\\n\\n        int256 preFeeCashToAccount = fCashToAccount.divInRatePrecision(\\n            getfCashExchangeRate(preFeeInterestRate, timeToMaturity)\\n        ).neg();\\n\\n        postFeeInterestRate = getPostFeeInterestRate(irParams, preFeeInterestRate, fCashToAccount < 0);\\n        postFeeCashToAccount = fCashToAccount.divInRatePrecision(\\n            getfCashExchangeRate(postFeeInterestRate, timeToMaturity)\\n        ).neg();\\n\\n        require(postFeeCashToAccount <= preFeeCashToAccount);\\n        // Both pre fee cash to account and post fee cash to account are either negative (lending) or positive\\n        // (borrowing). Fee will be positive or zero as a result.\\n        int256 fee = preFeeCashToAccount.sub(postFeeCashToAccount);\\n\\n        cashToReserve = fee.mul(cashGroup.getReserveFeeShare()).div(Constants.PERCENTAGE_DECIMALS);\\n\\n        // This inequality must hold inside given the fees:\\n        //  netToMarket + cashToReserve + postFeeCashToAccount = 0\\n\\n        // Example: Lending\\n        // Pre Fee Cash: -97 ETH\\n        // Post Fee Cash: -100 ETH\\n        // Fee: 3 ETH\\n        // To Reserve: 1 ETH\\n        // Net To Market = 99 ETH\\n        // 99 + 1 - 100 == 0\\n\\n        // Example: Borrowing\\n        // Pre Fee Cash: 100 ETH\\n        // Post Fee Cash: 97 ETH\\n        // Fee: 3 ETH\\n        // To Reserve: 1 ETH\\n        // Net To Market = -98 ETH\\n        // 97 + 1 - 98 == 0\\n\\n        // Therefore:\\n        //  netToMarket = - cashToReserve - postFeeCashToAccount\\n        //  netToMarket = - (cashToReserve + postFeeCashToAccount)\\n\\n        netUnderlyingToMarket = (postFeeCashToAccount.add(cashToReserve)).neg();\\n    }\\n\\n    /// @notice Sets the new market state\\n    /// @return netAssetCashToAccount: the positive or negative change in asset cash to the account\\n    /// @return assetCashToReserve: the positive amount of cash that accrues to the reserve\\n    function _setNewMarketState(\\n        MarketParameters memory market,\\n        PrimeRate memory primeRate,\\n        int256 netUnderlyingToAccount,\\n        int256 netUnderlyingToMarket,\\n        int256 netUnderlyingToReserve\\n    ) private view returns (int256, int256) {\\n        int256 netPrimeCashToMarket = primeRate.convertFromUnderlying(netUnderlyingToMarket);\\n        // Set storage checks that total prime cash is above zero\\n        market.totalPrimeCash = market.totalPrimeCash.add(netPrimeCashToMarket);\\n\\n        // Sets the trade time for the next oracle update\\n        market.previousTradeTime = block.timestamp;\\n        int256 primeCashToReserve = primeRate.convertFromUnderlying(netUnderlyingToReserve);\\n        int256 netPrimeCashToAccount = primeRate.convertFromUnderlying(netUnderlyingToAccount);\\n        return (netPrimeCashToAccount, primeCashToReserve);\\n    }\\n\\n    /// @notice Converts an interest rate to an exchange rate given a time to maturity. The\\n    /// formula is E = e^rt\\n    function getfCashExchangeRate(\\n        uint256 interestRate,\\n        uint256 timeToMaturity\\n    ) internal pure returns (int256 exchangeRate) {\\n        int128 expValue =\\n            ABDKMath64x64.fromUInt(interestRate.mul(timeToMaturity).div(Constants.YEAR));\\n        int128 expValueScaled = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\n        int128 expResult = ABDKMath64x64.exp(expValueScaled);\\n        int128 expResultScaled = ABDKMath64x64.mul(expResult, Constants.RATE_PRECISION_64x64);\\n\\n        exchangeRate = ABDKMath64x64.toInt(expResultScaled);\\n    }\\n\\n    /// @notice Uses secant method to converge on an fCash amount given the amount\\n    /// of cash. The relation between cash and fCash is:\\n    /// f(fCash) = cashAmount * exchangeRatePostFee(fCash) + fCash = 0\\n    /// where exchangeRatePostFee = e ^ (interestRatePostFee * timeToMaturity)\\n    ///       and interestRatePostFee = interestRateFunc(utilization)\\n    ///       and utilization = (totalfCash - fCashToAccount) / (totalfCash + totalCash)\\n    ///\\n    /// interestRateFunc is guaranteed to be monotonic and continuous, however, it is not\\n    /// differentiable therefore we must use the secant method instead of Newton's method.\\n    ///\\n    /// Secant method is:\\n    ///                          x_1 - x_0\\n    ///  x_n = x_1 - f(x_1) * ---------------\\n    ///                       f(x_1) - f(x_0)\\n    ///\\n    ///  break when (x_n - x_1) < maxDelta\\n    ///\\n    /// The initial guesses for x_0 and x_1 depend on the direction of the trade.\\n    ///     netUnderlyingToAccount > 0, then fCashToAccount < 0 and the interest rate will increase\\n    ///         therefore x_0 = f @ current utilization and x_1 = f @ max utilization\\n    ///     netUnderlyingToAccount < 0, then fCashToAccount > 0 and the interest rate will decrease\\n    ///         therefore x_0 = f @ min utilization and x_1 = f @ current utilization\\n    ///\\n    /// These initial guesses will ensure that the method converges to a root (if one exists).\\n    function getfCashGivenCashAmount(\\n        InterestRateParameters memory irParams,\\n        int256 totalfCash,\\n        int256 netUnderlyingToAccount,\\n        int256 totalCashUnderlying,\\n        uint256 timeToMaturity\\n    ) internal pure returns (int256) {\\n        require(netUnderlyingToAccount != 0);\\n        // Cannot borrow more than total cash underlying\\n        require(netUnderlyingToAccount <= totalCashUnderlying, \\\"Over Market Limit\\\");\\n\\n        int256 fCash_0;\\n        int256 fCash_1;\\n        {\\n            // Calculate fCash rate at the current mid point\\n            int256 currentfCashExchangeRate = _calculatePostFeeExchangeRate(\\n                irParams,\\n                totalfCash,\\n                totalCashUnderlying,\\n                timeToMaturity,\\n                netUnderlyingToAccount > 0 ? int256(-1) : int256(1) // set this such that we get the correct fee direction\\n            );\\n\\n            if (netUnderlyingToAccount < 0) {\\n                // Lending\\n                // Minimum guess is lending at 0% interest, which means receiving fCash 1-1\\n                // with underlying cash amounts\\n                fCash_0 = netUnderlyingToAccount.neg();\\n                fCash_1 = netUnderlyingToAccount.mulInRatePrecision(currentfCashExchangeRate).neg();\\n            } else {\\n                // Borrowing\\n                fCash_0 = netUnderlyingToAccount.mulInRatePrecision(currentfCashExchangeRate).neg();\\n                fCash_1 = netUnderlyingToAccount.mulInRatePrecision(\\n                    getfCashExchangeRate(irParams.maxRate, timeToMaturity)\\n                ).neg();\\n            }\\n        }\\n\\n        int256 diff_0 = _calculateDiff(\\n            irParams,\\n            totalfCash,\\n            totalCashUnderlying,\\n            fCash_0,\\n            timeToMaturity,\\n            netUnderlyingToAccount\\n        );\\n\\n        for (uint8 i = 0; i < 250; i++) {\\n            int256 fCashDelta = (fCash_1 - fCash_0);\\n            if (fCashDelta == 0) return fCash_1;\\n            int256 diff_1 = _calculateDiff(\\n                irParams,\\n                totalfCash,\\n                totalCashUnderlying,\\n                fCash_1,\\n                timeToMaturity,\\n                netUnderlyingToAccount\\n            );\\n            int256 fCash_n = fCash_1.sub(diff_1.mul(fCashDelta).div(diff_1.sub(diff_0)));\\n\\n            // Assign new values for next comparison\\n            (fCash_1, fCash_0) = (fCash_n, fCash_1);\\n            diff_0 = diff_1;\\n        }\\n\\n        revert(\\\"No convergence\\\");\\n    }\\n\\n    function _calculateDiff(\\n        InterestRateParameters memory irParams,\\n        int256 totalfCash,\\n        int256 totalCashUnderlying,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity,\\n        int256 netUnderlyingToAccount\\n    ) private pure returns (int256) {\\n        int256 exchangeRate =  _calculatePostFeeExchangeRate(\\n            irParams,\\n            totalfCash,\\n            totalCashUnderlying,\\n            timeToMaturity,\\n            fCashToAccount\\n        );\\n\\n        return fCashToAccount.add(netUnderlyingToAccount.mulInRatePrecision(exchangeRate));\\n    }\\n\\n    function _calculatePostFeeExchangeRate(\\n        InterestRateParameters memory irParams,\\n        int256 totalfCash,\\n        int256 totalCashUnderlying,\\n        uint256 timeToMaturity,\\n        int256 fCashToAccount\\n    ) private pure returns (int256) {\\n        uint256 preFeeInterestRate = getInterestRate(\\n            irParams,\\n            getfCashUtilization(fCashToAccount, totalfCash, totalCashUnderlying)\\n        );\\n        uint256 postFeeInterestRate = getPostFeeInterestRate(irParams, preFeeInterestRate, fCashToAccount < 0);\\n\\n        return getfCashExchangeRate(postFeeInterestRate, timeToMaturity);\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/markets/Market.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    MarketStorage,\\n    MarketParameters,\\n    CashGroupParameters\\n} from \\\"../../global/Types.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\n\\nimport {Emitter} from \\\"../Emitter.sol\\\";\\nimport {BalanceHandler} from \\\"../balances/BalanceHandler.sol\\\";\\nimport {DateTime} from \\\"./DateTime.sol\\\";\\nimport {InterestRateCurve} from \\\"./InterestRateCurve.sol\\\";\\n\\nlibrary Market {\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n\\n    /// @notice Add liquidity to a market, assuming that it is initialized. If not then\\n    /// this method will revert and the market must be initialized first.\\n    /// Return liquidityTokens and negative fCash to the portfolio\\n    function addLiquidity(MarketParameters memory market, int256 primeCash)\\n        internal\\n        returns (int256 liquidityTokens, int256 fCash)\\n    {\\n        require(market.totalLiquidity > 0, \\\"M: zero liquidity\\\");\\n        if (primeCash == 0) return (0, 0);\\n        require(primeCash > 0); // dev: negative asset cash\\n\\n        liquidityTokens = market.totalLiquidity.mul(primeCash).div(market.totalPrimeCash);\\n        // No need to convert this to underlying, primeCash / totalPrimeCash is a unitless proportion.\\n        fCash = market.totalfCash.mul(primeCash).div(market.totalPrimeCash);\\n\\n        market.totalLiquidity = market.totalLiquidity.add(liquidityTokens);\\n        market.totalfCash = market.totalfCash.add(fCash);\\n        market.totalPrimeCash = market.totalPrimeCash.add(primeCash);\\n        _setMarketStorageForLiquidity(market);\\n        // Flip the sign to represent the LP's net position\\n        fCash = fCash.neg();\\n    }\\n\\n    /// @notice Remove liquidity from a market, assuming that it is initialized.\\n    /// Return primeCash and positive fCash to the portfolio\\n    function removeLiquidity(MarketParameters memory market, int256 tokensToRemove)\\n        internal\\n        returns (int256 primeCash, int256 fCash)\\n    {\\n        if (tokensToRemove == 0) return (0, 0);\\n        require(tokensToRemove > 0); // dev: negative tokens to remove\\n\\n        primeCash = market.totalPrimeCash.mul(tokensToRemove).div(market.totalLiquidity);\\n        fCash = market.totalfCash.mul(tokensToRemove).div(market.totalLiquidity);\\n\\n        market.totalLiquidity = market.totalLiquidity.subNoNeg(tokensToRemove);\\n        market.totalfCash = market.totalfCash.subNoNeg(fCash);\\n        market.totalPrimeCash = market.totalPrimeCash.subNoNeg(primeCash);\\n\\n        _setMarketStorageForLiquidity(market);\\n    }\\n\\n    function executeTrade(\\n        MarketParameters memory market,\\n        address account,\\n        CashGroupParameters memory cashGroup,\\n        int256 fCashToAccount,\\n        uint256 timeToMaturity,\\n        uint256 marketIndex\\n    ) internal returns (int256 netPrimeCash, uint256 postFeeInterestRate) {\\n        int256 netPrimeCashToReserve;\\n        (netPrimeCash, netPrimeCashToReserve, postFeeInterestRate) = InterestRateCurve.calculatefCashTrade(\\n            market,\\n            cashGroup,\\n            fCashToAccount,\\n            timeToMaturity,\\n            marketIndex\\n        );\\n\\n        // A zero net prime cash value means that the trade has failed and we should not update the market state\\n        if (netPrimeCash != 0) {\\n            MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\n            _setMarketStorage(\\n                marketStorage,\\n                market.totalfCash,\\n                market.totalPrimeCash,\\n                market.lastImpliedRate,\\n                market.oracleRate,\\n                market.previousTradeTime\\n            );\\n            BalanceHandler.incrementFeeToReserve(cashGroup.currencyId, netPrimeCashToReserve);\\n\\n            Emitter.emitfCashMarketTrade(\\n                account, cashGroup.currencyId, market.maturity, fCashToAccount, netPrimeCash, netPrimeCashToReserve\\n            );\\n        }\\n    }\\n\\n    function getOracleRate(\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 rateOracleTimeWindow,\\n        uint256 blockTime\\n    ) internal view returns (uint256) {\\n        mapping(uint256 => mapping(uint256 => \\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\n\\n        uint256 lastImpliedRate = marketStorage.lastImpliedRate;\\n        uint256 oracleRate = marketStorage.oracleRate;\\n        uint256 previousTradeTime = marketStorage.previousTradeTime;\\n\\n        // If the oracle rate is set to zero this can only be because the markets have past their settlement\\n        // date but the new set of markets has not yet been initialized. This means that accounts cannot be liquidated\\n        // during this time, but market initialization can be called by anyone so the actual time that this condition\\n        // exists for should be quite short.\\n        require(oracleRate > 0, \\\"Market not initialized\\\");\\n\\n        return\\n            InterestRateCurve.updateRateOracle(\\n                previousTradeTime,\\n                lastImpliedRate,\\n                oracleRate,\\n                rateOracleTimeWindow,\\n                blockTime\\n            );\\n    }\\n\\n    /// @notice Reads a market object directly from storage. `loadMarket` should be called instead of this method\\n    /// which ensures that the rate oracle is set properly.\\n    function _loadMarketStorage(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        bool needsLiquidity,\\n        uint256 settlementDate\\n    ) private view {\\n        // Market object always uses the most current reference time as the settlement date\\n        mapping(uint256 => mapping(uint256 => \\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\n        MarketStorage storage marketStorage = store[currencyId][maturity][settlementDate];\\n        bytes32 slot;\\n        assembly {\\n            slot := marketStorage.slot\\n        }\\n\\n        market.storageSlot = slot;\\n        market.maturity = maturity;\\n        market.totalfCash = marketStorage.totalfCash;\\n        market.totalPrimeCash = marketStorage.totalPrimeCash;\\n        market.lastImpliedRate = marketStorage.lastImpliedRate;\\n        market.oracleRate = marketStorage.oracleRate;\\n        market.previousTradeTime = marketStorage.previousTradeTime;\\n\\n        if (needsLiquidity) {\\n            market.totalLiquidity = marketStorage.totalLiquidity;\\n        } else {\\n            market.totalLiquidity = 0;\\n        }\\n    }\\n\\n    function _getMarketStoragePointer(\\n        MarketParameters memory market\\n    ) private pure returns (MarketStorage storage marketStorage) {\\n        bytes32 slot = market.storageSlot;\\n        assembly {\\n            marketStorage.slot := slot\\n        }\\n    }\\n\\n    function _setMarketStorageForLiquidity(MarketParameters memory market) internal {\\n        MarketStorage storage marketStorage = _getMarketStoragePointer(market);\\n        // Oracle rate does not change on liquidity\\n        uint32 storedOracleRate = marketStorage.oracleRate;\\n\\n        _setMarketStorage(\\n            marketStorage,\\n            market.totalfCash,\\n            market.totalPrimeCash,\\n            market.lastImpliedRate,\\n            storedOracleRate,\\n            market.previousTradeTime\\n        );\\n\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\n    }\\n\\n    function setMarketStorageForInitialize(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 settlementDate\\n    ) internal {\\n        // On initialization we have not yet calculated the storage slot so we get it here.\\n        mapping(uint256 => mapping(uint256 => \\n            mapping(uint256 => MarketStorage))) storage store = LibStorage.getMarketStorage();\\n        MarketStorage storage marketStorage = store[currencyId][market.maturity][settlementDate];\\n\\n        _setMarketStorage(\\n            marketStorage,\\n            market.totalfCash,\\n            market.totalPrimeCash,\\n            market.lastImpliedRate,\\n            market.oracleRate,\\n            market.previousTradeTime\\n        );\\n\\n        _setTotalLiquidity(marketStorage, market.totalLiquidity);\\n    }\\n\\n    function _setTotalLiquidity(\\n        MarketStorage storage marketStorage,\\n        int256 totalLiquidity\\n    ) internal {\\n        require(totalLiquidity >= 0 && totalLiquidity <= type(uint80).max); // dev: market storage totalLiquidity overflow\\n        marketStorage.totalLiquidity = uint80(totalLiquidity);\\n    }\\n\\n    function _setMarketStorage(\\n        MarketStorage storage marketStorage,\\n        int256 totalfCash,\\n        int256 totalPrimeCash,\\n        uint256 lastImpliedRate,\\n        uint256 oracleRate,\\n        uint256 previousTradeTime\\n    ) private {\\n        require(totalfCash >= 0 && totalfCash <= type(uint80).max); // dev: storage totalfCash overflow\\n        require(totalPrimeCash >= 0 && totalPrimeCash <= type(uint80).max); // dev: storage totalPrimeCash overflow\\n        require(0 < lastImpliedRate && lastImpliedRate <= type(uint32).max); // dev: storage lastImpliedRate overflow\\n        require(0 < oracleRate && oracleRate <= type(uint32).max); // dev: storage oracleRate overflow\\n        require(0 <= previousTradeTime && previousTradeTime <= type(uint32).max); // dev: storage previous trade time overflow\\n\\n        marketStorage.totalfCash = uint80(totalfCash);\\n        marketStorage.totalPrimeCash = uint80(totalPrimeCash);\\n        marketStorage.lastImpliedRate = uint32(lastImpliedRate);\\n        marketStorage.oracleRate = uint32(oracleRate);\\n        marketStorage.previousTradeTime = uint32(previousTradeTime);\\n    }\\n\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately.\\n    function loadMarket(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        bool needsLiquidity,\\n        uint256 rateOracleTimeWindow\\n    ) internal view {\\n        // Always reference the current settlement date\\n        uint256 settlementDate = DateTime.getReferenceTime(blockTime) + Constants.QUARTER;\\n        loadMarketWithSettlementDate(\\n            market,\\n            currencyId,\\n            maturity,\\n            blockTime,\\n            needsLiquidity,\\n            rateOracleTimeWindow,\\n            settlementDate\\n        );\\n    }\\n\\n    /// @notice Creates a market object and ensures that the rate oracle time window is updated appropriately, this\\n    /// is mainly used in the InitializeMarketAction contract.\\n    function loadMarketWithSettlementDate(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        bool needsLiquidity,\\n        uint256 rateOracleTimeWindow,\\n        uint256 settlementDate\\n    ) internal view {\\n        _loadMarketStorage(market, currencyId, maturity, needsLiquidity, settlementDate);\\n\\n        market.oracleRate = InterestRateCurve.updateRateOracle(\\n            market.previousTradeTime,\\n            market.lastImpliedRate,\\n            market.oracleRate,\\n            rateOracleTimeWindow,\\n            blockTime\\n        );\\n    }\\n\\n    function loadSettlementMarket(\\n        MarketParameters memory market,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 settlementDate\\n    ) internal view {\\n        _loadMarketStorage(market, currencyId, maturity, true, settlementDate);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/internal/nToken/nTokenCalculations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    PrimeRate,\\n    nTokenPortfolio,\\n    CashGroupParameters,\\n    MarketParameters,\\n    PortfolioAsset\\n} from \\\"../../global/Types.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {Bitmap} from \\\"../../math/Bitmap.sol\\\";\\n\\nimport {BitmapAssetsHandler} from \\\"../portfolio/BitmapAssetsHandler.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {CashGroup} from \\\"../markets/CashGroup.sol\\\";\\nimport {DateTime} from \\\"../markets/DateTime.sol\\\";\\nimport {AssetHandler} from \\\"../valuation/AssetHandler.sol\\\";\\n\\nimport {nTokenHandler} from \\\"./nTokenHandler.sol\\\";\\n\\nlibrary nTokenCalculations {\\n    using Bitmap for bytes32;\\n    using SafeInt256 for int256;\\n    using PrimeRateLib for PrimeRate;\\n    using CashGroup for CashGroupParameters;\\n\\n    /// @notice Calculates the tokens to mint to the account as a ratio of the nToken\\n    /// present value denominated in asset cash terms.\\n    /// @return the amount of tokens to mint, the ifCash bitmap\\n    function calculateTokensToMint(\\n        nTokenPortfolio memory nToken,\\n        int256 primeCashToDeposit,\\n        uint256 blockTime\\n    ) internal view returns (int256) {\\n        require(primeCashToDeposit >= 0); // dev: deposit amount negative\\n        if (primeCashToDeposit == 0) return 0;\\n\\n        if (nToken.lastInitializedTime != 0) {\\n            // For the sake of simplicity, nTokens cannot be minted if they have assets\\n            // that need to be settled. This is only done during market initialization.\\n            uint256 nextSettleTime = nTokenHandler.getNextSettleTime(nToken);\\n            // If next settle time <= blockTime then the token can be settled\\n            require(nextSettleTime > blockTime, \\\"Requires settlement\\\");\\n        }\\n\\n        if (nToken.totalSupply == 0) {\\n            // Allow for the first deposit and bypass all the PV valuation\\n            return primeCashToDeposit;\\n        } else {\\n            (int256 nTokenOracleValue, int256 nTokenSpotValue) = nTokenCalculations.getNTokenPrimePVForMinting(\\n                nToken, blockTime\\n            );\\n\\n            // Defensive check to ensure PV remains positive\\n            require(nTokenOracleValue >= 0);\\n            require(nTokenSpotValue >= 0);\\n\\n            int256 maxValueDeviationRP = int256(\\n                uint256(uint8(nToken.parameters[Constants.MAX_MINT_DEVIATION_LIMIT])) * Constants.FIVE_BASIS_POINTS\\n            );\\n            // Check deviation limit here\\n            int256 deviationInRP = nTokenOracleValue.sub(nTokenSpotValue).abs()\\n                .divInRatePrecision(nTokenOracleValue);\\n            require(deviationInRP <= maxValueDeviationRP, \\\"Over Deviation Limit\\\");\\n\\n            // nTokenSpotValuePost = nTokenOracleValue + amountToDeposit\\n            // (tokenSupply + tokensToMint) / tokenSupply == (nTokenSpotValue + amountToDeposit) / nTokenOracleValue\\n            // (tokenSupply + tokensToMint) == (nTokenSpotValue + amountToDeposit) * tokenSupply / nTokenOracleValue\\n            // (tokenSupply + tokensToMint) == tokenSupply + (amountToDeposit * tokenSupply) / nTokenSpotValue\\n            // tokensToMint == (amountToDeposit * tokenSupply) / nTokenSpotValue\\n            return primeCashToDeposit.mul(nToken.totalSupply).div(nTokenSpotValue);\\n        }\\n    }\\n\\n    function getNTokenPrimePVForMinting(nTokenPortfolio memory nToken, uint256 blockTime)\\n        internal view returns (int256 nTokenOracleValue, int256 nTokenSpotValue) {\\n        // Skip the \\\"nextSettleTime\\\" check in this method. nTokens are not mintable when markets\\n        // are not yet initialized.\\n\\n        (int256 totalOracleValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\\n            {nToken: nToken, blockTime: blockTime, useOracleRate: true}\\n        );\\n        (int256 totalSpotValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\\n            {nToken: nToken, blockTime: blockTime, useOracleRate: false}\\n        );\\n        int256 ifCashResidualPrimePV = _getIfCashResidualPrimePV(nToken, blockTime);\\n\\n        // Return the total present value denominated in asset terms\\n        nTokenOracleValue = totalOracleValueInMarkets.add(ifCashResidualPrimePV).add(nToken.cashBalance);\\n        nTokenSpotValue = totalSpotValueInMarkets.add(ifCashResidualPrimePV).add(nToken.cashBalance);\\n    }\\n\\n    /// @notice Returns the nToken present value denominated in asset terms.\\n    function getNTokenPrimePV(nTokenPortfolio memory nToken, uint256 blockTime)\\n        internal view returns (int256) {\\n        {\\n            uint256 nextSettleTime = nTokenHandler.getNextSettleTime(nToken);\\n            // If the first asset maturity has passed (the 3 month), this means that all the LTs must\\n            // be settled except the 6 month (which is now the 3 month). We don't settle LTs except in\\n            // initialize markets so we calculate the cash value of the portfolio here.\\n            if (nextSettleTime <= blockTime) {\\n                // NOTE: this condition should only be present for a very short amount of time, which is the window between\\n                // when the markets are no longer tradable at quarter end and when the new markets have been initialized.\\n                // We time travel back to one second before maturity to value the liquidity tokens. Although this value is\\n                // not strictly correct the different should be quite slight. We do this to ensure that free collateral checks\\n                // for withdraws and liquidations can still be processed. If this condition persists for a long period of time then\\n                // the entire protocol will have serious problems as markets will not be tradable.\\n                blockTime = nextSettleTime - 1;\\n            }\\n        }\\n\\n        // This is the total value in liquid assets\\n        (int256 totalOracleValueInMarkets, /* int256[] memory netfCash */) = getNTokenMarketValue(\\n            {nToken: nToken, blockTime: blockTime, useOracleRate: true}\\n        );\\n\\n        int256 ifCashResidualPrimePV = _getIfCashResidualPrimePV(nToken, blockTime);\\n\\n        // Return the total present value denominated in prime cash terms\\n        return totalOracleValueInMarkets.add(ifCashResidualPrimePV).add(nToken.cashBalance);\\n    }\\n\\n    function _getIfCashResidualPrimePV(\\n        nTokenPortfolio memory nToken, uint256 blockTime\\n    ) private view returns (int256) {\\n        // Then get the total value in any idiosyncratic fCash residuals (if they exist)\\n        bytes32 ifCashBits = getNTokenifCashBits(\\n            nToken.tokenAddress,\\n            nToken.cashGroup.currencyId,\\n            nToken.lastInitializedTime,\\n            blockTime,\\n            nToken.cashGroup.maxMarketIndex\\n        );\\n\\n        if (ifCashBits != 0) {\\n            // Non idiosyncratic residuals have already been accounted for\\n            (int256 ifCashResidualUnderlyingPV, /* hasDebt */) = BitmapAssetsHandler.getNetPresentValueFromBitmap(\\n                nToken.tokenAddress,\\n                nToken.cashGroup.currencyId,\\n                nToken.lastInitializedTime,\\n                blockTime,\\n                nToken.cashGroup,\\n                false, // nToken present value calculation does not use risk adjusted values\\n                ifCashBits\\n            );\\n            return nToken.cashGroup.primeRate.convertFromUnderlying(ifCashResidualUnderlyingPV);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @notice Handles the case when liquidity tokens should be withdrawn in proportion to their amounts\\n     * in the market. This will be the case when there is no idiosyncratic fCash residuals in the nToken\\n     * portfolio.\\n     * @param nToken portfolio object for nToken\\n     * @param nTokensToRedeem amount of nTokens to redeem\\n     * @param tokensToWithdraw array of liquidity tokens to withdraw from each market, proportional to\\n     * the account's share of the total supply\\n     * @param netfCash an empty array to hold net fCash values calculated later when the tokens are actually\\n     * withdrawn from markets\\n     */\\n    function _getProportionalLiquidityTokens(\\n        nTokenPortfolio memory nToken,\\n        int256 nTokensToRedeem\\n    ) private pure returns (int256[] memory tokensToWithdraw, int256[] memory netfCash) {\\n        uint256 numMarkets = nToken.portfolioState.storedAssets.length;\\n        tokensToWithdraw = new int256[](numMarkets);\\n        netfCash = new int256[](numMarkets);\\n\\n        for (uint256 i = 0; i < numMarkets; i++) {\\n            int256 totalTokens = nToken.portfolioState.storedAssets[i].notional;\\n            tokensToWithdraw[i] = totalTokens.mul(nTokensToRedeem).div(nToken.totalSupply);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the number of liquidity tokens to withdraw from each market if the nToken\\n     * has idiosyncratic residuals during nToken redeem. In this case the redeemer will take\\n     * their cash from the rest of the fCash markets, redeeming around the nToken.\\n     * @param nToken portfolio object for nToken\\n     * @param nTokensToRedeem amount of nTokens to redeem\\n     * @param blockTime block time\\n     * @param ifCashBits the bits in the bitmap that represent ifCash assets\\n     * @return tokensToWithdraw array of tokens to withdraw from each corresponding market\\n     * @return netfCash array of netfCash amounts to go back to the account\\n     */\\n    function getLiquidityTokenWithdraw(\\n        nTokenPortfolio memory nToken,\\n        int256 nTokensToRedeem,\\n        uint256 blockTime,\\n        bytes32 ifCashBits\\n    ) internal view returns (int256[] memory, int256[] memory) {\\n        // If there are no ifCash bits set then this will just return the proportion of all liquidity tokens\\n        if (ifCashBits == 0) return _getProportionalLiquidityTokens(nToken, nTokensToRedeem);\\n\\n        (\\n            int256 totalPrimeValueInMarkets,\\n            int256[] memory netfCash\\n        // Need to use market values here to match the withdraw amounts on minting\\n        ) = getNTokenMarketValue({nToken: nToken, blockTime: blockTime, useOracleRate: false});\\n        int256[] memory tokensToWithdraw = new int256[](netfCash.length);\\n\\n        // NOTE: this total portfolio asset value does not include any cash balance the nToken may hold.\\n        // The redeemer will always get a proportional share of this cash balance and therefore we don't\\n        // need to account for it here when we calculate the share of liquidity tokens to withdraw. We are\\n        // only concerned with the nToken's portfolio assets in this method.\\n        int256 totalPortfolioAssetValue;\\n        {\\n            // Returns the risk adjusted net present value for the idiosyncratic residuals\\n            (int256 underlyingPV, /* hasDebt */) = BitmapAssetsHandler.getNetPresentValueFromBitmap(\\n                nToken.tokenAddress,\\n                nToken.cashGroup.currencyId,\\n                nToken.lastInitializedTime,\\n                blockTime,\\n                nToken.cashGroup,\\n                true, // use risk adjusted here to assess a penalty for withdrawing around the residual\\n                ifCashBits\\n            );\\n\\n            // NOTE: we do not include cash balance here because the account will always take their share\\n            // of the cash balance regardless of the residuals\\n            totalPortfolioAssetValue = totalPrimeValueInMarkets.add(\\n                nToken.cashGroup.primeRate.convertFromUnderlying(underlyingPV)\\n            );\\n        }\\n\\n        // Loops through each liquidity token and calculates how much the redeemer can withdraw to get\\n        // the requisite amount of present value after adjusting for the ifCash residual value that is\\n        // not accessible via redemption.\\n        for (uint256 i = 0; i < tokensToWithdraw.length; i++) {\\n            int256 totalTokens = nToken.portfolioState.storedAssets[i].notional;\\n            // Redeemer's baseline share of the liquidity tokens based on total supply:\\n            //      redeemerShare = totalTokens * nTokensToRedeem / totalSupply\\n            // Scalar factor to account for residual value (need to inflate the tokens to withdraw\\n            // proportional to the value locked up in ifCash residuals):\\n            //      scaleFactor = totalPortfolioAssetValue / totalPrimeValueInMarkets\\n            // Final math equals:\\n            //      tokensToWithdraw = redeemerShare * scalarFactor\\n            //      tokensToWithdraw = (totalTokens * nTokensToRedeem * totalPortfolioAssetValue)\\n            //         / (totalPrimeValueInMarkets * totalSupply)\\n            tokensToWithdraw[i] = totalTokens\\n                .mul(nTokensToRedeem)\\n                .mul(totalPortfolioAssetValue);\\n\\n            tokensToWithdraw[i] = tokensToWithdraw[i]\\n                .div(totalPrimeValueInMarkets)\\n                .div(nToken.totalSupply);\\n\\n            // This is the share of net fcash that will be credited back to the account\\n            netfCash[i] = netfCash[i].mul(tokensToWithdraw[i]).div(totalTokens);\\n        }\\n\\n        return (tokensToWithdraw, netfCash);\\n    }\\n\\n    /// @notice Returns the value of all the liquid assets in an nToken portfolio which are defined by\\n    /// the liquidity tokens held in each market and their corresponding fCash positions. The formula\\n    /// can be described as:\\n    /// totalPrimeValue = sum_per_liquidity_token(cashClaim + presentValue(netfCash))\\n    ///     where netfCash = fCashClaim + fCash\\n    ///     and fCash refers the the fCash position at the corresponding maturity\\n    function getNTokenMarketValue(nTokenPortfolio memory nToken, uint256 blockTime, bool useOracleRate)\\n        internal view returns (int256 totalPrimeValue, int256[] memory netfCash)\\n    {\\n        uint256 numMarkets = nToken.portfolioState.storedAssets.length;\\n        netfCash = new int256[](numMarkets);\\n\\n        MarketParameters memory market;\\n        for (uint256 i = 0; i < numMarkets; i++) {\\n            // Load the corresponding market into memory\\n            nToken.cashGroup.loadMarket(market, i + 1, true, blockTime);\\n            PortfolioAsset memory liquidityToken = nToken.portfolioState.storedAssets[i];\\n\\n            // Get the fCash claims and fCash assets. We do not use haircut versions here because\\n            // nTokenRedeem does not require it and getNTokenPV does not use it (a haircut is applied\\n            // at the end of the calculation to the entire PV instead).\\n            (int256 primeCashClaim, int256 fCashClaim) = AssetHandler.getCashClaims(liquidityToken, market);\\n\\n            // fCash is denominated in underlying\\n            netfCash[i] = fCashClaim.add(\\n                BitmapAssetsHandler.getifCashNotional(\\n                    nToken.tokenAddress,\\n                    nToken.cashGroup.currencyId,\\n                    liquidityToken.maturity\\n                )\\n            );\\n\\n            // This calculates for a single liquidity token:\\n            // primeCashClaim + convertToPrimeCash(pv(netfCash))\\n            int256 netPrimeValueInMarket = primeCashClaim.add(\\n                nToken.cashGroup.primeRate.convertFromUnderlying(\\n                    AssetHandler.getPresentfCashValue(\\n                        netfCash[i],\\n                        liquidityToken.maturity,\\n                        blockTime,\\n                        // No need to call cash group for oracle rate, it is up to date here\\n                        // and we are assured to be referring to this market.\\n                        useOracleRate ? market.oracleRate : market.lastImpliedRate\\n                    )\\n                )\\n            );\\n\\n            // Calculate the running total\\n            totalPrimeValue = totalPrimeValue.add(netPrimeValueInMarket);\\n        }\\n    }\\n\\n    /// @notice Returns just the bits in a bitmap that are idiosyncratic\\n    function getNTokenifCashBits(\\n        address tokenAddress,\\n        uint256 currencyId,\\n        uint256 lastInitializedTime,\\n        uint256 blockTime,\\n        uint256 maxMarketIndex\\n    ) internal view returns (bytes32) {\\n        // If max market index is less than or equal to 2, there are never ifCash assets by construction\\n        if (maxMarketIndex <= 2) return bytes32(0);\\n        bytes32 assetsBitmap = BitmapAssetsHandler.getAssetsBitmap(tokenAddress, currencyId);\\n        // Handles the case when there are no assets at the first initialization\\n        if (assetsBitmap == 0) return assetsBitmap;\\n\\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\\n\\n        if (tRef == lastInitializedTime) {\\n            // This is a more efficient way to turn off ifCash assets in the common case when the market is\\n            // initialized immediately\\n            return assetsBitmap & ~(Constants.ACTIVE_MARKETS_MASK);\\n        } else {\\n            // In this branch, initialize markets has occurred past the time above. It would occur in these\\n            // two scenarios (both should be exceedingly rare):\\n            // 1. initializing a cash group with 3+ markets for the first time (not beginning on the tRef)\\n            // 2. somehow initialize markets has been delayed for more than 24 hours\\n            for (uint i = 1; i <= maxMarketIndex; i++) {\\n                // In this loop we get the maturity of each active market and turn off the corresponding bit\\n                // one by one. It is less efficient than the option above.\\n                uint256 maturity = tRef + DateTime.getTradedMarket(i);\\n                (uint256 bitNum, /* */) = DateTime.getBitNumFromMaturity(lastInitializedTime, maturity);\\n                assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            }\\n\\n            return assetsBitmap;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/nToken/nTokenHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    nTokenContext,\\n    nTokenPortfolio\\n} from \\\"../../global/Types.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\n\\nimport {BitmapAssetsHandler} from \\\"../portfolio/BitmapAssetsHandler.sol\\\";\\nimport {PortfolioHandler} from \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport {BalanceHandler} from \\\"../balances/BalanceHandler.sol\\\";\\nimport {CashGroup} from \\\"../markets/CashGroup.sol\\\";\\nimport {DateTime} from \\\"../markets/DateTime.sol\\\";\\n\\nimport {nTokenSupply} from \\\"./nTokenSupply.sol\\\";\\nimport {IRewarder} from \\\"../../../interfaces/notional/IRewarder.sol\\\";\\n\\nlibrary nTokenHandler {\\n    using SafeInt256 for int256;\\n\\n    /// @dev Mirror of the value in LibStorage, solidity compiler does not allow assigning\\n    /// two constants to each other.\\n    uint256 private constant NUM_NTOKEN_MARKET_FACTORS = 14;\\n\\n    /// @notice Returns an account context object that is specific to nTokens.\\n    function getNTokenContext(address tokenAddress)\\n        internal\\n        view\\n        returns (\\n            uint16 currencyId,\\n            uint256 incentiveAnnualEmissionRate,\\n            uint256 lastInitializedTime,\\n            uint8 assetArrayLength,\\n            bytes6 parameters\\n        )\\n    {\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n\\n        currencyId = context.currencyId;\\n        incentiveAnnualEmissionRate = context.incentiveAnnualEmissionRate;\\n        lastInitializedTime = context.lastInitializedTime;\\n        assetArrayLength = context.assetArrayLength;\\n        parameters = context.nTokenParameters;\\n    }\\n\\n    /// @notice Returns the nToken token address for a given currency\\n    function nTokenAddress(uint256 currencyId) internal view returns (address tokenAddress) {\\n        mapping(uint256 => address) storage store = LibStorage.getNTokenAddressStorage();\\n        return store[currencyId];\\n    }\\n\\n    /// @notice Called by governance to set the nToken token address and its reverse lookup. Cannot be\\n    /// reset once this is set.\\n    function setNTokenAddress(uint16 currencyId, address tokenAddress) internal {\\n        mapping(uint256 => address) storage addressStore = LibStorage.getNTokenAddressStorage();\\n        require(addressStore[currencyId] == address(0), \\\"PT: token address exists\\\");\\n\\n        mapping(address => nTokenContext) storage contextStore = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = contextStore[tokenAddress];\\n        require(context.currencyId == 0, \\\"PT: currency exists\\\");\\n\\n        // This will initialize all other context slots to zero\\n        context.currencyId = currencyId;\\n        addressStore[currencyId] = tokenAddress;\\n    }\\n\\n    /// @notice Set nToken token collateral parameters\\n    function setNTokenCollateralParameters(\\n        address tokenAddress,\\n        uint8 residualPurchaseIncentive10BPS,\\n        uint8 pvHaircutPercentage,\\n        uint8 residualPurchaseTimeBufferHours,\\n        uint8 cashWithholdingBuffer10BPS,\\n        uint8 liquidationHaircutPercentage,\\n        uint8 maxMintDeviation5BPS\\n    ) internal {\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n\\n        require(liquidationHaircutPercentage <= Constants.PERCENTAGE_DECIMALS, \\\"Invalid haircut\\\");\\n        // The pv haircut percentage must be less than the liquidation percentage or else liquidators will not\\n        // get profit for liquidating nToken.\\n        require(pvHaircutPercentage < liquidationHaircutPercentage, \\\"Invalid pv haircut\\\");\\n        // The mint deviation percentage cannot be greater than the difference between the liquidation haircut\\n        // percentage and the pv haircut percentage.\\n        require(\\n            maxMintDeviation5BPS * Constants.FIVE_BASIS_POINTS <= \\n            (liquidationHaircutPercentage - pvHaircutPercentage) * uint256(Constants.RATE_PRECISION) / uint256(Constants.PERCENTAGE_DECIMALS)\\n        );\\n        // Ensure that the cash withholding buffer is greater than the residual purchase incentive or\\n        // the nToken may not have enough cash to pay accounts to buy its negative ifCash\\n        require(residualPurchaseIncentive10BPS <= cashWithholdingBuffer10BPS, \\\"Invalid discounts\\\");\\n\\n        bytes6 parameters = (\\n            (bytes6(uint48(liquidationHaircutPercentage)) << 40) |\\n            (bytes6(uint48(cashWithholdingBuffer10BPS)) << 32) |\\n            (bytes6(uint48(residualPurchaseTimeBufferHours)) << 24) |\\n            (bytes6(uint48(pvHaircutPercentage)) << 16) |\\n            (bytes6(uint48(residualPurchaseIncentive10BPS)) << 8) |\\n            (bytes6(uint48(maxMintDeviation5BPS)))\\n        );\\n\\n        // Set the parameters\\n        context.nTokenParameters = parameters;\\n    }\\n\\n    /// @notice Sets a secondary rewarder contract on an nToken so that incentives can come from a different\\n    /// contract, aside from the native NOTE token incentives.\\n    function setSecondaryRewarder(\\n        uint16 currencyId,\\n        IRewarder rewarder\\n    ) internal {\\n        address tokenAddress = nTokenAddress(currencyId);\\n        // nToken must exist for a secondary rewarder\\n        require(tokenAddress != address(0));\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n\\n        // Setting the rewarder to address(0) will disable it. We use a context setting here so that\\n        // we can save a storage read before getting the rewarder\\n        context.hasSecondaryRewarder = (address(rewarder) != address(0));\\n        LibStorage.getSecondaryIncentiveRewarder()[tokenAddress] = rewarder;\\n    }\\n\\n    /// @notice Returns the secondary rewarder if it is set\\n    function getSecondaryRewarder(address tokenAddress) internal view returns (IRewarder) {\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n        \\n        if (context.hasSecondaryRewarder) {\\n            return LibStorage.getSecondaryIncentiveRewarder()[tokenAddress];\\n        } else {\\n            return IRewarder(address(0));\\n        }\\n    }\\n\\n    function setArrayLengthAndInitializedTime(\\n        address tokenAddress,\\n        uint8 arrayLength,\\n        uint256 lastInitializedTime\\n    ) internal {\\n        require(lastInitializedTime >= 0 && uint256(lastInitializedTime) < type(uint32).max); // dev: next settle time overflow\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n        context.lastInitializedTime = uint32(lastInitializedTime);\\n        context.assetArrayLength = arrayLength;\\n    }\\n\\n    /// @notice Returns the array of deposit shares and leverage thresholds for nTokens\\n    function getDepositParameters(uint256 currencyId, uint256 maxMarketIndex)\\n        internal\\n        view\\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds)\\n    {\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\n        (depositShares, leverageThresholds) = _getParameters(depositParameters, maxMarketIndex);\\n    }\\n\\n    /// @notice Sets the deposit parameters\\n    /// @dev We pack the values in alternating between the two parameters into either one or two\\n    // storage slots depending on the number of markets. This is to save storage reads when we use the parameters.\\n    function setDepositParameters(\\n        uint256 currencyId,\\n        uint32[] calldata depositShares,\\n        uint32[] calldata leverageThresholds\\n    ) internal {\\n        require(\\n            depositShares.length <= Constants.MAX_TRADED_MARKET_INDEX,\\n            \\\"PT: deposit share length\\\"\\n        );\\n        require(depositShares.length == leverageThresholds.length, \\\"PT: leverage share length\\\");\\n\\n        uint256 shareSum;\\n        for (uint256 i; i < depositShares.length; i++) {\\n            // This cannot overflow in uint 256 with 9 max slots\\n            shareSum = shareSum + depositShares[i];\\n            require(\\n                leverageThresholds[i] > 0 && leverageThresholds[i] < Constants.RATE_PRECISION,\\n                \\\"PT: leverage threshold\\\"\\n            );\\n        }\\n\\n        // Total deposit share must add up to 100%\\n        require(shareSum == uint256(Constants.DEPOSIT_PERCENT_BASIS), \\\"PT: deposit shares sum\\\");\\n\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenDepositStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage depositParameters = store[currencyId];\\n        _setParameters(depositParameters, depositShares, leverageThresholds);\\n    }\\n\\n    /// @notice Sets the initialization parameters for the markets, these are read only when markets\\n    /// are initialized\\n    function setInitializationParameters(\\n        uint256 currencyId,\\n        uint32[] calldata annualizedAnchorRates,\\n        uint32[] calldata proportions\\n    ) internal {\\n        require(annualizedAnchorRates.length <= Constants.MAX_TRADED_MARKET_INDEX, \\\"PT: annualized anchor rates length\\\");\\n        require(proportions.length == annualizedAnchorRates.length, \\\"PT: proportions length\\\");\\n\\n        for (uint256 i; i < proportions.length; i++) {\\n            // Anchor rates are no longer used and must always be set to zero\\n            require(annualizedAnchorRates[i] == 0);\\n            // Proportions must be between zero and the rate precision\\n            require(\\n                proportions[i] > 0 && proportions[i] < Constants.RATE_PRECISION,\\n                \\\"PT: invalid proportion\\\"\\n            );\\n        }\\n\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\n        _setParameters(initParameters, annualizedAnchorRates, proportions);\\n    }\\n\\n    /// @notice Returns the array of initialization parameters for a given currency.\\n    function getInitializationParameters(uint256 currencyId, uint256 maxMarketIndex)\\n        internal\\n        view\\n        returns (int256[] memory proportions)\\n    {\\n        mapping(uint256 => uint32[NUM_NTOKEN_MARKET_FACTORS]) storage store = LibStorage.getNTokenInitStorage();\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage initParameters = store[currencyId];\\n\\n        // NOTE: annualized anchor rates are deprecated as a result of the liquidity curve change\\n        (/* annualizedAnchorRates */, proportions) = _getParameters(initParameters, maxMarketIndex);\\n    }\\n\\n    function _getParameters(\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\n        uint256 maxMarketIndex\\n    ) private view returns (int256[] memory, int256[] memory) {\\n        uint256 index = 0;\\n        int256[] memory array1 = new int256[](maxMarketIndex);\\n        int256[] memory array2 = new int256[](maxMarketIndex);\\n        for (uint256 i; i < maxMarketIndex; i++) {\\n            array1[i] = slot[index];\\n            index++;\\n            array2[i] = slot[index];\\n            index++;\\n        }\\n\\n        return (array1, array2);\\n    }\\n\\n    function _setParameters(\\n        uint32[NUM_NTOKEN_MARKET_FACTORS] storage slot,\\n        uint32[] calldata array1,\\n        uint32[] calldata array2\\n    ) private {\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < array1.length; i++) {\\n            slot[index] = array1[i];\\n            index++;\\n\\n            slot[index] = array2[i];\\n            index++;\\n        }\\n    }\\n\\n    function loadNTokenPortfolioNoCashGroup(nTokenPortfolio memory nToken, uint16 currencyId)\\n        internal\\n        view\\n    {\\n        nToken.tokenAddress = nTokenAddress(currencyId);\\n        // prettier-ignore\\n        (\\n            /* currencyId */,\\n            /* incentiveRate */,\\n            uint256 lastInitializedTime,\\n            uint8 assetArrayLength,\\n            bytes6 parameters\\n        ) = getNTokenContext(nToken.tokenAddress);\\n\\n        // prettier-ignore\\n        (\\n            uint256 totalSupply,\\n            /* accumulatedNOTEPerNToken */,\\n            /* lastAccumulatedTime */\\n        ) = nTokenSupply.getStoredNTokenSupplyFactors(nToken.tokenAddress);\\n\\n        nToken.lastInitializedTime = lastInitializedTime;\\n        nToken.totalSupply = int256(totalSupply);\\n        nToken.parameters = parameters;\\n\\n        nToken.portfolioState = PortfolioHandler.buildPortfolioState(\\n            nToken.tokenAddress,\\n            assetArrayLength,\\n            0\\n        );\\n\\n        nToken.cashBalance = BalanceHandler.getPositiveCashBalance(nToken.tokenAddress, currencyId);\\n    }\\n\\n    /// @notice Uses buildCashGroupStateful\\n    function loadNTokenPortfolioStateful(nTokenPortfolio memory nToken, uint16 currencyId)\\n        internal\\n    {\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\n        nToken.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\n    }\\n\\n    /// @notice Uses buildCashGroupView\\n    function loadNTokenPortfolioView(nTokenPortfolio memory nToken, uint16 currencyId)\\n        internal\\n        view\\n    {\\n        loadNTokenPortfolioNoCashGroup(nToken, currencyId);\\n        nToken.cashGroup = CashGroup.buildCashGroupView(currencyId);\\n    }\\n\\n    /// @notice Returns the next settle time for the nToken which is 1 quarter away\\n    function getNextSettleTime(nTokenPortfolio memory nToken) internal pure returns (uint256) {\\n        if (nToken.lastInitializedTime == 0) return 0;\\n        return DateTime.getReferenceTime(nToken.lastInitializedTime) + Constants.QUARTER;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/internal/nToken/nTokenSupply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    nTokenTotalSupplyStorage,\\n    nTokenContext\\n} from \\\"../../global/Types.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {nTokenHandler} from \\\"./nTokenHandler.sol\\\";\\n\\nlibrary nTokenSupply {\\n    using SafeInt256 for int256;\\n    using SafeUint256 for uint256;\\n\\n    /// @notice Retrieves stored nToken supply and related factors. Do not use accumulatedNOTEPerNToken for calculating\\n    /// incentives! Use `getUpdatedAccumulatedNOTEPerNToken` instead.\\n    function getStoredNTokenSupplyFactors(address tokenAddress)\\n        internal\\n        view\\n        returns (\\n            uint256 totalSupply,\\n            uint256 accumulatedNOTEPerNToken,\\n            uint256 lastAccumulatedTime\\n        )\\n    {\\n        mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\n        nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\n        totalSupply = nTokenStorage.totalSupply;\\n        // NOTE: DO NOT USE THIS RETURNED VALUE FOR CALCULATING INCENTIVES. The accumulatedNOTEPerNToken\\n        // must be updated given the block time. Use `getUpdatedAccumulatedNOTEPerNToken` instead\\n        accumulatedNOTEPerNToken = nTokenStorage.accumulatedNOTEPerNToken;\\n        lastAccumulatedTime = nTokenStorage.lastAccumulatedTime;\\n    }\\n\\n    /// @notice Returns the updated accumulated NOTE per nToken for calculating incentives\\n    function getUpdatedAccumulatedNOTEPerNToken(address tokenAddress, uint256 blockTime)\\n        internal view\\n        returns (\\n            uint256 totalSupply,\\n            uint256 accumulatedNOTEPerNToken,\\n            uint256 lastAccumulatedTime\\n        )\\n    {\\n        (\\n            totalSupply,\\n            accumulatedNOTEPerNToken,\\n            lastAccumulatedTime\\n        ) = getStoredNTokenSupplyFactors(tokenAddress);\\n\\n        // nToken totalSupply is never allowed to drop to zero but we check this here to avoid\\n        // divide by zero errors during initialization. Also ensure that lastAccumulatedTime is not\\n        // zero to avoid a massive accumulation amount on initialization.\\n        if (blockTime > lastAccumulatedTime && lastAccumulatedTime > 0 && totalSupply > 0) {\\n            // prettier-ignore\\n            (\\n                /* currencyId */,\\n                uint256 emissionRatePerYear,\\n                /* initializedTime */,\\n                /* assetArrayLength */,\\n                /* parameters */\\n            ) = nTokenHandler.getNTokenContext(tokenAddress);\\n\\n            uint256 additionalNOTEAccumulatedPerNToken = _calculateAdditionalNOTE(\\n                // Emission rate is denominated in whole tokens, scale to 1e8 decimals here\\n                emissionRatePerYear.mul(uint256(Constants.INTERNAL_TOKEN_PRECISION)),\\n                // Time since last accumulation (overflow checked above)\\n                blockTime - lastAccumulatedTime,\\n                totalSupply\\n            );\\n\\n            accumulatedNOTEPerNToken = accumulatedNOTEPerNToken.add(additionalNOTEAccumulatedPerNToken);\\n            require(accumulatedNOTEPerNToken < type(uint128).max); // dev: accumulated NOTE overflow\\n        }\\n    }\\n\\n    /// @notice additionalNOTEPerNToken accumulated since last accumulation time in 1e18 precision\\n    function _calculateAdditionalNOTE(\\n        uint256 emissionRatePerYear,\\n        uint256 timeSinceLastAccumulation,\\n        uint256 totalSupply\\n    )\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        // If we use 18 decimal places as the accumulation precision then we will overflow uint128 when\\n        // a single nToken has accumulated 3.4 x 10^20 NOTE tokens. This isn't possible since the max\\n        // NOTE that can accumulate is 10^16 (100 million NOTE in 1e8 precision) so we should be safe\\n        // using 18 decimal places and uint128 storage slot\\n\\n        // timeSinceLastAccumulation (SECONDS)\\n        // accumulatedNOTEPerSharePrecision (1e18)\\n        // emissionRatePerYear (INTERNAL_TOKEN_PRECISION)\\n        // DIVIDE BY\\n        // YEAR (SECONDS)\\n        // totalSupply (INTERNAL_TOKEN_PRECISION)\\n        return timeSinceLastAccumulation\\n            .mul(Constants.INCENTIVE_ACCUMULATION_PRECISION)\\n            .mul(emissionRatePerYear)\\n            .div(Constants.YEAR)\\n            // totalSupply > 0 is checked in the calling function\\n            .div(totalSupply);\\n    }\\n\\n    /// @notice Updates the nToken token supply amount when minting or redeeming.\\n    /// @param tokenAddress address of the nToken\\n    /// @param netChange positive or negative change to the total nToken supply\\n    /// @param blockTime current block time\\n    /// @return accumulatedNOTEPerNToken updated to the given block time\\n    function changeNTokenSupply(\\n        address tokenAddress,\\n        int256 netChange,\\n        uint256 blockTime\\n    ) internal returns (uint256) {\\n        (\\n            uint256 totalSupply,\\n            uint256 accumulatedNOTEPerNToken,\\n            /* uint256 lastAccumulatedTime */\\n        ) = getUpdatedAccumulatedNOTEPerNToken(tokenAddress, blockTime);\\n\\n        // Update storage variables\\n        mapping(address => nTokenTotalSupplyStorage) storage store = LibStorage.getNTokenTotalSupplyStorage();\\n        nTokenTotalSupplyStorage storage nTokenStorage = store[tokenAddress];\\n\\n        int256 newTotalSupply = int256(totalSupply).add(netChange);\\n        // We allow newTotalSupply to equal zero here even though it is prevented from being redeemed down to\\n        // exactly zero by other internal logic inside nTokenRedeem. This is meant to be purely an overflow check.\\n        require(0 <= newTotalSupply && uint256(newTotalSupply) < type(uint96).max); // dev: nToken supply overflow\\n\\n        nTokenStorage.totalSupply = uint96(newTotalSupply);\\n        // NOTE: overflow checked inside getUpdatedAccumulatedNOTEPerNToken so that behavior here mirrors what\\n        // the user would see if querying the view function\\n        nTokenStorage.accumulatedNOTEPerNToken = uint128(accumulatedNOTEPerNToken);\\n\\n        require(blockTime < type(uint32).max); // dev: block time overflow\\n        nTokenStorage.lastAccumulatedTime = uint32(blockTime);\\n\\n        return accumulatedNOTEPerNToken;\\n    }\\n\\n    /// @notice Called by governance to set the new emission rate\\n    function setIncentiveEmissionRate(address tokenAddress, uint32 newEmissionsRate, uint256 blockTime) internal {\\n        // Ensure that the accumulatedNOTEPerNToken updates to the current block time before we update the\\n        // emission rate\\n        changeNTokenSupply(tokenAddress, 0, blockTime);\\n\\n        mapping(address => nTokenContext) storage store = LibStorage.getNTokenContextStorage();\\n        nTokenContext storage context = store[tokenAddress];\\n        context.incentiveAnnualEmissionRate = newEmissionsRate;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/internal/pCash/PrimeCashExchangeRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {\\n    PrimeCashHoldingsOracle,\\n    PrimeCashFactorsStorage,\\n    PrimeCashFactors,\\n    PrimeRate,\\n    InterestRateParameters,\\n    InterestRateCurveSettings,\\n    BalanceState,\\n    TotalfCashDebtStorage\\n} from \\\"../../global/Types.sol\\\";\\nimport {FloatingPoint} from \\\"../../math/FloatingPoint.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\n\\nimport {Emitter} from \\\"../Emitter.sol\\\";\\nimport {InterestRateCurve} from \\\"../markets/InterestRateCurve.sol\\\";\\nimport {TokenHandler} from \\\"../balances/TokenHandler.sol\\\";\\nimport {BalanceHandler} from \\\"../balances/BalanceHandler.sol\\\";\\n\\nimport {IPrimeCashHoldingsOracle} from \\\"../../../interfaces/notional/IPrimeCashHoldingsOracle.sol\\\";\\nimport {IERC20} from \\\"../../../interfaces/IERC20.sol\\\";\\n\\nlibrary PrimeCashExchangeRate {\\n    using SafeInt256 for int256;\\n    using SafeUint256 for uint256;\\n    using InterestRateCurve for InterestRateParameters;\\n\\n    event PrimeProxyDeployed(uint16 indexed currencyId, address proxy, bool isCashProxy);\\n\\n    /// @notice Emits every time interest is accrued\\n    event PrimeCashInterestAccrued(\\n        uint16 indexed currencyId,\\n        uint256 underlyingScalar,\\n        uint256 supplyScalar,\\n        uint256 debtScalar\\n    );\\n\\n    event PrimeCashCurveChanged(uint16 indexed currencyId);\\n\\n    event PrimeCashHoldingsOracleUpdated(uint16 indexed currencyId, address oracle);\\n\\n    /// @dev Reads prime cash factors from storage\\n    function getPrimeCashFactors(\\n        uint16 currencyId\\n    ) internal view returns (PrimeCashFactors memory p) {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        p.lastAccrueTime = s.lastAccrueTime;\\n        p.totalPrimeSupply = s.totalPrimeSupply;\\n        p.totalPrimeDebt = s.totalPrimeDebt;\\n        p.oracleSupplyRate = s.oracleSupplyRate;\\n        p.lastTotalUnderlyingValue = s.lastTotalUnderlyingValue;\\n        p.underlyingScalar = s.underlyingScalar;\\n        p.supplyScalar = s.supplyScalar;\\n        p.debtScalar = s.debtScalar;\\n        p.rateOracleTimeWindow = s.rateOracleTimeWindow5Min * 5 minutes;\\n    }\\n\\n    function setProxyAddress(uint16 currencyId, address proxy, bool isCashProxy) internal {\\n        mapping(uint256 => address) storage store = isCashProxy ?\\n            LibStorage.getPCashAddressStorage() : LibStorage.getPDebtAddressStorage();\\n\\n        // Cannot reset proxy address once set\\n        require(store[currencyId]== address(0)); // dev: proxy exists\\n        store[currencyId] = proxy;\\n\\n        emit PrimeProxyDeployed(currencyId, proxy, isCashProxy);\\n    }\\n\\n    function getCashProxyAddress(uint16 currencyId) internal view returns (address proxy) {\\n        proxy = LibStorage.getPCashAddressStorage()[currencyId];\\n    }\\n\\n    function getDebtProxyAddress(uint16 currencyId) internal view returns (address proxy) {\\n        proxy = LibStorage.getPDebtAddressStorage()[currencyId];\\n    }\\n\\n    function updatePrimeCashHoldingsOracle(\\n        uint16 currencyId,\\n        IPrimeCashHoldingsOracle oracle\\n    ) internal {\\n        // Set the prime cash holdings oracle first so that getTotalUnderlying will succeed\\n        PrimeCashHoldingsOracle storage s = LibStorage.getPrimeCashHoldingsOracle()[currencyId];\\n        s.oracle = oracle;\\n\\n        emit PrimeCashHoldingsOracleUpdated(currencyId, address(oracle));\\n    }\\n\\n    function getPrimeCashHoldingsOracle(uint16 currencyId) internal view returns (IPrimeCashHoldingsOracle) {\\n        PrimeCashHoldingsOracle storage s = LibStorage.getPrimeCashHoldingsOracle()[currencyId];\\n        return s.oracle;\\n    }\\n\\n    /// @notice Returns the total value in underlying internal precision held by the\\n    /// Notional contract across actual underlying balances and any external money\\n    /// market tokens held.\\n    /// @dev External oracles allow:\\n    ///    - injection of mock oracles while testing\\n    ///    - adding additional protocols without having to upgrade the entire system\\n    ///    - reduces expensive storage reads, oracles can store the holdings information\\n    ///      in immutable variables which are compiled into bytecode and do not require SLOAD calls\\n    /// NOTE: stateful version is required for CompoundV2's accrueInterest method.\\n    function getTotalUnderlyingStateful(uint16 currencyId) internal returns (uint256) {\\n        (/* */, uint256 internalPrecision) = getPrimeCashHoldingsOracle(currencyId)\\n            .getTotalUnderlyingValueStateful();\\n        return internalPrecision;\\n    }\\n\\n    function getTotalUnderlyingView(uint16 currencyId) internal view returns (uint256) {\\n        (/* */, uint256 internalPrecision) = getPrimeCashHoldingsOracle(currencyId)\\n            .getTotalUnderlyingValueView();\\n        return internalPrecision;\\n    }\\n\\n    /// @notice Only called once during listing currencies to initialize the token balance storage. After this\\n    /// point the token balance storage will only be updated based on the net changes before and after deposits,\\n    /// withdraws, and treasury rebalancing. This is done so that donations to the protocol will not affect the\\n    /// valuation of prime cash.\\n    function initTokenBalanceStorage(uint16 currencyId, IPrimeCashHoldingsOracle oracle) internal {\\n        address[] memory holdings = oracle.holdings();\\n        address underlying = oracle.underlying();\\n\\n        uint256 newBalance = currencyId == Constants.ETH_CURRENCY_ID ? \\n            address(this).balance :\\n            IERC20(underlying).balanceOf(address(this));\\n\\n        // prevBalanceOf is set to zero to ensure that this token balance has not been initialized yet\\n        TokenHandler.updateStoredTokenBalance(underlying, 0, newBalance);\\n\\n        for (uint256 i; i < holdings.length; i++) {\\n            newBalance = IERC20(holdings[i]).balanceOf(address(this));\\n            TokenHandler.updateStoredTokenBalance(holdings[i], 0, newBalance);\\n        }\\n    }\\n\\n    function initPrimeCashCurve(\\n        uint16 currencyId,\\n        uint88 totalPrimeSupply,\\n        InterestRateCurveSettings memory debtCurve,\\n        IPrimeCashHoldingsOracle oracle,\\n        bool allowDebt,\\n        uint8 rateOracleTimeWindow5Min\\n    ) internal {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        \\n        // Set the prime cash holdings oracle first so that getTotalUnderlying will succeed\\n        updatePrimeCashHoldingsOracle(currencyId, oracle);\\n\\n        // Cannot re-initialize after the first time\\n        require(s.lastAccrueTime == 0);\\n\\n        // Cannot initialize with zero supply balance or will be unable\\n        // to accrue the scalar the first time. Practically speaking, this\\n        // means that some dust amount of supply must be donated to the\\n        // reserve in order to initialize the prime cash market.\\n        require(0 < totalPrimeSupply);\\n\\n        // Total underlying also cannot be initialized at zero or the underlying\\n        // scalar will be unable to accrue.\\n        uint256 currentTotalUnderlying = getTotalUnderlyingStateful(currencyId);\\n        require(0 < currentTotalUnderlying);\\n\\n        s.lastAccrueTime = block.timestamp.toUint40();\\n        s.supplyScalar = uint80(Constants.SCALAR_PRECISION);\\n        s.debtScalar = uint80(Constants.SCALAR_PRECISION);\\n        s.totalPrimeSupply = totalPrimeSupply;\\n        s.allowDebt = allowDebt;\\n        s.rateOracleTimeWindow5Min = rateOracleTimeWindow5Min;\\n\\n        s.underlyingScalar = currentTotalUnderlying\\n            .divInScalarPrecision(totalPrimeSupply).toUint80();\\n        s.lastTotalUnderlyingValue = currentTotalUnderlying.toUint88();\\n\\n        // Total prime debt must be initialized at zero which implies an oracle supply\\n        // rate of zero (oracle supply rate here only applies to the prime cash supply).\\n        s.totalPrimeDebt = 0;\\n        s.oracleSupplyRate = 0;\\n\\n        InterestRateCurve.setPrimeCashInterestRateParameters(currencyId, debtCurve);\\n        emit PrimeCashCurveChanged(currencyId);\\n    }\\n\\n    function doesAllowPrimeDebt(uint16 currencyId) internal view returns (bool) {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        return s.allowDebt;\\n    }\\n\\n    /// @notice Turns on prime cash debt. Cannot be turned off once set to true.\\n    function allowPrimeDebt(uint16 currencyId) internal {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        s.allowDebt = true;\\n    }\\n\\n    function setRateOracleTimeWindow(uint16 currencyId, uint8 rateOracleTimeWindow5min) internal {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        s.rateOracleTimeWindow5Min = rateOracleTimeWindow5min;\\n    }\\n\\n    function setMaxUnderlyingSupply(\\n        uint16 currencyId,\\n        uint256 maxUnderlyingSupply,\\n        uint8 maxPrimeDebtUtilization\\n    ) internal returns (uint256 unpackedSupply) {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        s.maxUnderlyingSupply = FloatingPoint.packTo32Bits(maxUnderlyingSupply);\\n        unpackedSupply = FloatingPoint.unpackFromBits(uint256(s.maxUnderlyingSupply));\\n\\n        // This is set in percentage of the max underlying supply\\n        require(maxPrimeDebtUtilization <= Constants.PERCENTAGE_DECIMALS);\\n        s.maxPrimeDebtUtilization = maxPrimeDebtUtilization;\\n    }\\n\\n    /// @notice Updates prime cash interest rate curve after initialization,\\n    /// called via governance\\n    function updatePrimeCashCurve(\\n        uint16 currencyId,\\n        InterestRateCurveSettings memory debtCurve\\n    ) internal {\\n        // Ensure that rates are accrued up to the current block before we change the\\n        // interest rate curve.\\n        getPrimeCashRateStateful(currencyId, block.timestamp);\\n        InterestRateCurve.setPrimeCashInterestRateParameters(currencyId, debtCurve);\\n\\n        emit PrimeCashCurveChanged(currencyId);\\n    }\\n\\n    /// @notice Sets the prime cash scalars on every accrual\\n    function _setPrimeCashFactorsOnAccrue(\\n        uint16 currencyId,\\n        uint256 primeSupplyToReserve,\\n        PrimeCashFactors memory p\\n    ) private {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        s.lastAccrueTime = p.lastAccrueTime.toUint40();\\n        s.underlyingScalar = p.underlyingScalar.toUint80();\\n        s.supplyScalar = p.supplyScalar.toUint80();\\n        s.debtScalar = p.debtScalar.toUint80();\\n        // totalPrimeSupply already includes the primeSupplyToReserve\\n        s.totalPrimeSupply = p.totalPrimeSupply.toUint88();\\n        s.totalPrimeDebt = p.totalPrimeDebt.toUint88();\\n        s.lastTotalUnderlyingValue = p.lastTotalUnderlyingValue.toUint88();\\n        s.oracleSupplyRate = p.oracleSupplyRate.toUint32();\\n\\n        // Adds prime debt fees to the reserve\\n        if (primeSupplyToReserve > 0) {\\n            int256 primeSupply = primeSupplyToReserve.toInt();\\n            BalanceHandler.incrementFeeToReserve(currencyId, primeSupply);\\n            Emitter.emitMintOrBurnPrimeCash(Constants.FEE_RESERVE, currencyId, primeSupply);\\n        }\\n\\n        emit PrimeCashInterestAccrued(\\n            currencyId, p.underlyingScalar, p.supplyScalar, p.debtScalar\\n        );\\n    }\\n\\n    /// @notice Updates prime debt when borrowing occurs. Whenever borrowing occurs, prime\\n    /// supply also increases accordingly to mark that some lender in the system will now\\n    /// receive the accrued interest from the borrowing. This method will be called on two\\n    /// occasions:\\n    ///     - when a negative cash balance is stored outside of settlement \\n    ///     - when fCash balances are settled (at the global level)\\n    function updateTotalPrimeDebt(\\n        address account,\\n        uint16 currencyId,\\n        int256 netPrimeDebtChange,\\n        int256 netPrimeSupplyChange\\n    ) internal {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        // This must always be true or we cannot update cash balances.\\n        require(s.lastAccrueTime == block.timestamp);\\n\\n        // updateTotalPrimeDebt is only called in two scenarios:\\n        //  - when a negative cash balance is stored\\n        //  - when fCash settlement rates are set\\n        // Neither should be possible if allowDebt is false, fCash can only\\n        // be created once GovernanceAction.enableCashGroup is called and that\\n        // will trigger allowDebt to be set. allowDebt cannot be set to false once\\n        // it is set to true.\\n        require(s.allowDebt);\\n\\n        int256 newTotalPrimeDebt = int256(uint256(s.totalPrimeDebt))\\n            .add(netPrimeDebtChange);\\n        \\n        // When totalPrimeDebt increases, totalPrimeSupply will also increase, no underflow\\n        // to zero occurs. Utilization will not exceed 100% since both values increase at the\\n        // same rate.\\n\\n        // When totalPrimeDebt decreases, totalPrimeSupply will also decrease, but since\\n        // utilization is not allowed to exceed 100%, totalPrimeSupply will not go negative\\n        // here.\\n        int256 newTotalPrimeSupply = int256(uint256(s.totalPrimeSupply))\\n            .add(netPrimeSupplyChange);\\n\\n        // PrimeRateLib#convertToStorageValue subtracts 1 from the value therefore may cause uint\\n        // to underflow. Clears the negative dust balance back to zero.\\n        if (-10 < newTotalPrimeDebt && newTotalPrimeDebt < 0) newTotalPrimeDebt = 0;\\n        if (-10 < newTotalPrimeSupply && newTotalPrimeSupply < 0) newTotalPrimeSupply = 0;\\n\\n        s.totalPrimeDebt = newTotalPrimeDebt.toUint().toUint88();\\n        s.totalPrimeSupply = newTotalPrimeSupply.toUint().toUint88();\\n\\n        Emitter.emitBorrowOrRepayPrimeDebt(account, currencyId, netPrimeSupplyChange, netPrimeDebtChange);\\n        _checkInvariant(s);\\n    }\\n\\n    /// @notice Updates prime supply whenever tokens enter or exit the system.\\n    function updateTotalPrimeSupply(\\n        uint16 currencyId,\\n        int256 netPrimeSupplyChange,\\n        int256 netUnderlyingChange\\n    ) internal {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        // This must always be true or we cannot update cash balances.\\n        require(s.lastAccrueTime == block.timestamp);\\n        int256 newTotalPrimeSupply = int256(uint256(s.totalPrimeSupply))\\n            .add(netPrimeSupplyChange);\\n        int256 newLastTotalUnderlyingValue = int256(uint256(s.lastTotalUnderlyingValue))\\n            .add(netUnderlyingChange);\\n\\n        require(Constants.MIN_TOTAL_UNDERLYING_VALUE <= newLastTotalUnderlyingValue); // dev: min underlying\\n\\n        // lastTotalUnderlyingValue cannot be negative since we cannot hold a negative\\n        // balance, if that occurs then this will revert.\\n        s.lastTotalUnderlyingValue = newLastTotalUnderlyingValue.toUint().toUint88();\\n\\n        // On deposits, total prime supply will increase. On withdraws, total prime supply\\n        // will decrease. It cannot decrease below the total underlying tokens held (which\\n        // itself is floored at zero). If total underlying tokens held is zero, then either\\n        // there is no supply or the prime cash market is at 100% utilization.\\n        s.totalPrimeSupply = newTotalPrimeSupply.toUint().toUint88();\\n\\n        _checkInvariant(s);\\n    }\\n\\n    function _checkInvariant(PrimeCashFactorsStorage storage s) private view {\\n        int256 supply = int256(s.supplyScalar).mul(s.underlyingScalar).mul(s.totalPrimeSupply);\\n        int256 debt = int256(s.debtScalar).mul(s.underlyingScalar).mul(s.totalPrimeDebt);\\n        // Adding 1 here ensures that any balances below 1e36 that will round off will not cause\\n        // invariant failures.\\n        int256 underlying = int256(s.lastTotalUnderlyingValue + 1).mul(Constants.DOUBLE_SCALAR_PRECISION);\\n        require(supply.sub(debt) <= underlying); // dev: invariant failed\\n    }\\n\\n    function getTotalfCashDebtOutstanding(\\n        uint16 currencyId,\\n        uint256 maturity\\n    ) internal view returns (int256) {\\n        mapping(uint256 => mapping(uint256 => TotalfCashDebtStorage)) storage store = LibStorage.getTotalfCashDebtOutstanding();\\n        return -int256(store[currencyId][maturity].totalfCashDebt);\\n    }\\n\\n    function updateSettlementReserveForVaultsLendingAtZero(\\n        address vault,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 primeCashToReserve,\\n        int256 fCashToLend\\n    ) internal {\\n        mapping(uint256 => mapping(uint256 => TotalfCashDebtStorage)) storage store = LibStorage.getTotalfCashDebtOutstanding();\\n        TotalfCashDebtStorage storage s = store[currencyId][maturity];\\n\\n        // Increase both figures (fCashDebt held is positive in storage)\\n        s.fCashDebtHeldInSettlementReserve = fCashToLend.toUint()\\n            .add(s.fCashDebtHeldInSettlementReserve).toUint80();\\n        s.primeCashHeldInSettlementReserve = primeCashToReserve.toUint()\\n            .add(s.primeCashHeldInSettlementReserve).toUint80();\\n\\n        Emitter.emitTransferPrimeCash(vault, Constants.SETTLEMENT_RESERVE, currencyId, primeCashToReserve);\\n        // Minting fCash liquidity on the settlement reserve\\n        Emitter.emitChangefCashLiquidity(Constants.SETTLEMENT_RESERVE, currencyId, maturity, fCashToLend);\\n        // Positive fCash is transferred to the vault (the vault will burn it)\\n        Emitter.emitTransferfCash(Constants.SETTLEMENT_RESERVE, vault, currencyId, maturity, fCashToLend);\\n    }\\n\\n    function updateTotalfCashDebtOutstanding(\\n        address account,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 initialfCashAmount,\\n        int256 finalfCashAmount\\n    ) internal {\\n        int256 netDebtChange = initialfCashAmount.negChange(finalfCashAmount);\\n        if (netDebtChange == 0) return;\\n\\n        mapping(uint256 => mapping(uint256 => TotalfCashDebtStorage)) storage store = LibStorage.getTotalfCashDebtOutstanding();\\n        // No overflow due to storage size\\n        int256 totalDebt = -int256(store[currencyId][maturity].totalfCashDebt);\\n        // Total fCash Debt outstanding is negative, netDebtChange is a positive signed value\\n        // (i.e. netDebtChange > 0 is more debt, not less)\\n        int256 newTotalDebt = totalDebt.sub(netDebtChange);\\n        require(newTotalDebt <= 0);\\n        store[currencyId][maturity].totalfCashDebt = newTotalDebt.neg().toUint().toUint80();\\n\\n        // Throughout the entire Notional system, negative fCash is only created when\\n        // when an fCash pair is minted in this method. Negative fCash is never \\\"transferred\\\"\\n        // in the system, only positive side of the fCash tokens are bought and sold.\\n\\n        // When net debt changes, we emit a burn of fCash liquidity as the total debt in the\\n        // system has decreased.\\n\\n        // When fCash debt is created (netDebtChange increases) we must mint an fCash\\n        // pair to ensure that total positive fCash equals total negative fCash. This\\n        // occurs when minting nTokens, initializing new markets, and if an account\\n        // transfers fCash via ERC1155 to a negative balance (effectively an OTC market\\n        // making operation).\\n        Emitter.emitChangefCashLiquidity(account, currencyId, maturity, netDebtChange);\\n    }\\n\\n    function getPrimeInterestRates(\\n        uint16 currencyId,\\n        PrimeCashFactors memory factors\\n    ) internal view returns (\\n        uint256 annualDebtRatePreFee,\\n        uint256 annualDebtRatePostFee,\\n        uint256 annualSupplyRate\\n    ) {\\n        // Utilization is calculated in underlying terms:\\n        //  utilization = accruedDebtUnderlying / accruedSupplyUnderlying\\n        //  (totalDebt * underlyingScalar * debtScalar) / \\n        //      (totalSupply * underlyingScalar * supplyScalar)\\n        //\\n        // NOTE: underlyingScalar cancels out in both numerator and denominator\\n        uint256 utilization;\\n        if (factors.totalPrimeSupply > 0) {\\n            // Avoid divide by zero error, supplyScalar is monotonic and initialized to 1\\n            utilization = factors.totalPrimeDebt.mul(factors.debtScalar)\\n                .divInRatePrecision(factors.totalPrimeSupply.mul(factors.supplyScalar));\\n        }\\n        InterestRateParameters memory i = InterestRateCurve.getPrimeCashInterestRateParameters(currencyId);\\n        \\n        annualDebtRatePreFee = i.getInterestRate(utilization);\\n        // If utilization is zero, then the annualDebtRate will be zero (as defined in the\\n        // interest rate curve). If we get the post fee interest rate, then the annual debt\\n        // rate will show some small amount and cause the debt scalar to accrue.\\n        if (utilization > 0) {\\n            // Debt rates are always \\\"borrow\\\" and therefore increase the interest rate\\n            annualDebtRatePostFee = i.getPostFeeInterestRate(annualDebtRatePreFee, true);\\n        }\\n\\n        // Lenders receive the borrow interest accrued amortized over the total supply:\\n        // (annualDebtRatePreFee * totalUnderlyingDebt) / totalUnderlyingSupply,\\n        // this is effectively the utilization calculated above.\\n        if (factors.totalPrimeSupply > 0) {\\n            annualSupplyRate = annualDebtRatePreFee.mulInRatePrecision(utilization);\\n        }\\n    }\\n\\n    /// @notice If there are fees that accrue to the reserve due to a difference in the debt rate pre fee\\n    /// and the debt rate post fee, calculate the amount of prime supply that goes to the reserve here.\\n    /// The total prime supply to the reserve is the difference in the debt scalar pre and post fee applied\\n    /// to the total prime debt.\\n    function _getScalarIncrease(\\n        uint16 currencyId,\\n        uint256 blockTime,\\n        PrimeCashFactors memory prior\\n    ) private view returns (\\n        uint256 debtScalarWithFee,\\n        uint256 newSupplyScalar,\\n        uint256 primeSupplyToReserve,\\n        uint256 annualSupplyRate\\n    ) {\\n        uint256 annualDebtRatePreFee;\\n        uint256 annualDebtRatePostFee;\\n        (annualDebtRatePreFee, annualDebtRatePostFee, annualSupplyRate) = getPrimeInterestRates(currencyId, prior);\\n\\n        // Interest rates need to be scaled up to scalar precision, so we scale the time since last\\n        // accrue by RATE_PRECISION to save some calculations.\\n        // if lastAccrueTime > blockTime, will revert\\n        uint256 scaledTimeSinceLastAccrue = uint256(Constants.RATE_PRECISION)\\n            .mul(blockTime.sub(prior.lastAccrueTime));\\n\\n        debtScalarWithFee = prior.debtScalar.mulInScalarPrecision(\\n            Constants.SCALAR_PRECISION.add(\\n                // No division underflow\\n                annualDebtRatePostFee.mul(scaledTimeSinceLastAccrue) / Constants.YEAR\\n            )\\n        );\\n\\n        newSupplyScalar = prior.supplyScalar.mulInScalarPrecision(\\n            Constants.SCALAR_PRECISION.add(\\n                // No division underflow\\n                annualSupplyRate.mul(scaledTimeSinceLastAccrue) / Constants.YEAR\\n            )\\n        );\\n\\n        // If the debt rates are the same pre and post fee, then no prime supply will be sent to the reserve.\\n        if (annualDebtRatePreFee == annualDebtRatePostFee) {\\n            return (debtScalarWithFee, newSupplyScalar, 0, annualSupplyRate);\\n        }\\n\\n        // Calculate the increase in the debt scalar:\\n        // debtScalarIncrease = debtScalarWithFee - debtScalarWithoutFee\\n        uint256 debtScalarNoFee = prior.debtScalar.mulInScalarPrecision(\\n            Constants.SCALAR_PRECISION.add(\\n                // No division underflow\\n                annualDebtRatePreFee.mul(scaledTimeSinceLastAccrue) / Constants.YEAR\\n            )\\n        );\\n        uint256 debtScalarIncrease = debtScalarWithFee.sub(debtScalarNoFee);\\n        // Total prime debt paid to the reserve is:\\n        //  underlyingToReserve = totalPrimeDebt * debtScalarIncrease * underlyingScalar / SCALAR_PRECISION^2\\n        //  primeSupplyToReserve = (underlyingToReserve * SCALAR_PRECISION^2) / (supplyScalar * underlyingScalar)\\n        //\\n        //  Combining and cancelling terms results in:\\n        //  primeSupplyToReserve = (totalPrimeDebt * debtScalarIncrease) / supplyScalar\\n        primeSupplyToReserve = prior.totalPrimeDebt.mul(debtScalarIncrease).div(newSupplyScalar);\\n    }\\n\\n    /// @notice Accrues interest to the prime cash supply scalar and debt scalar\\n    /// up to the current block time.\\n    /// @return PrimeCashFactors prime cash factors accrued up to current time\\n    /// @return uint256 prime supply to the reserve\\n    function _updatePrimeCashScalars(\\n        uint16 currencyId,\\n        PrimeCashFactors memory prior,\\n        uint256 currentUnderlyingValue,\\n        uint256 blockTime\\n    ) private view returns (PrimeCashFactors memory, uint256) {\\n        uint256 primeSupplyToReserve;\\n        uint256 annualSupplyRate;\\n        (\\n            prior.debtScalar,\\n            prior.supplyScalar,\\n            primeSupplyToReserve,\\n            annualSupplyRate\\n        ) = _getScalarIncrease(currencyId, blockTime, prior);\\n\\n        // Prime supply is added in memory here. In getPrimeCashStateful, the actual storage values\\n        // will increase as well.\\n        prior.totalPrimeSupply = prior.totalPrimeSupply.add(primeSupplyToReserve);\\n\\n        // Accrue the underlyingScalar, which represents interest earned via\\n        // external money market protocols.\\n        {\\n            // NOTE: this subtract reverts if this is negative. This is possible in two conditions:\\n            //  - the underlying value was not properly updated on the last exit\\n            //  - there is a misreporting in an external protocol, either due to logic error\\n            //    or some incident that requires a haircut to lenders\\n            uint256 underlyingInterestRate;\\n\\n            if (prior.lastTotalUnderlyingValue > 0) {\\n                // If lastTotalUnderlyingValue == 0 (meaning we have no tokens held), then the\\n                // underlying interest rate is exactly zero and we avoid a divide by zero error.\\n                underlyingInterestRate = currentUnderlyingValue.sub(prior.lastTotalUnderlyingValue)\\n                    .divInScalarPrecision(prior.lastTotalUnderlyingValue);\\n            }\\n\\n            prior.underlyingScalar = prior.underlyingScalar\\n                .mulInScalarPrecision(Constants.SCALAR_PRECISION.add(underlyingInterestRate));\\n            prior.lastTotalUnderlyingValue = currentUnderlyingValue;\\n        }\\n\\n        // Update the last accrue time\\n        prior.lastAccrueTime = blockTime;\\n\\n        return (prior, primeSupplyToReserve);\\n    }\\n\\n    /// @notice Gets current prime cash exchange rates without setting anything\\n    /// in storage. Should ONLY be used for off-chain interaction.\\n    function getPrimeCashRateView(\\n        uint16 currencyId,\\n        uint256 blockTime\\n    ) internal view returns (PrimeRate memory rate, PrimeCashFactors memory factors) {\\n        factors = getPrimeCashFactors(currencyId);\\n\\n        // Only accrue if the block time has increased\\n        if (factors.lastAccrueTime < blockTime) {\\n            uint256 currentUnderlyingValue = getTotalUnderlyingView(currencyId);\\n            (factors, /* primeSupplyToReserve */) = _updatePrimeCashScalars(\\n                currencyId, factors, currentUnderlyingValue, blockTime\\n            );\\n        } else {\\n            require(factors.lastAccrueTime == blockTime); // dev: revert invalid blocktime\\n        }\\n\\n        rate = PrimeRate({\\n            supplyFactor: factors.supplyScalar.mul(factors.underlyingScalar).toInt(),\\n            debtFactor: factors.debtScalar.mul(factors.underlyingScalar).toInt(),\\n            oracleSupplyRate: factors.oracleSupplyRate\\n        });\\n    }\\n\\n    /// @notice Gets current prime cash exchange rates and writes to storage.\\n    function getPrimeCashRateStateful(\\n        uint16 currencyId,\\n        uint256 blockTime\\n    ) internal returns (PrimeRate memory rate) {\\n        PrimeCashFactors memory factors = getPrimeCashFactors(currencyId);\\n\\n        // Only accrue if the block time has increased\\n        if (factors.lastAccrueTime < blockTime) {\\n            uint256 primeSupplyToReserve;\\n            uint256 currentUnderlyingValue = getTotalUnderlyingStateful(currencyId);\\n            (factors, primeSupplyToReserve) = _updatePrimeCashScalars(\\n                currencyId, factors, currentUnderlyingValue, blockTime\\n            );\\n            _setPrimeCashFactorsOnAccrue(currencyId, primeSupplyToReserve, factors);\\n        } else {\\n            require(factors.lastAccrueTime == blockTime); // dev: revert invalid blocktime\\n        }\\n\\n        rate = PrimeRate({\\n            supplyFactor: factors.supplyScalar.mul(factors.underlyingScalar).toInt(),\\n            debtFactor: factors.debtScalar.mul(factors.underlyingScalar).toInt(),\\n            oracleSupplyRate: factors.oracleSupplyRate\\n        });\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/pCash/PrimeRateLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    PrimeRate,\\n    PrimeCashFactors,\\n    PrimeCashFactorsStorage,\\n    PrimeSettlementRateStorage,\\n    MarketParameters,\\n    TotalfCashDebtStorage\\n} from \\\"../../global/Types.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {Deployments} from \\\"../../global/Deployments.sol\\\";\\n\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\n\\nimport {Emitter} from \\\"../Emitter.sol\\\";\\nimport {BalanceHandler} from \\\"../balances/BalanceHandler.sol\\\";\\nimport {nTokenHandler} from \\\"../nToken/nTokenHandler.sol\\\";\\nimport {PrimeCashExchangeRate} from \\\"./PrimeCashExchangeRate.sol\\\";\\nimport {Market} from \\\"../markets/Market.sol\\\";\\n\\nlibrary PrimeRateLib {\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n    using Market for MarketParameters;\\n\\n    /// @notice Emitted when a settlement rate is set\\n    event SetPrimeSettlementRate(\\n        uint256 indexed currencyId,\\n        uint256 indexed maturity,\\n        int256 supplyFactor,\\n        int256 debtFactor\\n    );\\n\\n    /// Prime cash balances are stored differently than they are used on the stack\\n    /// and in memory. On the stack, all prime cash balances (positive and negative) are fungible\\n    /// with each other and denominated in prime cash supply terms. In storage, negative prime cash\\n    /// (i.e. prime cash debt) is is stored in different terms so that it can properly accrue interest\\n    /// over time. In other words, positive prime cash balances are static (non-rebasing), but negative\\n    /// prime cash balances are monotonically increasing (i.e. rebasing) over time. This is because a\\n    /// negative prime cash balance represents an ever increasing amount of positive prime cash owed.\\n    ///\\n    /// Math is as follows:\\n    ///   positivePrimeSupply * supplyFactor = underlying\\n    ///   negativePrimeDebt * debtFactor = underlying\\n    ///\\n    /// Setting them equal:\\n    ///   positivePrimeSupply * supplyFactor = negativePrimeDebt * debtFactor\\n    ///\\n    ///   positivePrimeSupply = (negativePrimeDebt * debtFactor) / supplyFactor\\n    ///   negativePrimeDebt = (positivePrimeSupply * supplyFactor) / debtFactor\\n    \\n    /// @notice Converts stored cash balance into a signed value in prime supply\\n    /// terms (see comment above)\\n    function convertFromStorage(\\n        PrimeRate memory pr,\\n        int256 storedCashBalance\\n    ) internal pure returns (int256 signedPrimeSupplyValue) {\\n        if (storedCashBalance >= 0) {\\n            return storedCashBalance;\\n        } else {\\n            // Convert negative stored cash balance to signed prime supply value\\n            // signedPrimeSupply = (negativePrimeDebt * debtFactor) / supplyFactor\\n\\n            // cashBalance is stored as int88, debt factor is uint80 * uint80 so there\\n            // is no chance of phantom overflow (88 + 80 + 80 = 248) on mul\\n            return storedCashBalance.mul(pr.debtFactor).div(pr.supplyFactor);\\n        }\\n    }\\n\\n    function convertSettledfCashView(\\n        PrimeRate memory presentPrimeRate,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 fCashBalance,\\n        uint256 blockTime\\n    ) internal view returns (int256 signedPrimeSupplyValue) {\\n        PrimeRate memory settledPrimeRate = buildPrimeRateSettlementView(currencyId, maturity, blockTime);\\n        (signedPrimeSupplyValue, /* */) = _convertSettledfCash(presentPrimeRate, settledPrimeRate, fCashBalance);\\n    }\\n\\n    function convertSettledfCashInVault(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 fCashBalance,\\n        address vault\\n    ) internal returns (int256 settledPrimeStorageValue) {\\n        (PrimeRate memory settledPrimeRate, bool isSet) = _getPrimeSettlementRate(currencyId, maturity);\\n        // Requires that the vault has a settlement rate set first. This means that markets have been\\n        // initialized already. Vaults cannot have idiosyncratic borrow dates so relying on market initialization\\n        // is safe.\\n        require(isSet); // dev: settlement rate unset\\n\\n        // This is exactly how much prime debt the vault owes at settlement.\\n        settledPrimeStorageValue = convertUnderlyingToDebtStorage(settledPrimeRate, fCashBalance);\\n\\n        // Only emit the settle fcash event for the vault, not individual accounts\\n        if (vault != address(0)) {\\n            Emitter.emitSettlefCash(\\n                vault, currencyId, maturity, fCashBalance, settledPrimeStorageValue\\n            );\\n        }\\n    }\\n\\n    /// @notice Converts settled fCash to the current signed prime supply value\\n    function convertSettledfCash(\\n        PrimeRate memory presentPrimeRate,\\n        address account,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 fCashBalance,\\n        uint256 blockTime\\n    ) internal returns (int256 signedPrimeSupplyValue) {\\n        PrimeRate memory settledPrimeRate = buildPrimeRateSettlementStateful(currencyId, maturity, blockTime);\\n\\n        int256 settledPrimeStorageValue;\\n        (signedPrimeSupplyValue, settledPrimeStorageValue) = _convertSettledfCash(\\n            presentPrimeRate, settledPrimeRate, fCashBalance\\n        );\\n\\n        // Allows vault accounts to suppress this event because it is not relevant to them\\n        if (account != address(0)) {\\n            Emitter.emitSettlefCash(\\n                account, currencyId, maturity, fCashBalance, settledPrimeStorageValue\\n            );\\n        }\\n    }\\n\\n    /// @notice Converts an fCash balance to a signed prime supply value.\\n    /// @return signedPrimeSupplyValue the current (signed) prime cash value of the fCash \\n    /// @return settledPrimeStorageValue the storage value of the fCash at settlement, used for\\n    /// emitting events only\\n    function _convertSettledfCash(\\n        PrimeRate memory presentPrimeRate,\\n        PrimeRate memory settledPrimeRate,\\n        int256 fCashBalance\\n    ) private pure returns (int256 signedPrimeSupplyValue, int256 settledPrimeStorageValue) {\\n        // These values are valid at the time of settlement.\\n        signedPrimeSupplyValue = convertFromUnderlying(settledPrimeRate, fCashBalance);\\n        settledPrimeStorageValue = convertToStorageValue(settledPrimeRate, signedPrimeSupplyValue);\\n\\n        // If the signed prime supply value is negative, we need to accrue interest on the\\n        // debt up to the present from the settled prime rate. This simulates storing the\\n        // the debt, reading the debt from storage and then accruing interest up to the\\n        // current time. This is only required for debt values.\\n        // debtSharesAtSettlement = signedPrimeSupplyValue * settled.supplyFactor / settled.debtFactor\\n        // currentSignedPrimeSupplyValue = debtSharesAtSettlement * present.debtFactor / present.supplyFactor\\n        if (signedPrimeSupplyValue < 0) {\\n            // Divide between multiplication actions to protect against a phantom overflow at 256 due\\n            // to the two mul in the numerator.\\n            signedPrimeSupplyValue = signedPrimeSupplyValue\\n                .mul(settledPrimeRate.supplyFactor)\\n                .div(settledPrimeRate.debtFactor)\\n                .mul(presentPrimeRate.debtFactor)\\n                .div(presentPrimeRate.supplyFactor)\\n                // subtract one to protect protocol against rounding errors in division operations\\n                .sub(1);\\n        }\\n    }\\n\\n    function convertToStorageValue(\\n        PrimeRate memory pr,\\n        int256 signedPrimeSupplyValueToStore\\n    ) internal pure returns (int256 newStoredCashBalance) {\\n        newStoredCashBalance = signedPrimeSupplyValueToStore >= 0 ?\\n            signedPrimeSupplyValueToStore :\\n            // negativePrimeDebt = (signedPrimeSupply * supplyFactor) / debtFactor\\n            // subtract one to increase debt and protect protocol against rounding errors\\n            signedPrimeSupplyValueToStore.mul(pr.supplyFactor).div(pr.debtFactor).sub(1);\\n    }\\n\\n    /// @notice Updates total prime debt during settlement if debts are repaid by cash\\n    /// balances.\\n    /// @param pr current prime rate\\n    /// @param currencyId currency id this prime rate refers to\\n    /// @param previousSignedCashBalance the previous signed supply value of the stored cash balance\\n    /// @param positiveSettledCash amount of positive cash balances that have settled\\n    /// @param negativeSettledCash amount of negative cash balances that have settled\\n    function convertToStorageInSettlement(\\n        PrimeRate memory pr,\\n        address account,\\n        uint16 currencyId,\\n        int256 previousSignedCashBalance,\\n        int256 positiveSettledCash,\\n        int256 negativeSettledCash\\n    ) internal returns (int256 newStoredCashBalance) {\\n        // The new cash balance is the sum of all the balances converted to a proper storage value\\n        int256 endSignedBalance = previousSignedCashBalance.add(positiveSettledCash).add(negativeSettledCash);\\n        newStoredCashBalance = convertToStorageValue(pr, endSignedBalance);\\n\\n        // At settlement, the total prime debt outstanding is increased by the total fCash debt\\n        // outstanding figure in `_settleTotalfCashDebts`. This figure, however, is not aware of\\n        // individual accounts that have sufficient cash (or matured fCash) to repay a settled debt.\\n        // An example of the scenario would be an account with:\\n        //      +100 units of ETH cash balance, -50 units of matured fETH\\n        //\\n        // At settlement the total ETH debt outstanding is set to -50 ETH, causing an increase in\\n        // prime cash utilization and an increase to the prime cash debt rate. If this account settled\\n        // exactly at maturity, they would have +50 units of ETH cash balance and have accrued zero\\n        // additional variable rate debt. However, since the the smart contract is not made aware of this\\n        // without an explicit settlement transaction, it will continue to accrue interest to prime cash\\n        // suppliers (meaning that this account is paying variable interest on its -50 units of matured\\n        // fETH until it actually issues a settlement transaction).\\n        //\\n        // The effect of this is that the account will be paying the spread between the prime cash supply\\n        // interest rate and the prime debt interest rate for the period where it is not settled. If the\\n        // account remains un-settled for long enough, it will slowly creep into insolvency (i.e. once the\\n        // debt is greater than the cash, the account is insolvent). However, settlement transactions are\\n        // permission-less and only require the payment of a minor gas cost so anyone can settle an account\\n        // to stop the accrual of the variable rate debt and prevent an insolvency.\\n        //\\n        // The variable debt accrued by this account up to present time must be paid and is calculated\\n        // in `_convertSettledfCash`. The logic below will detect the netPrimeDebtChange based on the\\n        // cash balances and settled amounts and properly update the total prime debt figure accordingly.\\n\\n        // Only need to update total prime debt when there is a debt repayment via existing cash balances\\n        // or positive settled cash. In all other cases, settled prime debt or existing prime debt are\\n        // already captured by the total prime debt figure.\\n        require(0 <= positiveSettledCash);\\n        require(negativeSettledCash <= 0);\\n\\n        if (0 < previousSignedCashBalance) {\\n            positiveSettledCash = previousSignedCashBalance.add(positiveSettledCash);\\n        } else {\\n            negativeSettledCash = previousSignedCashBalance.add(negativeSettledCash);\\n        }\\n\\n        int256 netPrimeSupplyChange;\\n        if (negativeSettledCash.neg() < positiveSettledCash) {\\n            // All of the negative settled cash is repaid\\n            netPrimeSupplyChange = negativeSettledCash;\\n        } else {\\n            // Positive cash portion of the debt is repaid\\n            netPrimeSupplyChange = positiveSettledCash.neg();\\n        }\\n\\n        // netPrimeSupplyChange should always be negative or zero at this point\\n        if (netPrimeSupplyChange < 0) {\\n            int256 netPrimeDebtChange = netPrimeSupplyChange.mul(pr.supplyFactor).div(pr.debtFactor);\\n\\n            PrimeCashExchangeRate.updateTotalPrimeDebt(\\n                account,\\n                currencyId,\\n                netPrimeDebtChange,\\n                netPrimeSupplyChange\\n            );\\n        }\\n    }\\n\\n    /// @notice Converts signed prime supply value into a stored prime cash balance\\n    /// value, converting negative prime supply values into prime debt values if required.\\n    /// Also, updates totalPrimeDebt based on the net change in storage values. Should not\\n    /// be called during settlement.\\n    function convertToStorageNonSettlementNonVault(\\n        PrimeRate memory pr,\\n        address account,\\n        uint16 currencyId,\\n        int256 previousStoredCashBalance,\\n        int256 signedPrimeSupplyValueToStore\\n    ) internal returns (int256 newStoredCashBalance) {\\n        newStoredCashBalance = convertToStorageValue(pr, signedPrimeSupplyValueToStore);\\n        updateTotalPrimeDebt(\\n            pr,\\n            account,\\n            currencyId,\\n            // This will return 0 if both cash balances are positive.\\n            previousStoredCashBalance.negChange(newStoredCashBalance)\\n        );\\n    }\\n\\n    /// @notice Updates totalPrimeDebt given the change to the stored cash balance\\n    function updateTotalPrimeDebt(\\n        PrimeRate memory pr,\\n        address account,\\n        uint16 currencyId,\\n        int256 netPrimeDebtChange\\n    ) internal {\\n        if (netPrimeDebtChange != 0) {\\n            // Whenever prime debt changes, prime supply must also change to the same degree in\\n            // its own denomination. This marks the position of some lender in the system who\\n            // will receive the repayment of the debt change.\\n            // NOTE: total prime supply will also change when tokens enter or exit the system.\\n            int256 netPrimeSupplyChange = netPrimeDebtChange.mul(pr.debtFactor).div(pr.supplyFactor);\\n\\n            PrimeCashExchangeRate.updateTotalPrimeDebt(\\n                account,\\n                currencyId,\\n                netPrimeDebtChange,\\n                netPrimeSupplyChange\\n            );\\n        }\\n    }\\n\\n    /// @notice Converts a prime cash balance to underlying (both in internal 8\\n    /// decimal precision).\\n    function convertToUnderlying(\\n        PrimeRate memory pr,\\n        int256 primeCashBalance\\n    ) internal pure returns (int256) {\\n        int256 result = primeCashBalance.mul(pr.supplyFactor).div(Constants.DOUBLE_SCALAR_PRECISION);\\n        return primeCashBalance < 0 ? SafeInt256.min(result, -1) : result;\\n    }\\n\\n    /// @notice Converts underlying to a prime cash balance (both in internal 8\\n    /// decimal precision).\\n    function convertFromUnderlying(\\n        PrimeRate memory pr,\\n        int256 underlyingBalance\\n    ) internal pure returns (int256) {\\n        int256 result = underlyingBalance.mul(Constants.DOUBLE_SCALAR_PRECISION).div(pr.supplyFactor);\\n        return underlyingBalance < 0 ? SafeInt256.min(result, -1) : result;\\n    }\\n\\n    function convertDebtStorageToUnderlying(\\n        PrimeRate memory pr,\\n        int256 debtStorage\\n    ) internal pure returns (int256) {\\n        // debtStorage must be negative\\n        require(debtStorage < 1);\\n        if (debtStorage == 0) return 0;\\n\\n        return debtStorage.mul(pr.debtFactor).div(Constants.DOUBLE_SCALAR_PRECISION).sub(1);\\n    }\\n\\n    function convertUnderlyingToDebtStorage(\\n        PrimeRate memory pr,\\n        int256 underlying\\n    ) internal pure returns (int256) {\\n        // Floor dust balances at zero to prevent the following require check from reverting\\n        if (0 <= underlying && underlying < 10) return 0;\\n        require(underlying < 0);\\n        // underlying debt is specified as a negative number and therefore subtract\\n        // one to protect the protocol against rounding errors\\n        return underlying.mul(Constants.DOUBLE_SCALAR_PRECISION).div(pr.debtFactor).sub(1);\\n    }\\n    \\n    /// @notice Returns a prime rate object accrued up to the current time and updates\\n    /// values in storage.\\n    function buildPrimeRateStateful(\\n        uint16 currencyId\\n    ) internal returns (PrimeRate memory) {\\n        return PrimeCashExchangeRate.getPrimeCashRateStateful(currencyId, block.timestamp);\\n    }\\n\\n    /// @notice Returns a prime rate object for settlement at a particular maturity\\n    function buildPrimeRateSettlementView(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal view returns (PrimeRate memory pr) {\\n        bool isSet;\\n        (pr, isSet) = _getPrimeSettlementRate(currencyId, maturity);\\n        \\n        if (!isSet) {\\n            // Return the current cash rate if settlement rate not found\\n            (pr, /* */) = PrimeCashExchangeRate.getPrimeCashRateView(currencyId, blockTime);\\n        }\\n    }\\n\\n    /// @notice Returns a prime rate object for settlement at a particular maturity,\\n    /// and sets both accrued values and the settlement rate (if not set already).\\n    function buildPrimeRateSettlementStateful(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal returns (PrimeRate memory pr) {\\n        bool isSet;\\n        (pr, isSet) = _getPrimeSettlementRate(currencyId, maturity);\\n\\n        if (!isSet) {\\n            pr = _setPrimeSettlementRate(currencyId, maturity, blockTime);\\n        }\\n    }\\n\\n    /// @notice Loads the settlement rate from storage or uses the current rate if it\\n    /// has not yet been set.\\n    function _getPrimeSettlementRate(\\n        uint16 currencyId,\\n        uint256 maturity\\n    ) private view returns (PrimeRate memory pr, bool isSet) {\\n        mapping(uint256 => mapping(uint256 =>\\n            PrimeSettlementRateStorage)) storage store = LibStorage.getPrimeSettlementRates();\\n        PrimeSettlementRateStorage storage rateStorage = store[currencyId][maturity];\\n        isSet = rateStorage.isSet;\\n\\n        // If the settlement rate is not set, then this method will return zeros\\n        if (isSet) {\\n            uint256 underlyingScalar = rateStorage.underlyingScalar;\\n            pr.supplyFactor = int256(uint256(rateStorage.supplyScalar).mul(underlyingScalar));\\n            pr.debtFactor = int256(uint256(rateStorage.debtScalar).mul(underlyingScalar));\\n        }\\n    }\\n\\n    function _setPrimeSettlementRate(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) private returns (PrimeRate memory pr) {\\n        // Accrues prime rates up to current time and sets them\\n        pr = PrimeCashExchangeRate.getPrimeCashRateStateful(currencyId, blockTime);\\n        // These are the accrued factors\\n        PrimeCashFactors memory factors = PrimeCashExchangeRate.getPrimeCashFactors(currencyId);\\n\\n        mapping(uint256 => mapping(uint256 =>\\n            PrimeSettlementRateStorage)) storage store = LibStorage.getPrimeSettlementRates();\\n        PrimeSettlementRateStorage storage rateStorage = store[currencyId][maturity];\\n\\n        require(Deployments.NOTIONAL_V2_FINAL_SETTLEMENT < maturity); // dev: final settlement\\n        require(factors.lastAccrueTime == blockTime); // dev: did not accrue\\n        require(0 < blockTime); // dev: zero block time\\n        require(maturity <= blockTime); // dev: settlement rate timestamp\\n        require(0 < pr.supplyFactor); // dev: settlement rate zero\\n        require(0 < pr.debtFactor); // dev: settlement rate zero\\n\\n        rateStorage.underlyingScalar = factors.underlyingScalar.toUint80();\\n        rateStorage.supplyScalar = factors.supplyScalar.toUint80();\\n        rateStorage.debtScalar = factors.debtScalar.toUint80();\\n        rateStorage.isSet = true;\\n\\n        _settleTotalfCashDebts(currencyId, maturity, pr);\\n\\n        emit SetPrimeSettlementRate(\\n            currencyId,\\n            maturity,\\n            pr.supplyFactor,\\n            pr.debtFactor\\n        );\\n    }\\n\\n    function _settleTotalfCashDebts(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        PrimeRate memory settlementRate\\n    ) private {\\n        mapping(uint256 => mapping(uint256 => TotalfCashDebtStorage)) storage store = LibStorage.getTotalfCashDebtOutstanding();\\n        TotalfCashDebtStorage storage s = store[currencyId][maturity];\\n        int256 totalDebt = -int256(s.totalfCashDebt);\\n        \\n        // The nToken must be settled first via InitializeMarkets if there is any liquidity\\n        // in the matching market (if one exists).\\n        MarketParameters memory market;\\n        market.loadSettlementMarket(currencyId, maturity, maturity);\\n        require(market.totalLiquidity == 0, \\\"Must init markets\\\");\\n\\n        // totalDebt is negative, but netPrimeSupplyChange and netPrimeDebtChange must both be positive\\n        // since we are increasing the total debt load.\\n        int256 netPrimeSupplyChange = convertFromUnderlying(settlementRate, totalDebt.neg());\\n        int256 netPrimeDebtChange = convertUnderlyingToDebtStorage(settlementRate, totalDebt).neg();\\n\\n        // The settlement reserve will receive all of the prime debt initially and each account\\n        // will receive prime cash or prime debt as they settle individually.\\n        PrimeCashExchangeRate.updateTotalPrimeDebt(\\n            Constants.SETTLEMENT_RESERVE, currencyId, netPrimeDebtChange, netPrimeSupplyChange\\n        );\\n\\n        // This is purely done to fully reconcile off chain accounting with the edge condition where\\n        // leveraged vaults lend at zero interest. In this code block, no prime debt is created or\\n        // destroyed (the totalfCashDebt figure above does not include fCashDebt held in settlement\\n        // reserve). Only prime cash held in reserve is burned to repay the settled debt. Excess cash\\n        // is sent to the fee reserve.\\n        int256 fCashDebtInReserve = -int256(s.fCashDebtHeldInSettlementReserve);\\n        int256 primeCashInReserve = int256(s.primeCashHeldInSettlementReserve);\\n        if (fCashDebtInReserve < 0 || 0 < primeCashInReserve) {\\n            int256 settledDebtInPrimeCash = convertFromUnderlying(settlementRate, fCashDebtInReserve);\\n            // 0 < primeCashInReserve 0 and settledDebtInPrimeCash < 0\\n            int256 excessCash = primeCashInReserve.add(settledDebtInPrimeCash);\\n            if (0 < excessCash) {\\n                BalanceHandler.incrementFeeToReserve(currencyId, excessCash);\\n            } \\n\\n            Emitter.emitSettlefCashDebtInReserve(\\n                currencyId, maturity, fCashDebtInReserve, settledDebtInPrimeCash, excessCash\\n            );\\n        }\\n\\n        // Clear the storage slot, no longer needed\\n        delete store[currencyId][maturity];\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/pCash/PrimeSupplyCap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {PrimeRate, PrimeCashFactorsStorage} from \\\"../../global/Types.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {PrimeRateLib} from \\\"./PrimeRateLib.sol\\\";\\n\\nimport {FloatingPoint} from \\\"../../math/FloatingPoint.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\n\\nlibrary PrimeSupplyCap {\\n    using PrimeRateLib for PrimeRate;\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n\\n    /// @notice Checks whether or not a currency has exceeded its total prime supply cap. Used to\\n    /// prevent some listed currencies to be used as collateral above a threshold where liquidations\\n    /// can be safely done on chain.\\n    /// @dev Called during deposits in AccountAction and BatchAction. Supply caps are not checked\\n    /// during settlement, liquidation and withdraws.\\n    function checkSupplyCap(PrimeRate memory pr, uint16 currencyId) internal view {\\n        (\\n            uint256 maxUnderlyingSupply,\\n            uint256 totalUnderlyingSupply,\\n            /* */, /* */\\n        ) = getSupplyCap(pr, currencyId);\\n        if (maxUnderlyingSupply == 0) return;\\n\\n        require(totalUnderlyingSupply <= maxUnderlyingSupply, \\\"Over Supply Cap\\\");\\n    }\\n\\n    function checkDebtCap(PrimeRate memory pr, uint16 currencyId) internal view {\\n        (\\n            /* */, /* */,\\n            uint256 maxUnderlyingDebt,\\n            uint256 totalUnderlyingDebt\\n        ) = getSupplyCap(pr, currencyId);\\n        if (maxUnderlyingDebt == 0) return;\\n\\n        require(totalUnderlyingDebt <= maxUnderlyingDebt, \\\"Over Debt Cap\\\");\\n    }\\n\\n    function getSupplyCap(PrimeRate memory pr, uint16 currencyId) internal view returns (\\n        uint256 maxUnderlyingSupply,\\n        uint256 totalUnderlyingSupply,\\n        uint256 maxUnderlyingDebt,\\n        uint256 totalUnderlyingDebt\\n    ) {\\n        PrimeCashFactorsStorage storage s = LibStorage.getPrimeCashFactors()[currencyId];\\n        maxUnderlyingSupply = FloatingPoint.unpackFromBits(s.maxUnderlyingSupply);\\n\\n        // If maxUnderlyingSupply or maxPrimeDebtUtilization is set to zero, there is no debt cap. The\\n        // debt cap is applied to prevent the supply cap from being locked up by extremely high utilization\\n        maxUnderlyingDebt = maxUnderlyingSupply\\n            .mul(s.maxPrimeDebtUtilization).div(uint256(Constants.PERCENTAGE_DECIMALS));\\n\\n        // No potential for overflow due to storage size\\n        int256 totalPrimeSupply = int256(uint256(s.totalPrimeSupply));\\n        totalUnderlyingSupply = pr.convertToUnderlying(totalPrimeSupply).toUint();\\n\\n        // totalPrimeDebt is stored as a uint88 so the negation here will never underflow\\n        int256 totalPrimeDebt = -int256(uint256(s.totalPrimeDebt));\\n        totalUnderlyingDebt = pr.convertDebtStorageToUnderlying(totalPrimeDebt).neg().toUint();\\n    }\\n}\"\r\n    },\r\n    \"contracts/internal/portfolio/BitmapAssetsHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    PrimeRate,\\n    CashGroupParameters,\\n    AccountContext,\\n    PortfolioAsset,\\n    ifCashStorage\\n} from \\\"../../global/Types.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {Bitmap} from \\\"../../math/Bitmap.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\n\\nimport {AccountContextHandler} from \\\"../AccountContextHandler.sol\\\";\\nimport {CashGroup} from \\\"../markets/CashGroup.sol\\\";\\nimport {DateTime} from \\\"../markets/DateTime.sol\\\";\\nimport {AssetHandler} from \\\"../valuation/AssetHandler.sol\\\";\\nimport {PrimeCashExchangeRate} from \\\"../pCash/PrimeCashExchangeRate.sol\\\";\\n\\nlibrary BitmapAssetsHandler {\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n    using Bitmap for bytes32;\\n    using CashGroup for CashGroupParameters;\\n    using AccountContextHandler for AccountContext;\\n\\n    function getAssetsBitmap(address account, uint256 currencyId) internal view returns (bytes32 assetsBitmap) {\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\n        return store[account][currencyId];\\n    }\\n\\n    function setAssetsBitmap(\\n        address account,\\n        uint256 currencyId,\\n        bytes32 assetsBitmap\\n    ) internal {\\n        require(assetsBitmap.totalBitsSet() <= Constants.MAX_BITMAP_ASSETS, \\\"Over max assets\\\");\\n        mapping(address => mapping(uint256 => bytes32)) storage store = LibStorage.getAssetsBitmapStorage();\\n        store[account][currencyId] = assetsBitmap;\\n    }\\n\\n    function getifCashNotional(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity\\n    ) internal view returns (int256 notional) {\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n        return store[account][currencyId][maturity].notional;\\n    }\\n\\n    /// @notice Adds multiple assets to a bitmap portfolio\\n    function addMultipleifCashAssets(\\n        address account,\\n        AccountContext memory accountContext,\\n        PortfolioAsset[] memory assets\\n    ) internal {\\n        require(accountContext.isBitmapEnabled()); // dev: bitmap currency not set\\n        uint16 currencyId = accountContext.bitmapCurrencyId;\\n\\n        for (uint256 i; i < assets.length; i++) {\\n            PortfolioAsset memory asset = assets[i];\\n            if (asset.notional == 0) continue;\\n\\n            require(asset.currencyId == currencyId); // dev: invalid asset in set ifcash assets\\n            require(asset.assetType == Constants.FCASH_ASSET_TYPE); // dev: invalid asset in set ifcash assets\\n            int256 finalNotional;\\n\\n            finalNotional = addifCashAsset(\\n                account,\\n                currencyId,\\n                asset.maturity,\\n                accountContext.nextSettleTime,\\n                asset.notional\\n            );\\n\\n            if (finalNotional < 0)\\n                accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\n        }\\n    }\\n\\n    /// @notice Add an ifCash asset in the bitmap and mapping. Updates the bitmap in memory\\n    /// but not in storage.\\n    /// @return the updated assets bitmap and the final notional amount\\n    function addifCashAsset(\\n        address account,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 nextSettleTime,\\n        int256 notional\\n    ) internal returns (int256) {\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n        ifCashStorage storage fCashSlot = store[account][currencyId][maturity];\\n        (uint256 bitNum, bool isExact) = DateTime.getBitNumFromMaturity(nextSettleTime, maturity);\\n        require(isExact); // dev: invalid maturity in set ifcash asset\\n\\n        if (assetsBitmap.isBitSet(bitNum)) {\\n            // Bit is set so we read and update the notional amount\\n            int256 initialNotional = fCashSlot.notional;\\n            int256 finalNotional = notional.add(initialNotional);\\n            fCashSlot.notional = finalNotional.toInt128();\\n\\n            PrimeCashExchangeRate.updateTotalfCashDebtOutstanding(\\n                account, currencyId, maturity, initialNotional, finalNotional\\n            );\\n\\n            // If the new notional is zero then turn off the bit\\n            if (finalNotional == 0) {\\n                assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            }\\n\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\n            return finalNotional;\\n        }\\n\\n        if (notional != 0) {\\n            // Bit is not set so we turn it on and update the mapping directly, no read required.\\n            fCashSlot.notional = notional.toInt128();\\n\\n            PrimeCashExchangeRate.updateTotalfCashDebtOutstanding(\\n                account,\\n                currencyId,\\n                maturity,\\n                0, // bit was not set, so initial notional value is zero\\n                notional\\n            );\\n\\n            assetsBitmap = assetsBitmap.setBit(bitNum, true);\\n            setAssetsBitmap(account, currencyId, assetsBitmap);\\n        }\\n\\n        return notional;\\n    }\\n\\n    /// @notice Returns the present value of an asset\\n    function getPresentValue(\\n        address account,\\n        uint256 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        CashGroupParameters memory cashGroup,\\n        bool riskAdjusted\\n    ) internal view returns (int256) {\\n        int256 notional = getifCashNotional(account, currencyId, maturity);\\n\\n        // In this case the asset has matured and the total value is just the notional amount\\n        if (maturity <= blockTime) {\\n            return notional;\\n        } else {\\n            if (riskAdjusted) {\\n                return AssetHandler.getRiskAdjustedPresentfCashValue(\\n                    cashGroup, notional, maturity, blockTime\\n                );\\n            } else {\\n                uint256 oracleRate = cashGroup.calculateOracleRate(maturity, blockTime);\\n                return AssetHandler.getPresentfCashValue(\\n                    notional,\\n                    maturity,\\n                    blockTime,\\n                    oracleRate\\n                );\\n            }\\n        }\\n    }\\n\\n    function getNetPresentValueFromBitmap(\\n        address account,\\n        uint256 currencyId,\\n        uint256 nextSettleTime,\\n        uint256 blockTime,\\n        CashGroupParameters memory cashGroup,\\n        bool riskAdjusted,\\n        bytes32 assetsBitmap\\n    ) internal view returns (int256 totalValueUnderlying, bool hasDebt) {\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\n\\n        while (bitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\n            int256 pv = getPresentValue(\\n                account,\\n                currencyId,\\n                maturity,\\n                blockTime,\\n                cashGroup,\\n                riskAdjusted\\n            );\\n            totalValueUnderlying = totalValueUnderlying.add(pv);\\n\\n            if (pv < 0) hasDebt = true;\\n\\n            // Turn off the bit and look for the next one\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            bitNum = assetsBitmap.getNextBitNum();\\n        }\\n    }\\n\\n    /// @notice Get the net present value of all the ifCash assets\\n    function getifCashNetPresentValue(\\n        address account,\\n        uint256 currencyId,\\n        uint256 nextSettleTime,\\n        uint256 blockTime,\\n        CashGroupParameters memory cashGroup,\\n        bool riskAdjusted\\n    ) internal view returns (int256 totalValueUnderlying, bool hasDebt) {\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        return getNetPresentValueFromBitmap(\\n            account,\\n            currencyId,\\n            nextSettleTime,\\n            blockTime,\\n            cashGroup,\\n            riskAdjusted,\\n            assetsBitmap\\n        );\\n    }\\n\\n    /// @notice Returns the ifCash assets as an array\\n    function getifCashArray(\\n        address account,\\n        uint16 currencyId,\\n        uint256 nextSettleTime\\n    ) internal view returns (PortfolioAsset[] memory) {\\n        bytes32 assetsBitmap = getAssetsBitmap(account, currencyId);\\n        uint256 index = assetsBitmap.totalBitsSet();\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](index);\\n        index = 0;\\n\\n        uint256 bitNum = assetsBitmap.getNextBitNum();\\n        while (bitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(nextSettleTime, bitNum);\\n            int256 notional = getifCashNotional(account, currencyId, maturity);\\n\\n            PortfolioAsset memory asset = assets[index];\\n            asset.currencyId = currencyId;\\n            asset.maturity = maturity;\\n            asset.assetType = Constants.FCASH_ASSET_TYPE;\\n            asset.notional = notional;\\n            index += 1;\\n\\n            // Turn off the bit and look for the next one\\n            assetsBitmap = assetsBitmap.setBit(bitNum, false);\\n            bitNum = assetsBitmap.getNextBitNum();\\n        }\\n\\n        return assets;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/PortfolioHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    PortfolioState,\\n    PortfolioAsset,\\n    PortfolioAssetStorage,\\n    AssetStorageState\\n} from \\\"../../global/Types.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {TransferAssets} from \\\"./TransferAssets.sol\\\";\\nimport {AssetHandler} from \\\"../valuation/AssetHandler.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\n\\n/// @notice Handles the management of an array of assets including reading from storage, inserting\\n/// updating, deleting and writing back to storage.\\nlibrary PortfolioHandler {\\n    using SafeInt256 for int256;\\n    using AssetHandler for PortfolioAsset;\\n\\n    // Mirror of LibStorage.MAX_PORTFOLIO_ASSETS\\n    uint256 private constant MAX_PORTFOLIO_ASSETS = 8;\\n\\n    /// @notice Primarily used by the TransferAssets library\\n    function addMultipleAssets(PortfolioState memory portfolioState, PortfolioAsset[] memory assets)\\n        internal\\n        pure\\n    {\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            PortfolioAsset memory asset = assets[i];\\n            if (asset.notional == 0) continue;\\n\\n            addAsset(\\n                portfolioState,\\n                asset.currencyId,\\n                asset.maturity,\\n                asset.assetType,\\n                asset.notional\\n            );\\n        }\\n    }\\n\\n    function _mergeAssetIntoArray(\\n        PortfolioAsset[] memory assetArray,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        int256 notional\\n    ) private pure returns (bool) {\\n        for (uint256 i = 0; i < assetArray.length; i++) {\\n            PortfolioAsset memory asset = assetArray[i];\\n            if (\\n                asset.assetType != assetType ||\\n                asset.currencyId != currencyId ||\\n                asset.maturity != maturity\\n            ) continue;\\n\\n            // Either of these storage states mean that some error in logic has occurred, we cannot\\n            // store this portfolio\\n            require(\\n                asset.storageState != AssetStorageState.Delete &&\\n                asset.storageState != AssetStorageState.RevertIfStored\\n            ); // dev: portfolio handler deleted storage\\n\\n            int256 newNotional = asset.notional.add(notional);\\n            // Liquidity tokens cannot be reduced below zero.\\n            if (AssetHandler.isLiquidityToken(assetType)) {\\n                require(newNotional >= 0); // dev: portfolio handler negative liquidity token balance\\n            }\\n\\n            require(newNotional >= type(int88).min && newNotional <= type(int88).max); // dev: portfolio handler notional overflow\\n\\n            asset.notional = newNotional;\\n            asset.storageState = AssetStorageState.Update;\\n\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /// @notice Adds an asset to a portfolio state in memory (does not write to storage)\\n    /// @dev Ensures that only one version of an asset exists in a portfolio (i.e. does not allow two fCash assets of the same maturity\\n    /// to exist in a single portfolio). Also ensures that liquidity tokens do not have a negative notional.\\n    function addAsset(\\n        PortfolioState memory portfolioState,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        int256 notional\\n    ) internal pure {\\n        if (\\n            // Will return true if merged\\n            _mergeAssetIntoArray(\\n                portfolioState.storedAssets,\\n                currencyId,\\n                maturity,\\n                assetType,\\n                notional\\n            )\\n        ) return;\\n\\n        if (portfolioState.lastNewAssetIndex > 0) {\\n            bool merged = _mergeAssetIntoArray(\\n                portfolioState.newAssets,\\n                currencyId,\\n                maturity,\\n                assetType,\\n                notional\\n            );\\n            if (merged) return;\\n        }\\n\\n        // At this point if we have not merged the asset then append to the array\\n        // Cannot remove liquidity that the portfolio does not have\\n        if (AssetHandler.isLiquidityToken(assetType)) {\\n            require(notional >= 0); // dev: portfolio handler negative liquidity token balance\\n        }\\n        require(notional >= type(int88).min && notional <= type(int88).max); // dev: portfolio handler notional overflow\\n\\n        // Need to provision a new array at this point\\n        if (portfolioState.lastNewAssetIndex == portfolioState.newAssets.length) {\\n            portfolioState.newAssets = _extendNewAssetArray(portfolioState.newAssets);\\n        }\\n\\n        // Otherwise add to the new assets array. It should not be possible to add matching assets in a single transaction, we will\\n        // check this again when we write to storage. Assigning to memory directly here, do not allocate new memory via struct.\\n        PortfolioAsset memory newAsset = portfolioState.newAssets[portfolioState.lastNewAssetIndex];\\n        newAsset.currencyId = currencyId;\\n        newAsset.maturity = maturity;\\n        newAsset.assetType = assetType;\\n        newAsset.notional = notional;\\n        newAsset.storageState = AssetStorageState.NoChange;\\n        portfolioState.lastNewAssetIndex += 1;\\n    }\\n\\n    /// @dev Extends the new asset array if it is not large enough, this is likely to get a bit expensive if we do\\n    /// it too much\\n    function _extendNewAssetArray(PortfolioAsset[] memory newAssets)\\n        private\\n        pure\\n        returns (PortfolioAsset[] memory)\\n    {\\n        // Double the size of the new asset array every time we have to extend to reduce the number of times\\n        // that we have to extend it. This will go: 0, 1, 2, 4, 8 (probably stops there).\\n        uint256 newLength = newAssets.length == 0 ? 1 : newAssets.length * 2;\\n        PortfolioAsset[] memory extendedArray = new PortfolioAsset[](newLength);\\n        for (uint256 i = 0; i < newAssets.length; i++) {\\n            extendedArray[i] = newAssets[i];\\n        }\\n\\n        return extendedArray;\\n    }\\n\\n    /// @notice Takes a portfolio state and writes it to storage.\\n    /// @dev This method should only be called directly by the nToken. Account updates to portfolios should happen via\\n    /// the storeAssetsAndUpdateContext call in the AccountContextHandler.sol library.\\n    /// @return updated variables to update the account context with\\n    ///     hasDebt: whether or not the portfolio has negative fCash assets\\n    ///     portfolioActiveCurrencies: a byte32 word with all the currencies in the portfolio\\n    ///     uint8: the length of the storage array\\n    ///     uint40: the new nextSettleTime for the portfolio\\n    function storeAssets(PortfolioState memory portfolioState, address account)\\n        internal\\n        returns (\\n            bool,\\n            bytes32,\\n            uint8,\\n            uint40\\n        )\\n    {\\n        bool hasDebt;\\n        // NOTE: cannot have more than 16 assets or this byte object will overflow. Max assets is\\n        // set to 7 and the worst case during liquidation would be 7 liquidity tokens that generate\\n        // 7 additional fCash assets for a total of 14 assets. Although even in this case all assets\\n        // would be of the same currency so it would not change the end result of the active currency\\n        // calculation.\\n        bytes32 portfolioActiveCurrencies;\\n        uint256 nextSettleTime;\\n\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n            // NOTE: this is to prevent the storage of assets that have been modified in the AssetHandler\\n            // during valuation.\\n            require(asset.storageState != AssetStorageState.RevertIfStored);\\n\\n            // Mark any zero notional assets as deleted\\n            if (asset.storageState != AssetStorageState.Delete && asset.notional == 0) {\\n                deleteAsset(portfolioState, i);\\n            }\\n        }\\n\\n        // First delete assets from asset storage to maintain asset storage indexes\\n        for (uint256 i = 0; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n\\n            if (asset.storageState == AssetStorageState.Delete) {\\n                // Delete asset from storage\\n                uint256 currentSlot = asset.storageSlot;\\n                assembly {\\n                    sstore(currentSlot, 0x00)\\n                }\\n            } else {\\n                if (asset.storageState == AssetStorageState.Update) {\\n                    PortfolioAssetStorage storage assetStorage;\\n                    uint256 currentSlot = asset.storageSlot;\\n                    assembly {\\n                        assetStorage.slot := currentSlot\\n                    }\\n\\n                    _storeAsset(asset, assetStorage);\\n                }\\n\\n                // Update portfolio context for every asset that is in storage, whether it is\\n                // updated in storage or not.\\n                (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\n                    asset,\\n                    hasDebt,\\n                    portfolioActiveCurrencies,\\n                    nextSettleTime\\n                );\\n            }\\n        }\\n\\n        // Add new assets\\n        uint256 assetStorageLength = portfolioState.storedAssetLength;\\n        mapping(address => \\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\n        for (uint256 i = 0; i < portfolioState.newAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.newAssets[i];\\n            if (asset.notional == 0) continue;\\n            require(\\n                asset.storageState != AssetStorageState.Delete &&\\n                asset.storageState != AssetStorageState.RevertIfStored\\n            ); // dev: store assets deleted storage\\n\\n            (hasDebt, portfolioActiveCurrencies, nextSettleTime) = _updatePortfolioContext(\\n                asset,\\n                hasDebt,\\n                portfolioActiveCurrencies,\\n                nextSettleTime\\n            );\\n\\n            _storeAsset(asset, storageArray[assetStorageLength]);\\n            assetStorageLength += 1;\\n        }\\n\\n        // 16 is the maximum number of assets or portfolio active currencies will overflow its\\n        // 32 bytes size given 2 bytes per currency\\n        require(assetStorageLength <= 16); // dev: active currencies bytes32 overflow\\n        require(nextSettleTime <= type(uint40).max); // dev: portfolio return value overflow\\n        return (\\n            hasDebt,\\n            portfolioActiveCurrencies,\\n            uint8(assetStorageLength),\\n            uint40(nextSettleTime)\\n        );\\n    }\\n\\n    /// @notice Updates context information during the store assets method\\n    function _updatePortfolioContext(\\n        PortfolioAsset memory asset,\\n        bool hasDebt,\\n        bytes32 portfolioActiveCurrencies,\\n        uint256 nextSettleTime\\n    )\\n        private\\n        pure\\n        returns (\\n            bool,\\n            bytes32,\\n            uint256\\n        )\\n    {\\n        uint256 settlementDate = asset.getSettlementDate();\\n        // Tis will set it to the minimum settlement date\\n        if (nextSettleTime == 0 || nextSettleTime > settlementDate) {\\n            nextSettleTime = settlementDate;\\n        }\\n        hasDebt = hasDebt || asset.notional < 0;\\n\\n        require(uint16(uint256(portfolioActiveCurrencies)) == 0); // dev: portfolio active currencies overflow\\n        portfolioActiveCurrencies = \\n            (portfolioActiveCurrencies >> 16) | \\n            (bytes32(uint256(asset.currencyId)) << 240);\\n\\n        return (hasDebt, portfolioActiveCurrencies, nextSettleTime);\\n    }\\n\\n    /// @dev Encodes assets for storage\\n    function _storeAsset(\\n        PortfolioAsset memory asset,\\n        PortfolioAssetStorage storage assetStorage\\n    ) internal {\\n        require(0 < asset.currencyId && asset.currencyId <= Constants.MAX_CURRENCIES); // dev: encode asset currency id overflow\\n        require(0 < asset.maturity && asset.maturity <= type(uint40).max); // dev: encode asset maturity overflow\\n        require(0 < asset.assetType && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: encode asset type invalid\\n        require(type(int88).min <= asset.notional && asset.notional <= type(int88).max); // dev: encode asset notional overflow\\n\\n        assetStorage.currencyId = uint16(asset.currencyId);\\n        assetStorage.maturity = uint40(asset.maturity);\\n        assetStorage.assetType = uint8(asset.assetType);\\n        assetStorage.notional = int88(asset.notional);\\n    }\\n\\n    /// @notice Deletes an asset from a portfolio\\n    /// @dev This method should only be called during settlement, assets can only be removed from a portfolio before settlement\\n    /// by adding the offsetting negative position\\n    function deleteAsset(PortfolioState memory portfolioState, uint256 index) internal pure {\\n        require(index < portfolioState.storedAssets.length); // dev: stored assets bounds\\n        require(portfolioState.storedAssetLength > 0); // dev: stored assets length is zero\\n        PortfolioAsset memory assetToDelete = portfolioState.storedAssets[index];\\n        require(\\n            assetToDelete.storageState != AssetStorageState.Delete &&\\n            assetToDelete.storageState != AssetStorageState.RevertIfStored\\n        ); // dev: cannot delete asset\\n\\n        portfolioState.storedAssetLength -= 1;\\n\\n        uint256 maxActiveSlotIndex;\\n        uint256 maxActiveSlot;\\n        // The max active slot is the last storage slot where an asset exists, it's not clear where this will be in the\\n        // array so we search for it here.\\n        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory a = portfolioState.storedAssets[i];\\n            if (a.storageSlot > maxActiveSlot && a.storageState != AssetStorageState.Delete) {\\n                maxActiveSlot = a.storageSlot;\\n                maxActiveSlotIndex = i;\\n            }\\n        }\\n\\n        if (index == maxActiveSlotIndex) {\\n            // In this case we are deleting the asset with the max storage slot so no swap is necessary.\\n            assetToDelete.storageState = AssetStorageState.Delete;\\n            return;\\n        }\\n\\n        // Swap the storage slots of the deleted asset with the last non-deleted asset in the array. Mark them accordingly\\n        // so that when we call store assets they will be updated appropriately\\n        PortfolioAsset memory assetToSwap = portfolioState.storedAssets[maxActiveSlotIndex];\\n        (\\n            assetToSwap.storageSlot,\\n            assetToDelete.storageSlot\\n        ) = (\\n            assetToDelete.storageSlot,\\n            assetToSwap.storageSlot\\n        );\\n        assetToSwap.storageState = AssetStorageState.Update;\\n        assetToDelete.storageState = AssetStorageState.Delete;\\n    }\\n\\n    /// @notice Returns a portfolio array, will be sorted\\n    function getSortedPortfolio(address account, uint8 assetArrayLength)\\n        internal view returns (PortfolioAsset[] memory assets) {\\n        (assets, /* */) = getSortedPortfolioWithIds(account, assetArrayLength);\\n    }\\n\\n    function getSortedPortfolioWithIds(address account, uint8 assetArrayLength)\\n        internal view returns (PortfolioAsset[] memory assets, uint256[] memory ids) {\\n        assets = _loadAssetArray(account, assetArrayLength);\\n        ids = _sortInPlace(assets);\\n    }\\n\\n    /// @notice Builds a portfolio array from storage. The new assets hint parameter will\\n    /// be used to provision a new array for the new assets. This will increase gas efficiency\\n    /// so that we don't have to make copies when we extend the array.\\n    function buildPortfolioState(\\n        address account,\\n        uint8 assetArrayLength,\\n        uint256 newAssetsHint\\n    ) internal view returns (PortfolioState memory) {\\n        PortfolioState memory state;\\n        if (assetArrayLength == 0) return state;\\n\\n        state.storedAssets = getSortedPortfolio(account, assetArrayLength);\\n        state.storedAssetLength = assetArrayLength;\\n        state.newAssets = new PortfolioAsset[](newAssetsHint);\\n\\n        return state;\\n    }\\n\\n    function _sortId(uint16 currencyId, uint256 maturity, uint256 assetType) private pure returns (uint256) {\\n        return uint256(\\n            (bytes32(uint256(currencyId)) << 48) |\\n                (bytes32(uint256(uint40(maturity))) << 8) |\\n                bytes32(uint256(uint8(assetType)))\\n        );\\n    }\\n\\n    function _sortInPlace(\\n        PortfolioAsset[] memory assets\\n    ) private pure returns (uint256[] memory ids) {\\n        uint256 length = assets.length;\\n        ids = new uint256[](length);\\n        for (uint256 k; k < length; k++) {\\n            PortfolioAsset memory asset = assets[k];\\n            // Prepopulate the ids to calculate just once\\n            ids[k] = _sortId(asset.currencyId, asset.maturity, asset.assetType);\\n        }\\n\\n        // Uses insertion sort \\n        uint256 i = 1;\\n        while (i < length) {\\n            uint256 j = i;\\n            while (j > 0 && ids[j - 1] > ids[j]) {\\n                // Swap j - 1 and j\\n                (ids[j - 1], ids[j]) = (ids[j], ids[j - 1]);\\n                (assets[j - 1], assets[j]) = (assets[j], assets[j - 1]);\\n                j--;\\n            }\\n            i++;\\n        }\\n    }\\n\\n    function _loadAssetArray(address account, uint8 length)\\n        private\\n        view\\n        returns (PortfolioAsset[] memory)\\n    {\\n        // This will overflow the storage pointer\\n        require(length <= MAX_PORTFOLIO_ASSETS);\\n\\n        mapping(address => \\n            PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS]) storage store = LibStorage.getPortfolioArrayStorage();\\n        PortfolioAssetStorage[MAX_PORTFOLIO_ASSETS] storage storageArray = store[account];\\n        PortfolioAsset[] memory assets = new PortfolioAsset[](length);\\n\\n        for (uint256 i = 0; i < length; i++) {\\n            PortfolioAssetStorage storage assetStorage = storageArray[i];\\n            PortfolioAsset memory asset = assets[i];\\n            uint256 slot;\\n            assembly {\\n                slot := assetStorage.slot\\n            }\\n\\n            asset.currencyId = assetStorage.currencyId;\\n            asset.maturity = assetStorage.maturity;\\n            asset.assetType = assetStorage.assetType;\\n            asset.notional = assetStorage.notional;\\n            asset.storageSlot = slot;\\n        }\\n\\n        return assets;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/portfolio/TransferAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    PortfolioState,\\n    PortfolioAsset,\\n    AccountContext\\n} from \\\"../../global/Types.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {PortfolioHandler} from \\\"./PortfolioHandler.sol\\\";\\nimport {BitmapAssetsHandler} from \\\"./BitmapAssetsHandler.sol\\\";\\nimport {AccountContextHandler} from \\\"../AccountContextHandler.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\n\\n/// @notice Helper library for transferring assets from one portfolio to another\\nlibrary TransferAssets {\\n    using AccountContextHandler for AccountContext;\\n    using PortfolioHandler for PortfolioState;\\n    using SafeInt256 for int256;\\n\\n    /// @dev Used to flip the sign of assets to decrement the `from` account that is sending assets\\n    function invertNotionalAmountsInPlace(PortfolioAsset[] memory assets) internal pure {\\n        for (uint256 i; i < assets.length; i++) {\\n            assets[i].notional = assets[i].notional.neg();\\n        }\\n    }\\n\\n    /// @dev Useful method for hiding the logic of updating an account. WARNING: the account\\n    /// context returned from this method may not be the same memory location as the account\\n    /// context provided if the account is settled.\\n    function placeAssetsInAccount(\\n        address account,\\n        AccountContext memory accountContext,\\n        PortfolioAsset[] memory assets\\n    ) internal returns (AccountContext memory) {\\n        // If an account has assets that require settlement then placing assets inside it\\n        // may cause issues.\\n        require(!accountContext.mustSettleAssets(), \\\"Account must settle\\\");\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            // Adds fCash assets into the account and finalized storage\\n            BitmapAssetsHandler.addMultipleifCashAssets(account, accountContext, assets);\\n        } else {\\n            PortfolioState memory portfolioState = PortfolioHandler.buildPortfolioState(\\n                account,\\n                accountContext.assetArrayLength,\\n                assets.length\\n            );\\n            // This will add assets in memory\\n            portfolioState.addMultipleAssets(assets);\\n            // This will store assets and update the account context in memory\\n            accountContext.storeAssetsAndUpdateContext(account, portfolioState);\\n        }\\n\\n        return accountContext;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/settlement/SettleBitmapAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {PrimeRate, ifCashStorage} from \\\"../../global/Types.sol\\\";\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {Bitmap} from \\\"../../math/Bitmap.sol\\\";\\n\\nimport {DateTime} from \\\"../markets/DateTime.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {BitmapAssetsHandler} from \\\"../portfolio/BitmapAssetsHandler.sol\\\";\\n\\n/**\\n * Settles a bitmap portfolio by checking for all matured fCash assets and turning them into cash\\n * at the prevailing settlement rate. It will also update the asset bitmap to ensure that it continues\\n * to correctly reference all actual maturities. fCash asset notional values are stored in *absolute* \\n * time terms and bitmap bits are *relative* time terms based on the bitNumber and the stored oldSettleTime.\\n * Remapping bits requires converting the old relative bit numbers to new relative bit numbers based on\\n * newSettleTime and the absolute times (maturities) that the previous bitmap references.\\n */\\nlibrary SettleBitmapAssets {\\n    using PrimeRateLib for PrimeRate;\\n    using SafeInt256 for int256;\\n    using Bitmap for bytes32;\\n\\n    /// @notice Given a bitmap for a cash group and timestamps, will settle all assets\\n    /// that have matured and remap the bitmap to correspond to the current time.\\n    function settleBitmappedCashGroup(\\n        address account,\\n        uint16 currencyId,\\n        uint256 oldSettleTime,\\n        uint256 blockTime,\\n        PrimeRate memory presentPrimeRate\\n    ) internal returns (int256 positiveSettledCash, int256 negativeSettledCash, uint256 newSettleTime) {\\n        bytes32 bitmap = BitmapAssetsHandler.getAssetsBitmap(account, currencyId);\\n\\n        // This newSettleTime will be set to the new `oldSettleTime`. The bits between 1 and\\n        // `lastSettleBit` (inclusive) will be shifted out of the bitmap and settled. The reason\\n        // that lastSettleBit is inclusive is that it refers to newSettleTime which always less\\n        // than the current block time.\\n        newSettleTime = DateTime.getTimeUTC0(blockTime);\\n        // If newSettleTime == oldSettleTime lastSettleBit will be zero\\n        require(newSettleTime >= oldSettleTime); // dev: new settle time before previous\\n\\n        // Do not need to worry about validity, if newSettleTime is not on an exact bit we will settle up until\\n        // the closest maturity that is less than newSettleTime.\\n        (uint256 lastSettleBit, /* isValid */) = DateTime.getBitNumFromMaturity(oldSettleTime, newSettleTime);\\n        if (lastSettleBit == 0) return (0, 0, newSettleTime);\\n\\n        // Returns the next bit that is set in the bitmap\\n        uint256 nextBitNum = bitmap.getNextBitNum();\\n        while (nextBitNum != 0 && nextBitNum <= lastSettleBit) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);\\n            int256 settledPrimeCash = _settlefCashAsset(account, currencyId, maturity, blockTime, presentPrimeRate);\\n\\n            // Split up positive and negative amounts so that total prime debt can be properly updated later\\n            if (settledPrimeCash > 0) {\\n                positiveSettledCash = positiveSettledCash.add(settledPrimeCash);\\n            } else {\\n                negativeSettledCash = negativeSettledCash.add(settledPrimeCash);\\n            }\\n\\n            // Turn the bit off now that it is settled\\n            bitmap = bitmap.setBit(nextBitNum, false);\\n            nextBitNum = bitmap.getNextBitNum();\\n        }\\n\\n        bytes32 newBitmap;\\n        while (nextBitNum != 0) {\\n            uint256 maturity = DateTime.getMaturityFromBitNum(oldSettleTime, nextBitNum);\\n            (uint256 newBitNum, bool isValid) = DateTime.getBitNumFromMaturity(newSettleTime, maturity);\\n            require(isValid); // dev: invalid new bit num\\n\\n            newBitmap = newBitmap.setBit(newBitNum, true);\\n\\n            // Turn the bit off now that it is remapped\\n            bitmap = bitmap.setBit(nextBitNum, false);\\n            nextBitNum = bitmap.getNextBitNum();\\n        }\\n\\n        BitmapAssetsHandler.setAssetsBitmap(account, currencyId, newBitmap);\\n    }\\n\\n    /// @dev Stateful settlement function to settle a bitmapped asset. Deletes the\\n    /// asset from storage after calculating it.\\n    function _settlefCashAsset(\\n        address account,\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        PrimeRate memory presentPrimeRate\\n    ) private returns (int256 signedPrimeSupplyValue) {\\n        mapping(address => mapping(uint256 =>\\n            mapping(uint256 => ifCashStorage))) storage store = LibStorage.getifCashBitmapStorage();\\n        int256 notional = store[account][currencyId][maturity].notional;\\n        \\n        // Gets the current settlement rate or will store a new settlement rate if it does not\\n        // yet exist.\\n        signedPrimeSupplyValue = presentPrimeRate.convertSettledfCash(\\n            account, currencyId, maturity, notional, blockTime\\n        );\\n\\n        delete store[account][currencyId][maturity];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/settlement/SettlePortfolioAssets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {SettleAmount, AssetStorageState, PrimeRate} from \\\"../../global/Types.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\n\\nimport {PortfolioAsset, AssetHandler} from \\\"../valuation/AssetHandler.sol\\\";\\nimport {Market, MarketParameters} from \\\"../markets/Market.sol\\\";\\nimport {PortfolioState, PortfolioHandler} from \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\n\\nlibrary SettlePortfolioAssets {\\n    using SafeInt256 for int256;\\n    using PrimeRateLib for PrimeRate;\\n    using Market for MarketParameters;\\n    using PortfolioHandler for PortfolioState;\\n    using AssetHandler for PortfolioAsset;\\n\\n    /// @dev Returns a SettleAmount array for the assets that will be settled\\n    function _getSettleAmountArray(\\n        PortfolioState memory portfolioState,\\n        uint256 blockTime\\n    ) private returns (SettleAmount[] memory) {\\n        uint256 currenciesSettled;\\n        uint16 lastCurrencyId = 0;\\n        if (portfolioState.storedAssets.length == 0) return new SettleAmount[](0);\\n\\n        // Loop backwards so \\\"lastCurrencyId\\\" will be set to the first currency in the portfolio\\n        // NOTE: if this contract is ever upgraded to Solidity 0.8+ then this i-- will underflow and cause\\n        // a revert, must wrap in an unchecked.\\n        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n            // Assets settle on exactly blockTime\\n            if (asset.getSettlementDate() > blockTime) continue;\\n\\n            // Assume that this is sorted by cash group and maturity, currencyId = 0 is unused so this\\n            // will work for the first asset\\n            if (lastCurrencyId != asset.currencyId) {\\n                lastCurrencyId = asset.currencyId;\\n                currenciesSettled++;\\n            }\\n        }\\n\\n        // Actual currency ids will be set as we loop through the portfolio and settle assets\\n        SettleAmount[] memory settleAmounts = new SettleAmount[](currenciesSettled);\\n        if (currenciesSettled > 0) {\\n            settleAmounts[0].currencyId = lastCurrencyId;\\n            settleAmounts[0].presentPrimeRate = PrimeRateLib.buildPrimeRateStateful(lastCurrencyId);\\n        }\\n\\n        return settleAmounts;\\n    }\\n\\n    /// @notice Settles a portfolio array\\n    function settlePortfolio(\\n        address account,\\n        PortfolioState memory portfolioState,\\n        uint256 blockTime\\n    ) internal returns (SettleAmount[] memory) {\\n        SettleAmount[] memory settleAmounts = _getSettleAmountArray(portfolioState, blockTime);\\n        if (settleAmounts.length == 0) return settleAmounts;\\n        uint256 settleAmountIndex;\\n\\n        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\\n            PortfolioAsset memory asset = portfolioState.storedAssets[i];\\n            // Settlement date is on block time exactly\\n            if (asset.getSettlementDate() > blockTime) continue;\\n\\n            // On the first loop the lastCurrencyId is already set.\\n            if (settleAmounts[settleAmountIndex].currencyId != asset.currencyId) {\\n                // New currency in the portfolio\\n                settleAmountIndex += 1;\\n                settleAmounts[settleAmountIndex].currencyId = asset.currencyId;\\n                settleAmounts[settleAmountIndex].presentPrimeRate =\\n                    PrimeRateLib.buildPrimeRateStateful(asset.currencyId);\\n            }\\n            SettleAmount memory sa = settleAmounts[settleAmountIndex];\\n\\n            // Only the nToken is allowed to hold liquidity tokens\\n            require(asset.assetType == Constants.FCASH_ASSET_TYPE);\\n            // Gets or sets the settlement rate, only do this before settling fCash\\n            int256 primeCash = sa.presentPrimeRate.convertSettledfCash(\\n                account, asset.currencyId, asset.maturity, asset.notional, blockTime\\n            );\\n            portfolioState.deleteAsset(i);\\n\\n            // Positive and negative settled cash are not net off in this method, they have to be\\n            // split up in order to properly update the total prime debt outstanding figure.\\n            if (primeCash > 0) {\\n                sa.positiveSettledCash = sa.positiveSettledCash.add(primeCash);\\n            } else {\\n                sa.negativeSettledCash = sa.negativeSettledCash.add(primeCash);\\n            }\\n        }\\n\\n        return settleAmounts;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/valuation/AssetHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    PrimeRate,\\n    CashGroupParameters,\\n    PortfolioAsset,\\n    MarketParameters\\n} from \\\"../../global/Types.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"../../math/SafeUint256.sol\\\";\\nimport {ABDKMath64x64} from \\\"../../math/ABDKMath64x64.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\n\\nimport {DateTime} from \\\"../markets/DateTime.sol\\\";\\nimport {CashGroup} from \\\"../markets/CashGroup.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {PortfolioHandler} from \\\"../portfolio/PortfolioHandler.sol\\\";\\n\\nlibrary AssetHandler {\\n    using SafeUint256 for uint256;\\n    using SafeInt256 for int256;\\n    using CashGroup for CashGroupParameters;\\n    using PrimeRateLib for PrimeRate;\\n\\n    function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\\n        return\\n            assetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\\n            assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\\n    }\\n\\n    /// @notice Liquidity tokens settle every 90 days (not at the designated maturity). This method\\n    /// calculates the settlement date for any PortfolioAsset.\\n    function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\\n        require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX); // dev: settlement date invalid asset type\\n        // 3 month tokens and fCash tokens settle at maturity\\n        if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\\n\\n        uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\\n        // Liquidity tokens settle at tRef + 90 days. The formula to get a maturity is:\\n        // maturity = tRef + marketLength\\n        // Here we calculate:\\n        // tRef = (maturity - marketLength) + 90 days\\n        return asset.maturity.sub(marketLength).add(Constants.QUARTER);\\n    }\\n\\n    /// @notice Returns the continuously compounded discount rate given an oracle rate and a time to maturity.\\n    /// The formula is: e^(-rate * timeToMaturity).\\n    function getDiscountFactor(uint256 timeToMaturity, uint256 oracleRate)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        int128 expValue =\\n            ABDKMath64x64.fromUInt(oracleRate.mul(timeToMaturity).div(Constants.YEAR));\\n        expValue = ABDKMath64x64.div(expValue, Constants.RATE_PRECISION_64x64);\\n        expValue = ABDKMath64x64.exp(ABDKMath64x64.neg(expValue));\\n        expValue = ABDKMath64x64.mul(expValue, Constants.RATE_PRECISION_64x64);\\n        int256 discountFactor = ABDKMath64x64.toInt(expValue);\\n\\n        return discountFactor;\\n    }\\n\\n    /// @notice Present value of an fCash asset without any risk adjustments.\\n    function getPresentfCashValue(\\n        int256 notional,\\n        uint256 maturity,\\n        uint256 blockTime,\\n        uint256 oracleRate\\n    ) internal pure returns (int256) {\\n        if (notional == 0) return 0;\\n\\n        // NOTE: this will revert if maturity < blockTime. That is the correct behavior because we cannot\\n        // discount matured assets.\\n        uint256 timeToMaturity = maturity.sub(blockTime);\\n        int256 discountFactor = getDiscountFactor(timeToMaturity, oracleRate);\\n\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get present value invalid discount factor\\n\\n        int256 pv = notional.mulInRatePrecision(discountFactor);\\n        // Ensure that any debt balance always returns a -1 value.\\n        return notional < 0 ?  SafeInt256.min(pv, -1) : pv;\\n    }\\n\\n    function getRiskAdjustedfCashDiscount(\\n        CashGroupParameters memory cashGroup,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal view returns (int256 discountFactor) {\\n        uint256 oracleRate = cashGroup.calculateRiskAdjustedfCashOracleRate(maturity, blockTime);\\n        discountFactor = getDiscountFactor(maturity.sub(blockTime), oracleRate);\\n        int256 maxDiscountFactor = cashGroup.getMaxDiscountFactor();\\n        if (maxDiscountFactor < discountFactor) discountFactor = maxDiscountFactor;\\n    }\\n\\n    function getRiskAdjustedDebtDiscount(\\n        CashGroupParameters memory cashGroup,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal view returns (int256 discountFactor) {\\n        uint256 oracleRate = cashGroup.calculateRiskAdjustedDebtOracleRate(maturity, blockTime);\\n        discountFactor = oracleRate == 0 ? \\n            // Short circuit the expensive calculation if the oracle rate is floored to zero here.\\n            Constants.RATE_PRECISION :\\n            getDiscountFactor(maturity.sub(blockTime), oracleRate);\\n    }\\n\\n    /// @notice Present value of an fCash asset with risk adjustments. Positive fCash value will be discounted more\\n    /// heavily than the oracle rate given and vice versa for negative fCash.\\n    function getRiskAdjustedPresentfCashValue(\\n        CashGroupParameters memory cashGroup,\\n        int256 notional,\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) internal view returns (int256) {\\n        if (notional == 0) return 0;\\n\\n        int256 discountFactor = notional > 0 ?\\n            getRiskAdjustedfCashDiscount(cashGroup, maturity, blockTime) :\\n            getRiskAdjustedDebtDiscount(cashGroup, maturity, blockTime);\\n\\n        require(discountFactor <= Constants.RATE_PRECISION); // dev: get risk adjusted pv, invalid discount factor\\n        int256 pv = notional.mulInRatePrecision(discountFactor);\\n\\n        // Ensure that any debt balance always returns a -1 value.\\n        return notional < 0 ?  SafeInt256.min(pv, -1) : pv;\\n    }\\n\\n    /// @notice Returns the non haircut claims on cash and fCash by the liquidity token.\\n    function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\\n        internal\\n        pure\\n        returns (int256 primeCash, int256 fCash)\\n    {\\n        require(isLiquidityToken(token.assetType) && token.notional >= 0); // dev: invalid asset, get cash claims\\n\\n        primeCash = market.totalPrimeCash.mul(token.notional).div(market.totalLiquidity);\\n        fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\\n    }\\n\\n    /// @notice Returns present value of all assets in the cash group as prime cash and the updated\\n    /// portfolio index where the function has ended.\\n    /// @return the value of the cash group in asset cash\\n    function getNetCashGroupValue(\\n        PortfolioAsset[] memory assets,\\n        CashGroupParameters memory cashGroup,\\n        uint256 blockTime,\\n        uint256 portfolioIndex\\n    ) internal view returns (int256, uint256) {\\n        int256 presentValueInPrime;\\n        int256 presentValueUnderlying;\\n\\n        uint256 j = portfolioIndex;\\n        for (; j < assets.length; j++) {\\n            PortfolioAsset memory a = assets[j];\\n            if (a.assetType != Constants.FCASH_ASSET_TYPE) continue;\\n            // If we hit a different currency id then we've accounted for all assets in this currency\\n            // j will mark the index where we don't have this currency anymore\\n            if (a.currencyId != cashGroup.currencyId) break;\\n\\n            int256 pv = getRiskAdjustedPresentfCashValue(cashGroup, a.notional, a.maturity, blockTime);\\n            presentValueUnderlying = presentValueUnderlying.add(pv);\\n        }\\n\\n        presentValueInPrime = presentValueInPrime.add(\\n            cashGroup.primeRate.convertFromUnderlying(presentValueUnderlying)\\n        );\\n\\n        return (presentValueInPrime, j);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/valuation/ExchangeRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {LibStorage} from \\\"../../global/LibStorage.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {ETHRate, ETHRateStorage} from \\\"../../global/Types.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {AggregatorV2V3Interface} from \\\"../../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\n\\nlibrary ExchangeRate {\\n    using SafeInt256 for int256;\\n\\n    /// @notice Converts a balance to ETH from a base currency. Buffers or haircuts are\\n    /// always applied in this method.\\n    /// @param er exchange rate object from base to ETH\\n    /// @return the converted balance denominated in ETH with Constants.INTERNAL_TOKEN_PRECISION\\n    function convertToETH(ETHRate memory er, int256 balance) internal pure returns (int256) {\\n        int256 multiplier = balance > 0 ? er.haircut : er.buffer;\\n\\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\\n        // internalDecimals * rateDecimals * multiplier /  (rateDecimals * multiplierDecimals)\\n        // Therefore the result is in ethDecimals\\n        int256 result =\\n            balance.mul(er.rate).mul(multiplier).div(Constants.PERCENTAGE_DECIMALS).div(\\n                er.rateDecimals\\n            );\\n\\n        // Ensure that debt balances always return a negative value\\n        return balance < 0 ? SafeInt256.min(result, -1) : result;\\n    }\\n\\n    /// @notice Converts the balance denominated in ETH to the equivalent value in a base currency.\\n    /// Buffers and haircuts ARE NOT applied in this method.\\n    /// @param er exchange rate object from base to ETH\\n    /// @param balance amount (denominated in ETH) to convert\\n    function convertETHTo(ETHRate memory er, int256 balance) internal pure returns (int256) {\\n        // We are converting internal balances here so we know they have INTERNAL_TOKEN_PRECISION decimals\\n        // internalDecimals * rateDecimals / rateDecimals\\n        int256 result = balance.mul(er.rateDecimals).div(er.rate);\\n\\n        return result;\\n    }\\n\\n    /// @notice Calculates the exchange rate between two currencies via ETH. Returns the rate denominated in\\n    /// base exchange rate decimals: (baseRateDecimals * quoteRateDecimals) / quoteRateDecimals\\n    /// @param baseER base exchange rate struct\\n    /// @param quoteER quote exchange rate struct\\n    function exchangeRate(ETHRate memory baseER, ETHRate memory quoteER)\\n        internal\\n        pure\\n        returns (int256)\\n    {\\n        return baseER.rate.mul(quoteER.rateDecimals).div(quoteER.rate);\\n    }\\n\\n    /// @notice Returns an ETHRate object used to calculate free collateral\\n    function buildExchangeRate(uint256 currencyId) internal view returns (ETHRate memory) {\\n        mapping(uint256 => ETHRateStorage) storage store = LibStorage.getExchangeRateStorage();\\n        ETHRateStorage storage ethStorage = store[currencyId];\\n\\n        int256 rateDecimals;\\n        int256 rate;\\n        if (currencyId == Constants.ETH_CURRENCY_ID) {\\n            // ETH rates will just be 1e18, but will still have buffers, haircuts,\\n            // and liquidation discounts\\n            rateDecimals = Constants.ETH_DECIMALS;\\n            rate = Constants.ETH_DECIMALS;\\n        } else {\\n            // prettier-ignore\\n            (\\n                /* roundId */,\\n                rate,\\n                /* uint256 startedAt */,\\n                /* updatedAt */,\\n                /* answeredInRound */\\n            ) = ethStorage.rateOracle.latestRoundData();\\n            require(rate > 0);\\n\\n            // No overflow, restricted on storage\\n            rateDecimals = int256(10**ethStorage.rateDecimalPlaces);\\n            if (ethStorage.mustInvert) {\\n                rate = rateDecimals.mul(rateDecimals).div(rate);\\n            }\\n        }\\n\\n        int256 buffer = ethStorage.buffer;\\n        if (buffer > Constants.MIN_BUFFER_SCALE) {\\n            // Buffers from 100 to 150 are 1-1 (i.e. a buffer of 150 is a 150% increase)\\n            // in the debt amount. Buffers from 151 to 255 are scaled by a multiple of 10\\n            // units to allow for much higher buffers at the outer limits. A stored\\n            // buffer value of 151 = 150 + 10 = 160.\\n            // The max buffer value of of 255 = 150 + 105 * 10 = 1200.\\n\\n            // No possibility of overflows due to storage size and constant definition\\n            buffer = (buffer - Constants.MIN_BUFFER_SCALE) * Constants.BUFFER_SCALE \\n                + Constants.MIN_BUFFER_SCALE;\\n        }\\n\\n        return\\n            ETHRate({\\n                rateDecimals: rateDecimals,\\n                rate: rate,\\n                buffer: buffer,\\n                haircut: ethStorage.haircut,\\n                liquidationDiscount: ethStorage.liquidationDiscount\\n            });\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/internal/valuation/FreeCollateral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    PrimeRate,\\n    CashGroupParameters,\\n    PortfolioAsset,\\n    ETHRate,\\n    AccountContext,\\n    nTokenPortfolio,\\n    MarketParameters,\\n    LiquidationFactors\\n} from \\\"../../global/Types.sol\\\";\\nimport {Constants} from \\\"../../global/Constants.sol\\\";\\nimport {SafeInt256} from \\\"../../math/SafeInt256.sol\\\";\\nimport {Bitmap} from \\\"../../math/Bitmap.sol\\\";\\n\\nimport {CashGroup} from \\\"../markets/CashGroup.sol\\\";\\nimport {AccountContextHandler} from \\\"../AccountContextHandler.sol\\\";\\nimport {BalanceHandler} from \\\"../balances/BalanceHandler.sol\\\";\\nimport {PrimeRateLib} from \\\"../pCash/PrimeRateLib.sol\\\";\\nimport {PrimeCashExchangeRate} from \\\"../pCash/PrimeCashExchangeRate.sol\\\";\\nimport {PortfolioHandler} from \\\"../portfolio/PortfolioHandler.sol\\\";\\nimport {BitmapAssetsHandler} from \\\"../portfolio/BitmapAssetsHandler.sol\\\";\\nimport {nTokenHandler} from \\\"../nToken/nTokenHandler.sol\\\";\\nimport {nTokenCalculations} from \\\"../nToken/nTokenCalculations.sol\\\";\\n\\nimport {ExchangeRate} from \\\"./ExchangeRate.sol\\\";\\nimport {AssetHandler} from \\\"./AssetHandler.sol\\\";\\n\\nlibrary FreeCollateral {\\n    using SafeInt256 for int256;\\n    using Bitmap for bytes;\\n    using ExchangeRate for ETHRate;\\n    using PrimeRateLib for PrimeRate;\\n    using AccountContextHandler for AccountContext;\\n    using nTokenHandler for nTokenPortfolio;\\n\\n    /// @dev This is only used within the library to clean up the stack\\n    struct FreeCollateralFactors {\\n        int256 netETHValue;\\n        bool updateContext;\\n        uint256 portfolioIndex;\\n        CashGroupParameters cashGroup;\\n        PortfolioAsset[] portfolio;\\n        PrimeRate primeRate;\\n        nTokenPortfolio nToken;\\n    }\\n\\n    /// @notice Checks if an asset is active in the portfolio\\n    function _isActiveInPortfolio(bytes2 currencyBytes) private pure returns (bool) {\\n        return currencyBytes & Constants.ACTIVE_IN_PORTFOLIO == Constants.ACTIVE_IN_PORTFOLIO;\\n    }\\n\\n    /// @notice Checks if currency balances are active in the account returns them if true\\n    /// @return cash balance, nTokenBalance\\n    function _getCurrencyBalances(\\n        address account,\\n        bytes2 currencyBytes,\\n        PrimeRate memory primeRate\\n    ) private view returns (int256, int256) {\\n        if (currencyBytes & Constants.ACTIVE_IN_BALANCES == Constants.ACTIVE_IN_BALANCES) {\\n            uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\n            // prettier-ignore\\n            (\\n                int256 cashBalance,\\n                int256 nTokenBalance,\\n                /* lastClaimTime */,\\n                /* accountIncentiveDebt */\\n            ) = BalanceHandler.getBalanceStorage(account, currencyId, primeRate);\\n\\n            return (cashBalance, nTokenBalance);\\n        }\\n\\n        return (0, 0);\\n    }\\n\\n    /// @notice Calculates the nToken asset value with a haircut set by governance\\n    /// @return the value of the account's nTokens after haircut, the nToken parameters\\n    function _getNTokenHaircutPrimePV(\\n        CashGroupParameters memory cashGroup,\\n        nTokenPortfolio memory nToken,\\n        int256 tokenBalance,\\n        uint256 blockTime\\n    ) internal view returns (int256, bytes6) {\\n        nToken.loadNTokenPortfolioNoCashGroup(cashGroup.currencyId);\\n        nToken.cashGroup = cashGroup;\\n\\n        int256 nTokenPrimePV = nTokenCalculations.getNTokenPrimePV(nToken, blockTime);\\n\\n        // (tokenBalance * nTokenValue * haircut) / totalSupply\\n        int256 nTokenHaircutPrimePV =\\n            tokenBalance\\n                .mul(nTokenPrimePV)\\n                .mul(uint8(nToken.parameters[Constants.PV_HAIRCUT_PERCENTAGE]))\\n                .div(Constants.PERCENTAGE_DECIMALS)\\n                .div(nToken.totalSupply);\\n\\n        // nToken.parameters is returned for use in liquidation\\n        return (nTokenHaircutPrimePV, nToken.parameters);\\n    }\\n\\n    /// @notice Calculates portfolio and/or nToken values while using the supplied cash groups and\\n    /// markets. The reason these are grouped together is because they both require storage reads of the same\\n    /// values.\\n    function _getPortfolioAndNTokenAssetValue(\\n        FreeCollateralFactors memory factors,\\n        int256 nTokenBalance,\\n        uint256 blockTime\\n    )\\n        private\\n        view\\n        returns (\\n            int256 netPortfolioValue,\\n            int256 nTokenHaircutPrimeValue,\\n            bytes6 nTokenParameters\\n        )\\n    {\\n        // If the next asset matches the currency id then we need to calculate the cash group value\\n        if (\\n            factors.portfolioIndex < factors.portfolio.length &&\\n            factors.portfolio[factors.portfolioIndex].currencyId == factors.cashGroup.currencyId\\n        ) {\\n            // netPortfolioValue is in asset cash\\n            (netPortfolioValue, factors.portfolioIndex) = AssetHandler.getNetCashGroupValue(\\n                factors.portfolio,\\n                factors.cashGroup,\\n                blockTime,\\n                factors.portfolioIndex\\n            );\\n        } else {\\n            netPortfolioValue = 0;\\n        }\\n\\n        if (nTokenBalance > 0) {\\n            (nTokenHaircutPrimeValue, nTokenParameters) = _getNTokenHaircutPrimePV(\\n                factors.cashGroup,\\n                factors.nToken,\\n                nTokenBalance,\\n                blockTime\\n            );\\n        } else {\\n            nTokenHaircutPrimeValue = 0;\\n            nTokenParameters = 0;\\n        }\\n    }\\n\\n    /// @notice Returns balance values for the bitmapped currency\\n    function _getBitmapBalanceValue(\\n        address account,\\n        uint256 blockTime,\\n        AccountContext memory accountContext,\\n        FreeCollateralFactors memory factors\\n    )\\n        private\\n        view\\n        returns (\\n            int256 cashBalance,\\n            int256 nTokenHaircutPrimeValue,\\n            bytes6 nTokenParameters\\n        )\\n    {\\n        int256 nTokenBalance;\\n        // prettier-ignore\\n        (\\n            cashBalance,\\n            nTokenBalance, \\n            /* lastClaimTime */,\\n            /* accountIncentiveDebt */\\n        ) = BalanceHandler.getBalanceStorage(\\n            account,\\n            accountContext.bitmapCurrencyId,\\n            factors.cashGroup.primeRate\\n        );\\n\\n        if (nTokenBalance > 0) {\\n            (nTokenHaircutPrimeValue, nTokenParameters) = _getNTokenHaircutPrimePV(\\n                factors.cashGroup,\\n                factors.nToken,\\n                nTokenBalance,\\n                blockTime\\n            );\\n        } else {\\n            nTokenHaircutPrimeValue = 0;\\n        }\\n    }\\n\\n    /// @notice Returns portfolio value for the bitmapped currency\\n    function _getBitmapPortfolioValue(\\n        address account,\\n        uint256 blockTime,\\n        AccountContext memory accountContext,\\n        FreeCollateralFactors memory factors\\n    ) private view returns (int256) {\\n        (int256 netPortfolioValueUnderlying, bool bitmapHasDebt) =\\n            BitmapAssetsHandler.getifCashNetPresentValue(\\n                account,\\n                accountContext.bitmapCurrencyId,\\n                accountContext.nextSettleTime,\\n                blockTime,\\n                factors.cashGroup,\\n                true // risk adjusted\\n            );\\n\\n        // Turns off has debt flag if it has changed\\n        bool contextHasAssetDebt =\\n            accountContext.hasDebt & Constants.HAS_ASSET_DEBT == Constants.HAS_ASSET_DEBT;\\n        if (bitmapHasDebt && !contextHasAssetDebt) {\\n            // Turn on has debt\\n            accountContext.hasDebt = accountContext.hasDebt | Constants.HAS_ASSET_DEBT;\\n            factors.updateContext = true;\\n        } else if (!bitmapHasDebt && contextHasAssetDebt) {\\n            // Turn off has debt\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_ASSET_DEBT;\\n            factors.updateContext = true;\\n        }\\n\\n        // Return asset cash value\\n        return factors.cashGroup.primeRate.convertFromUnderlying(netPortfolioValueUnderlying);\\n    }\\n\\n    function _updateNetETHValue(\\n        uint256 currencyId,\\n        int256 netLocalAssetValue,\\n        FreeCollateralFactors memory factors\\n    ) private view returns (ETHRate memory) {\\n        ETHRate memory ethRate = ExchangeRate.buildExchangeRate(currencyId);\\n        // Converts to underlying first, ETH exchange rates are in underlying\\n        factors.netETHValue = factors.netETHValue.add(\\n            ethRate.convertToETH(factors.primeRate.convertToUnderlying(netLocalAssetValue))\\n        );\\n\\n        return ethRate;\\n    }\\n\\n    /// @notice Stateful version of get free collateral, returns the total net ETH value and true or false if the account\\n    /// context needs to be updated.\\n    function getFreeCollateralStateful(\\n        address account,\\n        AccountContext memory accountContext,\\n        uint256 blockTime\\n    ) internal returns (int256, bool) {\\n        FreeCollateralFactors memory factors;\\n        bool hasCashDebt;\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            factors.cashGroup = CashGroup.buildCashGroupStateful(accountContext.bitmapCurrencyId);\\n\\n            // prettier-ignore\\n            (\\n                int256 netCashBalance,\\n                int256 nTokenHaircutPrimeValue,\\n                /* nTokenParameters */\\n            ) = _getBitmapBalanceValue(account, blockTime, accountContext, factors);\\n            if (netCashBalance < 0) hasCashDebt = true;\\n\\n            int256 portfolioAssetValue =\\n                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);\\n            int256 netLocalAssetValue =\\n                netCashBalance.add(nTokenHaircutPrimeValue).add(portfolioAssetValue);\\n\\n            factors.primeRate = factors.cashGroup.primeRate;\\n            _updateNetETHValue(accountContext.bitmapCurrencyId, netLocalAssetValue, factors);\\n        } else {\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\n                account,\\n                accountContext.assetArrayLength\\n            );\\n        }\\n\\n        bytes18 currencies = accountContext.activeCurrencies;\\n        while (currencies != 0) {\\n            bytes2 currencyBytes = bytes2(currencies);\\n            uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\n            // Explicitly ensures that bitmap currency cannot be double counted\\n            require(currencyId != accountContext.bitmapCurrencyId);\\n\\n            factors.primeRate = PrimeRateLib.buildPrimeRateStateful(currencyId);\\n            \\n            (int256 netLocalAssetValue, int256 nTokenBalance) =\\n                _getCurrencyBalances(account, currencyBytes, factors.primeRate);\\n            if (netLocalAssetValue < 0) hasCashDebt = true;\\n\\n            if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {\\n                factors.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\n\\n                // prettier-ignore\\n                (\\n                    int256 netPortfolioAssetValue,\\n                    int256 nTokenHaircutPrimeValue,\\n                    /* nTokenParameters */\\n                ) = _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);\\n                netLocalAssetValue = netLocalAssetValue\\n                    .add(netPortfolioAssetValue)\\n                    .add(nTokenHaircutPrimeValue);\\n            }\\n\\n            _updateNetETHValue(currencyId, netLocalAssetValue, factors);\\n            currencies = currencies << 16;\\n        }\\n\\n        // Free collateral is the only method that examines all cash balances for an account at once. If there is no cash debt (i.e.\\n        // they have been repaid or settled via more debt) then this will turn off the flag. It's possible that this flag is out of\\n        // sync temporarily after a cash settlement and before the next free collateral check. The only downside for that is forcing\\n        // an account to do an extra free collateral check to turn off this setting.\\n        if (\\n            accountContext.hasDebt & Constants.HAS_CASH_DEBT == Constants.HAS_CASH_DEBT &&\\n            !hasCashDebt\\n        ) {\\n            accountContext.hasDebt = accountContext.hasDebt & ~Constants.HAS_CASH_DEBT;\\n            factors.updateContext = true;\\n        }\\n\\n        return (factors.netETHValue, factors.updateContext);\\n    }\\n\\n    /// @notice View version of getFreeCollateral, does not use the stateful version of build cash group and skips\\n    /// all the update context logic.\\n    function getFreeCollateralView(\\n        address account,\\n        AccountContext memory accountContext,\\n        uint256 blockTime\\n    ) internal view returns (int256, int256[] memory) {\\n        FreeCollateralFactors memory factors;\\n        uint256 netLocalIndex;\\n        int256[] memory netLocalAssetValues = new int256[](10);\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            factors.cashGroup = CashGroup.buildCashGroupView(accountContext.bitmapCurrencyId);\\n\\n            // prettier-ignore\\n            (\\n                int256 netCashBalance,\\n                int256 nTokenHaircutPrimeValue,\\n                /* nTokenParameters */\\n            ) = _getBitmapBalanceValue(account, blockTime, accountContext, factors);\\n            int256 portfolioAssetValue =\\n                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);\\n\\n            netLocalAssetValues[netLocalIndex] = netCashBalance\\n                .add(nTokenHaircutPrimeValue)\\n                .add(portfolioAssetValue);\\n            factors.primeRate = factors.cashGroup.primeRate;\\n            _updateNetETHValue(\\n                accountContext.bitmapCurrencyId,\\n                netLocalAssetValues[netLocalIndex],\\n                factors\\n            );\\n\\n            netLocalIndex++;\\n        } else {\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\n                account,\\n                accountContext.assetArrayLength\\n            );\\n        }\\n\\n        bytes18 currencies = accountContext.activeCurrencies;\\n        while (currencies != 0) {\\n            bytes2 currencyBytes = bytes2(currencies);\\n            uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\n            // Explicitly ensures that bitmap currency cannot be double counted\\n            require(currencyId != accountContext.bitmapCurrencyId);\\n            int256 nTokenBalance;\\n            (factors.primeRate, /* */) = PrimeCashExchangeRate.getPrimeCashRateView(currencyId, blockTime);\\n\\n            (netLocalAssetValues[netLocalIndex], nTokenBalance) = _getCurrencyBalances(\\n                account,\\n                currencyBytes,\\n                factors.primeRate\\n            );\\n\\n            if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {\\n                factors.cashGroup = CashGroup.buildCashGroupView(currencyId);\\n                // prettier-ignore\\n                (\\n                    int256 netPortfolioValue,\\n                    int256 nTokenHaircutPrimeValue,\\n                    /* nTokenParameters */\\n                ) = _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);\\n\\n                netLocalAssetValues[netLocalIndex] = netLocalAssetValues[netLocalIndex]\\n                    .add(netPortfolioValue)\\n                    .add(nTokenHaircutPrimeValue);\\n            }\\n\\n            _updateNetETHValue(currencyId, netLocalAssetValues[netLocalIndex], factors);\\n            netLocalIndex++;\\n            currencies = currencies << 16;\\n        }\\n\\n        return (factors.netETHValue, netLocalAssetValues);\\n    }\\n\\n    /// @notice Calculates the net value of a currency within a portfolio, this is a bit\\n    /// convoluted to fit into the stack frame\\n    function _calculateLiquidationAssetValue(\\n        FreeCollateralFactors memory factors,\\n        LiquidationFactors memory liquidationFactors,\\n        bytes2 currencyBytes,\\n        bool setLiquidationFactors,\\n        uint256 blockTime\\n    ) private returns (int256) {\\n        uint16 currencyId = uint16(currencyBytes & Constants.UNMASK_FLAGS);\\n        factors.primeRate = PrimeRateLib.buildPrimeRateStateful(currencyId);\\n        (int256 netLocalAssetValue, int256 nTokenBalance) =\\n            _getCurrencyBalances(liquidationFactors.account, currencyBytes, factors.primeRate);\\n\\n        if (_isActiveInPortfolio(currencyBytes) || nTokenBalance > 0) {\\n            factors.cashGroup = CashGroup.buildCashGroupStateful(currencyId);\\n            (int256 netPortfolioValue, int256 nTokenHaircutPrimeValue, bytes6 nTokenParameters) =\\n                _getPortfolioAndNTokenAssetValue(factors, nTokenBalance, blockTime);\\n\\n            netLocalAssetValue = netLocalAssetValue\\n                .add(netPortfolioValue)\\n                .add(nTokenHaircutPrimeValue);\\n\\n            // If collateralCurrencyId is set to zero then this is a local currency liquidation\\n            if (setLiquidationFactors) {\\n                liquidationFactors.collateralCashGroup = factors.cashGroup;\\n                liquidationFactors.nTokenParameters = nTokenParameters;\\n                liquidationFactors.nTokenHaircutPrimeValue = nTokenHaircutPrimeValue;\\n            }\\n        }\\n\\n        return netLocalAssetValue;\\n    }\\n\\n    /// @notice A version of getFreeCollateral used during liquidation to save off necessary additional information.\\n    function getLiquidationFactors(\\n        address account,\\n        AccountContext memory accountContext,\\n        uint256 blockTime,\\n        uint256 localCurrencyId,\\n        uint256 collateralCurrencyId\\n    ) internal returns (LiquidationFactors memory, PortfolioAsset[] memory) {\\n        FreeCollateralFactors memory factors;\\n        LiquidationFactors memory liquidationFactors;\\n        // This is only set to reduce the stack size\\n        liquidationFactors.account = account;\\n\\n        if (accountContext.isBitmapEnabled()) {\\n            factors.cashGroup = CashGroup.buildCashGroupStateful(accountContext.bitmapCurrencyId);\\n            (int256 netCashBalance, int256 nTokenHaircutPrimeValue, bytes6 nTokenParameters) =\\n                _getBitmapBalanceValue(account, blockTime, accountContext, factors);\\n            int256 portfolioBalance =\\n                _getBitmapPortfolioValue(account, blockTime, accountContext, factors);\\n\\n            int256 netLocalAssetValue =\\n                netCashBalance.add(nTokenHaircutPrimeValue).add(portfolioBalance);\\n            factors.primeRate = factors.cashGroup.primeRate;\\n            ETHRate memory ethRate =\\n                _updateNetETHValue(accountContext.bitmapCurrencyId, netLocalAssetValue, factors);\\n\\n            // If the bitmap currency id can only ever be the local currency where debt is held.\\n            // During enable bitmap we check that the account has no assets in their portfolio and\\n            // no cash debts.\\n            if (accountContext.bitmapCurrencyId == localCurrencyId) {\\n                liquidationFactors.localPrimeAvailable = netLocalAssetValue;\\n                liquidationFactors.localETHRate = ethRate;\\n                liquidationFactors.localPrimeRate = factors.primeRate;\\n\\n                // This will be the case during local currency or local fCash liquidation\\n                if (collateralCurrencyId == 0) {\\n                    // If this is local fCash liquidation, the cash group information is required\\n                    // to calculate fCash haircuts and buffers.\\n                    liquidationFactors.collateralCashGroup = factors.cashGroup;\\n                    liquidationFactors.nTokenHaircutPrimeValue = nTokenHaircutPrimeValue;\\n                    liquidationFactors.nTokenParameters = nTokenParameters;\\n                }\\n            }\\n        } else {\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\n                account,\\n                accountContext.assetArrayLength\\n            );\\n        }\\n\\n        bytes18 currencies = accountContext.activeCurrencies;\\n        while (currencies != 0) {\\n            bytes2 currencyBytes = bytes2(currencies);\\n\\n            // This next bit of code here is annoyingly structured to get around stack size issues\\n            bool setLiquidationFactors;\\n            {\\n                uint256 tempId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));\\n                // Explicitly ensures that bitmap currency cannot be double counted\\n                require(tempId != accountContext.bitmapCurrencyId);\\n                setLiquidationFactors =\\n                    (tempId == localCurrencyId && collateralCurrencyId == 0) ||\\n                    tempId == collateralCurrencyId;\\n            }\\n            int256 netLocalAssetValue =\\n                _calculateLiquidationAssetValue(\\n                    factors,\\n                    liquidationFactors,\\n                    currencyBytes,\\n                    setLiquidationFactors,\\n                    blockTime\\n                );\\n\\n            uint256 currencyId = uint256(uint16(currencyBytes & Constants.UNMASK_FLAGS));\\n            ETHRate memory ethRate = _updateNetETHValue(currencyId, netLocalAssetValue, factors);\\n\\n            if (currencyId == collateralCurrencyId) {\\n                // Ensure that this is set even if the cash group is not loaded, it will not be\\n                // loaded if the account only has a cash balance and no nTokens or assets\\n                liquidationFactors.collateralCashGroup.primeRate = factors.primeRate;\\n                liquidationFactors.collateralAssetAvailable = netLocalAssetValue;\\n                liquidationFactors.collateralETHRate = ethRate;\\n            } else if (currencyId == localCurrencyId) {\\n                // This branch will not be entered if bitmap is enabled\\n                liquidationFactors.localPrimeAvailable = netLocalAssetValue;\\n                liquidationFactors.localETHRate = ethRate;\\n                liquidationFactors.localPrimeRate = factors.primeRate;\\n                // If this is local fCash liquidation, the cash group information is required\\n                // to calculate fCash haircuts and buffers and it will have been set in\\n                // _calculateLiquidationAssetValue above because the account must have fCash assets,\\n                // there is no need to set cash group in this branch.\\n            }\\n\\n            currencies = currencies << 16;\\n        }\\n\\n        liquidationFactors.netETHValue = factors.netETHValue;\\n        require(liquidationFactors.netETHValue < 0, \\\"Sufficient collateral\\\");\\n\\n        // Refetch the portfolio if it exists, AssetHandler.getNetCashValue updates values in memory to do fCash\\n        // netting which will make further calculations incorrect.\\n        if (accountContext.assetArrayLength > 0) {\\n            factors.portfolio = PortfolioHandler.getSortedPortfolio(\\n                account,\\n                accountContext.assetArrayLength\\n            );\\n        }\\n\\n        return (liquidationFactors, factors.portfolio);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity 0.7.6;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /*\\n   * Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /*\\n   * Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    return int64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    require (x <= 0x7FFFFFFFFFFFFFFF);\\n    return int128 (x << 64);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    require (x >= 0);\\n    return uint64 (x >> 64);\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    int256 result = x >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    return int256 (x) << 64;\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) + y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) - y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    int256 result = int256(x) * y >> 64;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    if (x == MIN_64x64) {\\n      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n        y <= 0x1000000000000000000000000000000000000000000000000);\\n      return -y << 63;\\n    } else {\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x;\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint256 absoluteResult = mulu (x, uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <=\\n          0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <=\\n          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (absoluteResult);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    if (y == 0) return 0;\\n\\n    require (x >= 0);\\n\\n    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n    uint256 hi = uint256 (x) * (y >> 128);\\n\\n    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    hi <<= 64;\\n\\n    require (hi <=\\n      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n    return hi + lo;\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    require (y != 0);\\n    int256 result = (int256 (x) << 64) / y;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    require (y != 0);\\n\\n    bool negativeResult = false;\\n    if (x < 0) {\\n      x = -x; // We rely on overflow behavior here\\n      negativeResult = true;\\n    }\\n    if (y < 0) {\\n      y = -y; // We rely on overflow behavior here\\n      negativeResult = !negativeResult;\\n    }\\n    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n    if (negativeResult) {\\n      require (absoluteResult <= 0x80000000000000000000000000000000);\\n      return -int128 (absoluteResult); // We rely on overflow behavior here\\n    } else {\\n      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return int128 (absoluteResult); // We rely on overflow behavior here\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    require (y != 0);\\n    uint128 result = divuu (x, y);\\n    require (result <= uint128 (MAX_64x64));\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return -x;\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    require (x != MIN_64x64);\\n    return x < 0 ? -x : x;\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    require (x != 0);\\n    int256 result = int256 (0x100000000000000000000000000000000) / x;\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    return int128 ((int256 (x) + int256 (y)) >> 1);\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    int256 m = int256 (x) * int256 (y);\\n    require (m >= 0);\\n    require (m <\\n        0x4000000000000000000000000000000000000000000000000000000000000000);\\n    return int128 (sqrtu (uint256 (m)));\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    bool negative = x < 0 && y & 1 == 1;\\n\\n    uint256 absX = uint128 (x < 0 ? -x : x);\\n    uint256 absResult;\\n    absResult = 0x100000000000000000000000000000000;\\n\\n    if (absX <= 0x10000000000000000) {\\n      absX <<= 63;\\n      while (y != 0) {\\n        if (y & 0x1 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        if (y & 0x2 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        if (y & 0x4 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        if (y & 0x8 != 0) {\\n          absResult = absResult * absX >> 127;\\n        }\\n        absX = absX * absX >> 127;\\n\\n        y >>= 4;\\n      }\\n\\n      absResult >>= 64;\\n    } else {\\n      uint256 absXShift = 63;\\n      if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\n      if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\n      if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\n      if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\n      if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\n      if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\n\\n      uint256 resultShift = 0;\\n      while (y != 0) {\\n        require (absXShift < 64);\\n\\n        if (y & 0x1 != 0) {\\n          absResult = absResult * absX >> 127;\\n          resultShift += absXShift;\\n          if (absResult > 0x100000000000000000000000000000000) {\\n            absResult >>= 1;\\n            resultShift += 1;\\n          }\\n        }\\n        absX = absX * absX >> 127;\\n        absXShift <<= 1;\\n        if (absX >= 0x100000000000000000000000000000000) {\\n            absX >>= 1;\\n            absXShift += 1;\\n        }\\n\\n        y >>= 1;\\n      }\\n\\n      require (resultShift < 64);\\n      absResult >>= 64 - resultShift;\\n    }\\n    int256 result = negative ? -int256 (absResult) : int256 (absResult);\\n    require (result >= MIN_64x64 && result <= MAX_64x64);\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    require (x >= 0);\\n    return int128 (sqrtu (uint256 (x) << 64));\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    int256 msb = 0;\\n    int256 xc = x;\\n    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n    if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n    if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n    if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n    int256 result = msb - 64 << 64;\\n    uint256 ux = uint256 (x) << uint256 (127 - msb);\\n    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n      ux *= ux;\\n      uint256 b = ux >> 255;\\n      ux >>= 127 + b;\\n      result += bit * int256 (b);\\n    }\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    require (x > 0);\\n\\n    return int128 (\\n        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    uint256 result = 0x80000000000000000000000000000000;\\n\\n    if (x & 0x8000000000000000 > 0)\\n      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n    if (x & 0x4000000000000000 > 0)\\n      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n    if (x & 0x2000000000000000 > 0)\\n      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n    if (x & 0x1000000000000000 > 0)\\n      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n    if (x & 0x800000000000000 > 0)\\n      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n    if (x & 0x400000000000000 > 0)\\n      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n    if (x & 0x200000000000000 > 0)\\n      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n    if (x & 0x100000000000000 > 0)\\n      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n    if (x & 0x80000000000000 > 0)\\n      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n    if (x & 0x40000000000000 > 0)\\n      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n    if (x & 0x20000000000000 > 0)\\n      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n    if (x & 0x10000000000000 > 0)\\n      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n    if (x & 0x8000000000000 > 0)\\n      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n    if (x & 0x4000000000000 > 0)\\n      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n    if (x & 0x2000000000000 > 0)\\n      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n    if (x & 0x1000000000000 > 0)\\n      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n    if (x & 0x800000000000 > 0)\\n      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n    if (x & 0x400000000000 > 0)\\n      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n    if (x & 0x200000000000 > 0)\\n      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n    if (x & 0x100000000000 > 0)\\n      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n    if (x & 0x80000000000 > 0)\\n      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n    if (x & 0x40000000000 > 0)\\n      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n    if (x & 0x20000000000 > 0)\\n      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n    if (x & 0x10000000000 > 0)\\n      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n    if (x & 0x8000000000 > 0)\\n      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n    if (x & 0x4000000000 > 0)\\n      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n    if (x & 0x2000000000 > 0)\\n      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n    if (x & 0x1000000000 > 0)\\n      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n    if (x & 0x800000000 > 0)\\n      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n    if (x & 0x400000000 > 0)\\n      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n    if (x & 0x200000000 > 0)\\n      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n    if (x & 0x100000000 > 0)\\n      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n    if (x & 0x80000000 > 0)\\n      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n    if (x & 0x40000000 > 0)\\n      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n    if (x & 0x20000000 > 0)\\n      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n    if (x & 0x10000000 > 0)\\n      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n    if (x & 0x8000000 > 0)\\n      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n    if (x & 0x4000000 > 0)\\n      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n    if (x & 0x2000000 > 0)\\n      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n    if (x & 0x1000000 > 0)\\n      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n    if (x & 0x800000 > 0)\\n      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n    if (x & 0x400000 > 0)\\n      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n    if (x & 0x200000 > 0)\\n      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n    if (x & 0x100000 > 0)\\n      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n    if (x & 0x80000 > 0)\\n      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n    if (x & 0x40000 > 0)\\n      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n    if (x & 0x20000 > 0)\\n      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n    if (x & 0x10000 > 0)\\n      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n    if (x & 0x8000 > 0)\\n      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n    if (x & 0x4000 > 0)\\n      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n    if (x & 0x2000 > 0)\\n      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n    if (x & 0x1000 > 0)\\n      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n    if (x & 0x800 > 0)\\n      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n    if (x & 0x400 > 0)\\n      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n    if (x & 0x200 > 0)\\n      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n    if (x & 0x100 > 0)\\n      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n    if (x & 0x80 > 0)\\n      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n    if (x & 0x40 > 0)\\n      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n    if (x & 0x20 > 0)\\n      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n    if (x & 0x10 > 0)\\n      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n    if (x & 0x8 > 0)\\n      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n    if (x & 0x4 > 0)\\n      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n    if (x & 0x2 > 0)\\n      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n    if (x & 0x1 > 0)\\n      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n    result >>= uint256 (63 - (x >> 64));\\n    require (result <= uint256 (MAX_64x64));\\n\\n    return int128 (result);\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    require (x < 0x400000000000000000); // Overflow\\n\\n    if (x < -0x400000000000000000) return 0; // Underflow\\n\\n    return exp_2 (\\n        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    require (y != 0);\\n\\n    uint256 result;\\n\\n    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n      result = (x << 64) / y;\\n    else {\\n      uint256 msb = 192;\\n      uint256 xc = x >> 192;\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 hi = result * (y >> 128);\\n      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n      uint256 xh = x >> 192;\\n      uint256 xl = x << 64;\\n\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n      lo = hi << 128;\\n      if (xl < lo) xh -= 1;\\n      xl -= lo; // We rely on overflow behavior here\\n\\n      assert (xh == hi >> 128);\\n\\n      result += xl / y;\\n    }\\n\\n    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    return uint128 (result);\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\n    if (x == 0) return 0;\\n    else {\\n      uint256 xx = x;\\n      uint256 r = 1;\\n      if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\n      if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\n      if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\n      if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\n      if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\n      if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\n      if (xx >= 0x8) { r <<= 1; }\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1;\\n      r = (r + x / r) >> 1; // Seven iterations should be enough\\n      uint256 r1 = x / r;\\n      return uint128 (r < r1 ? r : r1);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/math/Bitmap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\npragma abicoder v2;\\n\\nimport {Constants} from \\\"../global/Constants.sol\\\";\\n\\n/// @notice Helper methods for bitmaps, they are big-endian and 1-indexed.\\nlibrary Bitmap {\\n\\n    /// @notice Set a bit on or off in a bitmap, index is 1-indexed\\n    function setBit(\\n        bytes32 bitmap,\\n        uint256 index,\\n        bool setOn\\n    ) internal pure returns (bytes32) {\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\n\\n        if (setOn) {\\n            return bitmap | (Constants.MSB >> (index - 1));\\n        } else {\\n            return bitmap & ~(Constants.MSB >> (index - 1));\\n        }\\n    }\\n\\n    /// @notice Check if a bit is set\\n    function isBitSet(bytes32 bitmap, uint256 index) internal pure returns (bool) {\\n        require(index >= 1 && index <= 256); // dev: set bit index bounds\\n        return ((bitmap << (index - 1)) & Constants.MSB) == Constants.MSB;\\n    }\\n\\n    /// @notice Count the total bits set\\n    function totalBitsSet(bytes32 bitmap) internal pure returns (uint256) {\\n        uint256 x = uint256(bitmap);\\n        x = (x & 0x5555555555555555555555555555555555555555555555555555555555555555) + (x >> 1 & 0x5555555555555555555555555555555555555555555555555555555555555555);\\n        x = (x & 0x3333333333333333333333333333333333333333333333333333333333333333) + (x >> 2 & 0x3333333333333333333333333333333333333333333333333333333333333333);\\n        x = (x & 0x0707070707070707070707070707070707070707070707070707070707070707) + (x >> 4);\\n        x = (x & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F) + (x >> 8 & 0x000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F);\\n        x = x + (x >> 16);\\n        x = x + (x >> 32);\\n        x = x  + (x >> 64);\\n        return (x & 0xFF) + (x >> 128 & 0xFF);\\n    }\\n\\n    // Does a binary search over x to get the position of the most significant bit\\n    function getMSB(uint256 x) internal pure returns (uint256 msb) {\\n        // If x == 0 then there is no MSB and this method will return zero. That would\\n        // be the same as the return value when x == 1 (MSB is zero indexed), so instead\\n        // we have this require here to ensure that the values don't get mixed up.\\n        require(x != 0); // dev: get msb zero value\\n        if (x >= 0x100000000000000000000000000000000) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 0x10000000000000000) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 0x100000000) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 0x10000) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 0x100) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 0x10) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 0x4) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 0x2) msb += 1; // No need to shift xc anymore\\n    }\\n\\n    /// @dev getMSB returns a zero indexed bit number where zero is the first bit counting\\n    /// from the right (little endian). Asset Bitmaps are counted from the left (big endian)\\n    /// and one indexed.\\n    function getNextBitNum(bytes32 bitmap) internal pure returns (uint256 bitNum) {\\n        // Short circuit the search if bitmap is all zeros\\n        if (bitmap == 0x00) return 0;\\n\\n        return 255 - getMSB(uint256(bitmap)) + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/FloatingPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\n\\nimport {Bitmap} from \\\"./Bitmap.sol\\\";\\nimport {SafeInt256} from \\\"./SafeInt256.sol\\\";\\nimport {SafeUint256} from \\\"./SafeUint256.sol\\\";\\n\\n/**\\n * Packs an uint value into a \\\"floating point\\\" storage slot. Used for storing\\n * lastClaimIntegralSupply values in balance storage. For these values, we don't need\\n * to maintain exact precision but we don't want to be limited by storage size overflows.\\n *\\n * A floating point value is defined by the 48 most significant bits and an 8 bit number\\n * of bit shifts required to restore its precision. The unpacked value will always be less\\n * than the packed value with a maximum absolute loss of precision of (2 ** bitShift) - 1.\\n */\\nlibrary FloatingPoint {\\n    using SafeInt256 for int256;\\n    using SafeUint256 for uint256;\\n\\n    function packTo56Bits(uint256 value) internal pure returns (uint56) {\\n        uint256 bitShift;\\n        // If the value is over the uint48 max value then we will shift it down\\n        // given the index of the most significant bit. We store this bit shift \\n        // in the least significant byte of the 56 bit slot available.\\n        if (value > type(uint48).max) bitShift = (Bitmap.getMSB(value) - 47);\\n\\n        uint256 shiftedValue = value >> bitShift;\\n        return uint56((shiftedValue << 8) | bitShift);\\n    }\\n\\n    function packTo32Bits(uint256 value) internal pure returns (uint32) {\\n        uint256 bitShift;\\n        // If the value is over the uint24 max value then we will shift it down\\n        // given the index of the most significant bit. We store this bit shift \\n        // in the least significant byte of the 32 bit slot available.\\n        if (value > type(uint24).max) bitShift = (Bitmap.getMSB(value) - 23);\\n\\n        uint256 shiftedValue = value >> bitShift;\\n        return uint32((shiftedValue << 8) | bitShift);\\n    }\\n\\n    function unpackFromBits(uint256 value) internal pure returns (uint256) {\\n        // The least significant 8 bits will be the amount to bit shift\\n        uint256 bitShift = uint256(uint8(value));\\n        return ((value >> 8) << bitShift);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/SafeInt256.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\n\\nimport {Constants} from \\\"../global/Constants.sol\\\";\\n\\nlibrary SafeInt256 {\\n    int256 private constant _INT256_MIN = type(int256).min;\\n\\n    /// @dev Returns the multiplication of two signed integers, reverting on\\n    /// overflow.\\n\\n    /// Counterpart to Solidity's `*` operator.\\n\\n    /// Requirements:\\n\\n    /// - Multiplication cannot overflow.\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a * b;\\n        if (a == -1) require (b == 0 || c / b == a);\\n        else require (a == 0 || c / a == b);\\n    }\\n\\n    /// @dev Returns the integer division of two signed integers. Reverts on\\n    /// division by zero. The result is rounded towards zero.\\n\\n    /// Counterpart to Solidity's `/` operator. Note: this function uses a\\n    /// `revert` opcode (which leaves remaining gas untouched) while Solidity\\n    /// uses an invalid opcode to revert (consuming all remaining gas).\\n\\n    /// Requirements:\\n\\n    /// - The divisor cannot be zero.\\n\\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\\n        // NOTE: solidity will automatically revert on divide by zero\\n        c = a / b;\\n    }\\n\\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\\n        //  taken from uniswap v3\\n        require((z = x - y) <= x == (y >= 0));\\n    }\\n\\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x + y) >= x == (y >= 0));\\n    }\\n\\n    function neg(int256 x) internal pure returns (int256 y) {\\n        return mul(-1, x);\\n    }\\n\\n    function abs(int256 x) internal pure returns (int256) {\\n        if (x < 0) return neg(x);\\n        else return x;\\n    }\\n\\n    function subNoNeg(int256 x, int256 y) internal pure returns (int256 z) {\\n        z = sub(x, y);\\n        require(z >= 0); // dev: int256 sub to negative\\n\\n        return z;\\n    }\\n\\n    /// @dev Calculates x * RATE_PRECISION / y while checking overflows\\n    function divInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\n        return div(mul(x, Constants.RATE_PRECISION), y);\\n    }\\n\\n    /// @dev Calculates x * y / RATE_PRECISION while checking overflows\\n    function mulInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\n        return div(mul(x, y), Constants.RATE_PRECISION);\\n    }\\n\\n    function toUint(int256 x) internal pure returns (uint256) {\\n        require(x >= 0);\\n        return uint256(x);\\n    }\\n\\n    function toInt(uint256 x) internal pure returns (int256) {\\n        require (x <= uint256(type(int256).max)); // dev: toInt overflow\\n        return int256(x);\\n    }\\n\\n    function toInt80(int256 x) internal pure returns (int80) {\\n        require (int256(type(int80).min) <= x && x <= int256(type(int80).max)); // dev: toInt overflow\\n        return int80(x);\\n    }\\n\\n    function toInt88(int256 x) internal pure returns (int88) {\\n        require (int256(type(int88).min) <= x && x <= int256(type(int88).max)); // dev: toInt overflow\\n        return int88(x);\\n    }\\n\\n    function toInt128(int256 x) internal pure returns (int128) {\\n        require (int256(type(int128).min) <= x && x <= int256(type(int128).max)); // dev: toInt overflow\\n        return int128(x);\\n    }\\n\\n    function max(int256 x, int256 y) internal pure returns (int256) {\\n        return x > y ? x : y;\\n    }\\n\\n    function min(int256 x, int256 y) internal pure returns (int256) {\\n        return x < y ? x : y;\\n    }\\n\\n    /// @notice Returns the net change in negative signed values, used for\\n    /// determining the (positive) amount of debt change\\n    function negChange(int256 start, int256 end) internal pure returns (int256) {\\n        // No change in these two scenarios\\n        if (start == end || (start >= 0 && end >= 0)) return 0;\\n        if (start <= 0 && 0 < end) {\\n            // Negative portion has been eliminated so the net change on the\\n            // negative side is start (i.e. a reduction in the negative balance)\\n            return start;\\n        } else if (end <= 0 && 0 < start) {\\n            // Entire negative portion has been created so the net change on the\\n            // negative side is -end (i.e. an increase in the negative balance)\\n            return neg(end);\\n        } else if (start <= 0 && end <= 0) {\\n            // There is some net change in the negative amounts.\\n            // If start < end then this is negative, debt has been reduced\\n            // If end < start then this is positive, debt has been increased\\n            return sub(start, end);\\n        }\\n\\n        // Should never get to this point\\n        revert();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/math/SafeUint256.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity =0.7.6;\\n\\nimport {Constants} from \\\"../global/Constants.sol\\\";\\n\\nlibrary SafeUint256 {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b);\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0);\\n        return a / b;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? x : y;\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x < y ? x : y;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0);\\n        return a % b;\\n    }\\n\\n    function divInRatePrecision(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return div(mul(x, uint256(Constants.RATE_PRECISION)), y);\\n    }\\n\\n    function mulInRatePrecision(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return div(mul(x, y), uint256(Constants.RATE_PRECISION));\\n    }\\n\\n    function divInScalarPrecision(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return div(mul(x, Constants.SCALAR_PRECISION), y);\\n    }\\n\\n    function mulInScalarPrecision(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return div(mul(x, y), Constants.SCALAR_PRECISION);\\n    }\\n\\n    function toUint8(uint256 x) internal pure returns (uint8) {\\n        require(x <= type(uint8).max);\\n        return uint8(x);\\n    }\\n\\n    function toUint32(uint256 x) internal pure returns (uint32) {\\n        require(x <= type(uint32).max);\\n        return uint32(x);\\n    }\\n\\n    function toUint40(uint256 x) internal pure returns (uint40) {\\n        require(x <= type(uint40).max);\\n        return uint40(x);\\n    }\\n\\n    function toUint48(uint256 x) internal pure returns (uint48) {\\n        require(x <= type(uint48).max);\\n        return uint48(x);\\n    }\\n\\n    function toUint56(uint256 x) internal pure returns (uint56) {\\n        require(x <= type(uint56).max);\\n        return uint56(x);\\n    }\\n\\n    function toUint72(uint256 x) internal pure returns (uint72) {\\n        require(x <= type(uint72).max);\\n        return uint72(x);\\n    }\\n    \\n    function toUint80(uint256 x) internal pure returns (uint80) {\\n        require(x <= type(uint80).max);\\n        return uint80(x);\\n    }\\n\\n    function toUint88(uint256 x) internal pure returns (uint88) {\\n        require(x <= type(uint88).max);\\n        return uint88(x);\\n    }\\n\\n    function toUint104(uint256 x) internal pure returns (uint104) {\\n        require(x <= type(uint104).max);\\n        return uint104(x);\\n    }\\n\\n    function toUint112(uint256 x) internal pure returns (uint112) {\\n        require(x <= type(uint112).max);\\n        return uint112(x);\\n    }\\n\\n    function toUint128(uint256 x) internal pure returns (uint128) {\\n        require(x <= type(uint128).max);\\n        return uint128(x);\\n    }\\n\\n    function toInt(uint256 x) internal pure returns (int256) {\\n        require (x <= uint256(type(int256).max)); // dev: toInt overflow\\n        return int256(x);\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity >=0.7.6;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\\ninterface IUpgradeableBeacon is IBeacon {\\n    function upgradeTo(address newImplementation) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/aave/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nstruct LendingPoolStorage {\\n  ILendingPool lendingPool;\\n}\\n\\ninterface ILendingPool {\\n\\n  /**\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n   * @param asset The address of the underlying asset to deposit\\n   * @param amount The amount to be deposited\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n   *   is a different wallet\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n   *   0 if the action is executed directly by the user, without any middle-man\\n   **/\\n  function deposit(\\n    address asset,\\n    uint256 amount,\\n    address onBehalfOf,\\n    uint16 referralCode\\n  ) external;\\n\\n  /**\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n   * @param asset The address of the underlying asset to withdraw\\n   * @param amount The underlying amount to be withdrawn\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n   *   different wallet\\n   * @return The final amount withdrawn\\n   **/\\n  function withdraw(\\n    address asset,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Returns the normalized income normalized income of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The reserve's normalized income\\n   */\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\n\\n    /**\\n   * @dev Returns the state and configuration of the reserve\\n   * @param asset The address of the underlying asset of the reserve\\n   * @return The state of the reserve\\n   **/\\n  function getReserveData(address asset) external view returns (ReserveData memory);\\n\\n  struct ReserveData {\\n    ReserveConfigurationMap configuration;\\n    uint128 liquidityIndex;\\n    uint128 currentLiquidityRate;\\n    uint128 variableBorrowIndex;\\n    uint128 currentVariableBorrowRate;\\n    uint128 currentStableBorrowRate;\\n    uint40 lastUpdateTimestamp;\\n    uint16 id;\\n    address aTokenAddress;\\n    address stableDebtTokenAddress;\\n    address variableDebtTokenAddress;\\n    address interestRateStrategyAddress;\\n    uint128 accruedToTreasury;\\n    uint128 unbacked;\\n    uint128 isolationModeTotalDebt;\\n  }\\n\\n  struct ReserveConfigurationMap {\\n    //bit 0-15: LTV\\n    //bit 16-31: Liq. threshold\\n    //bit 32-47: Liq. bonus\\n    //bit 48-55: Decimals\\n    //bit 56: Reserve is active\\n    //bit 57: reserve is frozen\\n    //bit 58: borrowing is enabled\\n    //bit 59: stable rate borrowing enabled\\n    //bit 60-63: reserved\\n    //bit 64-79: reserve factor\\n    uint256 data;\\n  }\\n\\n  struct UserConfigurationMap {\\n    uint256 data;\\n  }\\n\\n  enum InterestRateMode {NONE, STABLE, VARIABLE}\\n}\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\n{\\n}\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\"\r\n    },\r\n    \"interfaces/compound/CErc20Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity >=0.7.6;\\n\\nimport \\\"./CTokenInterface.sol\\\";\\n\\ninterface CErc20Interface {\\n\\n    /*** User Interface ***/\\n\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeem(uint redeemTokens) external returns (uint);\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n    function borrow(uint borrowAmount) external returns (uint);\\n    function repayBorrow(uint repayAmount) external returns (uint);\\n    function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint);\\n    function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) external returns (uint);\\n}\\n\"\r\n    },\r\n    \"interfaces/compound/CEtherInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity >=0.7.6;\\n\\ninterface CEtherInterface {\\n    function mint() external payable;\\n}\"\r\n    },\r\n    \"interfaces/compound/CTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity >=0.7.6;\\n\\ninterface CTokenInterface {\\n\\n    /*** User Interface ***/\\n\\n    function underlying() external view returns (address);\\n    function totalSupply() external view returns (uint256);\\n    function transfer(address dst, uint amount) external returns (bool);\\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\\n    function approve(address spender, uint amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function balanceOfUnderlying(address owner) external returns (uint);\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\n    function borrowRatePerBlock() external view returns (uint);\\n    function supplyRatePerBlock() external view returns (uint);\\n    function totalBorrowsCurrent() external returns (uint);\\n    function borrowBalanceCurrent(address account) external returns (uint);\\n    function borrowBalanceStored(address account) external view returns (uint);\\n    function exchangeRateCurrent() external returns (uint);\\n    function exchangeRateStored() external view returns (uint);\\n    function getCash() external view returns (uint);\\n    function accrueInterest() external returns (uint);\\n    function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint);\\n    function accrualBlockNumber() external view returns (uint256);\\n    function totalBorrows() external view returns (uint256);\\n    function totalReserves() external view returns (uint256);\\n    function interestRateModel() external view returns (address);\\n    function reserveFactorMantissa() external view returns (uint256);\\n    function initialExchangeRateMantissa() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"interfaces/IEIP20NonStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\n\\n/**\\n * @title EIP20NonStandardInterface\\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\\n */\\ninterface IEIP20NonStandard {\\n\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @return The supply of tokens\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transfer(address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external;\\n\\n    ///\\n    /// !!!!!!!!!!!!!!\\n    /// !!! NOTICE !!! `approve` does not return a value, in violation of the ERC-20 specification\\n    /// !!!!!!!!!!!!!!\\n    ///\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved\\n      */\\n    function approve(address spender, uint256 amount) external;\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return remaining The number of tokens allowed to be spent\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\"\r\n    },\r\n    \"interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"interfaces/IERC4626.sol\": {\r\n      \"content\": \"pragma solidity >=0.7.6;\\n\\ninterface IERC4626 {\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\\n     *\\n     * - MUST be an ERC-20 token contract.\\n     * - MUST NOT revert.\\n     */\\n    function asset() external view returns (address assetTokenAddress);\\n\\n    /**\\n     * @dev Returns the total amount of the underlying asset that is \\\"managed\\\" by Vault.\\n     *\\n     * - SHOULD include any compounding that occurs from yield.\\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT revert.\\n     */\\n    function totalAssets() external view returns (uint256 totalManagedAssets);\\n\\n    /**\\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \\\"per-user\\\" price-per-share, and instead should reflect the\\n     * \\\"average-user's\\\" price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\\n     * scenario where all the conditions are met.\\n     *\\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\\n     * - MUST NOT show any variations depending on the caller.\\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: This calculation MAY NOT reflect the \\\"per-user\\\" price-per-share, and instead should reflect the\\n     * \\\"average-user's\\\" price-per-share, meaning what the average user should expect to see when exchanging to and\\n     * from.\\n     */\\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\\n     * through a deposit call.\\n     *\\n     * - MUST return a limited value if receiver is subject to some deposit limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\\n     * - MUST NOT revert.\\n     */\\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\\n     *   in the same transaction.\\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   deposit execution, and are accounted for during deposit.\\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\\n     * - MUST return a limited value if receiver is subject to some mint limit.\\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\\n     * - MUST NOT revert.\\n     */\\n    function maxMint(address receiver) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\\n     * current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\\n     *   same transaction.\\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\\n     */\\n    function previewMint(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\\n     *\\n     * - MUST emit the Deposit event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\\n     *   execution, and are accounted for during mint.\\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\\n     *   approving enough underlying tokens to the Vault contract, etc).\\n     *\\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault\u2019s underlying asset token.\\n     */\\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\\n\\n    /**\\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\\n     * Vault, through a withdraw call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\\n     *   called\\n     *   in the same transaction.\\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\\n     */\\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\\n\\n    /**\\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   withdraw execution, and are accounted for during withdraw.\\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 shares);\\n\\n    /**\\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\\n     * through a redeem call.\\n     *\\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\\n     * - MUST NOT revert.\\n     */\\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\\n\\n    /**\\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redemption at the current block,\\n     * given current on-chain conditions.\\n     *\\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\\n     *   same transaction.\\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\\n     * - MUST NOT revert.\\n     *\\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\\n     */\\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\\n\\n    /**\\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\\n     *\\n     * - MUST emit the Withdraw event.\\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\\n     *   redeem execution, and are accounted for during redeem.\\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\\n     *   not having enough shares, etc).\\n     *\\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\\n     * Those methods should be performed separately.\\n     */\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) external returns (uint256 assets);\\n}\\n\"\r\n    },\r\n    \"interfaces/notional/AssetRateAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.0;\\n\\n/// @notice Used as a wrapper for tokens that are interest bearing for an\\n/// underlying token. Follows the cToken interface, however, can be adapted\\n/// for other interest bearing tokens.\\ninterface AssetRateAdapter {\\n    function token() external view returns (address);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function description() external view returns (string memory);\\n\\n    function version() external view returns (uint256);\\n\\n    function underlying() external view returns (address);\\n\\n    function getExchangeRateStateful() external returns (int256);\\n\\n    function getExchangeRateView() external view returns (int256);\\n\\n    function getAnnualizedSupplyRate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"interfaces/notional/IPrimeCashHoldingsOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.0;\\npragma abicoder v2;\\n\\nstruct DepositData {\\n    address[] targets;\\n    bytes[] callData;\\n    uint256[] msgValue;\\n    uint256 underlyingDepositAmount;\\n    address assetToken;\\n    uint8 rebasingTokenBalanceAdjustment;\\n}\\n\\nstruct RedeemData {\\n    address[] targets;\\n    bytes[] callData;\\n    uint256 expectedUnderlying;\\n    address assetToken;\\n    uint8 rebasingTokenBalanceAdjustment;\\n}\\n\\nstruct OracleData {\\n    address holding;\\n    uint256 externalUnderlyingAvailableForWithdraw;\\n    uint256 currentExternalUnderlyingLend;\\n    uint256 maxExternalDeposit;\\n}\\n\\ninterface IPrimeCashHoldingsOracle {\\n    /// @notice Returns a list of the various holdings for the prime cash\\n    /// currency\\n    function holdings() external view returns (address[] memory);\\n\\n    /// @notice Returns the underlying token that all holdings can be redeemed\\n    /// for.\\n    function underlying() external view returns (address);\\n\\n    /// @notice Returns the native decimal precision of the underlying token\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the total underlying held by the caller in all the\\n    /// listed holdings\\n    function getTotalUnderlyingValueStateful() external returns (\\n        uint256 nativePrecision,\\n        uint256 internalPrecision\\n    );\\n\\n    function getTotalUnderlyingValueView() external view returns (\\n        uint256 nativePrecision,\\n        uint256 internalPrecision\\n    );\\n\\n    /// @notice Returns calldata for how to withdraw an amount\\n    function getRedemptionCalldata(uint256 withdrawAmount) external view returns (\\n        RedeemData[] memory redeemData\\n    );\\n\\n    function holdingValuesInUnderlying() external view returns (uint256[] memory);\\n\\n    function getRedemptionCalldataForRebalancing(\\n        address[] calldata _holdings, \\n        uint256[] calldata withdrawAmounts\\n    ) external view returns (\\n        RedeemData[] memory redeemData\\n    );\\n\\n    function getDepositCalldataForRebalancing(\\n        address[] calldata _holdings,\\n        uint256[] calldata depositAmounts\\n    ) external view returns (\\n        DepositData[] memory depositData\\n    );\\n\\n    function getOracleData() external view returns (OracleData memory);\\n}\"\r\n    },\r\n    \"interfaces/notional/IRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\n\\ninterface IRewarder {\\n    event RewardTransfer(address indexed rewardToken, address indexed account, uint256 amount);\\n    event RewardEmissionUpdate(uint256 emissionRatePerYear, uint256 endTime);\\n\\n    function NTOKEN_ADDRESS() external returns(address);\\n\\n    function CURRENCY_ID() external returns(uint16);\\n\\n    function detached() external returns(bool);\\n\\n    function claimRewards(\\n        address account,\\n        uint16 currencyId,\\n        uint256 nTokenBalanceBefore,\\n        uint256 nTokenBalanceAfter,\\n        uint256 totalSupply\\n    ) external;\\n\\n    function getAccountRewardClaim(address account, uint32 blockTime) external returns (uint256);\\n\\n    function getAccountRewardClaim(address account, uint256 nTokenBalanceAtDetach, bytes32[] calldata proof)\\n        external\\n        returns (uint256);\\n\\n    function claimRewardsDirect(address account, uint256 nTokenBalanceAtDetach, bytes32[] calldata proof) external;\\n\\n    function accumulatedRewardPerNToken() external returns (uint128);\\n\\n    function lastAccumulatedTime() external returns (uint32);\\n\\n    function emissionRatePerYear() external returns (uint128);\\n\\n    function detach() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/notional/IVaultController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport {\\n    VaultConfigParams,\\n    VaultConfigStorage,\\n    VaultConfig,\\n    VaultState,\\n    VaultAccount,\\n    VaultAccountHealthFactors,\\n    PrimeRate\\n} from \\\"../../contracts/global/Types.sol\\\";\\n\\ninterface IVaultAction {\\n    /// @notice Emitted when a new vault is listed or updated\\n    event VaultUpdated(address indexed vault, bool enabled, uint80 maxPrimaryBorrowCapacity);\\n    /// @notice Emitted when a vault's status is updated\\n    event VaultPauseStatus(address indexed vault, bool enabled);\\n    /// @notice Emitted when a vault's deleverage status is updated\\n    event VaultDeleverageStatus(address indexed vaultAddress, bool disableDeleverage);\\n    /// @notice Emitted when a secondary currency borrow capacity is updated\\n    event VaultUpdateSecondaryBorrowCapacity(address indexed vault, uint16 indexed currencyId, uint80 maxSecondaryBorrowCapacity);\\n    /// @notice Emitted when the borrow capacity on a vault changes\\n    event VaultBorrowCapacityChange(address indexed vault, uint16 indexed currencyId, uint256 totalUsedBorrowCapacity);\\n\\n    /// @notice Emitted when a vault executes a secondary borrow\\n    event VaultSecondaryTransaction(\\n        address indexed vault,\\n        address indexed account,\\n        uint16 indexed currencyId,\\n        uint256 maturity,\\n        int256 netUnderlyingDebt,\\n        int256 netPrimeSupply\\n    );\\n\\n    /** Vault Action Methods */\\n\\n    /// @notice Governance only method to whitelist a particular vault\\n    function updateVault(\\n        address vaultAddress,\\n        VaultConfigParams memory vaultConfig,\\n        uint80 maxPrimaryBorrowCapacity\\n    ) external;\\n\\n    /// @notice Governance only method to pause a particular vault\\n    function setVaultPauseStatus(\\n        address vaultAddress,\\n        bool enable\\n    ) external;\\n\\n    function setVaultDeleverageStatus(\\n        address vaultAddress,\\n        bool disableDeleverage\\n    ) external;\\n\\n    /// @notice Governance only method to set the borrow capacity\\n    function setMaxBorrowCapacity(\\n        address vaultAddress,\\n        uint80 maxVaultBorrowCapacity\\n    ) external;\\n\\n    /// @notice Governance only method to update a vault's secondary borrow capacity\\n    function updateSecondaryBorrowCapacity(\\n        address vaultAddress,\\n        uint16 secondaryCurrencyId,\\n        uint80 maxBorrowCapacity\\n    ) external;\\n\\n    function borrowSecondaryCurrencyToVault(\\n        address account,\\n        uint256 maturity,\\n        uint256[2] calldata underlyingToBorrow,\\n        uint32[2] calldata maxBorrowRate,\\n        uint32[2] calldata minRollLendRate\\n    ) external returns (int256[2] memory underlyingTokensTransferred);\\n\\n    function repaySecondaryCurrencyFromVault(\\n        address account,\\n        uint256 maturity,\\n        uint256[2] calldata underlyingToRepay,\\n        uint32[2] calldata minLendRate\\n    ) external payable returns (int256[2] memory underlyingDepositExternal);\\n\\n    function settleSecondaryBorrowForAccount(address vault, address account) external;\\n}\\n\\ninterface IVaultAccountAction {\\n    /**\\n     * @notice Borrows a specified amount of fCash in the vault's borrow currency and deposits it\\n     * all plus the depositAmountExternal into the vault to mint strategy tokens.\\n     *\\n     * @param account the address that will enter the vault\\n     * @param vault the vault to enter\\n     * @param depositAmountExternal some amount of additional collateral in the borrowed currency\\n     * to be transferred to vault\\n     * @param maturity the maturity to borrow at\\n     * @param fCash amount to borrow\\n     * @param maxBorrowRate maximum interest rate to borrow at\\n     * @param vaultData additional data to pass to the vault contract\\n     */\\n    function enterVault(\\n        address account,\\n        address vault,\\n        uint256 depositAmountExternal,\\n        uint256 maturity,\\n        uint256 fCash,\\n        uint32 maxBorrowRate,\\n        bytes calldata vaultData\\n    ) external payable returns (uint256 strategyTokensAdded);\\n\\n    /**\\n     * @notice Re-enters the vault at a longer dated maturity. The account's existing borrow\\n     * position will be closed and a new borrow position at the specified maturity will be\\n     * opened. All strategy token holdings will be rolled forward.\\n     *\\n     * @param account the address that will reenter the vault\\n     * @param vault the vault to reenter\\n     * @param fCashToBorrow amount of fCash to borrow in the next maturity\\n     * @param maturity new maturity to borrow at\\n     */\\n    function rollVaultPosition(\\n        address account,\\n        address vault,\\n        uint256 fCashToBorrow,\\n        uint256 maturity,\\n        uint256 depositAmountExternal,\\n        uint32 minLendRate,\\n        uint32 maxBorrowRate,\\n        bytes calldata enterVaultData\\n    ) external payable returns (uint256 strategyTokensAdded);\\n\\n    /**\\n     * @notice Prior to maturity, allows an account to withdraw their position from the vault. Will\\n     * redeem some number of vault shares to the borrow currency and close the borrow position by\\n     * lending `fCashToLend`. Any shortfall in cash from lending will be transferred from the account,\\n     * any excess profits will be transferred to the account.\\n     *\\n     * Post maturity, will net off the account's debt against vault cash balances and redeem all remaining\\n     * strategy tokens back to the borrowed currency and transfer the profits to the account.\\n     *\\n     * @param account the address that will exit the vault\\n     * @param vault the vault to enter\\n     * @param vaultSharesToRedeem amount of vault tokens to exit, only relevant when exiting pre-maturity\\n     * @param fCashToLend amount of fCash to lend\\n     * @param minLendRate the minimum rate to lend at\\n     * @param exitVaultData passed to the vault during exit\\n     * @return underlyingToReceiver amount of underlying tokens returned to the receiver on exit\\n     */\\n    function exitVault(\\n        address account,\\n        address vault,\\n        address receiver,\\n        uint256 vaultSharesToRedeem,\\n        uint256 fCashToLend,\\n        uint32 minLendRate,\\n        bytes calldata exitVaultData\\n    ) external payable returns (uint256 underlyingToReceiver);\\n\\n    function settleVaultAccount(address account, address vault) external;\\n}\\n\\ninterface IVaultLiquidationAction {\\n    event VaultDeleverageAccount(\\n        address indexed vault,\\n        address indexed account,\\n        uint16 currencyId,\\n        uint256 vaultSharesToLiquidator,\\n        int256 depositAmountPrimeCash\\n    );\\n\\n    event VaultLiquidatorProfit(\\n        address indexed vault,\\n        address indexed account,\\n        address indexed liquidator,\\n        uint256 vaultSharesToLiquidator,\\n        bool transferSharesToLiquidator\\n    );\\n    \\n    event VaultAccountCashLiquidation(\\n        address indexed vault,\\n        address indexed account,\\n        address indexed liquidator,\\n        uint16 currencyId,\\n        int256 fCashDeposit,\\n        int256 cashToLiquidator\\n    );\\n\\n    /**\\n     * @notice If an account is below the minimum collateral ratio, this method wil deleverage (liquidate)\\n     * that account. `depositAmountExternal` in the borrow currency will be transferred from the liquidator\\n     * and used to offset the account's debt position. The liquidator will receive either vaultShares or\\n     * cash depending on the vault's configuration.\\n     * @param account the address that will exit the vault\\n     * @param vault the vault to enter\\n     * @param liquidator the address that will receive profits from liquidation\\n     * @param depositAmountPrimeCash amount of cash to deposit\\n     * @return vaultSharesFromLiquidation amount of vaultShares received from liquidation\\n     */\\n    function deleverageAccount(\\n        address account,\\n        address vault,\\n        address liquidator,\\n        uint16 currencyIndex,\\n        int256 depositUnderlyingInternal\\n    ) external payable returns (uint256 vaultSharesFromLiquidation, int256 depositAmountPrimeCash);\\n\\n    function liquidateVaultCashBalance(\\n        address account,\\n        address vault,\\n        address liquidator,\\n        uint256 currencyIndex,\\n        int256 fCashDeposit\\n    ) external returns (int256 cashToLiquidator);\\n\\n    function liquidateExcessVaultCash(\\n        address account,\\n        address vault,\\n        address liquidator,\\n        uint256 excessCashIndex,\\n        uint256 debtIndex,\\n        uint256 _depositUnderlyingInternal\\n    ) external payable returns (int256 cashToLiquidator);\\n}\\n\\ninterface IVaultAccountHealth {\\n    function getVaultAccountHealthFactors(address account, address vault) external view returns (\\n        VaultAccountHealthFactors memory h,\\n        int256[3] memory maxLiquidatorDepositUnderlying,\\n        uint256[3] memory vaultSharesToLiquidator\\n    );\\n\\n    function calculateDepositAmountInDeleverage(\\n        uint256 currencyIndex,\\n        VaultAccount memory vaultAccount,\\n        VaultConfig memory vaultConfig,\\n        VaultState memory vaultState,\\n        int256 depositUnderlyingInternal\\n    ) external returns (int256 depositInternal, uint256 vaultSharesToLiquidator, PrimeRate memory);\\n\\n    function getfCashRequiredToLiquidateCash(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 vaultAccountCashBalance\\n    ) external view returns (int256 fCashRequired, int256 discountFactor);\\n\\n    function checkVaultAccountCollateralRatio(address vault, address account, bool checkDebtCap) external;\\n\\n    function getVaultAccount(address account, address vault) external view returns (VaultAccount memory);\\n    function getVaultAccountWithFeeAccrual(\\n        address account, address vault\\n    ) external view returns (VaultAccount memory, int256 accruedPrimeVaultFeeInUnderlying);\\n\\n    function getVaultConfig(address vault) external view returns (VaultConfig memory vaultConfig);\\n\\n    function getBorrowCapacity(address vault, uint16 currencyId) external view returns (\\n        uint256 currentPrimeDebtUnderlying,\\n        uint256 totalfCashDebt,\\n        uint256 maxBorrowCapacity\\n    );\\n\\n    function getSecondaryBorrow(address vault, uint16 currencyId, uint256 maturity) \\n        external view returns (int256 totalDebt);\\n\\n    /// @notice View method to get vault state\\n    function getVaultState(address vault, uint256 maturity) external view returns (VaultState memory vaultState);\\n\\n    function getVaultAccountSecondaryDebt(address account, address vault) external view returns (\\n        uint256 maturity,\\n        int256[2] memory accountSecondaryDebt,\\n        int256[2] memory accountSecondaryCashHeld\\n    );\\n\\n    function signedBalanceOfVaultTokenId(address account, uint256 id) external view returns (int256);\\n}\\n\\ninterface IVaultController is IVaultAccountAction, IVaultAction, IVaultLiquidationAction, IVaultAccountHealth {}\\n\"\r\n    },\r\n    \"interfaces/notional/nERC1155Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../contracts/global/Types.sol\\\";\\n\\ninterface nERC1155Interface {\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n    event URI(string value, uint256 indexed id);\\n\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\\n\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function signedBalanceOf(address account, uint256 id) external view returns (int256);\\n\\n    function signedBalanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (int256[] memory);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external payable;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external payable;\\n\\n    function decodeToAssets(uint256[] calldata ids, uint256[] calldata amounts)\\n        external\\n        view\\n        returns (PortfolioAsset[] memory);\\n\\n    function encodeToId(\\n        uint16 currencyId,\\n        uint40 maturity,\\n        uint8 assetType\\n    ) external pure returns (uint256 id);\\n}\\n\"\r\n    },\r\n    \"interfaces/notional/NotionalCalculations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../contracts/global/Types.sol\\\";\\n\\ninterface NotionalCalculations {\\n    function calculateNTokensToMint(uint16 currencyId, uint88 amountToDepositExternalPrecision)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function nTokenPresentValueAssetDenominated(uint16 currencyId) external view returns (int256);\\n\\n    function nTokenPresentValueUnderlyingDenominated(uint16 currencyId)\\n        external\\n        view\\n        returns (int256);\\n\\n    function convertNTokenToUnderlying(uint16 currencyId, int256 nTokenBalance) external view returns (int256);\\n\\n    function getfCashAmountGivenCashAmount(\\n        uint16 currencyId,\\n        int88 netCashToAccount,\\n        uint256 marketIndex,\\n        uint256 blockTime\\n    ) external view returns (int256);\\n\\n    function getCashAmountGivenfCashAmount(\\n        uint16 currencyId,\\n        int88 fCashAmount,\\n        uint256 marketIndex,\\n        uint256 blockTime\\n    ) external view returns (int256, int256);\\n\\n    function nTokenGetClaimableIncentives(address account, uint256 blockTime)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getPresentfCashValue(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 notional,\\n        uint256 blockTime,\\n        bool riskAdjusted\\n    ) external view returns (int256 presentValue);\\n\\n    function getMarketIndex(\\n        uint256 maturity,\\n        uint256 blockTime\\n    ) external pure returns (uint8 marketIndex);\\n\\n    function getfCashLendFromDeposit(\\n        uint16 currencyId,\\n        uint256 depositAmountExternal,\\n        uint256 maturity,\\n        uint32 minLendRate,\\n        uint256 blockTime,\\n        bool useUnderlying\\n    ) external view returns (\\n        uint88 fCashAmount,\\n        uint8 marketIndex,\\n        bytes32 encodedTrade\\n    );\\n\\n    function getfCashBorrowFromPrincipal(\\n        uint16 currencyId,\\n        uint256 borrowedAmountExternal,\\n        uint256 maturity,\\n        uint32 maxBorrowRate,\\n        uint256 blockTime,\\n        bool useUnderlying\\n    ) external view returns (\\n        uint88 fCashDebt,\\n        uint8 marketIndex,\\n        bytes32 encodedTrade\\n    );\\n\\n    function getDepositFromfCashLend(\\n        uint16 currencyId,\\n        uint256 fCashAmount,\\n        uint256 maturity,\\n        uint32 minLendRate,\\n        uint256 blockTime\\n    ) external view returns (\\n        uint256 depositAmountUnderlying,\\n        uint256 depositAmountAsset,\\n        uint8 marketIndex,\\n        bytes32 encodedTrade\\n    );\\n\\n    function getPrincipalFromfCashBorrow(\\n        uint16 currencyId,\\n        uint256 fCashBorrow,\\n        uint256 maturity,\\n        uint32 maxBorrowRate,\\n        uint256 blockTime\\n    ) external view returns (\\n        uint256 borrowAmountUnderlying,\\n        uint256 borrowAmountAsset,\\n        uint8 marketIndex,\\n        bytes32 encodedTrade\\n    );\\n\\n    function convertCashBalanceToExternal(\\n        uint16 currencyId,\\n        int256 cashBalanceInternal,\\n        bool useUnderlying\\n    ) external view returns (int256);\\n\\n    function convertUnderlyingToPrimeCash(\\n        uint16 currencyId,\\n        int256 underlyingExternal\\n    ) external view returns (int256);\\n\\n    function convertSettledfCash(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        int256 fCashBalance,\\n        uint256 blockTime\\n    ) external view returns (int256 signedPrimeSupplyValue);\\n\\n    function accruePrimeInterest(\\n        uint16 currencyId\\n    ) external returns (PrimeRate memory pr, PrimeCashFactors memory);\\n}\\n\"\r\n    },\r\n    \"interfaces/notional/NotionalGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../contracts/global/Deployments.sol\\\";\\nimport \\\"../../contracts/global/Types.sol\\\";\\nimport \\\"../../interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\nimport \\\"../../interfaces/notional/NotionalGovernance.sol\\\";\\nimport \\\"../../interfaces/notional/IRewarder.sol\\\";\\nimport \\\"../../interfaces/aave/ILendingPool.sol\\\";\\nimport {IPrimeCashHoldingsOracle} from \\\"../../interfaces/notional/IPrimeCashHoldingsOracle.sol\\\";\\n\\ninterface NotionalGovernance {\\n    event ListCurrency(uint16 newCurrencyId);\\n    event UpdateETHRate(uint16 currencyId);\\n    event UpdateAssetRate(uint16 currencyId);\\n    event UpdateCashGroup(uint16 currencyId);\\n    event DeployNToken(uint16 currencyId, address nTokenAddress);\\n    event UpdateDepositParameters(uint16 currencyId);\\n    event UpdateInitializationParameters(uint16 currencyId);\\n    event UpdateTokenCollateralParameters(uint16 currencyId);\\n    event UpdateGlobalTransferOperator(address operator, bool approved);\\n    event UpdateAuthorizedCallbackContract(address operator, bool approved);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    event PauseRouterAndGuardianUpdated(address indexed pauseRouter, address indexed pauseGuardian);\\n    event UpdateInterestRateCurve(uint16 indexed currencyId, uint8 indexed marketIndex);\\n    event UpdateMaxUnderlyingSupply(uint16 indexed currencyId, uint256 maxUnderlyingSupply);\\n    event PrimeProxyDeployed(uint16 indexed currencyId, address proxy, bool isCashProxy);\\n\\n    function transferOwnership(address newOwner, bool direct) external;\\n\\n    function claimOwnership() external;\\n\\n    function upgradeBeacon(Deployments.BeaconType proxy, address newBeacon) external;\\n\\n    function setPauseRouterAndGuardian(address pauseRouter_, address pauseGuardian_) external;\\n\\n    function listCurrency(\\n        TokenStorage calldata underlyingToken,\\n        ETHRateStorage memory ethRate,\\n        InterestRateCurveSettings calldata primeDebtCurve,\\n        IPrimeCashHoldingsOracle primeCashHoldingsOracle,\\n        bool allowPrimeCashDebt,\\n        uint8 rateOracleTimeWindow5Min,\\n        string calldata underlyingName,\\n        string calldata underlyingSymbol\\n    ) external returns (uint16 currencyId);\\n\\n    function enableCashGroup(\\n        uint16 currencyId,\\n        CashGroupSettings calldata cashGroup,\\n        string calldata underlyingName,\\n        string calldata underlyingSymbol\\n    ) external;\\n\\n    function updateDepositParameters(\\n        uint16 currencyId,\\n        uint32[] calldata depositShares,\\n        uint32[] calldata leverageThresholds\\n    ) external;\\n\\n    function updateInitializationParameters(\\n        uint16 currencyId,\\n        uint32[] calldata annualizedAnchorRates,\\n        uint32[] calldata proportions\\n    ) external;\\n\\n\\n    function updateTokenCollateralParameters(\\n        uint16 currencyId,\\n        uint8 residualPurchaseIncentive10BPS,\\n        uint8 pvHaircutPercentage,\\n        uint8 residualPurchaseTimeBufferHours,\\n        uint8 cashWithholdingBuffer10BPS,\\n        uint8 liquidationHaircutPercentage,\\n        uint8 maxMintDeviationPercentage\\n    ) external;\\n\\n    function updateCashGroup(uint16 currencyId, CashGroupSettings calldata cashGroup) external;\\n\\n    function updateInterestRateCurve(\\n        uint16 currencyId,\\n        uint8[] calldata marketIndices,\\n        InterestRateCurveSettings[] calldata settings\\n    ) external;\\n\\n    function setMaxUnderlyingSupply(\\n        uint16 currencyId,\\n        uint256 maxUnderlyingSupply,\\n        uint8 maxPrimeDebtUtilization\\n    ) external;\\n\\n    function updatePrimeCashHoldingsOracle(\\n        uint16 currencyId,\\n        IPrimeCashHoldingsOracle primeCashHoldingsOracle\\n    ) external;\\n\\n    function updatePrimeCashCurve(\\n        uint16 currencyId,\\n        InterestRateCurveSettings calldata primeDebtCurve\\n    ) external;\\n\\n    function enablePrimeDebt(\\n        uint16 currencyId,\\n        string calldata underlyingName,\\n        string calldata underlyingSymbol\\n    ) external;\\n\\n    function updateETHRate(\\n        uint16 currencyId,\\n        AggregatorV2V3Interface rateOracle,\\n        bool mustInvert,\\n        uint8 buffer,\\n        uint8 haircut,\\n        uint8 liquidationDiscount\\n    ) external;\\n\\n    function updateAuthorizedCallbackContract(address operator, bool approved) external;\\n}\"\r\n    },\r\n    \"interfaces/notional/NotionalProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../contracts/global/Types.sol\\\";\\nimport \\\"./nTokenERC20.sol\\\";\\nimport \\\"./nERC1155Interface.sol\\\";\\nimport \\\"./NotionalGovernance.sol\\\";\\nimport \\\"./NotionalCalculations.sol\\\";\\nimport \\\"./NotionalViews.sol\\\";\\nimport \\\"./NotionalTreasury.sol\\\";\\nimport {IVaultController} from \\\"./IVaultController.sol\\\";\\n\\ninterface NotionalProxy is\\n    nTokenERC20,\\n    nERC1155Interface,\\n    NotionalGovernance,\\n    NotionalTreasury,\\n    NotionalCalculations,\\n    NotionalViews,\\n    IVaultController\\n{\\n    /** User trading events */\\n    event MarketsInitialized(uint16 currencyId);\\n    event SweepCashIntoMarkets(uint16 currencyId, int256 cashIntoMarkets);\\n\\n    /// @notice Emitted once when incentives are migrated\\n    event IncentivesMigrated(\\n        uint16 currencyId,\\n        uint256 migrationEmissionRate,\\n        uint256 finalIntegralTotalSupply,\\n        uint256 migrationTime\\n    );\\n    /// @notice Emitted if a token address is migrated\\n    event TokenMigrated(uint16 currencyId) ;\\n    /// @notice Emitted whenever an account context has updated\\n    event AccountContextUpdate(address indexed account);\\n    /// @notice Emitted when an account has assets that are settled\\n    event AccountSettled(address indexed account);\\n\\n    /* Liquidation Events */\\n    event LiquidateLocalCurrency(\\n        address indexed liquidated,\\n        address indexed liquidator,\\n        uint16 localCurrencyId,\\n        int256 netLocalFromLiquidator\\n    );\\n\\n    event LiquidateCollateralCurrency(\\n        address indexed liquidated,\\n        address indexed liquidator,\\n        uint16 localCurrencyId,\\n        uint16 collateralCurrencyId,\\n        int256 netLocalFromLiquidator,\\n        int256 netCollateralTransfer,\\n        int256 netNTokenTransfer\\n    );\\n\\n    event LiquidatefCashEvent(\\n        address indexed liquidated,\\n        address indexed liquidator,\\n        uint16 localCurrencyId,\\n        uint16 fCashCurrency,\\n        int256 netLocalFromLiquidator,\\n        uint256[] fCashMaturities,\\n        int256[] fCashNotionalTransfer\\n    );\\n\\n    event SetPrimeSettlementRate(\\n        uint256 indexed currencyId,\\n        uint256 indexed maturity,\\n        int256 supplyFactor,\\n        int256 debtFactor\\n    );\\n\\n    /// @notice Emits every time interest is accrued\\n    event PrimeCashInterestAccrued(\\n        uint16 indexed currencyId,\\n        uint256 underlyingScalar,\\n        uint256 supplyScalar,\\n        uint256 debtScalar\\n    );\\n\\n    event PrimeCashCurveChanged(uint16 indexed currencyId);\\n\\n    event PrimeCashHoldingsOracleUpdated(uint16 indexed currencyId, address oracle);\\n\\n    /** UUPS Upgradeable contract calls */\\n    function upgradeTo(address newImplementation) external;\\n\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;\\n\\n    function getImplementation() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function pauseRouter() external view returns (address);\\n\\n    function pauseGuardian() external view returns (address);\\n\\n    /** Initialize Markets Action */\\n    function initializeMarkets(uint16 currencyId, bool isFirstInit) external;\\n\\n    function sweepCashIntoMarkets(uint16 currencyId) external;\\n\\n    /** Account Action */\\n    function nTokenRedeem(\\n        address redeemer,\\n        uint16 currencyId,\\n        uint96 tokensToRedeem_\\n    ) external returns (int256);\\n\\n    function enablePrimeBorrow(bool allowPrimeBorrow) external;\\n\\n    function enableBitmapCurrency(uint16 currencyId) external;\\n\\n    function settleAccount(address account) external;\\n\\n    function depositUnderlyingToken(\\n        address account,\\n        uint16 currencyId,\\n        uint256 amountExternalPrecision\\n    ) external payable returns (uint256);\\n\\n    function depositAssetToken(\\n        address account,\\n        uint16 currencyId,\\n        uint256 amountExternalPrecision\\n    ) external returns (uint256);\\n\\n    function withdraw(\\n        uint16 currencyId,\\n        uint88 amountInternalPrecision,\\n        bool redeemToUnderlying\\n    ) external returns (uint256);\\n\\n    function withdrawViaProxy(\\n        uint16 currencyId,\\n        address owner,\\n        address receiver,\\n        address spender,\\n        uint88 withdrawAmountPrimeCash\\n    ) external returns (uint256);\\n\\n    /** Batch Action */\\n    function batchBalanceAction(address account, BalanceAction[] calldata actions) external payable;\\n\\n    function batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions)\\n        external\\n        payable;\\n\\n    function batchBalanceAndTradeActionWithCallback(\\n        address account,\\n        BalanceActionWithTrades[] calldata actions,\\n        bytes calldata callbackData\\n    ) external payable;\\n\\n    function batchLend(address account, BatchLend[] calldata actions) external;\\n\\n    /** Liquidation Action */\\n    function calculateLocalCurrencyLiquidation(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint96 maxNTokenLiquidation\\n    ) external returns (int256, int256);\\n\\n    function liquidateLocalCurrency(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint96 maxNTokenLiquidation\\n    ) external payable returns (int256, int256);\\n\\n    function calculateCollateralCurrencyLiquidation(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint16 collateralCurrency,\\n        uint128 maxCollateralLiquidation,\\n        uint96 maxNTokenLiquidation\\n    ) external returns (int256, int256, int256);\\n\\n    function liquidateCollateralCurrency(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint16 collateralCurrency,\\n        uint128 maxCollateralLiquidation,\\n        uint96 maxNTokenLiquidation,\\n        bool withdrawCollateral,\\n        bool redeemToUnderlying\\n    ) external payable returns (int256, int256, int256);\\n\\n    function calculatefCashLocalLiquidation(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts\\n    ) external returns (int256[] memory, int256);\\n\\n    function liquidatefCashLocal(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts\\n    ) external payable returns (int256[] memory, int256);\\n\\n    function calculatefCashCrossCurrencyLiquidation(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint16 fCashCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts\\n    ) external returns (int256[] memory, int256);\\n\\n    function liquidatefCashCrossCurrency(\\n        address liquidateAccount,\\n        uint16 localCurrency,\\n        uint16 fCashCurrency,\\n        uint256[] calldata fCashMaturities,\\n        uint256[] calldata maxfCashLiquidateAmounts\\n    ) external payable returns (int256[] memory, int256);\\n}\\n\"\r\n    },\r\n    \"interfaces/notional/NotionalTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport {IRewarder} from \\\"./IRewarder.sol\\\";\\n\\ninterface NotionalTreasury {\\n    event UpdateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate);\\n    event UpdateSecondaryIncentiveRewarder(uint16 indexed currencyId, address rewarder);\\n\\n    struct RebalancingTargetConfig {\\n        address holding;\\n        uint8 targetUtilization;\\n        uint16 externalWithdrawThreshold;\\n    }\\n\\n    /// @notice Emitted when reserve balance is updated\\n    event ReserveBalanceUpdated(uint16 indexed currencyId, int256 newBalance);\\n    /// @notice Emitted when reserve balance is harvested\\n    event ExcessReserveBalanceHarvested(uint16 indexed currencyId, int256 harvestAmount);\\n    /// @dev Emitted when treasury manager is updated\\n    event TreasuryManagerChanged(address indexed previousManager, address indexed newManager);\\n    /// @dev Emitted when reserve buffer value is updated\\n    event ReserveBufferUpdated(uint16 currencyId, uint256 bufferAmount);\\n\\n    event RebalancingTargetsUpdated(uint16 currencyId, RebalancingTargetConfig[] targets);\\n\\n    event RebalancingCooldownUpdated(uint16 currencyId, uint40 cooldownTimeInSeconds);\\n\\n    event CurrencyRebalanced(uint16 currencyId, uint256 supplyFactor, uint256 annualizedInterestRate);\\n\\n    /// @notice Emitted when the interest accrued on asset deposits is harvested \\n    event AssetInterestHarvested(uint16 indexed currencyId, address assetToken, uint256 harvestAmount);\\n\\n    function transferReserveToTreasury(uint16[] calldata currencies) external returns (uint256[] memory);\\n\\n    function harvestAssetInterest(uint16[] calldata currencies) external;\\n\\n    function setTreasuryManager(address manager) external;\\n\\n    function setRebalancingBot(address _rebalancingBot) external;\\n\\n    function setReserveBuffer(uint16 currencyId, uint256 amount) external;\\n\\n    function setReserveCashBalance(uint16 currencyId, int256 reserveBalance) external;\\n\\n    function setRebalancingTargets(uint16 currencyId, RebalancingTargetConfig[] calldata targets) external;\\n\\n    function setRebalancingCooldown(uint16 currencyId, uint40 cooldownTimeInSeconds) external;\\n\\n    function checkRebalance() external view returns (uint16[] memory currencyIds);\\n\\n    function rebalance(uint16 currencyId) external;\\n\\n    function updateIncentiveEmissionRate(uint16 currencyId, uint32 newEmissionRate) external;\\n\\n    function setSecondaryIncentiveRewarder(uint16 currencyId, IRewarder rewarder) external;\\n}\"\r\n    },\r\n    \"interfaces/notional/NotionalViews.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"../../contracts/global/Types.sol\\\";\\n\\ninterface NotionalViews {\\n    function getMaxCurrencyId() external view returns (uint16);\\n\\n    function getCurrencyId(address tokenAddress) external view returns (uint16 currencyId);\\n\\n    function getCurrency(uint16 currencyId)\\n        external\\n        view\\n        returns (Token memory assetToken, Token memory underlyingToken);\\n\\n    function getRateStorage(uint16 currencyId)\\n        external\\n        view\\n        returns (ETHRateStorage memory ethRate, AssetRateStorage memory assetRate);\\n\\n    function getCurrencyAndRates(uint16 currencyId)\\n        external\\n        view\\n        returns (\\n            Token memory assetToken,\\n            Token memory underlyingToken,\\n            ETHRate memory ethRate,\\n            Deprecated_AssetRateParameters memory assetRate\\n        );\\n\\n    function getCashGroup(uint16 currencyId) external view returns (CashGroupSettings memory);\\n\\n    function getCashGroupAndAssetRate(uint16 currencyId)\\n        external\\n        view\\n        returns (CashGroupSettings memory cashGroup, Deprecated_AssetRateParameters memory assetRate);\\n\\n    function getInterestRateCurve(uint16 currencyId) external view returns (\\n        InterestRateParameters[] memory nextInterestRateCurve,\\n        InterestRateParameters[] memory activeInterestRateCurve\\n    );\\n\\n    function getInitializationParameters(uint16 currencyId)\\n        external\\n        view\\n        returns (int256[] memory annualizedAnchorRates, int256[] memory proportions);\\n\\n    function getDepositParameters(uint16 currencyId)\\n        external\\n        view\\n        returns (int256[] memory depositShares, int256[] memory leverageThresholds);\\n\\n    function nTokenAddress(uint16 currencyId) external view returns (address);\\n\\n    function pCashAddress(uint16 currencyId) external view returns (address);\\n\\n    function pDebtAddress(uint16 currencyId) external view returns (address);\\n\\n    function getNoteToken() external view returns (address);\\n\\n    function getOwnershipStatus() external view returns (address owner, address pendingOwner);\\n\\n    function getGlobalTransferOperatorStatus(address operator)\\n        external\\n        view\\n        returns (bool isAuthorized);\\n\\n    function getAuthorizedCallbackContractStatus(address callback)\\n        external\\n        view\\n        returns (bool isAuthorized);\\n\\n    function getSecondaryIncentiveRewarder(uint16 currencyId)\\n        external\\n        view\\n        returns (address incentiveRewarder);\\n\\n    function getPrimeFactors(uint16 currencyId, uint256 blockTime) external view returns (\\n        PrimeRate memory primeRate,\\n        PrimeCashFactors memory factors,\\n        uint256 maxUnderlyingSupply,\\n        uint256 totalUnderlyingSupply,\\n        uint256 maxUnderlyingDebt,\\n        uint256 totalUnderlyingDebt\\n    );\\n\\n    function getPrimeFactorsStored(uint16 currencyId) external view returns (PrimeCashFactors memory);\\n\\n    function getPrimeCashHoldingsOracle(uint16 currencyId) external view returns (address);\\n\\n    function getPrimeInterestRateCurve(uint16 currencyId) external view returns (InterestRateParameters memory);\\n\\n    function getPrimeInterestRate(uint16 currencyId) external view returns (\\n        uint256 annualDebtRatePreFee,\\n        uint256 annualDebtRatePostFee,\\n        uint256 annualSupplyRate\\n    );\\n\\n    function getTotalfCashDebtOutstanding(uint16 currencyId, uint256 maturity) external view returns (\\n        int256 totalfCashDebt,\\n        int256 fCashDebtHeldInSettlementReserve,\\n        int256 primeCashHeldInSettlementReserve\\n    );\\n\\n    function getSettlementRate(uint16 currencyId, uint40 maturity)\\n        external\\n        view\\n        returns (PrimeRate memory);\\n\\n    function getMarket(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 settlementDate\\n    ) external view returns (MarketParameters memory);\\n\\n    function getActiveMarkets(uint16 currencyId) external view returns (MarketParameters[] memory);\\n\\n    function getActiveMarketsAtBlockTime(uint16 currencyId, uint32 blockTime)\\n        external\\n        view\\n        returns (MarketParameters[] memory);\\n\\n    function getReserveBalance(uint16 currencyId) external view returns (int256 reserveBalance);\\n\\n    function getNTokenPortfolio(address tokenAddress)\\n        external\\n        view\\n        returns (PortfolioAsset[] memory liquidityTokens, PortfolioAsset[] memory netfCashAssets);\\n\\n    function getNTokenAccount(address tokenAddress)\\n        external\\n        view\\n        returns (\\n            uint16 currencyId,\\n            uint256 totalSupply,\\n            uint256 incentiveAnnualEmissionRate,\\n            uint256 lastInitializedTime,\\n            bytes6 nTokenParameters,\\n            int256 cashBalance,\\n            uint256 accumulatedNOTEPerNToken,\\n            uint256 lastAccumulatedTime\\n        );\\n\\n    function getAccount(address account)\\n        external\\n        view\\n        returns (\\n            AccountContext memory accountContext,\\n            AccountBalance[] memory accountBalances,\\n            PortfolioAsset[] memory portfolio\\n        );\\n\\n    function getAccountContext(address account) external view returns (AccountContext memory);\\n\\n    function getAccountPrimeDebtBalance(uint16 currencyId, address account) external view returns (\\n        int256 debtBalance\\n    );\\n\\n    function getAccountBalance(uint16 currencyId, address account)\\n        external\\n        view\\n        returns (\\n            int256 cashBalance,\\n            int256 nTokenBalance,\\n            uint256 lastClaimTime\\n        );\\n\\n    function getBalanceOfPrimeCash(\\n        uint16 currencyId,\\n        address account\\n    ) external view returns (int256 cashBalance);\\n\\n    function getAccountPortfolio(address account) external view returns (PortfolioAsset[] memory);\\n\\n    function getfCashNotional(\\n        address account,\\n        uint16 currencyId,\\n        uint256 maturity\\n    ) external view returns (int256);\\n\\n    function getAssetsBitmap(address account, uint16 currencyId) external view returns (bytes32);\\n\\n    function getFreeCollateral(address account) external view returns (int256, int256[] memory);\\n\\n    function getTreasuryManager() external view returns (address);\\n\\n    function getReserveBuffer(uint16 currencyId) external view returns (uint256);\\n\\n    function getRebalancingFactors(uint16 currencyId) external view\\n      returns (address holding, uint8 target, uint16 externalWithdrawThreshold, RebalancingContextStorage memory context);\\n\\n    function getStoredTokenBalances(address[] calldata tokens) external view returns (uint256[] memory balances);\\n\\n    function decodeERC1155Id(uint256 id) external view returns (\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        address vaultAddress,\\n        bool isfCashDebt\\n    );\\n\\n    function encode(\\n        uint16 currencyId,\\n        uint256 maturity,\\n        uint256 assetType,\\n        address vaultAddress,\\n        bool isfCashDebt\\n    ) external pure returns (uint256);\\n}\"\r\n    },\r\n    \"interfaces/notional/nTokenERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\n\\ninterface nTokenERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    function nTokenTotalSupply(address nTokenAddress) external view returns (uint256);\\n\\n    function nTokenBalanceOf(uint16 currencyId, address account) external view returns (uint256);\\n\\n    function nTokenTransferAllowance(\\n        uint16 currencyId,\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function pCashTransferAllowance(\\n        uint16 currencyId,\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function nTokenTransferApprove(\\n        uint16 currencyId,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function pCashTransferApprove(\\n        uint16 currencyId,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function nTokenTransfer(\\n        uint16 currencyId,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function pCashTransfer(\\n        uint16 currencyId,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function nTokenTransferFrom(\\n        uint16 currencyId,\\n        address spender,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function pCashTransferFrom(\\n        uint16 currencyId,\\n        address spender,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function nTokenTransferApproveAll(address spender, uint256 amount) external returns (bool);\\n\\n    function nTokenClaimIncentives() external returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"interfaces/WETH9.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSUL-1.1\\npragma solidity >=0.7.6;\\n\\ninterface WETH9 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/external/FreeCollateralExternal.sol\": {\r\n        \"FreeCollateralExternal\": \"0xea7aa69dbeea9deb4294109bd344f69c79c6fdf7\"\r\n      },\r\n      \"contracts/external/SettleAssetsExternal.sol\": {\r\n        \"SettleAssetsExternal\": \"0xe10836ba543be91e978fc9b455bf483572a44b21\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidateAccount\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"localCurrency\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"fCashCurrency\",\"type\":\"uint16\"},{\"internalType\":\"uint256[]\",\"name\":\"fCashMaturities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxfCashLiquidateAmounts\",\"type\":\"uint256[]\"}],\"name\":\"calculatefCashCrossCurrencyLiquidation\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidateAccount\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"localCurrency\",\"type\":\"uint16\"},{\"internalType\":\"uint256[]\",\"name\":\"fCashMaturities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxfCashLiquidateAmounts\",\"type\":\"uint256[]\"}],\"name\":\"calculatefCashLocalLiquidation\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLibInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidateAccount\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"localCurrency\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"fCashCurrency\",\"type\":\"uint16\"},{\"internalType\":\"uint256[]\",\"name\":\"fCashMaturities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxfCashLiquidateAmounts\",\"type\":\"uint256[]\"}],\"name\":\"liquidatefCashCrossCurrency\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidateAccount\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"localCurrency\",\"type\":\"uint16\"},{\"internalType\":\"uint256[]\",\"name\":\"fCashMaturities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxfCashLiquidateAmounts\",\"type\":\"uint256[]\"}],\"name\":\"liquidatefCashLocal\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"\",\"type\":\"int256[]\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LiquidatefCashAction", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}