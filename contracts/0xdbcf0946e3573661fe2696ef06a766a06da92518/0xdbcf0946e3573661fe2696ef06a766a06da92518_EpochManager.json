{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/EpochManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\nimport {ReentrancyGuard} from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\n\\nimport {CannotSetNullAddress} from '@floor/utils/Errors.sol';\\n\\nimport {IVoteMarket} from '@floor-interfaces/bribes/VoteMarket.sol';\\nimport {IEpochEndTriggered} from '@floor-interfaces/utils/EpochEndTriggered.sol';\\nimport {INewCollectionWars} from '@floor-interfaces/voting/NewCollectionWars.sol';\\nimport {IEpochManager} from '@floor-interfaces/EpochManager.sol';\\n\\n/// If the epoch is currently timelocked and insufficient time has passed.\\n/// @param timelockExpiry The timestamp at which the epoch can next be run\\nerror EpochTimelocked(uint timelockExpiry);\\n\\n/**\\n * Handles epoch management for all other contracts.\\n */\\ncontract EpochManager is IEpochManager, Ownable, ReentrancyGuard {\\n    /// Stores the current epoch that is taking place.\\n    uint public currentEpoch;\\n\\n    /// Store a timestamp of when last epoch was run so that we can timelock usage\\n    uint public lastEpoch;\\n\\n    /// Store the length of an epoch\\n    uint public constant EPOCH_LENGTH = 2 weeks;\\n\\n    /// Holds our internal contract references\\n    INewCollectionWars public newCollectionWars;\\n    address public voteMarket;\\n\\n    /// Stores a mapping of an epoch to a collection\\n    mapping(uint => uint) public collectionEpochs;\\n\\n    /// Store our epoch triggers\\n    address[] private _epochEndTriggers;\\n\\n    /**\\n     * Will return if the current epoch is a collection addition vote.\\n     *\\n     * @return bool If the current epoch is a collection addition\\n     */\\n    function isCollectionAdditionEpoch() external view returns (bool) {\\n        return collectionEpochs[currentEpoch] != 0;\\n    }\\n\\n    /**\\n     * Will return true if the specified epoch is a collection addition vote.\\n     *\\n     * @param epoch The epoch to check\\n     *\\n     * @return bool If the specified epoch is a collection addition\\n     */\\n    function isCollectionAdditionEpoch(uint epoch) external view returns (bool) {\\n        return collectionEpochs[epoch] != 0;\\n    }\\n\\n    /**\\n     * Allows an epoch to be scheduled to be a collection addition vote. An index will\\n     * be specified to show which collection addition will be used. The index will not\\n     * be a zero value.\\n     *\\n     * @param epoch The epoch that the Collection Addition will take place in\\n     * @param index The Collection Addition array index\\n     */\\n    function scheduleCollectionAdditionEpoch(uint epoch, uint index) external {\\n        // Ensure that only our {NewCollectionWars} contract can make this call\\n        require(msg.sender == address(newCollectionWars), 'Invalid caller');\\n\\n        // Set our new collection epoch\\n        collectionEpochs[epoch] = index;\\n\\n        // If we have a {VoteMarket} contract set, then we need to increase the number\\n        // of epochs of any bribes that overlap the new collection war epoch. This is\\n        // done as only Sweep Wars utilise bribe logic and have a preset number of epochs\\n        // covered at the point of creation, so by taking one of their epochs we append\\n        // another to their bribe epoch window.\\n        if (voteMarket != address(0)) {\\n            IVoteMarket(voteMarket).extendBribes(epoch);\\n        }\\n\\n        emit CollectionAdditionWarScheduled(epoch, index);\\n    }\\n\\n    /**\\n     * Triggers an epoch to end.\\n     *\\n     * If the epoch has successfully ended, then the `currentEpoch` value will be increased\\n     * by one, and the epoch will be locked from updating again until `EPOCH_LENGTH` has\\n     * passed. We will also check if a new Collection Addition is starting in the new epoch\\n     * and initialise it if it is.\\n     */\\n    function endEpoch() external nonReentrant {\\n        // Ensure enough time has past since the last epoch ended\\n        if (lastEpoch != 0 && block.timestamp < lastEpoch + EPOCH_LENGTH) {\\n            revert EpochTimelocked(lastEpoch + EPOCH_LENGTH);\\n        }\\n\\n        unchecked {\\n            // If our lastEpoch is zero, then this is the first epoch ended and we want\\n            // to set it to the specific block timestamp. Otherwise, we just increase it\\n            // by the length of the epoch to avoid epoch creep.\\n            lastEpoch += (lastEpoch == 0) ? block.timestamp : EPOCH_LENGTH;\\n        }\\n\\n        // If we have any logic that needs to be triggered when an epoch ends, then we include\\n        // it here.\\n        uint triggersLength = _epochEndTriggers.length;\\n        for (uint i; i < triggersLength;) {\\n            IEpochEndTriggered(_epochEndTriggers[i]).endEpoch(currentEpoch);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit EpochEnded(currentEpoch, lastEpoch);\\n\\n        unchecked {\\n            ++currentEpoch;\\n        }\\n\\n        // If we have a floor war ready to start, then action it\\n        uint collectionWarIndex = collectionEpochs[currentEpoch];\\n        if (collectionWarIndex != 0) {\\n            newCollectionWars.startFloorWar(collectionWarIndex);\\n        }\\n    }\\n\\n    /**\\n     * Allows a new epochEnd trigger to be attached\\n     */\\n    function setEpochEndTrigger(address contractAddr, bool enabled) external onlyOwner {\\n        // If we are trying to add a zero address, exit early\\n        if (enabled && contractAddr == address(0)) revert CannotSetNullAddress();\\n\\n        // Both enabling and disabling an `epochEndTrigger` will benefit from\\n        // knowing the existing index of the `contractAddr`, if it already exists.\\n        int existingIndex = -1;\\n        uint triggersLength = _epochEndTriggers.length;\\n        uint i;\\n        for (i; i < triggersLength;) {\\n            if (_epochEndTriggers[i] == contractAddr) {\\n                existingIndex = int(i);\\n                break;\\n            }\\n            unchecked { ++i; }\\n        }\\n\\n        if (enabled) {\\n            require(existingIndex == -1, 'Trigger already exists');\\n            _epochEndTriggers.push(contractAddr);\\n        } else {\\n            require(existingIndex != -1, 'Trigger not found');\\n\\n            // Shift the elements after the deleted element by one position\\n            for (i = uint(existingIndex); i < triggersLength - 1;) {\\n                _epochEndTriggers[i] = _epochEndTriggers[i + 1];\\n                unchecked { ++i; }\\n            }\\n\\n            // Reduce the length of the array by 1\\n            _epochEndTriggers.pop();\\n        }\\n    }\\n\\n    /**\\n     * Provides an estimated timestamp of when an epoch started, and also the earliest\\n     * that an epoch in the future could start.\\n     *\\n     * @param _epoch The epoch to find the estimated timestamp of\\n     *\\n     * @return uint The estimated timestamp of when the specified epoch started\\n     */\\n    function epochIterationTimestamp(uint _epoch) public view returns (uint) {\\n        if (currentEpoch < _epoch) {\\n            return lastEpoch + ((_epoch - currentEpoch) * EPOCH_LENGTH);\\n        }\\n\\n        if (currentEpoch == _epoch) {\\n            return lastEpoch;\\n        }\\n\\n        return lastEpoch - ((currentEpoch - _epoch) * EPOCH_LENGTH);\\n    }\\n\\n    /**\\n     * Sets the contract addresses of internal contracts that are queried and used\\n     * in other functions.\\n     *\\n     * @dev The vote market contract can be a zero-address as this won't be ready at\\n     * launch.\\n     */\\n    function setContracts(address _newCollectionWars, address _voteMarket) external onlyOwner {\\n        if (_newCollectionWars == address(0)) revert CannotSetNullAddress();\\n\\n        newCollectionWars = INewCollectionWars(_newCollectionWars);\\n        voteMarket = _voteMarket;\\n\\n        emit EpochManagerContractsUpdated(_newCollectionWars, _voteMarket);\\n    }\\n\\n    /**\\n     * Provides a complete list of all epoch end triggers, in the order that they\\n     * are executed.\\n     */\\n    function epochEndTriggers() public view returns (address[] memory) {\\n        return _epochEndTriggers;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/utils/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/**\\n * A collection of generic errors that can be referenced across multiple\\n * contracts. Contract-specific errors should still be stored in their\\n * individual Solidity files.\\n */\\n\\n/// If a NULL address tries to be stored which should not be accepted\\nerror CannotSetNullAddress();\\n\\n/// If the caller has entered an insufficient amount to process the action. This\\n/// will likely be a zero amount.\\nerror InsufficientAmount();\\n\\n/// If the caller enters a percentage value that is too high for the requirements\\nerror PercentageTooHigh(uint amount);\\n\\n/// If a required ETH or token `transfer` call fails\\nerror TransferFailed();\\n\\n/// If a user calls a deposit related function with a zero amount\\nerror CannotDepositZeroAmount();\\n\\n/// If a user calls a withdrawal related function with a zero amount\\nerror CannotWithdrawZeroAmount();\\n\\n/// If there are no rewards available to be claimed\\nerror NoRewardsAvailableToClaim();\\n\\n/// If the requested collection is not approved\\n/// @param collection Address of the collection requested\\nerror CollectionNotApproved(address collection);\\n\\n/// If the requested strategy implementation is not approved\\n/// @param strategyImplementation Address of the strategy implementation requested\\nerror StrategyNotApproved(address strategyImplementation);\\n\"\r\n    },\r\n    \"src/interfaces/bribes/VoteMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IVoteMarket {\\n    /**\\n     * Bribe struct requirements.\\n     *\\n     * @param bribeId ID of the bribe\\n     * @param startEpoch The first epoch at which the bribe reward is claimable.\\n     * @param maxRewardPerVote Max Price per vote.\\n     * @param totalRewardAmount The total amount of `rewardToken` funding the bribe.\\n     * @param remainingRewards Tracking of the number of rewards remaining.\\n     * @param collection Address of the target gauge.\\n     * @param rewardToken Address of the ERC20 used for rewards.\\n     * @param creator The creator of the bribe.\\n     * @param numberOfEpochs The number of epochs the bribe will run for.\\n     */\\n    struct Bribe {\\n        uint startEpoch; // 256 / 256\\n        uint maxRewardPerVote; // 512 / 512\\n        uint remainingRewards; // 768 / 768\\n        uint totalRewardAmount; // 1024 / 1024\\n        address collection; // 1184 / 1280\\n        address rewardToken; // 1344 / 1536\\n        address creator; // 1504 / 1536\\n        uint8 numberOfEpochs; // 1512 / 1536\\n    }\\n\\n    /// Fired when a new bribe is created\\n    event BribeCreated(uint bribeId);\\n\\n    /// Fired when a user claims their bribe allocation\\n    event Claimed(address account, address rewardToken, uint bribeId, uint amount, uint epoch);\\n\\n    /// Fired when a new claim allocation is assigned for an epoch\\n    event ClaimRegistered(uint epoch, bytes32 merkleRoot);\\n\\n    /// Minimum number of epochs for a Bribe\\n    function MINIMUM_EPOCHS() external returns (uint8);\\n\\n    /// The percentage of bribes that will be sent to the DAO\\n    function DAO_FEE() external returns (uint8);\\n\\n    /// The recipient of any fees collected. This should be set to the {Treasury}, or\\n    /// to a specialist fee collection contract.\\n    function feeCollector() external returns (address);\\n\\n    /// Store our claim merkles that define the available rewards for each user across\\n    /// all collections and bribes.\\n    function epochMerkles(uint epoch) external returns (bytes32);\\n\\n    /// Stores a list of all bribes created, across past, live and future\\n    function bribes(uint index) external returns (Bribe memory);\\n\\n    /// A mapping of collection addresses to an array of bribe array indexes\\n    function collectionBribes(address) external returns (uint[] memory);\\n\\n    /// Blacklisted addresses per bribe that aren't counted for rewards arithmetics.\\n    function isBlacklisted(uint bribeId, address account) external returns (bool);\\n\\n    /// Oracle wallet that has permission to write merkles\\n    function oracleWallet() external returns (address);\\n\\n    /**\\n     * Create a new bribe.\\n     *\\n     * @param collection Address of the target collection.\\n     * @param rewardToken Address of the ERC20 used or rewards.\\n     * @param startEpoch The epoch to start offering the bribe.\\n     * @param numberOfEpochs Number of periods.\\n     * @param maxRewardPerVote Target Bias for the Gauge.\\n     * @param totalRewardAmount Total Reward Added.\\n     * @param blacklist Array of addresses to blacklist.\\n     *\\n     * @return newBribeID of the bribe created.\\n     */\\n    function createBribe(\\n        address collection,\\n        address rewardToken,\\n        uint startEpoch,\\n        uint8 numberOfEpochs,\\n        uint maxRewardPerVote,\\n        uint totalRewardAmount,\\n        address[] calldata blacklist\\n    ) external returns (uint newBribeID);\\n\\n    /**\\n     * Claims against any bribes for a user.\\n     */\\n    function claim(\\n        address account,\\n        uint[] calldata epoch,\\n        uint[] calldata bribeIds,\\n        address[] calldata collection,\\n        uint[] calldata votes,\\n        bytes32[][] calldata merkleProof\\n    ) external;\\n\\n    /**\\n     * Claims against all bribes in a collection for a user.\\n     */\\n    function claimAll(\\n        address account,\\n        uint[] calldata epoch,\\n        address[] calldata collection,\\n        uint[] calldata votes,\\n        bytes32[][] calldata merkleProof\\n    ) external;\\n\\n    /**\\n     * Allows the bribe creator to withdraw unclaimed funds when the claim window has expired.\\n     *\\n     * @param bribeId The bribe ID to be reclaimed\\n     */\\n    function reclaimExpiredFunds(uint bribeId) external;\\n\\n    /**\\n     * Checks if the user has already claimed against a bribe at an epoch.\\n     */\\n    function hasUserClaimed(uint bribeId, uint epoch) external view returns (bool);\\n\\n    /**\\n     * Allows our oracle wallet to upload a merkle root to define claims available against\\n     * a bribe when the epoch ends.\\n     */\\n    function registerClaims(uint epoch, bytes32 merkleRoot, address[] calldata collections, uint[] calldata collectionVotes) external;\\n\\n    /**\\n     * Sets our authorised oracle wallet that will upload bribe claims.\\n     */\\n    function setOracleWallet(address _oracleWallet) external;\\n\\n    /**\\n     * Allows our platform to increase the length of any sweep war bribes.\\n     *\\n     * @dev This will be called by the {EpochManager} when a New Collection War is created\\n     * to extend the duration any Sweep War bribes that would be active at that epoch.\\n     */\\n    function extendBribes(uint epoch) external;\\n\\n    /**\\n     * Allows our oracle wallet to expire collection bribes when they have expired.\\n     */\\n    function expireCollectionBribes(address[] calldata collection, uint[] calldata index) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/utils/EpochEndTriggered.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IEpochEndTriggered {\\n    /**\\n     * Function that is triggered when an epoch ends.\\n     */\\n    function endEpoch(uint epoch) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/voting/NewCollectionWars.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface INewCollectionWars {\\n    /**\\n     * For each FloorWar that is created, this structure will be created. When\\n     * the epoch ends, the FloorWar will remain and will be updated with information\\n     * on the winning collection and the votes attributed to each collection.\\n     */\\n    struct FloorWar {\\n        uint index;\\n        uint startEpoch;\\n        address[] collections;\\n    }\\n\\n    /// Sent when a user casts a vote\\n    event VoteCast(address sender, address collection, uint userVotes, uint collectionVotes);\\n\\n    /// Sent when a collection vote is revoked\\n    event VoteRevoked(address sender, address collection, uint collectionVotes);\\n\\n    /// Sent when a collection NFT is staked to vote\\n    event NftVoteCast(address sender, uint war, address collection, uint collectionVotes, uint collectionNftVotes);\\n\\n    /// Sent when a Collection Addition War is created\\n    event CollectionAdditionWarCreated(uint epoch, address[] collections, uint[] floorPrices);\\n\\n    /// Sent when a Collection Addition War is started\\n    event CollectionAdditionWarStarted(uint warIndex);\\n\\n    /// Sent when a Collection Addition War ends\\n    event CollectionAdditionWarEnded(uint warIndex, address collection);\\n\\n    /// Sent when Collection Addition War NFTs are exercised\\n    event CollectionExercised(uint warIndex, address collection, uint value);\\n\\n    /// Sent when the {NewCollectionWarOptions} contract address is updated\\n    event NewCollectionWarOptionsUpdated(address newCollectionWarOptions);\\n\\n    /// Stores the number of votes a user has placed against a war collection\\n    function userVotes(bytes32) external view returns (uint);\\n\\n    /// Stores the floor spot price of a collection token against a war collection\\n    function collectionSpotPrice(bytes32) external view returns (uint);\\n\\n    /// Stores the total number of votes against a war collection\\n    function collectionVotes(bytes32) external view returns (uint);\\n    function collectionNftVotes(bytes32) external view returns (uint);\\n\\n    /// Stores which collection the user has cast their votes towards to allow for\\n    /// reallocation on subsequent votes if needed.\\n    function userCollectionVote(bytes32) external view returns (address);\\n\\n    /// Stores the address of the collection that won a Floor War\\n    function floorWarWinner(uint _epoch) external view returns (address);\\n\\n    /// Stores if a collection has been flagged as ERC1155\\n    function is1155(address) external returns (bool);\\n\\n    /// Stores the unlock epoch of a collection in a floor war\\n    function collectionEpochLock(bytes32) external returns (uint);\\n\\n    /**\\n     * The total voting power of a user, regardless of if they have cast votes\\n     * or not.\\n     *\\n     * @param _user User address being checked\\n     */\\n    function userVotingPower(address _user) external view returns (uint);\\n\\n    /**\\n     * The total number of votes that a user has available.\\n     *\\n     * @param _user User address being checked\\n     *\\n     * @return uint Number of votes available to the user\\n     */\\n    function userVotesAvailable(uint _war, address _user) external view returns (uint);\\n\\n    /**\\n     * Allows the user to cast 100% of their voting power against an individual\\n     * collection. If the user has already voted on the FloorWar then this will\\n     * additionally reallocate their votes.\\n     */\\n    function vote(address collection) external;\\n\\n    /**\\n     * Allows an approved contract to submit option-related votes against a collection\\n     * in the current war.\\n     *\\n     * @param sender The address of the user that staked the token\\n     * @param collection The collection to cast the vote against\\n     * @param votingPower The voting power added from the option creation\\n     */\\n    function optionVote(address sender, uint war, address collection, uint votingPower) external;\\n\\n    /**\\n     * Revokes a user's current votes in the current war.\\n     *\\n     * @dev This is used when a user unstakes their floor\\n     *\\n     * @param account The address of the account that is having their vote revoked\\n     */\\n    function revokeVotes(address account) external;\\n\\n    /**\\n     * Allow an authorised user to create a new floor war to start with a range of\\n     * collections from a specific epoch.\\n     */\\n    function createFloorWar(uint epoch, address[] calldata collections, bool[] calldata isErc1155, uint[] calldata floorPrices)\\n        external\\n        returns (uint);\\n\\n    /**\\n     * Sets a scheduled {FloorWar} to be active.\\n     *\\n     * @dev This function is called by the {EpochManager} when a new epoch starts\\n     *\\n     * @param index The index of the {FloorWar} being started\\n     */\\n    function startFloorWar(uint index) external;\\n\\n    /**\\n     * When the epoch has come to an end, this function will be called to finalise\\n     * the votes and decide which collection has won. This collection will then need\\n     * to be added to the {CollectionRegistry}.\\n     *\\n     * Any NFTs that have been staked will be timelocked for an additional epoch to\\n     * give the DAO time to exercise or reject any options.\\n     *\\n     * @dev We can't action this in one single call as we will need information about\\n     * the underlying NFTX token as well.\\n     */\\n    function endFloorWar() external returns (address highestVoteCollection);\\n\\n    /**\\n     * Allows us to update our collection floor prices if we have seen a noticable difference\\n     * since the start of the epoch. This will need to be called for this reason as the floor\\n     * price of the collection heavily determines the amount of voting power awarded when\\n     * creating an option.\\n     */\\n    function updateCollectionFloorPrice(address collection, uint floorPrice) external;\\n\\n    /**\\n     * Allows our options contract to be updated.\\n     *\\n     * @param _contract The new contract to use\\n     */\\n    function setOptionsContract(address _contract) external;\\n\\n    /**\\n     * Check if a collection is in a FloorWar.\\n     */\\n    function isCollectionInWar(bytes32 warCollection) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/EpochManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * Handles epoch management for all other contracts.\\n */\\ninterface IEpochManager {\\n\\n    /// Emitted when an epoch is ended\\n    event EpochEnded(uint epoch, uint timestamp);\\n\\n    /// Emitted when a new collection war is scheduled\\n    event CollectionAdditionWarScheduled(uint epoch, uint index);\\n\\n    /// Emitted when required contracts are updated\\n    event EpochManagerContractsUpdated(address newCollectionWars, address voteMarket);\\n\\n    /**\\n     * The current epoch that is running across the codebase.\\n     *\\n     * @return The current epoch\\n     */\\n    function currentEpoch() external view returns (uint);\\n\\n    /**\\n     * Stores a mapping of an epoch to a collection addition war index.\\n     *\\n     * @param _epoch Epoch to check\\n     *\\n     * @return Index of the collection addition war. Will return 0 if none found\\n     */\\n    function collectionEpochs(uint _epoch) external view returns (uint);\\n\\n    /**\\n     * Will return if the current epoch is a collection addition vote.\\n     *\\n     * @return If the current epoch is a collection addition\\n     */\\n    function isCollectionAdditionEpoch() external view returns (bool);\\n\\n    /**\\n     * Will return if the specified epoch is a collection addition vote.\\n     *\\n     * @param epoch The epoch to check\\n     *\\n     * @return If the specified epoch is a collection addition\\n     */\\n    function isCollectionAdditionEpoch(uint epoch) external view returns (bool);\\n\\n    /**\\n     * Allows an epoch to be scheduled to be a collection addition vote. An index will\\n     * be specified to show which collection addition will be used. The index will not\\n     * be a zero value.\\n     *\\n     * @param epoch The epoch that the Collection Addition will take place in\\n     * @param index The Collection Addition array index\\n     */\\n    function scheduleCollectionAdditionEpoch(uint epoch, uint index) external;\\n\\n    /**\\n     * Triggers an epoch to end.\\n     *\\n     * @dev More information about this function can be found in the actual contract\\n     */\\n    function endEpoch() external;\\n\\n    /**\\n     * Provides an estimated timestamp of when an epoch started, and also the earliest\\n     * that an epoch in the future could start.\\n     *\\n     * @param _epoch The epoch to find the estimated timestamp of\\n     *\\n     * @return The estimated timestamp of when the specified epoch started\\n     */\\n    function epochIterationTimestamp(uint _epoch) external returns (uint);\\n\\n    /**\\n     * The length of an epoch in seconds.\\n     *\\n     * @return The length of the epoch in seconds\\n     */\\n    function EPOCH_LENGTH() external returns (uint);\\n\\n    /**\\n     * Sets contracts that the epoch manager relies on. This doesn't have to include\\n     * all of the contracts that are {EpochManaged}, but only needs to set ones that the\\n     * {EpochManager} needs to interact with.\\n     */\\n    function setContracts(address _newCollectionWars, address _voteMarket) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@uniswap-v3/=lib/\",\r\n      \"@uniswap/v3-periphery/=lib/v3-periphery/\",\r\n      \"@chainlink/=lib/chainlink/\",\r\n      \"@murky/=lib/murky/src/\",\r\n      \"@solidity-math-utils/=lib/solidity-math-utils/project/contracts/\",\r\n      \"@solidity-trigonometry/=lib/solidity-trigonometry/src/\",\r\n      \"@1inch/=lib/\",\r\n      \"@charmfi/=lib/charmfi-contracts-0.8.0-support/\",\r\n      \"@sudoswap/=lib/lssvm/src/\",\r\n      \"@floor/=src/contracts/\",\r\n      \"@floor-interfaces/=src/interfaces/\",\r\n      \"@floor-scripts/=script/\",\r\n      \"@ERC721A/=lib/ERC721A/contracts/\",\r\n      \"foundry-random/=lib/foundry-random/src/\",\r\n      \"lssvm2/=lib/lssvm2/src/\",\r\n      \"@nftx-protocol-v3/=lib/nftx-protocol-v3/src/\",\r\n      \"@manifoldxyz/=lib/lssvm2/lib/\",\r\n      \"@mocks/=lib/nftx-protocol-v3/src/mocks/\",\r\n      \"@permit2/=lib/nftx-protocol-v3/lib/permit2/src/\",\r\n      \"@prb/math/=lib/lssvm2/lib/prb-math/src/\",\r\n      \"@prb/test/=lib/foundry-random/lib/prb-test/src/\",\r\n      \"@src/=lib/nftx-protocol-v3/src/\",\r\n      \"@test/=lib/nftx-protocol-v3/test/\",\r\n      \"@uni-core/=lib/nftx-protocol-v3/src/uniswap/v3-core/\",\r\n      \"@uni-periphery/=lib/nftx-protocol-v3/src/uniswap/v3-periphery/\",\r\n      \"@uniswap/lib/=lib/nftx-protocol-v3/lib/solidity-lib/\",\r\n      \"@uniswap/v2-core/=lib/nftx-protocol-v3/lib/v2-core/\",\r\n      \"@uniswap/v3-core/contracts/=lib/nftx-protocol-v3/src/uniswap/v3-core/\",\r\n      \"CramBit/=lib/foundry-random/lib/CramBit/\",\r\n      \"ERC721A/=lib/ERC721A/contracts/\",\r\n      \"base64-sol/=lib/nftx-protocol-v3/src/uniswap/v3-periphery/libraries/\",\r\n      \"chainlink/=lib/chainlink/\",\r\n      \"charmfi-contracts-0.8.0-support/=lib/charmfi-contracts-0.8.0-support/\",\r\n      \"clones-with-immutable-args/=lib/lssvm2/lib/clones-with-immutable-args/src/\",\r\n      \"crambit/=lib/foundry-random/lib/CramBit/src/\",\r\n      \"create2-helpers/=lib/lssvm2/lib/royalty-registry-solidity/lib/create2-helpers/\",\r\n      \"create3-factory/=lib/lssvm2/lib/create3-factory/\",\r\n      \"foundry-huff/=lib/lssvm2/lib/foundry-huff/src/\",\r\n      \"foundry-random/=lib/foundry-random/src/\",\r\n      \"huffmate/=lib/lssvm2/lib/huffmate/src/\",\r\n      \"libraries-solidity/=lib/lssvm2/lib/libraries-solidity/contracts/\",\r\n      \"lssvm/=lib/lssvm/src/\",\r\n      \"lssvm2/=lib/lssvm2/src/\",\r\n      \"manifoldxyz/=lib/lssvm2/lib/royalty-registry-solidity/contracts/\",\r\n      \"murky/=lib/murky/src/\",\r\n      \"nftx-protocol-v3/=lib/nftx-protocol-v3/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"prb-math/=lib/solidity-trigonometry/lib/prb-math/contracts/\",\r\n      \"prb-test/=lib/foundry-random/lib/prb-test/src/\",\r\n      \"royalty-registry-solidity.git/=lib/lssvm/lib/royalty-registry-solidity.git/contracts/\",\r\n      \"royalty-registry-solidity/=lib/lssvm2/lib/royalty-registry-solidity/\",\r\n      \"solidity-bytes-utils/=lib/foundry-random/lib/solidity-bytes-utils/contracts/\",\r\n      \"solidity-math-utils/=lib/solidity-math-utils/\",\r\n      \"solidity-stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"solidity-trigonometry/=lib/solidity-trigonometry/src/\",\r\n      \"solidity-utils/=lib/solidity-utils/contracts/\",\r\n      \"solmate/=lib/lssvm2/lib/solmate/src/\",\r\n      \"src/=lib/foundry-random/src/\",\r\n      \"stringutils/=lib/lssvm2/lib/foundry-huff/lib/solidity-stringutils/\",\r\n      \"v3-core/=lib/v3-core/contracts/\",\r\n      \"v3-periphery/=lib/v3-periphery/contracts/\",\r\n      \"weird-erc20/=lib/lssvm/lib/solmate/lib/weird-erc20/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"CannotSetNullAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timelockExpiry\",\"type\":\"uint256\"}],\"name\":\"EpochTimelocked\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"CollectionAdditionWarScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"EpochEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCollectionWars\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voteMarket\",\"type\":\"address\"}],\"name\":\"EpochManagerContractsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EPOCH_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collectionEpochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochEndTriggers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"epochIterationTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"isCollectionAdditionEpoch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCollectionAdditionEpoch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newCollectionWars\",\"outputs\":[{\"internalType\":\"contract INewCollectionWars\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"scheduleCollectionAdditionEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCollectionWars\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_voteMarket\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setEpochEndTrigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteMarket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EpochManager", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}