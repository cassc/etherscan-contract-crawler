{"SourceCode": "pragma solidity ^0.4.4;\r\n\r\ncontract DigiPulse {\r\n\r\n\t// Token data for ERC20\r\n  string public constant name = \"DigiPulse\";\r\n  string public constant symbol = \"DGT\";\r\n  uint8 public constant decimals = 8;\r\n  mapping (address => uint256) public balanceOf;\r\n\r\n  // Max available supply is 16581633 * 1e8 (incl. 100000 presale and 2% bounties)\r\n  uint constant tokenSupply = 16125000 * 1e8;\r\n  uint8 constant dgtRatioToEth = 250;\r\n  uint constant raisedInPresale = 961735343125;\r\n  mapping (address => uint256) ethBalanceOf;\r\n  address owner;\r\n\r\n  // For LIVE\r\n  uint constant startOfIco = 1501833600; // 08/04/2017 @ 8:00am (UTC)\r\n  uint constant endOfIco = 1504223999; // 08/31/2017 @ 23:59pm (UTC)\r\n\r\n  uint allocatedSupply = 0;\r\n  bool icoFailed = false;\r\n  bool icoFulfilled = false;\r\n\r\n  // Generate public event that will notify clients\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Refund(address indexed _from, uint256 _value);\r\n\r\n  // No special actions are required upon creation, so initialiser is left empty\r\n  function DigiPulse() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  // For future transfers of DGT\r\n  function transfer(address _to, uint256 _value) {\r\n    require (balanceOf[msg.sender] >= _value);          // Check if the sender has enough\r\n    require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\r\n\r\n    balanceOf[msg.sender] -= _value;                    // Subtract from the sender\r\n    balanceOf[_to] += _value;                           // Add the same to the recipient\r\n\r\n    Transfer(msg.sender, _to, _value);\r\n  }\r\n\r\n  // logic which converts eth to dgt and stores in allocatedSupply\r\n  function() payable external {\r\n    // Abort if crowdfunding has reached an end\r\n    require (now > startOfIco);\r\n    require (now < endOfIco);\r\n    require (!icoFulfilled);\r\n\r\n    // Do not allow creating 0 tokens\r\n    require (msg.value != 0);\r\n\r\n    // Must adjust number of decimals, so the ratio will work as expected\r\n    // From ETH 16 decimals to DGT 8 decimals\r\n    uint256 dgtAmount = msg.value / 1e10 * dgtRatioToEth;\r\n    require (dgtAmount < (tokenSupply - allocatedSupply));\r\n\r\n    // Tier bonus calculations\r\n    uint256 dgtWithBonus;\r\n    uint256 applicable_for_tier;\r\n\r\n    for (uint8 i = 0; i < 4; i++) {\r\n      // Each tier has same amount of DGT\r\n      uint256 tier_amount = 3750000 * 1e8;\r\n      // Every next tier has 5% less bonus pool\r\n      uint8 tier_bonus = 115 - (i * 5);\r\n      applicable_for_tier += tier_amount;\r\n\r\n      // Skipping over this tier, since it is filled already\r\n      if (allocatedSupply >= applicable_for_tier) continue;\r\n\r\n      // Reached this tier with 0 amount, so abort\r\n      if (dgtAmount == 0) break;\r\n\r\n      // Cases when part of the contribution is covering two tiers\r\n      int256 diff = int(allocatedSupply) + int(dgtAmount - applicable_for_tier);\r\n\r\n      if (diff > 0) {\r\n        // add bonus for current tier and strip the difference for\r\n        // calculation in the next tier\r\n        dgtWithBonus += (uint(int(dgtAmount) - diff) * tier_bonus / 100);\r\n        dgtAmount = uint(diff);\r\n      } else {\r\n        dgtWithBonus += (dgtAmount * tier_bonus / 100);\r\n        dgtAmount = 0;\r\n      }\r\n    }\r\n\r\n    // Increase supply\r\n    allocatedSupply += dgtWithBonus;\r\n\r\n    // Assign new tokens to the sender and log token creation event\r\n    ethBalanceOf[msg.sender] += msg.value;\r\n    balanceOf[msg.sender] += dgtWithBonus;\r\n    Transfer(0, msg.sender, dgtWithBonus);\r\n  }\r\n\r\n  // Decide the state of the project\r\n  function finalise() external {\r\n    require (!icoFailed);\r\n    require (!icoFulfilled);\r\n    require (now > endOfIco || allocatedSupply >= tokenSupply);\r\n\r\n    // Min cap is 8000 ETH\r\n    if (this.balance < 8000 ether) {\r\n      icoFailed = true;\r\n    } else {\r\n      setPreSaleAmounts();\r\n      allocateBountyTokens();\r\n      icoFulfilled = true;\r\n    }\r\n  }\r\n\r\n  // If the goal is not reached till the end of the ICO\r\n  // allow refunds\r\n  function refundEther() external {\r\n  \trequire (icoFailed);\r\n\r\n    var ethValue = ethBalanceOf[msg.sender];\r\n    require (ethValue != 0);\r\n    ethBalanceOf[msg.sender] = 0;\r\n\r\n    // Refund original Ether amount\r\n    msg.sender.transfer(ethValue);\r\n    Refund(msg.sender, ethValue);\r\n  }\r\n\r\n  // Returns balance raised in ETH from specific address\r\n\tfunction getBalanceInEth(address addr) returns(uint){\r\n\t\treturn ethBalanceOf[addr];\r\n\t}\r\n\r\n  // Returns balance raised in DGT from specific address\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balanceOf[_owner];\r\n  }\r\n\r\n\t// Get remaining supply of DGT\r\n\tfunction getRemainingSupply() returns(uint) {\r\n\t\treturn tokenSupply - allocatedSupply;\r\n\t}\r\n\r\n  // Get raised amount during ICO\r\n  function totalSupply() returns (uint totalSupply) {\r\n    return allocatedSupply;\r\n  }\r\n\r\n  // Upon successfull ICO\r\n  // Allow owner to withdraw funds\r\n  function withdrawFundsToOwner(uint256 _amount) {\r\n    require (icoFulfilled);\r\n    require (this.balance >= _amount);\r\n\r\n    owner.transfer(_amount);\r\n  }\r\n\r\n  // Raised during Pre-sale\r\n  // Since some of the wallets in pre-sale were on exchanges, we transfer tokens\r\n  // to account which will send tokens manually out\r\n\tfunction setPreSaleAmounts() private {\r\n    balanceOf[0x8776A6fA922e65efcEa2371692FEFE4aB7c933AB] += raisedInPresale;\r\n    allocatedSupply += raisedInPresale;\r\n    Transfer(0, 0x8776A6fA922e65efcEa2371692FEFE4aB7c933AB, raisedInPresale);\r\n\t}\r\n\r\n\t// Bounty pool makes up 2% from all tokens bought\r\n\tfunction allocateBountyTokens() private {\r\n    uint256 bountyAmount = allocatedSupply * 100 / 98 * 2 / 100;\r\n\t\tbalanceOf[0x663F98e9c37B9bbA460d4d80ca48ef039eAE4052] += bountyAmount;\r\n    allocatedSupply += bountyAmount;\r\n    Transfer(0, 0x663F98e9c37B9bbA460d4d80ca48ef039eAE4052, bountyAmount);\r\n\t}\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFundsToOwner\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refundEther\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getBalanceInEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalise\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getRemainingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"}]", "ContractName": "DigiPulse", "CompilerVersion": "v0.4.13+commit.fb4cb1a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://470ac43204901dc7db9d442d8dbf8692c7e30a11d5792d8f022e370d5ced1fd6"}