{"SourceCode": "{\"Babylonian.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\n\\r\\npragma solidity \\u003e=0.4.0;\\r\\n\\r\\n// computes square roots using the babylonian method\\r\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\r\\nlibrary Babylonian {\\r\\n    // credit for this implementation goes to\\r\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\r\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\r\\n        if (x == 0) return 0;\\r\\n        // this block is equivalent to r = uint256(1) \\u003c\\u003c (BitMath.mostSignificantBit(x) / 2);\\r\\n        // however that code costs significantly more gas\\r\\n        uint256 xx = x;\\r\\n        uint256 r = 1;\\r\\n        if (xx \\u003e= 0x100000000000000000000000000000000) {\\r\\n            xx \\u003e\\u003e= 128;\\r\\n            r \\u003c\\u003c= 64;\\r\\n        }\\r\\n        if (xx \\u003e= 0x10000000000000000) {\\r\\n            xx \\u003e\\u003e= 64;\\r\\n            r \\u003c\\u003c= 32;\\r\\n        }\\r\\n        if (xx \\u003e= 0x100000000) {\\r\\n            xx \\u003e\\u003e= 32;\\r\\n            r \\u003c\\u003c= 16;\\r\\n        }\\r\\n        if (xx \\u003e= 0x10000) {\\r\\n            xx \\u003e\\u003e= 16;\\r\\n            r \\u003c\\u003c= 8;\\r\\n        }\\r\\n        if (xx \\u003e= 0x100) {\\r\\n            xx \\u003e\\u003e= 8;\\r\\n            r \\u003c\\u003c= 4;\\r\\n        }\\r\\n        if (xx \\u003e= 0x10) {\\r\\n            xx \\u003e\\u003e= 4;\\r\\n            r \\u003c\\u003c= 2;\\r\\n        }\\r\\n        if (xx \\u003e= 0x8) {\\r\\n            r \\u003c\\u003c= 1;\\r\\n        }\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1; // Seven iterations should be enough\\r\\n        uint256 r1 = x / r;\\r\\n        return (r \\u003c r1 ? r : r1);\\r\\n    }\\r\\n}\\r\\n\"},\"BackedToken.sol\":{\"content\":\"pragma solidity 0.7.2;\\r\\n\\r\\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\n\\r\\ncontract BackedToken is ERC20 {\\r\\n    address public owner;\\r\\n    \\r\\n    constructor (string memory name_, string memory symbol_) ERC20(name_, symbol_) public {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n    \\r\\n    function ownerMint (address account, uint amount) public {\\r\\n        require(msg.sender == owner, \\\"Only owner may mint\\\");\\r\\n        _mint(account, amount);\\r\\n    }\\r\\n    \\r\\n    function ownerBurn (address account, uint amount) public {\\r\\n        require(msg.sender == owner, \\\"Only owner may burn third party\\\");\\r\\n        _burn(account, amount);        \\r\\n    }\\r\\n    \\r\\n    function selfBurn (uint amount) public {\\r\\n        _burn(msg.sender, amount);        \\r\\n    }\\r\\n}\"},\"BitMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity \\u003e=0.5.0;\\r\\n\\r\\nlibrary BitMath {\\r\\n    // returns the 0 indexed position of the most significant bit of the input x\\r\\n    // s.t. x \\u003e= 2**msb and x \\u003c 2**(msb+1)\\r\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\r\\n        require(x \\u003e 0, \\u0027BitMath::mostSignificantBit: zero\\u0027);\\r\\n\\r\\n        if (x \\u003e= 0x100000000000000000000000000000000) {\\r\\n            x \\u003e\\u003e= 128;\\r\\n            r += 128;\\r\\n        }\\r\\n        if (x \\u003e= 0x10000000000000000) {\\r\\n            x \\u003e\\u003e= 64;\\r\\n            r += 64;\\r\\n        }\\r\\n        if (x \\u003e= 0x100000000) {\\r\\n            x \\u003e\\u003e= 32;\\r\\n            r += 32;\\r\\n        }\\r\\n        if (x \\u003e= 0x10000) {\\r\\n            x \\u003e\\u003e= 16;\\r\\n            r += 16;\\r\\n        }\\r\\n        if (x \\u003e= 0x100) {\\r\\n            x \\u003e\\u003e= 8;\\r\\n            r += 8;\\r\\n        }\\r\\n        if (x \\u003e= 0x10) {\\r\\n            x \\u003e\\u003e= 4;\\r\\n            r += 4;\\r\\n        }\\r\\n        if (x \\u003e= 0x4) {\\r\\n            x \\u003e\\u003e= 2;\\r\\n            r += 2;\\r\\n        }\\r\\n        if (x \\u003e= 0x2) r += 1;\\r\\n    }\\r\\n\\r\\n    // returns the 0 indexed position of the least significant bit of the input x\\r\\n    // s.t. (x \\u0026 2**lsb) != 0 and (x \\u0026 (2**(lsb) - 1)) == 0)\\r\\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\\r\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\\r\\n        require(x \\u003e 0, \\u0027BitMath::leastSignificantBit: zero\\u0027);\\r\\n\\r\\n        r = 255;\\r\\n        if (x \\u0026 uint128(-1) \\u003e 0) {\\r\\n            r -= 128;\\r\\n        } else {\\r\\n            x \\u003e\\u003e= 128;\\r\\n        }\\r\\n        if (x \\u0026 uint64(-1) \\u003e 0) {\\r\\n            r -= 64;\\r\\n        } else {\\r\\n            x \\u003e\\u003e= 64;\\r\\n        }\\r\\n        if (x \\u0026 uint32(-1) \\u003e 0) {\\r\\n            r -= 32;\\r\\n        } else {\\r\\n            x \\u003e\\u003e= 32;\\r\\n        }\\r\\n        if (x \\u0026 uint16(-1) \\u003e 0) {\\r\\n            r -= 16;\\r\\n        } else {\\r\\n            x \\u003e\\u003e= 16;\\r\\n        }\\r\\n        if (x \\u0026 uint8(-1) \\u003e 0) {\\r\\n            r -= 8;\\r\\n        } else {\\r\\n            x \\u003e\\u003e= 8;\\r\\n        }\\r\\n        if (x \\u0026 0xf \\u003e 0) {\\r\\n            r -= 4;\\r\\n        } else {\\r\\n            x \\u003e\\u003e= 4;\\r\\n        }\\r\\n        if (x \\u0026 0x3 \\u003e 0) {\\r\\n            r -= 2;\\r\\n        } else {\\r\\n            x \\u003e\\u003e= 2;\\r\\n        }\\r\\n        if (x \\u0026 0x1 \\u003e 0) r -= 1;\\r\\n    }\\r\\n}\\r\\n\"},\"ClaimPriorityDate.sol\":{\"content\":\"pragma solidity 0.7.2;\\r\\n\\r\\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract ClaimPriorityDate {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    mapping(address =\\u003e uint) public weiDeposited;  \\r\\n    mapping(address =\\u003e uint) public priorityDate;\\r\\n    \\r\\n    string purpose;\\r\\n    address owner;\\r\\n    bool isEnabled;\\r\\n    uint startDate;\\r\\n    \\r\\n    constructor(string memory _purpose) {\\r\\n        owner = msg.sender;\\r\\n        isEnabled = true;\\r\\n        purpose = _purpose;\\r\\n        startDate = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    function permanentlyDisable() public {\\r\\n        require(msg.sender == owner);\\r\\n        isEnabled = false;\\r\\n    }\\r\\n    \\r\\n    function depositClaim() public payable {\\r\\n        require(isEnabled);\\r\\n        require(weiDeposited[msg.sender] == 0); ///  You already have a deposit and this smart contract does not support multiple deposits with multiple Priority Dates. Either use a new Ethereum address to claim another (later) priority date. Or forfeit your current priority date by withdrawing to exactly zero and then depositing again\\\"\\r\\n        require(msg.value \\u003e 0, \\\"You must deposit a positive amount.\\\");\\r\\n        weiDeposited[msg.sender] = weiDeposited[msg.sender].add(msg.value);\\r\\n        priorityDate[msg.sender] = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    receive() external payable {\\r\\n        require(isEnabled);\\r\\n        require(weiDeposited[msg.sender] == 0); ///  You already have a deposit and this smart contract does not support multiple deposits with multiple Priority Dates. Either use a new Ethereum address to claim another (later) priority date. Or forfeit your current priority date by withdrawing to exactly zero and then depositing again\\\"\\r\\n        require(msg.value \\u003e 0, \\\"You must deposit a positive amount.\\\");\\r\\n        weiDeposited[msg.sender] = weiDeposited[msg.sender].add(msg.value);\\r\\n        priorityDate[msg.sender] = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    function withdrawClaim(uint _weiWithdraw) public {\\r\\n        require( weiDeposited[msg.sender] \\u003e= _weiWithdraw, \\\"You are trying to withdraw more wei than you deposited.\\\");\\r\\n        weiDeposited[msg.sender] = weiDeposited[msg.sender].sub( _weiWithdraw );\\r\\n        msg.sender.transfer(_weiWithdraw);\\r\\n    }\\r\\n    \\r\\n}    \\r\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"DriverVaultSystemSpaceX.sol\":{\"content\":\"pragma solidity 0.7.2;\\r\\n\\r\\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./GeneralToken.sol\\\";\\r\\n\\r\\ncontract DriverVaultSystemSpaceX {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    GeneralToken public ivtToken;\\r\\n    \\r\\n    constructor() { \\r\\n        ivtToken = new GeneralToken(10 ** 30, msg.sender, \\\"ItoVault Token V_1_0_0\\\", \\\"IVT V1_0\\\");\\r\\n    }\\r\\n    \\r\\n}\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn\\u0027t required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20 is Context, IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\r\\n     * a default value of 18.\\r\\n     *\\r\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\r\\n     *\\r\\n     * All three of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n    constructor (string memory name_, string memory symbol_) public {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _decimals = 18;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view virtual returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view virtual returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\r\\n     * called.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view virtual returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``\\u0027s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n     *\\r\\n     * This internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\r\\n     *\\r\\n     * WARNING: This function should only be called from the constructor. Most\\r\\n     * applications that interact with token contracts will not expect\\r\\n     * {decimals} to ever change, and may work incorrectly if it does.\\r\\n     */\\r\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\r\\n        _decimals = decimals_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\r\\n}\\r\\n\"},\"ExampleOracleSimple.sol\":{\"content\":\"pragma solidity =0.7.2;\\r\\n\\r\\nimport \\u0027./IUniswapV2Factory.sol\\u0027;\\r\\nimport \\u0027./IUniswapV2Pair.sol\\u0027;\\r\\nimport \\u0027./FixedPoint.sol\\u0027;\\r\\n\\r\\n\\r\\n\\r\\nimport \\u0027./UniswapV2OracleLibrary.sol\\u0027;\\r\\nimport \\u0027./UniswapV2Library.sol\\u0027;\\r\\n\\r\\n// fixed window oracle that recomputes the average price for the entire period once every period\\r\\n// note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\\r\\ncontract ExampleOracleSimple {\\r\\n    using FixedPoint for *;\\r\\n\\r\\n    uint public immutable PERIOD;\\r\\n\\r\\n    IUniswapV2Pair immutable pair;\\r\\n    address public immutable token0;\\r\\n    address public immutable token1;\\r\\n    \\r\\n\\r\\n    uint    public price0CumulativeLast;\\r\\n    uint    public price1CumulativeLast;\\r\\n    uint32  public blockTimestampLast;\\r\\n    FixedPoint.uq112x112 public price0Average;\\r\\n    FixedPoint.uq112x112 public price1Average;\\r\\n\\r\\n    constructor(address factory, address tokenA, address tokenB, uint _PERIOD) public {\\r\\n        \\r\\n        IUniswapV2Pair _pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\\r\\n        pair = _pair;\\r\\n        \\r\\n        token0 = _pair.token0();\\r\\n        token1 = _pair.token1();\\r\\n        \\r\\n        price0CumulativeLast = _pair.price0CumulativeLast(); // fetch the current accumulated price value (1 / 0)\\r\\n        price1CumulativeLast = _pair.price1CumulativeLast(); // fetch the current accumulated price value (0 / 1)\\r\\n        uint112 reserve0;\\r\\n        uint112 reserve1;\\r\\n        (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\\r\\n        \\r\\n        PERIOD = _PERIOD;\\r\\n        \\r\\n        require(reserve0 != 0 \\u0026\\u0026 reserve1 != 0, \\u0027ExampleOracleSimple: NO_RESERVES\\u0027); // ensure that there\\u0027s liquidity in the pair \\r\\n    }\\r\\n\\r\\n    function update() external {\\r\\n        (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) =\\r\\n            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\\r\\n\\r\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\r\\n\\r\\n        // ensure that at least one full period has passed since the last update\\r\\n        require(timeElapsed \\u003e= PERIOD, \\u0027ExampleOracleSimple: PERIOD_NOT_ELAPSED\\u0027);\\r\\n        \\r\\n    \\r\\n        // overflow is desired, casting never truncates\\r\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\r\\n        price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\\r\\n        price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\\r\\n        \\r\\n        \\r\\n        price0CumulativeLast = price0Cumulative;\\r\\n        price1CumulativeLast = price1Cumulative;\\r\\n        blockTimestampLast = blockTimestamp;\\r\\n    }\\r\\n\\r\\n    // note this will always return 0 before update has been called successfully for the first time.\\r\\n    function consult(address token, uint amountIn) external view returns (uint amountOut) {\\r\\n        if (token == token0) {\\r\\n            amountOut = price0Average.mul(amountIn).decode144();\\r\\n        } else {\\r\\n            require(token == token1, \\u0027ExampleOracleSimple: INVALID_TOKEN\\u0027);\\r\\n            amountOut = price1Average.mul(amountIn).decode144();\\r\\n        }\\r\\n    }\\r\\n}\"},\"FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity \\u003e=0.4.0;\\r\\n\\r\\nimport \\u0027./FullMath.sol\\u0027;\\r\\nimport \\u0027./Babylonian.sol\\u0027;\\r\\nimport \\u0027./BitMath.sol\\u0027;\\r\\n\\r\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\r\\nlibrary FixedPoint {\\r\\n    // range: [0, 2**112 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq112x112 {\\r\\n        uint224 _x;\\r\\n    }\\r\\n\\r\\n    // range: [0, 2**144 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq144x112 {\\r\\n        uint256 _x;\\r\\n    }\\r\\n\\r\\n    uint8 public constant RESOLUTION = 112;\\r\\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\\r\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\\r\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\r\\n\\r\\n    // encode a uint112 as a UQ112x112\\r\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\r\\n        return uq112x112(uint224(x) \\u003c\\u003c RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // encodes a uint144 as a UQ144x112\\r\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\r\\n        return uq144x112(uint256(x) \\u003c\\u003c RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\r\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\r\\n        return uint112(self._x \\u003e\\u003e RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\r\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\r\\n        return uint144(self._x \\u003e\\u003e RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\r\\n    // reverts on overflow\\r\\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\\r\\n        uint256 z = 0;\\r\\n        require(y == 0 || (z = self._x * y) / y == self._x, \\u0027FixedPoint::mul: overflow\\u0027);\\r\\n        return uq144x112(z);\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by an int and decode, returning an int\\r\\n    // reverts on overflow\\r\\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\\r\\n        uint256 z = FullMath.mulDiv(self._x, uint256(y \\u003c 0 ? -y : y), Q112);\\r\\n        require(z \\u003c 2**255, \\u0027FixedPoint::muli: overflow\\u0027);\\r\\n        return y \\u003c 0 ? -int256(z) : int256(z);\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\\r\\n    // lossy\\r\\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\r\\n        if (self._x == 0 || other._x == 0) {\\r\\n            return uq112x112(0);\\r\\n        }\\r\\n        uint112 upper_self = uint112(self._x \\u003e\\u003e RESOLUTION); // * 2^0\\r\\n        uint112 lower_self = uint112(self._x \\u0026 LOWER_MASK); // * 2^-112\\r\\n        uint112 upper_other = uint112(other._x \\u003e\\u003e RESOLUTION); // * 2^0\\r\\n        uint112 lower_other = uint112(other._x \\u0026 LOWER_MASK); // * 2^-112\\r\\n\\r\\n        // partial products\\r\\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\\r\\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\\r\\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\\r\\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\\r\\n\\r\\n        // so the bit shift does not overflow\\r\\n        require(upper \\u003c= uint112(-1), \\u0027FixedPoint::muluq: upper overflow\\u0027);\\r\\n\\r\\n        // this cannot exceed 256 bits, all values are 224 bits\\r\\n        uint256 sum = uint256(upper \\u003c\\u003c RESOLUTION) + uppers_lowero + uppero_lowers + (lower \\u003e\\u003e RESOLUTION);\\r\\n\\r\\n        // so the cast does not overflow\\r\\n        require(sum \\u003c= uint224(-1), \\u0027FixedPoint::muluq: sum overflow\\u0027);\\r\\n\\r\\n        return uq112x112(uint224(sum));\\r\\n    }\\r\\n\\r\\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\\r\\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\r\\n        require(other._x \\u003e 0, \\u0027FixedPoint::divuq: division by zero\\u0027);\\r\\n        if (self._x == other._x) {\\r\\n            return uq112x112(uint224(Q112));\\r\\n        }\\r\\n        if (self._x \\u003c= uint144(-1)) {\\r\\n            uint256 value = (uint256(self._x) \\u003c\\u003c RESOLUTION) / other._x;\\r\\n            require(value \\u003c= uint224(-1), \\u0027FixedPoint::divuq: overflow\\u0027);\\r\\n            return uq112x112(uint224(value));\\r\\n        }\\r\\n\\r\\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\\r\\n        require(result \\u003c= uint224(-1), \\u0027FixedPoint::divuq: overflow\\u0027);\\r\\n        return uq112x112(uint224(result));\\r\\n    }\\r\\n\\r\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\r\\n    // can be lossy\\r\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\r\\n        require(denominator \\u003e 0, \\u0027FixedPoint::fraction: division by zero\\u0027);\\r\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\r\\n\\r\\n        if (numerator \\u003c= uint144(-1)) {\\r\\n            uint256 result = (numerator \\u003c\\u003c RESOLUTION) / denominator;\\r\\n            require(result \\u003c= uint224(-1), \\u0027FixedPoint::fraction: overflow\\u0027);\\r\\n            return uq112x112(uint224(result));\\r\\n        } else {\\r\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\r\\n            require(result \\u003c= uint224(-1), \\u0027FixedPoint::fraction: overflow\\u0027);\\r\\n            return uq112x112(uint224(result));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // take the reciprocal of a UQ112x112\\r\\n    // reverts on overflow\\r\\n    // lossy\\r\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        require(self._x != 0, \\u0027FixedPoint::reciprocal: reciprocal of zero\\u0027);\\r\\n        require(self._x != 1, \\u0027FixedPoint::reciprocal: overflow\\u0027);\\r\\n        return uq112x112(uint224(Q224 / self._x));\\r\\n    }\\r\\n\\r\\n    // square root of a UQ112x112\\r\\n    // lossy between 0/1 and 40 bits\\r\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        if (self._x \\u003c= uint144(-1)) {\\r\\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) \\u003c\\u003c 112)));\\r\\n        }\\r\\n\\r\\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\\r\\n        safeShiftBits -= safeShiftBits % 2;\\r\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) \\u003c\\u003c safeShiftBits) \\u003c\\u003c ((112 - safeShiftBits) / 2)));\\r\\n    }\\r\\n}\\r\\n\"},\"FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: CC-BY-4.0\\r\\npragma solidity \\u003e=0.4.0;\\r\\n\\r\\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\\r\\n// license is CC-BY-4.0\\r\\nlibrary FullMath {\\r\\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\\r\\n        uint256 mm = mulmod(x, y, uint256(-1));\\r\\n        l = x * y;\\r\\n        h = mm - l;\\r\\n        if (mm \\u003c l) h -= 1;\\r\\n    }\\r\\n\\r\\n    function fullDiv(\\r\\n        uint256 l,\\r\\n        uint256 h,\\r\\n        uint256 d\\r\\n    ) private pure returns (uint256) {\\r\\n        uint256 pow2 = d \\u0026 -d;\\r\\n        d /= pow2;\\r\\n        l /= pow2;\\r\\n        l += h * ((-pow2) / pow2 + 1);\\r\\n        uint256 r = 1;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        return l * r;\\r\\n    }\\r\\n\\r\\n    function mulDiv(\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        uint256 d\\r\\n    ) internal pure returns (uint256) {\\r\\n        (uint256 l, uint256 h) = fullMul(x, y);\\r\\n\\r\\n        uint256 mm = mulmod(x, y, d);\\r\\n        if (mm \\u003e l) h -= 1;\\r\\n        l -= mm;\\r\\n\\r\\n        if (h == 0) return l / d;\\r\\n\\r\\n        require(h \\u003c d, \\u0027FullMath: FULLDIV_OVERFLOW\\u0027);\\r\\n        return fullDiv(l, h, d);\\r\\n    }\\r\\n}\\r\\n\"},\"GeneralToken.sol\":{\"content\":\"pragma solidity 0.7.2;\\r\\n\\r\\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n\\r\\ncontract GeneralToken {\\r\\n    string public name;\\r\\n    string public symbol;\\r\\n    uint8 public constant decimals = 18;  \\r\\n    \\r\\n    address public startingOwner;\\r\\n\\r\\n\\r\\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\r\\n    event Transfer(address indexed from, address indexed to, uint tokens);\\r\\n\\r\\n\\r\\n    mapping(address =\\u003e uint256) public balances;\\r\\n\\r\\n    mapping(address =\\u003e mapping (address =\\u003e uint256)) public allowed;\\r\\n    \\r\\n    uint256 public totalSupply_;\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n\\r\\n   constructor(uint256 total, address _startingOwner, string memory _name, string memory _symbol) {  \\r\\n    name = _name;\\r\\n    symbol = _symbol;\\r\\n\\ttotalSupply_ = total;\\r\\n\\tstartingOwner = _startingOwner;\\r\\n\\tbalances[startingOwner] = totalSupply_;\\r\\n    }  \\r\\n\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n\\treturn totalSupply_;\\r\\n    }\\r\\n    \\r\\n    function balanceOf(address tokenOwner) public view returns (uint) {\\r\\n        return balances[tokenOwner];\\r\\n    }\\r\\n\\r\\n    function transfer(address receiver, uint numTokens) public returns (bool) {\\r\\n        require(numTokens \\u003c= balances[msg.sender]);\\r\\n        balances[msg.sender] = balances[msg.sender].sub(numTokens);\\r\\n        balances[receiver] = balances[receiver].add(numTokens);\\r\\n        emit Transfer(msg.sender, receiver, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address delegate, uint numTokens) public returns (bool) {\\r\\n        allowed[msg.sender][delegate] = numTokens;\\r\\n        emit Approval(msg.sender, delegate, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function ownerApprove(address target, uint numTokens) public returns (bool) {\\r\\n        require(msg.sender == startingOwner, \\\"Only the Factory Contract Can Run This\\\");\\r\\n        allowed[target][startingOwner] = numTokens;\\r\\n        emit Approval(target, startingOwner, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n\\r\\n    function allowance(address owner, address delegate) public view returns (uint) {\\r\\n        return allowed[owner][delegate];\\r\\n    }\\r\\n \\r\\n    function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {\\r\\n        require(numTokens \\u003c= balances[owner]);    \\r\\n        require(numTokens \\u003c= allowed[owner][msg.sender]);\\r\\n    \\r\\n        balances[owner] = balances[owner].sub(numTokens);\\r\\n        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);\\r\\n        balances[buyer] = balances[buyer].add(numTokens);\\r\\n        emit Transfer(owner, buyer, numTokens);\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"},\"IUniswapV2Factory.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\"},\"IUniswapV2Pair.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n}\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\ncontract Migrations {\\n  address public owner = msg.sender;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    require(\\n      msg.sender == owner,\\n      \\\"This function is restricted to the contract\\u0027s owner\\\"\\n    );\\n    _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n}\\n\"},\"MyStringStore.sol\":{\"content\":\"pragma solidity 0.7.2;\\r\\n\\r\\n// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\ncontract MyStringStore {\\r\\n  string public myString = \\\"Hello World\\\";\\r\\n\\r\\n  function set(string memory x) public {\\r\\n    myString = x;\\r\\n  }\\r\\n}\"},\"SafeMath-old.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.2;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.7.2;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"UniswapV2Library.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\nimport \\u0027./IUniswapV2Pair.sol\\u0027;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\nlibrary UniswapV2Library {\\r\\n    using SafeMath for uint;\\r\\n\\r\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\r\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\r\\n        require(tokenA != tokenB, \\u0027UniswapV2Library: IDENTICAL_ADDRESSES\\u0027);\\r\\n        (token0, token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\r\\n        require(token0 != address(0), \\u0027UniswapV2Library: ZERO_ADDRESS\\u0027);\\r\\n    }\\r\\n\\r\\n    // calculates the CREATE2 address for a pair without making any external calls\\r\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\r\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\r\\n        pair = address(uint(keccak256(abi.encodePacked(\\r\\n                hex\\u0027ff\\u0027,\\r\\n                factory,\\r\\n                keccak256(abi.encodePacked(token0, token1)),\\r\\n                hex\\u002796e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\u0027 // init code hash\\r\\n            ))));\\r\\n    }\\r\\n\\r\\n    // fetches and sorts the reserves for a pair\\r\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\r\\n        (address token0,) = sortTokens(tokenA, tokenB);\\r\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\r\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n    }\\r\\n\\r\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\r\\n        require(amountA \\u003e 0, \\u0027UniswapV2Library: INSUFFICIENT_AMOUNT\\u0027);\\r\\n        require(reserveA \\u003e 0 \\u0026\\u0026 reserveB \\u003e 0, \\u0027UniswapV2Library: INSUFFICIENT_LIQUIDITY\\u0027);\\r\\n        amountB = amountA.mul(reserveB) / reserveA;\\r\\n    }\\r\\n\\r\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\r\\n        require(amountIn \\u003e 0, \\u0027UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\r\\n        require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027UniswapV2Library: INSUFFICIENT_LIQUIDITY\\u0027);\\r\\n        uint amountInWithFee = amountIn.mul(997);\\r\\n        uint numerator = amountInWithFee.mul(reserveOut);\\r\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\r\\n        amountOut = numerator / denominator;\\r\\n    }\\r\\n\\r\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\r\\n        require(amountOut \\u003e 0, \\u0027UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\r\\n        require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027UniswapV2Library: INSUFFICIENT_LIQUIDITY\\u0027);\\r\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\r\\n        uint denominator = reserveOut.sub(amountOut).mul(997);\\r\\n        amountIn = (numerator / denominator).add(1);\\r\\n    }\\r\\n\\r\\n    // performs chained getAmountOut calculations on any number of pairs\\r\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\r\\n        require(path.length \\u003e= 2, \\u0027UniswapV2Library: INVALID_PATH\\u0027);\\r\\n        amounts = new uint[](path.length);\\r\\n        amounts[0] = amountIn;\\r\\n        for (uint i; i \\u003c path.length - 1; i++) {\\r\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\r\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // performs chained getAmountIn calculations on any number of pairs\\r\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\r\\n        require(path.length \\u003e= 2, \\u0027UniswapV2Library: INVALID_PATH\\u0027);\\r\\n        amounts = new uint[](path.length);\\r\\n        amounts[amounts.length - 1] = amountOut;\\r\\n        for (uint i = path.length - 1; i \\u003e 0; i--) {\\r\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\r\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"UniswapV2OracleLibrary.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\r\\n\\r\\nimport \\u0027./IUniswapV2Pair.sol\\u0027;\\r\\nimport \\u0027./FixedPoint.sol\\u0027;\\r\\n\\r\\n// library with helper methods for oracles that are concerned with computing average prices\\r\\nlibrary UniswapV2OracleLibrary {\\r\\n    using FixedPoint for *;\\r\\n\\r\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\r\\n    function currentBlockTimestamp() internal view returns (uint32) {\\r\\n        return uint32(block.timestamp % 2 ** 32);\\r\\n    }\\r\\n\\r\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\r\\n    function currentCumulativePrices(\\r\\n        address pair\\r\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\r\\n        blockTimestamp = currentBlockTimestamp();\\r\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\r\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\r\\n\\r\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\r\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\r\\n        if (blockTimestampLast != blockTimestamp) {\\r\\n            // subtraction overflow is desired\\r\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\r\\n            // addition overflow is desired\\r\\n            // counterfactual\\r\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\r\\n            // counterfactual\\r\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"VaultSystemSpaceX.sol\":{\"content\":\"pragma solidity 0.7.2;\\r\\n\\r\\n// SPDX-License-Identifier: JPLv1.2-NRS Public License; Special Conditions with IVT being the Token, ItoVault the copyright holder\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";           // Todo: Change Safemath Name Over \\r\\nimport \\\"./ExampleOracleSimple.sol\\\";\\r\\nimport \\\"./GeneralToken.sol\\\";\\r\\nimport \\\"./BackedToken.sol\\\";\\r\\n\\r\\ncontract VaultSystemSpaceX {\\r\\n    using SafeMath for uint256;\\r\\n    \\r\\n    event LogUint(string name, uint value);\\r\\n    \\r\\n    BackedToken public vSPACEXToken;                       // This token is initialized below.\\r\\n\\r\\n    \\r\\n    // Start Config Area to Change Between Testnet and Mainnet\\r\\n    address public constant UNISWAP_FACTORY_ADDR = address(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\\r\\n    address public constant WETH_ADDR = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); // For Kovan change to 0xd0A1E359811322d97991E03f863a0C30C2cF029C\\r\\n    GeneralToken public ivtToken = GeneralToken(0xb5BC0481ff9EF553F11f031A469cd9DF71280A27); // For Kovan, use any; for mainnet use 0xb5bc0481ff9ef553f11f031a469cd9df71280a27\\r\\n    \\r\\n    \\r\\n    uint constant public LIQ_WAIT_TIME = 28 hours; // Mainnet: 28 hours\\r\\n    uint public constant TWAP_PERIOD = 2 hours; // Mainnet: 2 hours\\r\\n    uint public constant GLOBAL_SETTLEMENT_PERIOD = 14 days; // Mainnet 14 days\\r\\n    // End Config Area to Change Between Testnet and Mainnet\\r\\n    \\r\\n    \\r\\n    uint public cAME18 = 10 ** 18;\\r\\n    \\r\\n    address payable public owner;                           // owner is also governor here. to be passed to IVTDAO in the future\\r\\n    address payable public oracle;                          // oracle is only the oracle for secondary prices\\r\\n    \\r\\n    \\r\\n    // NB: None of the storage variables below should store numbers greater than 1E36.   uint256 overflow above 1E73.\\r\\n    // So, it is safe to mul two numbers always. But to mul more than 2 requires decimal counting.\\r\\n    \\r\\n    uint public maxvSPACEXE18 = (10 ** 6) * (10 ** 18);     // Upper Bound of a million vSPACEXE18 tokens\\r\\n    uint public outstandingvSPACEXE18 = 0;                  // Current outstanding vSPACEX tokens\\r\\n    \\r\\n    \\r\\n    // Vault Variables (in vSPY_1 notation, these are forward vaults, and not reverse vaults)\\r\\n    uint public initialLTVE10   = 5 * 10 ** 9;              // Maximum initial loan to value of a vault                 [Integer / 1E10]\\r\\n    uint public maintLTVE10     = 6 * 10 ** 9;              // Maximum maintnenance loan to value of a vault            [Integer / 1E10]\\r\\n    uint public liqPenaltyE10   = 5 * 10 ** 8;              // Bonus paid to any address for liquidating non-compliant\\r\\n                                                            // contract                                                 [Integer / 1E10]\\r\\n                                                            \\r\\n                                                            \\r\\n    // Global Settlement Variables\\r\\n    bool public inGlobalSettlement = false;\\r\\n    uint public globalSettlementStartTime;\\r\\n    uint public settledWeiPervSPACEX; \\r\\n    bool public isGloballySettled = false;\\r\\n    \\r\\n    // Corporate Action Multiplier\\r\\n    \\r\\n    \\r\\n\\r\\n    \\r\\n    // Price Feed Variables\\r\\n    ExampleOracleSimple public uniswapTWAPOracle;\\r\\n    uint public weiPervSPACEXTWAP = 10 ** 18;\\r\\n    bool public isTWAPOracleAttached = false;\\r\\n    \\r\\n    uint public weiPervSPACEXSecondary = 10 ** 18;\\r\\n    uint public weiPervSPACEXMin = 10 ** 18;\\r\\n    uint public weiPervSPACEXMax = 10 ** 18;\\r\\n    \\r\\n    uint public secondaryStartTime;\\r\\n    uint public secondaryEndTime;\\r\\n    \\r\\n\\r\\n    \\r\\n\\r\\n    // In this system, individual vaults *are* addresses.  Instances of vaults then are mapped by bare address\\r\\n    // Each vault has an \\\"asset\\\" side and a \\\"debt\\\" side\\r\\n    // The following variables track all Vaults.  Not strictly needed, but helps liquidate non-compliant vaults\\r\\n    mapping(address =\\u003e bool) public isAddressRegistered;    // Forward map to emulate a \\\"set\\\" struct\\r\\n    address[] public registeredAddresses;                   // Backward map for \\\"set\\\" struct\\r\\n    \\r\\n\\r\\n    // Vaults are defined here\\r\\n    mapping(address =\\u003e uint) public weiAsset;               // Weis the Vault owns -- the asset side. NET of queued assets\\r\\n    mapping(address =\\u003e uint) public vSPACEXDebtE18;         // vSPACEX -- the debt side of the balance sheet of each Vault.  NET of queued assets\\r\\n\\r\\n    // Each Vault has a liquidation \\\"queue\\\".  It is not a strict queue.  While items are always enqueued on top (high serial number)\\r\\n    // Items only *tend* to dequeue on bottom.\\r\\n    \\r\\n    struct VaultLiquidationQ {\\r\\n        uint size;                              // Number of elements in this queue\\r\\n        uint[] weiAssetInSpot;                  // wei amount being liquidated\\r\\n        uint[] vSPACEXDebtInSpotE18;            // Amount of vSPACEX Debt being liqudiated.  Not strictly necessary but for recordkeeping.\\r\\n        uint[] liqStartTime;                    // When did liquidation start?\\r\\n        uint[] weiPervSPACEXTWAPAtChallenge;    // TWAP price at challenge time\\r\\n        bool[] isLiqChallenged;                 // Is this liquidation being challenged?\\r\\n        bool[] isHarvested;                     // Is this liquidation already harvested?\\r\\n        uint[] liqChallengeWei;                 // Amount that has been put in for liquidation challenge purposes\\r\\n        address payable[] liquidator;           // Who is liquidating?\\r\\n    }\\r\\n    \\r\\n    mapping(address =\\u003e VaultLiquidationQ) public VaultLiquidationQs;\\r\\n\\r\\n    \\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n        oracle = msg.sender;\\r\\n        vSPACEXToken = new BackedToken(\\\"vSPACEX Token V1\\\", \\\"vSPACEX\\\");\\r\\n        //Pass in already existing ivtToken address\\r\\n\\r\\n    }\\r\\n    \\r\\n\\r\\n    \\r\\n    // This function attaches the Uniswap TWAP, without updating price at first.  After 24 hours of deploy, governance must update this price in order to make this smart contract usable.\\r\\n    function govAttachTWAP() public {\\r\\n        require(msg.sender == owner, \\\"Denied: Gov Must Attach TWAP\\\");\\r\\n        require(isTWAPOracleAttached == false, \\\"TWAP Already Attached\\\");\\r\\n        isTWAPOracleAttached = true;\\r\\n        \\r\\n        uniswapTWAPOracle = new ExampleOracleSimple(UNISWAP_FACTORY_ADDR, WETH_ADDR, address(vSPACEXToken), TWAP_PERIOD);\\r\\n        \\r\\n    }\\r\\n\\r\\n    \\r\\n    // Anyone can update the TWAP price.  Gov should update this at least once before the system is considered stable.\\r\\n    function updateTWAPPrice() public { \\r\\n        uniswapTWAPOracle.update();\\r\\n        weiPervSPACEXTWAP = uniswapTWAPOracle.consult(address(vSPACEXToken), 10 ** 18); // Verified 2021-02-17 Price Not Inverted\\r\\n        weiPervSPACEXMax = (weiPervSPACEXTWAP \\u003e  weiPervSPACEXSecondary) ? weiPervSPACEXTWAP : weiPervSPACEXSecondary;\\r\\n        weiPervSPACEXMin = (weiPervSPACEXTWAP \\u003e  weiPervSPACEXSecondary) ? weiPervSPACEXSecondary : weiPervSPACEXTWAP;\\r\\n    }\\r\\n    \\r\\n    // Oracle Functions\\r\\n    function oracleUpdatesecondaryTime(uint _secondaryStartTime, uint _secondaryEndTime) public {\\r\\n        require(msg.sender == oracle, \\\"Deny Update 2ndry Time: You are not oracle\\\");\\r\\n        require( (_secondaryStartTime \\u003c= _secondaryEndTime)  \\u0026\\u0026  (_secondaryEndTime \\u003c= block.timestamp), \\\"Invalid time\\\");\\r\\n        \\r\\n        secondaryStartTime = _secondaryStartTime;\\r\\n        secondaryEndTime = _secondaryEndTime;\\r\\n    }\\r\\n    \\r\\n    function oracleUpdateweiPervSPACEXSecondary(uint _weiPervSPACEXSecondary) public {\\r\\n        require(msg.sender == oracle, \\\"Denied: You are not oracle\\\");\\r\\n        weiPervSPACEXSecondary = _weiPervSPACEXSecondary;\\r\\n        weiPervSPACEXMax = (weiPervSPACEXTWAP \\u003e  weiPervSPACEXSecondary) ? weiPervSPACEXTWAP : weiPervSPACEXSecondary;\\r\\n        weiPervSPACEXMin = (weiPervSPACEXTWAP \\u003e  weiPervSPACEXSecondary) ? weiPervSPACEXSecondary : weiPervSPACEXTWAP;\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Governance Functions\\r\\n    function govUpdateinitialLTVE10(uint _initialLTVE10) public {\\r\\n        require(msg.sender == owner, \\\"Denied: You are not gov\\\");\\r\\n        initialLTVE10 = _initialLTVE10;\\r\\n    }\\r\\n    \\r\\n    function govUpdatecAME18(uint _cAME18) public {\\r\\n        require(msg.sender == owner, \\\"Denied: You are not gov\\\");\\r\\n        cAME18 = _cAME18;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function govUpdatemaintLTVE10(uint _maintLTVE10) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        maintLTVE10 = _maintLTVE10;\\r\\n    }\\r\\n    \\r\\n    function govUpdateliqPenaltyE10(uint _liqPenaltyE10) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        liqPenaltyE10 = _liqPenaltyE10;\\r\\n    }\\r\\n    \\r\\n    function govChangeOwner(address payable _owner) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        owner = _owner;\\r\\n    }\\r\\n    \\r\\n    function govChangeOracle(address payable _oracle) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        oracle = _oracle;\\r\\n    }\\r\\n    \\r\\n    function govChangemaxvSPACEXE18(uint _maxvSPACEXE18) public {\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        maxvSPACEXE18 = _maxvSPACEXE18;\\r\\n    }\\r\\n    \\r\\n    function govStartGlobalSettlement() public { // To be tested\\r\\n        require(msg.sender == owner, \\\"Disallowed: You are not governance\\\");\\r\\n        inGlobalSettlement = true;\\r\\n        globalSettlementStartTime = block.timestamp;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    \\r\\n    // Vault Functions\\r\\n    function depositWEI() public payable { // Same as receive fallback; but explictily declared for symmetry\\r\\n        require(msg.value \\u003e 0, \\\"Must Deposit Nonzero Wei\\\"); \\r\\n        weiAsset[msg.sender] = weiAsset[msg.sender].add( msg.value );\\r\\n        \\r\\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\\r\\n            isAddressRegistered[msg.sender] = true;\\r\\n            registeredAddresses.push(msg.sender);\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    receive() external payable { // Same as depositWEI()\\r\\n        require(msg.value \\u003e 0, \\\"Must Deposit Nonzero Wei\\\"); \\r\\n        // Receiving is automatic so double entry accounting not possible here\\r\\n        weiAsset[msg.sender] = weiAsset[msg.sender].add( msg.value );\\r\\n        \\r\\n        if(isAddressRegistered[msg.sender] != true) { // if user was not registered before\\r\\n            isAddressRegistered[msg.sender] = true;\\r\\n            registeredAddresses.push(msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawWEI(uint _weiWithdraw) public {  // NB: Security model is against msg.sender\\r\\n        // Presuming contract withdrawal is from own vault\\r\\n        require( _weiWithdraw \\u003c 10 ** 28, \\\"Protective max bound for uint argument\\\");\\r\\n        \\r\\n        // Maintenence Equation: (vSPYDebtE18/1E18) * weiPervSPY \\u003c= (weiAsset) * (initialLTVE10/1E10)\\r\\n        // =\\u003e After withdrawal (vSPYDebtE18)/1E18 * weiPervSPY \\u003c= (weiAsset - _weiWithdraw) * (initialLTVE10/1E10)\\r\\n        uint LHS = vSPACEXDebtE18[msg.sender].mul( weiPervSPACEXMax ).mul( 10 ** 10 ); // presuming weiPervSPACEXMax \\u003c 10 ** 24 (million ETH spacex)\\r\\n        uint RHS = (weiAsset[msg.sender].sub( _weiWithdraw )).mul( initialLTVE10 ).mul( 10 ** 18 );\\r\\n        require ( LHS \\u003c= RHS, \\\"Initial margin not enough to withdraw\\\");\\r\\n        \\r\\n        // Double Entry Accounting\\r\\n        weiAsset[msg.sender] = weiAsset[msg.sender].sub( _weiWithdraw ); // penalize wei deposited before sending money out\\r\\n        msg.sender.transfer(_weiWithdraw);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function lendvSPACEX(uint _vSPACEXLendE18) public {\\r\\n        //presuming message sender is using his own vault\\r\\n        require(_vSPACEXLendE18 \\u003c 10 ** 30, \\\"Protective max bound for uint argument\\\");\\r\\n        require(outstandingvSPACEXE18.add( _vSPACEXLendE18 ) \\u003c= maxvSPACEXE18, \\\"Current version limits max amount of vSPACEX possible\\\");\\r\\n        \\r\\n        // Maintenence Equation: (vSPYDebtE18/1E18) * weiPervSPY \\u003c= (weiAsset) * (initialLTVE10/1E10)\\r\\n        // I need: (_vSPYLendE18 + vSPYDebtE18)/1E18 * weiPervSPY  \\u003c weiAsset * (initialLTVE10/1E10)\\r\\n        uint LHS = vSPACEXDebtE18[msg.sender].add( _vSPACEXLendE18 ).mul( weiPervSPACEXMax ).mul( 10 ** 10 );\\r\\n        uint RHS = weiAsset[msg.sender].mul( initialLTVE10 ).mul( 10 ** 18 );\\r\\n        require(LHS \\u003c RHS, \\\"Your initial margin is insufficient for lending\\\");\\r\\n        \\r\\n        // Double Entry Accounting\\r\\n        vSPACEXDebtE18[msg.sender] = vSPACEXDebtE18[msg.sender].add( _vSPACEXLendE18 ); // penalize debt first.\\r\\n        outstandingvSPACEXE18 = outstandingvSPACEXE18.add(_vSPACEXLendE18);\\r\\n        vSPACEXToken.ownerMint(msg.sender, _vSPACEXLendE18);\\r\\n    }\\r\\n    \\r\\n    function repayvSPACEX(uint _vSPACEXRepayE18) public {\\r\\n        require(_vSPACEXRepayE18 \\u003c 10 ** 30, \\\"Protective max bound for uint argument\\\");\\r\\n        \\r\\n        // vSPACEXToken.ownerApprove(msg.sender, _vSPACEXRepayE18);  //Todo: Make a separate react button for owner to approve.\\r\\n        \\r\\n        // Double Entry Accounting\\r\\n        // vSPACEXToken.transferFrom(msg.sender, address(this), _vSPACEXRepayE18); // the actual deduction from the token contract\\r\\n        vSPACEXToken.ownerBurn(msg.sender, _vSPACEXRepayE18);\\r\\n        vSPACEXDebtE18[msg.sender] = vSPACEXDebtE18[msg.sender].sub( _vSPACEXRepayE18 );\\r\\n        outstandingvSPACEXE18 = outstandingvSPACEXE18.sub(_vSPACEXRepayE18);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    \\r\\n    function findNoncompliantVaults(uint _limitNum) public view returns(address[] memory, uint[] memory, uint[] memory, uint) {   // Return the first N noncompliant vaults\\r\\n        require(_limitNum \\u003e 0, \\\"Must run this on a positive integer\\\");\\r\\n        address[] memory noncompliantAddresses = new address[](_limitNum);\\r\\n        uint[] memory LHSs_vault = new uint[](_limitNum);\\r\\n        uint[] memory RHSs_vault = new uint[](_limitNum);\\r\\n        \\r\\n        uint j = 0;  // Iterator up to _limitNum\\r\\n        for (uint i=0; i\\u003cregisteredAddresses.length; i++) { // Iterate up to all the registered addresses.  NB: Should cost zero gas because this is a view function.\\r\\n            if(j\\u003e= _limitNum) { // Exits if _limitNum noncompliant vaults are found\\r\\n                break;\\r\\n            } \\r\\n            // Vault maintainance margin violation: (vSPYDebtE18)/1E18 * weiPervSPY  \\u003e weiAsset * (maintLTVE10)/1E10 for a violation\\r\\n            uint LHS_vault = vSPACEXDebtE18[registeredAddresses[i]].mul(weiPervSPACEXMax);\\r\\n            uint RHS_vault  = weiAsset[registeredAddresses[i]].mul( maintLTVE10 ).mul( 10 ** 8);\\r\\n            \\r\\n            if( (LHS_vault \\u003e RHS_vault) ) {\\r\\n                noncompliantAddresses[j] = registeredAddresses[i];\\r\\n                LHSs_vault[j] = LHS_vault;\\r\\n                RHSs_vault[j] = RHS_vault;\\r\\n\\r\\n                j = j + 1;\\r\\n            }\\r\\n        }\\r\\n        return(noncompliantAddresses, LHSs_vault, RHSs_vault, j);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    \\r\\n    function liquidateNonCompliant(uint _vSPACEXProvidedE18, address payable target_address) public returns(uint) { // liquidates a portion of the contract for non-compliance\\r\\n    \\r\\n        // If the system is in the final stage of GS, you can\\u0027t start a liquidation.\\r\\n        require( isGloballySettled == false,\\\"Cannot liq after GS closes.\\\" );\\r\\n        \\r\\n        // While it possible to have a more complex liquidation system, since liqudations are off-equilibrium, for the MVP \\r\\n        // We have decided we want overly aggressive liqudiations \\r\\n        require( _vSPACEXProvidedE18 \\u003c= vSPACEXDebtE18[target_address], \\\"You cannot provide more vSPACEX than vSPACEXDebt outstanding\\\");\\r\\n\\r\\n\\r\\n        // Maintenence Equation: (vSPYDebtE18/1E18) * weiPervSPY \\u003c= (weiAsset) * (maintLTVE10/1E10)\\r\\n        // For a violation, the above will be flipped: (vSPYDebtE18/1E18) * weiPervSPY \\u003e (weiAsset) * (maintLTVE10/1E10)        \\r\\n        uint LHS = vSPACEXDebtE18[target_address].mul( weiPervSPACEXMax ).mul( 10 ** 10);\\r\\n        uint RHS = weiAsset[target_address].mul( maintLTVE10 ).mul( 10 ** 18);\\r\\n        require(LHS \\u003e RHS, \\\"Current contract is within maintainance margin, so you cannot run this\\\");\\r\\n        \\r\\n\\r\\n        // If this vault is underwater-with-respect-to-rewards (different than noncompliant), liquidation is pro-rata\\r\\n        // underater iff: weiAsset[target_address] \\u003c vSPYDebtE18[target_address]/1E18 * weiPervSPY * (liqPenaltyE10+1E10)/1E10\\r\\n        uint LHS2 = weiAsset[target_address].mul( 10 ** 18 ).mul( 10 ** 10);\\r\\n        uint RHS2 = vSPACEXDebtE18[target_address].mul( weiPervSPACEXMax ).mul( liqPenaltyE10.add( 10 ** 10 ));\\r\\n        \\r\\n        uint weiClaim;\\r\\n        if( LHS2 \\u003c RHS2 ) { // pro-rata claim\\r\\n            // weiClaim = ( _vSPYProvidedE18 /  vSPYDebtE18[target_address]) * weiAsset[target_address];\\r\\n            weiClaim = _vSPACEXProvidedE18.mul( weiAsset[target_address] ).div( vSPACEXDebtE18[target_address] );\\r\\n        } else {\\r\\n            // maxWeiClaim = _vSPYProvidedE18/1E18 * weiPervSPY * (1+liqPenaltyE10/1E10)\\r\\n            weiClaim = _vSPACEXProvidedE18.mul( weiPervSPACEXMax ).mul( liqPenaltyE10.add( 10 ** 10 )).div( 10 ** 18 ).div( 10 ** 10 );\\r\\n        }\\r\\n        require(weiClaim \\u003c= weiAsset[target_address], \\\"Code Error if you reached this point\\\");\\r\\n        \\r\\n        \\r\\n        // Double Entry Accounting for returning vSPY Debt back\\r\\n        // vSPACEXToken.ownerApprove(msg.sender, _vSPACEXProvidedE18);  // Todo: Require Owner to approve token first.\\r\\n        vSPACEXToken.ownerBurn(msg.sender, _vSPACEXProvidedE18); // the actual deduction from the token contract\\r\\n        vSPACEXDebtE18[target_address] = vSPACEXDebtE18[target_address].sub( _vSPACEXProvidedE18 );\\r\\n        outstandingvSPACEXE18 = outstandingvSPACEXE18.sub( _vSPACEXProvidedE18 );\\r\\n        \\r\\n        \\r\\n        // Double Entry Accounting for deducting the vault\\u0027s assets\\r\\n        weiAsset[target_address] = weiAsset[target_address].sub( weiClaim );\\r\\n        \\r\\n        \\r\\n        if(weiPervSPACEXSecondary == weiPervSPACEXMax) {    // If the secondary price is the basis of liquidation, no wait is needed\\r\\n            msg.sender.transfer( weiClaim );\\r\\n            return 10 ** 30; // Sentinel for \\r\\n        } else {  // Otherwise, we need to wait LIQ_WAIT_TIME for liquidation\\r\\n        \\r\\n       \\r\\n        uint i = VaultLiquidationQs[target_address].size; // Index i must always be less than size.  Solidity is zero indexed\\r\\n        VaultLiquidationQs[target_address].size = VaultLiquidationQs[target_address].size.add( 1 );\\r\\n        \\r\\n        VaultLiquidationQs[target_address].weiAssetInSpot.push(weiClaim);                                // wei amount being liquidated\\r\\n        VaultLiquidationQs[target_address].vSPACEXDebtInSpotE18.push(_vSPACEXProvidedE18);               // amount of vSPACEX Debt being liqudiated\\r\\n        VaultLiquidationQs[target_address].liqStartTime.push(block.timestamp);                           // when did liquidation start?\\r\\n        VaultLiquidationQs[target_address].weiPervSPACEXTWAPAtChallenge.push(weiPervSPACEXTWAP);         // TWAP price at challenge time\\r\\n        VaultLiquidationQs[target_address].isLiqChallenged.push(false);                                  // Is this liquidation being challenged?\\r\\n        VaultLiquidationQs[target_address].liqChallengeWei.push(0);                                      // Amount that has been put in for liquidation challenge purposes\\r\\n        VaultLiquidationQs[target_address].liquidator.push(msg.sender); \\r\\n        VaultLiquidationQs[target_address].isHarvested.push(false); \\r\\n        return i;   // Liquidator expictly gets back their claim ticket number\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function settleUnchallengedLiquidation(address _targetVault, uint _position) public { // Liquidator can call\\r\\n        // If in Global Settlement Final: Still allow, because otherwise wei locked in Q cannot be retrieved\\r\\n        // critical requirements\\r\\n        require(_position \\u003c  VaultLiquidationQs[_targetVault].size, \\\"Err: PosInv\\\"); // position needs to be valid\\r\\n        require(msg.sender == VaultLiquidationQs[_targetVault].liquidator[_position] , \\\"Err: LiqCal\\\"); // only liqudiator can call\\r\\n        require(VaultLiquidationQs[_targetVault].liqStartTime[_position] + LIQ_WAIT_TIME \\u003c block.timestamp, \\\"Err: WaitL\\\"); // must be LIQ_WAIT_TIME (28 hour in v1) later.\\r\\n        require(VaultLiquidationQs[_targetVault].isLiqChallenged[_position] == false, \\\"Err: AlrCha\\\"); // Must not be challenged\\r\\n        require(VaultLiquidationQs[_targetVault].isHarvested[_position] == false, \\\"Err: AlrHar\\\"); // Must not be harvseted yet\\r\\n        \\r\\n        // other assumptions\\r\\n        require( VaultLiquidationQs[_targetVault].weiAssetInSpot[_position] \\u003e 0, \\\"SErr: Wei\\\");\\r\\n        require( VaultLiquidationQs[_targetVault].vSPACEXDebtInSpotE18[_position] \\u003e 0, \\\"SErr: vSP\\\");\\r\\n        require( VaultLiquidationQs[_targetVault].liqChallengeWei[_position] == 0, \\\"SErr: lCW\\\"); \\r\\n        \\r\\n        // end the challenge\\r\\n        \\r\\n        // set the future claimable values to zero\\r\\n        VaultLiquidationQs[_targetVault].isHarvested[_position] = true; // blocks a second transfer from happening\\r\\n        uint weiClaim = VaultLiquidationQs[_targetVault].weiAssetInSpot[_position];\\r\\n        VaultLiquidationQs[_targetVault].weiAssetInSpot[_position] = 0;\\r\\n        \\r\\n        // make the transfer\\r\\n        VaultLiquidationQs[_targetVault].liquidator[_position].transfer( weiClaim );\\r\\n    }\\r\\n    \\r\\n    \\r\\n        \\r\\n    \\r\\n    function challengeLiquidation(uint _position) public payable  {                     // usually owner of vault calls, but anyone can benefit the owner\\r\\n    \\r\\n        require( isGloballySettled == false,\\\"Cannot challenge after GS Closes.\\\" );      // Vault owner will have had at least GLOBAL_SETTLEMENT_PERIOD or 28 hours to challenge.  \\r\\n        // No need to allow this edge case of more challenges after global settlement closes.\\r\\n    \\r\\n        require(_position \\u003c  VaultLiquidationQs[msg.sender].size, \\\"Err: PosInv\\\");                      // position needs to be valid\\r\\n        require(VaultLiquidationQs[msg.sender].isHarvested[_position] == false, \\\"Err: AlrHar\\\");        // Must not be harvested yet\\r\\n        require(VaultLiquidationQs[msg.sender].isLiqChallenged[_position] == false, \\\"Err: AlrCha\\\");    // Must not be challenged\\r\\n\\r\\n        \\r\\n        require(msg.value \\u003e= ( VaultLiquidationQs[msg.sender].weiPervSPACEXTWAPAtChallenge[_position].mul( VaultLiquidationQs[msg.sender].vSPACEXDebtInSpotE18[_position] ).div(10 ** 18)), \\\"Err: ChaAmt\\\" ); \\r\\n        // Require owner to challenge the liqudiation with an amount of wei equal to the vSPACEX the liquidator provided, at the Uniswap price then.\\r\\n        \\r\\n        // other assumptions\\r\\n        require( VaultLiquidationQs[msg.sender].weiAssetInSpot[_position] \\u003e 0 , \\\"SErr: Wei\\\");\\r\\n        require( VaultLiquidationQs[msg.sender].vSPACEXDebtInSpotE18[_position] \\u003e 0, \\\"SErr: vSP\\\" );\\r\\n        require( VaultLiquidationQs[msg.sender].liqChallengeWei[_position] == 0, \\\"SErr: lCW\\\");\\r\\n        // INTENTIONALLY don\\u0027t block challenges even after LIQ_WAIT_TIME, as long as vault hasn\\u0027t yet been harvested\\r\\n        // No restriction on liqudiator\\r\\n        \\r\\n        // at this point, record the challenged\\r\\n        VaultLiquidationQs[msg.sender].isLiqChallenged[_position] = true;\\r\\n        VaultLiquidationQs[msg.sender].liqChallengeWei[_position] = msg.value;\\r\\n    } \\r\\n    \\r\\n    \\r\\n    \\r\\n    function endChallengeLiquidation(address _targetVault, uint _position) public {                 // Anyone can run, but only owner and liqudiator have direct incentive.\\r\\n        // NB: who the challege in ends in favor of depends on when it is run.  Thus it is in favor of the winning claimaint to run soon.\\r\\n        require(_position \\u003c  VaultLiquidationQs[_targetVault].size, \\\"Err: PosInv\\\");                                // position needs to be valid\\r\\n        require( VaultLiquidationQs[_targetVault].isLiqChallenged[_position] == true, \\\"Err: NotCha\\\");             // Must be challenged\\r\\n        require( VaultLiquidationQs[_targetVault].isHarvested[_position] == false, \\\"Err: AlrHar\\\");                  // Must not be harvested yet\\r\\n        \\r\\n        if(isGloballySettled == false) { // Only in case of world where Global Settlement is closed, can the secondaryPrice can be old\\r\\n            require( secondaryStartTime \\u003e VaultLiquidationQs[_targetVault].liqStartTime[_position], \\\"Err: OldSO\\\" );     // requires the secondary oracle to have been updated after the challenge started.\\r\\n        }\\r\\n        \\r\\n        // optional checks\\r\\n        require( VaultLiquidationQs[_targetVault].weiAssetInSpot[_position] \\u003e 0 , \\\"SErr: Wei\\\");\\r\\n        require( VaultLiquidationQs[_targetVault].vSPACEXDebtInSpotE18[_position] \\u003e 0, \\\"SErr: vSP\\\"); \\r\\n        require( VaultLiquidationQs[_targetVault].liqStartTime[_position]  + LIQ_WAIT_TIME \\u003c block.timestamp , \\\"SErr: lCW\\\"); // 28 hours must have elapsed as sanity check\\r\\n        // TWAP price checked later\\r\\n        // Function runner could be anyone\\r\\n        \\r\\n        // Payoff is both the base liquidate amount and the challenge amount:\\r\\n        uint weiClaim = VaultLiquidationQs[_targetVault].weiAssetInSpot[_position] + VaultLiquidationQs[_targetVault].liqChallengeWei[_position];\\r\\n        VaultLiquidationQs[_targetVault].weiAssetInSpot[_position] = 0;\\r\\n        VaultLiquidationQs[_targetVault].liqChallengeWei[_position] = 0;\\r\\n        \\r\\n        \\r\\n        \\r\\n        // settle vaults\\r\\n        VaultLiquidationQs[_targetVault].isLiqChallenged[_position] = false;\\r\\n        VaultLiquidationQs[_targetVault].isHarvested[_position] = true;\\r\\n        \\r\\n        \\r\\n        // transfer out\\r\\n        if( weiPervSPACEXSecondary * 3 \\u003c VaultLiquidationQs[_targetVault].weiPervSPACEXTWAPAtChallenge[_position] ) { // if the secondary price is much less than old TWAP (thus short squeeze)\\r\\n            // End in favor of the challenger (vault owner).  Credit the target Vault.\\r\\n            weiAsset[_targetVault] = weiClaim.add( weiAsset[_targetVault] );\\r\\n        } else { // this was not a short squeeze\\r\\n            // End in favor of the liquidator\\r\\n            VaultLiquidationQs[_targetVault].liquidator[_position].transfer( weiClaim );\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // The following functions are off off-equilibrium.  Thus they are vetted to be safe, but not necessarily efficient/optimal.\\r\\n\\r\\n\\r\\n    // Global Settlement Functions. Global settlement must start with governance. However, afterwards, closing of Global Settlement can be done by anyone\\r\\n    function registerGloballySettled() public { // Anyone can run this closing function\\r\\n        require(inGlobalSettlement, \\\"Gov must start settlement\\\");\\r\\n        require(block.timestamp \\u003e (globalSettlementStartTime + GLOBAL_SETTLEMENT_PERIOD), \\\"Wait TIME to finalize.\\\");\\r\\n        require(!isGloballySettled, \\\"Settlement Already Closed\\\");\\r\\n        settledWeiPervSPACEX = weiPervSPACEXSecondary;  // For fidelity, only actual SPACEX transaction prices (not vSPACEX coin) used for settlement.\\r\\n        isGloballySettled = true;\\r\\n    }\\r\\n    \\r\\n    function settledConvertvSPACEXtoWei(uint _vSPACEXTokenToConvertE18) public { // After Global Settlement (GS) someone who has vSPACEX can run to redeem.\\r\\n        require(isGloballySettled);\\r\\n        require(_vSPACEXTokenToConvertE18 \\u003c 10 ** 30, \\\"Protective max bound for input hit\\\");\\r\\n        \\r\\n        uint weiToReturn = _vSPACEXTokenToConvertE18.mul( settledWeiPervSPACEX ).div( 10 ** 18); // Rounds down\\r\\n        \\r\\n        // vSPACEX accounting is no longer double entry.  Destroy vSPACEX to get wei\\r\\n        //vSPACEXToken.ownerApprove(msg.sender, _vSPACEXTokenToConvertE18);                       // Factory gives itself approval. Todo: Require owner give this contract control\\r\\n        vSPACEXToken.ownerBurn(msg.sender, _vSPACEXTokenToConvertE18);                          // the actual deduction from the token contract\\r\\n        msg.sender.transfer(weiToReturn);                                                       // return wei\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function settledConvertVaulttoWei() public {        // After GS, someone who has a vault can withdraw the remaining value in the vault.\\r\\n        require(isGloballySettled);\\r\\n        \\r\\n        uint weiDebt = vSPACEXDebtE18[msg.sender].mul( settledWeiPervSPACEX ).div( 10 ** 18).add( 1 );       // Convert vSPACEX Debt to Wei. Round up.\\r\\n        require(weiAsset[msg.sender] \\u003e weiDebt, \\\"This CTV is not above water, cannot convert\\\");     \\r\\n        \\r\\n        uint weiEquity = weiAsset[msg.sender] - weiDebt;\\r\\n        \\r\\n        \\r\\n        // Zero out CTV and transfer equity remaining\\r\\n        vSPACEXDebtE18[msg.sender] = 0;\\r\\n        weiAsset[msg.sender] = 0;\\r\\n        msg.sender.transfer(weiEquity);  \\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n\\r\\n    function detachOwner() public { // an emergency function to commitally shut off the owner account while retaining residual functionality of tokens\\r\\n        require(msg.sender == owner);\\r\\n        initialLTVE10 = 4 * 10 ** 9; // 40% LTV at start\\r\\n        maintLTVE10 = 5 * 10 ** 9; // 50% LTV to maintain\\r\\n        liqPenaltyE10 = 15 * 10 ** 8; // 15% liquidation penalty\\r\\n        oracle = address(0);\\r\\n        owner = address(0);\\r\\n    }\\r\\n\\r\\n    \\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogUint\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GLOBAL_SETTLEMENT_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQ_WAIT_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TWAP_PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_FACTORY_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"VaultLiquidationQs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH_ADDR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cAME18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"challengeLiquidation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositWEI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"detachOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"endChallengeLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limitNum\",\"type\":\"uint256\"}],\"name\":\"findNoncompliantVaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalSettlementStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"govAttachTWAP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_oracle\",\"type\":\"address\"}],\"name\":\"govChangeOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"govChangeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxvSPACEXE18\",\"type\":\"uint256\"}],\"name\":\"govChangemaxvSPACEXE18\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"govStartGlobalSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cAME18\",\"type\":\"uint256\"}],\"name\":\"govUpdatecAME18\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialLTVE10\",\"type\":\"uint256\"}],\"name\":\"govUpdateinitialLTVE10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liqPenaltyE10\",\"type\":\"uint256\"}],\"name\":\"govUpdateliqPenaltyE10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maintLTVE10\",\"type\":\"uint256\"}],\"name\":\"govUpdatemaintLTVE10\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inGlobalSettlement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialLTVE10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAddressRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGloballySettled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTWAPOracleAttached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ivtToken\",\"outputs\":[{\"internalType\":\"contract GeneralToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSPACEXLendE18\",\"type\":\"uint256\"}],\"name\":\"lendvSPACEX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liqPenaltyE10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSPACEXProvidedE18\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"target_address\",\"type\":\"address\"}],\"name\":\"liquidateNonCompliant\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maintLTVE10\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxvSPACEXE18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_secondaryStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_secondaryEndTime\",\"type\":\"uint256\"}],\"name\":\"oracleUpdatesecondaryTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weiPervSPACEXSecondary\",\"type\":\"uint256\"}],\"name\":\"oracleUpdateweiPervSPACEXSecondary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outstandingvSPACEXE18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerGloballySettled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSPACEXRepayE18\",\"type\":\"uint256\"}],\"name\":\"repayvSPACEX\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondaryStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"settleUnchallengedLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settledConvertVaulttoWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vSPACEXTokenToConvertE18\",\"type\":\"uint256\"}],\"name\":\"settledConvertvSPACEXtoWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settledWeiPervSPACEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapTWAPOracle\",\"outputs\":[{\"internalType\":\"contract ExampleOracleSimple\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateTWAPPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vSPACEXDebtE18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vSPACEXToken\",\"outputs\":[{\"internalType\":\"contract BackedToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weiAsset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weiPervSPACEXMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weiPervSPACEXMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weiPervSPACEXSecondary\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weiPervSPACEXTWAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weiWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdrawWEI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "VaultSystemSpaceX", "CompilerVersion": "v0.7.2+commit.51b20bc0", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4b90338f83fcf36a387fe8b20581a5a06f9bed47123e67a20643af9510dac9e0"}