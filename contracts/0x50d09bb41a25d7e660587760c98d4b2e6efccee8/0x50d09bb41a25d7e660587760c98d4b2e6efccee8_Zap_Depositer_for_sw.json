{"SourceCode": "# @version 0.3.1\r\n\"\"\"\r\n@title Zap Depositer for swETH/ETHx Metapool\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface CurveMeta:\r\n    def add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) -> uint256: nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]) -> uint256[N_COINS]: nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256) -> uint256: nonpayable\r\n    def remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256) -> uint256: nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256: view\r\n    def base_pool() -> address: view\r\n    def coins(i: uint256) -> address: view\r\n\r\ninterface CurveBase:\r\n    def add_liquidity(amounts: uint256[BASE_N_COINS], min_mint_amount: uint256): nonpayable\r\n    def remove_liquidity(_amount: uint256, min_amounts: uint256[BASE_N_COINS]): nonpayable\r\n    def remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n    def remove_liquidity_imbalance(amounts: uint256[BASE_N_COINS], max_burn_amount: uint256): nonpayable\r\n    def calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[BASE_N_COINS], deposit: bool) -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n    def fee() -> uint256: view\r\n\r\n\r\nN_COINS: constant(int128) = 2\r\nMAX_COIN: constant(int128) = N_COINS - 1\r\nBASE_N_COINS: constant(int128) = 4\r\nN_ALL_COINS: constant(int128) = N_COINS + BASE_N_COINS - 1\r\n\r\nFEE_DENOMINATOR: constant(uint256) = 10 ** 10\r\nFEE_IMPRECISION: constant(uint256) = 100 * 10 ** 8  # % of the fee\r\n\r\npool: public(address)\r\ntoken: public(address)\r\nbase_pool: public(address)\r\n\r\ncoins: public(address[N_COINS])\r\nbase_coins: public(address[BASE_N_COINS])\r\n\r\n\r\n@external\r\ndef __init__(_pool: address, _token: address):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _pool Metapool address\r\n    @param _token Pool LP token address\r\n    \"\"\"\r\n    self.pool = _pool\r\n    self.token = _token\r\n    _base_pool: address = CurveMeta(_pool).base_pool()\r\n    self.base_pool = _base_pool\r\n\r\n    for i in range(N_COINS):\r\n        coin: address = CurveMeta(_pool).coins(i)\r\n        self.coins[i] = coin\r\n        # approve coins for infinite transfers\r\n        _response: Bytes[32] = raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(_pool, bytes32),\r\n                convert(MAX_UINT256, bytes32),\r\n            ),\r\n            max_outsize=32,\r\n        )\r\n        if len(_response) > 0:\r\n            assert convert(_response, bool)\r\n\r\n    for i in range(BASE_N_COINS):\r\n        coin: address = CurveBase(_base_pool).coins(i)\r\n        self.base_coins[i] = coin\r\n        # approve underlying coins for infinite transfers\r\n        if coin != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            assert ERC20(coin).approve(_base_pool, MAX_UINT256)\r\n\r\n\r\n@payable\r\n@external\r\ndef add_liquidity(amounts: uint256[N_ALL_COINS], min_mint_amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Wrap underlying coins and deposit them in the pool\r\n    @param amounts List of amounts of underlying coins to deposit\r\n    @param min_mint_amount Minimum amount of LP tokens to mint from the deposit\r\n    @return Amount of LP tokens received by depositing\r\n    \"\"\"\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    deposit_base: bool = False\r\n\r\n    # Transfer all coins in\r\n    for i in range(N_ALL_COINS):\r\n        amount: uint256 = amounts[i]\r\n        if amount == 0:\r\n            continue\r\n        coin: address = ZERO_ADDRESS\r\n        if i < MAX_COIN:\r\n            coin = self.coins[i]\r\n            meta_amounts[i] = amount\r\n        else:\r\n            x: int128 = i - MAX_COIN\r\n            coin = self.base_coins[x]\r\n            base_amounts[x] = amount\r\n            deposit_base = True\r\n\r\n        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            assert msg.value == amount\r\n        elif amounts[i] > 0:\r\n            assert ERC20(coin).transferFrom(msg.sender, self, amount)\r\n\r\n    # Deposit to the base pool\r\n    if deposit_base:\r\n        _response: Bytes[32] = raw_call(\r\n            self.base_pool,\r\n            _abi_encode(\r\n                base_amounts,\r\n                convert(0, bytes32),\r\n                method_id=method_id(\"add_liquidity(uint256[4],uint256)\"),\r\n            ),\r\n            value=msg.value,\r\n            max_outsize=32,\r\n        )\r\n        if len(_response) > 0:\r\n            assert convert(_response, bool)\r\n        meta_amounts[MAX_COIN] = ERC20(self.coins[MAX_COIN]).balanceOf(self)\r\n\r\n    # Deposit to the meta pool\r\n    CurveMeta(self.pool).add_liquidity(meta_amounts, min_mint_amount)\r\n\r\n    # Transfer meta token back\r\n    _lp_token: address = self.token\r\n    _lp_amount: uint256 = ERC20(_lp_token).balanceOf(self)\r\n    assert ERC20(_lp_token).transfer(msg.sender, _lp_amount)\r\n\r\n    return _lp_amount\r\n\r\n\r\n@external\r\ndef remove_liquidity(_amount: uint256, min_amounts: uint256[N_ALL_COINS]) -> uint256[N_ALL_COINS]:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap coins from the pool\r\n    @dev Withdrawal amounts are based on current deposit ratios\r\n    @param _amount Quantity of LP tokens to burn in the withdrawal\r\n    @param min_amounts Minimum amounts of underlying coins to receive\r\n    @return List of amounts of underlying coins that were withdrawn\r\n    \"\"\"\r\n    _token: address = self.token\r\n    assert ERC20(_token).transferFrom(msg.sender, self, _amount)\r\n\r\n    min_amounts_meta: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    min_amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts: uint256[N_ALL_COINS] = empty(uint256[N_ALL_COINS])\r\n\r\n    # Withdraw from meta\r\n    for i in range(MAX_COIN):\r\n        min_amounts_meta[i] = min_amounts[i]\r\n    CurveMeta(self.pool).remove_liquidity(_amount, min_amounts_meta)\r\n\r\n    # Withdraw from base\r\n    _base_amount: uint256 = ERC20(self.coins[MAX_COIN]).balanceOf(self)\r\n    for i in range(BASE_N_COINS):\r\n        min_amounts_base[i] = min_amounts[MAX_COIN+i]\r\n    CurveBase(self.base_pool).remove_liquidity(_base_amount, min_amounts_base)\r\n\r\n    # Transfer all coins out\r\n    for i in range(N_ALL_COINS):\r\n        coin: address = ZERO_ADDRESS\r\n        if i < MAX_COIN:\r\n            coin = self.coins[i]\r\n        else:\r\n            coin = self.base_coins[i - MAX_COIN]\r\n\r\n        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            amounts[i] = self.balance\r\n            raw_call(msg.sender, b\"\", value=amounts[i])\r\n        else:\r\n            amounts[i] = ERC20(coin).balanceOf(self)\r\n            assert ERC20(coin).transfer(msg.sender, amounts[i])\r\n\r\n    return amounts\r\n\r\n\r\n@external\r\ndef remove_liquidity_one_coin(_token_amount: uint256, i: int128, _min_amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw and unwrap a single coin from the pool\r\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the coin to withdraw\r\n    @param _min_amount Minimum amount of underlying coin to receive\r\n    @return Amount of underlying coin received\r\n    \"\"\"\r\n    assert ERC20(self.token).transferFrom(msg.sender, self, _token_amount)\r\n\r\n    coin: address = ZERO_ADDRESS\r\n    if i < MAX_COIN:\r\n        coin = self.coins[i]\r\n        # Withdraw a metapool coin\r\n        CurveMeta(self.pool).remove_liquidity_one_coin(_token_amount, i, _min_amount)\r\n    else:\r\n        coin = self.base_coins[i - MAX_COIN]\r\n        # Withdraw a base pool coin\r\n        CurveMeta(self.pool).remove_liquidity_one_coin(_token_amount, MAX_COIN, 0)\r\n        CurveBase(self.base_pool).remove_liquidity_one_coin(\r\n            ERC20(self.coins[MAX_COIN]).balanceOf(self), i-MAX_COIN, _min_amount\r\n        )\r\n\r\n    # Tranfer the coin out\r\n    coin_amount: uint256 = 0\r\n    if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        coin_amount = self.balance\r\n        raw_call(msg.sender, b\"\", value=coin_amount)\r\n    else:\r\n        coin_amount = ERC20(coin).balanceOf(self)\r\n        assert ERC20(coin).transfer(msg.sender, coin_amount)\r\n\r\n    return coin_amount\r\n\r\n\r\n@external\r\ndef remove_liquidity_imbalance(amounts: uint256[N_ALL_COINS], max_burn_amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw coins from the pool in an imbalanced amount\r\n    @param amounts List of amounts of underlying coins to withdraw\r\n    @param max_burn_amount Maximum amount of LP token to burn in the withdrawal.\r\n                           This value cannot exceed the caller's LP token balance.\r\n    @return Actual amount of the LP token burned in the withdrawal\r\n    \"\"\"\r\n    _base_pool: address = self.base_pool\r\n    _meta_pool: address = self.pool\r\n    _base_coins: address[BASE_N_COINS] = self.base_coins\r\n    _meta_coins: address[N_COINS] = self.coins\r\n    _lp_token: address = self.token\r\n\r\n    fee: uint256 = CurveBase(_base_pool).fee() * BASE_N_COINS / (4 * (BASE_N_COINS - 1))\r\n    fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR  # Overcharge to account for imprecision\r\n\r\n    # Transfer the LP token in\r\n    assert ERC20(_lp_token).transferFrom(msg.sender, self, max_burn_amount)\r\n\r\n    withdraw_base: bool = False\r\n    amounts_base: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n    amounts_meta: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    leftover_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n\r\n    # Prepare quantities\r\n    for i in range(MAX_COIN):\r\n        amounts_meta[i] = amounts[i]\r\n\r\n    for i in range(BASE_N_COINS):\r\n        amount: uint256 = amounts[MAX_COIN + i]\r\n        if amount != 0:\r\n            amounts_base[i] = amount\r\n            withdraw_base = True\r\n\r\n    if withdraw_base:\r\n        amounts_meta[MAX_COIN] = CurveBase(self.base_pool).calc_token_amount(amounts_base, False)\r\n        amounts_meta[MAX_COIN] += amounts_meta[MAX_COIN] * fee / FEE_DENOMINATOR + 1\r\n\r\n    # Remove liquidity and deposit leftovers back\r\n    CurveMeta(_meta_pool).remove_liquidity_imbalance(amounts_meta, max_burn_amount)\r\n    if withdraw_base:\r\n        CurveBase(_base_pool).remove_liquidity_imbalance(amounts_base, amounts_meta[MAX_COIN])\r\n        leftover_amounts[MAX_COIN] = ERC20(_meta_coins[MAX_COIN]).balanceOf(self)\r\n        if leftover_amounts[MAX_COIN] > 0:\r\n            CurveMeta(_meta_pool).add_liquidity(leftover_amounts, 0)\r\n\r\n    # Transfer all coins out\r\n    for i in range(N_ALL_COINS):\r\n        coin: address = ZERO_ADDRESS\r\n        amount: uint256 = 0\r\n        if i < MAX_COIN:\r\n            coin = _meta_coins[i]\r\n            amount = amounts_meta[i]\r\n        else:\r\n            coin = _base_coins[i - MAX_COIN]\r\n            amount = amounts_base[i - MAX_COIN]\r\n        if amount > 0:\r\n            if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n                raw_call(msg.sender, b\"\", value=amount)\r\n            else:\r\n                assert ERC20(coin).transfer(msg.sender, amount)\r\n\r\n    # Transfer the leftover LP token out\r\n    leftover: uint256 = ERC20(_lp_token).balanceOf(self)\r\n    if leftover > 0:\r\n        assert ERC20(_lp_token).transfer(msg.sender, leftover)\r\n\r\n    return max_burn_amount - leftover\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(_token_amount: uint256, i: int128) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the amount received when withdrawing and unwrapping a single coin\r\n    @param _token_amount Amount of LP tokens to burn in the withdrawal\r\n    @param i Index value of the underlying coin to withdraw\r\n    @return Amount of coin received\r\n    \"\"\"\r\n    if i < MAX_COIN:\r\n        return CurveMeta(self.pool).calc_withdraw_one_coin(_token_amount, i)\r\n    else:\r\n        _base_tokens: uint256 = CurveMeta(self.pool).calc_withdraw_one_coin(_token_amount, MAX_COIN)\r\n        return CurveBase(self.base_pool).calc_withdraw_one_coin(_base_tokens, i-MAX_COIN)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(amounts: uint256[N_ALL_COINS], is_deposit: bool) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate addition or reduction in token supply from a deposit or withdrawal\r\n    @dev This calculation accounts for slippage, but not fees.\r\n         Needed to prevent front-running, not for precise calculations!\r\n    @param amounts Amount of each underlying coin being deposited\r\n    @param is_deposit set True for deposits, False for withdrawals\r\n    @return Expected amount of LP tokens received\r\n    \"\"\"\r\n    meta_amounts: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    base_amounts: uint256[BASE_N_COINS] = empty(uint256[BASE_N_COINS])\r\n\r\n    for i in range(MAX_COIN):\r\n        meta_amounts[i] = amounts[i]\r\n\r\n    for i in range(BASE_N_COINS):\r\n        base_amounts[i] = amounts[i + MAX_COIN]\r\n\r\n    _base_tokens: uint256 = CurveBase(self.base_pool).calc_token_amount(base_amounts, is_deposit)\r\n    meta_amounts[MAX_COIN] = _base_tokens\r\n\r\n    return CurveMeta(self.pool).calc_token_amount(meta_amounts, is_deposit)\r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    pass", "ABI": "[{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[5]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":83999},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[5]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[5]\"}],\"gas\":219409},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":62400},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_imbalance\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[5]\"},{\"name\":\"max_burn_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":234486},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"_token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"int128\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":9981},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[5]\"},{\"name\":\"is_deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":11419},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2730},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2760},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"base_pool\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2790},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2865},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"base_coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2895}]", "ContractName": "Zap Depositer for swETH/ETHx Metapool", "CompilerVersion": "vyper:0.3.1", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "000000000000000000000000d10fce89a130cf71fd2e0cbfb792d0a4f5272f9a000000000000000000000000eeda0fd97340796c2295296d6fe9826f32e8fddd", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}