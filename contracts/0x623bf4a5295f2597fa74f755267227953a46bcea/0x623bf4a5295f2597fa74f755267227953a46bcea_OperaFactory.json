{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"OperaFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n\\n//SPDX-License-Identifier: MIT\\nimport \\\"OperaToken.sol\\\";\\nimport \\\"OperaRevenue.sol\\\";\\nimport \\\"WETH.sol\\\";\\nimport \\\"OperaLendingPool.sol\\\";\\nimport \\\"OperaLocker.sol\\\";\\nimport \\\"OperaDAO.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"Math.sol\\\";\\n\\ncontract OperaFactory {\\n    uint256 public feePerEth = 1 * 10 ** 17;\\n    uint256 public _tokenDecimals = 1 * 10 ** 18;\\n    uint256 public tokenDeployedCount;\\n    uint256 public lockTime;\\n    address public owner;\\n    address public WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    // address public WETHAddress = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public operaRewardAddress;\\n    address public operaPoolAddress;\\n    address public operaLockerAddress;\\n    address public operaDAOAddress;\\n\\n    mapping(uint256 => address) public tokenCountToAddress;\\n    mapping(uint256 => uint256) public initialLiquidityFromTokenCount;\\n\\n    IDEXRouter public router;\\n\\n    event feeChanged(uint256 amount);\\n    event tokenDeployed(\\n        address user,\\n        address token,\\n        uint256 amountEth,\\n        uint256 tokenCount,\\n        uint256 blocktime,\\n        string[] stringData,\\n        uint256[] uintData,\\n        address[] addressData\\n    );\\n\\n    constructor(address[] memory _addressData) {\\n        owner = msg.sender;\\n        operaRewardAddress = _addressData[0];\\n        operaPoolAddress = _addressData[1];\\n        operaLockerAddress = _addressData[2];\\n        operaDAOAddress = _addressData[3];\\n        // router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"only owner\\\");\\n        _;\\n    }\\n    modifier onlyDAO() {\\n        require(\\n            operaDAOAddress == msg.sender || msg.sender == owner,\\n            \\\"only dao\\\"\\n        );\\n        _;\\n    }\\n\\n    function changeAddresses(address[] memory _addressData) external onlyOwner {\\n        operaRewardAddress = _addressData[0];\\n        operaPoolAddress = _addressData[1];\\n        operaLockerAddress = _addressData[2];\\n        operaDAOAddress = _addressData[3];\\n    }\\n\\n    function updateFeePerEth(uint256 amount) external onlyOwner {\\n        feePerEth = amount;\\n        emit feeChanged(amount);\\n    }\\n\\n    function updateLockTime(uint256 amount) external onlyOwner {\\n        require(amount <= 259200, \\\"Locktime cannot be more than 3 days.\\\");\\n        lockTime = amount;\\n    }\\n\\n    function emitDeployedEvent(\\n        address token,\\n        uint256 amount,\\n        string[] memory _stringData,\\n        address[] memory _addressData,\\n        uint256[] memory _intData\\n    ) internal {\\n        emit tokenDeployed(\\n            msg.sender,\\n            token,\\n            amount,\\n            tokenDeployedCount,\\n            block.timestamp,\\n            _stringData,\\n            _intData,\\n            _addressData\\n        );\\n    }\\n\\n    function deployToken(\\n        string[] memory _stringData,\\n        address[] memory _addressData,\\n        uint256[] memory _intData,\\n        uint256 _amountEthToBorrow\\n    ) external payable returns (address) {\\n        require(_amountEthToBorrow > 0, \\\"Cannot deploy with 0 liquidity\\\");\\n        uint256 feeEmountEth = _amountEthToBorrow * feePerEth;\\n        require(feeEmountEth == msg.value, \\\"Send enough to cover the fee\\\");\\n        OperaToken deployedToken = new OperaToken(\\n            _stringData,\\n            _addressData,\\n            _intData,\\n            operaRewardAddress\\n        );\\n\\n        uint256 tokenAmount = deployedToken.balanceOf(address(this));\\n        deployedToken.approve(address(router), tokenAmount);\\n        OperaPool lender = OperaPool(payable(operaPoolAddress));\\n        lender.borrowEth(_amountEthToBorrow);\\n        router.addLiquidityETH{value: _amountEthToBorrow * _tokenDecimals}(\\n            address(deployedToken),\\n            tokenAmount,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp + 1\\n        );\\n        tokenCountToAddress[tokenDeployedCount] = address(deployedToken);\\n        initialLiquidityFromTokenCount[tokenDeployedCount] = _amountEthToBorrow;\\n\\n        OperaRevenue rewardContract = OperaRevenue(payable(operaRewardAddress));\\n        lockLPTokens(deployedToken.pair());\\n        rewardContract.recieveRewards{value: msg.value}();\\n        OperaDAO daoContract = OperaDAO(payable(operaDAOAddress));\\n        daoContract.startTimer(\\n            uint64(tokenDeployedCount),\\n            uint64(block.timestamp + lockTime)\\n        );\\n        emitDeployedEvent(\\n            address(deployedToken),\\n            _amountEthToBorrow,\\n            _stringData,\\n            _addressData,\\n            _intData\\n        );\\n        tokenDeployedCount += 1;\\n        deployedToken.transferOwnership(payable(msg.sender));\\n        return address(deployedToken);\\n    }\\n\\n    function lockLPTokens(address tokenPair) internal {\\n        OperaLocker locker = OperaLocker(payable(operaLockerAddress));\\n        IERC20 lpToken = IERC20(tokenPair);\\n        uint256 curBalance = lpToken.balanceOf(address(this));\\n        lpToken.approve(operaLockerAddress, curBalance);\\n        locker.lockTokens(tokenPair, curBalance, lockTime);\\n    }\\n\\n    function increaseLockTime(uint256 id, uint256 timer) external onlyDAO {\\n        address tokenAddress = tokenCountToAddress[id];\\n        OperaToken deployedToken = OperaToken(payable(tokenAddress));\\n        OperaLocker locker = OperaLocker(payable(operaLockerAddress));\\n        locker.increaseLockTime(deployedToken.pair(), timer);\\n    }\\n\\n    function claimLiquidityFromLockerWithId(\\n        uint256 tokenId\\n    ) external payable onlyDAO {\\n        address tokenAddress = tokenCountToAddress[tokenId];\\n        OperaToken deployedToken = OperaToken(payable(tokenAddress));\\n        OperaLocker locker = OperaLocker(payable(operaLockerAddress));\\n        uint256 tokenAmount = locker.getAddressLockedTokens(\\n            address(this),\\n            deployedToken.pair()\\n        );\\n        locker.withdrawTokenAmount(deployedToken.pair(), tokenAmount);\\n    }\\n\\n    function claimLiquidityFromLockerWithAddress(\\n        address addy\\n    ) external payable onlyDAO {\\n        OperaToken deployedToken = OperaToken(payable(addy));\\n        OperaLocker locker = OperaLocker(payable(operaLockerAddress));\\n        uint256 tokenAmount = locker.getAddressLockedTokens(\\n            address(this),\\n            deployedToken.pair()\\n        );\\n        locker.withdrawTokenAmount(deployedToken.pair(), tokenAmount);\\n    }\\n\\n    function removeLiquidity(uint256 tokenId) external onlyDAO returns (bool) {\\n        address tokenAddress = tokenCountToAddress[tokenId];\\n        OperaToken deployedToken = OperaToken(payable(tokenAddress));\\n        IERC20 lpToken = IERC20(deployedToken.pair());\\n        lpToken.approve(address(router), lpToken.balanceOf(address(this)));\\n        (uint256 amountA, uint256 amountB) = router.removeLiquidity(\\n            tokenAddress,\\n            WETHAddress,\\n            lpToken.balanceOf(address(this)),\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp + 1\\n        );\\n        IWETH wethContract = IWETH(payable(WETHAddress));\\n        wethContract.withdraw(amountB);\\n        uint256 extraLP;\\n        if (\\n            initialLiquidityFromTokenCount[tokenId] * _tokenDecimals >= amountB\\n        ) {\\n            OperaPool poolContract = OperaPool(payable(operaPoolAddress));\\n            poolContract.returnLentEth{value: amountB}(\\n                initialLiquidityFromTokenCount[tokenId]\\n            );\\n        } else {\\n            extraLP =\\n                amountB -\\n                (initialLiquidityFromTokenCount[tokenId] * _tokenDecimals);\\n\\n            OperaRevenue rewardContract = OperaRevenue(\\n                payable(operaRewardAddress)\\n            );\\n            rewardContract.recieveRewards{value: extraLP}();\\n            OperaPool poolContract = OperaPool(payable(operaPoolAddress));\\n            poolContract.returnLentEth{\\n                value: initialLiquidityFromTokenCount[tokenId] * _tokenDecimals\\n            }(initialLiquidityFromTokenCount[tokenId]);\\n        }\\n        return true;\\n    }\\n\\n    function removeLiquiditySafeGaurd(uint256 tokenId) external onlyOwner {\\n        address tokenAddress = tokenCountToAddress[tokenId];\\n        OperaToken deployedToken = OperaToken(payable(tokenAddress));\\n        IERC20 lpToken = IERC20(deployedToken.pair());\\n        lpToken.approve(address(router), lpToken.balanceOf(address(this)));\\n        (uint256 amountA, uint256 amountB) = router.removeLiquidity(\\n            tokenAddress,\\n            WETHAddress,\\n            lpToken.balanceOf(address(this)),\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp + 1\\n        );\\n    }\\n\\n    function removeLiquiditySafeGaurdAddress(address addy) external onlyOwner {\\n        OperaToken deployedToken = OperaToken(payable(addy));\\n        IERC20 lpToken = IERC20(deployedToken.pair());\\n        lpToken.approve(address(router), lpToken.balanceOf(address(this)));\\n        (uint256 amountA, uint256 amountB) = router.removeLiquidity(\\n            addy,\\n            WETHAddress,\\n            lpToken.balanceOf(address(this)),\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp + 1\\n        );\\n    }\\n\\n    receive() external payable {}\\n\\n    function rescueToken(address token) external onlyOwner {\\n        IERC20 tokenToRescue = IERC20(token);\\n        tokenToRescue.transfer(owner, tokenToRescue.balanceOf(address(this)));\\n    }\\n\\n    function authorizeOverride(address token, address addy) external onlyOwner {\\n        OperaToken tokenToRescue = OperaToken(payable(token));\\n        tokenToRescue.factoryAuthorizeOverride(addy);\\n    }\\n\\n    function rescueTokensETH(address token) external onlyOwner {\\n        OperaToken tokenToRescue = OperaToken(payable(token));\\n        tokenToRescue.clearStuckBalance();\\n    }\\n\\n    function withdraw() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"OperaToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n//SPDX-License-Identifier: MIT\\nimport \\\"OperaStakingV2.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"Auth.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\nimport \\\"IDEXRouter.sol\\\";\\nimport \\\"IDEXFactory.sol\\\";\\nimport \\\"OperaRevenue.sol\\\";\\n\\ncontract OperaToken is IERC20, Auth {\\n    using SafeMath for uint256;\\n\\n    string _name;\\n    string _symbol;\\n    string _telegram;\\n    string _website;\\n\\n    uint8 constant _decimals = 9;\\n\\n    uint256 public _totalSupply;\\n\\n    uint256 public _maxWalletToken;\\n    uint256 public _swapThreshold;\\n\\n    uint256 public _operaTax;\\n    uint256 public _marketingBuyTax;\\n    uint256 public _marketingSellTax;\\n    uint256 public _devBuyTax;\\n    uint256 public _devSellTax;\\n    uint256 public _liquidityBuyTax;\\n    uint256 public _liquiditySellTax;\\n\\n    mapping(address => uint256) _balances;\\n    mapping(address => mapping(address => uint256)) _allowances;\\n    mapping(address => bool) isFeeExempt;\\n\\n    address public pair;\\n    address public routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    // address public routerAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n    address public _devAddress;\\n    address public _marketingAddress;\\n    address public _operaRewardAddress;\\n    address public _operaAddress;\\n    address public WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    // address public WETHAddress = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n    address public DEAD = 0x000000000000000000000000000000000000dEaD;\\n    IDEXRouter public router;\\n\\n    bool inSwap;\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n    event AutoLiquify(uint256 amountETH, uint256 amountCoin);\\n\\n    constructor(\\n        string[] memory _stringData,\\n        address[] memory _addressData,\\n        uint256[] memory _intData,\\n        address rewardsAddress\\n    ) Auth(msg.sender) {\\n        require(_stringData.length == 4, \\\"String List needs 4 string inputs\\\");\\n        require(\\n            _addressData.length == 2,\\n            \\\"Address List needs 2 address inputs\\\"\\n        );\\n        require(_intData.length == 9, \\\"Int List needs 9 int inputs\\\");\\n        _operaRewardAddress = rewardsAddress;\\n        _operaAddress = msg.sender;\\n        router = IDEXRouter(routerAddress);\\n        pair = IDEXFactory(router.factory()).createPair(\\n            router.WETH(),\\n            address(this)\\n        );\\n\\n        authorizations[routerAddress] = true;\\n\\n        _name = _stringData[0];\\n        _symbol = _stringData[1];\\n        _telegram = _stringData[2];\\n        _website = _stringData[3];\\n\\n        _devAddress = _addressData[0];\\n        _marketingAddress = _addressData[1];\\n\\n        require(_intData[0] > 0 && _intData[0] < 999999999999999999);\\n        _totalSupply = _intData[0] * 10 ** _decimals;\\n        _balances[msg.sender] = _totalSupply;\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\n\\n        _maxWalletToken = (_totalSupply * _intData[1]) / 1000;\\n        _swapThreshold = (_totalSupply * _intData[2]) / 1000;\\n        _marketingBuyTax = _intData[3];\\n        _marketingSellTax = _intData[4];\\n        _devBuyTax = _intData[5];\\n        _devSellTax = _intData[6];\\n        _liquidityBuyTax = _intData[7];\\n        _liquiditySellTax = _intData[8];\\n\\n        _allowances[address(this)][address(router)] = _totalSupply;\\n\\n        require(\\n            _swapThreshold <= (_totalSupply / 20) &&\\n                _swapThreshold >= (_totalSupply / 500),\\n            \\\"Swap Threshold must be less than 5% of total supply, or greater than 0.2%.\\\"\\n        );\\n        require(\\n            _maxWalletToken >= (_totalSupply / 500),\\n            \\\"Max Wallet must be greater than 0.2%.\\\"\\n        );\\n        require(getSellTax() <= 480, \\\"Sell tax can't be greater than 48%.\\\");\\n        require(getBuyTax() <= 480, \\\"Buy tax can't be greater than 48%.\\\");\\n        if (getTotalTax() > 192) {\\n            _operaTax = 20;\\n        } else {\\n            _operaTax = 4;\\n        }\\n        require(\\n            _devAddress != address(0) && _marketingAddress != address(0),\\n            \\\"Reciever wallets can't be Zero address.\\\"\\n        );\\n    }\\n\\n    receive() external payable {}\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() external view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function getOwner() external view override returns (address) {\\n        return owner;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) external view override returns (uint256) {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, _totalSupply);\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        if (owner == msg.sender) {\\n            return _basicTransfer(msg.sender, recipient, amount);\\n        } else {\\n            return _transferFrom(msg.sender, recipient, amount);\\n        }\\n    }\\n\\n    function _basicTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        if (_allowances[sender][msg.sender] != _totalSupply) {\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\\n                .sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if (\\n            authorizations[sender] ||\\n            authorizations[recipient] ||\\n            recipient == _operaAddress\\n        ) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        checkLimits(sender, recipient, amount);\\n        if (shouldTokenSwap(recipient)) {\\n            tokenSwap();\\n        }\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        uint256 amountReceived = (recipient == pair || sender == pair)\\n            ? takeFee(sender, recipient, amount)\\n            : amount;\\n\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\n\\n        emit Transfer(sender, recipient, amountReceived);\\n        return true;\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (uint256) {\\n        if (isFeeExempt[sender] || isFeeExempt[recipient]) {\\n            return amount;\\n        }\\n        uint256 _totalFee;\\n\\n        _totalFee = (recipient == pair) ? getSellTax() : getBuyTax();\\n\\n        uint256 feeAmount = amount.mul(_totalFee).div(1000);\\n\\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\\n\\n        emit Transfer(sender, address(this), feeAmount);\\n\\n        return amount.sub(feeAmount);\\n    }\\n\\n    function getBuyTax() public view returns (uint) {\\n        return _liquidityBuyTax + _devBuyTax + _marketingBuyTax + _operaTax;\\n    }\\n\\n    function getSellTax() public view returns (uint) {\\n        return _liquiditySellTax + _devSellTax + _marketingSellTax + _operaTax;\\n    }\\n\\n    function getTotalTax() public view returns (uint) {\\n        return getSellTax() + getBuyTax();\\n    }\\n\\n    function setTaxes(\\n        uint256 _marketingBuyPercent,\\n        uint256 _marketingSellPercent,\\n        uint256 _devBuyPercent,\\n        uint256 _devSellPercent,\\n        uint256 _liquidityBuyPercent,\\n        uint256 _liquiditySellPercent\\n    ) external authorized {\\n        uint256 amount = _balances[address(this)];\\n        if (_operaTax == 20) {\\n            if (amount > 0) {\\n                tokenSwap();\\n            }\\n\\n            _operaTax = 4;\\n        }\\n        _marketingBuyTax = _marketingBuyPercent;\\n        _liquidityBuyTax = _liquidityBuyPercent;\\n        _devBuyTax = _devBuyPercent;\\n        _marketingSellTax = _marketingSellPercent;\\n        _liquiditySellTax = _liquiditySellPercent;\\n        _devSellTax = _devSellPercent;\\n        requireLimits();\\n    }\\n\\n    function tokenSwap() internal swapping {\\n        uint256 amount = _balances[address(this)];\\n\\n        uint256 amountToLiquify = (_liquidityBuyTax + _liquiditySellTax > 0)\\n            ? amount\\n                .mul(_liquidityBuyTax + _liquiditySellTax)\\n                .div(getTotalTax())\\n                .div(2)\\n            : 0;\\n\\n        uint256 amountToSwap = amount.sub(amountToLiquify);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = WETHAddress;\\n\\n        uint256 balanceBefore = address(this).balance;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        bool tmpSuccess;\\n\\n        uint256 amountETH = address(this).balance.sub(balanceBefore);\\n        uint256 totalETHFee = (_liquidityBuyTax + _liquiditySellTax > 0)\\n            ? getTotalTax().sub((_liquidityBuyTax + _liquiditySellTax).div(2))\\n            : getTotalTax();\\n\\n        uint256 amountETHLiquidity = amountETH\\n            .mul(_liquidityBuyTax + _liquiditySellTax)\\n            .div(totalETHFee)\\n            .div(2);\\n        if (_devBuyTax + _devSellTax > 0) {\\n            uint256 amountETHDev = amountETH.mul(_devBuyTax + _devSellTax).div(\\n                totalETHFee\\n            );\\n            (tmpSuccess, ) = payable(_devAddress).call{\\n                value: amountETHDev,\\n                gas: 100000\\n            }(\\\"\\\");\\n            tmpSuccess = false;\\n        }\\n\\n        if (_marketingBuyTax + _marketingSellTax > 0) {\\n            uint256 amountETHMarketing = amountETH\\n                .mul(_marketingBuyTax + _marketingSellTax)\\n                .div(totalETHFee);\\n            (tmpSuccess, ) = payable(_marketingAddress).call{\\n                value: amountETHMarketing,\\n                gas: 100000\\n            }(\\\"\\\");\\n            tmpSuccess = false;\\n        }\\n\\n        if (amountToLiquify > 0) {\\n            router.addLiquidityETH{value: amountETHLiquidity}(\\n                address(this),\\n                amountToLiquify,\\n                0,\\n                0,\\n                _operaAddress,\\n                block.timestamp\\n            );\\n            emit AutoLiquify(amountETHLiquidity, amountToLiquify);\\n        }\\n        uint256 operaFee = amountETH.mul(_operaTax.mul(2)).div(totalETHFee);\\n\\n        OperaRevenue rewardContract = OperaRevenue(\\n            payable(_operaRewardAddress)\\n        );\\n        rewardContract.recieveRewards{value: operaFee}();\\n    }\\n\\n    function shouldTokenSwap(address recipient) internal view returns (bool) {\\n        return ((recipient == pair) &&\\n            !inSwap &&\\n            _balances[address(this)] >= _swapThreshold);\\n    }\\n\\n    function checkLimits(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal view {\\n        if (\\n            !authorizations[sender] &&\\n            recipient != address(this) &&\\n            sender != address(this) &&\\n            recipient != address(DEAD) &&\\n            recipient != pair &&\\n            recipient != _marketingAddress &&\\n            recipient != _devAddress &&\\n            recipient != _operaAddress\\n        ) {\\n            uint256 heldTokens = balanceOf(recipient);\\n            require(\\n                (heldTokens + amount) <= _maxWalletToken,\\n                \\\"Total Holding is currently limited, you can not buy that much.\\\"\\n            );\\n        }\\n    }\\n\\n    function setMaxWallet(uint256 percent) external authorized {\\n        _maxWalletToken = (_totalSupply * percent) / 1000;\\n        requireLimits();\\n    }\\n\\n    function setTokenSwapSettings(uint256 percent) external authorized {\\n        _swapThreshold = (_totalSupply * percent) / 1000;\\n        requireLimits();\\n    }\\n\\n    function requireLimits() internal view {\\n        require(\\n            _swapThreshold <= (_totalSupply / 20) &&\\n                _swapThreshold >= (_totalSupply / 500),\\n            \\\"Swap Threshold must be less than 5% of total supply, or greater than 0.2%.\\\"\\n        );\\n        require(\\n            _maxWalletToken >= (_totalSupply / 500),\\n            \\\"Max Wallet must be greater than 0.2%.\\\"\\n        );\\n        require(getSellTax() <= 100, \\\"Sell tax can't be greater than 10%.\\\");\\n        require(getBuyTax() <= 100, \\\"Buy tax can't be greater than 10%.\\\");\\n        require(\\n            _devAddress != address(0) && _marketingAddress != address(0),\\n            \\\"Reciever wallets can't be Zero address.\\\"\\n        );\\n    }\\n\\n    function getAddress() external view returns (address) {\\n        return address(this);\\n    }\\n\\n    function aboutMe() external view returns (string memory, string memory) {\\n        return (_telegram, _website);\\n    }\\n\\n    function updateAboutMe(\\n        string memory telegram,\\n        string memory website\\n    ) external authorized {\\n        _telegram = telegram;\\n        _website = website;\\n    }\\n\\n    function factoryAuthorizeOverride(address addy) external {\\n        require(msg.sender == _operaAddress, \\\"Only the factory can call this.\\\");\\n        authorizations[addy] = true;\\n    }\\n\\n    function setAddresses(\\n        address marketingAddress,\\n        address devAddress\\n    ) external authorized {\\n        _marketingAddress = marketingAddress;\\n        _devAddress = devAddress;\\n        requireLimits();\\n    }\\n\\n    function setFeeExemption(address user, bool status) external authorized {\\n        isFeeExempt[user] = status;\\n    }\\n\\n    function clearStuckBalance() external {\\n        if (!inSwap) {\\n            require(\\n                msg.sender == _operaAddress,\\n                \\\"Only Factory Contract can clear balance.\\\"\\n            );\\n            payable(_operaAddress).transfer(address(this).balance);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"OperaStakingV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.18;\\nimport \\\"OperaToken.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data\\n    ) internal view returns (bytes memory) {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                \\\"Address: low-level static call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!_paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(\\n            value\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\\n            value,\\n            \\\"SafeERC20: decreased allowance below zero\\\"\\n        );\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            \\\"SafeERC20: low-level call failed\\\"\\n        );\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ncontract OperaStakingV2 is Pausable, Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 public rewardsToken;\\n    IERC20 public stakingToken;\\n\\n    uint256 public periodFinish = 0;\\n    uint256 public rewardRate = 0;\\n    uint256 public rewardsDuration;\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n    uint256 public stakingTokensDecimalRate;\\n    address public stakeAdmin;\\n    uint256 public lockDuration;\\n\\n    bool private initialised;\\n    bool public locked;\\n\\n    uint256 public constant MAX_UNSTAKE_FEE = 2000;\\n\\n    uint256 public earlyUnstakeFee = 1500;\\n\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    mapping(address => uint256) public rewards;\\n\\n    uint256 private _totalSupply;\\n    mapping(address => uint256) private _balances;\\n\\n    modifier notContract() {\\n        require(!_isContract(msg.sender), \\\"contract not allowed\\\");\\n        require(msg.sender == tx.origin, \\\"proxy contract not allowed\\\");\\n        _;\\n    }\\n\\n    function _isContract(address addr) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor() {\\n        stakingTokensDecimalRate = 10 ** 9;\\n        rewardsToken = IERC20(0x3bd8268791DE798d4ED5d424d49412cF42B8eC3a);\\n        stakingToken = IERC20(0x3bd8268791DE798d4ED5d424d49412cF42B8eC3a);\\n        rewardsDuration = 2630000;\\n        locked = true;\\n        if (locked) {\\n            lockDuration = 2630000;\\n        }\\n        stakeAdmin = msg.sender;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function totalSupply() external view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return min(block.timestamp, periodFinish);\\n    }\\n\\n    function rewardPerToken() public view returns (uint256) {\\n        if (_totalSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored.add(\\n                lastTimeRewardApplicable()\\n                    .sub(lastUpdateTime)\\n                    .mul(rewardRate)\\n                    .mul(stakingTokensDecimalRate)\\n                    .div(_totalSupply)\\n            );\\n    }\\n\\n    function earned(address account) public view returns (uint256) {\\n        return\\n            _balances[account]\\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\\n                .div(stakingTokensDecimalRate)\\n                .add(rewards[account]);\\n    }\\n\\n    function getRewardForDuration() external view returns (uint256) {\\n        return rewardRate.mul(rewardsDuration);\\n    }\\n\\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function PoolInfo()\\n        public\\n        view\\n        returns (\\n            uint256 _periodFinish,\\n            uint256 _rewardRate,\\n            uint256 _rewardsDuration,\\n            uint256 _lastUpdateTime,\\n            uint256 _rewardPerToken,\\n            uint256 _getRewardForDuration,\\n            uint256 _lockDuration,\\n            uint256 _earlyUnstakeFee,\\n            uint256 _totSupply\\n        )\\n    {\\n        _periodFinish = periodFinish;\\n        _rewardRate = rewardRate;\\n        _rewardsDuration = rewardsDuration;\\n        _lastUpdateTime = lastUpdateTime;\\n        _rewardPerToken = rewardPerToken();\\n        _getRewardForDuration = rewardRate.mul(rewardsDuration);\\n        _lockDuration = lockDuration;\\n        _earlyUnstakeFee = earlyUnstakeFee;\\n        _totSupply = _totalSupply;\\n    }\\n\\n    function UserInfo(\\n        address account\\n    )\\n        public\\n        view\\n        returns (uint256 _balanceOf, uint256 _earned, uint256 _rewards)\\n    {\\n        _balanceOf = _balances[account];\\n        _earned = earned(account);\\n        _rewards = rewards[account];\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    function stake(\\n        uint256 amount\\n    ) external notContract whenNotPaused updateReward(msg.sender) {\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\n        emit Staked(msg.sender, amount);\\n    }\\n\\n    function withdraw(\\n        uint256 amount\\n    ) public notContract updateReward(msg.sender) {\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\n        if (locked) {\\n            require(block.timestamp >= periodFinish, \\\"Lock Time is not over\\\");\\n        }\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        stakingToken.safeTransfer(msg.sender, amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function getReward() public notContract updateReward(msg.sender) {\\n        uint256 reward = rewards[msg.sender];\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n            rewardsToken.safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    function emergencyWithdraw(\\n        uint256 amount //allows you to exit the contract before unlock time, at a penalty to your balance\\n    ) public notContract updateReward(msg.sender) {\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\n        getReward();\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        if (earlyUnstakeFee > 0) {\\n            uint256 adminFee = amount.mul(earlyUnstakeFee).div(10000);\\n            amount -= adminFee;\\n            stakingToken.safeTransfer(stakeAdmin, adminFee);\\n        }\\n        stakingToken.safeTransfer(msg.sender, amount);\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function exit() external {\\n        withdraw(_balances[msg.sender]);\\n        getReward();\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function notifyRewardAmount(\\n        uint256 reward\\n    ) external onlyOwner updateReward(address(0)) {\\n        if (block.timestamp >= periodFinish) {\\n            rewardRate = reward.div(rewardsDuration);\\n        } else {\\n            uint256 remaining = periodFinish.sub(block.timestamp);\\n            uint256 leftover = remaining.mul(rewardRate);\\n            rewardRate = reward.add(leftover).div(rewardsDuration);\\n        }\\n\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\n        // This keeps the reward rate in the right range, preventing overflows due to\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\n        uint256 balance = rewardsToken.balanceOf(address(this));\\n        require(\\n            rewardRate <= balance.div(rewardsDuration),\\n            \\\"Provided reward too high\\\"\\n        );\\n\\n        lastUpdateTime = block.timestamp;\\n        periodFinish = block.timestamp.add(rewardsDuration);\\n        emit RewardAdded(reward);\\n    }\\n\\n    function setEarlyUnstakeFee(uint256 _earlyUnstakeFee) external onlyOwner {\\n        require(\\n            _earlyUnstakeFee <= MAX_UNSTAKE_FEE,\\n            \\\"earlyUnstakeFee cannot be more than MAX_UNSTAKE_FEE\\\"\\n        );\\n        earlyUnstakeFee = _earlyUnstakeFee;\\n    }\\n\\n    // function setTokenInternalFee(uint256 _tokenInternalFess) external onlyOwner {\\n    //     tokenInternalFess = _tokenInternalFess;\\n    // }\\n\\n    function manualUnlock() external onlyOwner {\\n        locked = false;\\n    }\\n\\n    function recoverERC20(\\n        address tokenAddress,\\n        uint256 tokenAmount\\n    ) external onlyOwner {\\n        require(\\n            block.timestamp >= periodFinish + 2 hours,\\n            \\\"Lock Time is not over\\\"\\n        );\\n\\n        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\\n        emit Recovered(tokenAddress, tokenAmount);\\n    }\\n\\n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\\n        require(\\n            block.timestamp > periodFinish,\\n            \\\"Previous rewards period must be complete before changing the duration for the new period\\\"\\n        );\\n        rewardsDuration = _rewardsDuration;\\n        emit RewardsDurationUpdated(rewardsDuration);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier updateReward(address account) {\\n        rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        if (account != address(0)) {\\n            rewards[account] = earned(account);\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n        }\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n    event RewardsDurationUpdated(uint256 newDuration);\\n    event Recovered(address token, uint256 amount);\\n    event Compounded(address indexed user, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function getOwner() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address _owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nabstract contract Auth {\\n    address internal owner;\\n    mapping(address => bool) internal authorizations;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        authorizations[_owner] = true;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"!OWNER\\\");\\n        _;\\n    }\\n\\n    modifier authorized() {\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function authorize(address adr) public onlyOwner {\\n        authorizations[adr] = true;\\n    }\\n\\n    function unauthorize(address adr) public onlyOwner {\\n        authorizations[adr] = false;\\n    }\\n\\n    function isOwner(address account) public view returns (bool) {\\n        return account == owner;\\n    }\\n\\n    function isAuthorized(address adr) public view returns (bool) {\\n        return authorizations[adr];\\n    }\\n\\n    function transferOwnership(address payable adr) public onlyOwner {\\n        owner = adr;\\n        authorizations[adr] = true;\\n        emit OwnershipTransferred(adr);\\n    }\\n\\n    event OwnershipTransferred(address owner);\\n}\\n\"\r\n    },\r\n    \"IDEXRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IDEXFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IDEXFactory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\n\"\r\n    },\r\n    \"OperaRevenue.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n\\n//SPDX-License-Identifier: MIT\\nimport \\\"OperaToken.sol\\\";\\nimport \\\"OperaLendingPool.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"Math.sol\\\";\\n\\ncontract OperaRevenue {\\n    address public owner;\\n    address public teamAlpha;\\n    address public teamBeta = 0xB0241BD37223F8c55096A2e15A13534A57938716;\\n    mapping(address => uint256) public claimableRewardsForAddress;\\n    address public lendingPoolAddress;\\n    event rewardsMoved(\\n        address account,\\n        uint256 amount,\\n        uint256 blocktime,\\n        bool incoming\\n    );\\n    event rewardsAwarded(address user, uint256 amount, uint256 blocktime);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        teamAlpha = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"only owner\\\");\\n        _;\\n    }\\n\\n    function withdraw() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    function requestReward() external {\\n        uint256 usersRewardAmount = claimableRewardsForAddress[msg.sender];\\n        require(usersRewardAmount > 0, \\\"You have no rewards.\\\");\\n        claimableRewardsForAddress[msg.sender] = 0;\\n        payable(msg.sender).transfer(usersRewardAmount);\\n        emit rewardsMoved(\\n            msg.sender,\\n            usersRewardAmount,\\n            block.timestamp,\\n            false\\n        );\\n    }\\n\\n    function setLendingPoolAddress(address addy) external onlyOwner {\\n        lendingPoolAddress = addy;\\n    }\\n\\n    function setBetaAddress(address addy) external onlyOwner {\\n        teamBeta = addy;\\n    }\\n\\n    function setAlphaAddress(address addy) external onlyOwner {\\n        teamAlpha = addy;\\n    }\\n\\n    function getAddressBalance(address _address) public view returns (uint256) {\\n        return _address.balance;\\n    }\\n\\n    receive() external payable {}\\n\\n    function recieveRewards() external payable {\\n        OperaPool lender = OperaPool(payable(lendingPoolAddress));\\n        uint256 totalEthLent = lender.totalEthLent();\\n        if (totalEthLent == 0) {\\n            uint256 getTeamFee = (msg.value * 50) / 100;\\n            claimableRewardsForAddress[teamAlpha] += getTeamFee;\\n            claimableRewardsForAddress[teamBeta] += getTeamFee;\\n        } else {\\n            uint256 numberOfLenders = lender.numberOfLenders();\\n            uint256 getLenderFee = (msg.value * 70) / 100;\\n            uint256 getTeamFee = (msg.value * 15) / 100;\\n            uint256 rewardsPerShare = getLenderFee / totalEthLent;\\n            address tempAddress;\\n            uint256 tempLentAmount;\\n            claimableRewardsForAddress[teamAlpha] += getTeamFee;\\n            claimableRewardsForAddress[teamBeta] += getTeamFee;\\n            for (uint256 i = 0; i < numberOfLenders; i++) {\\n                tempAddress = lender.lenderIdToAddress(i + 1);\\n                tempLentAmount = lender.usersCurrentLentAmount(tempAddress);\\n                claimableRewardsForAddress[tempAddress] +=\\n                    tempLentAmount *\\n                    rewardsPerShare;\\n                emit rewardsAwarded(\\n                    tempAddress,\\n                    tempLentAmount * rewardsPerShare,\\n                    block.timestamp\\n                );\\n            }\\n        }\\n\\n        emit rewardsMoved(msg.sender, msg.value, block.timestamp, true);\\n    }\\n}\\n\"\r\n    },\r\n    \"OperaLendingPool.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n//SPDX-License-Identifier: MIT\\nimport \\\"Auth.sol\\\";\\nimport \\\"OperaStakingV2.sol\\\";\\n\\ncontract OperaPool is Auth {\\n    uint256 public totalEthLent;\\n    uint256 public totalAvailableEth;\\n    uint256 public numberOfLenders;\\n    uint256 public lendingStakingRequirement;\\n    uint256 public borrowLimit = 3;\\n    uint256 public _tokenDecimals = 1 * 10 ** 18;\\n    bool public borrowingEnable = true;\\n    OperaStakingV2 public operaStakingAddress;\\n    mapping(address => uint256) public usersCurrentLentAmount;\\n    mapping(uint256 => address) public lenderIdToAddress;\\n    mapping(address => uint256) public lenderAddressToId;\\n    mapping(address => bool) public authorizedFactoryAddresses;\\n\\n    event ethMoved(\\n        address account,\\n        uint256 amount,\\n        uint256 code,\\n        uint256 blocktime\\n    ); // 1 lent 2 borrowed 3 returned 4 withdrawn\\n\\n    event factoryStatusChange(address factoryAddress, bool status);\\n\\n    constructor() Auth(msg.sender) {}\\n\\n    modifier onlyFactoryAuthorized() {\\n        require(\\n            authorizedFactoryAddresses[msg.sender],\\n            \\\"only factory contracts can borrow eth\\\"\\n        );\\n        _;\\n    }\\n\\n    function updateFactoryAuthorization(\\n        address addy,\\n        bool status\\n    ) external onlyOwner {\\n        authorizedFactoryAddresses[addy] = status;\\n        emit factoryStatusChange(addy, status);\\n    }\\n\\n    function updateBorrowLimit(uint256 limit) external onlyOwner {\\n        borrowLimit = limit;\\n    }\\n\\n    function updateLendingStakeRequirement(uint256 limit) external onlyOwner {\\n        lendingStakingRequirement = limit;\\n    }\\n\\n    function setStakingAddress(address addy) external onlyOwner {\\n        operaStakingAddress = OperaStakingV2(addy);\\n    }\\n\\n    function updateBorrowingEnabled(bool status) external onlyOwner {\\n        borrowingEnable = status;\\n    }\\n\\n    receive() external payable {}\\n\\n    function lendEth() external payable returns (bool) {\\n        require(\\n            msg.value > 0 && msg.value % _tokenDecimals == 0,\\n            \\\"Only send full ether.\\\"\\n        );\\n        if (lendingStakingRequirement > 0) {\\n            require(\\n                operaStakingAddress.balanceOf(msg.sender) >=\\n                    lendingStakingRequirement,\\n                \\\"You are not staking enough to lend.\\\"\\n            );\\n        }\\n        if (lenderAddressToId[msg.sender] == 0) {\\n            lenderAddressToId[msg.sender] = numberOfLenders + 1;\\n            lenderIdToAddress[numberOfLenders + 1] = msg.sender;\\n            numberOfLenders += 1;\\n        }\\n        uint256 amountReceived = msg.value / _tokenDecimals;\\n        emit ethMoved(msg.sender, amountReceived, 1, block.timestamp);\\n        totalEthLent += amountReceived;\\n\\n        usersCurrentLentAmount[msg.sender] += amountReceived;\\n        totalAvailableEth += amountReceived;\\n\\n        return true;\\n    }\\n\\n    function borrowEth(uint256 _amount) external onlyFactoryAuthorized {\\n        require(_amount <= totalAvailableEth, \\\"Not Enough eth to borrow\\\");\\n        require(_amount > 0, \\\"Cannot borrow 0\\\");\\n        require(borrowingEnable, \\\"Borrowing is not enabled.\\\");\\n        require(_amount <= borrowLimit, \\\"Can't borrow that much.\\\");\\n        totalAvailableEth -= _amount;\\n        payable(msg.sender).transfer(_amount * _tokenDecimals);\\n        emit ethMoved(msg.sender, _amount, 2, block.timestamp);\\n    }\\n\\n    function returnLentEth(uint256 amountEth) external payable returns (bool) {\\n        require(\\n            (amountEth * _tokenDecimals) - msg.value == 0,\\n            \\\"Did not send enough eth.\\\"\\n        );\\n\\n        emit ethMoved(msg.sender, amountEth, 3, block.timestamp);\\n        totalAvailableEth += amountEth;\\n\\n        return true;\\n    }\\n\\n    function withdrawLentEth(uint256 _amountEther) external payable {\\n        require(\\n            usersCurrentLentAmount[msg.sender] >= _amountEther,\\n            \\\"You Did not lend that much.\\\"\\n        );\\n\\n        require(_amountEther > 0, \\\"Cant withdraw 0.\\\");\\n        require(_amountEther <= totalAvailableEth, \\\"Not enough eth available.\\\");\\n        if (usersCurrentLentAmount[msg.sender] == _amountEther) {\\n            uint256 tempIdOfUser = lenderAddressToId[msg.sender];\\n            address addressOfLastUser = lenderIdToAddress[numberOfLenders];\\n            if (addressOfLastUser != msg.sender) {\\n                delete lenderAddressToId[msg.sender];\\n                lenderAddressToId[addressOfLastUser] = tempIdOfUser;\\n                lenderIdToAddress[tempIdOfUser] = addressOfLastUser;\\n                delete lenderIdToAddress[numberOfLenders];\\n                numberOfLenders -= 1;\\n            } else {\\n                delete lenderAddressToId[msg.sender];\\n                delete lenderIdToAddress[tempIdOfUser];\\n                numberOfLenders -= 1;\\n            }\\n        }\\n        usersCurrentLentAmount[msg.sender] -= _amountEther;\\n        totalAvailableEth -= _amountEther;\\n        totalEthLent -= _amountEther;\\n        payable(msg.sender).transfer(_amountEther * _tokenDecimals);\\n        emit ethMoved(msg.sender, _amountEther, 4, block.timestamp);\\n    }\\n\\n    //safe gaurd so no funds get locked\\n    function withdraw() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    function rescueToken(address token) external onlyOwner {\\n        IERC20 tokenToRescue = IERC20(token);\\n        tokenToRescue.transfer(owner, tokenToRescue.balanceOf(address(this)));\\n    }\\n\\n    function removeExcess() external payable onlyOwner {\\n        require(\\n            address(this).balance > totalAvailableEth * _tokenDecimals,\\n            \\\"There is no excess eth\\\"\\n        );\\n        uint256 excessAmount = address(this).balance -\\n            (totalAvailableEth * _tokenDecimals);\\n        payable(owner).transfer(excessAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"Math.sol\": {\r\n      \"content\": \"/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >0.4.13;\\n\\ncontract DSMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint x, uint y) internal pure returns (uint z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int x, int y) internal pure returns (int z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int x, int y) internal pure returns (int z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint constant WAD = 10 ** 18;\\n    uint constant RAY = 10 ** 27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function rmul(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint x, uint n) internal pure returns (uint z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"WETH.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n\\n//SPDX-License-Identifier: MIT\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint value) external returns (bool);\\n\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"OperaLocker.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n\\n//SPDX-License-Identifier: MIT\\nimport \\\"IERC20.sol\\\";\\nimport \\\"Math.sol\\\";\\n\\ncontract OperaLocker {\\n    address public owner;\\n    bool public lockEnabled = true;\\n\\n    mapping(address => mapping(address => uint256)) public accountsLockedTokens;\\n    mapping(address => mapping(address => uint256))\\n        public accountsLockedTimeOfToken;\\n\\n    event tokenLocked(\\n        address account,\\n        address token,\\n        uint256 amount,\\n        uint256 locktime\\n    );\\n    event tokenWithdrawn(address account, address token, uint256 amount);\\n\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"only owner\\\");\\n        _;\\n    }\\n\\n    function getAddressLockedTokens(\\n        address user,\\n        address token\\n    ) public view returns (uint256) {\\n        return accountsLockedTokens[user][token];\\n    }\\n\\n    function changeLockEnabled(bool locked) external onlyOwner {\\n        lockEnabled = locked;\\n    }\\n\\n    function getAddressLockedTime(\\n        address user,\\n        address token\\n    ) public view returns (uint256) {\\n        return accountsLockedTimeOfToken[user][token];\\n    }\\n\\n    function withdrawTokenAmount(\\n        address tokenAddress,\\n        uint256 amount\\n    ) external {\\n        if (lockEnabled) {\\n            require(\\n                accountsLockedTimeOfToken[msg.sender][tokenAddress] > 0 &&\\n                    accountsLockedTimeOfToken[msg.sender][tokenAddress] <=\\n                    block.timestamp,\\n                \\\"Tokens are not ready to be unlocked.\\\"\\n            );\\n        }\\n\\n        require(\\n            accountsLockedTokens[msg.sender][tokenAddress] >= amount,\\n            \\\"You did not lock this many tokens.\\\"\\n        );\\n        if (accountsLockedTokens[msg.sender][tokenAddress] == amount) {\\n            accountsLockedTimeOfToken[msg.sender][tokenAddress] = 0; //resetting timer for lock to indicate no tokens locked\\n        }\\n        accountsLockedTokens[msg.sender][tokenAddress] -= amount;\\n        IERC20 tokenToLock = IERC20(tokenAddress);\\n        uint256 balanceBefore = tokenToLock.balanceOf(address(this));\\n        tokenToLock.transfer(msg.sender, amount);\\n        uint256 balanceAfter = tokenToLock.balanceOf(address(this));\\n        require(\\n            balanceBefore - amount == balanceAfter,\\n            \\\"Failed to transfer amount of tokens when withdrawing.\\\"\\n        );\\n        emit tokenWithdrawn(msg.sender, tokenAddress, amount);\\n    }\\n\\n    function lockTokens(\\n        address tokenAddress,\\n        uint256 amount,\\n        uint256 locktimeInSeconds\\n    ) external {\\n        require(\\n            accountsLockedTimeOfToken[msg.sender][tokenAddress] == 0,\\n            \\\"You already have this tocken locked.\\\"\\n        );\\n        // require(amount > 0, \\\"Cannot Lock 0 tokens\\\");\\n        IERC20 tokenToLock = IERC20(tokenAddress);\\n        uint256 balanceBefore = tokenToLock.balanceOf(address(this));\\n        tokenToLock.transferFrom(msg.sender, address(this), amount);\\n        uint256 balanceAfter = tokenToLock.balanceOf(address(this));\\n        require(\\n            balanceAfter - amount == balanceBefore,\\n            \\\"Failed to transfer amount of tokens when locking.\\\"\\n        );\\n        accountsLockedTokens[msg.sender][tokenAddress] = amount;\\n        accountsLockedTimeOfToken[msg.sender][tokenAddress] =\\n            block.timestamp +\\n            locktimeInSeconds;\\n        emit tokenLocked(\\n            msg.sender,\\n            tokenAddress,\\n            accountsLockedTokens[msg.sender][tokenAddress],\\n            block.timestamp + locktimeInSeconds\\n        );\\n    }\\n\\n    function increaseLockTime(\\n        address tokenAddress,\\n        uint256 increasedSeconds\\n    ) external {\\n        require(\\n            accountsLockedTimeOfToken[msg.sender][tokenAddress] > 0,\\n            \\\"You have no tokens locked.\\\"\\n        );\\n        require(increasedSeconds > 0, \\\"Cannot Lock 0 seconds\\\");\\n        accountsLockedTimeOfToken[msg.sender][tokenAddress] += increasedSeconds;\\n        emit tokenLocked(\\n            msg.sender,\\n            tokenAddress,\\n            accountsLockedTokens[msg.sender][tokenAddress],\\n            accountsLockedTimeOfToken[msg.sender][tokenAddress]\\n        );\\n    }\\n\\n    function increaseTokenAmount(\\n        address tokenAddress,\\n        uint256 amount\\n    ) external {\\n        require(\\n            accountsLockedTimeOfToken[msg.sender][tokenAddress] > 0,\\n            \\\"You have no tokens locked.\\\"\\n        );\\n        require(amount > 0, \\\"Cannot Lock 0 tokens\\\");\\n        IERC20 tokenToLock = IERC20(tokenAddress);\\n        uint256 balanceBefore = tokenToLock.balanceOf(address(this));\\n        tokenToLock.transferFrom(msg.sender, address(this), amount);\\n        uint256 balanceAfter = tokenToLock.balanceOf(address(this));\\n        require(\\n            balanceAfter - amount == balanceBefore,\\n            \\\"Failed to transfer amount of tokens when locking.\\\"\\n        );\\n        accountsLockedTokens[msg.sender][tokenAddress] += amount;\\n        emit tokenLocked(\\n            msg.sender,\\n            tokenAddress,\\n            accountsLockedTokens[msg.sender][tokenAddress],\\n            accountsLockedTimeOfToken[msg.sender][tokenAddress]\\n        );\\n    }\\n\\n    function withdraw() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"OperaDAO.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n\\n//SPDX-License-Identifier: MIT\\n//This contract is used to vote on which token liquidity pools to be returned.\\nimport \\\"OperaToken.sol\\\";\\nimport \\\"OperaFactory.sol\\\";\\nimport \\\"OperaStakingV2.sol\\\";\\n\\ncontract OperaDAO {\\n    address public owner;\\n    address public operaFactoryAddress;\\n    address public operaTokenAddress =\\n        0x3bd8268791DE798d4ED5d424d49412cF42B8eC3a;\\n\\n    OperaStakingV2 public operaStakingAddress;\\n    uint64 public lobbyCount;\\n    uint64 public voteTime;\\n    uint64 public cooldownTimer;\\n    uint64 public delayTimer;\\n    mapping(uint64 => uint256) public tokenIdVoteTimer;\\n    mapping(uint64 => VoteState) public tokenIdVoteState;\\n    mapping(uint64 => uint64) public tokenIdVoteLobby;\\n    mapping(uint64 => uint64) public lobbyVoterCount;\\n    mapping(uint64 => mapping(uint64 => Vote)) public votingLobbyToPositionVote;\\n    mapping(address => mapping(uint256 => bool))\\n        public voterAlreadyVotedForLobby;\\n\\n    struct Vote {\\n        address voter;\\n        bool vote;\\n    }\\n    enum VoteState {\\n        NOTINITIATED,\\n        VOTING,\\n        COOLDOWN,\\n        REMOVELPDELAY,\\n        COMPLETED\\n    }\\n    event tokenVoteStateChanged(\\n        uint64 tokenId,\\n        uint64 lobbyId,\\n        uint256 blocktime,\\n        VoteState state\\n    );\\n    event voteEmitted(address voter, uint64 lobbyId, uint64 tokenId, bool vote);\\n    event voteCounted(\\n        address voter,\\n        uint64 tokenId,\\n        uint64 lobbyId,\\n        uint256 amount\\n    );\\n\\n    constructor(uint64 _voteTime) {\\n        owner = msg.sender;\\n        voteTime = _voteTime;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"only owner\\\");\\n        _;\\n    }\\n\\n    function setStakingAddress(address addy) external onlyOwner {\\n        operaStakingAddress = OperaStakingV2(addy);\\n    }\\n\\n    function setFactoryAddress(address factory) external onlyOwner {\\n        operaFactoryAddress = factory;\\n    }\\n\\n    function setTimers(\\n        uint64 cooldown,\\n        uint64 delay,\\n        uint64 _voteTime\\n    ) external onlyOwner {\\n        require(cooldown <= 604800, \\\"No more than 1 week\\\");\\n        require(delay <= 86400, \\\"No more than 1 day\\\");\\n        require(_voteTime <= 86400, \\\"No more than 1 day\\\");\\n        cooldownTimer = cooldown;\\n        delayTimer = delay;\\n        voteTime = _voteTime;\\n    }\\n\\n    function startTimer(uint64 tokenId, uint64 time) external {\\n        require(\\n            msg.sender == operaFactoryAddress,\\n            \\\"Only the factory can start a timer for a token.\\\"\\n        );\\n        tokenIdVoteTimer[tokenId] = time;\\n        tokenIdVoteState[tokenId] = VoteState.COOLDOWN;\\n        emit tokenVoteStateChanged(\\n            tokenId,\\n            0,\\n            block.timestamp,\\n            VoteState.COOLDOWN\\n        );\\n    }\\n\\n    function startVoteForTokenId(uint64 id) external {\\n        require(\\n            tokenIdVoteState[id] == VoteState.COOLDOWN,\\n            \\\"Voting needs to be in cooldown.\\\"\\n        );\\n        require(\\n            tokenIdVoteTimer[id] > 0 && tokenIdVoteTimer[id] <= block.timestamp,\\n            \\\"Still on cooldown.\\\"\\n        );\\n        tokenIdVoteTimer[id] = block.timestamp;\\n        tokenIdVoteState[id] = VoteState.VOTING;\\n        tokenIdVoteLobby[id] = lobbyCount;\\n        lobbyCount += 1;\\n        emit tokenVoteStateChanged(\\n            id,\\n            tokenIdVoteLobby[id],\\n            block.timestamp,\\n            VoteState.VOTING\\n        );\\n    }\\n\\n    function voteForId(uint64 id, bool vote) external {\\n        require(tokenIdVoteState[id] == VoteState.VOTING, \\\"Voting not enabled\\\");\\n        uint64 lobbyId = tokenIdVoteLobby[id];\\n        require(\\n            voterAlreadyVotedForLobby[msg.sender][lobbyId] == false,\\n            \\\"You already voted\\\"\\n        );\\n        voterAlreadyVotedForLobby[msg.sender][lobbyId] = true;\\n        uint64 voterCount = lobbyVoterCount[lobbyId];\\n        votingLobbyToPositionVote[lobbyId][voterCount] = Vote(msg.sender, vote);\\n        lobbyVoterCount[lobbyId] += 1;\\n        emit voteEmitted(msg.sender, lobbyId, id, vote);\\n    }\\n\\n    function completeVote(uint64 id) external {\\n        require(\\n            tokenIdVoteState[id] == VoteState.VOTING,\\n            \\\"Not currently voting.\\\"\\n        );\\n        require(\\n            tokenIdVoteTimer[id] + voteTime <= block.timestamp,\\n            \\\"Voting in effect.\\\"\\n        );\\n\\n        if (getVoteResult(tokenIdVoteLobby[id], id)) {\\n            tokenIdVoteState[id] = VoteState.REMOVELPDELAY;\\n            tokenIdVoteTimer[id] = block.timestamp + delayTimer;\\n            emit tokenVoteStateChanged(\\n                id,\\n                tokenIdVoteLobby[id],\\n                block.timestamp,\\n                VoteState.REMOVELPDELAY\\n            );\\n        } else {\\n            tokenIdVoteState[id] = VoteState.COOLDOWN;\\n            tokenIdVoteTimer[id] = block.timestamp + cooldownTimer;\\n            OperaFactory factory = OperaFactory(payable(operaFactoryAddress));\\n            factory.increaseLockTime(id, cooldownTimer + voteTime);\\n            emit tokenVoteStateChanged(\\n                id,\\n                tokenIdVoteLobby[id],\\n                block.timestamp,\\n                VoteState.COOLDOWN\\n            );\\n        }\\n    }\\n\\n    function getVoteResult(\\n        uint64 lobbyId,\\n        uint64 tokenId\\n    ) internal returns (bool) {\\n        OperaToken operaToken = OperaToken(payable(operaTokenAddress));\\n\\n        uint256 voteFor;\\n        uint256 voteAgainst;\\n        Vote memory tempVote;\\n        uint256 tempVoteAmount;\\n        for (uint64 i = 0; i < lobbyVoterCount[lobbyId]; i++) {\\n            tempVote = votingLobbyToPositionVote[lobbyId][i];\\n            tempVoteAmount =\\n                operaToken.balanceOf(tempVote.voter) +\\n                operaStakingAddress.balanceOf(tempVote.voter);\\n            if (tempVote.vote) {\\n                voteFor += tempVoteAmount;\\n            } else {\\n                voteAgainst += tempVoteAmount;\\n            }\\n            emit voteCounted(tempVote.voter, tokenId, lobbyId, tempVoteAmount);\\n        }\\n        uint256 totalVotes = voteFor + voteAgainst;\\n        uint256 voteThreshhold = (totalVotes * 60) / 100;\\n        if (voteFor >= voteThreshhold) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function removeTokenLP(uint64 id) external {\\n        require(\\n            tokenIdVoteState[id] == VoteState.REMOVELPDELAY,\\n            \\\"Not in remove lp State.\\\"\\n        );\\n        require(\\n            tokenIdVoteTimer[id] <= block.timestamp,\\n            \\\"Delay still in effect.\\\"\\n        );\\n        tokenIdVoteState[id] = VoteState.COMPLETED;\\n        emit tokenVoteStateChanged(\\n            id,\\n            tokenIdVoteLobby[id],\\n            block.timestamp,\\n            VoteState.COMPLETED\\n        );\\n        OperaFactory factory = OperaFactory(payable(operaFactoryAddress));\\n        factory.claimLiquidityFromLockerWithId(id);\\n        bool removedLP = factory.removeLiquidity(id);\\n        require(removedLP, \\\"Failed to removed liquidity\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"OperaFactory.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addressData\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"feeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountEth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blocktime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"stringData\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"uintData\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"addressData\",\"type\":\"address[]\"}],\"name\":\"tokenDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETHAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokenDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"authorizeOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addressData\",\"type\":\"address[]\"}],\"name\":\"changeAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"claimLiquidityFromLockerWithAddress\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimLiquidityFromLockerWithId\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_stringData\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_addressData\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_intData\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_amountEthToBorrow\",\"type\":\"uint256\"}],\"name\":\"deployToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePerEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timer\",\"type\":\"uint256\"}],\"name\":\"increaseLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initialLiquidityFromTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operaDAOAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operaLockerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operaPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operaRewardAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"removeLiquiditySafeGaurd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"removeLiquiditySafeGaurdAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescueTokensETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenCountToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDeployedCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateFeePerEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OperaFactory", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000400000000000000000000000011c68f5c28684fd553160ac89b32c1f6390e7f330000000000000000000000007900421514e80d34b60fc3867261491fdafac533000000000000000000000000033437cb8d213fceab933cf32458e6c8b5f2bb74000000000000000000000000cc14edfff7d0408ee523fbd328207d1b385e1871", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}