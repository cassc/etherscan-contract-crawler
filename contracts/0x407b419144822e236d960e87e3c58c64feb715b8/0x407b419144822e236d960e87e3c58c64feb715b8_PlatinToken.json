{"SourceCode": "pragma solidity ^0.4.25; // solium-disable-line linebreak-style\r\n\r\n/**\r\n * @author Anatolii Kucheruk (anatolii@platin.io)\r\n * @author Platin Limited, platin.io (platin@platin.io)\r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param _token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic _token) external onlyOwner {\r\n    uint256 balance = _token.balanceOf(this);\r\n    _token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2\u03c0.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this Ether.\r\n * @notice Ether can still be sent to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n */\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  constructor() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by setting a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    owner.transfer(address(this).balance);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Contracts that should not own Tokens\r\n * @author Remco Bloemen <remco@2\u03c0.com>\r\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\r\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\r\n * owner to reclaim the tokens.\r\n */\r\ncontract HasNoTokens is CanReclaimToken {\r\n\r\n /**\r\n  * @dev Reject all ERC223 compatible tokens\r\n  * @param _from address The address that is transferring the tokens\r\n  * @param _value uint256 the amount of the specified token\r\n  * @param _data Bytes The data passed from the caller.\r\n  */\r\n  function tokenFallback(\r\n    address _from,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    external\r\n    pure\r\n  {\r\n    _from;\r\n    _value;\r\n    _data;\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Contracts that should not own Contracts\r\n * @author Remco Bloemen <remco@2\u03c0.com>\r\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\r\n * of this contract to reclaim ownership of the contracts.\r\n */\r\ncontract HasNoContracts is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim ownership of Ownable contracts\r\n   * @param _contractAddr The address of the Ownable to be reclaimed.\r\n   */\r\n  function reclaimContract(address _contractAddr) external onlyOwner {\r\n    Ownable contractInst = Ownable(_contractAddr);\r\n    contractInst.transferOwnership(owner);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Base contract for contracts that should not own things.\r\n * @author Remco Bloemen <remco@2\u03c0.com>\r\n * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\r\n * Owned contracts. See respective base contracts for details.\r\n */\r\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title Authorizable\r\n * @dev Authorizable contract holds a list of control addresses that authorized to do smth.\r\n */\r\ncontract Authorizable is Ownable {\r\n\r\n    // List of authorized (control) addresses\r\n    mapping (address => bool) public authorized;\r\n\r\n    // Authorize event logging\r\n    event Authorize(address indexed who);\r\n\r\n    // UnAuthorize event logging\r\n    event UnAuthorize(address indexed who);\r\n\r\n    // onlyAuthorized modifier, restrict to the owner and the list of authorized addresses\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == owner || authorized[msg.sender], \"Not Authorized.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Authorize given address\r\n     * @param _who address Address to authorize \r\n     */\r\n    function authorize(address _who) public onlyOwner {\r\n        require(_who != address(0), \"Address can't be zero.\");\r\n        require(!authorized[_who], \"Already authorized\");\r\n\r\n        authorized[_who] = true;\r\n        emit Authorize(_who);\r\n    }\r\n\r\n    /**\r\n     * @dev unAuthorize given address\r\n     * @param _who address Address to unauthorize \r\n     */\r\n    function unAuthorize(address _who) public onlyOwner {\r\n        require(_who != address(0), \"Address can't be zero.\");\r\n        require(authorized[_who], \"Address is not authorized\");\r\n\r\n        authorized[_who] = false;\r\n        emit UnAuthorize(_who);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  uint256 internal totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Holders Token\r\n * @dev Extension to the OpenZepellin's StandardToken contract to track token holders.\r\n * Only holders with the non-zero balance are listed.\r\n */\r\ncontract HoldersToken is StandardToken {\r\n    using SafeMath for uint256;    \r\n\r\n    // holders list\r\n    address[] public holders;\r\n\r\n    // holder number in the list\r\n    mapping (address => uint256) public holderNumber;\r\n\r\n    /**\r\n     * @dev Get the holders count\r\n     * @return uint256 Holders count\r\n     */\r\n    function holdersCount() public view returns (uint256) {\r\n        return holders.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another preserving token holders\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @return bool Returns true if the transfer was succeeded\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        _preserveHolders(msg.sender, _to, _value);\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another preserving token holders\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @return bool Returns true if the transfer was succeeded\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        _preserveHolders(_from, _to, _value);\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove holder from the holders list\r\n     * @param _holder address Address of the holder to remove\r\n     */\r\n    function _removeHolder(address _holder) internal {\r\n        uint256 _number = holderNumber[_holder];\r\n\r\n        if (_number == 0 || holders.length == 0 || _number > holders.length)\r\n            return;\r\n\r\n        uint256 _index = _number.sub(1);\r\n        uint256 _lastIndex = holders.length.sub(1);\r\n        address _lastHolder = holders[_lastIndex];\r\n\r\n        if (_index != _lastIndex) {\r\n            holders[_index] = _lastHolder;\r\n            holderNumber[_lastHolder] = _number;\r\n        }\r\n\r\n        holderNumber[_holder] = 0;\r\n        holders.length = _lastIndex;\r\n    } \r\n\r\n    /**\r\n     * @dev Add holder to the holders list\r\n     * @param _holder address Address of the holder to add   \r\n     */\r\n    function _addHolder(address _holder) internal {\r\n        if (holderNumber[_holder] == 0) {\r\n            holders.push(_holder);\r\n            holderNumber[_holder] = holders.length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Preserve holders during transfers\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function _preserveHolders(address _from, address _to, uint256 _value) internal {\r\n        _addHolder(_to);   \r\n        if (balanceOf(_from).sub(_value) == 0) \r\n            _removeHolder(_from);\r\n    }\r\n}\r\n\r\n/**\r\n * @title PlatinTGE\r\n * @dev Platin Token Generation Event contract. It holds token economic constants and makes initial token allocation.\r\n * Initial token allocation function should be called outside the blockchain at the TGE moment of time, \r\n * from here on out, Platin Token and other Platin contracts become functional.\r\n */\r\ncontract PlatinTGE {\r\n    using SafeMath for uint256;\r\n    \r\n    // Token decimals\r\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\r\n\r\n    // Total Tokens Supply\r\n    uint256 public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); // 1,000,000,000 PTNX\r\n\r\n    // SUPPLY\r\n    // TOTAL_SUPPLY = 1,000,000,000 PTNX, is distributed as follows:\r\n    uint256 public constant SALES_SUPPLY = 300000000 * (10 ** uint256(decimals)); // 300,000,000 PTNX - 30%\r\n    uint256 public constant MINING_POOL_SUPPLY = 200000000 * (10 ** uint256(decimals)); // 200,000,000 PTNX - 20%\r\n    uint256 public constant FOUNDERS_AND_EMPLOYEES_SUPPLY = 200000000 * (10 ** uint256(decimals)); // 200,000,000 PTNX - 20%\r\n    uint256 public constant AIRDROPS_POOL_SUPPLY = 100000000 * (10 ** uint256(decimals)); // 100,000,000 PTNX - 10%\r\n    uint256 public constant RESERVES_POOL_SUPPLY = 100000000 * (10 ** uint256(decimals)); // 100,000,000 PTNX - 10%\r\n    uint256 public constant ADVISORS_POOL_SUPPLY = 70000000 * (10 ** uint256(decimals)); // 70,000,000 PTNX - 7%\r\n    uint256 public constant ECOSYSTEM_POOL_SUPPLY = 30000000 * (10 ** uint256(decimals)); // 30,000,000 PTNX - 3%\r\n\r\n    // HOLDERS\r\n    address public PRE_ICO_POOL; // solium-disable-line mixedcase\r\n    address public LIQUID_POOL; // solium-disable-line mixedcase\r\n    address public ICO; // solium-disable-line mixedcase\r\n    address public MINING_POOL; // solium-disable-line mixedcase \r\n    address public FOUNDERS_POOL; // solium-disable-line mixedcase\r\n    address public EMPLOYEES_POOL; // solium-disable-line mixedcase \r\n    address public AIRDROPS_POOL; // solium-disable-line mixedcase \r\n    address public RESERVES_POOL; // solium-disable-line mixedcase \r\n    address public ADVISORS_POOL; // solium-disable-line mixedcase\r\n    address public ECOSYSTEM_POOL; // solium-disable-line mixedcase \r\n\r\n    // HOLDER AMOUNT AS PART OF SUPPLY\r\n    // SALES_SUPPLY = PRE_ICO_POOL_AMOUNT + LIQUID_POOL_AMOUNT + ICO_AMOUNT\r\n    uint256 public constant PRE_ICO_POOL_AMOUNT = 20000000 * (10 ** uint256(decimals)); // 20,000,000 PTNX\r\n    uint256 public constant LIQUID_POOL_AMOUNT = 100000000 * (10 ** uint256(decimals)); // 100,000,000 PTNX\r\n    uint256 public constant ICO_AMOUNT = 180000000 * (10 ** uint256(decimals)); // 180,000,000 PTNX\r\n    // FOUNDERS_AND_EMPLOYEES_SUPPLY = FOUNDERS_POOL_AMOUNT + EMPLOYEES_POOL_AMOUNT\r\n    uint256 public constant FOUNDERS_POOL_AMOUNT = 190000000 * (10 ** uint256(decimals)); // 190,000,000 PTNX\r\n    uint256 public constant EMPLOYEES_POOL_AMOUNT = 10000000 * (10 ** uint256(decimals)); // 10,000,000 PTNX\r\n\r\n    // Unsold tokens reserve address\r\n    address public UNSOLD_RESERVE; // solium-disable-line mixedcase\r\n\r\n    // Tokens ico sale with lockup period\r\n    uint256 public constant ICO_LOCKUP_PERIOD = 182 days;\r\n    \r\n    // Platin Token ICO rate, regular\r\n    uint256 public constant TOKEN_RATE = 1000; \r\n\r\n    // Platin Token ICO rate with lockup, 20% bonus\r\n    uint256 public constant TOKEN_RATE_LOCKUP = 1200;\r\n\r\n    // Platin ICO min purchase amount\r\n    uint256 public constant MIN_PURCHASE_AMOUNT = 1 ether;\r\n\r\n    // Platin Token contract\r\n    PlatinToken public token;\r\n\r\n    // TGE time\r\n    uint256 public tgeTime;\r\n\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _tgeTime uint256 TGE moment of time\r\n     * @param _token address Address of the Platin Token contract       \r\n     * @param _preIcoPool address Address of the Platin PreICO Pool\r\n     * @param _liquidPool address Address of the Platin Liquid Pool\r\n     * @param _ico address Address of the Platin ICO contract\r\n     * @param _miningPool address Address of the Platin Mining Pool\r\n     * @param _foundersPool address Address of the Platin Founders Pool\r\n     * @param _employeesPool address Address of the Platin Employees Pool\r\n     * @param _airdropsPool address Address of the Platin Airdrops Pool\r\n     * @param _reservesPool address Address of the Platin Reserves Pool\r\n     * @param _advisorsPool address Address of the Platin Advisors Pool\r\n     * @param _ecosystemPool address Address of the Platin Ecosystem Pool  \r\n     * @param _unsoldReserve address Address of the Platin Unsold Reserve                                 \r\n     */  \r\n    constructor(\r\n        uint256 _tgeTime,\r\n        PlatinToken _token, \r\n        address _preIcoPool,\r\n        address _liquidPool,\r\n        address _ico,\r\n        address _miningPool,\r\n        address _foundersPool,\r\n        address _employeesPool,\r\n        address _airdropsPool,\r\n        address _reservesPool,\r\n        address _advisorsPool,\r\n        address _ecosystemPool,\r\n        address _unsoldReserve\r\n    ) public {\r\n        require(_tgeTime >= block.timestamp, \"TGE time should be >= current time.\"); // solium-disable-line security/no-block-members\r\n        require(_token != address(0), \"Token address can't be zero.\");\r\n        require(_preIcoPool != address(0), \"PreICO Pool address can't be zero.\");\r\n        require(_liquidPool != address(0), \"Liquid Pool address can't be zero.\");\r\n        require(_ico != address(0), \"ICO address can't be zero.\");\r\n        require(_miningPool != address(0), \"Mining Pool address can't be zero.\");\r\n        require(_foundersPool != address(0), \"Founders Pool address can't be zero.\");\r\n        require(_employeesPool != address(0), \"Employees Pool address can't be zero.\");\r\n        require(_airdropsPool != address(0), \"Airdrops Pool address can't be zero.\");\r\n        require(_reservesPool != address(0), \"Reserves Pool address can't be zero.\");\r\n        require(_advisorsPool != address(0), \"Advisors Pool address can't be zero.\");\r\n        require(_ecosystemPool != address(0), \"Ecosystem Pool address can't be zero.\");\r\n        require(_unsoldReserve != address(0), \"Unsold reserve address can't be zero.\");\r\n\r\n        // Setup tge time\r\n        tgeTime = _tgeTime;\r\n\r\n        // Setup token address\r\n        token = _token;\r\n\r\n        // Setup holder addresses\r\n        PRE_ICO_POOL = _preIcoPool;\r\n        LIQUID_POOL = _liquidPool;\r\n        ICO = _ico;\r\n        MINING_POOL = _miningPool;\r\n        FOUNDERS_POOL = _foundersPool;\r\n        EMPLOYEES_POOL = _employeesPool;\r\n        AIRDROPS_POOL = _airdropsPool;\r\n        RESERVES_POOL = _reservesPool;\r\n        ADVISORS_POOL = _advisorsPool;\r\n        ECOSYSTEM_POOL = _ecosystemPool;\r\n\r\n        // Setup unsold reserve address\r\n        UNSOLD_RESERVE = _unsoldReserve; \r\n    }\r\n\r\n    /**\r\n     * @dev Allocate function. Token Generation Event entry point.\r\n     * It makes initial token allocation according to the initial token supply constants.\r\n     */\r\n    function allocate() public {\r\n\r\n        // Should be called just after tge time\r\n        require(block.timestamp >= tgeTime, \"Should be called just after tge time.\"); // solium-disable-line security/no-block-members\r\n\r\n        // Should not be allocated already\r\n        require(token.totalSupply() == 0, \"Allocation is already done.\");\r\n\r\n        // SALES          \r\n        token.allocate(PRE_ICO_POOL, PRE_ICO_POOL_AMOUNT);\r\n        token.allocate(LIQUID_POOL, LIQUID_POOL_AMOUNT);\r\n        token.allocate(ICO, ICO_AMOUNT);\r\n      \r\n        // MINING POOL\r\n        token.allocate(MINING_POOL, MINING_POOL_SUPPLY);\r\n\r\n        // FOUNDERS AND EMPLOYEES\r\n        token.allocate(FOUNDERS_POOL, FOUNDERS_POOL_AMOUNT);\r\n        token.allocate(EMPLOYEES_POOL, EMPLOYEES_POOL_AMOUNT);\r\n\r\n        // AIRDROPS POOL\r\n        token.allocate(AIRDROPS_POOL, AIRDROPS_POOL_SUPPLY);\r\n\r\n        // RESERVES POOL\r\n        token.allocate(RESERVES_POOL, RESERVES_POOL_SUPPLY);\r\n\r\n        // ADVISORS POOL\r\n        token.allocate(ADVISORS_POOL, ADVISORS_POOL_SUPPLY);\r\n\r\n        // ECOSYSTEM POOL\r\n        token.allocate(ECOSYSTEM_POOL, ECOSYSTEM_POOL_SUPPLY);\r\n\r\n        // Check Token Total Supply\r\n        require(token.totalSupply() == TOTAL_SUPPLY, \"Total supply check error.\");   \r\n    }\r\n}\r\n\r\n/**\r\n * @title PlatinToken\r\n * @dev Platin PTNX Token contract. Tokens are allocated during TGE.\r\n * Token contract is a standard ERC20 token with additional capabilities: TGE allocation, holders tracking and lockup.\r\n * Initial allocation should be invoked by the TGE contract at the TGE moment of time.\r\n * Token contract holds list of token holders, the list includes holders with positive balance only.\r\n * Authorized holders can transfer token with lockup(s). Lockups can be refundable. \r\n * Lockups is a list of releases dates and releases amounts.\r\n * In case of refund previous holder can get back locked up tokens. Only still locked up amounts can be transferred back.\r\n */\r\ncontract PlatinToken is HoldersToken, NoOwner, Authorizable, Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Platin Token\"; // solium-disable-line uppercase\r\n    string public constant symbol = \"PTNX\"; // solium-disable-line uppercase\r\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\r\n \r\n    // lockup sruct\r\n    struct Lockup {\r\n        uint256 release; // release timestamp\r\n        uint256 amount; // amount of tokens to release\r\n    }\r\n\r\n    // list of lockups\r\n    mapping (address => Lockup[]) public lockups;\r\n\r\n    // list of lockups that can be refunded\r\n    mapping (address => mapping (address => Lockup[])) public refundable;\r\n\r\n    // idexes mapping from refundable to lockups lists \r\n    mapping (address => mapping (address => mapping (uint256 => uint256))) public indexes;    \r\n\r\n    // Platin TGE contract\r\n    PlatinTGE public tge;\r\n\r\n    // allocation event logging\r\n    event Allocate(address indexed to, uint256 amount);\r\n\r\n    // lockup event logging\r\n    event SetLockups(address indexed to, uint256 amount, uint256 fromIdx, uint256 toIdx);\r\n\r\n    // refund event logging\r\n    event Refund(address indexed from, address indexed to, uint256 amount);\r\n\r\n    // spotTransfer modifier, check balance spot on transfer\r\n    modifier spotTransfer(address _from, uint256 _value) {\r\n        require(_value <= balanceSpot(_from), \"Attempt to transfer more than balance spot.\");\r\n        _;\r\n    }\r\n\r\n    // onlyTGE modifier, restrict to the TGE contract only\r\n    modifier onlyTGE() {\r\n        require(msg.sender == address(tge), \"Only TGE method.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Set TGE contract\r\n     * @param _tge address PlatinTGE contract address    \r\n     */\r\n    function setTGE(PlatinTGE _tge) external onlyOwner {\r\n        require(tge == address(0), \"TGE is already set.\");\r\n        require(_tge != address(0), \"TGE address can't be zero.\");\r\n        tge = _tge;\r\n        authorize(_tge);\r\n    }        \r\n\r\n    /**\r\n     * @dev Allocate tokens during TGE\r\n     * @param _to address Address gets the tokens\r\n     * @param _amount uint256 Amount to allocate\r\n     */ \r\n    function allocate(address _to, uint256 _amount) external onlyTGE {\r\n        require(_to != address(0), \"Allocate To address can't be zero\");\r\n        require(_amount > 0, \"Allocate amount should be > 0.\");\r\n       \r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n\r\n        _addHolder(_to);\r\n\r\n        require(totalSupply_ <= tge.TOTAL_SUPPLY(), \"Can't allocate more than TOTAL SUPPLY.\");\r\n\r\n        emit Allocate(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n    }  \r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @return bool Returns true if the transfer was succeeded\r\n     */\r\n    function transfer(address _to, uint256 _value) public whenNotPaused spotTransfer(msg.sender, _value) returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @return bool Returns true if the transfer was succeeded\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused spotTransfer(_from, _value) returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another with lockup\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @param _lockupReleases uint256[] List of lockup releases\r\n     * @param _lockupAmounts uint256[] List of lockup amounts\r\n     * @param _refundable bool Is locked up amount refundable\r\n     * @return bool Returns true if the transfer was succeeded     \r\n     */\r\n    function transferWithLockup(\r\n        address _to, \r\n        uint256 _value, \r\n        uint256[] _lockupReleases,\r\n        uint256[] _lockupAmounts,\r\n        bool _refundable\r\n    ) \r\n    public onlyAuthorized returns (bool)\r\n    {        \r\n        transfer(_to, _value);\r\n        _lockup(_to, _value, _lockupReleases, _lockupAmounts, _refundable); // solium-disable-line arg-overflow     \r\n    }       \r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another with lockup\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @param _lockupReleases uint256[] List of lockup releases\r\n     * @param _lockupAmounts uint256[] List of lockup amounts\r\n     * @param _refundable bool Is locked up amount refundable      \r\n     * @return bool Returns true if the transfer was succeeded     \r\n     */\r\n    function transferFromWithLockup(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value, \r\n        uint256[] _lockupReleases,\r\n        uint256[] _lockupAmounts,\r\n        bool _refundable\r\n    ) \r\n    public onlyAuthorized returns (bool)\r\n    {\r\n        transferFrom(_from, _to, _value);\r\n        _lockup(_to, _value, _lockupReleases, _lockupAmounts, _refundable); // solium-disable-line arg-overflow  \r\n    }     \r\n\r\n    /**\r\n     * @dev Refund refundable locked up amount\r\n     * @param _from address The address which you want to refund tokens from\r\n     * @return uint256 Returns amount of refunded tokens   \r\n     */\r\n    function refundLockedUp(\r\n        address _from\r\n    )\r\n    public onlyAuthorized returns (uint256)\r\n    {\r\n        address _sender = msg.sender;\r\n        uint256 _balanceRefundable = 0;\r\n        uint256 _refundableLength = refundable[_from][_sender].length;\r\n        if (_refundableLength > 0) {\r\n            uint256 _lockupIdx;\r\n            for (uint256 i = 0; i < _refundableLength; i++) {\r\n                if (refundable[_from][_sender][i].release > block.timestamp) { // solium-disable-line security/no-block-members\r\n                    _balanceRefundable = _balanceRefundable.add(refundable[_from][_sender][i].amount);\r\n                    refundable[_from][_sender][i].release = 0;\r\n                    refundable[_from][_sender][i].amount = 0;\r\n                    _lockupIdx = indexes[_from][_sender][i];\r\n                    lockups[_from][_lockupIdx].release = 0;\r\n                    lockups[_from][_lockupIdx].amount = 0;       \r\n                }    \r\n            }\r\n\r\n            if (_balanceRefundable > 0) {\r\n                _preserveHolders(_from, _sender, _balanceRefundable);\r\n                balances[_from] = balances[_from].sub(_balanceRefundable);\r\n                balances[_sender] = balances[_sender].add(_balanceRefundable);\r\n                emit Refund(_from, _sender, _balanceRefundable);\r\n                emit Transfer(_from, _sender, _balanceRefundable);\r\n            }\r\n        }\r\n        return _balanceRefundable;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the lockups list count\r\n     * @param _who address Address owns locked up list\r\n     * @return uint256 Lockups list count\r\n     */\r\n    function lockupsCount(address _who) public view returns (uint256) {\r\n        return lockups[_who].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Find out if the address has lockups\r\n     * @param _who address Address checked for lockups\r\n     * @return bool Returns true if address has lockups\r\n     */\r\n    function hasLockups(address _who) public view returns (bool) {\r\n        return lockups[_who].length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Get balance locked up at the current moment of time\r\n     * @param _who address Address owns locked up amounts\r\n     * @return uint256 Balance locked up at the current moment of time\r\n     */\r\n    function balanceLockedUp(address _who) public view returns (uint256) {\r\n        uint256 _balanceLokedUp = 0;\r\n        uint256 _lockupsLength = lockups[_who].length;\r\n        for (uint256 i = 0; i < _lockupsLength; i++) {\r\n            if (lockups[_who][i].release > block.timestamp) // solium-disable-line security/no-block-members\r\n                _balanceLokedUp = _balanceLokedUp.add(lockups[_who][i].amount);\r\n        }\r\n        return _balanceLokedUp;\r\n    }\r\n\r\n    /**\r\n     * @dev Get refundable locked up balance at the current moment of time\r\n     * @param _who address Address owns locked up amounts\r\n     * @param _sender address Address owned locked up amounts\r\n     * @return uint256 Locked up refundable balance at the current moment of time\r\n     */\r\n    function balanceRefundable(address _who, address _sender) public view returns (uint256) {\r\n        uint256 _balanceRefundable = 0;\r\n        uint256 _refundableLength = refundable[_who][_sender].length;\r\n        if (_refundableLength > 0) {\r\n            for (uint256 i = 0; i < _refundableLength; i++) {\r\n                if (refundable[_who][_sender][i].release > block.timestamp) // solium-disable-line security/no-block-members\r\n                    _balanceRefundable = _balanceRefundable.add(refundable[_who][_sender][i].amount);\r\n            }\r\n        }\r\n        return _balanceRefundable;\r\n    }\r\n\r\n    /**\r\n     * @dev Get balance spot for the current moment of time\r\n     * @param _who address Address owns balance spot\r\n     * @return uint256 Balance spot for the current moment of time\r\n     */\r\n    function balanceSpot(address _who) public view returns (uint256) {\r\n        uint256 _balanceSpot = balanceOf(_who);\r\n        _balanceSpot = _balanceSpot.sub(balanceLockedUp(_who));\r\n        return _balanceSpot;\r\n    }\r\n\r\n    /**\r\n     * @dev Lockup amount till release time\r\n     * @param _who address Address gets the locked up amount\r\n     * @param _amount uint256 Amount to lockup\r\n     * @param _lockupReleases uint256[] List of lockup releases\r\n     * @param _lockupAmounts uint256[] List of lockup amounts\r\n     * @param _refundable bool Is locked up amount refundable     \r\n     */     \r\n    function _lockup(\r\n        address _who, \r\n        uint256 _amount, \r\n        uint256[] _lockupReleases,\r\n        uint256[] _lockupAmounts,\r\n        bool _refundable) \r\n    internal \r\n    {\r\n        require(_lockupReleases.length == _lockupAmounts.length, \"Length of lockup releases and amounts lists should be equal.\");\r\n        require(_lockupReleases.length.add(lockups[_who].length) <= 1000, \"Can't be more than 1000 lockups per address.\");\r\n        if (_lockupReleases.length > 0) {\r\n            uint256 _balanceLokedUp = 0;\r\n            address _sender = msg.sender;\r\n            uint256 _fromIdx = lockups[_who].length;\r\n            uint256 _toIdx = _fromIdx + _lockupReleases.length - 1;\r\n            uint256 _lockupIdx;\r\n            uint256 _refundIdx;\r\n            for (uint256 i = 0; i < _lockupReleases.length; i++) {\r\n                if (_lockupReleases[i] > block.timestamp) { // solium-disable-line security/no-block-members\r\n                    lockups[_who].push(Lockup(_lockupReleases[i], _lockupAmounts[i]));\r\n                    _balanceLokedUp = _balanceLokedUp.add(_lockupAmounts[i]);\r\n                    if (_refundable) {\r\n                        refundable[_who][_sender].push(Lockup(_lockupReleases[i], _lockupAmounts[i]));\r\n                        _lockupIdx = lockups[_who].length - 1;\r\n                        _refundIdx = refundable[_who][_sender].length - 1;\r\n                        indexes[_who][_sender][_refundIdx] = _lockupIdx;\r\n                    }\r\n                }\r\n            }\r\n\r\n            require(_balanceLokedUp <= _amount, \"Can't lockup more than transferred amount.\");\r\n            emit SetLockups(_who, _amount, _fromIdx, _toIdx); // solium-disable-line arg-overflow\r\n        }            \r\n    }      \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceLockedUp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refundable\",\"outputs\":[{\"name\":\"release\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"unAuthorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"balanceRefundable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceSpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"hasLockups\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tge\",\"type\":\"address\"}],\"name\":\"setTGE\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tge\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_lockupReleases\",\"type\":\"uint256[]\"},{\"name\":\"_lockupAmounts\",\"type\":\"uint256[]\"},{\"name\":\"_refundable\",\"type\":\"bool\"}],\"name\":\"transferWithLockup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allocate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_lockupReleases\",\"type\":\"uint256[]\"},{\"name\":\"_lockupAmounts\",\"type\":\"uint256[]\"},{\"name\":\"_refundable\",\"type\":\"bool\"}],\"name\":\"transferFromWithLockup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockups\",\"outputs\":[{\"name\":\"release\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"lockupsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"holderNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"refundLockedUp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Allocate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fromIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toIdx\",\"type\":\"uint256\"}],\"name\":\"SetLockups\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Authorize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"}],\"name\":\"UnAuthorize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "PlatinToken", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://17386ed75286216469fd26a4d49c410d1a84c8c920e5356e9121a27ab970c1e1"}