{"SourceCode": "// File: node_modules\\@openzeppelin\\contracts\\utils\\introspection\\IERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC1155\\IERC1155.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts\\model\\IERC1155Views.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n\r\n/**\r\n * @title IERC1155Views - An optional utility interface to improve the ERC-1155 Standard.\r\n * @dev This interface introduces some additional capabilities for ERC-1155 Tokens.\r\n */\r\ninterface IERC1155Views {\r\n\r\n    /**\r\n     * @dev Returns the total supply of the given token id\r\n     * @param itemId the id of the token whose availability you want to know \r\n     */\r\n    function totalSupply(uint256 itemId) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the name of the given token id\r\n     * @param itemId the id of the token whose name you want to know \r\n     */\r\n    function name(uint256 itemId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the given token id\r\n     * @param itemId the id of the token whose symbol you want to know \r\n     */\r\n    function symbol(uint256 itemId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals of the given token id\r\n     * @param itemId the id of the token whose decimals you want to know \r\n     */\r\n    function decimals(uint256 itemId) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the uri of the given token id\r\n     * @param itemId the id of the token whose uri you want to know \r\n     */\r\n    function uri(uint256 itemId) external view returns (string memory);\r\n}\r\n\r\n// File: contracts\\model\\Item.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\npragma abicoder v2;\r\n\r\n\r\n\r\nstruct Header {\r\n    address host;\r\n    string name;\r\n    string symbol;\r\n    string uri;\r\n}\r\n\r\nstruct CreateItem {\r\n    Header header;\r\n    bytes32 collectionId;\r\n    uint256 id;\r\n    address[] accounts;\r\n    uint256[] amounts;\r\n}\r\n\r\ninterface Item is IERC1155, IERC1155Views {\r\n\r\n    event CollectionItem(bytes32 indexed fromCollectionId, bytes32 indexed toCollectionId, uint256 indexed itemId);\r\n\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n    function decimals() external view returns(uint256);\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount) external;\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts) external;\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount, bytes calldata data) external;\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts, bytes calldata data) external;\r\n\r\n    function mintItems(CreateItem[] calldata items) external returns(uint256[] memory itemIds);\r\n    function setItemsCollection(uint256[] calldata itemIds, bytes32[] calldata collectionIds) external returns(bytes32[] memory oldCollectionIds);\r\n    function setItemsMetadata(uint256[] calldata itemIds, Header[] calldata newValues) external returns(Header[] memory oldValues);\r\n\r\n    function interoperableOf(uint256 itemId) external view returns(address);\r\n}\r\n\r\n// File: contracts\\model\\IItemMainInterface.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\nstruct ItemData {\r\n    bytes32 collectionId;\r\n    Header header;\r\n    bytes32 domainSeparator;\r\n    uint256 totalSupply;\r\n    mapping(address => uint256) balanceOf;\r\n    mapping(address => mapping(address => uint256)) allowance;\r\n    mapping(address => uint256) nonces;\r\n}\r\n\r\ninterface IItemMainInterface is Item {\r\n\r\n    event Collection(address indexed from, address indexed to, bytes32 indexed collectionId);\r\n\r\n    function interoperableInterfaceModel() external view returns(address);\r\n\r\n    function uri() external view returns(string memory);\r\n    function plainUri() external view returns(string memory);\r\n    function dynamicUriResolver() external view returns(address);\r\n    function hostInitializer() external view returns(address);\r\n\r\n    function collection(bytes32 collectionId) external view returns(address host, string memory name, string memory symbol, string memory uri);\r\n    function collectionUri(bytes32 collectionId) external view returns(string memory);\r\n    function createCollection(Header calldata _collection, CreateItem[] calldata items) external returns(bytes32 collectionId, uint256[] memory itemIds);\r\n    function setCollectionsMetadata(bytes32[] calldata collectionIds, Header[] calldata values) external returns(Header[] memory oldValues);\r\n\r\n    function setApprovalForAllByCollectionHost(bytes32 collectionId, address account, address operator, bool approved) external;\r\n\r\n    function item(uint256 itemId) external view returns(bytes32 collectionId, Header memory header, bytes32 domainSeparator, uint256 totalSupply);\r\n\r\n    function mintTransferOrBurn(bool isMulti, bytes calldata data) external;\r\n\r\n    function allowance(address account, address spender, uint256 itemId) external view returns(uint256);\r\n    function approve(address account, address spender, uint256 amount, uint256 itemId) external;\r\n    function TYPEHASH_PERMIT() external view returns (bytes32);\r\n    function EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION() external view returns(string memory domainSeparatorName, string memory domainSeparatorVersion);\r\n    function permit(uint256 itemId, address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function nonces(address owner, uint256 itemId) external view returns(uint256);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\extensions\\IERC20Metadata.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\extensions\\draft-IERC20Permit.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// File: contracts\\model\\IItemInteroperableInterface.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n\r\n\r\n\r\n\r\ninterface IItemInteroperableInterface is IERC20, IERC20Metadata, IERC20Permit {\r\n\r\n    function init() external;\r\n    function mainInterface() external view returns(address);\r\n    function itemId() external view returns(uint256);\r\n    function emitEvent(bool forApprove, bool isMulti, bytes calldata data) external;\r\n    function burn(uint256 amount) external;\r\n    function burnFrom(address account, uint256 amount) external;\r\n    function EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION() external view returns(string memory name, string memory version);\r\n}\r\n\r\n// File: contracts\\impl\\ItemInteroperableInterface.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n\r\n\r\n\r\ncontract ItemInteroperableInterface is IItemInteroperableInterface {\r\n\r\n    address public override mainInterface;\r\n\r\n    function init() override external {\r\n        require(mainInterface == address(0));\r\n        mainInterface = msg.sender;\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() external override view returns (bytes32 domainSeparatorValue) {\r\n        (,,domainSeparatorValue,) = IItemMainInterface(mainInterface).item(itemId());\r\n    }\r\n\r\n    function EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION() external override view returns(string memory, string memory) {\r\n        return IItemMainInterface(mainInterface).EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION();\r\n    }\r\n\r\n    function itemId() override public view returns(uint256) {\r\n        return uint160(address(this));\r\n    }\r\n\r\n    function emitEvent(bool forApprove, bool isMulti, bytes calldata data) override external {\r\n        require(msg.sender == mainInterface, \"Unauthorized\");\r\n        if(isMulti) {\r\n            (address[] memory froms, address[] memory tos, uint256[] memory amounts) = abi.decode(data, (address[], address[], uint256[]));\r\n            for(uint256 i = 0; i < froms.length; i++) {\r\n                if(forApprove) {\r\n                    emit Approval(froms[i], tos[i], amounts[i]);\r\n                } else {\r\n                    emit Transfer(froms[i], tos[i], amounts[i]);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        (address from, address to, uint256 amount) = abi.decode(data, (address, address, uint256));\r\n        if(forApprove) {\r\n            emit Approval(from, to, amount);\r\n        } else {\r\n            emit Transfer(from, to, amount);\r\n       }\r\n    }\r\n\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) override external {\r\n        IItemMainInterface(mainInterface).permit(itemId(), owner, spender, value, deadline, v, r, s);\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function burn(uint256 amount) override external {\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(false, abi.encode(msg.sender, msg.sender, address(0), itemId(), amount));\r\n        emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n\r\n    function burnFrom(address account, uint256 amount) external override {\r\n        require(account != address(0), \"burn zero address\");\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(false, abi.encode(msg.sender, account, address(0), itemId(), amount));\r\n        emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n\r\n    function name() override external view returns (string memory) {\r\n        (, Header memory header,,) = IItemMainInterface(mainInterface).item(itemId());\r\n        return header.name;\r\n    }\r\n\r\n    function symbol() override external view returns (string memory) {\r\n        (, Header memory header,,) = IItemMainInterface(mainInterface).item(itemId());\r\n        return header.symbol;\r\n    }\r\n\r\n    function decimals() override external pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function nonces(address owner) external override view returns(uint256) {\r\n        return IItemMainInterface(mainInterface).nonces(owner, itemId());\r\n    }\r\n\r\n    function totalSupply() override external view returns (uint256 totalSupplyValue) {\r\n        (,,, totalSupplyValue) = IItemMainInterface(mainInterface).item(itemId());\r\n    }\r\n\r\n    function balanceOf(address account) override external view returns (uint256) {\r\n        return IItemMainInterface(mainInterface).balanceOf(account, itemId());\r\n    }\r\n\r\n    function allowance(address owner, address spender) override external view returns (uint256) {\r\n        return IItemMainInterface(mainInterface).allowance(owner, spender, itemId());\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) override external returns(bool) {\r\n        IItemMainInterface(mainInterface).approve(msg.sender, spender, amount, itemId());\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) override external returns(bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) override external returns(bool) {\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) private returns(bool) {\r\n        require(sender != address(0), \"transfer from the zero address\");\r\n        require(recipient != address(0), \"transfer to the zero address\");\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(false, abi.encode(msg.sender, sender, recipient, itemId(), amount));\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"domainSeparatorValue\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"forApprove\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMulti\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"emitEvent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"itemId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainInterface\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupplyValue\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ItemInteroperableInterface", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d922c58b49c28044de048f0b8eb389b2db7621d53a1817ef78aab29398263280"}