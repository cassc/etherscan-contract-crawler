{"SourceCode": "// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n// File: contracts/shadow.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract ShadowStorage {\r\n    struct tokenDetail{\r\n        address nftAddress; //nft address\r\n        uint256 tokenId;    //tokenId\r\n        bool status;        //status \r\n    }\r\n\r\n    mapping (address=> mapping(uint256=>uint256)) private shadows;  //NFT => Id => shadowId\r\n    mapping (uint256=>tokenDetail) public shadowDetails;            //shadowId => tokenDetails\r\n\r\n    function getShadowId(address nft, uint256 tokenId) public view returns(uint256) {\r\n        return shadows[nft][tokenId];\r\n    }\r\n\r\n    function isExistShadow(address nft, uint256 tokenId) public view returns(bool) {\r\n        return shadows[nft][tokenId] != 0;\r\n    }\r\n\r\n    function isActiveShadow(uint256 shadowId) public view returns(bool) {\r\n        return shadowDetails[shadowId].status;\r\n    }\r\n\r\n    function _newShadow(address nft, uint256 tokenId, uint256 shadowId) internal {\r\n        shadows[nft][tokenId] = shadowId;\r\n        shadowDetails[shadowId] = tokenDetail(nft, tokenId, true);\r\n    }  \r\n\r\n    function _updataShadow(uint256 tokenId, bool status) internal{\r\n        shadowDetails[tokenId].status = status;\r\n    }\r\n}\r\n\r\ninterface IERC721Metadata{\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\ncontract Shadow is ShadowStorage, IERC721{\r\n    //ERC721 metadata\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public totalsupply;\r\n\r\n    mapping(uint256 => address) private _owners;\r\n    mapping(address => uint256) private _balances;\r\n\r\n    function setShadow(string memory _name, string memory _symbol) internal {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view override returns(address owner){\r\n        return _owners[tokenId];\r\n    }\r\n\r\n    function balanceOf(address owner) public view override returns(uint256 balance){\r\n        return _balances[owner];\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view returns (string memory){\r\n        tokenDetail memory s = shadowDetails[tokenId];\r\n        return IERC721Metadata(s.nftAddress).tokenURI(s.tokenId);\r\n    }\r\n    \r\n    function _mint(address to) private returns(uint256 tokenId) {\r\n        totalsupply++;\r\n        tokenId = totalsupply;\r\n    \r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _revive(address to, uint256 tokenId) private {\r\n        require(totalsupply >= tokenId,\"Shadow: unexist tokenId\");\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n   \r\n    function mint(address to, address nft, uint256 tokenId) internal {\r\n        require(to != address(0), \"Shadow: zero address\");\r\n        uint256 sid;\r\n        if (isExistShadow(nft, tokenId)){  \r\n            sid = getShadowId(nft, tokenId);\r\n            _revive(to, sid);\r\n            _updataShadow(sid, true);\r\n        }else {\r\n            sid = _mint(to);   \r\n            _newShadow(nft, tokenId, sid);\r\n        }\r\n    }\r\n\r\n    function burn(uint256 tokenId) internal {\r\n        address owner = ownerOf(tokenId);\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n        _updataShadow(tokenId, false);\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    //---virtuel function for ERC721 \r\n    function approve(address to, uint256 tokenId) external override{}\r\n    function transferFrom(address from, address to, uint256 tokenId) external override{}\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external override{}\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external override{}\r\n    function setApprovalForAll(address operator, bool approved) external override{}\r\n    function getApproved(uint256 tokenId) external view override returns (address){}\r\n    function isApprovedForAll(address owner, address operator) external view override returns (bool) {}\r\n    function supportsInterface(bytes4 interfaceId) external view override returns (bool){}\r\n}\r\n\r\n// File: contracts/factory.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ninterface Ilink {\r\n    function initialize(address _factory, address _nft, address _userA, address _userB, uint256 _idA, uint256 _idB, uint256 _lockDays) external;\r\n    function userB() external returns(address);\r\n    function idB() external returns(uint256);\r\n    function NFT() external returns(address);\r\n    function agree() external;\r\n}\r\n\r\ncontract Ownable{\r\n    address public owner;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner) external onlyOwner{\r\n        require(_owner != address(0), \"owner address cannot be 0\");\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\ncontract Initialize {\r\n    bool internal initialized;\r\n    modifier noInit(){\r\n        require(!initialized, \"initialized\");\r\n        _;\r\n        initialized = true;\r\n    }\r\n}\r\n\r\ncontract Config is Ownable{\r\n    uint256 public minLockDay;\r\n    uint256 public maxLockDay;\r\n    address public nftLink;\r\n    mapping(address => bool) public allowedNFT;\r\n    mapping(address => bool) public shadowNeed;\r\n    mapping(address => bool) public isLink;\r\n    uint256 public totalLink;\r\n\r\n    function setNftLink(address link) external onlyOwner {\r\n        require(link != address(0), \"link address cannot be 0\");\r\n        nftLink = link;\r\n    }\r\n\r\n    function setLockDay(uint256 min, uint256 max) external onlyOwner {\r\n        (minLockDay, maxLockDay) = (min, max);\r\n    }\r\n\r\n    function addProject(address nft, bool isNeedShadow) external onlyOwner {\r\n        require(nft != address(0), \"nft address cannot be 0\");\r\n        allowedNFT[nft] = true;\r\n        shadowNeed[nft] = isNeedShadow;\r\n    }\r\n\r\n    function removeProject(address nft) external onlyOwner {\r\n        delete allowedNFT[nft];\r\n        delete shadowNeed[nft];\r\n    }\r\n}\r\n\r\ncontract CloneFactory {\r\n    function _clone(address target) internal returns (address result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n}\r\n\r\ncontract FactoryV2 is Ownable, Config, Initialize, CloneFactory, Shadow {\r\n    event Create(address indexed from, address indexed target, address indexed nft, address link, bool isFullLink);\r\n    event LinkActive(address _link, address _user, uint256 _methodId);\r\n\r\n    modifier onlyLink(){\r\n        require(isLink[msg.sender], \"only Link\");\r\n        _;\r\n    } \r\n\r\n    function initialize(address link) noInit public {\r\n        (minLockDay, maxLockDay) = (1, 1285);\r\n        setShadow(\"ATM-SHADOW\", \"ATS\");\r\n        nftLink = link;\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function getToken(address nft, address user, uint256 id) onlyLink external {\r\n         IERC721(nft).transferFrom(user, msg.sender, id);\r\n    }\r\n\r\n    function mintShadow(address to, address nft, uint256 tokenId) onlyLink external {\r\n        mint(to, nft, tokenId);\r\n    }\r\n\r\n    function burnShadow(address nft, uint256 tokenId) onlyLink external {\r\n        uint256 sid = getShadowId(nft, tokenId);\r\n        burn(sid);\r\n    }\r\n\r\n    function createLink(address nft, address target, uint256[] calldata tokenId, uint256 lockDays) external{\r\n        require(target != address(0),\"target cannot be 0\");\r\n        require(target != msg.sender,\"target cannot be self\");\r\n        require(allowedNFT[nft], \"nft invalid\");\r\n        require(lockDays >= minLockDay && lockDays <= maxLockDay, \"lockDays invalid\");\r\n        require(tokenId.length == 1 || tokenId.length == 2, \"tokenId invalid\");\r\n        bool isFullLink = tokenId.length == 2;\r\n        IERC721 NFT = IERC721(nft);\r\n        if (isFullLink){\r\n            //fullLink\r\n            require(tokenId[0] != 0 && tokenId[1] != 0, \"tokenId invalid\");\r\n            require(tokenId[0] != tokenId[1], \"tokenId cannot be the same\");\r\n            require(NFT.ownerOf(tokenId[0]) == msg.sender && NFT.ownerOf(tokenId[1]) == msg.sender,\"not token owner\");\r\n            require(NFT.isApprovedForAll(msg.sender, address(this)) || (NFT.getApproved(tokenId[0]) == address(this) && NFT.getApproved(tokenId[1]) == address(this)),\"not Approved\");\r\n        }else{\r\n            //normalLink\r\n            require(tokenId[0] != 0, \"tokenId invalid\");\r\n            require(NFT.ownerOf(tokenId[0]) == msg.sender,\"not token owner\");\r\n            require(NFT.isApprovedForAll(msg.sender, address(this)) || NFT.getApproved(tokenId[0]) == address(this),\"not Approved\");\r\n        }\r\n\r\n        //create contract\r\n        Ilink link = Ilink(_clone(nftLink));\r\n        totalLink++;\r\n        isLink[address(link)] = true;\r\n        uint256 idB = isFullLink ? tokenId[1] : 0;\r\n\r\n        //transfer token   \r\n        NFT.transferFrom(msg.sender, address(link), tokenId[0]);\r\n        if (isFullLink) {\r\n            NFT.transferFrom(msg.sender, address(link), tokenId[1]);\r\n        }\r\n\r\n        //create shadowNFT\r\n        if (shadowNeed[nft]){\r\n            mint(msg.sender, nft, tokenId[0]);\r\n            if (isFullLink) {\r\n                mint(msg.sender, nft, tokenId[1]);\r\n            }\r\n        }\r\n\r\n        //set link info\r\n        link.initialize(address(this), nft, msg.sender, target, tokenId[0], idB, lockDays);\r\n        emit Create(msg.sender, target, nft, address(link), isFullLink);\r\n    }\r\n\r\n    function linkActive(address _user, uint256 _methodId) external{\r\n        require(isLink[msg.sender], \"Factory: only Link\");\r\n        emit LinkActive(msg.sender, _user, _methodId);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"link\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isFullLink\",\"type\":\"bool\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_methodId\",\"type\":\"uint256\"}],\"name\":\"LinkActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isNeedShadow\",\"type\":\"bool\"}],\"name\":\"addProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burnShadow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lockDays\",\"type\":\"uint256\"}],\"name\":\"createLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getShadowId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"link\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shadowId\",\"type\":\"uint256\"}],\"name\":\"isActiveShadow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isExistShadow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLink\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_methodId\",\"type\":\"uint256\"}],\"name\":\"linkActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLockDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minLockDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mintShadow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftLink\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"removeProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setLockDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"link\",\"type\":\"address\"}],\"name\":\"setNftLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shadowDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shadowNeed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLink\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalsupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FactoryV2", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c70b1efb883ee35f4630e491e20648083f3a2e4072fcb6ee0c9eeec605cea378"}