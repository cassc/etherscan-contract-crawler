{"SourceCode": "pragma solidity =0.8.0;\r\n\r\n// SPDX-License-Identifier: SimPL-2.0\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns(bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns(uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns(address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns(address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns(bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface IERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string memory);\r\n    \r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string memory);\r\n    \r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    /// {\"name\":\"\",\"description\":\"\",\"image\":\"\"}\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);\r\n}\r\n\r\ninterface IERC721TokenReceiverEx is IERC721TokenReceiver {\r\n    // bytes4(keccak256(\"onERC721ExReceived(address,address,uint256[],bytes)\")) = 0x0f7b88e3\r\n    function onERC721ExReceived(address operator, address from,\r\n        uint256[] memory tokenIds, bytes memory data)\r\n        external returns(bytes4);\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns(bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\nlibrary Bytes {\r\n    bytes internal constant BASE64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\r\n    \r\n    function base64Encode(bytes memory bs) internal pure returns(string memory) {\r\n        uint256 remain = bs.length % 3;\r\n        uint256 length = bs.length / 3 * 4;\r\n        bytes memory result = new bytes(length + (remain != 0 ? 4 : 0) + (3 - remain) % 3);\r\n        \r\n        uint256 i = 0;\r\n        uint256 j = 0;\r\n        while (i < length) {\r\n            result[i++] = BASE64_CHARS[uint8(bs[j] >> 2)];\r\n            result[i++] = BASE64_CHARS[uint8((bs[j] & 0x03) << 4 | bs[j + 1] >> 4)];\r\n            result[i++] = BASE64_CHARS[uint8((bs[j + 1] & 0x0f) << 2 | bs[j + 2] >> 6)];\r\n            result[i++] = BASE64_CHARS[uint8(bs[j + 2] & 0x3f)];\r\n            \r\n            j += 3;\r\n        }\r\n        \r\n        if (remain != 0) {\r\n            result[i++] = BASE64_CHARS[uint8(bs[j] >> 2)];\r\n            \r\n            if (remain == 2) {\r\n                result[i++] = BASE64_CHARS[uint8((bs[j] & 0x03) << 4 | bs[j + 1] >> 4)];\r\n                result[i++] = BASE64_CHARS[uint8((bs[j + 1] & 0x0f) << 2)];\r\n                result[i++] = BASE64_CHARS[0];\r\n                result[i++] = 0x3d;\r\n            } else {\r\n                result[i++] = BASE64_CHARS[uint8((bs[j] & 0x03) << 4)];\r\n                result[i++] = BASE64_CHARS[0];\r\n                result[i++] = BASE64_CHARS[0];\r\n                result[i++] = 0x3d;\r\n                result[i++] = 0x3d;\r\n            }\r\n        }\r\n        \r\n        return string(result);\r\n    }\r\n    \r\n    function concat(bytes memory a, bytes memory b)\r\n        internal pure returns(bytes memory) {\r\n        \r\n        uint256 al = a.length;\r\n        uint256 bl = b.length;\r\n        \r\n        bytes memory c = new bytes(al + bl);\r\n        \r\n        for (uint256 i = 0; i < al; ++i) {\r\n            c[i] = a[i];\r\n        }\r\n        \r\n        for (uint256 i = 0; i < bl; ++i) {\r\n            c[al + i] = b[i];\r\n        }\r\n        \r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary String {\r\n    function equals(string memory a, string memory b)\r\n        internal pure returns(bool) {\r\n        \r\n        bytes memory ba = bytes(a);\r\n        bytes memory bb = bytes(b);\r\n        \r\n        uint256 la = ba.length;\r\n        uint256 lb = bb.length;\r\n        \r\n        for (uint256 i = 0; i < la && i < lb; ++i) {\r\n            if (ba[i] != bb[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return la == lb;\r\n    }\r\n    \r\n    function concat(string memory a, string memory b)\r\n        internal pure returns(string memory) {\r\n        \r\n        bytes memory ba = bytes(a);\r\n        bytes memory bb = bytes(b);\r\n        bytes memory bc = new bytes(ba.length + bb.length);\r\n        \r\n        uint256 bal = ba.length;\r\n        uint256 bbl = bb.length;\r\n        uint256 k = 0;\r\n        \r\n        for (uint256 i = 0; i < bal; ++i) {\r\n            bc[k++] = ba[i];\r\n        }\r\n        \r\n        for (uint256 i = 0; i < bbl; ++i) {\r\n            bc[k++] = bb[i];\r\n        }\r\n        \r\n        return string(bc);\r\n    }\r\n}\r\n\r\nlibrary UInteger {\r\n    function toString(uint256 a, uint256 radix)\r\n        internal pure returns(string memory) {\r\n        \r\n        if (a == 0) {\r\n            return \"0\";\r\n        }\r\n        \r\n        uint256 length = 0;\r\n        for (uint256 n = a; n != 0; n /= radix) {\r\n            ++length;\r\n        }\r\n        \r\n        bytes memory bs = new bytes(length);\r\n        \r\n        while (a != 0) {\r\n            uint256 b = a % radix;\r\n            a /= radix;\r\n            \r\n            if (b < 10) {\r\n                bs[--length] = bytes1(uint8(b + 48));\r\n            } else {\r\n                bs[--length] = bytes1(uint8(b + 87));\r\n            }\r\n        }\r\n        \r\n        return string(bs);\r\n    }\r\n    \r\n    function toString(uint256 a) internal pure returns(string memory) {\r\n        return UInteger.toString(a, 10);\r\n    }\r\n    \r\n    function max(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n    \r\n    function min(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n    \r\n    function shiftLeft(uint256 n, uint256 bits, uint256 shift)\r\n        internal pure returns(uint256) {\r\n        \r\n        require(n < (1 << bits), \"shiftLeft overflow\");\r\n        \r\n        return n << shift;\r\n    }\r\n    \r\n    function toDecBytes(uint256 n) internal pure returns(bytes memory) {\r\n        if (n == 0) {\r\n            return bytes(\"0\");\r\n        }\r\n        \r\n        uint256 length = 0;\r\n        for (uint256 m = n; m > 0; m /= 10) {\r\n            ++length;\r\n        }\r\n        \r\n        bytes memory bs = new bytes(length);\r\n        \r\n        while (n > 0) {\r\n            uint256 m = n % 10;\r\n            n /= 10;\r\n            \r\n            bs[--length] = bytes1(uint8(m + 48));\r\n        }\r\n        \r\n        return bs;\r\n    }\r\n}\r\n\r\nlibrary Util {\r\n    bytes4 internal constant ERC721_RECEIVER_RETURN = 0x150b7a02;\r\n    bytes4 internal constant ERC721_RECEIVER_EX_RETURN = 0x0f7b88e3;\r\n}\r\n\r\nabstract contract ContractOwner {\r\n    address immutable public contractOwner = msg.sender;\r\n    \r\n    modifier onlyContractOwner {\r\n        require(msg.sender == contractOwner, \"only contract owner\");\r\n        _;\r\n    }\r\n}\r\n\r\nabstract contract ERC721 is IERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    \r\n    /*\r\n     * bytes4(keccak256(\"supportsInterface(bytes4)\")) == 0x01ffc9a7\r\n     */\r\n    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    \r\n    /*\r\n     *     bytes4(keccak256(\"balanceOf(address)\")) == 0x70a08231\r\n     *     bytes4(keccak256(\"ownerOf(uint256)\")) == 0x6352211e\r\n     *     bytes4(keccak256(\"approve(address,uint256)\")) == 0x095ea7b3\r\n     *     bytes4(keccak256(\"getApproved(uint256)\")) == 0x081812fc\r\n     *     bytes4(keccak256(\"setApprovalForAll(address,bool)\")) == 0xa22cb465\r\n     *     bytes4(keccak256(\"isApprovedForAll(address,address)\")) == 0xe985e9c5\r\n     *     bytes4(keccak256(\"transferFrom(address,address,uint256)\")) == 0x23b872dd\r\n     *     bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\")) == 0x42842e0e\r\n     *     bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    \r\n    bytes4 private constant INTERFACE_ID_ERC721Metadata = 0x5b5e139f;\r\n    \r\n    string public override name;\r\n    string public override symbol;\r\n    \r\n    mapping(address => uint256[]) internal ownerTokens;\r\n    mapping(uint256 => uint256) internal tokenIndexs;\r\n    mapping(uint256 => address) internal tokenOwners;\r\n    \r\n    mapping(uint256 => address) internal tokenApprovals;\r\n    mapping(address => mapping(address => bool)) internal approvalForAlls;\r\n    \r\n    constructor(string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n    \r\n    function balanceOf(address owner) external view override returns(uint256) {\r\n        require(owner != address(0), \"owner is zero address\");\r\n        return ownerTokens[owner].length;\r\n    }\r\n    \r\n    // [startIndex, endIndex)\r\n    function tokensOf(address owner, uint256 startIndex, uint256 endIndex)\r\n        external view returns(uint256[] memory) {\r\n        \r\n        require(owner != address(0), \"owner is zero address\");\r\n        \r\n        uint256[] storage tokens = ownerTokens[owner];\r\n        if (endIndex == 0) {\r\n            endIndex = tokens.length;\r\n        }\r\n        \r\n        uint256[] memory result = new uint256[](endIndex - startIndex);\r\n        for (uint256 i = startIndex; i < endIndex; ++i) {\r\n            result[i - startIndex] = tokens[i];\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    function ownerOf(uint256 tokenId)\r\n        external view override returns(address) {\r\n        \r\n        address owner = tokenOwners[tokenId];\r\n        require(owner != address(0), \"nobody own the token\");\r\n        return owner;\r\n    }\r\n    \r\n    function safeTransferFrom(address from, address to, uint256 tokenId)\r\n            external payable override {\r\n        \r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n    \r\n    function safeTransferFrom(address from, address to, uint256 tokenId,\r\n        bytes memory data) public payable override {\r\n        \r\n        _transferFrom(from, to, tokenId);\r\n        \r\n        if (to.isContract()) {\r\n            require(IERC721TokenReceiver(to)\r\n                .onERC721Received(msg.sender, from, tokenId, data)\r\n                == Util.ERC721_RECEIVER_RETURN,\r\n                \"onERC721Received() return invalid\");\r\n        }\r\n    }\r\n    \r\n    function transferFrom(address from, address to, uint256 tokenId)\r\n        external payable override {\r\n        \r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n    \r\n    function _transferFrom(address from, address to, uint256 tokenId)\r\n        internal {\r\n        \r\n        require(from != address(0), \"from is zero address\");\r\n        require(to != address(0), \"to is zero address\");\r\n        \r\n        require(from == tokenOwners[tokenId], \"from must be owner\");\r\n        \r\n        require(msg.sender == from\r\n            || msg.sender == tokenApprovals[tokenId]\r\n            || approvalForAlls[from][msg.sender],\r\n            \"sender must be owner or approvaled\");\r\n        \r\n        if (tokenApprovals[tokenId] != address(0)) {\r\n            delete tokenApprovals[tokenId];\r\n        }\r\n        \r\n        _removeTokenFrom(from, tokenId);\r\n        _addTokenTo(to, tokenId);\r\n        \r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n    \r\n    // ensure everything is ok before call it\r\n    function _removeTokenFrom(address from, uint256 tokenId) internal {\r\n        uint256 index = tokenIndexs[tokenId];\r\n        \r\n        uint256[] storage tokens = ownerTokens[from];\r\n        uint256 indexLast = tokens.length - 1;\r\n        \r\n        // save gas\r\n        // if (index != indexLast) {\r\n            uint256 tokenIdLast = tokens[indexLast];\r\n            tokens[index] = tokenIdLast;\r\n            tokenIndexs[tokenIdLast] = index;\r\n        // }\r\n        \r\n        tokens.pop();\r\n        \r\n        // delete tokenIndexs[tokenId]; // save gas\r\n        delete tokenOwners[tokenId];\r\n    }\r\n    \r\n    // ensure everything is ok before call it\r\n    function _addTokenTo(address to, uint256 tokenId) internal {\r\n        uint256[] storage tokens = ownerTokens[to];\r\n        tokenIndexs[tokenId] = tokens.length;\r\n        tokens.push(tokenId);\r\n        \r\n        tokenOwners[tokenId] = to;\r\n    }\r\n    \r\n    function approve(address to, uint256 tokenId)\r\n        external payable override {\r\n        \r\n        address owner = tokenOwners[tokenId];\r\n        \r\n        require(msg.sender == owner\r\n            || approvalForAlls[owner][msg.sender],\r\n            \"sender must be owner or approved for all\"\r\n        );\r\n        \r\n        tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n    \r\n    function setApprovalForAll(address to, bool approved) external override {\r\n        approvalForAlls[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n    \r\n    function getApproved(uint256 tokenId)\r\n        external view override returns(address) {\r\n        \r\n        require(tokenOwners[tokenId] != address(0),\r\n            \"nobody own then token\");\r\n        \r\n        return tokenApprovals[tokenId];\r\n    }\r\n    \r\n    function isApprovedForAll(address owner, address operator)\r\n        external view override returns(bool) {\r\n        \r\n        return approvalForAlls[owner][operator];\r\n    }\r\n    \r\n    function supportsInterface(bytes4 interfaceID)\r\n        external pure override returns(bool) {\r\n        \r\n        return interfaceID == INTERFACE_ID_ERC165\r\n            || interfaceID == INTERFACE_ID_ERC721\r\n            || interfaceID == INTERFACE_ID_ERC721Metadata;\r\n    }\r\n}\r\n\r\nabstract contract ERC721Ex is ERC721 {\r\n    using Address for address;\r\n    using String for string;\r\n    using UInteger for uint256;\r\n    \r\n    uint256 public totalSupply = 0;\r\n    \r\n    string public uriPrefix;\r\n    \r\n    function _mint(address to, uint256 tokenId) internal {\r\n        _addTokenTo(to, tokenId);\r\n        \r\n        ++totalSupply;\r\n        \r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n    \r\n    function _burn(uint256 tokenId) internal {\r\n        address owner = tokenOwners[tokenId];\r\n        _removeTokenFrom(owner, tokenId);\r\n        \r\n        if (tokenApprovals[tokenId] != address(0)) {\r\n            delete tokenApprovals[tokenId];\r\n        }\r\n        \r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n    \r\n    function safeBatchTransferFrom(address from, address to,\r\n        uint256[] memory tokenIds) external {\r\n        \r\n        safeBatchTransferFrom(from, to, tokenIds, \"\");\r\n    }\r\n    \r\n    function safeBatchTransferFrom(address from, address to,\r\n        uint256[] memory tokenIds, bytes memory data) public {\r\n        \r\n        batchTransferFrom(from, to, tokenIds);\r\n        \r\n        if (to.isContract()) {\r\n            require(IERC721TokenReceiverEx(to)\r\n                .onERC721ExReceived(msg.sender, from, tokenIds, data)\r\n                == Util.ERC721_RECEIVER_EX_RETURN,\r\n                \"onERC721ExReceived() return invalid\");\r\n        }\r\n    }\r\n    \r\n    function batchTransferFrom(address from, address to,\r\n        uint256[] memory tokenIds) public {\r\n        \r\n        require(from != address(0), \"from is zero address\");\r\n        require(to != address(0), \"to is zero address\");\r\n        \r\n        address sender = msg.sender;\r\n        bool approval = from == sender || approvalForAlls[from][sender];\r\n        \r\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\r\n            uint256 tokenId = tokenIds[i];\r\n\t\t\t\r\n            require(from == tokenOwners[tokenId], \"from must be owner\");\r\n            require(approval || sender == tokenApprovals[tokenId],\r\n                \"sender must be owner or approvaled\");\r\n            \r\n            if (tokenApprovals[tokenId] != address(0)) {\r\n                delete tokenApprovals[tokenId];\r\n            }\r\n            \r\n            _removeTokenFrom(from, tokenId);\r\n            _addTokenTo(to, tokenId);\r\n            \r\n            emit Transfer(from, to, tokenId);\r\n        }\r\n    }\r\n    \r\n    function tokenURI(uint256 cardId)\r\n        external view override returns(string memory) {\r\n        \r\n        return uriPrefix.concat(cardId.toString());\r\n    }\r\n}\r\n\r\ncontract Card is ERC721Ex, ContractOwner {\r\n    mapping(address => bool) public whiteList;\r\n    \r\n    constructor(string memory _name, string memory _symbol)\r\n        ERC721(_name, _symbol) {\r\n    }\r\n    \r\n    function setUriPrefix(string memory prefix) external onlyContractOwner {\r\n        uriPrefix = prefix;\r\n    }\r\n    \r\n    function setWhiteList(address account, bool enable) external onlyContractOwner {\r\n        whiteList[account] = enable;\r\n    }\r\n    \r\n    function mint(address to) external {\r\n        require(whiteList[msg.sender], \"not in whiteList\");\r\n        \r\n        _mint(to, totalSupply + 1);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"prefix\",\"type\":\"string\"}],\"name\":\"setUriPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"name\":\"tokensOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Card", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000114d79746856657273652047656e6573697300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044d59544800000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "BSD-2-Clause", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://77922ea72002267b7b6c937dab266ab778df98abaf8e8cfda4181b97c23ac0d6"}