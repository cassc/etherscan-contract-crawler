{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/handlers/PermissionlessGenericHandler.sol\": {\r\n      \"content\": \"// The Licensed Work is (c) 2022 Sygma\\n// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.11;\\n\\nimport \\\"../interfaces/IHandler.sol\\\";\\n\\n/**\\n    @title Handles generic deposits and deposit executions.\\n    @author ChainSafe Systems.\\n    @notice This contract is intended to be used with the Bridge contract.\\n */\\ncontract PermissionlessGenericHandler is IHandler {\\n    uint256 public constant MAX_FEE = 1000000;\\n\\n    address public immutable _bridgeAddress;\\n\\n    modifier onlyBridge() {\\n        _onlyBridge();\\n        _;\\n    }\\n\\n    function _onlyBridge() private view {\\n        require(msg.sender == _bridgeAddress, \\\"sender must be bridge contract\\\");\\n    }\\n\\n    /**\\n        @param bridgeAddress Contract address of previously deployed Bridge.\\n     */\\n    constructor(\\n        address          bridgeAddress\\n    ) {\\n        _bridgeAddress = bridgeAddress;\\n    }\\n\\n    /**\\n        @notice Blank function, required in IHandler.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\\n        @param args Additional data to be passed to specified handler.\\n     */\\n    function setResource(\\n        bytes32 resourceID,\\n        address contractAddress,\\n        bytes calldata args\\n    ) external onlyBridge {}\\n\\n    /**\\n        @notice A deposit is initiated by making a deposit in the Bridge contract.\\n        @param resourceID ResourceID used to find address of contract to be used for deposit.\\n        @param depositor Address of the account making deposit in the Bridge contract.\\n        @param data Structure should be constructed as follows:\\n          maxFee:                       uint256  bytes  0                                                                                           -  32\\n          len(executeFuncSignature):    uint16   bytes  32                                                                                          -  34\\n          executeFuncSignature:         bytes    bytes  34                                                                                          -  34 + len(executeFuncSignature)\\n          len(executeContractAddress):  uint8    bytes  34 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature)\\n          executeContractAddress        bytes    bytes  35 + len(executeFuncSignature)                                                              -  35 + len(executeFuncSignature) + len(executeContractAddress)\\n          len(executionDataDepositor):  uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress)\\n          executionDataDepositor:       bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)\\n          executionData:                bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END\\n\\n          executionData is repacked together with executionDataDepositor address for using it in the target contract.\\n          If executionData contains dynamic types then it is necessary to keep the offsets correct.\\n          executionData should be encoded together with a 32-byte address and then passed as a parameter without that address.\\n          If the target function accepts (address depositor, bytes executionData)\\n          then a function like the following one can be used:\\n\\n            function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) {\\n                bytes memory encoded = abi.encode(address(0), executionData);\\n                return this.slice(encoded, 32);\\n            }\\n\\n            function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) {\\n                return input[position:];\\n            }\\n          After this, the target contract will get the following:\\n          executeFuncSignature(address executionDataDepositor, bytes executionData)\\n\\n          Another example: if the target function accepts (address depositor, uint[], address)\\n          then a function like the following one can be used:\\n\\n            function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) {\\n                bytes memory encoded = abi.encode(address(0), uintArray, addr);\\n                return this.slice(encoded, 32);\\n            }\\n\\n          After this, the target contract will get the following:\\n          executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)\\n     */\\n    function deposit(bytes32 resourceID, address depositor, bytes calldata data) external view returns (bytes memory) {\\n        require(data.length >= 76, \\\"Incorrect data length\\\"); // 32 + 2 + 1 + 1 + 20 + 20\\n\\n        uint256        maxFee;\\n        uint16         lenExecuteFuncSignature;\\n        uint8          lenExecuteContractAddress;\\n        uint8          lenExecutionDataDepositor;\\n        address        executionDataDepositor;\\n\\n        maxFee                            = uint256(bytes32(data[:32]));\\n        lenExecuteFuncSignature           = uint16(bytes2(data[32:34]));\\n        lenExecuteContractAddress         = uint8(bytes1(data[34 + lenExecuteFuncSignature:35 + lenExecuteFuncSignature]));\\n        lenExecutionDataDepositor         = uint8(bytes1(data[35 + lenExecuteFuncSignature + lenExecuteContractAddress:36 + lenExecuteFuncSignature + lenExecuteContractAddress]));\\n        executionDataDepositor            = address(uint160(bytes20(data[36 + lenExecuteFuncSignature + lenExecuteContractAddress:36 + lenExecuteFuncSignature + lenExecuteContractAddress + lenExecutionDataDepositor])));\\n\\n        require(maxFee < MAX_FEE, 'requested fee too large');\\n        require(depositor == executionDataDepositor, 'incorrect depositor in deposit data');\\n    }\\n\\n    /**\\n        @notice Proposal execution should be initiated when a proposal is finalized in the Bridge contract.\\n        @param resourceID ResourceID used to find address of contract to be used for deposit.\\n        @param data Structure should be constructed as follows:\\n          maxFee:                             uint256  bytes  0                                                             -  32\\n          len(executeFuncSignature):          uint16   bytes  32                                                            -  34\\n          executeFuncSignature:               bytes    bytes  34                                                            -  34 + len(executeFuncSignature)\\n          len(executeContractAddress):        uint8    bytes  34 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature)\\n          executeContractAddress              bytes    bytes  35 + len(executeFuncSignature)                                -  35 + len(executeFuncSignature) + len(executeContractAddress)\\n          len(executionDataDepositor):        uint8    bytes  35 + len(executeFuncSignature) + len(executeContractAddress)  -  36 + len(executeFuncSignature) + len(executeContractAddress)\\n          executionDataDepositor:             bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress)                                -  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)\\n          executionData:                      bytes    bytes  36 + len(executeFuncSignature) + len(executeContractAddress) + len(executionDataDepositor)  -  END\\n\\n          executionData is repacked together with executionDataDepositor address for using it in the target contract.\\n          If executionData contains dynamic types then it is necessary to keep the offsets correct.\\n          executionData should be encoded together with a 32-byte address and then passed as a parameter without that address.\\n          If the target function accepts (address depositor, bytes executionData)\\n          then a function like the following one can be used:\\n\\n            function prepareDepositData(bytes calldata executionData) view external returns (bytes memory) {\\n                bytes memory encoded = abi.encode(address(0), executionData);\\n                return this.slice(encoded, 32);\\n            }\\n\\n            function slice(bytes calldata input, uint256 position) pure public returns (bytes memory) {\\n                return input[position:];\\n            }\\n\\n          After this, the target contract will get the following:\\n          executeFuncSignature(address executionDataDepositor, bytes executionData)\\n\\n          Another example: if the target function accepts (address depositor, uint[], address)\\n          then a function like the following one can be used:\\n\\n            function prepareDepositData(uint[] calldata uintArray, address addr) view external returns (bytes memory) {\\n                bytes memory encoded = abi.encode(address(0), uintArray, addr);\\n                return this.slice(encoded, 32);\\n            }\\n\\n          After this, the target contract will get the following:\\n          executeFuncSignature(address executionDataDepositor, uint[] uintArray, address addr)\\n     */\\n    function executeProposal(bytes32 resourceID, bytes calldata data) external onlyBridge returns (bytes memory) {\\n        uint256        maxFee;\\n        uint16         lenExecuteFuncSignature;\\n        bytes4         executeFuncSignature;\\n        uint8          lenExecuteContractAddress;\\n        address        executeContractAddress;\\n        uint8          lenExecutionDataDepositor;\\n        address        executionDataDepositor;\\n        bytes   memory executionData;\\n\\n        maxFee                            = uint256(bytes32(data[0:32]));\\n        lenExecuteFuncSignature           = uint16(bytes2(data[32:34]));\\n        executeFuncSignature              = bytes4(data[34:34 + lenExecuteFuncSignature]);\\n        lenExecuteContractAddress         = uint8(bytes1(data[34 + lenExecuteFuncSignature:35 + lenExecuteFuncSignature]));\\n        executeContractAddress            = address(uint160(bytes20(data[35 + lenExecuteFuncSignature:35 + lenExecuteFuncSignature + lenExecuteContractAddress])));\\n        lenExecutionDataDepositor         = uint8(bytes1(data[35 + lenExecuteFuncSignature + lenExecuteContractAddress:36 + lenExecuteFuncSignature + lenExecuteContractAddress]));\\n        executionDataDepositor            = address(uint160(bytes20(data[36 + lenExecuteFuncSignature + lenExecuteContractAddress:36 + lenExecuteFuncSignature + lenExecuteContractAddress + lenExecutionDataDepositor])));\\n        executionData                     = bytes(data[36 + lenExecuteFuncSignature + lenExecuteContractAddress + lenExecutionDataDepositor:]);\\n\\n        bytes memory callData = abi.encodePacked(executeFuncSignature, abi.encode(executionDataDepositor), executionData);\\n        (bool success, bytes memory returndata) = executeContractAddress.call{gas: maxFee}(callData);\\n        return abi.encode(success, returndata);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHandler.sol\": {\r\n      \"content\": \"// The Licensed Work is (c) 2022 Sygma\\n// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.11;\\n\\n/**\\n    @title Interface for handler that handles generic deposits and deposit executions.\\n    @author ChainSafe Systems.\\n */\\ninterface IHandler {\\n    /**\\n        @notice It is intended that deposit are made using the Bridge contract.\\n        @param resourceID ResourceID used to find address of handler to be used for deposit.\\n        @param depositor Address of account making the deposit in the Bridge contract.\\n        @param data Consists of additional data needed for a specific deposit.\\n     */\\n    function deposit(bytes32 resourceID, address depositor, bytes calldata data) external returns (bytes memory);\\n\\n    /**\\n        @notice It is intended that proposals are executed by the Bridge contract.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param data Consists of additional data needed for a specific deposit execution.\\n     */\\n    function executeProposal(bytes32 resourceID, bytes calldata data) external returns (bytes memory);\\n\\n    /**\\n        @notice Correlates {_resourceIDToContractAddress} with {contractAddress}, {_tokenContractAddressToTokenProperties[tokenAddress].resourceID} with {resourceID} and marks\\n        {_tokenContractAddressToTokenProperties[tokenAddress].isWhitelisted} to true for {contractAddress} in ERCHandlerHelpers contract.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\\n        @param args Additional data to be passed to specified handler.\\n     */\\n    function setResource(bytes32 resourceID, address contractAddress, bytes calldata args) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridgeAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_bridgeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"args\",\"type\":\"bytes\"}],\"name\":\"setResource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PermissionlessGenericHandler", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000004d878e8fb90178588cda4cf1dccdc9a6d2757089", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}