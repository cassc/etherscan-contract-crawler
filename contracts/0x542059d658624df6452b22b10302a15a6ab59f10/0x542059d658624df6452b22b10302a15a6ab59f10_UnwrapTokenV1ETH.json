{"SourceCode": "pragma solidity 0.6.12;\r\n\r\n/**\r\n * @notice The Ownable contract has an owner address, and provides basic\r\n * authorization control functions\r\n * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-labs/blob/3887ab77b8adafba4a26ace002f3a684c1a3388b/upgradeability_ownership/contracts/ownership/Ownable.sol\r\n * Modifications:\r\n * 1. Consolidate OwnableStorage into this contract (7/13/18)\r\n * 2. Reformat, conform to Solidity 0.6 syntax, and add error messages (5/13/20)\r\n * 3. Make public functions external (5/27/20)\r\n */\r\ncontract Ownable {\r\n    // Owner of the contract\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev Event to show ownership has been transferred\r\n     * @param previousOwner representing the address of the previous owner\r\n     * @param newOwner representing the address of the new owner\r\n     */\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n     * @dev The constructor sets the original owner of the contract to the sender account.\r\n     */\r\n    constructor() public {\r\n        setOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the owner\r\n     * @return the address of the owner\r\n     */\r\n    function owner() external view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new owner address\r\n     */\r\n    function setOwner(address newOwner) internal {\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        setOwner(newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File centre-tokens/contracts/v1/Blacklistable.sol@v1.0.0\r\n\r\n/**\r\n * \r\n *\r\n * Copyright (c) 2018-2020 CENTRE SECZ\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title Blacklistable Token\r\n * @dev Allows accounts to be blacklisted by a \"blacklister\" role\r\n */\r\ncontract Blacklistable is Ownable {\r\n    address public blacklister;\r\n    mapping(address => bool) internal blacklisted;\r\n\r\n    event Blacklisted(address indexed _account);\r\n    event UnBlacklisted(address indexed _account);\r\n    event BlacklisterChanged(address indexed newBlacklister);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the blacklister\r\n     */\r\n    modifier onlyBlacklister() {\r\n        require(\r\n            msg.sender == blacklister,\r\n            \"Blacklistable: caller is not the blacklister\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if argument account is blacklisted\r\n     * @param _account The address to check\r\n     */\r\n    modifier notBlacklisted(address _account) {\r\n        require(\r\n            !blacklisted[_account],\r\n            \"Blacklistable: account is blacklisted\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if account is blacklisted\r\n     * @param _account The address to check\r\n     */\r\n    function isBlacklisted(address _account) external view returns (bool) {\r\n        return blacklisted[_account];\r\n    }\r\n\r\n    /**\r\n     * @dev Adds account to blacklist\r\n     * @param _account The address to blacklist\r\n     */\r\n    function blacklist(address _account) external onlyBlacklister {\r\n        blacklisted[_account] = true;\r\n        emit Blacklisted(_account);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes account from blacklist\r\n     * @param _account The address to remove from the blacklist\r\n     */\r\n    function unBlacklist(address _account) external onlyBlacklister {\r\n        blacklisted[_account] = false;\r\n        emit UnBlacklisted(_account);\r\n    }\r\n\r\n    function updateBlacklister(address _newBlacklister) external onlyOwner {\r\n        require(\r\n            _newBlacklister != address(0),\r\n            \"Blacklistable: new blacklister is the zero address\"\r\n        );\r\n        blacklister = _newBlacklister;\r\n        emit BlacklisterChanged(blacklister);\r\n    }\r\n}\r\n\r\n\r\n// File centre-tokens/contracts/v1/Pausable.sol@v1.0.0\r\n\r\n/**\r\n * \r\n *\r\n * Copyright (c) 2016 Smart Contract Solutions, Inc.\r\n * Copyright (c) 2018-2020 CENTRE SECZ0\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @notice Base contract which allows children to implement an emergency stop\r\n * mechanism\r\n * @dev Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/feb665136c0dae9912e08397c1a21c4af3651ef3/contracts/lifecycle/Pausable.sol\r\n * Modifications:\r\n * 1. Added pauser role, switched pause/unpause to be onlyPauser (6/14/2018)\r\n * 2. Removed whenNotPause/whenPaused from pause/unpause (6/14/2018)\r\n * 3. Removed whenPaused (6/14/2018)\r\n * 4. Switches ownable library to use ZeppelinOS (7/12/18)\r\n * 5. Remove constructor (7/13/18)\r\n * 6. Reformat, conform to Solidity 0.6 syntax and add error messages (5/13/20)\r\n * 7. Make public functions external (5/27/20)\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n    event PauserChanged(address indexed newAddress);\r\n\r\n    address public pauser;\r\n    bool public paused = false;\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev throws if called by any account other than the pauser\r\n     */\r\n    modifier onlyPauser() {\r\n        require(msg.sender == pauser, \"Pausable: caller is not the pauser\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() external onlyPauser {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() external onlyPauser {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev update the pauser role\r\n     */\r\n    function updatePauser(address _newPauser) external onlyOwner {\r\n        require(\r\n            _newPauser != address(0),\r\n            \"Pausable: new pauser is the zero address\"\r\n        );\r\n        pauser = _newPauser;\r\n        emit PauserChanged(pauser);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.1.0\r\n\r\n// \r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/wrapped-tokens/staking/UnwrapTokenV1.sol\r\n\r\n// \r\npragma experimental ABIEncoderV2;\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n/**\r\n * @title UnwrapTokenV1\r\n * @notice Used For Unwap WBETH to ETH, version 1\r\n */\r\ncontract UnwrapTokenV1 is Pausable, Blacklistable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant MIN_LOCK_TIME = 2 days; // 2*24*3600 second\r\n    uint256 public constant MAX_LOOP_NUM = 1000; // max loop number\r\n    address public constant WBETH_TOKEN_ADDRESS = 0xa2E3356610840701BDf5611a53974510Ae27E2e1;\r\n\r\n    bool internal initialized; // init once\r\n\r\n    uint256 public ethStaked; // eth staked amount\r\n\r\n    address public operatorAddress; // trigger allocated\r\n\r\n    address public rechargeAddress; // recharge eth when insufficient\r\n\r\n    address public ethBackAddress; // If it has extra eth, Operator can transfer back to this address\r\n\r\n    uint256 public lockTime; // init lock time\r\n\r\n    struct WithdrawRequest {\r\n        address recipient; // user who withdraw\r\n        uint256 wbethAmount; //WBETH\r\n        uint256 ethAmount; //ETH\r\n        uint256 triggerTime; //user trigger time\r\n        uint256 claimTime; //user claim time\r\n        bool allocated;  //is it allocated\r\n    }\r\n    uint256 public startAllocatedEthIndex; //If new ETH send, just allocated start with this index\r\n\r\n    uint256 public nextIndex; // user request index\r\n\r\n    mapping(uint256 => WithdrawRequest) private withdrawRequests; // all request queue\r\n\r\n    mapping(address => uint256[]) private userWithdrawRequests; // user request withdraw\r\n\r\n    uint256 public availableAllocateAmount; // the amount can allocated to new user\r\n\r\n    uint256 public needEthAmount; // the eth amount that need to be allocated for user\r\n\r\n    /**\r\n     * @dev Emitted when the operator is updated\r\n     * @param newOperator The new Operator\r\n     */\r\n    event OperatorUpdated(address indexed newOperator);\r\n\r\n    /**\r\n     * @dev Emitted when the recharge address is updated\r\n     * @param newRechargeAddress The new newChargeAddress\r\n     */\r\n    event RechargeAddressUpdated(address indexed newRechargeAddress);\r\n\r\n    /**\r\n     * @dev Emitted when the eth return back address is updated\r\n     * @param newEthBackAddress The new ethBackAddress\r\n     */\r\n    event EthBackAddressUpdated(address indexed newEthBackAddress);\r\n\r\n    /**\r\n     * @dev Emitted when the lock time is updated\r\n     * @param operatorAddress The operator address\r\n     * @param newLockTime The new newLockTime\r\n     */\r\n    event LockTimeUpdated(address indexed operatorAddress, uint256 newLockTime);\r\n\r\n    /**\r\n     * @dev Emitted when request withdraw\r\n     * @param recipient The recipient request the event\r\n     * @param wbethAmount The recipient request wbethAmount\r\n     * @param ethAmount The recipient will get\r\n     * @param index At the queue index\r\n     */\r\n    event RequestWithdraw(address indexed recipient, uint256 wbethAmount, uint256 ethAmount, uint256 index);\r\n\r\n    /**\r\n     * @dev Emitted when user claim eth\r\n     * @param recipient The user can get eth\r\n     * @param ethAmount The recipient will get eth amount\r\n     * @param index At the user's request list\r\n     */\r\n    event ClaimWithdraw(address indexed recipient, uint256 ethAmount, uint256 index);\r\n\r\n    /**\r\n     * @dev Emitted when operator triggers to allocate eth\r\n     * @param operator The operator can trigger\r\n     * @param nextAllocateEthIndex The next index that  start to allocate eth\r\n     */\r\n    event Allocate(address indexed operator, uint256 nextAllocateEthIndex);\r\n\r\n    /**\r\n     * @dev Emitted when recharge eth from recharge address\r\n     * @param rechargeAddress The recharge address\r\n     * @param ethAmount  the Recharge eth amount\r\n     */\r\n    event RechargeFromRechargeAddress(address indexed rechargeAddress, uint256 ethAmount);\r\n\r\n    /**\r\n     * @dev Emitted when move eth from wbeth token contract address\r\n     * @param wrapTokenAddress The wbeth token address\r\n     * @param ethAmount the eth amount\r\n     */\r\n    event MoveFromWrapContract(address indexed wrapTokenAddress, uint256 ethAmount);\r\n\r\n    /**\r\n     * @dev Emitted when move eth to eth back address\r\n     * @param ethBackAddress The receive eth address\r\n     * @param ethAmount the eth amount\r\n     */\r\n    event MoveToEthBackAddress(address indexed ethBackAddress, uint256 ethAmount);\r\n\r\n    /**\r\n     * @dev Emitted when the eth staked amount is updated\r\n     * @param operatorAddress The operatorAddress\r\n     * @param ethStakedAmount The eth staked amount\r\n     */\r\n    event EthStakedUpdated(address indexed operatorAddress, uint256 ethStakedAmount);\r\n\r\n    function initialize(\r\n        address _newOperatorAddress,\r\n        address _newEthBackAddress,\r\n        address _newRechargeAddress,\r\n        address _newPauser,\r\n        address _newBlacklister,\r\n        address _newOwner\r\n    ) public {\r\n        require(!initialized, \"UnwrapTokenV1: contract is already initialized\");\r\n\r\n        require(\r\n            _newOperatorAddress != address(0),\r\n            \"UnwrapTokenV1: new operatorAddress is the zero address\"\r\n        );\r\n        require(\r\n            _newEthBackAddress != address(0),\r\n            \"UnwrapTokenV1: new ethBackAddress is the zero address\"\r\n        );\r\n        require(\r\n            _newRechargeAddress != address(0),\r\n            \"UnwrapTokenV1: new rechargeAddress is the zero address\"\r\n        );\r\n\r\n        require(\r\n            _newPauser != address(0),\r\n            \"UnwrapTokenV1: new pauser is the zero address\"\r\n        );\r\n        require(\r\n            _newBlacklister != address(0),\r\n            \"UnwrapTokenV1: new blacklister is the zero address\"\r\n        );\r\n        require(\r\n            _newOwner != address(0),\r\n            \"UnwrapTokenV1: new owner is the zero address\"\r\n        );\r\n        ethBackAddress = _newEthBackAddress;\r\n        operatorAddress = _newOperatorAddress;\r\n        rechargeAddress = _newRechargeAddress;\r\n        pauser = _newPauser;\r\n        blacklister = _newBlacklister;\r\n        setOwner(_newOwner);\r\n        lockTime = MIN_LOCK_TIME;\r\n        initialized = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when request withdraw eth from WBETH contract\r\n     * @param _recipient The user can receive eth\r\n     * @param _wbethAmount the wbeth amount user send\r\n     * @param _ethAmount the eth amount user will receive\r\n     */\r\n    function requestWithdraw(address _recipient, uint256 _wbethAmount, uint256 _ethAmount)\r\n        external onlyWrapTokenAddress {\r\n        require(_recipient != address(0), \"_recipient is the zero address\");\r\n        require(_ethAmount > 0, \"eth amount is zero\");\r\n\r\n        uint256 _currentIndex = nextIndex++;\r\n        bool _allocated = false;\r\n        if (availableAllocateAmount >= _ethAmount && startAllocatedEthIndex == _currentIndex) {\r\n            _allocated = true;\r\n            availableAllocateAmount = availableAllocateAmount.sub(_ethAmount);\r\n            startAllocatedEthIndex++;\r\n        } else {\r\n            needEthAmount = needEthAmount.add(_ethAmount);\r\n        }\r\n        withdrawRequests[_currentIndex] = WithdrawRequest({\r\n            recipient: _recipient,\r\n            wbethAmount: _wbethAmount,\r\n            ethAmount: _ethAmount,\r\n            triggerTime: block.timestamp,\r\n            claimTime: 0,\r\n            allocated: _allocated\r\n        });\r\n        userWithdrawRequests[_recipient].push(\r\n            _currentIndex\r\n        );\r\n        emit RequestWithdraw(_recipient, _wbethAmount, _ethAmount, _currentIndex);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieves all withdraw requests initiated by the given address\r\n     * @param _recipient - Address of an user\r\n     * @return WithdrawRequest array of user withdraw requests NO more then 1000\r\n     */\r\n    function getUserWithdrawRequests(address _recipient)\r\n    external\r\n    view\r\n    returns (WithdrawRequest[] memory)\r\n    {\r\n        uint256[] memory _userRequests = userWithdrawRequests[_recipient];\r\n        uint256 _length = _userRequests.length;\r\n        if (_length > MAX_LOOP_NUM) {\r\n            _length = MAX_LOOP_NUM;\r\n        }\r\n        WithdrawRequest[] memory _userDetailRequests = new WithdrawRequest[](_length);\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            uint256 _allocateIndex = _userRequests[i];\r\n            _userDetailRequests[i] = withdrawRequests[_allocateIndex];\r\n        }\r\n        return _userDetailRequests;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Retrieves withdraw requests by index\r\n     * @param _startIndex - the startIndex\r\n     * @return WithdrawRequest array of user withdraw requests\r\n     */\r\n    function getWithdrawRequests(uint256 _startIndex)\r\n    external\r\n    view\r\n    returns (WithdrawRequest[] memory)\r\n    {\r\n        require(_startIndex < nextIndex, \"Wrong start Index\");\r\n        uint256 _length = nextIndex.sub(_startIndex);\r\n        if (_length > MAX_LOOP_NUM) {\r\n            _length = MAX_LOOP_NUM;\r\n        }\r\n        WithdrawRequest[] memory _detailWithdrawRequests = new WithdrawRequest[](_length);\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            uint256 _index = _startIndex.add(i);\r\n            _detailWithdrawRequests[i] = withdrawRequests[_index];\r\n        }\r\n        return _detailWithdrawRequests;\r\n    }\r\n\r\n    /**\r\n     * @dev claim the allocated eth\r\n     * @param _index the index to claim\r\n     * @return the eth amount\r\n     */\r\n    function claimWithdraw(uint256 _index) external whenNotPaused\r\n            notBlacklisted(msg.sender) returns (uint256)\r\n    {\r\n        address _user = msg.sender;\r\n        uint256[] storage _userRequests = userWithdrawRequests[_user];\r\n        require(_index < _userRequests.length, \"Invalid index\");\r\n\r\n        uint256 _allocateIndex = _userRequests[_index];\r\n        WithdrawRequest storage _withdrawRequest = withdrawRequests[_allocateIndex];\r\n        uint256 _ethAmount = _withdrawRequest.ethAmount;\r\n\r\n        require(_withdrawRequest.recipient == _user, \"Wrong recipient\");\r\n        require(block.timestamp >= _withdrawRequest.triggerTime.add(lockTime), \"Claim time not reach\");\r\n        require(_withdrawRequest.allocated, \"Not allocated yet\");\r\n        require(_withdrawRequest.claimTime == 0, \"Already claim yet\");\r\n        require(_getCurrentBalance() >= _ethAmount, \"Not enough balance\");\r\n\r\n        if (_userRequests.length > 1) {\r\n            _userRequests[_index] = _userRequests[_userRequests.length - 1];\r\n        }\r\n        _userRequests.pop();\r\n\r\n        _withdrawRequest.claimTime = block.timestamp;\r\n        _transferEth(_user, _ethAmount);\r\n        emit ClaimWithdraw(_user, _ethAmount, _allocateIndex);\r\n        return _ethAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev allocated eth to every request\r\n     * @param _maxAllocateNum the max number\r\n     * @return the next allocate eth index\r\n     */\r\n    function allocate(uint256 _maxAllocateNum) external whenNotPaused onlyOperator returns (uint256)\r\n    {\r\n        require(needEthAmount > 0 && availableAllocateAmount > 0, \"No need allocated or no more availableAllocateAmount \");\r\n        require(_maxAllocateNum <= MAX_LOOP_NUM, \"Too big number > 1000\");\r\n        require(startAllocatedEthIndex < nextIndex, \"Not need allocated\");\r\n\r\n        for (uint256 _reqCount = 0; _reqCount < _maxAllocateNum && startAllocatedEthIndex < nextIndex &&\r\n                                withdrawRequests[startAllocatedEthIndex].ethAmount <= availableAllocateAmount;\r\n            _reqCount++\r\n        ) {\r\n            WithdrawRequest storage _withdrawRequest = withdrawRequests[startAllocatedEthIndex];\r\n            _withdrawRequest.allocated = true;\r\n\r\n            availableAllocateAmount = availableAllocateAmount.sub(_withdrawRequest.ethAmount);\r\n            needEthAmount = needEthAmount.sub(_withdrawRequest.ethAmount);\r\n\r\n            startAllocatedEthIndex++;\r\n        }\r\n        emit Allocate(operatorAddress, startAllocatedEthIndex);\r\n        return startAllocatedEthIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev get need recharge eth amount\r\n     */\r\n    function getNeedRechargeEthAmount() external view returns (uint256) {\r\n        if (availableAllocateAmount >= needEthAmount) {\r\n            return 0;\r\n        } else {\r\n            return needEthAmount.sub(availableAllocateAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev get eth balance of contract\r\n     */\r\n    function _getCurrentBalance() internal view virtual returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to transfer eth to sender\r\n     * @param _ethAmount The eth amount\r\n     */\r\n    function _transferEth(address _recipient, uint256 _ethAmount) internal virtual {\r\n        (bool success, ) = payable(_recipient).call{value: _ethAmount}(\"\");\r\n        require(success, \"transfer failed\");\r\n    }\r\n\r\n    /**\r\n    * @dev Function to update the operatorAddress\r\n     * @param _newOperatorAddress The new botAddress\r\n     */\r\n    function setNewOperator(address _newOperatorAddress) external onlyOwner {\r\n        require(_newOperatorAddress != address(0), \"zero address provided\");\r\n        operatorAddress = _newOperatorAddress;\r\n        emit OperatorUpdated(_newOperatorAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to update the rechargeAddress\r\n     * @param _newRechargeAddress The new rechargeAddress\r\n     */\r\n    function setRechargeAddress(address _newRechargeAddress) external onlyOwner {\r\n        require(_newRechargeAddress != address(0), \"zero address provided\");\r\n        rechargeAddress = _newRechargeAddress;\r\n        emit RechargeAddressUpdated(_newRechargeAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to update the ethBackAddress\r\n     * @param _newEthBackAddress The new ethBackAddress\r\n     */\r\n    function setEthBackAddress(address _newEthBackAddress) external onlyOwner {\r\n        require(_newEthBackAddress != address(0), \"zero address provided\");\r\n        ethBackAddress = _newEthBackAddress;\r\n        emit EthBackAddressUpdated(_newEthBackAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to update the lock time\r\n     * @param _newLockTime The new lock time\r\n     */\r\n    function setLockTime(uint256 _newLockTime) external onlyOperator {\r\n        require(_newLockTime >= MIN_LOCK_TIME, \"LockTime is too small\");\r\n        lockTime = _newLockTime;\r\n        emit LockTimeUpdated(operatorAddress, lockTime);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to update the eth staked amount\r\n     * @param _newEthStakedAmount new eth staked amount\r\n     */\r\n    function setNewEthStaked(uint256 _newEthStakedAmount) external onlyOperator {\r\n        require(ethStaked != _newEthStakedAmount, \"ethStaked not change\");\r\n        ethStaked = _newEthStakedAmount;\r\n        emit EthStakedUpdated(msg.sender, _newEthStakedAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the WBETH token address\r\n     */\r\n    modifier onlyWrapTokenAddress() {\r\n        require(\r\n            msg.sender == WBETH_TOKEN_ADDRESS,\r\n            \"UnwrapTokenV1: caller is not the WrapTokenAddress\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than operator address\r\n     */\r\n    modifier onlyOperator() {\r\n        require(\r\n            msg.sender == operatorAddress,\r\n            \"UnwrapTokenV1: caller is not the BOT_ADDRESS\"\r\n        );\r\n        _;\r\n    }\r\n    /**\r\n    * @dev Throws if called by any account other than recharge eth address\r\n     */\r\n    modifier onlyRechargeAddress() {\r\n        require(\r\n            msg.sender == rechargeAddress,\r\n            \"UnwrapTokenV1: caller is not the RECHARGE_ADDRESS\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n\r\n    uint256[50] private __reserve_slots;\r\n}\r\n\r\n\r\n// File contracts/wrapped-tokens/staking/UnwrapTokenV1ETH.sol\r\n\r\n//\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title UnwrapTokenV1ETH\r\n * @notice Ethers Chain\r\n */\r\ncontract UnwrapTokenV1ETH is UnwrapTokenV1 {\r\n\r\n    /**\r\n     * @dev gas limit of eth transfer.\r\n     */\r\n    uint256 private constant _ETH_TRANSFER_GAS = 5000;\r\n\r\n    function rechargeFromRechargeAddress() external payable whenNotPaused onlyRechargeAddress{\r\n        _rechargeAmount(msg.value);\r\n        emit RechargeFromRechargeAddress(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to move eth to the ethBackAddress\r\n     * @param _amount The eth amount to move\r\n     */\r\n    function moveToBackAddress(uint256 _amount) external onlyOperator {\r\n        require(_amount > 0, \"amount cannot be 0\");\r\n        require(ethBackAddress != address(0), \"zero ethBackAddress\");\r\n\r\n        uint256 _canBackAmount = availableAllocateAmount.sub(needEthAmount);\r\n        require(_amount <= _canBackAmount, \"surplus balance not enough\");\r\n        require(_amount <= _getCurrentBalance(), \"balance not enough\");\r\n        availableAllocateAmount = availableAllocateAmount.sub(_amount);\r\n\r\n        (bool success, ) = ethBackAddress.call{value: _amount, gas: _ETH_TRANSFER_GAS}(\"\");\r\n        require(success, \"transfer failed\");\r\n\r\n        emit MoveToEthBackAddress(ethBackAddress, _amount);\r\n    }\r\n\r\n    function moveFromWrapContract() external payable whenNotPaused onlyWrapTokenAddress{\r\n        _rechargeAmount(msg.value);\r\n        emit MoveFromWrapContract(msg.sender, msg.value);\r\n    }\r\n\r\n    function _rechargeAmount(uint256 _ethAmount) internal {\r\n        require(_ethAmount > 0, \"Invalid _ethAmount\");\r\n        availableAllocateAmount = availableAllocateAmount.add(_ethAmount);\r\n        require(_getCurrentBalance() >= availableAllocateAmount, \"Invalid AvailableAllocateAmount\");\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextAllocateEthIndex\",\"type\":\"uint256\"}],\"name\":\"Allocate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBlacklister\",\"type\":\"address\"}],\"name\":\"BlacklisterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"ClaimWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newEthBackAddress\",\"type\":\"address\"}],\"name\":\"EthBackAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethStakedAmount\",\"type\":\"uint256\"}],\"name\":\"EthStakedUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLockTime\",\"type\":\"uint256\"}],\"name\":\"LockTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wrapTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"MoveFromWrapContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ethBackAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"MoveToEthBackAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRechargeAddress\",\"type\":\"address\"}],\"name\":\"RechargeAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rechargeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"RechargeFromRechargeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wbethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"RequestWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"UnBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_LOOP_NUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_LOCK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBETH_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxAllocateNum\",\"type\":\"uint256\"}],\"name\":\"allocate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableAllocateAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blacklister\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claimWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethBackAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNeedRechargeEthAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"getUserWithdrawRequests\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wbethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"triggerTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allocated\",\"type\":\"bool\"}],\"internalType\":\"struct UnwrapTokenV1.WithdrawRequest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"}],\"name\":\"getWithdrawRequests\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wbethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"triggerTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allocated\",\"type\":\"bool\"}],\"internalType\":\"struct UnwrapTokenV1.WithdrawRequest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newEthBackAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newRechargeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newPauser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newBlacklister\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moveFromWrapContract\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"moveToBackAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"needEthAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rechargeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rechargeFromRechargeAddress\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_wbethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"name\":\"requestWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newEthBackAddress\",\"type\":\"address\"}],\"name\":\"setEthBackAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLockTime\",\"type\":\"uint256\"}],\"name\":\"setLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newEthStakedAmount\",\"type\":\"uint256\"}],\"name\":\"setNewEthStaked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOperatorAddress\",\"type\":\"address\"}],\"name\":\"setNewOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRechargeAddress\",\"type\":\"address\"}],\"name\":\"setRechargeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAllocatedEthIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"unBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBlacklister\",\"type\":\"address\"}],\"name\":\"updateBlacklister\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPauser\",\"type\":\"address\"}],\"name\":\"updatePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UnwrapTokenV1ETH", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8a69be18b2a0d250b6a21864e6c2ce8994abfa9ab5e3bf48eb0d0959b4160727"}