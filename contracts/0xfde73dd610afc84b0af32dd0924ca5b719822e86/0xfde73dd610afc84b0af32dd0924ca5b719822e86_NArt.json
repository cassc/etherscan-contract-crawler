{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title The Punks art storage contract\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { IArt } from './interfaces/IArt.sol';\\nimport { SSTORE2 } from './libs/SSTORE2.sol';\\nimport { IInflator } from './interfaces/IInflator.sol';\\n\\ncontract NArt is IArt {\\n    /// @notice Current Punk Descriptor address\\n    address public override descriptor;\\n\\n    /// @notice Current inflator address\\n    IInflator public override inflator;\\n\\n    /// @notice Punk Color Palettes (Index => Hex Colors, stored as a contract using SSTORE2)\\n    mapping(uint8 => address) public palettesPointers;\\n\\n    Trait public punkTypesTrait;\\n    Trait public hatsTrait;\\n    Trait public helmetsTrait;\\n    Trait public hairsTrait;\\n    Trait public beardsTrait;\\n    Trait public eyesesTrait;\\n    Trait public glassesesTrait;\\n    Trait public gogglesesTrait;\\n    Trait public mouthsTrait;\\n    Trait public teethsTrait;\\n    Trait public lipsesTrait;\\n    Trait public necksTrait;\\n    Trait public emotionsTrait;\\n    Trait public facesTrait;\\n    Trait public earsesTrait;\\n    Trait public nosesTrait;\\n    Trait public cheeksesTrait;\\n\\n    /**\\n     * @notice Require that the sender is the descriptor.\\n     */\\n    modifier onlyDescriptor() {\\n        if (msg.sender != descriptor) {\\n            revert SenderIsNotDescriptor();\\n        }\\n        _;\\n    }\\n\\n    constructor(address _descriptor, IInflator _inflator) {\\n        descriptor = _descriptor;\\n        inflator = _inflator;\\n    }\\n\\n    /**\\n     * @notice Set the descriptor.\\n     * @dev This function can only be called by the current descriptor.\\n     */\\n    function setDescriptor(address _descriptor) external override onlyDescriptor {\\n        address oldDescriptor = descriptor;\\n        descriptor = _descriptor;\\n\\n        emit DescriptorUpdated(oldDescriptor, descriptor);\\n    }\\n\\n    /**\\n     * @notice Set the inflator.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function setInflator(IInflator _inflator) external override onlyDescriptor {\\n        address oldInflator = address(inflator);\\n        inflator = _inflator;\\n\\n        emit InflatorUpdated(oldInflator, address(_inflator));\\n    }\\n\\n    /**\\n     * @notice Get the Trait struct for bodies.\\n     * @dev This explicit getter is needed because implicit getters for structs aren't fully supported yet:\\n     * https://github.com/ethereum/solidity/issues/11826\\n     * @return Trait the struct, including a total image count, and an array of storage pages.\\n     */\\n    function getPunkTypesTrait() external view override returns (Trait memory) {\\n        return punkTypesTrait;\\n    }\\n    function getHatsTrait() external view override returns (Trait memory) {\\n        return hatsTrait;\\n    }\\n    function getHelmetsTrait() external view override returns (Trait memory) {\\n        return helmetsTrait;\\n    }\\n    function getHairsTrait() external view override returns (Trait memory) {\\n        return hairsTrait;\\n    }\\n    function getBeardsTrait() external view override returns (Trait memory) {\\n        return beardsTrait;\\n    }\\n    function getEyesesTrait() external view override returns (Trait memory) {\\n        return eyesesTrait;\\n    }\\n    function getGlassesesTrait() external view override returns (Trait memory) {\\n        return glassesesTrait;\\n    }\\n    function getGogglesesTrait() external view override returns (Trait memory) {\\n        return gogglesesTrait;\\n    }\\n    function getMouthsTrait() external view override returns (Trait memory) {\\n        return mouthsTrait;\\n    }\\n    function getTeethsTrait() external view override returns (Trait memory) {\\n        return teethsTrait;\\n    }\\n    function getLipsesTrait() external view override returns (Trait memory) {\\n        return lipsesTrait;\\n    }\\n    function getNecksTrait() external view override returns (Trait memory) {\\n        return necksTrait;\\n    }\\n    function getEmotionsTrait() external view override returns (Trait memory) {\\n        return emotionsTrait;\\n    }\\n    function getFacesTrait() external view override returns (Trait memory) {\\n        return facesTrait;\\n    }\\n    function getEarsesTrait() external view override returns (Trait memory) {\\n        return earsesTrait;\\n    }\\n    function getNosesTrait() external view override returns (Trait memory) {\\n        return nosesTrait;\\n    }\\n    function getCheeksesTrait() external view override returns (Trait memory) {\\n        return cheeksesTrait;\\n    }\\n\\n    /**\\n     * @notice Update a single color palette. This function can be used to\\n     * add a new color palette or update an existing palette.\\n     * @param paletteIndex the identifier of this palette\\n     * @param palette byte array of colors. every 4 bytes represent an RGBA color. max length: 256 * 4 = 1024\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external override onlyDescriptor {\\n        if (palette.length == 0) {\\n            revert EmptyPalette();\\n        }\\n        if (palette.length % 4 != 0 || palette.length > 1024) {\\n            revert BadPaletteLength();\\n        }\\n        palettesPointers[paletteIndex] = SSTORE2.write(palette);\\n\\n        emit PaletteSet(paletteIndex);\\n    }\\n\\n    /**\\n     * @notice Add a batch of body images.\\n     * @param encodedCompressed bytes created by taking a string array of RLE-encoded images, abi encoding it as a bytes array,\\n     * and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addPunkTypes(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(punkTypesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit PunkTypesAdded(imageCount);\\n    }\\n    function addHats(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(hatsTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit HatsAdded(imageCount);\\n    }\\n    function addHelmets(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(helmetsTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit HelmetsAdded(imageCount);\\n    }\\n    function addHairs(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(hairsTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit HairsAdded(imageCount);\\n    }\\n    function addBeards(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(beardsTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit BeardsAdded(imageCount);\\n    }\\n    function addEyeses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(eyesesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit EyesesAdded(imageCount);\\n    }\\n    function addGlasseses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(glassesesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit GlassesesAdded(imageCount);\\n    }\\n    function addGoggleses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(gogglesesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit GogglesesAdded(imageCount);\\n    }\\n    function addMouths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(mouthsTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit MouthsAdded(imageCount);\\n    }\\n    function addTeeths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(teethsTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit TeethsAdded(imageCount);\\n    }\\n    function addLipses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(lipsesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit LipsesAdded(imageCount);\\n    }\\n    function addNecks(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(necksTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit NecksAdded(imageCount);\\n    }\\n    function addEmotions(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(emotionsTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit EmotionsAdded(imageCount);\\n    }\\n    function addFaces(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(facesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit FacesAdded(imageCount);\\n    }\\n    function addEarses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(earsesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit EarsesAdded(imageCount);\\n    }\\n    function addNoses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(nosesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit NosesAdded(imageCount);\\n    }\\n    function addCheekses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(cheeksesTrait, encodedCompressed, decompressedLength, imageCount);\\n\\n        emit CheeksesAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Update a single color palette. This function can be used to\\n     * add a new color palette or update an existing palette. This function does not check for data length validity\\n     * (len <= 768, len % 3 == 0).\\n     * @param paletteIndex the identifier of this palette\\n     * @param pointer the address of the contract holding the palette bytes. every 3 bytes represent an RGB color.\\n     * max length: 256 * 3 = 768.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external override onlyDescriptor {\\n        palettesPointers[paletteIndex] = pointer;\\n\\n        emit PaletteSet(paletteIndex);\\n    }\\n\\n    /**\\n     * @notice Add a batch of body images from an existing storage contract.\\n     * @param pointer the address of a contract where the image batch was stored using SSTORE2. The data\\n     * format is expected to be like {encodedCompressed}: bytes created by taking a string array of\\n     * RLE-encoded images, abi encoding it as a bytes array, and finally compressing it using deflate.\\n     * @param decompressedLength the size in bytes the images bytes were prior to compression; required input for Inflate.\\n     * @param imageCount the number of images in this batch; used when searching for images among batches.\\n     * @dev This function can only be called by the descriptor.\\n     */\\n    function addPunkTypesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(punkTypesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit PunkTypesAdded(imageCount);\\n    }\\n    function addHatsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(hatsTrait, pointer, decompressedLength, imageCount);\\n\\n        emit HatsAdded(imageCount);\\n    }\\n    function addHelmetsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(helmetsTrait, pointer, decompressedLength, imageCount);\\n\\n        emit HelmetsAdded(imageCount);\\n    }\\n    function addHairsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(hairsTrait, pointer, decompressedLength, imageCount);\\n\\n        emit HairsAdded(imageCount);\\n    }\\n    function addBeardsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(beardsTrait, pointer, decompressedLength, imageCount);\\n\\n        emit BeardsAdded(imageCount);\\n    }\\n    function addEyesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(eyesesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit EyesesAdded(imageCount);\\n    }\\n    function addGlassesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(glassesesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit GlassesesAdded(imageCount);\\n    }\\n    function addGogglesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(gogglesesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit GogglesesAdded(imageCount);\\n    }\\n    function addMouthsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(mouthsTrait, pointer, decompressedLength, imageCount);\\n\\n        emit MouthsAdded(imageCount);\\n    }\\n    function addTeethsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(teethsTrait, pointer, decompressedLength, imageCount);\\n\\n        emit TeethsAdded(imageCount);\\n    }\\n    function addLipsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(lipsesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit LipsesAdded(imageCount);\\n    }\\n    function addNecksFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(necksTrait, pointer, decompressedLength, imageCount);\\n\\n        emit NecksAdded(imageCount);\\n    }\\n    function addEmotionsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(emotionsTrait, pointer, decompressedLength, imageCount);\\n\\n        emit EmotionsAdded(imageCount);\\n    }\\n    function addFacesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(facesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit FacesAdded(imageCount);\\n    }\\n    function addEarsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(earsesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit EarsesAdded(imageCount);\\n    }\\n    function addNosesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(nosesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit NosesAdded(imageCount);\\n    }\\n    function addCheeksesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external override onlyDescriptor {\\n        addPage(cheeksesTrait, pointer, decompressedLength, imageCount);\\n\\n        emit CheeksesAdded(imageCount);\\n    }\\n\\n    /**\\n     * @notice Get the number of available Punk `backgrounds`.\\n     */\\n    // function backgroundsCount() public view override returns (uint256) {\\n    //     return backgrounds.length;\\n    // }\\n\\n    /**\\n     * @notice Get a head image bytes (RLE-encoded).\\n     */\\n    function punkTypes(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(punkTypesTrait, index);\\n    }\\n    function hats(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(hatsTrait, index);\\n    }\\n    function helmets(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(helmetsTrait, index);\\n    }\\n    function hairs(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(hairsTrait, index);\\n    }\\n    function beards(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(beardsTrait, index);\\n    }\\n    function eyeses(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(eyesesTrait, index);\\n    }\\n    function glasseses(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(glassesesTrait, index);\\n    }\\n    function goggleses(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(gogglesesTrait, index);\\n    }\\n    function mouths(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(mouthsTrait, index);\\n    }\\n    function teeths(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(teethsTrait, index);\\n    }\\n    function lipses(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(lipsesTrait, index);\\n    }\\n    function necks(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(necksTrait, index);\\n    }\\n    function emotions(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(emotionsTrait, index);\\n    }\\n    function faces(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(facesTrait, index);\\n    }\\n    function earses(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(earsesTrait, index);\\n    }\\n    function noses(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(nosesTrait, index);\\n    }\\n    function cheekses(uint256 index) public view override returns (bytes memory) {\\n        return imageByIndex(cheeksesTrait, index);\\n    }\\n\\n    /**\\n     * @notice Get a color palette bytes.\\n     */\\n    function palettes(uint8 paletteIndex) public view override returns (bytes memory) {\\n        address pointer = palettesPointers[paletteIndex];\\n        if (pointer == address(0)) {\\n            revert PaletteNotFound();\\n        }\\n        return SSTORE2.read(palettesPointers[paletteIndex]);\\n    }\\n\\n    // function _addBackground(string calldata _background) internal {\\n    //     backgrounds.push(_background);\\n    // }\\n\\n    function addPage(\\n        Trait storage trait,\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) internal {\\n        if (encodedCompressed.length == 0) {\\n            revert EmptyBytes();\\n        }\\n        address pointer = SSTORE2.write(encodedCompressed);\\n        addPage(trait, pointer, decompressedLength, imageCount);\\n    }\\n\\n    function addPage(\\n        Trait storage trait,\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) internal {\\n        if (decompressedLength == 0) {\\n            revert BadDecompressedLength();\\n        }\\n        if (imageCount == 0) {\\n            revert BadImageCount();\\n        }\\n        trait.storagePages.push(\\n            NArtStoragePage({ pointer: pointer, decompressedLength: decompressedLength, imageCount: imageCount })\\n        );\\n        trait.storedImagesCount += imageCount;\\n    }\\n\\n    function imageByIndex(IArt.Trait storage trait, uint256 index) internal view returns (bytes memory) {\\n        (IArt.NArtStoragePage storage page, uint256 indexInPage) = getPage(trait.storagePages, index);\\n        bytes[] memory decompressedImages = decompressAndDecode(page);\\n        return decompressedImages[indexInPage];\\n    }\\n\\n    /**\\n     * @dev Given an image index, this function finds the storage page the image is in, and the relative index\\n     * inside the page, so the image can be read from storage.\\n     * Example: if you have 2 pages with 100 images each, and you want to get image 150, this function would return\\n     * the 2nd page, and the 50th index.\\n     * @return IArt.NArtStoragePage the page containing the image at index\\n     * @return uint256 the index of the image in the page\\n     */\\n    function getPage(IArt.NArtStoragePage[] storage pages, uint256 index)\\n        internal\\n        view\\n        returns (IArt.NArtStoragePage storage, uint256)\\n    {\\n        uint256 len = pages.length;\\n        uint256 pageFirstImageIndex = 0;\\n        for (uint256 i = 0; i < len; i++) {\\n            IArt.NArtStoragePage storage page = pages[i];\\n\\n            if (index < pageFirstImageIndex + page.imageCount) {\\n                return (page, index - pageFirstImageIndex);\\n            }\\n\\n            pageFirstImageIndex += page.imageCount;\\n        }\\n\\n        revert ImageNotFound();\\n    }\\n\\n    function decompressAndDecode(IArt.NArtStoragePage storage page) internal view returns (bytes[] memory) {\\n        bytes memory compressedData = SSTORE2.read(page.pointer);\\n        (, bytes memory decompressedData) = inflator.puff(compressedData, page.decompressedLength);\\n        return abi.decode(decompressedData, (bytes[]));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for NArt\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Inflate } from '../libs/Inflate.sol';\\nimport { IInflator } from './IInflator.sol';\\n\\ninterface IArt {\\n    error SenderIsNotDescriptor();\\n\\n    error EmptyPalette();\\n\\n    error BadPaletteLength();\\n\\n    error EmptyBytes();\\n\\n    error BadDecompressedLength();\\n\\n    error BadImageCount();\\n\\n    error ImageNotFound();\\n\\n    error PaletteNotFound();\\n\\n    event DescriptorUpdated(address oldDescriptor, address newDescriptor);\\n\\n    event InflatorUpdated(address oldInflator, address newInflator);\\n\\n    event PaletteSet(uint8 paletteIndex);\\n\\n    event PunkTypesAdded(uint16 count);\\n    event HatsAdded(uint16 count);\\n    event HelmetsAdded(uint16 count);\\n    event HairsAdded(uint16 count);\\n    event BeardsAdded(uint16 count);\\n    event EyesesAdded(uint16 count);\\n    event GlassesesAdded(uint16 count);\\n    event GogglesesAdded(uint16 count);\\n    event MouthsAdded(uint16 count);\\n    event TeethsAdded(uint16 count);\\n    event LipsesAdded(uint16 count);\\n    event NecksAdded(uint16 count);\\n    event EmotionsAdded(uint16 count);\\n    event FacesAdded(uint16 count);\\n    event EarsesAdded(uint16 count);\\n    event NosesAdded(uint16 count);\\n    event CheeksesAdded(uint16 count);\\n\\n    struct NArtStoragePage {\\n        uint16 imageCount;\\n        uint80 decompressedLength;\\n        address pointer;\\n    }\\n\\n    struct Trait {\\n        NArtStoragePage[] storagePages;\\n        uint256 storedImagesCount;\\n    }\\n\\n    function descriptor() external view returns (address);\\n\\n    function inflator() external view returns (IInflator);\\n\\n    function setDescriptor(address descriptor) external;\\n\\n    function setInflator(IInflator inflator) external;\\n\\n    function palettes(uint8 paletteIndex) external view returns (bytes memory);\\n\\n    function setPalette(uint8 paletteIndex, bytes calldata palette) external;\\n\\n    function addPunkTypes(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHats(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHelmets(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHairs(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addBeards(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEyeses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGlasseses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGoggleses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addMouths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addTeeths(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addLipses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNecks(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEmotions(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addFaces(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEarses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNoses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addCheekses(\\n        bytes calldata encodedCompressed,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n    function setPalettePointer(uint8 paletteIndex, address pointer) external;\\n\\n    function addPunkTypesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHatsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHelmetsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addHairsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addBeardsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEyesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGlassesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addGogglesesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addMouthsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addTeethsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addLipsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNecksFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEmotionsFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addFacesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addEarsesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addNosesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n    function addCheeksesFromPointer(\\n        address pointer,\\n        uint80 decompressedLength,\\n        uint16 imageCount\\n    ) external;\\n\\n\\n    function punkTypes(uint256 index) external view returns (bytes memory);\\n    function hats(uint256 index) external view returns (bytes memory);\\n    function helmets(uint256 index) external view returns (bytes memory);\\n    function hairs(uint256 index) external view returns (bytes memory);\\n    function beards(uint256 index) external view returns (bytes memory);\\n    function eyeses(uint256 index) external view returns (bytes memory);\\n    function glasseses(uint256 index) external view returns (bytes memory);\\n    function goggleses(uint256 index) external view returns (bytes memory);\\n    function mouths(uint256 index) external view returns (bytes memory);\\n    function teeths(uint256 index) external view returns (bytes memory);\\n    function lipses(uint256 index) external view returns (bytes memory);\\n    function necks(uint256 index) external view returns (bytes memory);\\n    function emotions(uint256 index) external view returns (bytes memory);\\n    function faces(uint256 index) external view returns (bytes memory);\\n    function earses(uint256 index) external view returns (bytes memory);\\n    function noses(uint256 index) external view returns (bytes memory);\\n    function cheekses(uint256 index) external view returns (bytes memory);\\n\\n    function getPunkTypesTrait() external view returns (Trait memory);\\n    function getHatsTrait() external view returns (Trait memory);\\n    function getHelmetsTrait() external view returns (Trait memory);\\n    function getHairsTrait() external view returns (Trait memory);\\n    function getBeardsTrait() external view returns (Trait memory);\\n    function getEyesesTrait() external view returns (Trait memory);\\n    function getGlassesesTrait() external view returns (Trait memory);\\n    function getGogglesesTrait() external view returns (Trait memory);\\n    function getMouthsTrait() external view returns (Trait memory);\\n    function getTeethsTrait() external view returns (Trait memory);\\n    function getLipsesTrait() external view returns (Trait memory);\\n    function getNecksTrait() external view returns (Trait memory);\\n    function getEmotionsTrait() external view returns (Trait memory);\\n    function getFacesTrait() external view returns (Trait memory);\\n    function getEarsesTrait() external view returns (Trait memory);\\n    function getNosesTrait() external view returns (Trait memory);\\n    function getCheeksesTrait() external view returns (Trait memory);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity ^0.8.6;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex'00', data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex'60_0B_59_81_38_03_80_92_59_39_F3', // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), 'DEPLOYMENT_FAILED');\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(\\n        address pointer,\\n        uint256 start,\\n        uint256 end\\n    ) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, 'OUT_OF_BOUNDS');\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(\\n        address pointer,\\n        uint256 start,\\n        uint256 size\\n    ) private view returns (bytes memory data) {\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInflator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/// @title Interface for Inflator\\n\\n/*********************************\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n * \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 *\\n *********************************/\\n\\npragma solidity ^0.8.6;\\n\\nimport { Inflate } from '../libs/Inflate.sol';\\n\\ninterface IInflator {\\n    function puff(bytes memory source, uint256 destlen) external pure returns (Inflate.ErrorCode, bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Inflate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/// @notice Based on https://github.com/madler/zlib/blob/master/contrib/puff\\n/// @dev Modified the original code for gas optimizations\\n/// 1. Disable overflow/underflow checks\\n/// 2. Chunk some loop iterations\\nlibrary Inflate {\\n    // Maximum bits in a code\\n    uint256 constant MAXBITS = 15;\\n    // Maximum number of literal/length codes\\n    uint256 constant MAXLCODES = 286;\\n    // Maximum number of distance codes\\n    uint256 constant MAXDCODES = 30;\\n    // Maximum codes lengths to read\\n    uint256 constant MAXCODES = (MAXLCODES + MAXDCODES);\\n    // Number of fixed literal/length codes\\n    uint256 constant FIXLCODES = 288;\\n\\n    // Error codes\\n    enum ErrorCode {\\n        ERR_NONE, // 0 successful inflate\\n        ERR_NOT_TERMINATED, // 1 available inflate data did not terminate\\n        ERR_OUTPUT_EXHAUSTED, // 2 output space exhausted before completing inflate\\n        ERR_INVALID_BLOCK_TYPE, // 3 invalid block type (type == 3)\\n        ERR_STORED_LENGTH_NO_MATCH, // 4 stored block length did not match one's complement\\n        ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, // 5 dynamic block code description: too many length or distance codes\\n        ERR_CODE_LENGTHS_CODES_INCOMPLETE, // 6 dynamic block code description: code lengths codes incomplete\\n        ERR_REPEAT_NO_FIRST_LENGTH, // 7 dynamic block code description: repeat lengths with no first length\\n        ERR_REPEAT_MORE, // 8 dynamic block code description: repeat more than specified lengths\\n        ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, // 9 dynamic block code description: invalid literal/length code lengths\\n        ERR_INVALID_DISTANCE_CODE_LENGTHS, // 10 dynamic block code description: invalid distance code lengths\\n        ERR_MISSING_END_OF_BLOCK, // 11 dynamic block code description: missing end-of-block code\\n        ERR_INVALID_LENGTH_OR_DISTANCE_CODE, // 12 invalid literal/length or distance code in fixed or dynamic block\\n        ERR_DISTANCE_TOO_FAR, // 13 distance is too far back in fixed or dynamic block\\n        ERR_CONSTRUCT // 14 internal: error in construct()\\n    }\\n\\n    // Input and output state\\n    struct State {\\n        //////////////////\\n        // Output state //\\n        //////////////////\\n        // Output buffer\\n        bytes output;\\n        // Bytes written to out so far\\n        uint256 outcnt;\\n        /////////////////\\n        // Input state //\\n        /////////////////\\n        // Input buffer\\n        bytes input;\\n        // Bytes read so far\\n        uint256 incnt;\\n        ////////////////\\n        // Temp state //\\n        ////////////////\\n        // Bit buffer\\n        uint256 bitbuf;\\n        // Number of bits in bit buffer\\n        uint256 bitcnt;\\n        //////////////////////////\\n        // Static Huffman codes //\\n        //////////////////////////\\n        Huffman lencode;\\n        Huffman distcode;\\n    }\\n\\n    // Huffman code decoding tables\\n    struct Huffman {\\n        uint256[] counts;\\n        uint256[] symbols;\\n    }\\n\\n    function bits(State memory s, uint256 need) private pure returns (uint256) {\\n        unchecked {\\n            // Bit accumulator (can use up to 20 bits)\\n            uint256 val;\\n\\n            // Load at least need bits into val\\n            val = s.bitbuf;\\n            while (s.bitcnt < need) {\\n                require(s.incnt < s.input.length, \\\"Inflate: ErrorCode.ERR_NOT_TERMINATED\\\");\\n\\n                // Load eight bits\\n                // val |= uint256(uint8(s.input[s.incnt])) << s.bitcnt;\\n                // array length check is skipped\\n                assembly {\\n                    val := or(val, shl(mload(add(s, 0xa0)), shr(0xf8, mload(add(add(mload(add(s, 0x40)), 0x20), mload(add(s, 0x60)))))))\\n                }\\n                s.incnt++;\\n                s.bitcnt += 8;\\n            }\\n\\n            // Drop need bits and update buffer, always zero to seven bits left\\n            s.bitbuf = val >> need;\\n            s.bitcnt -= need;\\n\\n            // Return need bits, zeroing the bits above that\\n            uint256 ret = (val & ((1 << need) - 1));\\n            return ret;\\n        }\\n    }\\n\\n    function bits1(State memory s) private pure returns (uint256) {\\n        unchecked {\\n            uint256 val;\\n            if (s.bitcnt > 0) {\\n                val = s.bitbuf & 0x1;\\n                s.bitbuf >>= 1;\\n                s.bitcnt--;\\n            } else {\\n                require(s.incnt < s.input.length, \\\"Inflate: ErrorCode.ERR_NOT_TERMINATED\\\");\\n                // val = uint256(uint8(s.input[s.incnt]));\\n                // array length check is skipped\\n                assembly {\\n                    val := shr(0xf8, mload(add(add(mload(add(s, 0x40)), 0x20), mload(add(s, 0x60)))))\\n                }\\n                s.bitbuf = val >> 1;\\n                val &= 0x1;\\n                s.bitcnt = 7;\\n                s.incnt++;\\n            }\\n            return val;\\n        }\\n    }\\n\\n    function _stored(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Length of stored block\\n            uint256 len;\\n\\n            // Discard leftover bits from current byte (assumes s.bitcnt < 8)\\n            s.bitbuf = 0;\\n            s.bitcnt = 0;\\n\\n            // Get length and check against its one's complement\\n            if (s.incnt + 4 > s.input.length) {\\n                // Not enough input\\n                return ErrorCode.ERR_NOT_TERMINATED;\\n            }\\n            len = uint256(uint8(s.input[s.incnt++]));\\n            len |= uint256(uint8(s.input[s.incnt++])) << 8;\\n\\n            if (uint8(s.input[s.incnt++]) != (~len & 0xFF) || uint8(s.input[s.incnt++]) != ((~len >> 8) & 0xFF)) {\\n                // Didn't match complement!\\n                return ErrorCode.ERR_STORED_LENGTH_NO_MATCH;\\n            }\\n\\n            // Copy len bytes from in to out\\n            if (s.incnt + len > s.input.length) {\\n                // Not enough input\\n                return ErrorCode.ERR_NOT_TERMINATED;\\n            }\\n            if (s.outcnt + len > s.output.length) {\\n                // Not enough output space\\n                return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n            }\\n            while (len != 0) {\\n                // Note: Solidity reverts on underflow, so we decrement here\\n                len -= 1;\\n                s.output[s.outcnt++] = s.input[s.incnt++];\\n            }\\n\\n            // Done with a valid stored block\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _decode(State memory s, Huffman memory h) private pure returns (uint256) {\\n        unchecked {\\n            // Current number of bits in code\\n            uint256 len;\\n            // Len bits being decoded\\n            uint256 code = 0;\\n            // First code of length len\\n            uint256 first = 0;\\n            // Number of codes of length len\\n            uint256 count;\\n            // Index of first code of length len in symbol table\\n            uint256 index = 0;\\n\\n            for (len = 1; len <= MAXBITS; len += 5) {\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len + 1];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len + 2];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len + 3];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n\\n                // Get next bit\\n                code |= bits1(s);\\n                count = h.counts[len + 4];\\n\\n                // If length len, return symbol\\n                if (code < first + count) {\\n                    return h.symbols[index + (code - first)];\\n                }\\n                // Else update for next length\\n                index += count;\\n                first += count;\\n                first <<= 1;\\n                code <<= 1;\\n            }\\n\\n            // Ran out of codes\\n            revert(\\\"Inflate: ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE\\\");\\n        }\\n    }\\n\\n    function _construct(\\n        Huffman memory h,\\n        uint256[] memory lengths,\\n        uint256 n,\\n        uint256 start\\n    ) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Current symbol when stepping through lengths[]\\n            uint256 symbol;\\n            // Current length when stepping through h.counts[]\\n            uint256 len;\\n            // Number of possible codes left of current length\\n            uint256 left;\\n            // Offsets in symbol table for each length\\n            uint256[MAXBITS + 1] memory offs;\\n\\n            // Count number of codes of each length\\n            for (len = 0; len <= MAXBITS; ++len) {\\n                h.counts[len] = 0;\\n            }\\n            for (symbol = 0; symbol < n; ++symbol) {\\n                // Assumes lengths are within bounds\\n                ++h.counts[lengths[start + symbol]];\\n            }\\n            // No codes!\\n            if (h.counts[0] == n) {\\n                // Complete, but decode() will fail\\n                return (ErrorCode.ERR_NONE);\\n            }\\n\\n            // Check for an over-subscribed or incomplete set of lengths\\n\\n            // One possible code of zero length\\n            left = 1;\\n\\n            for (len = 1; len <= MAXBITS; len += 5) {\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 1]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 1];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 2]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 2];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 3]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 3];\\n\\n                // One more bit, double codes left\\n                left <<= 1;\\n                if (left < h.counts[len + 4]) {\\n                    // Over-subscribed--return error\\n                    return ErrorCode.ERR_CONSTRUCT;\\n                }\\n                // Deduct count from possible codes\\n                left -= h.counts[len + 4];\\n            }\\n\\n            // Generate offsets into symbol table for each length for sorting\\n            offs[1] = 0;\\n            for (len = 1; len < MAXBITS; ++len) {\\n                offs[len + 1] = offs[len] + h.counts[len];\\n            }\\n\\n            // Put symbols in table sorted by length, by symbol order within each length\\n            for (symbol = 0; symbol < n; ++symbol) {\\n                if (lengths[start + symbol] != 0) {\\n                    h.symbols[offs[lengths[start + symbol]]++] = symbol;\\n                }\\n            }\\n\\n            // Left > 0 means incomplete\\n            return left > 0 ? ErrorCode.ERR_CONSTRUCT : ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _codes(\\n        State memory s,\\n        Huffman memory lencode,\\n        Huffman memory distcode\\n    ) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Decoded symbol\\n            uint256 symbol;\\n            // Length for copy\\n            uint256 len;\\n            // Distance for copy\\n            uint256 dist;\\n            // TODO Solidity doesn't support constant arrays, but these are fixed at compile-time\\n            uint16[118] memory fixedTabs = [\\n            // Size base for length codes 257..285\\n            // uint16[29] memory lens = [\\n                3,\\n                4,\\n                5,\\n                6,\\n                7,\\n                8,\\n                9,\\n                10,\\n                11,\\n                13,\\n                15,\\n                17,\\n                19,\\n                23,\\n                27,\\n                31,\\n                35,\\n                43,\\n                51,\\n                59,\\n                67,\\n                83,\\n                99,\\n                115,\\n                131,\\n                163,\\n                195,\\n                227,\\n                258,\\n            // ];\\n            // Extra bits for length codes 257..285\\n            // uint8[29] memory lext = [\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                1,\\n                1,\\n                2,\\n                2,\\n                2,\\n                2,\\n                3,\\n                3,\\n                3,\\n                3,\\n                4,\\n                4,\\n                4,\\n                4,\\n                5,\\n                5,\\n                5,\\n                5,\\n                0,\\n            // ];\\n            // Offset base for distance codes 0..29\\n            // uint16[30] memory dists = [\\n                1,\\n                2,\\n                3,\\n                4,\\n                5,\\n                7,\\n                9,\\n                13,\\n                17,\\n                25,\\n                33,\\n                49,\\n                65,\\n                97,\\n                129,\\n                193,\\n                257,\\n                385,\\n                513,\\n                769,\\n                1025,\\n                1537,\\n                2049,\\n                3073,\\n                4097,\\n                6145,\\n                8193,\\n                12289,\\n                16385,\\n                24577,\\n            // ];\\n            // Extra bits for distance codes 0..29\\n            // uint8[30] memory dext = [\\n                0,\\n                0,\\n                0,\\n                0,\\n                1,\\n                1,\\n                2,\\n                2,\\n                3,\\n                3,\\n                4,\\n                4,\\n                5,\\n                5,\\n                6,\\n                6,\\n                7,\\n                7,\\n                8,\\n                8,\\n                9,\\n                9,\\n                10,\\n                10,\\n                11,\\n                11,\\n                12,\\n                12,\\n                13,\\n                13\\n            ];\\n\\n            // Decode literals and length/distance pairs\\n            while (symbol != 256) {\\n                symbol = _decode(s, lencode);\\n\\n                if (symbol < 256) {\\n                    // Literal: symbol is the byte\\n                    // Write out the literal\\n                    if (s.outcnt == s.output.length) {\\n                        return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                    }\\n                    // s.output[s.outcnt] = bytes1(uint8(symbol));\\n                    // array length check is skipped\\n                    // symbol range trimming is skipped because symbol < 256\\n                    assembly {\\n                        mstore8(add(add(mload(s), 0x20), mload(add(s, 0x20))), symbol)\\n                    }\\n                    ++s.outcnt;\\n                } else if (symbol > 256) {\\n                    // Length\\n                    // Get and compute length\\n                    symbol -= 257;\\n                    if (symbol >= 29) {\\n                        // Invalid fixed code\\n                        return ErrorCode.ERR_INVALID_LENGTH_OR_DISTANCE_CODE;\\n                    }\\n\\n                    len = fixedTabs[symbol] + bits(s, fixedTabs[29 + symbol]);\\n\\n                    // Get and check distance\\n                    symbol = _decode(s, distcode);\\n                    dist = fixedTabs[58 + symbol] + bits(s, fixedTabs[88 + symbol]);\\n                    if (dist > s.outcnt) {\\n                        // Distance too far back\\n                        return ErrorCode.ERR_DISTANCE_TOO_FAR;\\n                    }\\n\\n                    // Copy length bytes from distance bytes back\\n                    if (s.outcnt + len > s.output.length) {\\n                        return ErrorCode.ERR_OUTPUT_EXHAUSTED;\\n                    }\\n                    uint256 pointer;\\n                    assembly {\\n                        pointer := add(add(mload(s), 0x20), mload(add(s, 0x20)))\\n                    }\\n                    s.outcnt += len;\\n                    if (dist < len && dist < 32) {  // copy dist bytes\\n                        uint256 mask;\\n                        assembly {\\n                            mask := shr(mul(dist, 8), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                        }\\n                        while (len > dist) {\\n                            assembly {\\n                                mstore(pointer,\\n                                    or(\\n                                        and(mload(sub(pointer, dist)), not(mask)),\\n                                        and(mload(pointer), mask)\\n                                    )\\n                                )\\n                            }\\n                            pointer += dist;\\n                            len -= dist;\\n                        }\\n                    } else {  // copy 32 bytes\\n                        while (len > 32) {\\n                            assembly {\\n                                mstore(pointer, mload(sub(pointer, dist)))\\n                            }\\n                            pointer += 32;\\n                            len -= 32;\\n                        }\\n                    }\\n                    assembly {  // copy left\\n                        let mask := shr(mul(len, 8), 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                        mstore(pointer,\\n                            or(\\n                                and(mload(sub(pointer, dist)), not(mask)),\\n                                and(mload(pointer), mask)\\n                            )\\n                        )\\n                    }\\n                } else {\\n                    s.outcnt += len;\\n                }\\n            }\\n\\n            // Done with a valid fixed or dynamic block\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _build_fixed(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Build fixed Huffman tables\\n\\n            // _construct(s.lencode, lengths, FIXLCODES, 0);\\n            for (uint256 symbol = 0; symbol < 144; ++symbol) { // 8\\n                s.lencode.symbols[symbol + 24] = symbol;\\n            }\\n            for (uint256 symbol = 144; symbol < 256; ++symbol) { // 9\\n                s.lencode.symbols[symbol + FIXLCODES - 256] = symbol;\\n            }\\n            for (uint256 symbol = 256; symbol < 280; ++symbol) { // 7\\n                s.lencode.symbols[symbol - 256] = symbol;\\n            }\\n            for (uint256 symbol = 280; symbol < FIXLCODES; ++symbol) { // 8\\n                s.lencode.symbols[symbol - 112] = symbol;\\n            }\\n            s.lencode.counts[7] = 280 - 256;\\n            s.lencode.counts[8] = 144 + FIXLCODES - 280;\\n            s.lencode.counts[9] = 256 - 144;\\n\\n            // _construct(s.distcode, lengths, MAXDCODES, 0);\\n            for (uint256 symbol = 0; symbol < MAXDCODES; ++symbol) {\\n                s.distcode.symbols[symbol] = symbol;\\n            }\\n            s.distcode.counts[5] = MAXDCODES;\\n\\n            return ErrorCode.ERR_NONE;\\n        }\\n    }\\n\\n    function _fixed(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Decode data until end-of-block code\\n            return _codes(s, s.lencode, s.distcode);\\n        }\\n    }\\n\\n    function _build_dynamic_lengths(State memory s) private pure returns (ErrorCode, uint256[] memory) {\\n        unchecked {\\n            uint256 ncode;\\n            // Index of lengths[]\\n            uint256 index;\\n            // Descriptor code lengths\\n            uint256[] memory lengths = new uint256[](MAXCODES);\\n            // Permutation of code length codes\\n            uint8[19] memory order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\\n\\n            ncode = bits(s, 4) + 4;\\n\\n            // Read code length code lengths (really), missing lengths are zero\\n            for (index = 0; index < ncode; ++index) {\\n                lengths[order[index]] = bits(s, 3);\\n            }\\n            for (; index < 19; ++index) {\\n                lengths[order[index]] = 0;\\n            }\\n\\n            return (ErrorCode.ERR_NONE, lengths);\\n        }\\n    }\\n\\n    function _build_dynamic(State memory s)\\n        private\\n        pure\\n        returns (\\n            ErrorCode,\\n            Huffman memory,\\n            Huffman memory\\n        )\\n    {\\n        unchecked {\\n            // Number of lengths in descriptor\\n            uint256 nlen;\\n            uint256 ndist;\\n            // Index of lengths[]\\n            uint256 index;\\n            // Error code\\n            ErrorCode err;\\n            // Descriptor code lengths\\n            uint256[] memory lengths = new uint256[](MAXCODES);\\n            // Length and distance codes\\n            Huffman memory lencode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXLCODES));\\n            Huffman memory distcode = Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES));\\n\\n            // Get number of lengths in each table, check lengths\\n            nlen = bits(s, 5) + 257;\\n            ndist = bits(s, 5) + 1;\\n\\n            if (nlen > MAXLCODES || ndist > MAXDCODES) {\\n                // Bad counts\\n                return (ErrorCode.ERR_TOO_MANY_LENGTH_OR_DISTANCE_CODES, lencode, distcode);\\n            }\\n\\n            (err, lengths) = _build_dynamic_lengths(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, lencode, distcode);\\n            }\\n\\n            // Build huffman table for code lengths codes (use lencode temporarily)\\n            err = _construct(lencode, lengths, 19, 0);\\n            if (err != ErrorCode.ERR_NONE) {\\n                // Require complete code set here\\n                return (ErrorCode.ERR_CODE_LENGTHS_CODES_INCOMPLETE, lencode, distcode);\\n            }\\n\\n            // Read length/literal and distance code length tables\\n            index = 0;\\n            while (index < nlen + ndist) {\\n                // Decoded value\\n                uint256 symbol;\\n                // Last length to repeat\\n                uint256 len;\\n\\n                symbol = _decode(s, lencode);\\n\\n                if (symbol < 16) {\\n                    // Length in 0..15\\n                    lengths[index++] = symbol;\\n                } else {\\n                    // Repeat instruction\\n                    // Assume repeating zeros\\n                    len = 0;\\n                    if (symbol == 16) {\\n                        // Repeat last length 3..6 times\\n                        if (index == 0) {\\n                            // No last length!\\n                            return (ErrorCode.ERR_REPEAT_NO_FIRST_LENGTH, lencode, distcode);\\n                        }\\n                        // Last length\\n                        len = lengths[index - 1];\\n                        symbol = 3 + bits(s, 2);\\n                    } else if (symbol == 17) {\\n                        // Repeat zero 3..10 times\\n                        symbol = 3 + bits(s, 3);\\n                    } else {\\n                        // == 18, repeat zero 11..138 times\\n                        symbol = 11 + bits(s, 7);\\n                    }\\n\\n                    if (index + symbol > nlen + ndist) {\\n                        // Too many lengths!\\n                        return (ErrorCode.ERR_REPEAT_MORE, lencode, distcode);\\n                    }\\n                    while (symbol != 0) {\\n                        // Note: Solidity reverts on underflow, so we decrement here\\n                        symbol -= 1;\\n\\n                        // Repeat last or zero symbol times\\n                        lengths[index++] = len;\\n                    }\\n                }\\n            }\\n\\n            // Check for end-of-block code -- there better be one!\\n            if (lengths[256] == 0) {\\n                return (ErrorCode.ERR_MISSING_END_OF_BLOCK, lencode, distcode);\\n            }\\n\\n            // Build huffman table for literal/length codes\\n            err = _construct(lencode, lengths, nlen, 0);\\n            if (\\n                err != ErrorCode.ERR_NONE &&\\n                (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                    err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                    nlen != lencode.counts[0] + lencode.counts[1])\\n            ) {\\n                // Incomplete code ok only for single length 1 code\\n                return (ErrorCode.ERR_INVALID_LITERAL_LENGTH_CODE_LENGTHS, lencode, distcode);\\n            }\\n\\n            // Build huffman table for distance codes\\n            err = _construct(distcode, lengths, ndist, nlen);\\n            if (\\n                err != ErrorCode.ERR_NONE &&\\n                (err == ErrorCode.ERR_NOT_TERMINATED ||\\n                    err == ErrorCode.ERR_OUTPUT_EXHAUSTED ||\\n                    ndist != distcode.counts[0] + distcode.counts[1])\\n            ) {\\n                // Incomplete code ok only for single length 1 code\\n                return (ErrorCode.ERR_INVALID_DISTANCE_CODE_LENGTHS, lencode, distcode);\\n            }\\n\\n            return (ErrorCode.ERR_NONE, lencode, distcode);\\n        }\\n    }\\n\\n    function _dynamic(State memory s) private pure returns (ErrorCode) {\\n        unchecked {\\n            // Length and distance codes\\n            Huffman memory lencode;\\n            Huffman memory distcode;\\n            // Error code\\n            ErrorCode err;\\n\\n            (err, lencode, distcode) = _build_dynamic(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return err;\\n            }\\n\\n            // Decode data until end-of-block code\\n            return _codes(s, lencode, distcode);\\n        }\\n    }\\n\\n    function puff(bytes memory source, uint256 destlen) internal pure returns (ErrorCode, bytes memory) {\\n        unchecked {\\n            // Input/output state\\n            State memory s = State(\\n                new bytes(destlen),\\n                0,\\n                source,\\n                0,\\n                0,\\n                0,\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](FIXLCODES)),\\n                Huffman(new uint256[](MAXBITS + 1), new uint256[](MAXDCODES))\\n            );\\n            // Temp: last bit\\n            uint256 last;\\n            // Temp: block type bit\\n            uint256 t;\\n            // Error code\\n            ErrorCode err;\\n\\n            // Build fixed Huffman tables\\n            err = _build_fixed(s);\\n            if (err != ErrorCode.ERR_NONE) {\\n                return (err, s.output);\\n            }\\n\\n            // Process blocks until last block or error\\n            while (last == 0) {\\n                // One if last block\\n                last = bits1(s);\\n\\n                // Block type 0..3\\n                t = bits(s, 2);\\n\\n                err = (\\n                    t == 0\\n                        ? _stored(s)\\n                        : (t == 1 ? _fixed(s) : (t == 2 ? _dynamic(s) : ErrorCode.ERR_INVALID_BLOCK_TYPE))\\n                );\\n                // type == 3, invalid\\n\\n                if (err != ErrorCode.ERR_NONE) {\\n                    // Return with error\\n                    break;\\n                }\\n            }\\n\\n            return (err, s.output);\\n        }\\n    }\\n\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_descriptor\",\"type\":\"address\"},{\"internalType\":\"contract IInflator\",\"name\":\"_inflator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadDecompressedLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadImageCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadPaletteLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyBytes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyPalette\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ImageNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PaletteNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderIsNotDescriptor\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"BeardsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"CheeksesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDescriptor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDescriptor\",\"type\":\"address\"}],\"name\":\"DescriptorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"EarsesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"EmotionsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"EyesesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"FacesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"GlassesesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"GogglesesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"HairsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"HatsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"HelmetsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldInflator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newInflator\",\"type\":\"address\"}],\"name\":\"InflatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"LipsesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"MouthsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"NecksAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"NosesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"}],\"name\":\"PaletteSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"PunkTypesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"TeethsAdded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addBeards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addBeardsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addCheekses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addCheeksesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEarses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEarsesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEmotions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEmotionsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEyeses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addEyesesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addFaces\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addFacesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGlasseses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGlassesesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGoggleses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addGogglesesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHairsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHats\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHatsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHelmets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addHelmetsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addLipses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addLipsesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addMouths\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addMouthsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addNecks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addNecksFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addNoses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addNosesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addPunkTypes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addPunkTypesFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedCompressed\",\"type\":\"bytes\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addTeeths\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"}],\"name\":\"addTeethsFromPointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"beards\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beardsTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"cheekses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cheeksesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"descriptor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"earses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earsesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"emotions\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emotionsTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"eyeses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eyesesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"faces\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBeardsTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCheeksesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEarsesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEmotionsTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEyesesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFacesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlassesesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGogglesesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHairsTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHatsTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHelmetsTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLipsesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMouthsTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNecksTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNosesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPunkTypesTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTeethsTrait\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"imageCount\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"decompressedLength\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"internalType\":\"struct IArt.NArtStoragePage[]\",\"name\":\"storagePages\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IArt.Trait\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"glasseses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"glassesesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"goggleses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gogglesesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"hairs\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hairsTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"hats\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hatsTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"helmets\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"helmetsTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inflator\",\"outputs\":[{\"internalType\":\"contract IInflator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"lipses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lipsesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"mouths\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mouthsTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"necks\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"necksTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"noses\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nosesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"}],\"name\":\"palettes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"palettesPointers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"punkTypes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"punkTypesTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_descriptor\",\"type\":\"address\"}],\"name\":\"setDescriptor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IInflator\",\"name\":\"_inflator\",\"type\":\"address\"}],\"name\":\"setInflator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"palette\",\"type\":\"bytes\"}],\"name\":\"setPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"pointer\",\"type\":\"address\"}],\"name\":\"setPalettePointer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"teeths\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teethsTrait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"storedImagesCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NArt", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000007745a96ba4e1bb84631dfc9f183cf5bdf082388a0000000000000000000000005e10371557c9d2e69b6485df67ce876515cfa2eb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}