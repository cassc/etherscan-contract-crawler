{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Hyperobject.sol\": {\r\n      \"content\": \"/// Luxury rap, the Herm\u00e9s of verses\\n/// Sophisticated ignorance, write my curses in cursive\\n/// I get it custom, you a customer\\n/// You ain't accustomed to going through customs, you ain't been nowhere, huh?\\n\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.11;\\n\\nimport \\\"./Exchange.sol\\\";\\nimport \\\"@rari-capital/solmate/src/tokens/ERC721.sol\\\";\\n\\n/// @title Cryptomedia\\n/// @author neuroswish\\n/// @notice NFT with an autonomous exchange\\n\\ncontract Hyperobject is ERC721 {\\n\\n    // ======== Storage ========\\n\\n    address public exchange; // Exchange token pair address\\n    address public immutable factory; // Pair factory address\\n    string public baseURI; // NFT base URI\\n    uint256 currentTokenId; // Counter keeping track of last minted token id\\n\\n    // ======== Errors ========\\n\\n\\t/// @notice Thrown when function caller is unauthorized\\n\\terror Unauthorized();\\n\\n\\t/// @notice Thrown when transfer recipient is invalid\\n\\terror InvalidRecipient();\\n\\n    /// @notice Thrown when token id is invalid\\n\\terror InvalidTokenId();\\n\\n    // ======== Constructor ========\\n\\n    /// @notice Set factory address\\n    /// @param _factory Factory address\\n    constructor(address _factory) ERC721(\\\"Verse\\\", \\\"VERSE\\\") {\\n        factory = _factory;\\n     }\\n\\n    // ======== Initializer ========\\n\\n    /// @notice Initialize a new exchange\\n    /// @param _name Hyperobject name\\n    /// @param _symbol Hyperobject symbol\\n    /// @param _baseURI Token base URI\\n    /// @param _exchange Exchange address\\n    /// @dev Called by factory at time of deployment\\n    function initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        string calldata _baseURI,\\n        address _exchange\\n    ) external {\\n        if (msg.sender != factory) revert Unauthorized();\\n        name = _name;\\n        symbol = _symbol;\\n        baseURI = _baseURI;\\n        exchange = _exchange;\\n        currentTokenId++;\\n    }\\n\\n    // ======== Functions ========\\n\\n    /// @notice Mint NFT\\n    /// @param _recipient NFT recipient\\n    /// @dev Increments currentTokenId\\n    function mint(address _recipient) external {\\n        if (msg.sender != exchange) revert Unauthorized();\\n        if (_recipient == address(0)) revert InvalidRecipient();\\n        _mint(_recipient, currentTokenId++);\\n    }\\n\\n    /// @notice Retrieve token URI for specified NFT\\n    /// @param _tokenId Token id\\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\\n        if (ownerOf[_tokenId] == address(0)) revert InvalidTokenId();\\n        return bytes(baseURI).length > 0 ? baseURI : \\\"\\\";\\n    }\\n\\n}\\n\\n\"\r\n    },\r\n    \"contracts/Exchange.sol\": {\r\n      \"content\": \"/// I just needed time alone with my own thoughts\\n/// Got treasures in my mind, but couldn't open up my own vault\\n/// My childlike creativity, purity, and honesty\\n/// Is honestly being crowded by these grown thoughts\\n\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.11;\\n\\nimport \\\"./interfaces/IBondingCurve.sol\\\";\\nimport \\\"./interfaces/IHyperobject.sol\\\";\\nimport \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport \\\"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\n\\n/// @title Exchange\\n/// @author neuroswish\\n/// @notice Autonomous exchange for hyperobjects\\n\\ncontract Exchange is ERC20, ReentrancyGuard {\\n\\n    // ======== Storage ========\\n\\n    address public immutable factory; // Exchange factory address\\n    address public immutable bondingCurve; // Bonding curve address\\n    address public creator; // Hyperobject creator\\n    address public hyperobject; // Hyperobject address\\n    uint256 public reserveRatio; // Reserve ratio of token market cap to ETH pool\\n    uint256 public slopeInit; // Slope value to initialize supply\\n    uint256 public poolBalance; // ETH balance in contract pool\\n    uint256 public transactionShare; // Transaction share\\n\\n    // ======== Errors ========\\n\\n\\t/// @notice Thrown when function caller is unauthorized\\n\\terror Unauthorized();\\n\\n\\t/// @notice Thrown when token or ETH input is invalid\\n\\terror InvalidValue();\\n\\n    /// @notice Thrown when slippage input is invalid\\n\\terror InvalidSlippage();\\n\\n    /// @notice Thrown when initial price input is insufficient\\n\\terror InsufficientInitialPrice();\\n\\n    /// @notice Thrown when slippage occurs\\n\\terror Slippage();\\n\\n    /// @notice Thrown when sell amount is invalid\\n\\terror InvalidSellAmount();\\n\\n    /// @notice Thrown when user balance is insufficient\\n\\terror InsufficientBalance();\\n\\n    /// @notice Thrown when pool balance is insufficient\\n\\terror InsufficientPoolBalance();\\n\\n    // ======== Events ========\\n\\n    /// @notice Emitted when tokens are purchased\\n\\t/// @param buyer Token buyer\\n    /// @param poolBalance Pool balance\\n    /// @param totalSupply Total supply\\n    /// @param tokens Tokens bought\\n    /// @param price ETH\\n    event Buy(\\n        address indexed buyer,\\n        uint256 poolBalance,\\n        uint256 totalSupply,\\n        uint256 tokens,\\n        uint256 price\\n    );\\n\\n    /// @notice Emitted when tokens are sold\\n\\t/// @param seller Token seller\\n    /// @param poolBalance Pool balance\\n    /// @param totalSupply Total supply\\n    /// @param tokens Tokens sold\\n    /// @param eth ETH\\n    event Sell(\\n        address indexed seller,\\n        uint256 poolBalance,\\n        uint256 totalSupply,\\n        uint256 tokens,\\n        uint256 eth\\n    );\\n\\n    /// @notice Emitted when tokens are sold\\n\\t/// @param redeemer Token redeemer\\n    event Redeem(\\n        address indexed redeemer\\n    );\\n\\n    // ======== Constructor ========\\n\\n    /// @notice Set factory and bonding curve addresses\\n    /// @param _factory Factory address\\n    /// @param _bondingCurve Bonding curve address\\n    constructor(address _factory, address _bondingCurve) ERC20(\\\"Verse\\\", \\\"VERSE\\\", 18) {\\n        factory = _factory;\\n        bondingCurve = _bondingCurve;\\n    }\\n\\n    // ======== Initializer ========\\n\\n    /// @notice Initialize a new exchange\\n    /// @param _name Hyperobject name\\n    /// @param _symbol Hyperobject symbol\\n    /// @param _reserveRatio Reserve ratio\\n    /// @param _slopeInit Initial slope value to determine price curve\\n    /// @param _transactionShare Transaction share\\n    /// @param _hyperobject Hyperobject address\\n    /// @param _creator Hyperobject creator\\n    /// @dev Called by factory at time of deployment\\n    function initialize(\\n        string calldata _name,\\n        string calldata _symbol,\\n        uint256 _reserveRatio,\\n        uint256 _slopeInit,\\n        uint256 _transactionShare,\\n        address _hyperobject,\\n        address _creator\\n    ) external {\\n        if (msg.sender != factory) revert Unauthorized();\\n        name = _name;\\n        symbol = _symbol;\\n        reserveRatio = _reserveRatio;\\n        slopeInit = _slopeInit;\\n        transactionShare = _transactionShare;\\n        hyperobject = _hyperobject;\\n        creator = _creator;\\n    }\\n\\n    // ======== Functions ========\\n\\n    /// @notice Buy tokens with ETH\\n    /// @param _minTokensReturned Minimum tokens returned in case of slippage\\n    /// @dev Emits a Buy event upon success; callable by anyone\\n    function buy(uint256 _minTokensReturned) external payable {\\n        if (msg.value == 0) revert InvalidValue();\\n        if (_minTokensReturned == 0) revert InvalidSlippage();\\n        uint256 price = msg.value;\\n        uint256 creatorShare = splitShare(price);\\n        uint256 buyAmount = price - creatorShare;\\n        uint256 tokensReturned;\\n        if (totalSupply == 0 || poolBalance == 0) {\\n            if (buyAmount < 1 * (10**15)) revert InsufficientInitialPrice();\\n            tokensReturned = IBondingCurve(bondingCurve)\\n                .calculateInitializationReturn(buyAmount / (10**15), reserveRatio, slopeInit);\\n            tokensReturned = tokensReturned * (10**15);\\n        } else {\\n            tokensReturned = IBondingCurve(bondingCurve)\\n                .calculatePurchaseReturn(\\n                    totalSupply,\\n                    poolBalance,\\n                    reserveRatio,\\n                    buyAmount\\n                );\\n        }\\n        if (tokensReturned < _minTokensReturned) revert Slippage();\\n        _mint(msg.sender, tokensReturned);\\n        poolBalance += buyAmount;\\n        SafeTransferLib.safeTransferETH(payable(creator), creatorShare);\\n        emit Buy(msg.sender, poolBalance, totalSupply, tokensReturned, buyAmount);\\n    }\\n\\n    /// @notice Sell market tokens for ETH\\n    /// @param _tokens Tokens to sell\\n    /// @param _minETHReturned Minimum ETH returned in case of slippage\\n    /// @dev Emits a Sell event upon success; callable by token holders\\n    function sell(uint256 _tokens, uint256 _minETHReturned)\\n        external\\n    {\\n        if (_tokens == 0) revert InvalidSellAmount();\\n        if (_tokens > balanceOf[msg.sender]) revert InsufficientBalance();\\n        if (poolBalance == 0) revert InsufficientPoolBalance();\\n        if (_minETHReturned == 0) revert InvalidSlippage();\\n        uint256 ethReturned = IBondingCurve(bondingCurve).calculateSaleReturn(\\n            totalSupply,\\n            poolBalance,\\n            reserveRatio,\\n            _tokens\\n        );\\n        uint256 creatorShare = splitShare(ethReturned);\\n        uint256 sellerShare = ethReturned - creatorShare;\\n        if (sellerShare < _minETHReturned) revert Slippage();\\n        _burn(msg.sender, _tokens);\\n        poolBalance -= ethReturned;\\n        SafeTransferLib.safeTransferETH(payable(msg.sender), sellerShare);\\n        SafeTransferLib.safeTransferETH(payable(creator), creatorShare);\\n        emit Sell(msg.sender, poolBalance, totalSupply, _tokens, ethReturned);\\n    }\\n\\n    \\n    /// @notice Redeem ERC20 token for Hyperobject NFT\\n    /// @dev Mints NFT from Hyperobject contract for caller upon success; callable by token holders with at least 1 token\\n    function redeem() public {\\n        if (balanceOf[msg.sender] < (1 * (10**18))) revert InsufficientBalance();\\n        transfer(hyperobject, (1 * (10**18)));\\n        IHyperobject(hyperobject).mint(msg.sender);\\n        emit Redeem(msg.sender);\\n    }\\n\\n    // ======== Utility Functions ========\\n\\n    /// @notice Calculate share of ETH that goes to creator for each transaction\\n    /// @param _amount Amount to split\\n    /// @dev Calculates share based on 10000 basis points; called internally\\n    function splitShare(uint256 _amount) internal view returns (uint256 _share) {\\n        _share = (_amount * transactionShare) / 10000;\\n    }\\n    \\n}\\n\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondingCurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.11;\\n\\ninterface IBondingCurve {\\n    function calculateInitializationReturn(uint256 _price, uint256 _reserveRatio, uint256 _slopeInit)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function calculatePurchaseReturn(\\n        uint256 _supply,\\n        uint256 _poolBalance,\\n        uint256 _reserveRatio,\\n        uint256 _price\\n    ) external returns (uint256);\\n    \\n    function calculateSaleReturn(\\n        uint256 _supply,\\n        uint256 _poolBalance,\\n        uint256 _reserveRatio,\\n        uint256 _tokens\\n    ) external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IHyperobject.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.11;\\n\\ninterface IHyperobject {\\n    function mint(address _recipient) external;\\n}\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private reentrancyStatus = 1;\\n\\n    modifier nonReentrant() {\\n        require(reentrancyStatus == 1, \\\"REENTRANCY\\\");\\n\\n        reentrancyStatus = 2;\\n\\n        _;\\n\\n        reentrancyStatus = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_exchange\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Hyperobject", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000519204ec6318320842843d84ad1d776e905a73aa", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}