{"SourceCode": "{\"BaseToken.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract BaseToken is Ownable {\\n    using SafeMath for uint256;\\n\\n    // MARK: error message.\\n    string internal constant ERROR_APPROVED_BALANCE_NOT_ENOUGH =\\n        \\\"Reason: Approved balance is not enough.\\\";\\n    string internal constant ERROR_BALANCE_NOT_ENOUGH =\\n        \\\"Reason: Balance is not enough.\\\";\\n    string internal constant ERROR_LOCKED = \\\"Reason: Locked.\\\";\\n    string internal constant ERROR_ADDRESS_NOT_VALID =\\n        \\\"Reason: Address is not valid.\\\";\\n    string internal constant ERROR_ADDRESS_IS_SAME = \\\"Reason: Address is same.\\\";\\n    string internal constant ERROR_VALUE_NOT_VALID =\\n        \\\"Reason: Value must be greater than 0.\\\";\\n    string internal constant ERROR_NO_LOCKUP = \\\"Reason: There is no lockup.\\\";\\n    string internal constant ERROR_DATE_TIME_NOT_VALID =\\n        \\\"Reason: Datetime must grater or equals than zero.\\\";\\n    string internal constant ERROR_OUT_OF_INDEX = \\\"Reason: Out of index.\\\";\\n    string internal constant ERROR_TIME_IS_PAST = \\\"Reason: Time is past.\\\";\\n\\n    // MARK: basic token information.\\n    uint256 internal constant E18 = 1000000000000000000;\\n    uint256 public constant decimals = 18;\\n    uint256 public totalSupply;\\n\\n    struct Lock {\\n        uint256 amount;\\n        uint256 expiresAt;\\n    }\\n\\n    mapping(address =\\u003e uint256) public balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public approvals;\\n    mapping(address =\\u003e Lock[]) public lockup;\\n\\n    // MARK: events\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    event Locked(address _who, uint256 _index);\\n    event UnlockedAll(address _who);\\n    event UnlockedIndex(address _who, uint256 _index);\\n    event Burn(address indexed from, uint256 indexed value);\\n\\n    constructor() public {\\n        balances[msg.sender] = totalSupply;\\n    }\\n\\n    modifier transferParamsValidation(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    ) {\\n        require(_from != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_to != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_value \\u003e 0, ERROR_VALUE_NOT_VALID);\\n        require(balances[_from] \\u003e= _value, ERROR_BALANCE_NOT_ENOUGH);\\n        require(!isLocked(_from, _value), ERROR_LOCKED);\\n        _;\\n    }\\n\\n    // MARK: functions for view data\\n    function balanceOf(address _who) public view returns (uint256) {\\n        return balances[_who];\\n    }\\n\\n    function lockedBalanceOf(address _who) public view returns (uint256) {\\n        require(_who != address(0), ERROR_ADDRESS_NOT_VALID);\\n\\n        uint256 lockedBalance = 0;\\n        if (lockup[_who].length \\u003e 0) {\\n            Lock[] storage locks = lockup[_who];\\n\\n            uint256 length = locks.length;\\n            for (uint i = 0; i \\u003c length; i++) {\\n                if (now \\u003c locks[i].expiresAt) {\\n                    lockedBalance = lockedBalance.add(locks[i].amount);\\n                }\\n            }\\n        }\\n\\n        return lockedBalance;\\n    }\\n\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    ) external view returns (uint256) {\\n        return approvals[_owner][_spender];\\n    }\\n\\n    // true: _who can transfer token\\n    // false: _who can\\u0027t transfer token\\n    function isLocked(address _who, uint256 _value) public view returns (bool) {\\n        uint256 lockedBalance = lockedBalanceOf(_who);\\n        uint256 balance = balanceOf(_who);\\n\\n        if (lockedBalance \\u003c= 0) {\\n            return false;\\n        } else {\\n            return\\n                !(balance \\u003e lockedBalance \\u0026\\u0026\\n                    balance.sub(lockedBalance) \\u003e= _value);\\n        }\\n    }\\n\\n    // MARK: functions for token transfer\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        onlyWhenNotStopped\\n        transferParamsValidation(msg.sender, _to, _value)\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, _to, _value);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        external\\n        onlyWhenNotStopped\\n        transferParamsValidation(_from, _to, _value)\\n        returns (bool)\\n    {\\n        require(\\n            approvals[_from][msg.sender] \\u003e= _value,\\n            ERROR_APPROVED_BALANCE_NOT_ENOUGH\\n        );\\n\\n        approvals[_from][msg.sender] = approvals[_from][msg.sender].sub(_value);\\n\\n        _transfer(_from, _to, _value);\\n\\n        return true;\\n    }\\n\\n    function transferWithLock(\\n        address _to,\\n        uint256 _value,\\n        uint256 _time\\n    )\\n        external\\n        onlyOwner\\n        transferParamsValidation(msg.sender, _to, _value)\\n        returns (bool)\\n    {\\n        require(_time \\u003e now, ERROR_TIME_IS_PAST);\\n\\n        _lock(_to, _value, _time);\\n        _transfer(msg.sender, _to, _value);\\n\\n        return true;\\n    }\\n\\n    // MARK: utils for transfer authentication\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    ) external onlyWhenNotStopped returns (bool) {\\n        require(_spender != address(0), ERROR_VALUE_NOT_VALID);\\n        require(balances[msg.sender] \\u003e= _value, ERROR_BALANCE_NOT_ENOUGH);\\n        require(msg.sender != _spender, ERROR_ADDRESS_IS_SAME);\\n\\n        approvals[msg.sender][_spender] = _value;\\n\\n        emit Approval(msg.sender, _spender, _value);\\n\\n        return true;\\n    }\\n\\n    // MARK: utils for amount of token\\n    // Lock up token until specific date time.\\n    function unlock(\\n        address _who,\\n        uint256 _index\\n    ) external onlyOwner returns (bool) {\\n        uint256 length = lockup[_who].length;\\n        require(length \\u003e _index, ERROR_OUT_OF_INDEX);\\n\\n        lockup[_who][_index] = lockup[_who][length - 1];\\n        lockup[_who].length--;\\n\\n        emit UnlockedIndex(_who, _index);\\n\\n        return true;\\n    }\\n\\n    function unlockAll(address _who) external onlyOwner returns (bool) {\\n        require(lockup[_who].length \\u003e 0, ERROR_NO_LOCKUP);\\n\\n        delete lockup[_who];\\n        emit UnlockedAll(_who);\\n\\n        return true;\\n    }\\n\\n    function burn(uint256 _value) external {\\n        require(balances[msg.sender] \\u003e= _value, ERROR_BALANCE_NOT_ENOUGH);\\n        require(_value \\u003e 0, ERROR_VALUE_NOT_VALID);\\n\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\n\\n        totalSupply = totalSupply.sub(_value);\\n\\n        emit Burn(msg.sender, _value);\\n    }\\n\\n    // MARK: internal functions\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        balances[_from] = balances[_from].sub(_value);\\n        balances[_to] = balances[_to].add(_value);\\n\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    function _lock(\\n        address _who,\\n        uint256 _value,\\n        uint256 _dateTime\\n    ) internal onlyOwner {\\n        lockup[_who].push(Lock(_value, _dateTime));\\n\\n        emit Locked(_who, lockup[_who].length - 1);\\n    }\\n\\n    // destruct for only after token upgrade\\n    function close() public onlyOwner {\\n        selfdestruct(msg.sender);\\n    }\\n}\\n\"},\"Nestree.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./BaseToken.sol\\\";\\n\\ncontract Nestree is BaseToken {\\n    using SafeMath for uint256;\\n\\n    string internal constant ERROR_DUPLICATE_ADDRESS =\\n        \\\"Reason: msg.sender and receivers can not be the same.\\\";\\n\\n    // MARK: token information.\\n    string public constant name = \\\"Nestree\\\";\\n    string public constant symbol = \\\"EGG\\\";\\n    string public constant version = \\\"1.0.0\\\";\\n\\n    // MARK: events\\n    event ReferralDrop(\\n        address indexed from,\\n        address indexed to1,\\n        uint256 value1,\\n        address indexed to2,\\n        uint256 value2\\n    );\\n\\n    constructor() public {\\n        totalSupply = 3000000000 * E18;\\n        balances[msg.sender] = totalSupply;\\n    }\\n\\n    function referralDrop(\\n        address _to1,\\n        uint256 _value1,\\n        address _to2,\\n        uint256 _value2,\\n        address _sale,\\n        uint256 _fee\\n    ) external onlyWhenNotStopped returns (bool) {\\n        require(_to1 != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_to2 != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(_sale != address(0), ERROR_ADDRESS_NOT_VALID);\\n        require(\\n            balances[msg.sender] \\u003e= _value1.add(_value2).add(_fee),\\n            ERROR_VALUE_NOT_VALID\\n        );\\n        require(\\n            !isLocked(msg.sender, _value1.add(_value2).add(_fee)),\\n            ERROR_LOCKED\\n        );\\n        require(\\n            msg.sender != _to1 \\u0026\\u0026 msg.sender != _to2 \\u0026\\u0026 msg.sender != _sale,\\n            ERROR_DUPLICATE_ADDRESS\\n        );\\n\\n        balances[msg.sender] = balances[msg.sender].sub(\\n            _value1.add(_value2).add(_fee)\\n        );\\n\\n        if (_value1 \\u003e 0) {\\n            balances[_to1] = balances[_to1].add(_value1);\\n        }\\n\\n        if (_value2 \\u003e 0) {\\n            balances[_to2] = balances[_to2].add(_value2);\\n        }\\n\\n        if (_fee \\u003e 0) {\\n            balances[_sale] = balances[_sale].add(_fee);\\n        }\\n\\n        emit ReferralDrop(msg.sender, _to1, _value1, _to2, _value2);\\n        return true;\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\ncontract Ownable {\\n    string internal constant ERROR_NO_HAVE_PERMISSION =\\n        \\\"Reason: No have permission.\\\";\\n    string internal constant ERROR_IS_STOPPED = \\\"Reason: Is stopped.\\\";\\n    string internal constant ERROR_ADDRESS_NOT_VALID =\\n        \\\"Reason: Address is not valid.\\\";\\n    string internal constant ERROR_CALLER_ALREADY_OWNER =\\n        \\\"Reason: Caller already is owner\\\";\\n    string internal constant ERROR_NOT_PROPOSED_OWNER =\\n        \\\"Reason: Not proposed owner\\\";\\n\\n    bool private stopped;\\n    address private _owner;\\n    address private proposedOwner;\\n    mapping(address =\\u003e bool) private _allowed;\\n\\n    event Stopped();\\n    event Started();\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n    event Allowed(address indexed _address);\\n    event RemoveAllowed(address indexed _address);\\n\\n    constructor() internal {\\n        stopped = false;\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), ERROR_NO_HAVE_PERMISSION);\\n        _;\\n    }\\n\\n    modifier onlyAllowed() {\\n        require(isAllowed() || isOwner(), ERROR_NO_HAVE_PERMISSION);\\n        _;\\n    }\\n\\n    modifier onlyWhenNotStopped() {\\n        require(!isStopped(), ERROR_IS_STOPPED);\\n        _;\\n    }\\n\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    function isAllowed() public view returns (bool) {\\n        return _allowed[msg.sender];\\n    }\\n\\n    function allow(address _target) external onlyOwner returns (bool) {\\n        _allowed[_target] = true;\\n        emit Allowed(_target);\\n        return true;\\n    }\\n\\n    function removeAllowed(address _target) external onlyOwner returns (bool) {\\n        _allowed[_target] = false;\\n        emit RemoveAllowed(_target);\\n        return true;\\n    }\\n\\n    function isStopped() public view returns (bool) {\\n        if (isOwner() || isAllowed()) {\\n            return false;\\n        } else {\\n            return stopped;\\n        }\\n    }\\n\\n    function stop() public onlyOwner {\\n        _stop();\\n    }\\n\\n    function start() public onlyOwner {\\n        _start();\\n    }\\n\\n    function proposeOwner(address _proposedOwner) public onlyOwner {\\n        require(msg.sender != _proposedOwner, ERROR_CALLER_ALREADY_OWNER);\\n        proposedOwner = _proposedOwner;\\n    }\\n\\n    function claimOwnership() public {\\n        require(msg.sender == proposedOwner, ERROR_NOT_PROPOSED_OWNER);\\n\\n        emit OwnershipTransferred(_owner, proposedOwner);\\n\\n        _owner = proposedOwner;\\n        proposedOwner = address(0);\\n    }\\n\\n    function _stop() internal {\\n        emit Stopped();\\n        stopped = true;\\n    }\\n\\n    function _start() internal {\\n        emit Started();\\n        stopped = false;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.5.8;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Multiplies two unsigned integers, reverts on overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b \\u003e 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two unsigned integers, reverts on overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n     * reverts when dividing by zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to1\",\"type\":\"address\"},{\"name\":\"_value1\",\"type\":\"uint256\"},{\"name\":\"_to2\",\"type\":\"address\"},{\"name\":\"_value2\",\"type\":\"uint256\"},{\"name\":\"_sale\",\"type\":\"address\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"referralDrop\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"lockedBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"removeAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"unlock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"approvals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockup\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"proposeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"unlockAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"transferWithLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"allow\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to1\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value1\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to2\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value2\",\"type\":\"uint256\"}],\"name\":\"ReferralDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"UnlockedAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"UnlockedIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"Allowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"RemoveAllowed\",\"type\":\"event\"}]", "ContractName": "Nestree", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://4da670ae6a313d2059068bef220a43b2a1bf653d7d2d95c9acd105f34203e1d3"}