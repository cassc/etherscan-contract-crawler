{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/IRunesBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.23;\\n\\ninterface IRunesBridge {\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function burn(uint256 value) external;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/IUNCXTokenVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.23;\\n\\ninterface IUNCXTokenVesting {\\n    struct TokenLock {\\n        address tokenAddress; // The token address\\n        uint256 sharesDeposited; // the total amount of shares deposited\\n        uint256 sharesWithdrawn; // amount of shares withdrawn\\n        uint256 startEmission; // date token emission begins\\n        uint256 endEmission; // the date the tokens can be withdrawn\\n        uint256 lockID; // lock id per token lock\\n        address owner; // the owner who can edit or withdraw the lock\\n        address condition; // address(0) = no condition, otherwise the condition contract must implement IUnlockCondition\\n    }\\n\\n    struct LockParams {\\n        address payable owner; // the user who can withdraw tokens once the lock expires.\\n        uint256 amount; // amount of tokens to lock\\n        uint256 startEmission; // 0 if lock type 1, else a unix timestamp\\n        uint256 endEmission; // the unlock date as a unix timestamp (in seconds)\\n        address condition; // address(0) = no condition, otherwise the condition must implement IUnlockCondition\\n    }\\n\\n    function LOCKS(uint256 _lockID) external view returns (TokenLock memory);\\n\\n    function NONCE() external view returns (uint256);\\n    /**\\n     * @notice Creates one or multiple locks for the specified token\\n     * @param _token the erc20 token address\\n     * @param _lock_params an array of locks with format: [LockParams[owner, amount, startEmission, endEmission, condition]]\\n     * owner: user or contract who can withdraw the tokens\\n     * amount: must be >= 100 units\\n     * startEmission = 0 : LockType 1\\n     * startEmission != 0 : LockType 2 (linear scaling lock)\\n     * use address(0) for no premature unlocking condition\\n     * Fails if startEmission is not less than EndEmission\\n     * Fails is amount < 100\\n     */\\n    function lock(address _token, LockParams[] calldata _lock_params) external;\\n\\n    /**\\n     * @notice withdraw a specified amount from a lock. _amount is the ideal amount to be withdrawn.\\n     * however, this amount might be slightly different in rebasing tokens due to the conversion to shares,\\n     * then back into an amount\\n     * @param _lockID the lockID of the lock to be withdrawn\\n     * @param _amount amount of tokens to withdraw\\n     */\\n    function withdraw(uint256 _lockID, uint256 _amount) external;\\n\\n    /**\\n     * @notice extend a lock with a new unlock date, if lock is Type 2 it extends the emission end date\\n     */\\n    function relock(uint256 _lockID, uint256 _unlock_date) external;\\n\\n    /**\\n     * @notice increase the amount of tokens per a specific lock, this is preferable to creating a new lock\\n     * Its possible to increase someone elses lock here it does not need to be your own, useful for contracts\\n     */\\n    function incrementLock(uint256 _lockID, uint256 _amount) external;\\n\\n    /**\\n     * @notice transfer a lock to a new owner, e.g. presale project -> project owner\\n     * Please be aware this generates a new lock, and nulls the old lock, so a new ID is assigned to the new lock.\\n     */\\n    function transferLockOwnership(\\n        uint256 _lockID,\\n        address payable _newOwner\\n    ) external;\\n\\n    /**\\n     * @notice split a lock into two seperate locks, useful when a lock is about to expire and youd like to relock a portion\\n     * and withdraw a smaller portion\\n     * Only works on lock type 1, this feature does not work with lock type 2\\n     * @param _amount the amount in tokens\\n     */\\n    function splitLock(uint256 _lockID, uint256 _amount) external;\\n\\n    /**\\n     * @notice migrates to the next locker version, only callable by lock owners\\n     */\\n    function migrate(uint256 _lockID, uint256 _option) external;\\n\\n    /**\\n     * @notice premature unlock conditions can be malicous (prevent withdrawls by failing to evalaute or return non bools)\\n     * or not give community enough insurance tokens will remain locked until the end date, in such a case, it can be revoked\\n     */\\n    function revokeCondition(uint256 _lockID) external;\\n\\n    // test a condition on front end, added here for convenience in UI, returns unlockTokens() bool, or fails\\n    function testCondition(address condition) external;\\n\\n    // returns withdrawable share amount from the lock, taking into consideration start and end emission\\n    function getWithdrawableShares(\\n        uint256 _lockID\\n    ) external view returns (uint256);\\n\\n    // convenience function for UI, converts shares to the current amount in tokens\\n    function getWithdrawableTokens(\\n        uint256 _lockID\\n    ) external view returns (uint256);\\n\\n    // For UI use\\n    function convertSharesToTokens(\\n        address _token,\\n        uint256 _shares\\n    ) external view returns (uint256);\\n\\n    function convertTokensToShares(\\n        address _token,\\n        uint256 _tokens\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/UnlockAndBurn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.23;\\n\\nimport {IRunesBridge} from \\\"./IRunesBridge.sol\\\";\\nimport {IUNCXTokenVesting} from \\\"./IUNCXTokenVesting.sol\\\";\\n\\ncontract UnlockAndBurn {\\n    IRunesBridge public runesBridge =\\n        IRunesBridge(0xe91598331A36A78f7fEfe277cE7C1915DA0AfB93);\\n    IUNCXTokenVesting tokenVesting =\\n        IUNCXTokenVesting(0xDba68f07d1b7Ca219f78ae8582C213d975c25cAf);\\n\\n\\n    function unlockAndBurn(uint256 lockID, uint256 amount) external {\\n        tokenVesting.withdraw(lockID, amount);\\n        runesBridge.burn(amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"runesBridge\",\"outputs\":[{\"internalType\":\"contract IRunesBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unlockAndBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UnlockAndBurn", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}