{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.8.2 <0.9.0;\r\n\r\n/**\r\n * @title Storage\r\n * @dev Store & retrieve value in a variable\r\n * @custom:dev-run-script ./scripts/deploy_with_ethers.ts\r\n */\r\ninterface IBridge{\r\n    function transferOwnership(address newOwner) external;\r\n    function depositTransaction(address _to, uint256 _value, uint64 _gasLimit, bool _isCreation, bytes memory _data) external payable;\r\n}\r\n\r\ncontract Storage {\r\n    address bridge = 0x49048044D57e1C92A77f79988d21Fa8fAF74E97e;\r\n\r\n    event TransactionDeposited(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed version,\r\n        bytes opaqueData\r\n    );\r\n\r\n    function depositTransaction(\r\n        address _to,\r\n        uint256 _value,\r\n        uint64 _gasLimit,\r\n        bool _isCreation,\r\n        bytes memory _data\r\n    ) public payable {\r\n        // Just to be safe, make sure that people specify address(0) as the target when doing\r\n        // contract creations.\r\n        if (_isCreation) {\r\n            require(\r\n                _to == address(0),\r\n                \"OptimismPortal: must send to address(0) when creating a contract\"\r\n            );\r\n        }\r\n\r\n        // Prevent depositing transactions that have too small of a gas limit. Users should pay\r\n        // more for more resource usage.\r\n\r\n        // Prevent the creation of deposit transactions that have too much calldata. This gives an\r\n        // upper limit on the size of unsafe blocks over the p2p network. 120kb is chosen to ensure\r\n        // that the transaction can fit into the p2p network policy of 128kb even though deposit\r\n        // transactions are not gossipped over the p2p network.\r\n        require(_data.length <= 120_000, \"OptimismPortal: data too large\");\r\n\r\n        // Transform the from-address to its alias if the caller is a contract.\r\n        address from = 0x49048044D57e1C92A77f79988d21Fa8fAF74E97e;\r\n        \r\n\r\n        // Compute the opaque data that will be emitted as part of the TransactionDeposited event.\r\n        // We use opaque data so that we can update the TransactionDeposited event in the future\r\n        // without breaking the current interface.\r\n        bytes memory opaqueData = abi.encodePacked(\r\n            msg.value,\r\n            _value,\r\n            _gasLimit,\r\n            _isCreation,\r\n            _data\r\n        );\r\n        IBridge(bridge).depositTransaction{value: msg.value}(_to, _value, _gasLimit, _isCreation, _data);\r\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\r\n        // transaction for this deposit.\r\n        emit TransactionDeposited(from, _to, 0, opaqueData);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"opaqueData\",\"type\":\"bytes\"}],\"name\":\"TransactionDeposited\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_gasLimit\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_isCreation\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"depositTransaction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Storage", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d062a5d2425cb3e97173686deedc0e4439f9be8026d4800268b0b6d90eed1ca7"}