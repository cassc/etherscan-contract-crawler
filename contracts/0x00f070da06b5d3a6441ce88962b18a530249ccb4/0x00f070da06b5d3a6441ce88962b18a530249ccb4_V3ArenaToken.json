{"SourceCode": "// ARENA DEATHMATCH - Warning: When the countdown ends on arenadm.io, the contest is over and liquidity will be pulled. Exit before the timer ends and trade at your own risk.\n// --------\n// Token Deployed using Saintbot.\n// Contract Renounced automatically.\n// Liquidity Locked on UNCX, 0 Owner Tokens, Anti-Rug by default.\n// Deploy and manage fair launch anti-rug tokens seamlessly and lightning-fast with low gas on our free-to-use Telegram bot.\n// --------\n// Website: https://arenadm.io/\n// Twitter: https://twitter.com/arenadeathmatch\n// Telegram: https://t.me/arenaportal\n// Gitbook: https://docs.arenadm.io\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.21;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev Initializes the contract setting the deployer as the initial owner.\n   */\n  constructor() {\n    _transferOwnership(_msgSender());\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby removing any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"../IERC20.sol\"; */\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n   *\n   * The default value of {decimals} is 18. To select a different value for\n   * {decimals} you should overload it.\n   *\n   * All two of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(\n    address account\n  ) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(\n    address owner,\n    address spender\n  ) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(\n    address spender,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * Requirements:\n   *\n   * - `sender` and `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``sender``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\n    require(\n      currentAllowance >= amount,\n      \"ERC20: transfer amount exceeds allowance\"\n    );\n    unchecked {\n      _approve(sender, _msgSender(), currentAllowance - amount);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  ) public virtual returns (bool) {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender] + addedValue\n    );\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  ) public virtual returns (bool) {\n    uint256 currentAllowance = _allowances[_msgSender()][spender];\n    require(\n      currentAllowance >= subtractedValue,\n      \"ERC20: decreased allowance below zero\"\n    );\n    unchecked {\n      _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `sender` to `recipient`.\n   *\n   * This internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `sender` cannot be the zero address.\n   * - `recipient` cannot be the zero address.\n   * - `sender` must have a balance of at least `amount`.\n   */\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    uint256 senderBalance = _balances[sender];\n    require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[sender] = senderBalance - amount;\n    }\n    _balances[recipient] += amount;\n\n    emit Transfer(sender, recipient, amount);\n\n    _afterTokenTransfer(sender, recipient, amount);\n  }\n\n  /**\n   * @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    _balances[account] += amount;\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * has been transferred to `to`.\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `+` operator.\n   *\n   * Requirements:\n   *\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a + b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a - b;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity's `*` operator.\n   *\n   * Requirements:\n   *\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator.\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * CAUTION: This function is deprecated because it requires allocating memory for the error\n   * message unnecessarily. For custom revert reasons use {trySub}.\n   *\n   * Counterpart to Solidity's `-` operator.\n   *\n   * Requirements:\n   *\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b <= a, errorMessage);\n      return a - b;\n    }\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   *\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    unchecked {\n      require(b > 0, errorMessage);\n      return a / b;\n    }\n  }\n}\n\ninterface IUniswapV2Factory {\n  function createPair(\n    address tokenA,\n    address tokenB\n  ) external returns (address pair);\n}\n\ninterface IUniswapV2Pair {\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n}\n\ninterface IUniswapV2Router02 {\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n}\n\ninterface IERCBurn {\n  function burn(uint256 _amount) external;\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender) external returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IUNCX {\n  function lockLPToken(\n    address _lpToken,\n    uint256 _amount,\n    uint256 _unlock_date,\n    address payable _referral,\n    bool _fee_in_eth,\n    address payable _withdrawer\n  ) external payable;\n\n  struct FeeStruct {\n    uint256 ethFee; // Small eth fee to prevent spam on the platform\n    IERCBurn secondaryFeeToken; // UNCX or UNCL\n    uint256 secondaryTokenFee; // optional, UNCX or UNCL\n    uint256 secondaryTokenDiscount; // discount on liquidity fee for burning secondaryToken\n    uint256 liquidityFee; // fee on univ2 liquidity tokens\n    uint256 referralPercent; // fee for referrals\n    IERCBurn referralToken; // token the refferer must hold to qualify as a referrer\n    uint256 referralHold; // balance the referrer must hold to qualify as a referrer\n    uint256 referralDiscount; // discount on flatrate fees for using a valid referral address\n  }\n\n  function gFees() external returns (FeeStruct memory);\n}\n\ninterface IRefSys {\n  function getRefReceiver(\n    bytes memory _refCode\n  ) external view returns (address receiverWallet);\n}\n\ncontract V3ArenaToken is ERC20, Ownable {\n  using SafeMath for uint256;\n\n  IUniswapV2Router02 public immutable uniswapV2Router;\n  address public immutable uniswapV2Pair;\n  address public constant deadAddress = address(0xdead);\n\n  bool private swapping;\n\n  address public teamWallet;\n\n  uint256 public maxTransactionAmount;\n  uint256 public swapTokensAtAmount;\n  uint256 public maxSell;\n  uint256 public maxWallet;\n\n  bool public tradingActive = false;\n  bool public swapEnabled = false;\n\n  uint256 public immutable buyTotalFees;\n  uint256 public immutable sellTotalFees;\n\n  // exclude from fees and max transaction amount\n  mapping(address => bool) private _isExcludedFromFees;\n  mapping(address => bool) public _isExcludedMaxTransactionAmount;\n\n  // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\n  // could be subject to a maximum transfer amount\n  mapping(address => bool) public automatedMarketMakerPairs;\n\n  event ExcludeFromFees(address indexed account, bool isExcluded);\n\n  event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n\n  event teamWalletUpdated(address indexed newWallet, address indexed oldWallet);\n\n  address public immutable REF;\n\n  IRefSys public constant REF_SYS =\n    IRefSys(0x8A99c005C7B425ce999441afeE22D4987F7a9869);\n  address public constant MAINNET_BOT_TRADING_RECEIVER =\n    0xD5E2E43e30b706de8A0e01e72a6aBa2b8930af44;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint256 _totalSupply,\n    uint256 _buyTaxes,\n    uint256 _sellTaxes,\n    address _lockOwnerAndTaxReceiver,\n    bytes memory _ref\n  ) payable ERC20(_name, _symbol) {\n    require(\n      msg.value >= 0.4 ether,\n      \"weth liquidity need to be bigger than 0.4\"\n    );\n    require(\n      _totalSupply >= 10 && _totalSupply <= 1_000_000_000_000_000,\n      \"InvalidSupply()\"\n    );\n    require(_buyTaxes >= 1 && _buyTaxes <= 7, \"InvalidTaxes()\");\n    require(_sellTaxes >= 1 && _sellTaxes <= 7, \"InvalidTaxes()\");\n\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\n      0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n    );\n\n    excludeFromMaxTransaction(address(_uniswapV2Router), true);\n\n    uniswapV2Router = _uniswapV2Router;\n\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(\n      address(this),\n      _uniswapV2Router.WETH()\n    );\n\n    excludeFromMaxTransaction(address(uniswapV2Pair), true);\n    _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\n\n    uint256 totalSupply_ = _totalSupply * 1e18;\n\n    maxTransactionAmount = (totalSupply_ * 3) / 100;\n    maxWallet = (totalSupply_ * 6) / 100;\n    swapTokensAtAmount = (totalSupply_ * 5) / 10000; // 0.05%\n\n    buyTotalFees = _buyTaxes;\n    sellTotalFees = _sellTaxes;\n\n    maxSell = (totalSupply_ * 5) / 1_000;\n\n    teamWallet = _lockOwnerAndTaxReceiver; // set as team wallet\n\n    // exclude from paying fees or having max transaction amount\n    excludeFromFees(address(this), true);\n    excludeFromFees(address(0xdead), true);\n\n    excludeFromMaxTransaction(address(this), true);\n    excludeFromMaxTransaction(address(0xdead), true);\n    excludeFromMaxTransaction(address(uniswapV2Router), true);\n    excludeFromMaxTransaction(msg.sender, true);\n\n    REF = REF_SYS.getRefReceiver(_ref);\n\n    /*\n            _mint is an internal function in ERC20.sol that is only called here,\n            and CANNOT be called ever again\n        */\n    _mint(address(this), totalSupply_);\n  }\n\n  function addLiquidity() external {\n    require(msg.sender == owner(), \"auth\");\n\n    _approve(address(this), address(uniswapV2Router), totalSupply());\n    tradingActive = true;\n    swapEnabled = true;\n\n    uniswapV2Router.addLiquidityETH{value: address(this).balance}(\n      address(this),\n      balanceOf(address(this)),\n      0,\n      0,\n      msg.sender,\n      block.timestamp\n    );\n\n    renounceOwnership();\n  }\n\n  receive() external payable {}\n\n  function excludeFromMaxTransaction(address updAds, bool isEx) internal {\n    _isExcludedMaxTransactionAmount[updAds] = isEx;\n  }\n\n  function excludeFromFees(address account, bool excluded) internal {\n    _isExcludedFromFees[account] = excluded;\n    emit ExcludeFromFees(account, excluded);\n  }\n\n  function setAutomatedMarketMakerPair(address pair, bool value) internal {\n    require(\n      pair != uniswapV2Pair,\n      \"The pair cannot be removed from automatedMarketMakerPairs\"\n    );\n\n    _setAutomatedMarketMakerPair(pair, value);\n  }\n\n  function _setAutomatedMarketMakerPair(address pair, bool value) private {\n    automatedMarketMakerPairs[pair] = value;\n\n    emit SetAutomatedMarketMakerPair(pair, value);\n  }\n\n  function updateTeamWallet(address newWallet) external {\n    require(msg.sender == teamWallet, \"auth\");\n\n    emit teamWalletUpdated(newWallet, teamWallet);\n\n    teamWallet = newWallet;\n  }\n\n  function isExcludedFromFees(address account) public view returns (bool) {\n    return _isExcludedFromFees[account];\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    if (amount == 0) {\n      super._transfer(from, to, 0);\n      return;\n    }\n\n    if (to != address(0) && to != address(0xdead) && !swapping) {\n      if (!tradingActive) {\n        require(\n          _isExcludedFromFees[from] || _isExcludedFromFees[to],\n          \"Trading is not active.\"\n        );\n      }\n\n      //when buy\n      if (\n        automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]\n      ) {\n        require(\n          amount <= maxTransactionAmount,\n          \"Buy transfer amount exceeds the maxTransactionAmount.\"\n        );\n        require(amount + balanceOf(to) <= maxWallet, \"Max wallet exceeded\");\n      }\n      //when sell\n      else if (\n        automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]\n      ) {\n        require(\n          amount <= maxTransactionAmount,\n          \"Sell transfer amount exceeds the maxTransactionAmount.\"\n        );\n      } else if (!_isExcludedMaxTransactionAmount[to]) {\n        require(amount + balanceOf(to) <= maxWallet, \"Max wallet exceeded\");\n      }\n    }\n\n    uint256 contractTokenBalance = balanceOf(address(this));\n\n    bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n    if (\n      canSwap &&\n      swapEnabled &&\n      !swapping &&\n      !automatedMarketMakerPairs[from] &&\n      !_isExcludedFromFees[from] &&\n      !_isExcludedFromFees[to]\n    ) {\n      swapping = true;\n\n      swapBack();\n\n      swapping = false;\n    }\n\n    bool takeFee = !swapping;\n\n    // if any account belongs to _isExcludedFromFee account then remove the fee\n    if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n      takeFee = false;\n    }\n\n    uint256 fees = 0;\n\n    // only take fees on buys/sells, do not take on wallet transfers\n    if (takeFee) {\n      // on sell\n      if (automatedMarketMakerPairs[to]) {\n        fees = amount.mul(sellTotalFees).div(100);\n      }\n      // on buy\n      else if (automatedMarketMakerPairs[from]) {\n        fees = amount.mul(buyTotalFees).div(100);\n      }\n\n      if (fees > 0) {\n        super._transfer(from, address(this), fees);\n      }\n\n      amount -= fees;\n    }\n\n    super._transfer(from, to, amount);\n  }\n\n  function swapTokensForEth(uint256 tokenAmount) private {\n    // generate the uniswap pair path of token -> weth\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n\n    uint256 sellAmount_ = min(tokenAmount, min(tokenAmount, maxSell));\n\n    _approve(address(this), address(uniswapV2Router), sellAmount_);\n\n    // make the swap\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n      sellAmount_,\n      0, // accept any amount of ETH\n      path,\n      address(this),\n      block.timestamp\n    );\n  }\n\n  function manualSwap(uint256 _amount) external {\n    require(_msgSender() == teamWallet, \"auth\");\n\n    uint256 tokenBalance = _amount;\n\n    if (tokenBalance > 0) {\n      swapTokensForEth(tokenBalance);\n    }\n    uint256 ethBalance = address(this).balance;\n    if (ethBalance > 0) {\n      (bool ok, ) = teamWallet.call{value: ethBalance}(\"\");\n      require(ok, \"failed\");\n    }\n  }\n\n  function min(uint256 a, uint256 b) private pure returns (uint256) {\n    return (a > b) ? b : a;\n  }\n\n  function swapBack() private {\n    uint256 contractBalance = balanceOf(address(this));\n\n    swapTokensForEth(contractBalance);\n\n    uint256 ethBalance = address(this).balance;\n\n    if (REF == address(0)) {\n      // If user has not entered a ref code, he will receive 4% fees\n      uint256 taxWalletAmount = (ethBalance * 80) / 100;\n\n      // Send 80% of the fees\n      (bool success, ) = teamWallet.call{value: taxWalletAmount}(\"\");\n\n      require(success, \"failed sending eth\");\n\n      address payable SAINTBOT_TAXES = payable(MAINNET_BOT_TRADING_RECEIVER);\n\n      // Send 100% - 80% of the fees to us\n      (success, ) = SAINTBOT_TAXES.call{value: ethBalance - taxWalletAmount}(\n        \"\"\n      );\n\n      require(success, \"failed sending eth\");\n    } else {\n      // If he did enter a ref code, he will receive 4.1% fees\n      uint256 taxWalletAmount = (ethBalance * 82) / 100;\n\n      // Send 82% of the fees\n      (bool success, ) = teamWallet.call{value: taxWalletAmount}(\"\");\n\n      require(success, \"failed sending eth\");\n\n      // 0.15% to ref address, meaning that its 3% out of the 5%\n      payable(REF).transfer((taxWalletAmount * 3) / 100);\n\n      address payable SAINTBOT_TAXES = payable(MAINNET_BOT_TRADING_RECEIVER);\n\n      (success, ) = SAINTBOT_TAXES.call{value: (ethBalance * 15) / 100}(\"\");\n\n      require(success, \"failed sending eth\");\n    }\n  }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyTaxes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellTaxes\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lockOwnerAndTaxReceiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_ref\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"}],\"name\":\"teamWalletUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAINNET_BOT_TRADING_RECEIVER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REF\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REF_SYS\",\"outputs\":[{\"internalType\":\"contract IRefSys\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updateTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "V3ArenaToken", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000400000000000000000000000054da087598f0f8604663dd455e5933a429b539dc000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000000166377616c6b696e67206d79206665656c7320617761790000000000000000000000000000000000000000000000000000000000000000000000000000000000054645454c530000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}