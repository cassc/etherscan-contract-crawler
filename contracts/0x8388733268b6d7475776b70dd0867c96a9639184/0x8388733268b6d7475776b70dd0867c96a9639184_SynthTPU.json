{"SourceCode": "/** \r\nWebsite: http://synthtpu.cloud\r\nTelegram: https://t.me/SynthTPU\r\nTwitter: https://twitter.com/SynthTPU\r\n**/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    return account.code.length > 0;\r\n  }\r\n\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n    (bool success, ) = recipient.call{value: amount}(\"\");\r\n    require(\r\n      success,\r\n      \"Address: unable to send value, recipient may have reverted\"\r\n    );\r\n  }\r\n\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n  }\r\n\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionCallWithValue(\r\n        target,\r\n        data,\r\n        value,\r\n        \"Address: low-level call with value failed\"\r\n      );\r\n  }\r\n\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(\r\n      address(this).balance >= value,\r\n      \"Address: insufficient balance for call\"\r\n    );\r\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n    return\r\n      verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n  }\r\n\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data\r\n  ) internal view returns (bytes memory) {\r\n    return\r\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n  }\r\n\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return\r\n      verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n  }\r\n\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionDelegateCall(\r\n        target,\r\n        data,\r\n        \"Address: low-level delegate call failed\"\r\n      );\r\n  }\r\n\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return\r\n      verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n  }\r\n\r\n  function verifyCallResultFromTarget(\r\n    address target,\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    if (success) {\r\n      if (returndata.length == 0) {\r\n        // only check isContract if the call was successful and the return data is empty\r\n        // otherwise we already know that it was a contract\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n      }\r\n      return returndata;\r\n    } else {\r\n      _revert(returndata, errorMessage);\r\n    }\r\n  }\r\n\r\n  function verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      _revert(returndata, errorMessage);\r\n    }\r\n  }\r\n\r\n  function _revert(\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure {\r\n    // Look for revert reason and bubble it up if present\r\n    if (returndata.length > 0) {\r\n      // The easiest way to bubble the revert reason is using memory via assembly\r\n      /// @solidity memory-safe-assembly\r\n      assembly {\r\n        let returndata_size := mload(returndata)\r\n        revert(add(32, returndata), returndata_size)\r\n      }\r\n    } else {\r\n      revert(errorMessage);\r\n    }\r\n  }\r\n}\r\n\r\nabstract contract Context {\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n  ) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXFactory {\r\n  function createPair(\r\n    address tokenA,\r\n    address tokenB\r\n  ) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n  function factory() external pure returns (address);\r\n\r\n  function WETH() external pure returns (address);\r\n\r\n  function addLiquidityETH(\r\n    address token,\r\n    uint amountTokenDesired,\r\n    uint amountTokenMin,\r\n    uint amountETHMin,\r\n    address to,\r\n    uint deadline\r\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint amountIn,\r\n    uint amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint deadline\r\n  ) external;\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  constructor() {\r\n    _transferOwnership(_msgSender());\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    _checkOwner();\r\n    _;\r\n  }\r\n\r\n  function owner() public view virtual returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  function _checkOwner() internal view virtual {\r\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n  }\r\n\r\n  function renounceOwnership() public virtual onlyOwner {\r\n    _transferOwnership(address(0));\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public virtual onlyOwner {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal virtual {\r\n    address oldOwner = _owner;\r\n    _owner = newOwner;\r\n    emit OwnershipTransferred(oldOwner, newOwner);\r\n  }\r\n}\r\n\r\ncontract SynthTPU is IERC20, Ownable {\r\n  using Address for address;\r\n\r\n  address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n  address ZERO = 0x0000000000000000000000000000000000000000;\r\n\r\n  string constant _name = \"SynthTPU\";\r\n  string constant _symbol = \"STPU\";\r\n  uint8 constant _decimals = 18;\r\n\r\n  uint256 _totalSupply = 100_000_000 * (10 ** _decimals);\r\n  uint256 _maxBuyTxAmount = (_totalSupply * 1) / 100;\r\n  uint256 _maxSellTxAmount = (_totalSupply * 1) / 100;\r\n  uint256 _maxWalletSize = (_totalSupply * 1) / 100;\r\n\r\n  mapping(address => uint256) _balances;\r\n  mapping(address => mapping(address => uint256)) _allowances;\r\n\r\n  mapping(uint256 => uint256) public swapBackCounter;\r\n  uint256 public swapBackRateLimit = 3;\r\n\r\n  mapping(address => bool) public isFeeExempt;\r\n  mapping(address => bool) public isTxLimitExempt;\r\n  mapping(address => bool) public isLiquidityCreator;\r\n\r\n  uint256 marketingBuyFee = 1000;\r\n  uint256 marketingSellFee = 6000;\r\n  uint256 liquidityBuyFee = 0;\r\n  uint256 liquiditySellFee = 0;\r\n  uint256 totalBuyFee = marketingBuyFee + liquidityBuyFee;\r\n  uint256 totalSellFee = marketingSellFee + liquiditySellFee;\r\n  uint256 feeDenominator = 10000;\r\n\r\n  bool public transferTax = false;\r\n\r\n  address payable public liquidityFeeReceiver = payable(0x895E3541dE993590E101028d7720Eb67315C46A5);\r\n  address payable public marketingFeeReceiver = payable(0x895E3541dE993590E101028d7720Eb67315C46A5);\r\n\r\n  IDEXRouter public router;\r\n  address routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n  mapping(address => bool) liquidityPools;\r\n  address public pair;\r\n\r\n  mapping(address => uint256) public blacklist;\r\n  uint256 public blacklistCount;\r\n\r\n  uint256 public launchBlock;\r\n  uint256 public launchTimestamp;\r\n  bool isTradingEnabled = false;\r\n\r\n  bool public swapEnabled = false;\r\n  uint256 public swapThreshold = _totalSupply / 1000;\r\n  uint256 public swapAtMinimum = _totalSupply / 10000;\r\n  bool inSwap;\r\n\r\n  modifier swapping() {\r\n    inSwap = true;\r\n    _;\r\n    inSwap = false;\r\n  }\r\n\r\n  mapping(address => bool) teamMembers;\r\n\r\n  modifier onlyTeam() {\r\n    require(\r\n      teamMembers[_msgSender()] || msg.sender == owner(),\r\n      \"Caller is not a team member\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  event WalletBlacklisted(address, address, uint256);\r\n\r\n  constructor() {\r\n    router = IDEXRouter(routerAddress);\r\n    pair = IDEXFactory(router.factory()).createPair(\r\n      router.WETH(),\r\n      address(this)\r\n    );\r\n    liquidityPools[pair] = true;\r\n    _allowances[owner()][routerAddress] = type(uint256).max;\r\n    _allowances[address(this)][routerAddress] = type(uint256).max;\r\n\r\n    isFeeExempt[owner()] = true;\r\n    isLiquidityCreator[owner()] = true;\r\n\r\n    isTxLimitExempt[address(this)] = true;\r\n    isTxLimitExempt[owner()] = true;\r\n    isTxLimitExempt[routerAddress] = true;\r\n    isTxLimitExempt[DEAD] = true;\r\n\r\n    _balances[owner()] = _totalSupply;\r\n\r\n    emit Transfer(address(0), owner(), _totalSupply);\r\n  }\r\n\r\n  receive() external payable {}\r\n\r\n  function totalSupply() external view override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function decimals() external pure returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  function symbol() external pure returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function name() external pure returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  function getOwner() external view returns (address) {\r\n    return owner();\r\n  }\r\n\r\n  function maxBuyTxTokens() external view returns (uint256) {\r\n    return _maxBuyTxAmount / (10 ** _decimals);\r\n  }\r\n\r\n  function maxSellTxTokens() external view returns (uint256) {\r\n    return _maxSellTxAmount / (10 ** _decimals);\r\n  }\r\n\r\n  function maxWalletTokens() external view returns (uint256) {\r\n    return _maxWalletSize / (10 ** _decimals);\r\n  }\r\n\r\n  function balanceOf(address account) public view override returns (uint256) {\r\n    return _balances[account];\r\n  }\r\n\r\n  function allowance(\r\n    address holder,\r\n    address spender\r\n  ) external view override returns (uint256) {\r\n    return _allowances[holder][spender];\r\n  }\r\n\r\n  function approve(\r\n    address spender,\r\n    uint256 amount\r\n  ) public override returns (bool) {\r\n    _allowances[msg.sender][spender] = amount;\r\n    emit Approval(msg.sender, spender, amount);\r\n    return true;\r\n  }\r\n\r\n  function approveMaxAmount(address spender) external returns (bool) {\r\n    return approve(spender, type(uint256).max);\r\n  }\r\n\r\n  function setTeamMember(address _team, bool _enabled) external onlyOwner {\r\n    teamMembers[_team] = _enabled;\r\n  }\r\n\r\n  function airdrop(\r\n    address[] calldata addresses,\r\n    uint256[] calldata amounts\r\n  ) external onlyOwner {\r\n    require(addresses.length > 0 && amounts.length == addresses.length);\r\n    address from = msg.sender;\r\n\r\n    for (uint i = 0; i < addresses.length; i++) {\r\n      if (!liquidityPools[addresses[i]] && !isLiquidityCreator[addresses[i]]) {\r\n        _basicTransfer(from, addresses[i], amounts[i] * (10 ** _decimals));\r\n      }\r\n    }\r\n  }\r\n\r\n  function clearStuckBalance(\r\n    uint256 amountPercentage,\r\n    address adr\r\n  ) external onlyTeam {\r\n    uint256 amountETH = address(this).balance;\r\n\r\n    if (amountETH > 0) {\r\n      (bool sent, ) = adr.call{value: (amountETH * amountPercentage) / 100}(\"\");\r\n      require(sent, \"Failed to transfer funds\");\r\n    }\r\n  }\r\n\r\n  function blacklistWallets(\r\n    address[] calldata _wallets,\r\n    bool _blacklist\r\n  ) external onlyTeam {\r\n    for (uint i = 0; i < _wallets.length; i++) {\r\n      if (_blacklist) {\r\n        blacklistCount++;\r\n        emit WalletBlacklisted(tx.origin, _wallets[i], block.number);\r\n      } else {\r\n        if (blacklist[_wallets[i]] != 0) blacklistCount--;\r\n      }\r\n      blacklist[_wallets[i]] = _blacklist ? block.number : 0;\r\n    }\r\n  }\r\n\r\n  function transfer(\r\n    address recipient,\r\n    uint256 amount\r\n  ) external override returns (bool) {\r\n    return _transferFrom(msg.sender, recipient, amount);\r\n  }\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external override returns (bool) {\r\n    if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n      _allowances[sender][msg.sender] =\r\n        _allowances[sender][msg.sender] -\r\n        amount;\r\n    }\r\n\r\n    return _transferFrom(sender, recipient, amount);\r\n  }\r\n\r\n  function _transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) internal returns (bool) {\r\n    require(sender != address(0), \"ERC20: transfer from 0x0\");\r\n    require(recipient != address(0), \"ERC20: transfer to 0x0\");\r\n    require(amount > 0, \"Amount must be > zero\");\r\n    require(_balances[sender] >= amount, \"Insufficient balance\");\r\n    if (!launched() && liquidityPools[recipient]) {\r\n      require(isLiquidityCreator[sender], \"Liquidity not added yet.\");\r\n      launch();\r\n    }\r\n    if (!isTradingEnabled) {\r\n      require(\r\n        isLiquidityCreator[sender] || isLiquidityCreator[recipient],\r\n        \"Trading is not launched yet.\"\r\n      );\r\n    }\r\n\r\n    checkTxLimit(sender, recipient, amount);\r\n\r\n    if (!liquidityPools[recipient] && recipient != DEAD) {\r\n      if (!isTxLimitExempt[recipient]) {\r\n        checkWalletLimit(recipient, amount);\r\n      }\r\n    }\r\n\r\n    if (inSwap) {\r\n      return _basicTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    _balances[sender] = _balances[sender] - amount;\r\n\r\n    uint256 amountReceived = amount;\r\n\r\n    if (shouldTakeFee(sender, recipient)) {\r\n      amountReceived = takeFee(recipient, amount);\r\n      if (shouldSwapBack(recipient) && amount > 0) swapBack(amount);\r\n    }\r\n\r\n    _balances[recipient] = _balances[recipient] + amountReceived;\r\n\r\n    emit Transfer(sender, recipient, amountReceived);\r\n    return true;\r\n  }\r\n\r\n  function launched() internal view returns (bool) {\r\n    return launchBlock != 0;\r\n  }\r\n\r\n  function launch() internal {\r\n    launchBlock = block.number;\r\n    launchTimestamp = block.timestamp;\r\n  }\r\n\r\n  function openTrading() external onlyTeam {\r\n    require(!isTradingEnabled, \"Can't re-open trading\");\r\n    isTradingEnabled = true;\r\n    swapEnabled = true;\r\n  }\r\n\r\n  function _basicTransfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) internal returns (bool) {\r\n    _balances[sender] = _balances[sender] - amount;\r\n    _balances[recipient] = _balances[recipient] + amount;\r\n    emit Transfer(sender, recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  function checkWalletLimit(address recipient, uint256 amount) internal view {\r\n    uint256 walletLimit = _maxWalletSize;\r\n    require(\r\n      _balances[recipient] + amount <= walletLimit,\r\n      \"Amount exceeds the max wallet size.\"\r\n    );\r\n  }\r\n\r\n  function checkTxLimit(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) internal view {\r\n    if (isTxLimitExempt[sender] || isTxLimitExempt[recipient]) return;\r\n\r\n    require(\r\n      amount <= (liquidityPools[sender] ? _maxBuyTxAmount : _maxSellTxAmount),\r\n      \"Amount exceeds the tx limit.\"\r\n    );\r\n\r\n    require(blacklist[sender] == 0, \"Wallet blacklisted!\");\r\n  }\r\n\r\n  function shouldTakeFee(\r\n    address sender,\r\n    address recipient\r\n  ) public view returns (bool) {\r\n    if (!transferTax && !liquidityPools[recipient] && !liquidityPools[sender])\r\n      return false;\r\n    return !isFeeExempt[sender] && !isFeeExempt[recipient];\r\n  }\r\n\r\n  function getTotalFee(bool selling) public view returns (uint256) {\r\n    if (selling) return totalSellFee;\r\n    return totalBuyFee;\r\n  }\r\n\r\n  function takeFee(\r\n    address recipient,\r\n    uint256 amount\r\n  ) internal returns (uint256) {\r\n    bool selling = liquidityPools[recipient];\r\n    uint256 feeAmount = (amount * getTotalFee(selling)) / feeDenominator;\r\n\r\n    _balances[address(this)] += feeAmount;\r\n\r\n    return amount - feeAmount;\r\n  }\r\n\r\n  function shouldSwapBack(address recipient) internal view returns (bool) {\r\n    return\r\n      !liquidityPools[msg.sender] &&\r\n      !inSwap &&\r\n      swapEnabled &&\r\n      swapBackCounter[block.number] < swapBackRateLimit &&\r\n      liquidityPools[recipient] &&\r\n      _balances[address(this)] >= swapAtMinimum &&\r\n      totalBuyFee + totalSellFee > 0;\r\n  }\r\n\r\n  function swapBack(uint256 amount) internal swapping {\r\n    uint256 totalFee = totalBuyFee + totalSellFee;\r\n    uint256 amountToSwap = amount < swapThreshold ? amount : swapThreshold;\r\n    if (_balances[address(this)] < amountToSwap)\r\n      amountToSwap = _balances[address(this)];\r\n\r\n    uint256 totalLiquidityFee = liquidityBuyFee + liquiditySellFee;\r\n    uint256 amountToLiquify = ((amountToSwap * totalLiquidityFee) / 2) /\r\n      totalFee;\r\n    amountToSwap -= amountToLiquify;\r\n\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(this);\r\n    path[1] = router.WETH();\r\n\r\n    uint256 balanceBefore = address(this).balance;\r\n\r\n    router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n      amountToSwap,\r\n      0,\r\n      path,\r\n      address(this),\r\n      block.timestamp\r\n    );\r\n\r\n    uint256 amountETH = address(this).balance - balanceBefore;\r\n    uint256 totalETHFee = totalFee - (totalLiquidityFee / 2);\r\n\r\n    uint256 amountETHLiquidity = ((amountETH * totalLiquidityFee) / 2) /\r\n      totalETHFee;\r\n    uint256 amountETHMarketing = amountETH - amountETHLiquidity;\r\n\r\n    if (amountETHMarketing > 0) {\r\n      (bool sentMarketing, ) = marketingFeeReceiver.call{\r\n        value: amountETHMarketing\r\n      }(\"\");\r\n      if (!sentMarketing) {\r\n        //Failed to transfer to marketing wallet\r\n      }\r\n    }\r\n\r\n    if (amountToLiquify > 0) {\r\n      router.addLiquidityETH{value: amountETHLiquidity}(\r\n        address(this),\r\n        amountToLiquify,\r\n        0,\r\n        0,\r\n        liquidityFeeReceiver,\r\n        block.timestamp\r\n      );\r\n    }\r\n    swapBackCounter[block.number] = swapBackCounter[block.number] + 1;\r\n    emit FundsDistributed(\r\n      amountETHMarketing,\r\n      amountETHLiquidity,\r\n      amountToLiquify\r\n    );\r\n  }\r\n\r\n  function addLiquidityPool(address lp, bool isPool) external onlyOwner {\r\n    require(lp != pair, \"Can't alter current liquidity pair\");\r\n    liquidityPools[lp] = isPool;\r\n  }\r\n\r\n  function setSwapBackRateLimit(uint256 rate) external onlyOwner {\r\n    swapBackRateLimit = rate;\r\n  }\r\n\r\n  function setTxLimit(\r\n    uint256 buyNumerator,\r\n    uint256 sellNumerator,\r\n    uint256 divisor\r\n  ) external onlyOwner {\r\n    require(\r\n      buyNumerator > 0 && sellNumerator > 0 && divisor > 0 && divisor <= 10000\r\n    );\r\n    _maxBuyTxAmount = (_totalSupply * buyNumerator) / divisor;\r\n    _maxSellTxAmount = (_totalSupply * sellNumerator) / divisor;\r\n  }\r\n\r\n  function setMaxWallet(uint256 numerator, uint256 divisor) external onlyOwner {\r\n    require(numerator > 0 && divisor > 0 && divisor <= 10000);\r\n    _maxWalletSize = (_totalSupply * numerator) / divisor;\r\n  }\r\n\r\n  function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\r\n    isFeeExempt[holder] = exempt;\r\n  }\r\n\r\n  function setIsTxLimitExempt(address holder, bool exempt) external onlyOwner {\r\n    isTxLimitExempt[holder] = exempt;\r\n  }\r\n\r\n  function setFees(\r\n    uint256 _liquidityBuyFee,\r\n    uint256 _liquiditySellFee,\r\n    uint256 _marketingBuyFee,\r\n    uint256 _marketingSellFee,\r\n    uint256 _feeDenominator\r\n  ) external onlyOwner {\r\n    require(\r\n      ((_liquidityBuyFee + _liquiditySellFee) / 2) * 2 ==\r\n        (_liquidityBuyFee + _liquiditySellFee),\r\n      \"Liquidity fee must be an even number for rounding compatibility.\"\r\n    );\r\n    liquidityBuyFee = _liquidityBuyFee;\r\n    liquiditySellFee = _liquiditySellFee;\r\n    marketingBuyFee = _marketingBuyFee;\r\n    marketingSellFee = _marketingSellFee;\r\n    totalBuyFee = _liquidityBuyFee + _marketingBuyFee;\r\n    totalSellFee = _liquiditySellFee + _marketingSellFee;\r\n    feeDenominator = _feeDenominator;\r\n    emit FeesSet(totalBuyFee, totalSellFee, feeDenominator);\r\n  }\r\n\r\n  function toggleTransferTax() external onlyOwner {\r\n    transferTax = !transferTax;\r\n  }\r\n\r\n  function setFeeReceivers(\r\n    address _liquidityFeeReceiver,\r\n    address _marketingFeeReceiver\r\n  ) external onlyOwner {\r\n    liquidityFeeReceiver = payable(_liquidityFeeReceiver);\r\n    marketingFeeReceiver = payable(_marketingFeeReceiver);\r\n  }\r\n\r\n  function setSwapBackSettings(\r\n    bool _enabled,\r\n    uint256 _denominator,\r\n    uint256 _swapAtMinimum\r\n  ) external onlyOwner {\r\n    require(_denominator > 0);\r\n    swapEnabled = _enabled;\r\n    swapThreshold = _totalSupply / _denominator;\r\n    swapAtMinimum = _swapAtMinimum * (10 ** _decimals);\r\n  }\r\n\r\n  function getCirculatingSupply() public view returns (uint256) {\r\n    return _totalSupply - (balanceOf(DEAD) + balanceOf(ZERO));\r\n  }\r\n\r\n  event FundsDistributed(\r\n    uint256 marketingETH,\r\n    uint256 liquidityETH,\r\n    uint256 liquidityTokens\r\n  );\r\n  event FeesSet(\r\n    uint256 totalBuyFees,\r\n    uint256 totalSellFees,\r\n    uint256 denominator\r\n  );\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBuyFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSellFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"FeesSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityTokens\",\"type\":\"uint256\"}],\"name\":\"FundsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"WalletBlacklisted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isPool\",\"type\":\"bool\"}],\"name\":\"addLiquidityPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMaxAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blacklistCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_blacklist\",\"type\":\"bool\"}],\"name\":\"blacklistWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"selling\",\"type\":\"bool\"}],\"name\":\"getTotalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLiquidityCreator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeReceiver\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyTxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellTxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquiditySellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeDenominator\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setSwapBackRateLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapAtMinimum\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_team\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setTeamMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buyNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellNumerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"shouldTakeFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAtMinimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swapBackCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapBackRateLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleTransferTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SynthTPU", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8e6ef83661081e1116c69bab48aac7980a5a49b52f088c96aa8afa64e1d0877b"}