{"SourceCode": "// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity 0.8.0;\r\n\r\n\r\ninterface IStaking {\r\n    function getEpochId(uint timestamp) external view returns (uint); // get epoch id\r\n    function getEpochUserBalance(address user, address token, uint128 epoch) external view returns(uint);\r\n    function getEpochPoolSize(address token, uint128 epoch) external view returns (uint);\r\n    function epoch1Start() external view returns (uint);\r\n    function epochDuration() external view returns (uint);\r\n    function hasReferrer(address addr) external view returns(bool);\r\n    function referrals(address addr) external view returns(address);\r\n    function firstReferrerRewardPercentage() external view returns(uint256);\r\n    function secondReferrerRewardPercentage() external view returns(uint256);\r\n    function isStakeFinished(address staker) external view returns (bool);\r\n    function stakeData(address staker) external view returns (uint256 startEpoch, uint256 endEpoch, bool active);\r\n    function stakeEndEpoch(address staker) external view returns (uint128);\r\n    function calcDurationBonusMultiplier(uint128 epochId, address staker) external view returns (uint256);\r\n}\r\n\r\ninterface Minter {\r\n    function mint(address to, uint256 amount) external;\r\n}\r\n\r\ncontract SwappYieldFarm {\r\n    // lib\r\n    using SafeMath for uint;\r\n    using SafeMath for uint128;\r\n\r\n    // constants\r\n    uint public constant NR_OF_EPOCHS = 60;\r\n    uint256 constant private CALC_MULTIPLIER = 1000000;\r\n\r\n    // addreses\r\n    address private _swappAddress = 0x8CB924583681cbFE487A62140a994A49F833c244;\r\n    address private _owner;\r\n    bool private _paused = false;\r\n    // contracts\r\n    IStaking private _staking;\r\n\tMinter private _minter;\r\n\r\n    uint[] private epochs = new uint[](NR_OF_EPOCHS + 1);\r\n    uint128 public lastInitializedEpoch;\r\n    mapping(address => uint128) public lastEpochIdHarvested;\r\n    uint public epochDuration; // init from staking contract\r\n    uint public epochStart; // init from staking contract\r\n\r\n    mapping(uint128 => uint256) public epochAmounts;\r\n    mapping(uint128 => uint256) public epochDurationBonus;\r\n    mapping(address => uint256) public collectedDurationBonus;\r\n    \r\n    modifier onlyStaking() {\r\n        require(msg.sender == address(_staking), \"Only staking contract can perfrom this action\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Only owner can perfrom this action\");\r\n        _;\r\n    }\r\n    \r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    // events\r\n    event MassHarvest(address indexed user, uint256 epochsHarvested, uint256 totalValue);\r\n    event Harvest(address indexed user, uint128 indexed epochId, uint256 amount);\r\n    event ReferrerRewardCollected(address indexed staker, address indexed referrer, uint256 rewardAmount);\r\n    event Referrer2RewardCollected(address indexed staker, address indexed referrer, address indexed referrer2, uint256 rewardAmount);\r\n    event DurationBonusCollected(address indexed staker, uint128 indexed epochId, uint256 bonusAmount);\r\n    event DurationBonusDistributed(address indexed staker, uint128 indexed epochId, uint256 bonusAmount);\r\n    event DurationBonusLost(address indexed staker, uint128 indexed epochId, uint256 bonusAmount);\r\n\r\n    // constructor\r\n    constructor() {\r\n        _staking = IStaking(0x60F4D3e409Ad2Bb6BF5edFBCC85691eE1977cf35);\r\n\t\t_minter = Minter(0xBC1f9993ea5eE2C77909bf43d7a960bB8dA8C9B9);\r\n\r\n        epochDuration = _staking.epochDuration();\r\n        epochStart = _staking.epoch1Start();\r\n\r\n        _owner = msg.sender;\r\n        \r\n        _initEpochReward();\r\n        _initDurationBonus();\r\n    }\r\n\r\n    function setEpochAmount(uint128 epochId, uint256 amount) external onlyOwner {\r\n        require(epochId > 0 && epochId <= NR_OF_EPOCHS, \"Minimum epoch number is 1 and Maximum number of epochs is 60\");\r\n        require(epochId > _getEpochId(), \"Only future epoch can be updated\");\r\n        epochAmounts[epochId] = amount;\r\n    }\r\n    \r\n    function setEpochDurationBonus(uint128 epochId, uint256 amount) external onlyOwner {\r\n        require(epochId > 0 && epochId <= NR_OF_EPOCHS, \"Minimum epoch number is 1 and Maximum number of epochs is 60\");\r\n        require(epochId > _getEpochId(), \"Only future epoch can be updated\");\r\n        epochDurationBonus[epochId] = amount;\r\n    }\r\n\r\n    function getTotalAmountPerEpoch(uint128 epoch) public view returns (uint) {\r\n        return epochAmounts[epoch].mul(10**18);\r\n    }\r\n    \r\n    function getDurationBonusPerEpoch(uint128 epoch) public view returns (uint) {\r\n        return epochDurationBonus[epoch].mul(10**18);\r\n    }\r\n    \r\n    function getCurrentEpochAmount() public view returns (uint) {\r\n        uint128 currentEpoch = _getEpochId();\r\n        if (currentEpoch <= 0 || currentEpoch > NR_OF_EPOCHS) {\r\n            return 0;\r\n        }\r\n\r\n        return epochAmounts[currentEpoch];\r\n    }\r\n    \r\n    function getCurrentEpochDurationBonus() public view returns (uint) {\r\n        uint128 currentEpoch = _getEpochId();\r\n        if (currentEpoch <= 0 || currentEpoch > NR_OF_EPOCHS) {\r\n            return 0;\r\n        }\r\n\r\n        return epochDurationBonus[currentEpoch];\r\n    }\r\n\r\n    function getTotalDistributedAmount() external view returns(uint256) {\r\n        uint256 totalDistributed;\r\n        for (uint128 i = 1; i <= NR_OF_EPOCHS; i++) {\r\n            totalDistributed += epochAmounts[i];\r\n        }\r\n        return totalDistributed;\r\n    } \r\n    \r\n    function getTotalDurationBonus() external view returns(uint256) {\r\n        uint256 totalBonus;\r\n        for (uint128 i = 1; i <= NR_OF_EPOCHS; i++) {\r\n            totalBonus += epochDurationBonus[i];\r\n        }\r\n        return totalBonus;\r\n    } \r\n\r\n    // public methods\r\n    // public method to harvest all the unharvested epochs until current epoch - 1\r\n    function massHarvest() external whenNotPaused returns (uint){\r\n        uint totalDistributedValue;\r\n        uint epochId = _getEpochId().sub(1); // fails in epoch 0\r\n        // force max number of epochs\r\n        if (epochId > NR_OF_EPOCHS) {\r\n            epochId = NR_OF_EPOCHS;\r\n        }\r\n\r\n        for (uint128 i = lastEpochIdHarvested[msg.sender] + 1; i <= epochId; i++) {\r\n            // i = epochId\r\n            // compute distributed Value and do one single transfer at the end\r\n            totalDistributedValue += _harvest(i);\r\n            \r\n            uint256 durationBonus = _calcDurationBonus(i);\r\n            if (durationBonus > 0) {\r\n                collectedDurationBonus[msg.sender] = collectedDurationBonus[msg.sender].add(durationBonus);\r\n                emit DurationBonusCollected(msg.sender, i, durationBonus);\r\n            }\r\n        }\r\n\r\n        emit MassHarvest(msg.sender, epochId - lastEpochIdHarvested[msg.sender], totalDistributedValue);\r\n\r\n        uint256 totalDurationBonus = 0;\r\n        if (_staking.isStakeFinished(msg.sender) && collectedDurationBonus[msg.sender] > 0) {\r\n            totalDurationBonus = collectedDurationBonus[msg.sender];\r\n            collectedDurationBonus[msg.sender] = 0;\r\n            _minter.mint(msg.sender, totalDurationBonus);\r\n            emit DurationBonusDistributed(msg.sender, _getEpochId(), totalDurationBonus);\r\n        }\r\n\r\n        if (totalDistributedValue > 0) {\r\n\t\t\t_minter.mint(msg.sender, totalDistributedValue);\r\n            //Referrer reward\r\n            distributeReferrerReward(totalDistributedValue.add(totalDurationBonus));\r\n        }\r\n\r\n        return totalDistributedValue.add(totalDurationBonus);\r\n    }\r\n\r\n    function harvest (uint128 epochId) external whenNotPaused returns (uint){\r\n        // checks for requested epoch\r\n        require (_getEpochId() > epochId, \"This epoch is in the future\");\r\n        require(epochId <= NR_OF_EPOCHS, \"Maximum number of epochs is 60\");\r\n        require (lastEpochIdHarvested[msg.sender].add(1) == epochId, \"Harvest in order\");\r\n        uint userReward = _harvest(epochId);\r\n        \r\n        uint256 durationBonus = _calcDurationBonus(epochId);\r\n        collectedDurationBonus[msg.sender] = collectedDurationBonus[msg.sender].add(_calcDurationBonus(epochId));\r\n        emit DurationBonusCollected(msg.sender, epochId, durationBonus);\r\n        \r\n        uint256 totalDurationBonus = 0;\r\n        if (_staking.isStakeFinished(msg.sender) && collectedDurationBonus[msg.sender] > 0) {\r\n            totalDurationBonus = collectedDurationBonus[msg.sender];\r\n            collectedDurationBonus[msg.sender] = 0;\r\n            _minter.mint(msg.sender, totalDurationBonus);\r\n            emit DurationBonusDistributed(msg.sender, epochId, totalDurationBonus);\r\n        }\r\n        \r\n        if (userReward > 0) {\r\n\t\t\t_minter.mint(msg.sender, userReward);\r\n            //Referrer reward\r\n            distributeReferrerReward(userReward.add(totalDurationBonus));\r\n        }\r\n        emit Harvest(msg.sender, epochId, userReward);\r\n        return userReward.add(totalDurationBonus);\r\n    }\r\n    \r\n    function distributeReferrerReward(uint256 stakerReward) internal {\r\n        if (_staking.hasReferrer(msg.sender)) {\r\n            address referrer = _staking.referrals(msg.sender);\r\n            uint256 ref1Reward = stakerReward.mul(_staking.firstReferrerRewardPercentage()).div(10000);\r\n            _minter.mint(referrer, ref1Reward);\r\n            emit ReferrerRewardCollected(msg.sender, referrer, ref1Reward);\r\n            \r\n            // second step referrer\r\n            if (_staking.hasReferrer(referrer)) {\r\n                address referrer2 = _staking.referrals(referrer);\r\n                uint256 ref2Reward = stakerReward.mul(_staking.secondReferrerRewardPercentage()).div(10000);\r\n            \t_minter.mint(referrer2, ref2Reward);\r\n                emit Referrer2RewardCollected(msg.sender, referrer, referrer2, ref2Reward);\r\n            }\r\n        }\r\n    }\r\n\r\n    // views\r\n    // calls to the staking smart contract to retrieve the epoch total pool size\r\n    function getPoolSize(uint128 epochId) external view returns (uint) {\r\n        return _getPoolSize(epochId);\r\n    }\r\n\r\n    function getCurrentEpoch() external view returns (uint) {\r\n        return _getEpochId();\r\n    }\r\n\r\n    // calls to the staking smart contract to retrieve user balance for an epoch\r\n    function getEpochStake(address userAddress, uint128 epochId) external view returns (uint) {\r\n        return _getUserBalancePerEpoch(userAddress, epochId);\r\n    }\r\n\r\n    function userLastEpochIdHarvested() external view returns (uint){\r\n        return lastEpochIdHarvested[msg.sender];\r\n    }\r\n    \r\n    function getUserLastEpochHarvested(address staker) external view returns (uint) {\r\n        return lastEpochIdHarvested[staker];\r\n    }\r\n    \r\n    function estimateDurationBonus (uint128 epochId) public view returns (uint) {\r\n        uint256 poolSize = _getPoolSize(epochId);\r\n        \r\n        // exit if there is no stake on the epoch\r\n        if (poolSize == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        uint256 stakerMultiplier = stakerDurationMultiplier(msg.sender, epochId + 1);\r\n\r\n        return getDurationBonusPerEpoch(epochId)\r\n        .mul(_getUserBalancePerEpoch(msg.sender, epochId))\r\n        .div(poolSize).mul(stakerMultiplier).div(CALC_MULTIPLIER);\r\n    }\r\n    \r\n    function stakerDurationMultiplier(address staker, uint128 epochId) public view returns (uint256) {\r\n        (uint256 startEpoch, uint256 endEpoch, bool active) = _staking.stakeData(staker);\r\n\r\n        if (epochId > endEpoch || (epochId <= endEpoch && active == false) || epochId < startEpoch) {\r\n            return 0;\r\n        }\r\n        \r\n        uint256 stakerMultiplier = _staking.calcDurationBonusMultiplier(epochId, staker);\r\n        \r\n        return stakerMultiplier;\r\n    }\r\n    \r\n    function reduceDurationBonus(address staker, uint256 reduceMultiplier) public onlyStaking {\r\n        uint256 collected = collectedDurationBonus[staker];\r\n        if (collected > 0) {\r\n            collectedDurationBonus[staker] = collected.mul(reduceMultiplier).div(CALC_MULTIPLIER);\r\n            uint256 bonusLost = collected.sub(collectedDurationBonus[staker]);\r\n            DurationBonusLost(staker, _getEpochId(), bonusLost);\r\n        }\r\n    }\r\n    \r\n    function clearDurationBonus(address staker) public onlyStaking {\r\n        uint256 collected = collectedDurationBonus[staker];\r\n        if (collected > 0) {\r\n            collectedDurationBonus[staker] = 0;\r\n            DurationBonusLost(staker, _getEpochId(), collected);\r\n        }\r\n    }\r\n\r\n    // internal methods\r\n\r\n    function _initEpoch(uint128 epochId) internal {\r\n        require(lastInitializedEpoch.add(1) == epochId, \"Epoch can be init only in order\");\r\n        lastInitializedEpoch = epochId;\r\n        // call the staking smart contract to init the epoch\r\n        epochs[epochId] = _getPoolSize(epochId);\r\n    }\r\n\r\n    function _harvest (uint128 epochId) internal returns (uint) {\r\n        // try to initialize an epoch. if it can't it fails\r\n        // if it fails either user either a Swapp account will init not init epochs\r\n        if (lastInitializedEpoch < epochId) {\r\n            _initEpoch(epochId);\r\n        }\r\n        // Set user state for last harvested\r\n        lastEpochIdHarvested[msg.sender] = epochId;\r\n        // compute and return user total reward. For optimization reasons the transfer have been moved to an upper layer (i.e. massHarvest needs to do a single transfer)\r\n\r\n        // exit if there is no stake on the epoch\r\n        if (epochs[epochId] == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        uint128 endEpoch = _staking.stakeEndEpoch(msg.sender);\r\n        if (epochId >= endEpoch) {\r\n            return 0;\r\n        }\r\n        \r\n        return getTotalAmountPerEpoch(epochId)\r\n        .mul(_getUserBalancePerEpoch(msg.sender, epochId))\r\n        .div(epochs[epochId]);\r\n    }\r\n    \r\n\r\n    function _calcDurationBonus(uint128 epochId) internal view returns (uint) {\r\n        // exit if there is no stake on the epoch\r\n        if (epochs[epochId] == 0) {\r\n            return 0;\r\n        }\r\n        \r\n        uint256 stakerMultiplier = stakerDurationMultiplier(msg.sender, epochId + 1);\r\n\r\n        return getDurationBonusPerEpoch(epochId)\r\n        .mul(_getUserBalancePerEpoch(msg.sender, epochId))\r\n        .div(epochs[epochId]).mul(stakerMultiplier).div(CALC_MULTIPLIER);\r\n    }\r\n\r\n    function _getPoolSize(uint128 epochId) internal view returns (uint) {\r\n        // retrieve token balance\r\n        return _staking.getEpochPoolSize(_swappAddress, epochId);\r\n    }\r\n\r\n    function _getUserBalancePerEpoch(address userAddress, uint128 epochId) internal view returns (uint){\r\n        // retrieve token balance per user per epoch\r\n        return _staking.getEpochUserBalance(userAddress, _swappAddress, epochId);\r\n    }\r\n\r\n    // compute epoch id from blocktimestamp and epochstart date\r\n    function _getEpochId() internal view returns (uint128 epochId) {\r\n        if (block.timestamp < epochStart) {\r\n            return 0;\r\n        }\r\n        epochId = uint128(block.timestamp.sub(epochStart).div(epochDuration).add(1));\r\n    }\r\n    \r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n    \r\n    function pause() external onlyOwner {\r\n        _paused = true;\r\n    }\r\n    \r\n    function unpause() external onlyOwner {\r\n        _paused = false;\r\n    }\r\n    \r\n    function _initEpochReward() internal {\r\n        epochAmounts[1] = 5000000;\r\n        epochAmounts[2] = 2000000;\r\n        epochAmounts[3] = 2000000;\r\n        epochAmounts[4] = 2000000;\r\n        epochAmounts[5] = 2000000;\r\n        epochAmounts[6] = 2000000;\r\n        epochAmounts[7] = 1500000;\r\n        epochAmounts[8] = 1500000;\r\n        epochAmounts[9] = 1500000;\r\n        epochAmounts[10] = 1500000;\r\n        epochAmounts[11] = 1500000;\r\n        epochAmounts[12] = 1500000;\r\n        epochAmounts[13] = 500000;\r\n        epochAmounts[14] = 500000;\r\n        epochAmounts[15] = 500000;\r\n        epochAmounts[16] = 500000;\r\n        epochAmounts[17] = 500000;\r\n        epochAmounts[18] = 500000;\r\n        epochAmounts[19] = 500000;\r\n        epochAmounts[20] = 500000;\r\n        epochAmounts[21] = 500000;\r\n        epochAmounts[22] = 500000;\r\n        epochAmounts[23] = 500000;\r\n        epochAmounts[24] = 500000;\r\n        epochAmounts[25] = 400000;\r\n        epochAmounts[26] = 400000;\r\n        epochAmounts[27] = 400000;\r\n        epochAmounts[28] = 400000;\r\n        epochAmounts[29] = 400000;\r\n        epochAmounts[30] = 400000;\r\n        epochAmounts[31] = 400000;\r\n        epochAmounts[32] = 400000;\r\n        epochAmounts[33] = 400000;\r\n        epochAmounts[34] = 400000;\r\n        epochAmounts[35] = 400000;\r\n        epochAmounts[36] = 400000;\r\n        epochAmounts[37] = 250000;\r\n        epochAmounts[38] = 250000;\r\n        epochAmounts[39] = 250000;\r\n        epochAmounts[40] = 250000;\r\n        epochAmounts[41] = 250000;\r\n        epochAmounts[42] = 250000;\r\n        epochAmounts[43] = 250000;\r\n        epochAmounts[44] = 250000;\r\n        epochAmounts[45] = 250000;\r\n        epochAmounts[46] = 250000;\r\n        epochAmounts[47] = 250000;\r\n        epochAmounts[48] = 250000;\r\n        epochAmounts[49] = 250000;\r\n        epochAmounts[50] = 250000;\r\n        epochAmounts[51] = 250000;\r\n        epochAmounts[52] = 250000;\r\n        epochAmounts[53] = 250000;\r\n        epochAmounts[54] = 250000;\r\n        epochAmounts[55] = 250000;\r\n        epochAmounts[56] = 250000;\r\n        epochAmounts[57] = 250000;\r\n        epochAmounts[58] = 250000;\r\n        epochAmounts[59] = 250000;\r\n        epochAmounts[60] = 250000;\r\n    }\r\n    \r\n    function _initDurationBonus() internal {\r\n        epochDurationBonus[1] = 21450;\r\n        epochDurationBonus[2] = 23595;\r\n        epochDurationBonus[3] = 25954;\r\n        epochDurationBonus[4] = 28550;\r\n        epochDurationBonus[5] = 31405;\r\n        epochDurationBonus[6] = 34545;\r\n        epochDurationBonus[7] = 38000;\r\n        epochDurationBonus[8] = 41800;\r\n        epochDurationBonus[9] = 45980;\r\n        epochDurationBonus[10] = 50578;\r\n        epochDurationBonus[11] = 55635;\r\n        epochDurationBonus[12] = 61477;\r\n        epochDurationBonus[13] = 67932;\r\n        epochDurationBonus[14] = 75065;\r\n        epochDurationBonus[15] = 82947;\r\n        epochDurationBonus[16] = 91656;\r\n        epochDurationBonus[17] = 101280;\r\n        epochDurationBonus[18] = 111915;\r\n        epochDurationBonus[19] = 123666;\r\n        epochDurationBonus[20] = 136651;\r\n        epochDurationBonus[21] = 150999;\r\n        epochDurationBonus[22] = 166854;\r\n        epochDurationBonus[23] = 184374;\r\n        epochDurationBonus[24] = 204701;\r\n        epochDurationBonus[25] = 227269;\r\n        epochDurationBonus[26] = 252326;\r\n        epochDurationBonus[27] = 280145;\r\n        epochDurationBonus[28] = 311031;\r\n        epochDurationBonus[29] = 345322;\r\n        epochDurationBonus[30] = 383393;\r\n        epochDurationBonus[31] = 425662;\r\n        epochDurationBonus[32] = 472592;\r\n        epochDurationBonus[33] = 524695;\r\n        epochDurationBonus[34] = 582543;\r\n        epochDurationBonus[35] = 646768;\r\n        epochDurationBonus[36] = 721639;\r\n        epochDurationBonus[37] = 805178;\r\n        epochDurationBonus[38] = 898388;\r\n        epochDurationBonus[39] = 1002387;\r\n        epochDurationBonus[40] = 1118426;\r\n        epochDurationBonus[41] = 1247898;\r\n        epochDurationBonus[42] = 1392358;\r\n        epochDurationBonus[43] = 1553541;\r\n        epochDurationBonus[44] = 1733382;\r\n        epochDurationBonus[45] = 1934043;\r\n        epochDurationBonus[46] = 2157933;\r\n        epochDurationBonus[47] = 2407740;\r\n        epochDurationBonus[48] = 2700403;\r\n        epochDurationBonus[49] = 3028638;\r\n        epochDurationBonus[50] = 3396771;\r\n        epochDurationBonus[51] = 3809651;\r\n        epochDurationBonus[52] = 4272716;\r\n        epochDurationBonus[53] = 4792068;\r\n        epochDurationBonus[54] = 5374546;\r\n        epochDurationBonus[55] = 6027826;\r\n        epochDurationBonus[56] = 6760512;\r\n        epochDurationBonus[57] = 7582256;\r\n        epochDurationBonus[58] = 8503884;\r\n        epochDurationBonus[59] = 9537537;\r\n        epochDurationBonus[60] = 11000000;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"DurationBonusCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"DurationBonusDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"DurationBonusLost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochsHarvested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalValue\",\"type\":\"uint256\"}],\"name\":\"MassHarvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"Referrer2RewardCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"ReferrerRewardCollected\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NR_OF_EPOCHS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"clearDurationBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collectedDurationBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"epochAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"epochDurationBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"estimateDurationBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpochDurationBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"epoch\",\"type\":\"uint128\"}],\"name\":\"getDurationBonusPerEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"getEpochStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"getPoolSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"epoch\",\"type\":\"uint128\"}],\"name\":\"getTotalAmountPerEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDistributedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDurationBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getUserLastEpochHarvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"harvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastEpochIdHarvested\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastInitializedEpoch\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massHarvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reduceMultiplier\",\"type\":\"uint256\"}],\"name\":\"reduceDurationBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setEpochAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setEpochDurationBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"epochId\",\"type\":\"uint128\"}],\"name\":\"stakerDurationMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userLastEpochIdHarvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SwappYieldFarm", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://835848fa0cf11f61af53c7e70b522fd99596de6fcf63dcca9ca1f5ff8d7e9e31"}