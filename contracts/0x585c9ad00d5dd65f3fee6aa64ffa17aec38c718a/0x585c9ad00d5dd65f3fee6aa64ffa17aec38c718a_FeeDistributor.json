{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity 0.6.12;\n\n\n// \n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// \n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// \n/******************\n@title WadRayMath library\n@author Aave\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n */\nlibrary WadRayMath {\n  using SafeMath for uint256;\n\n  uint256 internal constant _WAD = 1e18;\n  uint256 internal constant _HALF_WAD = _WAD / 2;\n\n  uint256 internal constant _RAY = 1e27;\n  uint256 internal constant _HALF_RAY = _RAY / 2;\n\n  uint256 internal constant _WAD_RAY_RATIO = 1e9;\n\n  function ray() internal pure returns (uint256) {\n    return _RAY;\n  }\n\n  function wad() internal pure returns (uint256) {\n    return _WAD;\n  }\n\n  function halfRay() internal pure returns (uint256) {\n    return _HALF_RAY;\n  }\n\n  function halfWad() internal pure returns (uint256) {\n    return _HALF_WAD;\n  }\n\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return _HALF_WAD.add(a.mul(b)).div(_WAD);\n  }\n\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 halfB = b / 2;\n\n    return halfB.add(a.mul(_WAD)).div(b);\n  }\n\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return _HALF_RAY.add(a.mul(b)).div(_RAY);\n  }\n\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 halfB = b / 2;\n\n    return halfB.add(a.mul(_RAY)).div(b);\n  }\n\n  function rayToWad(uint256 a) internal pure returns (uint256) {\n    uint256 halfRatio = _WAD_RAY_RATIO / 2;\n\n    return halfRatio.add(a).div(_WAD_RAY_RATIO);\n  }\n\n  function wadToRay(uint256 a) internal pure returns (uint256) {\n    return a.mul(_WAD_RAY_RATIO);\n  }\n\n  /**\n   * @dev calculates x^n, in ray. The code uses the ModExp precompile\n   * @param x base\n   * @param n exponent\n   * @return z = x^n, in ray\n   */\n  function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n    z = n % 2 != 0 ? x : _RAY;\n\n    for (n /= 2; n != 0; n /= 2) {\n      x = rayMul(x, x);\n\n      if (n % 2 != 0) {\n        z = rayMul(z, x);\n      }\n    }\n  }\n}\n\n// \n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// \ninterface IAccessController {\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function renounceRole(bytes32 role, address account) external;\n\n  function MANAGER_ROLE() external view returns (bytes32);\n\n  function MINTER_ROLE() external view returns (bytes32);\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n}\n\n// \ninterface IConfigProvider {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 liquidationRatio;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n    uint256 liquidationBonus;\n    uint256 liquidationFee;\n  }\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 liquidationRatio,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee,\n    uint256 liquidationBonus,\n    uint256 liquidationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _liquidationRatio,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee,\n    uint256 _liquidationBonus,\n    uint256 _liquidationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus) external;\n\n  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) external;\n\n  function setMinVotingPeriod(uint256 _minVotingPeriod) external;\n\n  function setMaxVotingPeriod(uint256 _maxVotingPeriod) external;\n\n  function setVotingQuorum(uint256 _votingQuorum) external;\n\n  function setProposalThreshold(uint256 _proposalThreshold) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function minVotingPeriod() external view returns (uint256);\n\n  function maxVotingPeriod() external view returns (uint256);\n\n  function votingQuorum() external view returns (uint256);\n\n  function proposalThreshold() external view returns (uint256);\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationRatio(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationBonus(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationFee(address _collateralType) external view returns (uint256);\n}\n\n// \ninterface ISTABLEX is IERC20 {\n  function mint(address account, uint256 amount) external;\n\n  function burn(address account, uint256 amount) external;\n\n  function a() external view returns (IAddressProvider);\n}\n\n// \ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n\n// \ninterface IPriceFeed {\n  event OracleUpdated(address indexed asset, address oracle, address sender);\n  event EurOracleUpdated(address oracle, address sender);\n\n  function setAssetOracle(address _asset, address _oracle) external;\n\n  function setEurOracle(address _oracle) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function assetOracles(address _asset) external view returns (AggregatorV3Interface);\n\n  function eurOracle() external view returns (AggregatorV3Interface);\n\n  function getAssetPrice(address _asset) external view returns (uint256);\n\n  function convertFrom(address _asset, uint256 _amount) external view returns (uint256);\n\n  function convertTo(address _asset, uint256 _amount) external view returns (uint256);\n}\n\n// \ninterface IRatesManager {\n  function a() external view returns (IAddressProvider);\n\n  //current annualized borrow rate\n  function annualizedBorrowRate(uint256 _currentBorrowRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate totalDebt based on baseDebt at time T0\n  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate baseDebt at time T0\n  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //calculate a new cumulative rate\n  function calculateCumulativeRate(\n    uint256 _borrowRate,\n    uint256 _cumulativeRate,\n    uint256 _timeElapsed\n  ) external view returns (uint256);\n}\n\n// \ninterface ILiquidationManager {\n  function a() external view returns (IAddressProvider);\n\n  function calculateHealthFactor(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(address _collateralType, uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(address _collateralType, uint256 _amount)\n    external\n    view\n    returns (uint256 discountedAmount);\n\n  function isHealthy(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) external view returns (bool);\n}\n\n// \ninterface IVaultsDataProvider {\n  struct Vault {\n    // borrowedType support USDX / PAR\n    address collateralType;\n    address owner;\n    uint256 collateralBalance;\n    uint256 baseDebt;\n    uint256 createdAt;\n  }\n\n  //Write\n  function createVault(address _collateralType, address _owner) external returns (uint256);\n\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\n\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\n\n  // Read\n  function a() external view returns (IAddressProvider);\n\n  function baseDebt(address _collateralType) external view returns (uint256);\n\n  function vaultCount() external view returns (uint256);\n\n  function vaults(uint256 _id) external view returns (Vault memory);\n\n  function vaultOwner(uint256 _id) external view returns (address);\n\n  function vaultCollateralType(uint256 _id) external view returns (address);\n\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\n\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\n\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\n\n  function vaultExists(uint256 _id) external view returns (bool);\n\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function collateralDebt(address _collateralType) external view returns (uint256);\n}\n\n// \ninterface IFeeDistributor {\n  event PayeeAdded(address indexed account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  function release() external;\n\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function lastReleasedAt() external view returns (uint256);\n\n  function getPayees() external view returns (address[] memory);\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address payee) external view returns (uint256);\n}\n\n// \ninterface IAddressProvider {\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProvider _config) external;\n\n  function setVaultsCore(IVaultsCore _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManager _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProvider);\n\n  function core() external view returns (IVaultsCore);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManager);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n}\n\n// \ninterface IConfigProviderV1 {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n  }\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setLiquidationBonus(uint256 _bonus) external;\n\n  function a() external view returns (IAddressProviderV1);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function liquidationBonus() external view returns (uint256);\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n}\n\n// \ninterface ILiquidationManagerV1 {\n  function a() external view returns (IAddressProviderV1);\n\n  function calculateHealthFactor(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(uint256 _amount) external view returns (uint256 discountedAmount);\n\n  function isHealthy(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (bool);\n}\n\n// \ninterface IVaultsCoreV1 {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawAll(uint256 _vaultId) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  //Refresh\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  //upgrade\n  function upgrade(address _newVaultsCore) external;\n\n  //Read only\n\n  function a() external view returns (IAddressProviderV1);\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n}\n\n// \ninterface IWETH {\n  function deposit() external payable;\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n}\n\n// \ninterface IGovernorAlpha {\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n\n        // Creator of the proposal\n        address proposer;\n\n        // The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n\n        // the ordered list of target addresses for calls to be made\n        address[] targets;\n\n        // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n\n        // The ordered list of function signatures to be called\n        string[] signatures;\n\n        // The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n\n        // The timestamp at which voting begins: holders must delegate their votes prior to this timestamp\n        uint256 startTime;\n\n        // The timestamp at which voting ends: votes must be cast prior to this timestamp\n        uint endTime;\n\n        // Current number of votes in favor of this proposal\n        uint256 forVotes;\n\n        // Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n\n        // Flag marking whether the proposal has been executed\n        bool executed;\n\n        // Receipts of ballots for the entire set of voters\n        mapping (address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n\n        // Whether or not the voter supports the proposal\n        bool support;\n\n        // The number of votes the voter had, which were cast\n        uint votes;\n    }\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(uint256 id, address proposer, address[] targets, uint256[] values, string[] signatures, bytes[] calldatas, uint startTime, uint endTime, string description);\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    function propose(address[] memory targets, uint256[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description, uint256 endTime) external returns (uint);\n\n    function queue(uint256 proposalId) external;\n\n    function execute(uint256 proposalId) external payable;\n\n    function cancel(uint256 proposalId) external;\n\n    function castVote(uint256 proposalId, bool support) external;\n\n    function getActions(uint256 proposalId) external view returns (address[] memory targets, uint256[] memory values, string[] memory signatures, bytes[] memory calldatas);\n\n    function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);\n\n    function state(uint proposalId) external view returns (ProposalState);\n\n    function quorumVotes() external view returns (uint256);\n\n    function proposalThreshold() external view returns (uint256);\n}\n\n// \ninterface ITimelock {\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  function acceptAdmin() external;\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n}\n\n// \ninterface IVotingEscrow {\n  enum LockAction { CREATE_LOCK, INCREASE_LOCK_AMOUNT, INCREASE_LOCK_TIME }\n\n  struct LockedBalance {\n    uint256 amount;\n    uint256 end;\n  }\n\n  /** Shared Events */\n  event Deposit(address indexed provider, uint256 value, uint256 locktime, LockAction indexed action, uint256 ts);\n  event Withdraw(address indexed provider, uint256 value, uint256 ts);\n  event Expired();\n\n  function createLock(uint256 _value, uint256 _unlockTime) external;\n\n  function increaseLockAmount(uint256 _value) external;\n\n  function increaseLockLength(uint256 _unlockTime) external;\n\n  function withdraw() external;\n\n  function expireContract() external;\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint256);\n\n  function balanceOf(address _owner) external view returns (uint256);\n\n  function balanceOfAt(address _owner, uint256 _blockTime) external view returns (uint256);\n\n  function stakingToken() external view returns (IERC20);\n}\n\n// \ninterface IMIMO is IERC20 {\n\n  function burn(address account, uint256 amount) external;\n  \n  function mint(address account, uint256 amount) external;\n\n}\n\n// \ninterface ISupplyMiner {\n\n  function baseDebtChanged(address user, uint256 newBaseDebt) external;\n}\n\n// \ninterface IDebtNotifier {\n\n  function debtChanged(uint256 _vaultId) external;\n\n  function setCollateralSupplyMiner(address collateral, ISupplyMiner supplyMiner) external;\n\n  function a() external view returns (IGovernanceAddressProvider);\n\n\tfunction collateralSupplyMinerMapping(address collateral) external view returns (ISupplyMiner);\n}\n\n// \ninterface IGovernanceAddressProvider {\n  function setParallelAddressProvider(IAddressProvider _parallel) external;\n\n  function setMIMO(IMIMO _mimo) external;\n\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\n\n  function setGovernorAlpha(IGovernorAlpha _governorAlpha) external;\n\n  function setTimelock(ITimelock _timelock) external;\n\n  function setVotingEscrow(IVotingEscrow _votingEscrow) external;\n\n  function controller() external view returns (IAccessController);\n\n  function parallel() external view returns (IAddressProvider);\n\n  function mimo() external view returns (IMIMO);\n\n  function debtNotifier() external view returns (IDebtNotifier);\n\n  function governorAlpha() external view returns (IGovernorAlpha);\n\n  function timelock() external view returns (ITimelock);\n\n  function votingEscrow() external view returns (IVotingEscrow);\n}\n\n// \ninterface IVaultsCore {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function depositETH() external payable;\n\n  function depositByVaultId(uint256 _vaultId, uint256 _amount) external;\n\n  function depositETHByVaultId(uint256 _vaultId) external payable;\n\n  function depositAndBorrow(\n    address _collateralType,\n    uint256 _depositAmount,\n    uint256 _borrowAmount\n  ) external;\n\n  function depositETHAndBorrow(uint256 _borrowAmount) external payable;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawETH(uint256 _vaultId, uint256 _amount) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  function liquidatePartial(uint256 _vaultId, uint256 _amount) external;\n\n  function upgrade(address payable _newVaultsCore) external;\n\n  function acceptUpgrade(address payable _oldVaultsCore) external;\n\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\n\n  //Read only\n  function a() external view returns (IAddressProvider);\n\n  function WETH() external view returns (IWETH);\n\n  function debtNotifier() external view returns (IDebtNotifier);\n\n  function state() external view returns (IVaultsCoreState);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n}\n\n// \ninterface IAddressProviderV1 {\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProviderV1 _config) external;\n\n  function setVaultsCore(IVaultsCoreV1 _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManagerV1 _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProviderV1);\n\n  function core() external view returns (IVaultsCoreV1);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManagerV1);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n}\n\n// \ninterface IVaultsCoreState {\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\n\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  function syncState(IVaultsCoreState _stateAddress) external;\n\n  function syncStateFromV1(IVaultsCoreV1 _core) external;\n\n  //Read only\n  function a() external view returns (IAddressProvider);\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n\n  function synced() external view returns (bool);\n}\n\n// \ncontract FeeDistributor is IFeeDistributor, ReentrancyGuard {\n  using SafeMath for uint256;\n\n  event PayeeAdded(address account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  uint256 public override lastReleasedAt;\n  IAddressProvider public override a;\n\n  uint256 public override totalShares;\n  mapping(address => uint256) public override shares;\n  address[] public payees;\n\n  modifier onlyManager() {\n    require(a.controller().hasRole(a.controller().MANAGER_ROLE(), msg.sender), \"Caller is not Manager\");\n    _;\n  }\n\n  constructor(IAddressProvider _addresses) public {\n    require(address(_addresses) != address(0));\n    a = _addresses;\n  }\n\n  /**\n    Public function to release the accumulated fee income to the payees.\n    @dev anyone can call this.\n  */\n  function release() public override nonReentrant {\n    uint256 income = a.core().state().availableIncome();\n    require(income > 0, \"income is 0\");\n    require(payees.length > 0, \"Payees not configured yet\");\n    lastReleasedAt = now;\n\n    // Mint USDX to all receivers\n    for (uint256 i = 0; i < payees.length; i++) {\n      address payee = payees[i];\n      _release(income, payee);\n    }\n    emit FeeReleased(income, lastReleasedAt);\n  }\n\n  /**\n    Updates the payee configuration to a new one.\n    @dev will release existing fees before the update.\n    @param _payees Array of payees\n    @param _shares Array of shares for each payee\n  */\n  function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    uint256 income = a.core().state().availableIncome();\n    if (income > 0 && payees.length > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }\n\n  /**\n    Get current configured payees.\n    @return array of current payees.\n  */\n  function getPayees() public view override returns (address[] memory) {\n    return payees;\n  }\n\n  /**\n    Internal function to release a percentage of income to a specific payee\n    @dev uses totalShares to calculate correct share\n    @param _totalIncomeReceived Total income for all payees, will be split according to shares\n    @param _payee The address of the payee to whom to distribute the fees.\n  */\n  function _release(uint256 _totalIncomeReceived, address _payee) internal {\n    uint256 payment = _totalIncomeReceived.mul(shares[_payee]).div(totalShares);\n    a.stablex().mint(_payee, payment);\n  }\n\n  /**\n    Internal function to add a new payee.\n    @dev will update totalShares and therefore reduce the relative share of all other payees.\n    @param _payee The address of the payee to add.\n    @param _shares The number of shares owned by the payee.\n  */\n  function _addPayee(address _payee, uint256 _shares) internal {\n    require(_payee != address(0), \"payee is the zero address\");\n    require(_shares > 0, \"shares are 0\");\n    require(shares[_payee] == 0, \"payee already has shares\");\n\n    payees.push(_payee);\n    shares[_payee] = _shares;\n    totalShares = totalShares.add(_shares);\n    emit PayeeAdded(_payee, _shares);\n  }\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IAddressProvider\",\"name\":\"_addresses\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"income\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releasedAt\",\"type\":\"uint256\"}],\"name\":\"FeeReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"PayeeAdded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"a\",\"outputs\":[{\"internalType\":\"contract IAddressProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_payees\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shares\",\"type\":\"uint256[]\"}],\"name\":\"changePayees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPayees\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastReleasedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FeeDistributor", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006fae125de41c03fa7d917ccfa17ba54ef4feb014", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}