{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TITANX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"./openzeppelin/security/ReentrancyGuard.sol\\\";\\nimport \\\"./openzeppelin/token/ERC20/ERC20.sol\\\";\\nimport \\\"./openzeppelin/interfaces/IERC165.sol\\\";\\n\\nimport \\\"../interfaces/ITitanOnBurn.sol\\\";\\nimport \\\"../interfaces/ITITANX.sol\\\";\\n\\nimport \\\"../libs/calcFunctions.sol\\\";\\n\\nimport \\\"./GlobalInfo.sol\\\";\\nimport \\\"./MintInfo.sol\\\";\\nimport \\\"./StakeInfo.sol\\\";\\nimport \\\"./BurnInfo.sol\\\";\\nimport \\\"./OwnerInfo.sol\\\";\\n\\n//custom errors\\nerror TitanX_InvalidAmount();\\nerror TitanX_InsufficientBalance();\\nerror TitanX_NotSupportedContract();\\nerror TitanX_InsufficientProtocolFees();\\nerror TitanX_FailedToSendAmount();\\nerror TitanX_NotAllowed();\\nerror TitanX_NoCycleRewardToClaim();\\nerror TitanX_NoSharesExist();\\nerror TitanX_EmptyUndistributeFees();\\nerror TitanX_InvalidBurnRewardPercent();\\nerror TitanX_InvalidBatchCount();\\nerror TitanX_InvalidMintLadderInterval();\\nerror TitanX_InvalidMintLadderRange();\\nerror TitanX_MaxedWalletMints();\\nerror TitanX_LPTokensHasMinted();\\nerror TitanX_InvalidAddress();\\nerror TitanX_InsufficientBurnAllowance();\\n\\n/** @title Titan X */\\ncontract TITANX is ERC20, ReentrancyGuard, GlobalInfo, MintInfo, StakeInfo, BurnInfo, OwnerInfo {\\n    /** Storage Variables*/\\n    /** @dev stores genesis wallet address */\\n    address private s_genesisAddress;\\n    /** @dev stores buy and burn contract address */\\n    address private s_buyAndBurnAddress;\\n\\n    /** @dev tracks collected protocol fees until it is distributed */\\n    uint88 private s_undistributedEth;\\n    /** @dev tracks burn reward from distributeETH() until payout is triggered */\\n    uint88 private s_cycleBurnReward;\\n\\n    /** @dev tracks if initial LP tokens has minted or not */\\n    InitialLPMinted private s_initialLPMinted;\\n\\n    /** @dev trigger to turn on burn pool reward */\\n    BurnPoolEnabled private s_burnPoolEnabled;\\n\\n    /** @dev tracks user + project burn mints allowance */\\n    mapping(address => mapping(address => uint256)) private s_allowanceBurnMints;\\n\\n    /** @dev tracks user + project burn stakes allowance */\\n    mapping(address => mapping(address => uint256)) private s_allowanceBurnStakes;\\n\\n    event ProtocolFeeRecevied(address indexed user, uint256 indexed day, uint256 indexed amount);\\n    event ETHDistributed(address indexed caller, uint256 indexed amount);\\n    event CyclePayoutTriggered(\\n        address indexed caller,\\n        uint256 indexed cycleNo,\\n        uint256 indexed reward,\\n        uint256 burnReward\\n    );\\n    event RewardClaimed(address indexed user, uint256 indexed reward);\\n    event ApproveBurnStakes(address indexed user, address indexed project, uint256 indexed amount);\\n    event ApproveBurnMints(address indexed user, address indexed project, uint256 indexed amount);\\n\\n    constructor(address genesisAddress, address buyAndBurnAddress) ERC20(\\\"TITAN X\\\", \\\"TITANX\\\") {\\n        if (genesisAddress == address(0)) revert TitanX_InvalidAddress();\\n        if (buyAndBurnAddress == address(0)) revert TitanX_InvalidAddress();\\n        s_genesisAddress = genesisAddress;\\n        s_buyAndBurnAddress = buyAndBurnAddress;\\n    }\\n\\n    /**** Mint Functions *****/\\n    /** @notice create a new mint\\n     * @param mintPower 1 - 100\\n     * @param numOfDays mint length of 1 - 280\\n     */\\n    function startMint(\\n        uint256 mintPower,\\n        uint256 numOfDays\\n    ) external payable nonReentrant dailyUpdate {\\n        if (getUserLatestMintId(_msgSender()) + 1 > MAX_MINT_PER_WALLET)\\n            revert TitanX_MaxedWalletMints();\\n        uint256 gMintPower = getGlobalMintPower() + mintPower;\\n        uint256 currentTRank = getGlobalTRank() + 1;\\n        uint256 gMinting = getTotalMinting() +\\n            _startMint(\\n                _msgSender(),\\n                mintPower,\\n                numOfDays,\\n                getCurrentMintableTitan(),\\n                getCurrentMintPowerBonus(),\\n                getCurrentEAABonus(),\\n                getUserBurnAmplifierBonus(_msgSender()),\\n                gMintPower,\\n                currentTRank,\\n                getBatchMintCost(mintPower, 1, getCurrentMintCost())\\n            );\\n        _updateMintStats(currentTRank, gMintPower, gMinting);\\n        _protocolFees(mintPower, 1);\\n    }\\n\\n    /** @notice create new mints in batch of up to 100 mints\\n     * @param mintPower 1 - 100\\n     * @param numOfDays mint length of 1 - 280\\n     * @param count 1 - 100\\n     */\\n    function batchMint(\\n        uint256 mintPower,\\n        uint256 numOfDays,\\n        uint256 count\\n    ) external payable nonReentrant dailyUpdate {\\n        if (count == 0 || count > MAX_BATCH_MINT_COUNT) revert TitanX_InvalidBatchCount();\\n        if (getUserLatestMintId(_msgSender()) + count > MAX_MINT_PER_WALLET)\\n            revert TitanX_MaxedWalletMints();\\n\\n        _startBatchMint(\\n            _msgSender(),\\n            mintPower,\\n            numOfDays,\\n            getCurrentMintableTitan(),\\n            getCurrentMintPowerBonus(),\\n            getCurrentEAABonus(),\\n            getUserBurnAmplifierBonus(_msgSender()),\\n            count,\\n            getBatchMintCost(mintPower, 1, getCurrentMintCost()) //only need 1 mint cost for all mints\\n        );\\n        _protocolFees(mintPower, count);\\n    }\\n\\n    /** @notice create new mints in ladder up to 100 mints\\n     * @param mintPower 1 - 100\\n     * @param minDay minimum mint length\\n     * @param maxDay maximum mint lenght\\n     * @param dayInterval day increase from previous mint length\\n     * @param countPerInterval how many mints per mint length\\n     */\\n    function batchMintLadder(\\n        uint256 mintPower,\\n        uint256 minDay,\\n        uint256 maxDay,\\n        uint256 dayInterval,\\n        uint256 countPerInterval\\n    ) external payable nonReentrant dailyUpdate {\\n        if (dayInterval == 0) revert TitanX_InvalidMintLadderInterval();\\n        if (maxDay < minDay || minDay == 0 || maxDay > MAX_MINT_LENGTH)\\n            revert TitanX_InvalidMintLadderRange();\\n\\n        uint256 count = getBatchMintLadderCount(minDay, maxDay, dayInterval, countPerInterval);\\n        if (count == 0 || count > MAX_BATCH_MINT_COUNT) revert TitanX_InvalidBatchCount();\\n        if (getUserLatestMintId(_msgSender()) + count > MAX_MINT_PER_WALLET)\\n            revert TitanX_MaxedWalletMints();\\n\\n        uint256 mintCost = getBatchMintCost(mintPower, 1, getCurrentMintCost()); //only need 1 mint cost for all mints\\n\\n        _startbatchMintLadder(\\n            _msgSender(),\\n            mintPower,\\n            minDay,\\n            maxDay,\\n            dayInterval,\\n            countPerInterval,\\n            getCurrentMintableTitan(),\\n            getCurrentMintPowerBonus(),\\n            getCurrentEAABonus(),\\n            getUserBurnAmplifierBonus(_msgSender()),\\n            mintCost\\n        );\\n        _protocolFees(mintPower, count);\\n    }\\n\\n    /** @notice claim a matured mint\\n     * @param id mint id\\n     */\\n    function claimMint(uint256 id) external dailyUpdate nonReentrant {\\n        _mintReward(_claimMint(_msgSender(), id, MintAction.CLAIM));\\n    }\\n\\n    /** @notice batch claim matured mint of up to 100 claims per run\\n     */\\n    function batchClaimMint() external dailyUpdate nonReentrant {\\n        _mintReward(_batchClaimMint(_msgSender()));\\n    }\\n\\n    /**** Stake Functions *****/\\n    /** @notice start a new stake\\n     * @param amount titan amount\\n     * @param numOfDays stake length\\n     */\\n    function startStake(uint256 amount, uint256 numOfDays) external dailyUpdate nonReentrant {\\n        if (balanceOf(_msgSender()) < amount) revert TitanX_InsufficientBalance();\\n\\n        _burn(_msgSender(), amount);\\n        _initFirstSharesCycleIndex(\\n            _msgSender(),\\n            _startStake(\\n                _msgSender(),\\n                amount,\\n                numOfDays,\\n                getCurrentShareRate(),\\n                getCurrentContractDay(),\\n                getGlobalPayoutTriggered()\\n            )\\n        );\\n    }\\n\\n    /** @notice end a stake\\n     * @param id stake id\\n     */\\n    function endStake(uint256 id) external dailyUpdate nonReentrant {\\n        _mint(\\n            _msgSender(),\\n            _endStake(\\n                _msgSender(),\\n                id,\\n                getCurrentContractDay(),\\n                StakeAction.END,\\n                StakeAction.END_OWN,\\n                getGlobalPayoutTriggered()\\n            )\\n        );\\n    }\\n\\n    /** @notice end a stake for others\\n     * @param user wallet address\\n     * @param id stake id\\n     */\\n    function endStakeForOthers(address user, uint256 id) external dailyUpdate nonReentrant {\\n        _mint(\\n            user,\\n            _endStake(\\n                user,\\n                id,\\n                getCurrentContractDay(),\\n                StakeAction.END,\\n                StakeAction.END_OTHER,\\n                getGlobalPayoutTriggered()\\n            )\\n        );\\n    }\\n\\n    /** @notice distribute the collected protocol fees into different pools/payouts\\n     * automatically send the incentive fee to caller, buyAndBurnFunds to BuyAndBurn contract, and genesis wallet\\n     */\\n    function distributeETH() external dailyUpdate nonReentrant {\\n        (uint256 incentiveFee, uint256 buyAndBurnFunds, uint256 genesisWallet) = _distributeETH();\\n        _sendFunds(incentiveFee, buyAndBurnFunds, genesisWallet);\\n    }\\n\\n    /** @notice trigger cylce payouts for day 8, 28, 90, 369, 888 including the burn reward cycle 28\\n     * As long as the cycle has met its maturiy day (eg. Cycle8 is day 8), payout can be triggered in any day onwards\\n     */\\n    function triggerPayouts() external dailyUpdate nonReentrant {\\n        uint256 globalActiveShares = getGlobalShares() - getGlobalExpiredShares();\\n        if (globalActiveShares < 1) revert TitanX_NoSharesExist();\\n\\n        uint256 incentiveFee;\\n        uint256 buyAndBurnFunds;\\n        uint256 genesisWallet;\\n        if (s_undistributedEth != 0)\\n            (incentiveFee, buyAndBurnFunds, genesisWallet) = _distributeETH();\\n\\n        uint256 currentContractDay = getCurrentContractDay();\\n        PayoutTriggered isTriggered = PayoutTriggered.NO;\\n        _triggerCyclePayout(DAY8, globalActiveShares, currentContractDay) == PayoutTriggered.YES &&\\n            isTriggered == PayoutTriggered.NO\\n            ? isTriggered = PayoutTriggered.YES\\n            : isTriggered;\\n        _triggerCyclePayout(DAY28, globalActiveShares, currentContractDay) == PayoutTriggered.YES &&\\n            isTriggered == PayoutTriggered.NO\\n            ? isTriggered = PayoutTriggered.YES\\n            : isTriggered;\\n        _triggerCyclePayout(DAY90, globalActiveShares, currentContractDay) == PayoutTriggered.YES &&\\n            isTriggered == PayoutTriggered.NO\\n            ? isTriggered = PayoutTriggered.YES\\n            : isTriggered;\\n        _triggerCyclePayout(DAY369, globalActiveShares, currentContractDay) ==\\n            PayoutTriggered.YES &&\\n            isTriggered == PayoutTriggered.NO\\n            ? isTriggered = PayoutTriggered.YES\\n            : isTriggered;\\n        _triggerCyclePayout(DAY888, globalActiveShares, currentContractDay) ==\\n            PayoutTriggered.YES &&\\n            isTriggered == PayoutTriggered.NO\\n            ? isTriggered = PayoutTriggered.YES\\n            : isTriggered;\\n\\n        if (isTriggered == PayoutTriggered.YES) {\\n            if (getGlobalPayoutTriggered() == PayoutTriggered.NO) _setGlobalPayoutTriggered();\\n        }\\n\\n        if (incentiveFee != 0) _sendFunds(incentiveFee, buyAndBurnFunds, genesisWallet);\\n    }\\n\\n    /** @notice claim all user available ETH payouts in one call */\\n    function claimUserAvailableETHPayouts() external dailyUpdate nonReentrant {\\n        uint256 reward = _claimCyclePayout(DAY8, PayoutClaim.SHARES);\\n        reward += _claimCyclePayout(DAY28, PayoutClaim.SHARES);\\n        reward += _claimCyclePayout(DAY90, PayoutClaim.SHARES);\\n        reward += _claimCyclePayout(DAY369, PayoutClaim.SHARES);\\n        reward += _claimCyclePayout(DAY888, PayoutClaim.SHARES);\\n\\n        if (reward == 0) revert TitanX_NoCycleRewardToClaim();\\n        _sendViaCall(payable(_msgSender()), reward);\\n        emit RewardClaimed(_msgSender(), reward);\\n    }\\n\\n    /** @notice claim all user available burn rewards in one call */\\n    function claimUserAvailableETHBurnPool() external dailyUpdate nonReentrant {\\n        uint256 reward = _claimCyclePayout(DAY28, PayoutClaim.BURN);\\n        if (reward == 0) revert TitanX_NoCycleRewardToClaim();\\n        _sendViaCall(payable(_msgSender()), reward);\\n        emit RewardClaimed(_msgSender(), reward);\\n    }\\n\\n    /** @notice Set BuyAndBurn Contract Address - able to change to new contract that supports UniswapV4+\\n     * Only owner can call this function\\n     * @param contractAddress BuyAndBurn contract address\\n     */\\n    function setBuyAndBurnContractAddress(address contractAddress) external onlyOwner {\\n        if (contractAddress == address(0)) revert TitanX_InvalidAddress();\\n        s_buyAndBurnAddress = contractAddress;\\n    }\\n\\n    /** @notice enable burn pool to start accumulate reward. Only owner can call this function. */\\n    function enableBurnPoolReward() external onlyOwner {\\n        s_burnPoolEnabled = BurnPoolEnabled.TRUE;\\n    }\\n\\n    /** @notice Set to new genesis wallet. Only genesis wallet can call this function\\n     * @param newAddress new genesis wallet address\\n     */\\n    function setNewGenesisAddress(address newAddress) external {\\n        if (_msgSender() != s_genesisAddress) revert TitanX_NotAllowed();\\n        if (newAddress == address(0)) revert TitanX_InvalidAddress();\\n        s_genesisAddress = newAddress;\\n    }\\n\\n    /** @notice mint initial LP tokens. Only BuyAndBurn contract set by genesis wallet can call this function\\n     */\\n    function mintLPTokens() external {\\n        if (_msgSender() != s_buyAndBurnAddress) revert TitanX_NotAllowed();\\n        if (s_initialLPMinted == InitialLPMinted.YES) revert TitanX_LPTokensHasMinted();\\n        s_initialLPMinted = InitialLPMinted.YES;\\n        _mint(s_buyAndBurnAddress, INITAL_LP_TOKENS);\\n    }\\n\\n    /** @notice burn all BuyAndBurn contract Titan */\\n    function burnLPTokens() external dailyUpdate {\\n        _burn(s_buyAndBurnAddress, balanceOf(s_buyAndBurnAddress));\\n    }\\n\\n    //private functions\\n    /** @dev mint reward to user and 1% to genesis wallet\\n     * @param reward titan amount\\n     */\\n    function _mintReward(uint256 reward) private {\\n        _mint(_msgSender(), reward);\\n        _mint(s_genesisAddress, (reward * 800) / PERCENT_BPS);\\n    }\\n\\n    /** @dev send ETH to respective parties\\n     * @param incentiveFee fees for caller to run distributeETH()\\n     * @param buyAndBurnFunds funds for buy and burn\\n     * @param genesisWalletFunds funds for genesis wallet\\n     */\\n    function _sendFunds(\\n        uint256 incentiveFee,\\n        uint256 buyAndBurnFunds,\\n        uint256 genesisWalletFunds\\n    ) private {\\n        _sendViaCall(payable(_msgSender()), incentiveFee);\\n        _sendViaCall(payable(s_genesisAddress), genesisWalletFunds);\\n        _sendViaCall(payable(s_buyAndBurnAddress), buyAndBurnFunds);\\n    }\\n\\n    /** @dev calculation to distribute collected protocol fees into different pools/parties */\\n    function _distributeETH()\\n        private\\n        returns (uint256 incentiveFee, uint256 buyAndBurnFunds, uint256 genesisWallet)\\n    {\\n        uint256 accumulatedFees = s_undistributedEth;\\n        if (accumulatedFees == 0) revert TitanX_EmptyUndistributeFees();\\n        s_undistributedEth = 0;\\n        emit ETHDistributed(_msgSender(), accumulatedFees);\\n\\n        incentiveFee = (accumulatedFees * INCENTIVE_FEE_PERCENT) / INCENTIVE_FEE_PERCENT_BASE; //0.01%\\n        accumulatedFees -= incentiveFee;\\n\\n        buyAndBurnFunds = (accumulatedFees * PERCENT_TO_BUY_AND_BURN) / PERCENT_BPS;\\n        uint256 cylceBurnReward = (accumulatedFees * PERCENT_TO_BURN_PAYOUTS) / PERCENT_BPS;\\n        genesisWallet = (accumulatedFees * PERCENT_TO_GENESIS) / PERCENT_BPS;\\n        uint256 cycleRewardPool = accumulatedFees -\\n            buyAndBurnFunds -\\n            cylceBurnReward -\\n            genesisWallet;\\n\\n        if (s_burnPoolEnabled == BurnPoolEnabled.TRUE) s_cycleBurnReward += uint88(cylceBurnReward);\\n        else buyAndBurnFunds += cylceBurnReward;\\n\\n        //cycle payout\\n        if (cycleRewardPool != 0) {\\n            uint256 cycle8Reward = (cycleRewardPool * CYCLE_8_PERCENT) / PERCENT_BPS;\\n            uint256 cycle28Reward = (cycleRewardPool * CYCLE_28_PERCENT) / PERCENT_BPS;\\n            uint256 cycle90Reward = (cycleRewardPool * CYCLE_90_PERCENT) / PERCENT_BPS;\\n            uint256 cycle369Reward = (cycleRewardPool * CYCLE_369_PERCENT) / PERCENT_BPS;\\n            _setCyclePayoutPool(DAY8, cycle8Reward);\\n            _setCyclePayoutPool(DAY28, cycle28Reward);\\n            _setCyclePayoutPool(DAY90, cycle90Reward);\\n            _setCyclePayoutPool(DAY369, cycle369Reward);\\n            _setCyclePayoutPool(\\n                DAY888,\\n                cycleRewardPool - cycle8Reward - cycle28Reward - cycle90Reward - cycle369Reward\\n            );\\n        }\\n    }\\n\\n    /** @dev calcualte required protocol fees, and return the balance (if any)\\n     * @param mintPower mint power 1-100\\n     * @param count how many mints\\n     */\\n    function _protocolFees(uint256 mintPower, uint256 count) private {\\n        uint256 protocolFee;\\n\\n        protocolFee = getBatchMintCost(mintPower, count, getCurrentMintCost());\\n        if (msg.value < protocolFee) revert TitanX_InsufficientProtocolFees();\\n\\n        uint256 feeBalance;\\n        s_undistributedEth += uint88(protocolFee);\\n        feeBalance = msg.value - protocolFee;\\n\\n        if (feeBalance != 0) {\\n            _sendViaCall(payable(_msgSender()), feeBalance);\\n        }\\n\\n        emit ProtocolFeeRecevied(_msgSender(), getCurrentContractDay(), protocolFee);\\n    }\\n\\n    /** @dev calculate payouts for each cycle day tracked by cycle index\\n     * @param cycleNo cylce day 8, 28, 90, 369, 888\\n     * @param globalActiveShares global active shares\\n     * @param currentContractDay current contract day\\n     * @return triggered is payout triggered succesfully\\n     */\\n    function _triggerCyclePayout(\\n        uint256 cycleNo,\\n        uint256 globalActiveShares,\\n        uint256 currentContractDay\\n    ) private returns (PayoutTriggered triggered) {\\n        //check against cylce payout maturity day\\n        if (currentContractDay < getNextCyclePayoutDay(cycleNo)) return PayoutTriggered.NO;\\n\\n        //update the next cycle payout day regardless of payout triggered succesfully or not\\n        _setNextCyclePayoutDay(cycleNo);\\n\\n        uint256 reward = getCyclePayoutPool(cycleNo);\\n        if (reward == 0) return PayoutTriggered.NO;\\n\\n        //calculate cycle reward per share and get new cycle Index\\n        uint256 cycleIndex = _calculateCycleRewardPerShare(cycleNo, reward, globalActiveShares);\\n\\n        //calculate burn reward if cycle is 28\\n        uint256 totalCycleBurn = getCycleBurnTotal(cycleIndex);\\n        uint256 burnReward;\\n        if (cycleNo == DAY28 && totalCycleBurn != 0) {\\n            burnReward = s_cycleBurnReward;\\n            if (burnReward != 0) {\\n                s_cycleBurnReward = 0;\\n                _calculateCycleBurnRewardPerToken(cycleIndex, burnReward, totalCycleBurn);\\n            }\\n        }\\n\\n        emit CyclePayoutTriggered(_msgSender(), cycleNo, reward, burnReward);\\n\\n        return PayoutTriggered.YES;\\n    }\\n\\n    /** @dev calculate user reward with specified cycle day and claim type (shares/burn) and update user's last claim cycle index\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     * @param payoutClaim claim type - (Shares=0/Burn=1)\\n     */\\n    function _claimCyclePayout(uint256 cycleNo, PayoutClaim payoutClaim) private returns (uint256) {\\n        (\\n            uint256 reward,\\n            uint256 userClaimCycleIndex,\\n            uint256 userClaimSharesIndex,\\n            uint256 userClaimBurnCycleIndex\\n        ) = _calculateUserCycleReward(_msgSender(), cycleNo, payoutClaim);\\n\\n        if (payoutClaim == PayoutClaim.SHARES)\\n            _updateUserClaimIndexes(\\n                _msgSender(),\\n                cycleNo,\\n                userClaimCycleIndex,\\n                userClaimSharesIndex\\n            );\\n        if (payoutClaim == PayoutClaim.BURN) {\\n            _updateUserBurnCycleClaimIndex(_msgSender(), cycleNo, userClaimBurnCycleIndex);\\n        }\\n\\n        return reward;\\n    }\\n\\n    /** @dev burn liquid Titan through other project.\\n     * called by other contracts for proof of burn 2.0 with up to 8% for both builder fee and user rebate\\n     * @param user user address\\n     * @param amount liquid titan amount\\n     * @param userRebatePercentage percentage for user rebate in liquid titan (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid titan (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     */\\n    function _burnLiquidTitan(\\n        address user,\\n        uint256 amount,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress\\n    ) private {\\n        if (amount == 0) revert TitanX_InvalidAmount();\\n        if (balanceOf(user) < amount) revert TitanX_InsufficientBalance();\\n        _spendAllowance(user, _msgSender(), amount);\\n        _burnbefore(userRebatePercentage, rewardPaybackPercentage);\\n        _burn(user, amount);\\n        _burnAfter(\\n            user,\\n            amount,\\n            userRebatePercentage,\\n            rewardPaybackPercentage,\\n            rewardPaybackAddress,\\n            BurnSource.LIQUID\\n        );\\n    }\\n\\n    /** @dev burn stake through other project.\\n     * called by other contracts for proof of burn 2.0 with up to 8% for both builder fee and user rebate\\n     * @param user user address\\n     * @param id stake id\\n     * @param userRebatePercentage percentage for user rebate in liquid titan (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid titan (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     */\\n    function _burnStake(\\n        address user,\\n        uint256 id,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress\\n    ) private {\\n        _spendBurnStakeAllowance(user);\\n        _burnbefore(userRebatePercentage, rewardPaybackPercentage);\\n        _burnAfter(\\n            user,\\n            _endStake(\\n                user,\\n                id,\\n                getCurrentContractDay(),\\n                StakeAction.BURN,\\n                StakeAction.END_OWN,\\n                getGlobalPayoutTriggered()\\n            ),\\n            userRebatePercentage,\\n            rewardPaybackPercentage,\\n            rewardPaybackAddress,\\n            BurnSource.STAKE\\n        );\\n    }\\n\\n    /** @dev burn mint through other project.\\n     * called by other contracts for proof of burn 2.0\\n     * burn mint has no builder reward and no user rebate\\n     * @param user user address\\n     * @param id mint id\\n     */\\n    function _burnMint(address user, uint256 id) private {\\n        _spendBurnMintAllowance(user);\\n        _burnbefore(0, 0);\\n        uint256 amount = _claimMint(user, id, MintAction.BURN);\\n        _mint(s_genesisAddress, (amount * 800) / PERCENT_BPS);\\n        _burnAfter(user, amount, 0, 0, _msgSender(), BurnSource.MINT);\\n    }\\n\\n    /** @dev perform checks before burning starts.\\n     * check reward percentage and check if called by supported contract\\n     * @param userRebatePercentage percentage for user rebate\\n     * @param rewardPaybackPercentage percentage for builder fee\\n     */\\n    function _burnbefore(\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage\\n    ) private view {\\n        if (rewardPaybackPercentage + userRebatePercentage > MAX_BURN_REWARD_PERCENT)\\n            revert TitanX_InvalidBurnRewardPercent();\\n\\n        //Only supported contracts is allowed to call this function\\n        if (\\n            !IERC165(_msgSender()).supportsInterface(IERC165.supportsInterface.selector) ||\\n            !IERC165(_msgSender()).supportsInterface(type(ITitanOnBurn).interfaceId)\\n        ) revert TitanX_NotSupportedContract();\\n    }\\n\\n    /** @dev update burn stats and mint reward to builder or user if applicable\\n     * @param user user address\\n     * @param amount titan amount burned\\n     * @param userRebatePercentage percentage for user rebate in liquid titan (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid titan (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     * @param source liquid/mint/stake\\n     */\\n    function _burnAfter(\\n        address user,\\n        uint256 amount,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress,\\n        BurnSource source\\n    ) private {\\n        uint256 index = getCurrentCycleIndex(DAY28) + 1;\\n        /** set to the latest cylceIndex + 1 for fresh wallet\\n         * same concept as _initFirstSharesCycleIndex, refer to its dev comment  */\\n        if (getUserBurnTotal(user) == 0) _updateUserBurnCycleClaimIndex(user, DAY28, index);\\n        _updateBurnAmount(user, _msgSender(), amount, index, source);\\n\\n        uint256 devFee;\\n        uint256 userRebate;\\n        if (rewardPaybackPercentage != 0)\\n            devFee = (amount * rewardPaybackPercentage * PERCENT_BPS) / (100 * PERCENT_BPS);\\n        if (userRebatePercentage != 0)\\n            userRebate = (amount * userRebatePercentage * PERCENT_BPS) / (100 * PERCENT_BPS);\\n\\n        if (devFee != 0) _mint(rewardPaybackAddress, devFee);\\n        if (userRebate != 0) _mint(user, userRebate);\\n\\n        ITitanOnBurn(_msgSender()).onBurn(user, amount);\\n    }\\n\\n    /** @dev Recommended method to use to send native coins.\\n     * @param to receiving address.\\n     * @param amount in wei.\\n     */\\n    function _sendViaCall(address payable to, uint256 amount) private {\\n        if (to == address(0)) revert TitanX_InvalidAddress();\\n        (bool sent, ) = to.call{value: amount}(\\\"\\\");\\n        if (!sent) revert TitanX_FailedToSendAmount();\\n    }\\n\\n    /** @dev reduce user's allowance for caller (spender/project) by 1 (burn 1 stake at a time)\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     * @param user user address\\n     */\\n    function _spendBurnStakeAllowance(address user) private {\\n        uint256 currentAllowance = allowanceBurnStakes(user, _msgSender());\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance == 0) revert TitanX_InsufficientBurnAllowance();\\n            --s_allowanceBurnStakes[user][_msgSender()];\\n        }\\n    }\\n\\n    /** @dev reduce user's allowance for caller (spender/project) by 1 (burn 1 mint at a time)\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     * @param user user address\\n     */\\n    function _spendBurnMintAllowance(address user) private {\\n        uint256 currentAllowance = allowanceBurnMints(user, _msgSender());\\n        if (currentAllowance != type(uint256).max) {\\n            if (currentAllowance == 0) revert TitanX_InsufficientBurnAllowance();\\n            --s_allowanceBurnMints[user][_msgSender()];\\n        }\\n    }\\n\\n    //Views\\n    /** @dev calculate user payout reward with specified cycle day and claim type (shares/burn).\\n     * it loops through all the unclaimed cylce index until the latest cycle index\\n     * @param user user address\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     * @param payoutClaim claim type (Shares=0/Burn=1)\\n     * @return rewards calculated reward\\n     * @return userClaimCycleIndex last claim cycle index\\n     * @return userClaimSharesIndex last claim shares index\\n     * @return userClaimBurnCycleIndex last claim burn cycle index\\n     */\\n    function _calculateUserCycleReward(\\n        address user,\\n        uint256 cycleNo,\\n        PayoutClaim payoutClaim\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 rewards,\\n            uint256 userClaimCycleIndex,\\n            uint256 userClaimSharesIndex,\\n            uint256 userClaimBurnCycleIndex\\n        )\\n    {\\n        uint256 cycleMaxIndex = getCurrentCycleIndex(cycleNo);\\n\\n        if (payoutClaim == PayoutClaim.SHARES) {\\n            (userClaimCycleIndex, userClaimSharesIndex) = getUserLastClaimIndex(user, cycleNo);\\n            uint256 sharesMaxIndex = getUserLatestShareIndex(user);\\n\\n            for (uint256 i = userClaimCycleIndex; i <= cycleMaxIndex; i++) {\\n                (uint256 payoutPerShare, uint256 payoutDay) = getPayoutPerShare(cycleNo, i);\\n                uint256 shares;\\n\\n                //loop shares indexes to find the last updated shares before/same triggered payout day\\n                for (uint256 j = userClaimSharesIndex; j <= sharesMaxIndex; j++) {\\n                    if (getUserActiveSharesDay(user, j) <= payoutDay)\\n                        shares = getUserActiveShares(user, j);\\n                    else break;\\n\\n                    userClaimSharesIndex = j;\\n                }\\n\\n                if (payoutPerShare != 0 && shares != 0) {\\n                    //reward has 18 decimals scaling, so here divide by 1e18\\n                    rewards += (shares * payoutPerShare) / SCALING_FACTOR_1e18;\\n                }\\n\\n                userClaimCycleIndex = i + 1;\\n            }\\n        } else if (cycleNo == DAY28 && payoutClaim == PayoutClaim.BURN) {\\n            userClaimBurnCycleIndex = getUserLastBurnClaimIndex(user, cycleNo);\\n            for (uint256 i = userClaimBurnCycleIndex; i <= cycleMaxIndex; i++) {\\n                uint256 burnPayoutPerToken = getCycleBurnPayoutPerToken(i);\\n                rewards += (burnPayoutPerToken != 0)\\n                    ? (burnPayoutPerToken * _getUserCycleBurnTotal(user, i)) / SCALING_FACTOR_1e18\\n                    : 0;\\n                userClaimBurnCycleIndex = i + 1;\\n            }\\n        }\\n    }\\n\\n    /** @notice get contract ETH balance\\n     * @return balance eth balance\\n     */\\n    function getBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    /** @notice get undistributed ETH balance\\n     * @return amount eth amount\\n     */\\n    function getUndistributedEth() public view returns (uint256) {\\n        return s_undistributedEth;\\n    }\\n\\n    /** @notice get user ETH payout for all cycles\\n     * @param user user address\\n     * @return reward total reward\\n     */\\n    function getUserETHClaimableTotal(address user) public view returns (uint256 reward) {\\n        uint256 _reward;\\n        (_reward, , , ) = _calculateUserCycleReward(user, DAY8, PayoutClaim.SHARES);\\n        reward += _reward;\\n        (_reward, , , ) = _calculateUserCycleReward(user, DAY28, PayoutClaim.SHARES);\\n        reward += _reward;\\n        (_reward, , , ) = _calculateUserCycleReward(user, DAY90, PayoutClaim.SHARES);\\n        reward += _reward;\\n        (_reward, , , ) = _calculateUserCycleReward(user, DAY369, PayoutClaim.SHARES);\\n        reward += _reward;\\n        (_reward, , , ) = _calculateUserCycleReward(user, DAY888, PayoutClaim.SHARES);\\n        reward += _reward;\\n    }\\n\\n    /** @notice get user burn reward ETH payout\\n     * @param user user address\\n     * @return reward burn reward\\n     */\\n    function getUserBurnPoolETHClaimableTotal(address user) public view returns (uint256 reward) {\\n        (reward, , , ) = _calculateUserCycleReward(user, DAY28, PayoutClaim.BURN);\\n    }\\n\\n    /** @notice get total penalties from mint and stake\\n     * @return amount total penalties\\n     */\\n    function getTotalPenalties() public view returns (uint256) {\\n        return getTotalMintPenalty() + getTotalStakePenalty();\\n    }\\n\\n    /** @notice get burn pool reward\\n     * @return reward burn pool reward\\n     */\\n    function getCycleBurnPool() public view returns (uint256) {\\n        return s_cycleBurnReward;\\n    }\\n\\n    /** @notice get user current burn cycle percentage\\n     * @return percentage in 18 decimals\\n     */\\n    function getCurrentUserBurnCyclePercentage() public view returns (uint256) {\\n        uint256 index = getCurrentCycleIndex(DAY28) + 1;\\n        uint256 cycleBurnTotal = getCycleBurnTotal(index);\\n        return\\n            cycleBurnTotal == 0\\n                ? 0\\n                : (_getUserCycleBurnTotal(_msgSender(), index) * 100 * SCALING_FACTOR_1e18) /\\n                    cycleBurnTotal;\\n    }\\n\\n    /** @notice get user current cycle total titan burned\\n     * @param user user address\\n     * @return burnTotal total titan burned in curreny burn cycle\\n     */\\n    function getUserCycleBurnTotal(address user) public view returns (uint256) {\\n        return _getUserCycleBurnTotal(user, getCurrentCycleIndex(DAY28) + 1);\\n    }\\n\\n    function isBurnPoolEnabled() public view returns (BurnPoolEnabled) {\\n        return s_burnPoolEnabled;\\n    }\\n\\n    /** @notice returns user's burn stakes allowance of a project\\n     * @param user user address\\n     * @param spender project address\\n     */\\n    function allowanceBurnStakes(address user, address spender) public view returns (uint256) {\\n        return s_allowanceBurnStakes[user][spender];\\n    }\\n\\n    /** @notice returns user's burn mints allowance of a project\\n     * @param user user address\\n     * @param spender project address\\n     */\\n    function allowanceBurnMints(address user, address spender) public view returns (uint256) {\\n        return s_allowanceBurnMints[user][spender];\\n    }\\n\\n    //Public functions for devs to intergrate with Titan\\n    /** @notice allow anyone to sync dailyUpdate manually */\\n    function manualDailyUpdate() public dailyUpdate {}\\n\\n    /** @notice Burn Titan tokens and creates Proof-Of-Burn record to be used by connected DeFi and fee is paid to specified address\\n     * @param user user address\\n     * @param amount titan amount\\n     * @param userRebatePercentage percentage for user rebate in liquid titan (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid titan (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     */\\n    function burnTokensToPayAddress(\\n        address user,\\n        uint256 amount,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress\\n    ) public dailyUpdate nonReentrant {\\n        _burnLiquidTitan(\\n            user,\\n            amount,\\n            userRebatePercentage,\\n            rewardPaybackPercentage,\\n            rewardPaybackAddress\\n        );\\n    }\\n\\n    /** @notice Burn Titan tokens and creates Proof-Of-Burn record to be used by connected DeFi and fee is paid to specified address\\n     * @param user user address\\n     * @param amount titan amount\\n     * @param userRebatePercentage percentage for user rebate in liquid titan (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid titan (0 - 8)\\n     */\\n    function burnTokens(\\n        address user,\\n        uint256 amount,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage\\n    ) public dailyUpdate nonReentrant {\\n        _burnLiquidTitan(user, amount, userRebatePercentage, rewardPaybackPercentage, _msgSender());\\n    }\\n\\n    /** @notice allows user to burn liquid titan directly from contract\\n     * @param amount titan amount\\n     */\\n    function userBurnTokens(uint256 amount) public dailyUpdate nonReentrant {\\n        if (amount == 0) revert TitanX_InvalidAmount();\\n        if (balanceOf(_msgSender()) < amount) revert TitanX_InsufficientBalance();\\n        _burn(_msgSender(), amount);\\n        _updateBurnAmount(\\n            _msgSender(),\\n            address(0),\\n            amount,\\n            getCurrentCycleIndex(DAY28) + 1,\\n            BurnSource.LIQUID\\n        );\\n    }\\n\\n    /** @notice Burn stake and creates Proof-Of-Burn record to be used by connected DeFi and fee is paid to specified address\\n     * @param user user address\\n     * @param id stake id\\n     * @param userRebatePercentage percentage for user rebate in liquid titan (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid titan (0 - 8)\\n     * @param rewardPaybackAddress builder can opt to receive fee in another address\\n     */\\n    function burnStakeToPayAddress(\\n        address user,\\n        uint256 id,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage,\\n        address rewardPaybackAddress\\n    ) public dailyUpdate nonReentrant {\\n        _burnStake(user, id, userRebatePercentage, rewardPaybackPercentage, rewardPaybackAddress);\\n    }\\n\\n    /** @notice Burn stake and creates Proof-Of-Burn record to be used by connected DeFi and fee is paid to project contract address\\n     * @param user user address\\n     * @param id stake id\\n     * @param userRebatePercentage percentage for user rebate in liquid titan (0 - 8)\\n     * @param rewardPaybackPercentage percentage for builder fee in liquid titan (0 - 8)\\n     */\\n    function burnStake(\\n        address user,\\n        uint256 id,\\n        uint256 userRebatePercentage,\\n        uint256 rewardPaybackPercentage\\n    ) public dailyUpdate nonReentrant {\\n        _burnStake(user, id, userRebatePercentage, rewardPaybackPercentage, _msgSender());\\n    }\\n\\n    /** @notice allows user to burn stake directly from contract\\n     * @param id stake id\\n     */\\n    function userBurnStake(uint256 id) public dailyUpdate nonReentrant {\\n        _updateBurnAmount(\\n            _msgSender(),\\n            address(0),\\n            _endStake(\\n                _msgSender(),\\n                id,\\n                getCurrentContractDay(),\\n                StakeAction.BURN,\\n                StakeAction.END_OWN,\\n                getGlobalPayoutTriggered()\\n            ),\\n            getCurrentCycleIndex(DAY28) + 1,\\n            BurnSource.STAKE\\n        );\\n    }\\n\\n    /** @notice Burn mint and creates Proof-Of-Burn record to be used by connected DeFi.\\n     * Burn mint has no project reward or user rebate\\n     * @param user user address\\n     * @param id mint id\\n     */\\n    function burnMint(address user, uint256 id) public dailyUpdate nonReentrant {\\n        _burnMint(user, id);\\n    }\\n\\n    /** @notice allows user to burn mint directly from contract\\n     * @param id mint id\\n     */\\n    function userBurnMint(uint256 id) public dailyUpdate nonReentrant {\\n        _updateBurnAmount(\\n            _msgSender(),\\n            address(0),\\n            _claimMint(_msgSender(), id, MintAction.BURN),\\n            getCurrentCycleIndex(DAY28) + 1,\\n            BurnSource.MINT\\n        );\\n    }\\n\\n    /** @notice Sets `amount` as the allowance of `spender` over the caller's (user) mints.\\n     * @param spender contract address\\n     * @param amount allowance amount\\n     */\\n    function approveBurnMints(address spender, uint256 amount) public returns (bool) {\\n        if (spender == address(0)) revert TitanX_InvalidAddress();\\n        s_allowanceBurnMints[_msgSender()][spender] = amount;\\n        emit ApproveBurnMints(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /** @notice Sets `amount` as the allowance of `spender` over the caller's (user) stakes.\\n     * @param spender contract address\\n     * @param amount allowance amount\\n     */\\n    function approveBurnStakes(address spender, uint256 amount) public returns (bool) {\\n        if (spender == address(0)) revert TitanX_InvalidAddress();\\n        s_allowanceBurnStakes[_msgSender()][spender] = amount;\\n        emit ApproveBurnStakes(_msgSender(), spender, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OwnerInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"./openzeppelin/utils/Context.sol\\\";\\n\\nerror TitanX_NotOnwer();\\n\\nabstract contract OwnerInfo is Context {\\n    address private s_owner;\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        s_owner = _msgSender();\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (s_owner != _msgSender()) revert TitanX_NotOnwer();\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        s_owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BurnInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"../libs/constant.sol\\\";\\nimport \\\"../libs/enum.sol\\\";\\n\\n/**\\n * @title BurnInfo\\n * @dev this contract is meant to be inherited into main contract\\n * @notice It has the variables and functions specifically for tracking burn amount and reward\\n */\\n\\nabstract contract BurnInfo {\\n    //Variables\\n    //track the total titan burn amount\\n    uint256 private s_totalTitanBurned;\\n\\n    //mappings\\n    //track wallet address -> total titan burn amount\\n    mapping(address => uint256) private s_userBurnAmount;\\n    //track contract/project address -> total titan burn amount\\n    mapping(address => uint256) private s_project_BurnAmount;\\n    //track contract/project address, wallet address -> total titan burn amount\\n    mapping(address => mapping(address => uint256)) private s_projectUser_BurnAmount;\\n\\n    /** @dev cycleIndex is increased when triggerPayouts() was called successfully\\n     * so we track data in current cycleIndex + 1 which means tracking for the next cycle payout\\n     * cycleIndex is passed from the TITANX contract during function call\\n     */\\n    //track cycleIndex + 1 -> total burn amount\\n    mapping(uint256 => uint256) private s_cycle28TotalBurn;\\n    //track address, cycleIndex + 1 -> total burn amount\\n    mapping(address => mapping(uint256 => uint256)) private s_userCycle28TotalBurn;\\n    //track cycleIndex + 1 -> burn payout per token\\n    mapping(uint256 => uint256) private s_cycle28BurnPayoutPerToken;\\n\\n    //events\\n    /** @dev log user burn titan event\\n     * project can be address(0) if user burns Titan directly from Titan contract\\n     * burnPoolCycleIndex is the cycle 28 index, which reuse the same index as Day 28 cycle index\\n     * titanSource 0=Liquid, 1=Mint, 2=Stake\\n     */\\n    event TitanBurned(\\n        address indexed user,\\n        address indexed project,\\n        uint256 indexed burnPoolCycleIndex,\\n        uint256 amount,\\n        BurnSource titanSource\\n    );\\n\\n    //functions\\n    /** @dev update the burn amount in each 28-cylce for user and project (if any)\\n     * @param user wallet address\\n     * @param project contract address\\n     * @param amount titan amount burned\\n     * @param cycleIndex cycle payout triggered index\\n     */\\n    function _updateBurnAmount(\\n        address user,\\n        address project,\\n        uint256 amount,\\n        uint256 cycleIndex,\\n        BurnSource source\\n    ) internal {\\n        s_userBurnAmount[user] += amount;\\n        s_totalTitanBurned += amount;\\n        s_cycle28TotalBurn[cycleIndex] += amount;\\n        s_userCycle28TotalBurn[user][cycleIndex] += amount;\\n\\n        if (project != address(0)) {\\n            s_project_BurnAmount[project] += amount;\\n            s_projectUser_BurnAmount[project][user] += amount;\\n        }\\n\\n        emit TitanBurned(user, project, cycleIndex, amount, source);\\n    }\\n\\n    /**\\n     * @dev calculate burn reward per titan burned based on total reward / total titan burned in current cycle\\n     * @param cycleIndex wallet address\\n     * @param reward contract address\\n     * @param cycleBurnAmount titan amount burned\\n     */\\n    function _calculateCycleBurnRewardPerToken(\\n        uint256 cycleIndex,\\n        uint256 reward,\\n        uint256 cycleBurnAmount\\n    ) internal {\\n        //add 18 decimals to reward for better precision in calculation\\n        s_cycle28BurnPayoutPerToken[cycleIndex] = (reward * SCALING_FACTOR_1e18) / cycleBurnAmount;\\n    }\\n\\n    /** @dev returned value is in 18 decimals, need to divide it by 1e18 and 100 (percentage) when using this value for reward calculation\\n     * The burn amplifier percentage is applied to all future mints. Capped at MAX_BURN_AMP_PERCENT (8%)\\n     * @param user wallet address\\n     * @return percentage returns percentage value in 18 decimals\\n     */\\n    function getUserBurnAmplifierBonus(address user) public view returns (uint256) {\\n        uint256 userBurnTotal = getUserBurnTotal(user);\\n        if (userBurnTotal == 0) return 0;\\n        if (userBurnTotal >= MAX_BURN_AMP_BASE) return MAX_BURN_AMP_PERCENT;\\n        return (MAX_BURN_AMP_PERCENT * userBurnTotal) / MAX_BURN_AMP_BASE;\\n    }\\n\\n    //views\\n    /** @notice return total burned titan amount from all users burn or projects burn\\n     * @return totalBurnAmount returns entire burned titan\\n     */\\n    function getTotalBurnTotal() public view returns (uint256) {\\n        return s_totalTitanBurned;\\n    }\\n\\n    /** @notice return user address total burned titan\\n     * @return userBurnAmount returns user address total burned titan\\n     */\\n    function getUserBurnTotal(address user) public view returns (uint256) {\\n        return s_userBurnAmount[user];\\n    }\\n\\n    /** @notice return project address total burned titan amount\\n     * @return projectTotalBurnAmount returns project total burned titan\\n     */\\n    function getProjectBurnTotal(address contractAddress) public view returns (uint256) {\\n        return s_project_BurnAmount[contractAddress];\\n    }\\n\\n    /** @notice return user address total burned titan amount via a project address\\n     * @param contractAddress project address\\n     * @param user user address\\n     * @return projectUserTotalBurnAmount returns user address total burned titan via a project address\\n     */\\n    function getProjectUserBurnTotal(\\n        address contractAddress,\\n        address user\\n    ) public view returns (uint256) {\\n        return s_projectUser_BurnAmount[contractAddress][user];\\n    }\\n\\n    /** @notice return cycle28 total burned titan amount with the specified cycleIndex\\n     * @param cycleIndex cycle index\\n     * @return cycle28TotalBurn returns cycle28 total burned titan amount with the specified cycleIndex\\n     */\\n    function getCycleBurnTotal(uint256 cycleIndex) public view returns (uint256) {\\n        return s_cycle28TotalBurn[cycleIndex];\\n    }\\n\\n    /** @notice return cycle28 total burned titan amount with the specified cycleIndex\\n     * @param user user address\\n     * @param cycleIndex cycle index\\n     * @return cycle28TotalBurn returns cycle28 user address total burned titan amount with the specified cycleIndex\\n     */\\n    function _getUserCycleBurnTotal(\\n        address user,\\n        uint256 cycleIndex\\n    ) internal view returns (uint256) {\\n        return s_userCycle28TotalBurn[user][cycleIndex];\\n    }\\n\\n    /** @notice return cycle28 burn payout per titan with the specified cycleIndex\\n     * @param cycleIndex cycle index\\n     * @return cycle28TotalBurn returns cycle28 burn payout per titan with the specified cycleIndex\\n     */\\n    function getCycleBurnPayoutPerToken(uint256 cycleIndex) public view returns (uint256) {\\n        return s_cycle28BurnPayoutPerToken[cycleIndex];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/StakeInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"../libs/calcFunctions.sol\\\";\\n\\n//custom errors\\nerror TitanX_InvalidStakeLength();\\nerror TitanX_RequireOneMinimumShare();\\nerror TitanX_ExceedMaxAmountPerStake();\\nerror TitanX_NoStakeExists();\\nerror TitanX_StakeHasEnded();\\nerror TitanX_StakeNotMatured();\\nerror TitanX_StakeHasBurned();\\nerror TitanX_MaxedWalletStakes();\\n\\nabstract contract StakeInfo {\\n    //Variables\\n    /** @dev track global stake Id */\\n    uint256 private s_globalStakeId;\\n    /** @dev track global shares */\\n    uint256 private s_globalShares;\\n    /** @dev track global expired shares */\\n    uint256 private s_globalExpiredShares;\\n    /** @dev track global staked titan */\\n    uint256 private s_globalTitanStaked;\\n    /** @dev track global end stake penalty */\\n    uint256 private s_globalStakePenalty;\\n    /** @dev track global ended stake */\\n    uint256 private s_globalStakeEnd;\\n    /** @dev track global burned stake */\\n    uint256 private s_globalStakeBurn;\\n\\n    //mappings\\n    /** @dev track address => stakeId */\\n    mapping(address => uint256) private s_addressSId;\\n    /** @dev track address, stakeId => global stake Id */\\n    mapping(address => mapping(uint256 => uint256)) private s_addressSIdToGlobalStakeId;\\n    /** @dev track global stake Id => stake info */\\n    mapping(uint256 => UserStakeInfo) private s_globalStakeIdToStakeInfo;\\n\\n    /** @dev track address => shares Index */\\n    mapping(address => uint256) private s_userSharesIndex;\\n    /** @dev track user total active shares by user shares index\\n     * s_addressIdToActiveShares[user][index] = UserActiveShares (contract day, total user active shares)\\n     * works like a snapshot or log when user shares has changed (increase/decrease)\\n     */\\n    mapping(address => mapping(uint256 => UserActiveShares)) private s_addressIdToActiveShares;\\n\\n    //structs\\n    struct UserStakeInfo {\\n        uint152 titanAmount;\\n        uint128 shares;\\n        uint16 numOfDays;\\n        uint48 stakeStartTs;\\n        uint48 maturityTs;\\n        StakeStatus status;\\n    }\\n\\n    struct UserStake {\\n        uint256 sId;\\n        uint256 globalStakeId;\\n        UserStakeInfo stakeInfo;\\n    }\\n\\n    struct UserActiveShares {\\n        uint256 day;\\n        uint256 activeShares;\\n    }\\n\\n    //events\\n    event StakeStarted(\\n        address indexed user,\\n        uint256 indexed globalStakeId,\\n        uint256 numOfDays,\\n        UserStakeInfo indexed userStakeInfo\\n    );\\n\\n    event StakeEnded(\\n        address indexed user,\\n        uint256 indexed globalStakeId,\\n        uint256 titanAmount,\\n        uint256 indexed penalty,\\n        uint256 penaltyAmount\\n    );\\n\\n    //functions\\n    /** @dev create a new stake\\n     * @param user user address\\n     * @param amount titan amount\\n     * @param numOfDays stake lenght\\n     * @param shareRate current share rate\\n     * @param day current contract day\\n     * @param isPayoutTriggered has global payout triggered\\n     * @return isFirstShares first created shares or not\\n     */\\n    function _startStake(\\n        address user,\\n        uint256 amount,\\n        uint256 numOfDays,\\n        uint256 shareRate,\\n        uint256 day,\\n        PayoutTriggered isPayoutTriggered\\n    ) internal returns (uint256 isFirstShares) {\\n        uint256 sId = ++s_addressSId[user];\\n        if (sId > MAX_STAKE_PER_WALLET) revert TitanX_MaxedWalletStakes();\\n        if (numOfDays < MIN_STAKE_LENGTH || numOfDays > MAX_STAKE_LENGTH)\\n            revert TitanX_InvalidStakeLength();\\n\\n        //calculate shares\\n        uint256 shares = calculateShares(amount, numOfDays, shareRate);\\n        if (shares / SCALING_FACTOR_1e18 < 1) revert TitanX_RequireOneMinimumShare();\\n\\n        uint256 currentGStakeId = ++s_globalStakeId;\\n        uint256 maturityTs;\\n\\n        maturityTs = block.timestamp + (numOfDays * SECONDS_IN_DAY);\\n\\n        UserStakeInfo memory userStakeInfo = UserStakeInfo({\\n            titanAmount: uint152(amount),\\n            shares: uint128(shares),\\n            numOfDays: uint16(numOfDays),\\n            stakeStartTs: uint48(block.timestamp),\\n            maturityTs: uint48(maturityTs),\\n            status: StakeStatus.ACTIVE\\n        });\\n\\n        /** s_addressSId[user] tracks stake Id for each address\\n         * s_addressSIdToGlobalStakeId[user][id] tracks stack id to global stake Id\\n         * s_globalStakeIdToStakeInfo[currentGStakeId] stores stake info\\n         */\\n        s_addressSIdToGlobalStakeId[user][sId] = currentGStakeId;\\n        s_globalStakeIdToStakeInfo[currentGStakeId] = userStakeInfo;\\n\\n        //update shares changes\\n        isFirstShares = _updateSharesStats(\\n            user,\\n            shares,\\n            amount,\\n            day,\\n            isPayoutTriggered,\\n            StakeAction.START\\n        );\\n\\n        emit StakeStarted(user, currentGStakeId, numOfDays, userStakeInfo);\\n    }\\n\\n    /** @dev end stake and calculate pinciple with penalties (if any) or burn stake\\n     * @param user user address\\n     * @param id stake Id\\n     * @param day current contract day\\n     * @param action end stake or burn stake\\n     * @param payOther is end stake for others\\n     * @param isPayoutTriggered has global payout triggered\\n     * @return titan titan principle\\n     */\\n    function _endStake(\\n        address user,\\n        uint256 id,\\n        uint256 day,\\n        StakeAction action,\\n        StakeAction payOther,\\n        PayoutTriggered isPayoutTriggered\\n    ) internal returns (uint256 titan) {\\n        uint256 globalStakeId = s_addressSIdToGlobalStakeId[user][id];\\n        if (globalStakeId == 0) revert TitanX_NoStakeExists();\\n\\n        UserStakeInfo memory userStakeInfo = s_globalStakeIdToStakeInfo[globalStakeId];\\n        if (userStakeInfo.status == StakeStatus.ENDED) revert TitanX_StakeHasEnded();\\n        if (userStakeInfo.status == StakeStatus.BURNED) revert TitanX_StakeHasBurned();\\n        //end stake for others requires matured stake to prevent EES for others\\n        if (payOther == StakeAction.END_OTHER && block.timestamp < userStakeInfo.maturityTs)\\n            revert TitanX_StakeNotMatured();\\n\\n        //update shares changes\\n        uint256 shares = userStakeInfo.shares;\\n        _updateSharesStats(user, shares, userStakeInfo.titanAmount, day, isPayoutTriggered, action);\\n\\n        if (action == StakeAction.END) {\\n            ++s_globalStakeEnd;\\n            s_globalStakeIdToStakeInfo[globalStakeId].status = StakeStatus.ENDED;\\n        } else if (action == StakeAction.BURN) {\\n            ++s_globalStakeBurn;\\n            s_globalStakeIdToStakeInfo[globalStakeId].status = StakeStatus.BURNED;\\n        }\\n\\n        titan = _calculatePrinciple(user, globalStakeId, userStakeInfo, action);\\n    }\\n\\n    /** @dev update shares changes to track when user shares has changed, this affect the payout calculation\\n     * @param user user address\\n     * @param shares shares\\n     * @param amount titan amount\\n     * @param day current contract day\\n     * @param isPayoutTriggered has global payout triggered\\n     * @param action start stake or end stake\\n     * @return isFirstShares first created shares or not\\n     */\\n    function _updateSharesStats(\\n        address user,\\n        uint256 shares,\\n        uint256 amount,\\n        uint256 day,\\n        PayoutTriggered isPayoutTriggered,\\n        StakeAction action\\n    ) private returns (uint256 isFirstShares) {\\n        //Get previous active shares to calculate new shares change\\n        uint256 index = s_userSharesIndex[user];\\n        uint256 previousShares = s_addressIdToActiveShares[user][index].activeShares;\\n\\n        if (action == StakeAction.START) {\\n            //return 1 if this is a new wallet address\\n            //this is used to initialize last claim index to the latest cycle index\\n            if (index == 0) isFirstShares = 1;\\n\\n            s_addressIdToActiveShares[user][++index].activeShares = previousShares + shares;\\n            s_globalShares += shares;\\n            s_globalTitanStaked += amount;\\n        } else {\\n            s_addressIdToActiveShares[user][++index].activeShares = previousShares - shares;\\n            s_globalExpiredShares += shares;\\n            s_globalTitanStaked -= amount;\\n        }\\n\\n        //If global payout hasn't triggered, use current contract day to eligible for payout\\n        //If global payout has triggered, then start with next contract day as it's no longer eligible to claim latest payout\\n        s_addressIdToActiveShares[user][index].day = uint128(\\n            isPayoutTriggered == PayoutTriggered.NO ? day : day + 1\\n        );\\n\\n        s_userSharesIndex[user] = index;\\n    }\\n\\n    /** @dev calculate stake principle and apply penalty (if any)\\n     * @param user user address\\n     * @param globalStakeId global stake Id\\n     * @param userStakeInfo stake info\\n     * @param action end stake or burn stake\\n     * @return principle calculated principle after penalty (if any)\\n     */\\n    function _calculatePrinciple(\\n        address user,\\n        uint256 globalStakeId,\\n        UserStakeInfo memory userStakeInfo,\\n        StakeAction action\\n    ) internal returns (uint256 principle) {\\n        uint256 titanAmount = userStakeInfo.titanAmount;\\n        //penalty is in percentage\\n        uint256 penalty = calculateEndStakePenalty(\\n            userStakeInfo.stakeStartTs,\\n            userStakeInfo.maturityTs,\\n            block.timestamp,\\n            action\\n        );\\n\\n        uint256 penaltyAmount;\\n        penaltyAmount = (titanAmount * penalty) / 100;\\n        principle = titanAmount - penaltyAmount;\\n        s_globalStakePenalty += penaltyAmount;\\n\\n        emit StakeEnded(user, globalStakeId, principle, penalty, penaltyAmount);\\n    }\\n\\n    //Views\\n    /** @notice get global shares\\n     * @return globalShares global shares\\n     */\\n    function getGlobalShares() public view returns (uint256) {\\n        return s_globalShares;\\n    }\\n\\n    /** @notice get global expired shares\\n     * @return globalExpiredShares global expired shares\\n     */\\n    function getGlobalExpiredShares() public view returns (uint256) {\\n        return s_globalExpiredShares;\\n    }\\n\\n    /** @notice get global active shares\\n     * @return globalActiveShares global active shares\\n     */\\n    function getGlobalActiveShares() public view returns (uint256) {\\n        return s_globalShares - s_globalExpiredShares;\\n    }\\n\\n    /** @notice get total titan staked\\n     * @return totalTitanStaked total titan staked\\n     */\\n    function getTotalTitanStaked() public view returns (uint256) {\\n        return s_globalTitanStaked;\\n    }\\n\\n    /** @notice get global stake id\\n     * @return globalStakeId global stake id\\n     */\\n    function getGlobalStakeId() public view returns (uint256) {\\n        return s_globalStakeId;\\n    }\\n\\n    /** @notice get global active stakes\\n     * @return globalActiveStakes global active stakes\\n     */\\n    function getGlobalActiveStakes() public view returns (uint256) {\\n        return s_globalStakeId - getTotalStakeEnd();\\n    }\\n\\n    /** @notice get total stake ended\\n     * @return totalStakeEnded total stake ended\\n     */\\n    function getTotalStakeEnd() public view returns (uint256) {\\n        return s_globalStakeEnd;\\n    }\\n\\n    /** @notice get total stake burned\\n     * @return totalStakeBurned total stake burned\\n     */\\n    function getTotalStakeBurn() public view returns (uint256) {\\n        return s_globalStakeBurn;\\n    }\\n\\n    /** @notice get total end stake penalty\\n     * @return totalEndStakePenalty total end stake penalty\\n     */\\n    function getTotalStakePenalty() public view returns (uint256) {\\n        return s_globalStakePenalty;\\n    }\\n\\n    /** @notice get user latest shares index\\n     * @return latestSharesIndex latest shares index\\n     */\\n    function getUserLatestShareIndex(address user) public view returns (uint256) {\\n        return s_userSharesIndex[user];\\n    }\\n\\n    /** @notice get user current active shares\\n     * @return currentActiveShares current active shares\\n     */\\n    function getUserCurrentActiveShares(address user) public view returns (uint256) {\\n        return s_addressIdToActiveShares[user][getUserLatestShareIndex(user)].activeShares;\\n    }\\n\\n    /** @notice get user active shares at sharesIndex\\n     * @return activeShares active shares at sharesIndex\\n     */\\n    function getUserActiveShares(\\n        address user,\\n        uint256 sharesIndex\\n    ) internal view returns (uint256) {\\n        return s_addressIdToActiveShares[user][sharesIndex].activeShares;\\n    }\\n\\n    /** @notice get user active shares contract day at sharesIndex\\n     * @return activeSharesDay active shares contract day at sharesIndex\\n     */\\n    function getUserActiveSharesDay(\\n        address user,\\n        uint256 sharesIndex\\n    ) internal view returns (uint256) {\\n        return s_addressIdToActiveShares[user][sharesIndex].day;\\n    }\\n\\n    /** @notice get stake info with stake id\\n     * @return stakeInfo stake info\\n     */\\n    function getUserStakeInfo(address user, uint256 id) public view returns (UserStakeInfo memory) {\\n        return s_globalStakeIdToStakeInfo[s_addressSIdToGlobalStakeId[user][id]];\\n    }\\n\\n    /** @notice get all stake info of an address\\n     * @return stakeInfos all stake info of an address\\n     */\\n    function getUserStakes(address user) public view returns (UserStake[] memory) {\\n        uint256 count = s_addressSId[user];\\n        UserStake[] memory stakes = new UserStake[](count);\\n\\n        for (uint256 i = 1; i <= count; i++) {\\n            stakes[i - 1] = UserStake({\\n                sId: i,\\n                globalStakeId: uint128(s_addressSIdToGlobalStakeId[user][i]),\\n                stakeInfo: getUserStakeInfo(user, i)\\n            });\\n        }\\n\\n        return stakes;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MintInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"../libs/calcFunctions.sol\\\";\\n\\n//custom errors\\nerror TitanX_InvalidMintLength();\\nerror TitanX_InvalidMintPower();\\nerror TitanX_NoMintExists();\\nerror TitanX_MintHasClaimed();\\nerror TitanX_MintNotMature();\\nerror TitanX_MintHasBurned();\\n\\nabstract contract MintInfo {\\n    //variables\\n    /** @dev track global tRank */\\n    uint256 private s_globalTRank;\\n    /** @dev track total mint claimed */\\n    uint256 private s_globalMintClaim;\\n    /** @dev track total mint burned */\\n    uint256 private s_globalMintBurn;\\n    /** @dev track total titan minting */\\n    uint256 private s_globalTitanMinting;\\n    /** @dev track total titan penalty */\\n    uint256 private s_globalTitanMintPenalty;\\n    /** @dev track global mint power */\\n    uint256 private s_globalMintPower;\\n\\n    //mappings\\n    /** @dev track address => mintId */\\n    mapping(address => uint256) private s_addressMId;\\n    /** @dev track address, mintId => tRank info (gTrank, gMintPower) */\\n    mapping(address => mapping(uint256 => TRankInfo)) private s_addressMIdToTRankInfo;\\n    /** @dev track global tRank => mintInfo*/\\n    mapping(uint256 => UserMintInfo) private s_tRankToMintInfo;\\n\\n    //structs\\n    struct UserMintInfo {\\n        uint8 mintPower;\\n        uint16 numOfDays;\\n        uint96 mintableTitan;\\n        uint48 mintStartTs;\\n        uint48 maturityTs;\\n        uint32 mintPowerBonus;\\n        uint32 EAABonus;\\n        uint128 mintedTitan;\\n        uint64 mintCost;\\n        MintStatus status;\\n    }\\n\\n    struct TRankInfo {\\n        uint256 tRank;\\n        uint256 gMintPower;\\n    }\\n\\n    struct UserMint {\\n        uint256 mId;\\n        uint256 tRank;\\n        uint256 gMintPower;\\n        UserMintInfo mintInfo;\\n    }\\n\\n    //events\\n    event MintStarted(\\n        address indexed user,\\n        uint256 indexed tRank,\\n        uint256 indexed gMintpower,\\n        UserMintInfo userMintInfo\\n    );\\n\\n    event MintClaimed(\\n        address indexed user,\\n        uint256 indexed tRank,\\n        uint256 rewardMinted,\\n        uint256 indexed penalty,\\n        uint256 mintPenalty\\n    );\\n\\n    //functions\\n    /** @dev create a new mint\\n     * @param user user address\\n     * @param mintPower mint power\\n     * @param numOfDays mint lenght\\n     * @param mintableTitan mintable titan\\n     * @param mintPowerBonus mint power bonus\\n     * @param EAABonus EAA bonus\\n     * @param burnAmpBonus burn amplifier bonus\\n     * @param gMintPower global mint power\\n     * @param currentTRank current global tRank\\n     * @param mintCost actual mint cost paid for a mint\\n     */\\n    function _startMint(\\n        address user,\\n        uint256 mintPower,\\n        uint256 numOfDays,\\n        uint256 mintableTitan,\\n        uint256 mintPowerBonus,\\n        uint256 EAABonus,\\n        uint256 burnAmpBonus,\\n        uint256 gMintPower,\\n        uint256 currentTRank,\\n        uint256 mintCost\\n    ) internal returns (uint256 mintable) {\\n        if (numOfDays == 0 || numOfDays > MAX_MINT_LENGTH) revert TitanX_InvalidMintLength();\\n        if (mintPower == 0 || mintPower > MAX_MINT_POWER_CAP) revert TitanX_InvalidMintPower();\\n\\n        //calculate mint reward up front with the provided params\\n        mintable = calculateMintReward(mintPower, numOfDays, mintableTitan, EAABonus, burnAmpBonus);\\n\\n        //store variables into mint info\\n        UserMintInfo memory userMintInfo = UserMintInfo({\\n            mintPower: uint8(mintPower),\\n            numOfDays: uint16(numOfDays),\\n            mintableTitan: uint96(mintable),\\n            mintPowerBonus: uint32(mintPowerBonus),\\n            EAABonus: uint32(EAABonus),\\n            mintStartTs: uint48(block.timestamp),\\n            maturityTs: uint48(block.timestamp + (numOfDays * SECONDS_IN_DAY)),\\n            mintedTitan: 0,\\n            mintCost: uint64(mintCost),\\n            status: MintStatus.ACTIVE\\n        });\\n\\n        /** s_addressMId[user] tracks mintId for each addrress\\n         * s_addressMIdToTRankInfo[user][id] tracks current mint tRank and gPowerMint\\n         *  s_tRankToMintInfo[currentTRank] stores mint info\\n         */\\n        uint256 id = ++s_addressMId[user];\\n        s_addressMIdToTRankInfo[user][id].tRank = currentTRank;\\n        s_addressMIdToTRankInfo[user][id].gMintPower = gMintPower;\\n        s_tRankToMintInfo[currentTRank] = userMintInfo;\\n\\n        emit MintStarted(user, currentTRank, gMintPower, userMintInfo);\\n    }\\n\\n    /** @dev create new mint in a batch of up to max 100 mints with the same mint length\\n     * @param user user address\\n     * @param mintPower mint power\\n     * @param numOfDays mint lenght\\n     * @param mintableTitan mintable titan\\n     * @param mintPowerBonus mint power bonus\\n     * @param EAABonus EAA bonus\\n     * @param burnAmpBonus burn amplifier bonus\\n     * @param mintCost actual mint cost paid for a mint\\n     */\\n    function _startBatchMint(\\n        address user,\\n        uint256 mintPower,\\n        uint256 numOfDays,\\n        uint256 mintableTitan,\\n        uint256 mintPowerBonus,\\n        uint256 EAABonus,\\n        uint256 burnAmpBonus,\\n        uint256 count,\\n        uint256 mintCost\\n    ) internal {\\n        uint256 gMintPower = s_globalMintPower;\\n        uint256 currentTRank = s_globalTRank;\\n        uint256 gMinting = s_globalTitanMinting;\\n\\n        for (uint256 i = 0; i < count; i++) {\\n            gMintPower += mintPower;\\n            gMinting += _startMint(\\n                user,\\n                mintPower,\\n                numOfDays,\\n                mintableTitan,\\n                mintPowerBonus,\\n                EAABonus,\\n                burnAmpBonus,\\n                gMintPower,\\n                ++currentTRank,\\n                mintCost\\n            );\\n        }\\n        _updateMintStats(currentTRank, gMintPower, gMinting);\\n    }\\n\\n    /** @dev create new mint in a batch of up to max 100 mints with different mint length\\n     * @param user user address\\n     * @param mintPower mint power\\n     * @param minDay minimum start day\\n     * @param maxDay maximum end day\\n     * @param dayInterval days interval between each new mint length\\n     * @param countPerInterval number of mint(s) to create in each mint length interval\\n     * @param mintableTitan mintable titan\\n     * @param mintPowerBonus mint power bonus\\n     * @param EAABonus EAA bonus\\n     * @param burnAmpBonus burn amplifier bonus\\n     * @param mintCost actual mint cost paid for a mint\\n     */\\n    function _startbatchMintLadder(\\n        address user,\\n        uint256 mintPower,\\n        uint256 minDay,\\n        uint256 maxDay,\\n        uint256 dayInterval,\\n        uint256 countPerInterval,\\n        uint256 mintableTitan,\\n        uint256 mintPowerBonus,\\n        uint256 EAABonus,\\n        uint256 burnAmpBonus,\\n        uint256 mintCost\\n    ) internal {\\n        uint256 gMintPower = s_globalMintPower;\\n        uint256 currentTRank = s_globalTRank;\\n        uint256 gMinting = s_globalTitanMinting;\\n\\n        /**first for loop is used to determine mint length\\n         * minDay is the starting mint length\\n         * maxDay is the max mint length where it stops\\n         * dayInterval increases the minDay for the next mint\\n         */\\n        for (; minDay <= maxDay; minDay += dayInterval) {\\n            /**first for loop is used to determine mint length\\n             * second for loop is to create number mints per mint length\\n             */\\n            for (uint256 j = 0; j < countPerInterval; j++) {\\n                gMintPower += mintPower;\\n                gMinting += _startMint(\\n                    user,\\n                    mintPower,\\n                    minDay,\\n                    mintableTitan,\\n                    mintPowerBonus,\\n                    EAABonus,\\n                    burnAmpBonus,\\n                    gMintPower,\\n                    ++currentTRank,\\n                    mintCost\\n                );\\n            }\\n        }\\n        _updateMintStats(currentTRank, gMintPower, gMinting);\\n    }\\n\\n    /** @dev update variables\\n     * @param currentTRank current tRank\\n     * @param gMintPower current global mint power\\n     * @param gMinting current global minting\\n     */\\n    function _updateMintStats(uint256 currentTRank, uint256 gMintPower, uint256 gMinting) internal {\\n        s_globalTRank = currentTRank;\\n        s_globalMintPower = gMintPower;\\n        s_globalTitanMinting = gMinting;\\n    }\\n\\n    /** @dev calculate reward for claim mint or burn mint.\\n     * Claim mint has maturity check while burn mint would bypass maturity check.\\n     * @param user user address\\n     * @param id mint id\\n     * @param action claim mint or burn mint\\n     * @return reward calculated final reward after all bonuses and penalty (if any)\\n     */\\n    function _claimMint(\\n        address user,\\n        uint256 id,\\n        MintAction action\\n    ) internal returns (uint256 reward) {\\n        uint256 tRank = s_addressMIdToTRankInfo[user][id].tRank;\\n        uint256 gMintPower = s_addressMIdToTRankInfo[user][id].gMintPower;\\n        if (tRank == 0) revert TitanX_NoMintExists();\\n\\n        UserMintInfo memory mint = s_tRankToMintInfo[tRank];\\n        if (mint.status == MintStatus.CLAIMED) revert TitanX_MintHasClaimed();\\n        if (mint.status == MintStatus.BURNED) revert TitanX_MintHasBurned();\\n\\n        //Only check maturity for claim mint action, burn mint bypass this check\\n        if (mint.maturityTs > block.timestamp && action == MintAction.CLAIM)\\n            revert TitanX_MintNotMature();\\n\\n        s_globalTitanMinting -= mint.mintableTitan;\\n        reward = _calculateClaimReward(user, tRank, gMintPower, mint, action);\\n    }\\n\\n    /** @dev calculate reward up to 100 claims for batch claim function. Only calculate active and matured mints.\\n     * @param user user address\\n     * @return reward total batch claims final calculated reward after all bonuses and penalty (if any)\\n     */\\n    function _batchClaimMint(address user) internal returns (uint256 reward) {\\n        uint256 maxId = s_addressMId[user];\\n        uint256 claimCount;\\n        uint256 tRank;\\n        uint256 gMinting;\\n        UserMintInfo memory mint;\\n\\n        for (uint256 i = 1; i <= maxId; i++) {\\n            tRank = s_addressMIdToTRankInfo[user][i].tRank;\\n            mint = s_tRankToMintInfo[tRank];\\n            if (mint.status == MintStatus.ACTIVE && block.timestamp >= mint.maturityTs) {\\n                reward += _calculateClaimReward(\\n                    user,\\n                    tRank,\\n                    s_addressMIdToTRankInfo[user][i].gMintPower,\\n                    mint,\\n                    MintAction.CLAIM\\n                );\\n\\n                gMinting += mint.mintableTitan;\\n                ++claimCount;\\n            }\\n\\n            if (claimCount == 100) break;\\n        }\\n\\n        s_globalTitanMinting -= gMinting;\\n    }\\n\\n    /** @dev calculate final reward with bonuses and penalty (if any)\\n     * @param user user address\\n     * @param tRank mint's tRank\\n     * @param gMintPower mint's gMintPower\\n     * @param userMintInfo mint's info\\n     * @param action claim mint or burn mint\\n     * @return reward calculated final reward after all bonuses and penalty (if any)\\n     */\\n    function _calculateClaimReward(\\n        address user,\\n        uint256 tRank,\\n        uint256 gMintPower,\\n        UserMintInfo memory userMintInfo,\\n        MintAction action\\n    ) private returns (uint256 reward) {\\n        if (action == MintAction.CLAIM) s_tRankToMintInfo[tRank].status = MintStatus.CLAIMED;\\n        if (action == MintAction.BURN) s_tRankToMintInfo[tRank].status = MintStatus.BURNED;\\n\\n        uint256 penaltyAmount;\\n        uint256 penalty;\\n        uint256 bonus;\\n\\n        //only calculate penalty when current block timestamp > maturity timestamp\\n        if (block.timestamp > userMintInfo.maturityTs) {\\n            penalty = calculateClaimMintPenalty(block.timestamp - userMintInfo.maturityTs);\\n        }\\n\\n        //Only Claim action has mintPower bonus\\n        if (action == MintAction.CLAIM) {\\n            bonus = calculateMintPowerBonus(\\n                userMintInfo.mintPowerBonus,\\n                userMintInfo.mintPower,\\n                gMintPower,\\n                s_globalMintPower\\n            );\\n        }\\n\\n        //mintPowerBonus has scaling factor of 1e7, so divide by 1e7\\n        reward = uint256(userMintInfo.mintableTitan) + (bonus / SCALING_FACTOR_1e7);\\n        penaltyAmount = (reward * penalty) / 100;\\n        reward -= penaltyAmount;\\n\\n        if (action == MintAction.CLAIM) ++s_globalMintClaim;\\n        if (action == MintAction.BURN) ++s_globalMintBurn;\\n        if (penaltyAmount != 0) s_globalTitanMintPenalty += penaltyAmount;\\n\\n        //only stored minted amount for claim mint\\n        if (action == MintAction.CLAIM) s_tRankToMintInfo[tRank].mintedTitan = uint128(reward);\\n\\n        emit MintClaimed(user, tRank, reward, penalty, penaltyAmount);\\n    }\\n\\n    //views\\n    /** @notice Returns the latest Mint Id of an address\\n     * @param user address\\n     * @return mId latest mint id\\n     */\\n    function getUserLatestMintId(address user) public view returns (uint256) {\\n        return s_addressMId[user];\\n    }\\n\\n    /** @notice Returns mint info of an address + mint id\\n     * @param user address\\n     * @param id mint id\\n     * @return mintInfo user mint info\\n     */\\n    function getUserMintInfo(\\n        address user,\\n        uint256 id\\n    ) public view returns (UserMintInfo memory mintInfo) {\\n        return s_tRankToMintInfo[s_addressMIdToTRankInfo[user][id].tRank];\\n    }\\n\\n    /** @notice Return all mints info of an address\\n     * @param user address\\n     * @return mintInfos all mints info of an address including mint id, tRank and gMintPower\\n     */\\n    function getUserMints(address user) public view returns (UserMint[] memory mintInfos) {\\n        uint256 count = s_addressMId[user];\\n        mintInfos = new UserMint[](count);\\n\\n        for (uint256 i = 1; i <= count; i++) {\\n            mintInfos[i - 1] = UserMint({\\n                mId: i,\\n                tRank: s_addressMIdToTRankInfo[user][i].tRank,\\n                gMintPower: s_addressMIdToTRankInfo[user][i].gMintPower,\\n                mintInfo: getUserMintInfo(user, i)\\n            });\\n        }\\n    }\\n\\n    /** @notice Return total mints burned\\n     * @return totalMintBurned total mints burned\\n     */\\n    function getTotalMintBurn() public view returns (uint256) {\\n        return s_globalMintBurn;\\n    }\\n\\n    /** @notice Return current gobal tRank\\n     * @return globalTRank global tRank\\n     */\\n    function getGlobalTRank() public view returns (uint256) {\\n        return s_globalTRank;\\n    }\\n\\n    /** @notice Return current gobal mint power\\n     * @return globalMintPower global mint power\\n     */\\n    function getGlobalMintPower() public view returns (uint256) {\\n        return s_globalMintPower;\\n    }\\n\\n    /** @notice Return total mints claimed\\n     * @return totalMintClaimed total mints claimed\\n     */\\n    function getTotalMintClaim() public view returns (uint256) {\\n        return s_globalMintClaim;\\n    }\\n\\n    /** @notice Return total active mints (exluded claimed and burned mints)\\n     * @return totalActiveMints total active mints\\n     */\\n    function getTotalActiveMints() public view returns (uint256) {\\n        return s_globalTRank - s_globalMintClaim - s_globalMintBurn;\\n    }\\n\\n    /** @notice Return total minting titan\\n     * @return totalMinting total minting titan\\n     */\\n    function getTotalMinting() public view returns (uint256) {\\n        return s_globalTitanMinting;\\n    }\\n\\n    /** @notice Return total titan penalty\\n     * @return totalTitanPenalty total titan penalty\\n     */\\n    function getTotalMintPenalty() public view returns (uint256) {\\n        return s_globalTitanMintPenalty;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GlobalInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"../libs/enum.sol\\\";\\nimport \\\"../libs/constant.sol\\\";\\n\\nabstract contract GlobalInfo {\\n    //Variables\\n    //deployed timestamp\\n    uint256 private immutable i_genesisTs;\\n\\n    /** @dev track current contract day */\\n    uint256 private s_currentContractDay;\\n    /** @dev shareRate starts 800 ether and increases capped at 2800 ether, uint72 has enough size */\\n    uint72 private s_currentshareRate;\\n    /** @dev mintCost starts 0.2 ether increases and capped at 1 ether, uint64 has enough size */\\n    uint64 private s_currentMintCost;\\n    /** @dev mintableTitan starts 8m ether decreases and capped at 800 ether, uint96 has enough size */\\n    uint96 private s_currentMintableTitan;\\n    /** @dev mintPowerBonus starts 350_000_000 and decreases capped at 35_000, uint32 has enough size */\\n    uint32 private s_currentMintPowerBonus;\\n    /** @dev EAABonus starts 10_000_000 and decreases to 0, uint32 has enough size */\\n    uint32 private s_currentEAABonus;\\n\\n    /** @dev track if any of the cycle day 8, 28, 90, 369, 888 has payout triggered succesfully\\n     * this is used in end stake where either the shares change should be tracked in current/next payout cycle\\n     */\\n    PayoutTriggered private s_isGlobalPayoutTriggered;\\n\\n    /** @dev track payouts based on every cycle day 8, 28, 90, 369, 888 when distributeETH() is called */\\n    mapping(uint256 => uint256) private s_cyclePayouts;\\n\\n    /** @dev track payout index for each cycle day, increased by 1 when triggerPayouts() is called succesfully\\n     *  eg. curent index is 2, s_cyclePayoutIndex[DAY8] = 2 */\\n    mapping(uint256 => uint256) private s_cyclePayoutIndex;\\n\\n    /** @dev track payout info (day and payout per share) for each cycle day\\n     * eg. s_cyclePayoutIndex is 2,\\n     *  s_CyclePayoutPerShare[DAY8][2].day = 8\\n     * s_CyclePayoutPerShare[DAY8][2].payoutPerShare = 0.1\\n     */\\n    mapping(uint256 => mapping(uint256 => CycleRewardPerShare)) private s_cyclePayoutPerShare;\\n\\n    /** @dev track user last payout reward claim index for cycleIndex, burnCycleIndex and sharesIndex\\n     * so calculation would start from next index instead of the first index\\n     * [address][DAY8].cycleIndex = 1\\n     * [address][DAY8].burnCycleIndex = 1\\n     * [address][DAY8].sharesIndex = 2\\n     * cycleIndex is the last stop in s_cyclePayoutPerShare\\n     * sharesIndex is the last stop in s_addressIdToActiveShares\\n     */\\n    mapping(address => mapping(uint256 => UserCycleClaimIndex))\\n        private s_addressCycleToLastClaimIndex;\\n\\n    /** @dev track when is the next cycle payout day for each cycle day\\n     * eg. s_nextCyclePayoutDay[DAY8] = 8\\n     *     s_nextCyclePayoutDay[DAY28] = 28\\n     */\\n    mapping(uint256 => uint256) s_nextCyclePayoutDay;\\n\\n    //structs\\n    struct CycleRewardPerShare {\\n        uint256 day;\\n        uint256 payoutPerShare;\\n    }\\n\\n    struct UserCycleClaimIndex {\\n        uint96 cycleIndex;\\n        uint96 burnCycleIndex;\\n        uint64 sharesIndex;\\n    }\\n\\n    //event\\n    event GlobalDailyUpdateStats(\\n        uint256 indexed day,\\n        uint256 indexed mintCost,\\n        uint256 indexed shareRate,\\n        uint256 mintableTitan,\\n        uint256 mintPowerBonus,\\n        uint256 EAABonus\\n    );\\n\\n    /** @dev Update variables in terms of day, modifier is used in all external/public functions (exclude view)\\n     * Every interaction to the contract would run this function to update variables\\n     */\\n    modifier dailyUpdate() {\\n        _dailyUpdate();\\n        _;\\n    }\\n\\n    constructor() {\\n        i_genesisTs = block.timestamp;\\n        s_currentContractDay = 1;\\n        s_currentMintCost = uint64(START_MAX_MINT_COST);\\n        s_currentMintableTitan = uint96(START_MAX_MINTABLE_PER_DAY);\\n        s_currentshareRate = uint72(START_SHARE_RATE);\\n        s_currentMintPowerBonus = uint32(START_MINTPOWER_INCREASE_BONUS);\\n        s_currentEAABonus = uint32(EAA_START);\\n        s_nextCyclePayoutDay[DAY8] = DAY8;\\n        s_nextCyclePayoutDay[DAY28] = DAY28;\\n        s_nextCyclePayoutDay[DAY90] = DAY90;\\n        s_nextCyclePayoutDay[DAY369] = DAY369;\\n        s_nextCyclePayoutDay[DAY888] = DAY888;\\n    }\\n\\n    /** @dev calculate and update variables daily and reset triggers flag */\\n    function _dailyUpdate() private {\\n        uint256 currentContractDay = s_currentContractDay;\\n        uint256 currentBlockDay = ((block.timestamp - i_genesisTs) / 1 days) + 1;\\n\\n        if (currentBlockDay > currentContractDay) {\\n            //get last day info ready for calculation\\n            uint256 newMintCost = s_currentMintCost;\\n            uint256 newShareRate = s_currentshareRate;\\n            uint256 newMintableTitan = s_currentMintableTitan;\\n            uint256 newMintPowerBonus = s_currentMintPowerBonus;\\n            uint256 newEAABonus = s_currentEAABonus;\\n            uint256 dayDifference = currentBlockDay - currentContractDay;\\n\\n            /** Reason for a for loop to update Mint supply\\n             * Ideally, user interaction happens daily, so Mint supply is synced in every day\\n             *      (cylceDifference = 1)\\n             * However, if there's no interaction for more than 1 day, then\\n             *      Mint supply isn't updated correctly due to cylceDifference > 1 day\\n             * Eg. 2 days of no interaction, then interaction happens in 3rd day.\\n             *     It's incorrect to only decrease the Mint supply one time as now it's in 3rd day.\\n             *   And if this happens, there will be no tracked data for the skipped days as not needed\\n             */\\n            for (uint256 i; i < dayDifference; i++) {\\n                newMintCost = (newMintCost * DAILY_MINT_COST_INCREASE_STEP) / PERCENT_BPS;\\n                newShareRate = (newShareRate * DAILY_SHARE_RATE_INCREASE_STEP) / PERCENT_BPS;\\n                newMintableTitan =\\n                    (newMintableTitan * DAILY_SUPPLY_MINTABLE_REDUCTION) /\\n                    PERCENT_BPS;\\n                newMintPowerBonus =\\n                    (newMintPowerBonus * DAILY_MINTPOWER_INCREASE_BONUS_REDUCTION) /\\n                    PERCENT_BPS;\\n\\n                if (newMintCost > 1 ether) {\\n                    newMintCost = CAPPED_MAX_MINT_COST;\\n                }\\n\\n                if (newShareRate > CAPPED_MAX_RATE) newShareRate = CAPPED_MAX_RATE;\\n\\n                if (newMintableTitan < CAPPED_MIN_DAILY_TITAN_MINTABLE) {\\n                    newMintableTitan = CAPPED_MIN_DAILY_TITAN_MINTABLE;\\n                }\\n\\n                if (newMintPowerBonus < CAPPED_MIN_MINTPOWER_BONUS) {\\n                    newMintPowerBonus = CAPPED_MIN_MINTPOWER_BONUS;\\n                }\\n\\n                if (currentBlockDay <= MAX_BONUS_DAY) {\\n                    newEAABonus -= EAA_BONUSE_FIXED_REDUCTION_PER_DAY;\\n                } else {\\n                    newEAABonus = EAA_END;\\n                }\\n\\n                emit GlobalDailyUpdateStats(\\n                    ++currentContractDay,\\n                    newMintCost,\\n                    newShareRate,\\n                    newMintableTitan,\\n                    newMintPowerBonus,\\n                    newEAABonus\\n                );\\n            }\\n\\n            s_currentMintCost = uint64(newMintCost);\\n            s_currentshareRate = uint72(newShareRate);\\n            s_currentMintableTitan = uint96(newMintableTitan);\\n            s_currentMintPowerBonus = uint32(newMintPowerBonus);\\n            s_currentEAABonus = uint32(newEAABonus);\\n            s_currentContractDay = currentBlockDay;\\n            s_isGlobalPayoutTriggered = PayoutTriggered.NO;\\n        }\\n    }\\n\\n    /** @dev first created shares will start from the last payout index + 1 (next cycle payout)\\n     * as first shares will always disqualified from past payouts\\n     * reduce gas cost needed to loop from first index\\n     * @param user user address\\n     * @param isFirstShares flag to only initialize when address is fresh wallet\\n     */\\n    function _initFirstSharesCycleIndex(address user, uint256 isFirstShares) internal {\\n        if (isFirstShares == 1) {\\n            if (s_cyclePayoutIndex[DAY8] != 0) {\\n                s_addressCycleToLastClaimIndex[user][DAY8].cycleIndex = uint96(\\n                    s_cyclePayoutIndex[DAY8] + 1\\n                );\\n\\n                s_addressCycleToLastClaimIndex[user][DAY28].cycleIndex = uint96(\\n                    s_cyclePayoutIndex[DAY28] + 1\\n                );\\n\\n                s_addressCycleToLastClaimIndex[user][DAY90].cycleIndex = uint96(\\n                    s_cyclePayoutIndex[DAY90] + 1\\n                );\\n\\n                s_addressCycleToLastClaimIndex[user][DAY369].cycleIndex = uint96(\\n                    s_cyclePayoutIndex[DAY369] + 1\\n                );\\n\\n                s_addressCycleToLastClaimIndex[user][DAY888].cycleIndex = uint96(\\n                    s_cyclePayoutIndex[DAY888] + 1\\n                );\\n            }\\n        }\\n    }\\n\\n    /** @dev first created shares will start from the last payout index + 1 (next cycle payout)\\n     * as first shares will always disqualified from past payouts\\n     * reduce gas cost needed to loop from first index\\n     * @param cycleNo cylce day 8, 28, 90, 369, 888\\n     * @param reward total accumulated reward in cycle day 8, 28, 90, 369, 888\\n     * @param globalActiveShares global active shares\\n     * @return index return latest current cycleIndex\\n     */\\n    function _calculateCycleRewardPerShare(\\n        uint256 cycleNo,\\n        uint256 reward,\\n        uint256 globalActiveShares\\n    ) internal returns (uint256 index) {\\n        s_cyclePayouts[cycleNo] = 0;\\n        index = ++s_cyclePayoutIndex[cycleNo];\\n        //add 18 decimals to reward for better precision in calculation\\n        s_cyclePayoutPerShare[cycleNo][index].payoutPerShare =\\n            (reward * SCALING_FACTOR_1e18) /\\n            globalActiveShares;\\n        s_cyclePayoutPerShare[cycleNo][index].day = getCurrentContractDay();\\n    }\\n\\n    /** @dev update with the last index where a user has claimed the payout reward\\n     * @param user user address\\n     * @param cycleNo cylce day 8, 28, 90, 369, 888\\n     * @param userClaimCycleIndex last claimed cycle index\\n     * @param userClaimSharesIndex last claimed shares index\\n     */\\n    function _updateUserClaimIndexes(\\n        address user,\\n        uint256 cycleNo,\\n        uint256 userClaimCycleIndex,\\n        uint256 userClaimSharesIndex\\n    ) internal {\\n        if (userClaimCycleIndex != s_addressCycleToLastClaimIndex[user][cycleNo].cycleIndex)\\n            s_addressCycleToLastClaimIndex[user][cycleNo].cycleIndex = uint96(userClaimCycleIndex);\\n\\n        if (userClaimSharesIndex != s_addressCycleToLastClaimIndex[user][cycleNo].sharesIndex)\\n            s_addressCycleToLastClaimIndex[user][cycleNo].sharesIndex = uint64(\\n                userClaimSharesIndex\\n            );\\n    }\\n\\n    /** @dev update with the last index where a user has claimed the burn payout reward\\n     * @param user user address\\n     * @param cycleNo cylce day 8, 28, 90, 369, 888\\n     * @param userClaimBurnCycleIndex last claimed burn cycle index\\n     */\\n    function _updateUserBurnCycleClaimIndex(\\n        address user,\\n        uint256 cycleNo,\\n        uint256 userClaimBurnCycleIndex\\n    ) internal {\\n        if (userClaimBurnCycleIndex != s_addressCycleToLastClaimIndex[user][cycleNo].burnCycleIndex)\\n            s_addressCycleToLastClaimIndex[user][cycleNo].burnCycleIndex = uint96(\\n                userClaimBurnCycleIndex\\n            );\\n    }\\n\\n    /** @dev set to YES when any of the cycle days payout is triggered\\n     * reset to NO in new contract day\\n     */\\n    function _setGlobalPayoutTriggered() internal {\\n        s_isGlobalPayoutTriggered = PayoutTriggered.YES;\\n    }\\n\\n    /** @dev add reward into cycle day 8, 28, 90, 369, 888 pool\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     * @param reward reward from distributeETH()\\n     */\\n    function _setCyclePayoutPool(uint256 cycleNo, uint256 reward) internal {\\n        s_cyclePayouts[cycleNo] += reward;\\n    }\\n\\n    /** @dev calculate and update the next payout day for specified cycleNo\\n     * the formula will update the payout day based on current contract day\\n     * this is to make sure the value is correct when for some reason has skipped more than one cycle payout\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     */\\n    function _setNextCyclePayoutDay(uint256 cycleNo) internal {\\n        uint256 maturityDay = s_nextCyclePayoutDay[cycleNo];\\n        uint256 currentContractDay = s_currentContractDay;\\n        if (currentContractDay >= maturityDay) {\\n            s_nextCyclePayoutDay[cycleNo] +=\\n                cycleNo *\\n                (((currentContractDay - maturityDay) / cycleNo) + 1);\\n        }\\n    }\\n\\n    /** Views */\\n    /** @notice Returns current block timestamp\\n     * @return currentBlockTs current block timestamp\\n     */\\n    function getCurrentBlockTimeStamp() public view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /** @notice Returns current contract day\\n     * @return currentContractDay current contract day\\n     */\\n    function getCurrentContractDay() public view returns (uint256) {\\n        return s_currentContractDay;\\n    }\\n\\n    /** @notice Returns current mint cost\\n     * @return currentMintCost current block timestamp\\n     */\\n    function getCurrentMintCost() public view returns (uint256) {\\n        return s_currentMintCost;\\n    }\\n\\n    /** @notice Returns current share rate\\n     * @return currentShareRate current share rate\\n     */\\n    function getCurrentShareRate() public view returns (uint256) {\\n        return s_currentshareRate;\\n    }\\n\\n    /** @notice Returns current mintable titan\\n     * @return currentMintableTitan current mintable titan\\n     */\\n    function getCurrentMintableTitan() public view returns (uint256) {\\n        return s_currentMintableTitan;\\n    }\\n\\n    /** @notice Returns current mint power bonus\\n     * @return currentMintPowerBonus current mint power bonus\\n     */\\n    function getCurrentMintPowerBonus() public view returns (uint256) {\\n        return s_currentMintPowerBonus;\\n    }\\n\\n    /** @notice Returns current contract EAA bonus\\n     * @return currentEAABonus current EAA bonus\\n     */\\n    function getCurrentEAABonus() public view returns (uint256) {\\n        return s_currentEAABonus;\\n    }\\n\\n    /** @notice Returns current cycle index for the specified cycle day\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     * @return currentCycleIndex current cycle index to track the payouts\\n     */\\n    function getCurrentCycleIndex(uint256 cycleNo) public view returns (uint256) {\\n        return s_cyclePayoutIndex[cycleNo];\\n    }\\n\\n    /** @notice Returns whether payout is triggered successfully in any cylce day\\n     * @return isTriggered 0 or 1, 0= No, 1=Yes\\n     */\\n    function getGlobalPayoutTriggered() public view returns (PayoutTriggered) {\\n        return s_isGlobalPayoutTriggered;\\n    }\\n\\n    /** @notice Returns the distributed pool reward for the specified cycle day\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     * @return currentPayoutPool current accumulated payout pool\\n     */\\n    function getCyclePayoutPool(uint256 cycleNo) public view returns (uint256) {\\n        return s_cyclePayouts[cycleNo];\\n    }\\n\\n    /** @notice Returns the calculated payout per share and contract day for the specified cycle day and index\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     * @param index cycle index\\n     * @return payoutPerShare calculated payout per share\\n     * @return triggeredDay the day when payout was triggered to perform calculation\\n     */\\n    function getPayoutPerShare(\\n        uint256 cycleNo,\\n        uint256 index\\n    ) public view returns (uint256, uint256) {\\n        return (\\n            s_cyclePayoutPerShare[cycleNo][index].payoutPerShare,\\n            s_cyclePayoutPerShare[cycleNo][index].day\\n        );\\n    }\\n\\n    /** @notice Returns user's last claimed shares payout indexes for the specified cycle day\\n     * @param user user address\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     * @return cycleIndex cycle index\\n     * @return sharesIndex shares index\\n     \\n     */\\n    function getUserLastClaimIndex(\\n        address user,\\n        uint256 cycleNo\\n    ) public view returns (uint256 cycleIndex, uint256 sharesIndex) {\\n        return (\\n            s_addressCycleToLastClaimIndex[user][cycleNo].cycleIndex,\\n            s_addressCycleToLastClaimIndex[user][cycleNo].sharesIndex\\n        );\\n    }\\n\\n    /** @notice Returns user's last claimed burn payout index for the specified cycle day\\n     * @param user user address\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     * @return burnCycleIndex burn cycle index\\n     */\\n    function getUserLastBurnClaimIndex(\\n        address user,\\n        uint256 cycleNo\\n    ) public view returns (uint256 burnCycleIndex) {\\n        return s_addressCycleToLastClaimIndex[user][cycleNo].burnCycleIndex;\\n    }\\n\\n    /** @notice Returns contract deployment block timestamp\\n     * @return genesisTs deployed timestamp\\n     */\\n    function genesisTs() public view returns (uint256) {\\n        return i_genesisTs;\\n    }\\n\\n    /** @notice Returns next payout day for the specified cycle day\\n     * @param cycleNo cycle day 8, 28, 90, 369, 888\\n     * @return nextPayoutDay next payout day\\n     */\\n    function getNextCyclePayoutDay(uint256 cycleNo) public view returns (uint256) {\\n        return s_nextCyclePayoutDay[cycleNo];\\n    }\\n}\\n\"\r\n    },\r\n    \"libs/calcFunctions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nimport \\\"./constant.sol\\\";\\nimport \\\"./enum.sol\\\";\\n\\n//TitanX\\n/**@notice get batch mint ladder total count\\n * @param minDay minimum mint length\\n * @param maxDay maximum mint length, cap at 280\\n * @param dayInterval day increase from previous mint length\\n * @param countPerInterval number of mints per minth length\\n * @return count total mints\\n */\\nfunction getBatchMintLadderCount(\\n    uint256 minDay,\\n    uint256 maxDay,\\n    uint256 dayInterval,\\n    uint256 countPerInterval\\n) pure returns (uint256 count) {\\n    if (maxDay > minDay) {\\n        count = (((maxDay - minDay) / dayInterval) + 1) * countPerInterval;\\n    }\\n}\\n\\n/** @notice get incentive fee in 4 decimals scaling\\n * @return fee fee\\n */\\nfunction getIncentiveFeePercent() pure returns (uint256) {\\n    return (INCENTIVE_FEE_PERCENT * 1e4) / INCENTIVE_FEE_PERCENT_BASE;\\n}\\n\\n/** @notice get batch mint cost\\n * @param mintPower mint power (1 - 100)\\n * @param count number of mints\\n * @return mintCost total mint cost\\n */\\nfunction getBatchMintCost(\\n    uint256 mintPower,\\n    uint256 count,\\n    uint256 mintCost\\n) pure returns (uint256) {\\n    return (mintCost * mintPower * count) / MAX_MINT_POWER_CAP;\\n}\\n\\n//MintInfo\\n\\n/** @notice the formula to calculate mint reward at create new mint\\n * @param mintPower mint power 1 - 100\\n * @param numOfDays mint length 1 - 280\\n * @param mintableTitan current contract day mintable titan\\n * @param EAABonus current contract day EAA Bonus\\n * @param burnAmpBonus user burn amplifier bonus from getUserBurnAmplifierBonus(user)\\n * @return reward base titan amount\\n */\\nfunction calculateMintReward(\\n    uint256 mintPower,\\n    uint256 numOfDays,\\n    uint256 mintableTitan,\\n    uint256 EAABonus,\\n    uint256 burnAmpBonus\\n) pure returns (uint256 reward) {\\n    uint256 baseReward = (mintableTitan * mintPower * numOfDays);\\n    if (numOfDays != 1)\\n        baseReward -= (baseReward * MINT_DAILY_REDUCTION * (numOfDays - 1)) / PERCENT_BPS;\\n\\n    reward = baseReward;\\n    if (EAABonus != 0) {\\n        //EAA Bonus has 1e6 scaling, so here divide by 1e6\\n        reward += ((baseReward * EAABonus) / 100 / SCALING_FACTOR_1e6);\\n    }\\n\\n    if (burnAmpBonus != 0) {\\n        //burnAmpBonus has 1e18 scaling\\n        reward += (baseReward * burnAmpBonus) / 100 / SCALING_FACTOR_1e18;\\n    }\\n\\n    reward /= MAX_MINT_POWER_CAP;\\n}\\n\\n/** @notice the formula to calculate bonus reward\\n * heavily influenced by the difference between current global mint power and user mint's global mint power\\n * @param mintPowerBonus mint power bonus from mintinfo\\n * @param mintPower mint power 1 - 100 from mintinfo\\n * @param gMintPower global mint power from mintinfo\\n * @param globalMintPower current global mint power\\n * @return bonus bonus amount in titan\\n */\\nfunction calculateMintPowerBonus(\\n    uint256 mintPowerBonus,\\n    uint256 mintPower,\\n    uint256 gMintPower,\\n    uint256 globalMintPower\\n) pure returns (uint256 bonus) {\\n    if (globalMintPower <= gMintPower) return 0;\\n    bonus = (((mintPowerBonus * mintPower * (globalMintPower - gMintPower)) * SCALING_FACTOR_1e18) /\\n        MAX_MINT_POWER_CAP);\\n}\\n\\n/** @notice Return max mint length\\n * @return maxMintLength max mint length\\n */\\nfunction getMaxMintDays() pure returns (uint256) {\\n    return MAX_MINT_LENGTH;\\n}\\n\\n/** @notice Return max mints per wallet\\n * @return maxMintPerWallet max mints per wallet\\n */\\nfunction getMaxMintsPerWallet() pure returns (uint256) {\\n    return MAX_MINT_PER_WALLET;\\n}\\n\\n/**\\n * @dev Return penalty percentage based on number of days late after the grace period of 7 days\\n * @param secsLate seconds late (block timestamp - maturity timestamp)\\n * @return penalty penalty in percentage\\n */\\nfunction calculateClaimMintPenalty(uint256 secsLate) pure returns (uint256 penalty) {\\n    if (secsLate <= CLAIM_MINT_GRACE_PERIOD * SECONDS_IN_DAY) return 0;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 1) * SECONDS_IN_DAY) return 1;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 2) * SECONDS_IN_DAY) return 3;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 3) * SECONDS_IN_DAY) return 8;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 4) * SECONDS_IN_DAY) return 17;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 5) * SECONDS_IN_DAY) return 35;\\n    if (secsLate <= (CLAIM_MINT_GRACE_PERIOD + 6) * SECONDS_IN_DAY) return 72;\\n    return 99;\\n}\\n\\n//StakeInfo\\n\\nerror TitanX_AtLeastHalfMaturity();\\n\\n/** @notice get max stake length\\n * @return maxStakeLength max stake length\\n */\\nfunction getMaxStakeLength() pure returns (uint256) {\\n    return MAX_STAKE_LENGTH;\\n}\\n\\n/** @notice calculate shares and shares bonus\\n * @param amount titan amount\\n * @param noOfDays stake length\\n * @param shareRate current contract share rate\\n * @return shares calculated shares in 18 decimals\\n */\\nfunction calculateShares(\\n    uint256 amount,\\n    uint256 noOfDays,\\n    uint256 shareRate\\n) pure returns (uint256) {\\n    uint256 shares = amount;\\n    shares += (shares * calculateShareBonus(amount, noOfDays)) / SCALING_FACTOR_1e11;\\n    shares /= (shareRate / SCALING_FACTOR_1e18);\\n    return shares;\\n}\\n\\n/** @notice calculate share bonus\\n * @param amount titan amount\\n * @param noOfDays stake length\\n * @return shareBonus calculated shares bonus in 11 decimals\\n */\\nfunction calculateShareBonus(uint256 amount, uint256 noOfDays) pure returns (uint256 shareBonus) {\\n    uint256 cappedExtraDays = noOfDays <= LPB_MAX_DAYS ? noOfDays : LPB_MAX_DAYS;\\n    uint256 cappedStakedTitan = amount <= BPB_MAX_TITAN ? amount : BPB_MAX_TITAN;\\n    shareBonus =\\n        ((cappedExtraDays * SCALING_FACTOR_1e11) / LPB_PER_PERCENT) +\\n        ((cappedStakedTitan * SCALING_FACTOR_1e11) / BPB_PER_PERCENT);\\n    return shareBonus;\\n}\\n\\n/** @notice calculate end stake penalty\\n * @param stakeStartTs start stake timestamp\\n * @param maturityTs  maturity timestamp\\n * @param currentBlockTs current block timestamp\\n * @param action end stake or burn stake\\n * @return penalty penalty in percentage\\n */\\nfunction calculateEndStakePenalty(\\n    uint256 stakeStartTs,\\n    uint256 maturityTs,\\n    uint256 currentBlockTs,\\n    StakeAction action\\n) view returns (uint256) {\\n    //Matured, then calculate and return penalty\\n    if (currentBlockTs > maturityTs) {\\n        uint256 lateSec = currentBlockTs - maturityTs;\\n        uint256 gracePeriodSec = END_STAKE_GRACE_PERIOD * SECONDS_IN_DAY;\\n        if (lateSec <= gracePeriodSec) return 0;\\n        return max((min((lateSec - gracePeriodSec), 1) / SECONDS_IN_DAY) + 1, 99);\\n    }\\n\\n    //burn stake is excluded from penalty\\n    //if not matured and action is burn stake then return 0\\n    if (action == StakeAction.BURN) return 0;\\n\\n    //Emergency End Stake\\n    //Not allow to EES below 50% maturity\\n    if (block.timestamp < stakeStartTs + (maturityTs - stakeStartTs) / 2)\\n        revert TitanX_AtLeastHalfMaturity();\\n\\n    //50% penalty for EES before maturity timestamp\\n    return 50;\\n}\\n\\n//a - input to check against b\\n//b - minimum number\\nfunction min(uint256 a, uint256 b) pure returns (uint256) {\\n    if (a > b) return a;\\n    return b;\\n}\\n\\n//a - input to check against b\\n//b - maximum number\\nfunction max(uint256 a, uint256 b) pure returns (uint256) {\\n    if (a > b) return b;\\n    return a;\\n}\\n\"\r\n    },\r\n    \"interfaces/ITITANX.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\ninterface ITITANX {\\n    function balanceOf(address account) external returns (uint256);\\n\\n    function getBalance() external;\\n\\n    function mintLPTokens() external;\\n\\n    function burnLPTokens() external;\\n}\\n\"\r\n    },\r\n    \"interfaces/ITitanOnBurn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\ninterface ITitanOnBurn {\\n    function onBurn(address user, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"contracts/openzeppelin/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"libs/enum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\nenum MintAction {\\n    CLAIM,\\n    BURN\\n}\\nenum MintStatus {\\n    ACTIVE,\\n    CLAIMED,\\n    BURNED\\n}\\nenum StakeAction {\\n    START,\\n    END,\\n    BURN,\\n    END_OWN,\\n    END_OTHER\\n}\\nenum StakeStatus {\\n    ACTIVE,\\n    ENDED,\\n    BURNED\\n}\\nenum PayoutTriggered {\\n    NO,\\n    YES\\n}\\nenum InitialLPMinted {\\n    NO,\\n    YES\\n}\\nenum PayoutClaim {\\n    SHARES,\\n    BURN\\n}\\nenum BurnSource {\\n    LIQUID,\\n    MINT,\\n    STAKE\\n}\\nenum BurnPoolEnabled {\\n    FALSE,\\n    TRUE\\n}\\n\"\r\n    },\r\n    \"libs/constant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.10;\\n\\n// ===================== common ==========================================\\nuint256 constant SECONDS_IN_DAY = 86400;\\nuint256 constant SCALING_FACTOR_1e3 = 1e3;\\nuint256 constant SCALING_FACTOR_1e6 = 1e6;\\nuint256 constant SCALING_FACTOR_1e7 = 1e7;\\nuint256 constant SCALING_FACTOR_1e11 = 1e11;\\nuint256 constant SCALING_FACTOR_1e18 = 1e18;\\n\\n// ===================== TITANX ==========================================\\nuint256 constant PERCENT_TO_BUY_AND_BURN = 62_00;\\nuint256 constant PERCENT_TO_CYCLE_PAYOUTS = 28_00;\\nuint256 constant PERCENT_TO_BURN_PAYOUTS = 7_00;\\nuint256 constant PERCENT_TO_GENESIS = 3_00;\\n\\nuint256 constant INCENTIVE_FEE_PERCENT = 3300;\\nuint256 constant INCENTIVE_FEE_PERCENT_BASE = 1_000_000;\\n\\nuint256 constant INITAL_LP_TOKENS = 100_000_000_000 ether;\\n\\n// ===================== globalInfo ==========================================\\n//Titan Supply Variables\\nuint256 constant START_MAX_MINTABLE_PER_DAY = 8_000_000 ether;\\nuint256 constant CAPPED_MIN_DAILY_TITAN_MINTABLE = 800 ether;\\nuint256 constant DAILY_SUPPLY_MINTABLE_REDUCTION = 99_65;\\n\\n//EAA Variables\\nuint256 constant EAA_START = 10 * SCALING_FACTOR_1e6;\\nuint256 constant EAA_BONUSE_FIXED_REDUCTION_PER_DAY = 28_571;\\nuint256 constant EAA_END = 0;\\nuint256 constant MAX_BONUS_DAY = 350;\\n\\n//Mint Cost Variables\\nuint256 constant START_MAX_MINT_COST = 0.2 ether;\\nuint256 constant CAPPED_MAX_MINT_COST = 1 ether;\\nuint256 constant DAILY_MINT_COST_INCREASE_STEP = 100_08;\\n\\n//mintPower Bonus Variables\\nuint256 constant START_MINTPOWER_INCREASE_BONUS = 35 * SCALING_FACTOR_1e7; //starts at 35 with 1e7 scaling factor\\nuint256 constant CAPPED_MIN_MINTPOWER_BONUS = 35 * SCALING_FACTOR_1e3; //capped min of 0.0035 * 1e7 = 35 * 1e3\\nuint256 constant DAILY_MINTPOWER_INCREASE_BONUS_REDUCTION = 99_65;\\n\\n//Share Rate Variables\\nuint256 constant START_SHARE_RATE = 800 ether;\\nuint256 constant DAILY_SHARE_RATE_INCREASE_STEP = 100_03;\\nuint256 constant CAPPED_MAX_RATE = 2_800 ether;\\n\\n//Cycle Variables\\nuint256 constant DAY8 = 8;\\nuint256 constant DAY28 = 28;\\nuint256 constant DAY90 = 90;\\nuint256 constant DAY369 = 369;\\nuint256 constant DAY888 = 888;\\nuint256 constant CYCLE_8_PERCENT = 28_00;\\nuint256 constant CYCLE_28_PERCENT = 28_00;\\nuint256 constant CYCLE_90_PERCENT = 18_00;\\nuint256 constant CYCLE_369_PERCENT = 18_00;\\nuint256 constant CYCLE_888_PERCENT = 8_00;\\nuint256 constant PERCENT_BPS = 100_00;\\n\\n// ===================== mintInfo ==========================================\\nuint256 constant MAX_MINT_POWER_CAP = 100;\\nuint256 constant MAX_MINT_LENGTH = 280;\\nuint256 constant CLAIM_MINT_GRACE_PERIOD = 7;\\nuint256 constant MAX_BATCH_MINT_COUNT = 100;\\nuint256 constant MAX_MINT_PER_WALLET = 1000;\\nuint256 constant MAX_BURN_AMP_BASE = 80 * 1e9 * 1 ether;\\nuint256 constant MAX_BURN_AMP_PERCENT = 8 ether;\\nuint256 constant MINT_DAILY_REDUCTION = 11;\\n\\n// ===================== stakeInfo ==========================================\\nuint256 constant MAX_STAKE_PER_WALLET = 1000;\\nuint256 constant MIN_STAKE_LENGTH = 28;\\nuint256 constant MAX_STAKE_LENGTH = 3500;\\nuint256 constant END_STAKE_GRACE_PERIOD = 7;\\n\\n/* Stake Longer Pays Better bonus */\\nuint256 constant LPB_MAX_DAYS = 2888;\\nuint256 constant LPB_PER_PERCENT = 825;\\n\\n/* Stake Bigger Pays Better bonus */\\nuint256 constant BPB_MAX_TITAN = 100 * 1e9 * SCALING_FACTOR_1e18; //100 billion\\nuint256 constant BPB_PER_PERCENT = 1_250_000_000_000 * SCALING_FACTOR_1e18;\\n\\n// ===================== burnInfo ==========================================\\nuint256 constant MAX_BURN_REWARD_PERCENT = 8;\\n\"\r\n    },\r\n    \"contracts/openzeppelin/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"genesisAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyAndBurnAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"TitanX_AtLeastHalfMaturity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_EmptyUndistributeFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_FailedToSendAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InsufficientBurnAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InsufficientProtocolFees\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InvalidBatchCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InvalidBurnRewardPercent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InvalidMintLadderInterval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InvalidMintLadderRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InvalidMintLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InvalidMintPower\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_InvalidStakeLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_LPTokensHasMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_MaxedWalletMints\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_MaxedWalletStakes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_MintHasBurned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_MintHasClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_MintNotMature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_NoCycleRewardToClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_NoMintExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_NoSharesExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_NoStakeExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_NotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_NotOnwer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_NotSupportedContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_RequireOneMinimumShare\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_StakeHasBurned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_StakeHasEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TitanX_StakeNotMatured\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"project\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ApproveBurnMints\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"project\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ApproveBurnStakes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnReward\",\"type\":\"uint256\"}],\"name\":\"CyclePayoutTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ETHDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"mintCost\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"shareRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintableTitan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintPowerBonus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"EAABonus\",\"type\":\"uint256\"}],\"name\":\"GlobalDailyUpdateStats\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tRank\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintPenalty\",\"type\":\"uint256\"}],\"name\":\"MintClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tRank\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"gMintpower\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"mintPower\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"mintableTitan\",\"type\":\"uint96\"},{\"internalType\":\"uint48\",\"name\":\"mintStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"mintPowerBonus\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"EAABonus\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"mintedTitan\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"mintCost\",\"type\":\"uint64\"},{\"internalType\":\"enum MintStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct MintInfo.UserMintInfo\",\"name\":\"userMintInfo\",\"type\":\"tuple\"}],\"name\":\"MintStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeRecevied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"globalStakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"titanAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"name\":\"StakeEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"globalStakeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numOfDays\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint152\",\"name\":\"titanAmount\",\"type\":\"uint152\"},{\"internalType\":\"uint128\",\"name\":\"shares\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"stakeStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"enum StakeStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"indexed\":true,\"internalType\":\"struct StakeInfo.UserStakeInfo\",\"name\":\"userStakeInfo\",\"type\":\"tuple\"}],\"name\":\"StakeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"project\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"burnPoolCycleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum BurnSource\",\"name\":\"titanSource\",\"type\":\"uint8\"}],\"name\":\"TitanBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowanceBurnMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowanceBurnStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveBurnMints\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveBurnStakes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchClaimMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numOfDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dayInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"countPerInterval\",\"type\":\"uint256\"}],\"name\":\"batchMintLadder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnLPTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"burnMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRebatePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPaybackPercentage\",\"type\":\"uint256\"}],\"name\":\"burnStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRebatePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPaybackPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rewardPaybackAddress\",\"type\":\"address\"}],\"name\":\"burnStakeToPayAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRebatePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPaybackPercentage\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userRebatePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPaybackPercentage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rewardPaybackAddress\",\"type\":\"address\"}],\"name\":\"burnTokensToPayAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"claimMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimUserAvailableETHBurnPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimUserAvailableETHPayouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableBurnPoolReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"endStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"endStakeForOthers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentBlockTimeStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentContractDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getCurrentCycleIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEAABonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMintPowerBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMintableTitan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentShareRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentUserBurnCyclePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleIndex\",\"type\":\"uint256\"}],\"name\":\"getCycleBurnPayoutPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCycleBurnPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleIndex\",\"type\":\"uint256\"}],\"name\":\"getCycleBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getCyclePayoutPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalActiveShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalActiveStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalExpiredShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalMintPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalPayoutTriggered\",\"outputs\":[{\"internalType\":\"enum PayoutTriggered\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalStakeId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalTRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getNextCyclePayoutDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getPayoutPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"getProjectBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getProjectUserBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalActiveMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMintPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMinting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPenalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakeBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakeEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakePenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalTitanStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUndistributedEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserBurnAmplifierBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserBurnPoolETHClaimableTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserCurrentActiveShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserCycleBurnTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserETHClaimableTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getUserLastBurnClaimIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"burnCycleIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cycleNo\",\"type\":\"uint256\"}],\"name\":\"getUserLastClaimIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cycleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLatestMintId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLatestShareIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserMintInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"mintPower\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"mintableTitan\",\"type\":\"uint96\"},{\"internalType\":\"uint48\",\"name\":\"mintStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"mintPowerBonus\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"EAABonus\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"mintedTitan\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"mintCost\",\"type\":\"uint64\"},{\"internalType\":\"enum MintStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct MintInfo.UserMintInfo\",\"name\":\"mintInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserMints\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gMintPower\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"mintPower\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint96\",\"name\":\"mintableTitan\",\"type\":\"uint96\"},{\"internalType\":\"uint48\",\"name\":\"mintStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"mintPowerBonus\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"EAABonus\",\"type\":\"uint32\"},{\"internalType\":\"uint128\",\"name\":\"mintedTitan\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"mintCost\",\"type\":\"uint64\"},{\"internalType\":\"enum MintStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct MintInfo.UserMintInfo\",\"name\":\"mintInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct MintInfo.UserMint[]\",\"name\":\"mintInfos\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserStakeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint152\",\"name\":\"titanAmount\",\"type\":\"uint152\"},{\"internalType\":\"uint128\",\"name\":\"shares\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"stakeStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"enum StakeStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct StakeInfo.UserStakeInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"globalStakeId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint152\",\"name\":\"titanAmount\",\"type\":\"uint152\"},{\"internalType\":\"uint128\",\"name\":\"shares\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"numOfDays\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"stakeStartTs\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturityTs\",\"type\":\"uint48\"},{\"internalType\":\"enum StakeStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct StakeInfo.UserStakeInfo\",\"name\":\"stakeInfo\",\"type\":\"tuple\"}],\"internalType\":\"struct StakeInfo.UserStake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBurnPoolEnabled\",\"outputs\":[{\"internalType\":\"enum BurnPoolEnabled\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDailyUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintLPTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setBuyAndBurnContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setNewGenesisAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numOfDays\",\"type\":\"uint256\"}],\"name\":\"startMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numOfDays\",\"type\":\"uint256\"}],\"name\":\"startStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerPayouts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"userBurnMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"userBurnStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"userBurnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TITANX", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "20", "ConstructorArguments": "000000000000000000000000e5e0c13133782d967b002b3400e6ebea5d9814c00000000000000000000000001393ad734ea3c52865b4b541cf049dafd25c23a5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}