{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(int256 value) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV // Deprecated in v4.8\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature` or error string. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n     *\r\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\r\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\r\n            mstore(0x1c, hash)\r\n            message := keccak256(0x00, 0x3c)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, \"\\x19\\x01\")\r\n            mstore(add(ptr, 0x02), domainSeparator)\r\n            mstore(add(ptr, 0x22), structHash)\r\n            data := keccak256(ptr, 0x42)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\r\n     * `validator` and `data` according to the version 0 of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/draft-EIP712.sol)\r\n\r\n// EIP-712 is Final as of 2022-08-11. This file is deprecated.\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\r\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```solidity\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\r\n * _Available since v4.9 for `string`, `bytes`._\r\n */\r\nlibrary StorageSlot {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n\r\n    struct StringSlot {\r\n        string value;\r\n    }\r\n\r\n    struct BytesSlot {\r\n        bytes value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\r\n     */\r\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\r\n     */\r\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\r\n     */\r\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r.slot := store.slot\r\n        }\r\n    }\r\n}\r\n\r\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\r\n// | length  | 0x                                                              BB |\r\ntype ShortString is bytes32;\r\n\r\n/**\r\n * @dev This library provides functions to convert short memory strings\r\n * into a `ShortString` type that can be used as an immutable variable.\r\n *\r\n * Strings of arbitrary length can be optimized using this library if\r\n * they are short enough (up to 31 bytes) by packing them with their\r\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\r\n * fallback mechanism can be used for every other case.\r\n *\r\n * Usage example:\r\n *\r\n * ```solidity\r\n * contract Named {\r\n *     using ShortStrings for *;\r\n *\r\n *     ShortString private immutable _name;\r\n *     string private _nameFallback;\r\n *\r\n *     constructor(string memory contractName) {\r\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\r\n *     }\r\n *\r\n *     function name() external view returns (string memory) {\r\n *         return _name.toStringWithFallback(_nameFallback);\r\n *     }\r\n * }\r\n * ```\r\n */\r\nlibrary ShortStrings {\r\n    // Used as an identifier for strings longer than 31 bytes.\r\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\r\n\r\n    error StringTooLong(string str);\r\n    error InvalidShortString();\r\n\r\n    /**\r\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\r\n     *\r\n     * This will trigger a `StringTooLong` error is the input string is too long.\r\n     */\r\n    function toShortString(string memory str) internal pure returns (ShortString) {\r\n        bytes memory bstr = bytes(str);\r\n        if (bstr.length > 31) {\r\n            revert StringTooLong(str);\r\n        }\r\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\r\n    }\r\n\r\n    /**\r\n     * @dev Decode a `ShortString` back to a \"normal\" string.\r\n     */\r\n    function toString(ShortString sstr) internal pure returns (string memory) {\r\n        uint256 len = byteLength(sstr);\r\n        // using `new string(len)` would work locally but is not memory safe.\r\n        string memory str = new string(32);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(str, len)\r\n            mstore(add(str, 0x20), sstr)\r\n        }\r\n        return str;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the length of a `ShortString`.\r\n     */\r\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\r\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\r\n        if (result > 31) {\r\n            revert InvalidShortString();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\r\n     */\r\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\r\n        if (bytes(value).length < 32) {\r\n            return toShortString(value);\r\n        } else {\r\n            StorageSlot.getStringSlot(store).value = value;\r\n            return ShortString.wrap(_FALLBACK_SENTINEL);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\r\n     */\r\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\r\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\r\n            return toString(value);\r\n        } else {\r\n            return store;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\r\n     *\r\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\r\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\r\n     */\r\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\r\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\r\n            return byteLength(value);\r\n        } else {\r\n            return bytes(store).length;\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\r\n\r\ninterface IERC5267 {\r\n    /**\r\n     * @dev MAY be emitted to signal that the domain could have changed.\r\n     */\r\n    event EIP712DomainChanged();\r\n\r\n    /**\r\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\r\n     * signature.\r\n     */\r\n    function eip712Domain()\r\n        external\r\n        view\r\n        returns (\r\n            bytes1 fields,\r\n            string memory name,\r\n            string memory version,\r\n            uint256 chainId,\r\n            address verifyingContract,\r\n            bytes32 salt,\r\n            uint256[] memory extensions\r\n        );\r\n}\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\r\n *\r\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\r\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\r\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\r\n *\r\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\r\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\r\n * ({_hashTypedDataV4}).\r\n *\r\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\r\n * the chain id to protect against replay attacks on an eventual fork of the chain.\r\n *\r\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\r\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\r\n *\r\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\r\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\r\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\r\n *\r\n * _Available since v3.4._\r\n *\r\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\r\n */\r\nabstract contract EIP712 is IERC5267 {\r\n    using ShortStrings for *;\r\n\r\n    bytes32 private constant _TYPE_HASH =\r\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n\r\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\r\n    // invalidate the cached domain separator if the chain id changes.\r\n    bytes32 private immutable _cachedDomainSeparator;\r\n    uint256 private immutable _cachedChainId;\r\n    address private immutable _cachedThis;\r\n\r\n    bytes32 private immutable _hashedName;\r\n    bytes32 private immutable _hashedVersion;\r\n\r\n    ShortString private immutable _name;\r\n    ShortString private immutable _version;\r\n    string private _nameFallback;\r\n    string private _versionFallback;\r\n\r\n    /**\r\n     * @dev Initializes the domain separator and parameter caches.\r\n     *\r\n     * The meaning of `name` and `version` is specified in\r\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\r\n     *\r\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\r\n     * - `version`: the current major version of the signing domain.\r\n     *\r\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\r\n     * contract upgrade].\r\n     */\r\n    constructor(string memory name, string memory version) {\r\n        _name = name.toShortStringWithFallback(_nameFallback);\r\n        _version = version.toShortStringWithFallback(_versionFallback);\r\n        _hashedName = keccak256(bytes(name));\r\n        _hashedVersion = keccak256(bytes(version));\r\n\r\n        _cachedChainId = block.chainid;\r\n        _cachedDomainSeparator = _buildDomainSeparator();\r\n        _cachedThis = address(this);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the domain separator for the current chain.\r\n     */\r\n    function _domainSeparatorV4() internal view returns (bytes32) {\r\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\r\n            return _cachedDomainSeparator;\r\n        } else {\r\n            return _buildDomainSeparator();\r\n        }\r\n    }\r\n\r\n    function _buildDomainSeparator() private view returns (bytes32) {\r\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\r\n     * function returns the hash of the fully encoded EIP712 message for this domain.\r\n     *\r\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\r\n     *\r\n     * ```solidity\r\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\r\n     *     keccak256(\"Mail(address to,string contents)\"),\r\n     *     mailTo,\r\n     *     keccak256(bytes(mailContents))\r\n     * )));\r\n     * address signer = ECDSA.recover(digest, signature);\r\n     * ```\r\n     */\r\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\r\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\r\n    }\r\n\r\n    /**\r\n     * @dev See {EIP-5267}.\r\n     *\r\n     * _Available since v4.9._\r\n     */\r\n    function eip712Domain()\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (\r\n            bytes1 fields,\r\n            string memory name,\r\n            string memory version,\r\n            uint256 chainId,\r\n            address verifyingContract,\r\n            bytes32 salt,\r\n            uint256[] memory extensions\r\n        )\r\n    {\r\n        return (\r\n            hex\"0f\", // 01111\r\n            _name.toStringWithFallback(_nameFallback),\r\n            _version.toStringWithFallback(_versionFallback),\r\n            block.chainid,\r\n            address(this),\r\n            bytes32(0),\r\n            new uint256[](0)\r\n        );\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\r\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint248 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint248).\r\n     *\r\n     * Counterpart to Solidity's `uint248` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 248 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint248(uint256 value) internal pure returns (uint248) {\r\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\r\n        return uint248(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint240 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint240).\r\n     *\r\n     * Counterpart to Solidity's `uint240` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 240 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint240(uint256 value) internal pure returns (uint240) {\r\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\r\n        return uint240(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint232 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint232).\r\n     *\r\n     * Counterpart to Solidity's `uint232` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 232 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint232(uint256 value) internal pure returns (uint232) {\r\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\r\n        return uint232(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint224 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint224).\r\n     *\r\n     * Counterpart to Solidity's `uint224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function toUint224(uint256 value) internal pure returns (uint224) {\r\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\r\n        return uint224(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint216 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint216).\r\n     *\r\n     * Counterpart to Solidity's `uint216` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 216 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint216(uint256 value) internal pure returns (uint216) {\r\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\r\n        return uint216(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint208 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint208).\r\n     *\r\n     * Counterpart to Solidity's `uint208` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 208 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint208(uint256 value) internal pure returns (uint208) {\r\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\r\n        return uint208(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint200 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint200).\r\n     *\r\n     * Counterpart to Solidity's `uint200` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 200 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint200(uint256 value) internal pure returns (uint200) {\r\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\r\n        return uint200(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint192 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint192).\r\n     *\r\n     * Counterpart to Solidity's `uint192` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 192 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint192(uint256 value) internal pure returns (uint192) {\r\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\r\n        return uint192(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint184 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint184).\r\n     *\r\n     * Counterpart to Solidity's `uint184` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 184 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint184(uint256 value) internal pure returns (uint184) {\r\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\r\n        return uint184(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint176 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint176).\r\n     *\r\n     * Counterpart to Solidity's `uint176` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 176 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint176(uint256 value) internal pure returns (uint176) {\r\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\r\n        return uint176(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint168 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint168).\r\n     *\r\n     * Counterpart to Solidity's `uint168` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 168 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint168(uint256 value) internal pure returns (uint168) {\r\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\r\n        return uint168(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint160 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint160).\r\n     *\r\n     * Counterpart to Solidity's `uint160` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 160 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint160(uint256 value) internal pure returns (uint160) {\r\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\r\n        return uint160(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint152 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint152).\r\n     *\r\n     * Counterpart to Solidity's `uint152` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 152 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint152(uint256 value) internal pure returns (uint152) {\r\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\r\n        return uint152(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint144 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint144).\r\n     *\r\n     * Counterpart to Solidity's `uint144` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 144 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint144(uint256 value) internal pure returns (uint144) {\r\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\r\n        return uint144(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint136 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint136).\r\n     *\r\n     * Counterpart to Solidity's `uint136` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 136 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint136(uint256 value) internal pure returns (uint136) {\r\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\r\n        return uint136(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint120 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint120).\r\n     *\r\n     * Counterpart to Solidity's `uint120` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 120 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint120(uint256 value) internal pure returns (uint120) {\r\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\r\n        return uint120(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint112 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint112).\r\n     *\r\n     * Counterpart to Solidity's `uint112` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 112 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint112(uint256 value) internal pure returns (uint112) {\r\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\r\n        return uint112(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint104 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint104).\r\n     *\r\n     * Counterpart to Solidity's `uint104` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 104 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint104(uint256 value) internal pure returns (uint104) {\r\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\r\n        return uint104(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint96 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint96).\r\n     *\r\n     * Counterpart to Solidity's `uint96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\r\n        return uint96(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint88 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint88).\r\n     *\r\n     * Counterpart to Solidity's `uint88` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 88 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint88(uint256 value) internal pure returns (uint88) {\r\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\r\n        return uint88(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint80 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint80).\r\n     *\r\n     * Counterpart to Solidity's `uint80` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 80 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint80(uint256 value) internal pure returns (uint80) {\r\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\r\n        return uint80(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint72 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint72).\r\n     *\r\n     * Counterpart to Solidity's `uint72` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 72 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint72(uint256 value) internal pure returns (uint72) {\r\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\r\n        return uint72(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint56 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint56).\r\n     *\r\n     * Counterpart to Solidity's `uint56` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 56 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint56(uint256 value) internal pure returns (uint56) {\r\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\r\n        return uint56(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint48 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint48).\r\n     *\r\n     * Counterpart to Solidity's `uint48` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 48 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint48(uint256 value) internal pure returns (uint48) {\r\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\r\n        return uint48(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint40 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint40).\r\n     *\r\n     * Counterpart to Solidity's `uint40` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint40(uint256 value) internal pure returns (uint40) {\r\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\r\n        return uint40(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint24 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint24).\r\n     *\r\n     * Counterpart to Solidity's `uint24` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 24 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toUint24(uint256 value) internal pure returns (uint24) {\r\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\r\n        return uint24(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits\r\n     *\r\n     * _Available since v2.5._\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     *\r\n     * _Available since v3.0._\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int248 from int256, reverting on\r\n     * overflow (when the input is less than smallest int248 or\r\n     * greater than largest int248).\r\n     *\r\n     * Counterpart to Solidity's `int248` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 248 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\r\n        downcasted = int248(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int240 from int256, reverting on\r\n     * overflow (when the input is less than smallest int240 or\r\n     * greater than largest int240).\r\n     *\r\n     * Counterpart to Solidity's `int240` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 240 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\r\n        downcasted = int240(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int232 from int256, reverting on\r\n     * overflow (when the input is less than smallest int232 or\r\n     * greater than largest int232).\r\n     *\r\n     * Counterpart to Solidity's `int232` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 232 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\r\n        downcasted = int232(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int224 from int256, reverting on\r\n     * overflow (when the input is less than smallest int224 or\r\n     * greater than largest int224).\r\n     *\r\n     * Counterpart to Solidity's `int224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\r\n        downcasted = int224(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int216 from int256, reverting on\r\n     * overflow (when the input is less than smallest int216 or\r\n     * greater than largest int216).\r\n     *\r\n     * Counterpart to Solidity's `int216` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 216 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\r\n        downcasted = int216(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int208 from int256, reverting on\r\n     * overflow (when the input is less than smallest int208 or\r\n     * greater than largest int208).\r\n     *\r\n     * Counterpart to Solidity's `int208` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 208 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\r\n        downcasted = int208(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int200 from int256, reverting on\r\n     * overflow (when the input is less than smallest int200 or\r\n     * greater than largest int200).\r\n     *\r\n     * Counterpart to Solidity's `int200` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 200 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\r\n        downcasted = int200(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int192 from int256, reverting on\r\n     * overflow (when the input is less than smallest int192 or\r\n     * greater than largest int192).\r\n     *\r\n     * Counterpart to Solidity's `int192` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 192 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\r\n        downcasted = int192(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int184 from int256, reverting on\r\n     * overflow (when the input is less than smallest int184 or\r\n     * greater than largest int184).\r\n     *\r\n     * Counterpart to Solidity's `int184` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 184 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\r\n        downcasted = int184(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int176 from int256, reverting on\r\n     * overflow (when the input is less than smallest int176 or\r\n     * greater than largest int176).\r\n     *\r\n     * Counterpart to Solidity's `int176` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 176 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\r\n        downcasted = int176(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int168 from int256, reverting on\r\n     * overflow (when the input is less than smallest int168 or\r\n     * greater than largest int168).\r\n     *\r\n     * Counterpart to Solidity's `int168` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 168 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\r\n        downcasted = int168(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int160 from int256, reverting on\r\n     * overflow (when the input is less than smallest int160 or\r\n     * greater than largest int160).\r\n     *\r\n     * Counterpart to Solidity's `int160` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 160 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\r\n        downcasted = int160(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int152 from int256, reverting on\r\n     * overflow (when the input is less than smallest int152 or\r\n     * greater than largest int152).\r\n     *\r\n     * Counterpart to Solidity's `int152` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 152 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\r\n        downcasted = int152(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int144 from int256, reverting on\r\n     * overflow (when the input is less than smallest int144 or\r\n     * greater than largest int144).\r\n     *\r\n     * Counterpart to Solidity's `int144` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 144 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\r\n        downcasted = int144(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int136 from int256, reverting on\r\n     * overflow (when the input is less than smallest int136 or\r\n     * greater than largest int136).\r\n     *\r\n     * Counterpart to Solidity's `int136` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 136 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\r\n        downcasted = int136(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\r\n        downcasted = int128(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int120 from int256, reverting on\r\n     * overflow (when the input is less than smallest int120 or\r\n     * greater than largest int120).\r\n     *\r\n     * Counterpart to Solidity's `int120` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 120 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\r\n        downcasted = int120(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int112 from int256, reverting on\r\n     * overflow (when the input is less than smallest int112 or\r\n     * greater than largest int112).\r\n     *\r\n     * Counterpart to Solidity's `int112` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 112 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\r\n        downcasted = int112(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int104 from int256, reverting on\r\n     * overflow (when the input is less than smallest int104 or\r\n     * greater than largest int104).\r\n     *\r\n     * Counterpart to Solidity's `int104` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 104 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\r\n        downcasted = int104(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int96 from int256, reverting on\r\n     * overflow (when the input is less than smallest int96 or\r\n     * greater than largest int96).\r\n     *\r\n     * Counterpart to Solidity's `int96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\r\n        downcasted = int96(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int88 from int256, reverting on\r\n     * overflow (when the input is less than smallest int88 or\r\n     * greater than largest int88).\r\n     *\r\n     * Counterpart to Solidity's `int88` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 88 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\r\n        downcasted = int88(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int80 from int256, reverting on\r\n     * overflow (when the input is less than smallest int80 or\r\n     * greater than largest int80).\r\n     *\r\n     * Counterpart to Solidity's `int80` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 80 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\r\n        downcasted = int80(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int72 from int256, reverting on\r\n     * overflow (when the input is less than smallest int72 or\r\n     * greater than largest int72).\r\n     *\r\n     * Counterpart to Solidity's `int72` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 72 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\r\n        downcasted = int72(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\r\n        downcasted = int64(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int56 from int256, reverting on\r\n     * overflow (when the input is less than smallest int56 or\r\n     * greater than largest int56).\r\n     *\r\n     * Counterpart to Solidity's `int56` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 56 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\r\n        downcasted = int56(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int48 from int256, reverting on\r\n     * overflow (when the input is less than smallest int48 or\r\n     * greater than largest int48).\r\n     *\r\n     * Counterpart to Solidity's `int48` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 48 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\r\n        downcasted = int48(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int40 from int256, reverting on\r\n     * overflow (when the input is less than smallest int40 or\r\n     * greater than largest int40).\r\n     *\r\n     * Counterpart to Solidity's `int40` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 40 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\r\n        downcasted = int40(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\r\n        downcasted = int32(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int24 from int256, reverting on\r\n     * overflow (when the input is less than smallest int24 or\r\n     * greater than largest int24).\r\n     *\r\n     * Counterpart to Solidity's `int24` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 24 bits\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\r\n        downcasted = int24(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\r\n        downcasted = int16(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\r\n        downcasted = int8(value);\r\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     *\r\n     * _Available since v3.0._\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\r\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the {Governor} core.\r\n */\r\nabstract contract IGovernor is IERC165 {\r\n    enum ContestState {\r\n        NotStarted,\r\n        Active,\r\n        Canceled,\r\n        Queued,\r\n        Completed\r\n    }\r\n\r\n    uint256 public constant METADATAS_COUNT = uint256(type(Metadatas).max) + 1;\r\n\r\n    enum Metadatas {\r\n        Target,\r\n        Safe\r\n    }\r\n\r\n    struct TargetMetadata {\r\n        address targetAddress;\r\n    }\r\n\r\n    struct SafeMetadata {\r\n        address[] signers;\r\n        uint256 threshold;\r\n    }\r\n\r\n    struct ProposalCore {\r\n        address author;\r\n        bool exists;\r\n        string description;\r\n        TargetMetadata targetMetadata;\r\n        SafeMetadata safeMetadata;\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when a jokerace is created.\r\n     */\r\n    event JokeraceCreated(string name, address creator);\r\n\r\n    /**\r\n     * @dev Emitted when a proposal is created.\r\n     */\r\n    event ProposalCreated(uint256 proposalId, address proposer);\r\n\r\n    /**\r\n     * @dev Emitted when proposals are deleted.\r\n     */\r\n    event ProposalsDeleted(uint256[] proposalIds);\r\n\r\n    /**\r\n     * @dev Emitted when a contest is canceled.\r\n     */\r\n    event ContestCanceled();\r\n\r\n    /**\r\n     * @dev Emitted when a vote is cast.\r\n     */\r\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 numVotes);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Name of the contest.\r\n     */\r\n    function name() public view virtual returns (string memory);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Prompt of the contest.\r\n     */\r\n    function prompt() public view virtual returns (string memory);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Version of the contest contract.\r\n     */\r\n    function version() public view virtual returns (string memory);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Hashing function used to build the proposal id from the proposal details.\r\n     */\r\n    function hashProposal(ProposalCore memory proposal) public pure virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Current state of a Contest, following Compound's convention\r\n     */\r\n    function state() public view virtual returns (ContestState);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Timestamp the contest starts at. Submissions open at the end of this block, so it is not possible to propose\r\n     * during this block.\r\n     */\r\n    function contestStart() public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Timestamp the contest vote begins. Votes open at the end of this block, so it is possible to propose\r\n     * during this block.\r\n     */\r\n    function voteStart() public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Timestamp at which votes close. Votes close at the end of this block, so it is possible to cast a vote\r\n     * during this block.\r\n     */\r\n    function contestDeadline() public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:user-config\r\n     * @dev Delay, in seconds, between the proposal is created and the vote starts. This can be increassed to\r\n     * leave time for users to buy voting power, of delegate it, before the voting of a proposal starts.\r\n     */\r\n    function votingDelay() public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:user-config\r\n     * @dev Delay, in seconds, between the vote start and vote ends.\r\n     *\r\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\r\n     * duration compared to the voting delay.\r\n     */\r\n    function votingPeriod() public view virtual returns (uint256);\r\n\r\n    /**\r\n     * @notice module:core\r\n     * @dev Creator of the contest, has the power to cancel the contest and delete proposals in it.\r\n     */\r\n    function creator() public view virtual returns (address);\r\n\r\n    /**\r\n     * @dev Verifies that `account` is permissioned to propose via merkle proof.\r\n     */\r\n    function verifyProposer(address account, bytes32[] calldata proof) public virtual returns (bool);\r\n\r\n    /**\r\n     * @dev Verifies that all of the metadata in the proposal is valid.\r\n     */\r\n    function validateProposalData(ProposalCore memory proposal) public virtual returns (bool);\r\n\r\n    /**\r\n     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends\r\n     * {IGovernor-votingPeriod} blocks after the voting starts.\r\n     *\r\n     * Emits a {ProposalCreated} event.\r\n     */\r\n    function propose(ProposalCore calldata proposal, bytes32[] calldata proof)\r\n        public\r\n        virtual\r\n        returns (uint256 proposalId);\r\n\r\n    /**\r\n     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends\r\n     * {IGovernor-votingPeriod} blocks after the voting starts.\r\n     *\r\n     * Emits a {ProposalCreated} event.\r\n     */\r\n    function proposeWithoutProof(ProposalCore calldata proposal) public virtual returns (uint256 proposalId);\r\n\r\n    /**\r\n     * @dev Verifies that `account` is permissioned to vote with `totalVotes` via merkle proof.\r\n     */\r\n    function verifyVoter(address account, uint256 totalVotes, bytes32[] calldata proof) public virtual returns (bool);\r\n\r\n    /**\r\n     * @dev Cast a vote with a merkle proof.\r\n     *\r\n     * Emits a {VoteCast} event.\r\n     */\r\n    function castVote(uint256 proposalId, uint8 support, uint256 totalVotes, uint256 numVotes, bytes32[] calldata proof)\r\n        public\r\n        virtual\r\n        returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Cast a vote without including the merkle proof.\r\n     *\r\n     * Emits a {VoteCast} event.\r\n     */\r\n    function castVoteWithoutProof(uint256 proposalId, uint8 support, uint256 numVotes)\r\n        public\r\n        virtual\r\n        returns (uint256 balance);\r\n}\r\n\r\n/// ============ Imports ============\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The tree and the proofs can be generated using our\r\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\r\n * You will find a quickstart guide in the readme.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\r\n * against this attack out of the box.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {verify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProofCalldata(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\r\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerify(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProof(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\r\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\r\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\r\n     * respectively.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\r\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\r\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProof(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 proofLen = proof.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProofCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 proofLen = proof.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n // OZ: MerkleProof\r\n\r\n/// @title GovernorMerkleVotes\r\nabstract contract GovernorMerkleVotes {\r\n    /// ============ Immutable storage ============\r\n\r\n    /// @notice ERC20-claimee inclusion root\r\n    bytes32 public immutable submissionMerkleRoot;\r\n    bytes32 public immutable votingMerkleRoot;\r\n\r\n    /// ============ Errors ============\r\n\r\n    /// @notice Thrown if address/amount are not part of Merkle tree\r\n    error NotInMerkle();\r\n\r\n    /// ============ Constructor ============\r\n\r\n    /// @notice Creates a new GovernorMerkleVotes contract\r\n    /// @param _submissionMerkleRoot of claimees\r\n    /// @param _votingMerkleRoot of claimees\r\n    constructor(bytes32 _submissionMerkleRoot, bytes32 _votingMerkleRoot) {\r\n        submissionMerkleRoot = _submissionMerkleRoot; // Update root\r\n        votingMerkleRoot = _votingMerkleRoot; // Update root\r\n    }\r\n\r\n    /// ============ Functions ============\r\n\r\n    /// @notice Allows checking of proofs for an address\r\n    /// @param addressToCheck address of claimee\r\n    /// @param amount to check that the claimee has\r\n    /// @param proof merkle proof to prove address and amount are in tree\r\n    /// @param voting true if this is for a voting proof, false if this is for a submission proof\r\n    function checkProof(address addressToCheck, uint256 amount, bytes32[] calldata proof, bool voting)\r\n        public\r\n        view\r\n        returns (bool verified)\r\n    {\r\n        // Verify merkle proof, or revert if not in tree\r\n        bytes32 leaf = keccak256(abi.encodePacked(addressToCheck, amount));\r\n        bool isValidLeaf = voting\r\n            ? MerkleProof.verify(proof, votingMerkleRoot, leaf)\r\n            : MerkleProof.verify(proof, submissionMerkleRoot, leaf);\r\n        if (!isValidLeaf) revert NotInMerkle();\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Core of the governance system, designed to be extended though various modules.\r\n */\r\nabstract contract Governor is Context, ERC165, EIP712, GovernorMerkleVotes, IGovernor {\r\n    using SafeCast for uint256;\r\n\r\n    uint256 public constant AMOUNT_FOR_SUMBITTER_PROOF = 10000000000000000000;\r\n    address public constant JK_LABS_ADDRESS = 0xDc652C746A8F85e18Ce632d97c6118e8a52fa738;\r\n\r\n    string private _name;\r\n    string private _prompt;\r\n\r\n    uint256[] public proposalIds;\r\n    uint256[] public deletedProposalIds;\r\n    mapping(uint256 => bool) public proposalIsDeleted;\r\n    bool public canceled;\r\n    mapping(uint256 => ProposalCore) public proposals;\r\n    mapping(address => uint256) public numSubmissions;\r\n    address[] public proposalAuthors;\r\n    address[] public addressesThatHaveVoted;\r\n\r\n    mapping(address => uint256) public addressTotalVotes;\r\n    mapping(address => bool) public addressTotalVotesVerified;\r\n    mapping(address => bool) public addressSubmitterVerified;\r\n\r\n    /// @notice Thrown if there is metadata included in a proposal that isn't covered in data validation\r\n    error TooManyMetadatas();\r\n\r\n    /**\r\n     * @dev Sets the value for {name} and {version}\r\n     */\r\n    constructor(string memory name_, string memory prompt_, bytes32 submissionMerkleRoot_, bytes32 votingMerkleRoot_)\r\n        GovernorMerkleVotes(submissionMerkleRoot_, votingMerkleRoot_)\r\n        EIP712(name_, version())\r\n    {\r\n        _name = name_;\r\n        _prompt = prompt_;\r\n\r\n        emit JokeraceCreated(name_, msg.sender); // emit upon creation to be able to easily find jokeraces on a chain\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\r\n        return interfaceId == type(IGovernor).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-prompt}.\r\n     */\r\n    function prompt() public view virtual override returns (string memory) {\r\n        return _prompt;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-version}.\r\n     */\r\n    function version() public view virtual override returns (string memory) {\r\n        return \"3.18\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-hashProposal}.\r\n     */\r\n    function hashProposal(ProposalCore memory proposal) public pure virtual override returns (uint256) {\r\n        return uint256(keccak256(abi.encode(proposal)));\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-state}.\r\n     */\r\n    function state() public view virtual override returns (ContestState) {\r\n        if (canceled) {\r\n            return ContestState.Canceled;\r\n        }\r\n\r\n        uint256 contestStartTimestamp = contestStart();\r\n\r\n        if (contestStartTimestamp >= block.timestamp) {\r\n            return ContestState.NotStarted;\r\n        }\r\n\r\n        uint256 voteStartTimestamp = voteStart();\r\n\r\n        if (voteStartTimestamp >= block.timestamp) {\r\n            return ContestState.Queued;\r\n        }\r\n\r\n        uint256 deadlineTimestamp = contestDeadline();\r\n\r\n        if (deadlineTimestamp >= block.timestamp) {\r\n            return ContestState.Active;\r\n        }\r\n\r\n        return ContestState.Completed;\r\n    }\r\n\r\n    /**\r\n     * @dev Return all proposals.\r\n     */\r\n    function getAllProposalIds() public view virtual returns (uint256[] memory) {\r\n        return proposalIds;\r\n    }\r\n\r\n    /**\r\n     * @dev Return all proposal authors.\r\n     */\r\n    function getAllProposalAuthors() public view virtual returns (address[] memory) {\r\n        return proposalAuthors;\r\n    }\r\n\r\n    /**\r\n     * @dev Return all addresses that have voted.\r\n     */\r\n    function getAllAddressesThatHaveVoted() public view virtual returns (address[] memory) {\r\n        return addressesThatHaveVoted;\r\n    }\r\n\r\n    /**\r\n     * @dev Return all deleted proposals.\r\n     */\r\n    function getAllDeletedProposalIds() public view virtual returns (uint256[] memory) {\r\n        return deletedProposalIds;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-voteStart}.\r\n     */\r\n    function voteStart() public view virtual override returns (uint256) {\r\n        return contestStart() + votingDelay();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-contestDeadline}.\r\n     */\r\n    function contestDeadline() public view virtual override returns (uint256) {\r\n        return voteStart() + votingPeriod();\r\n    }\r\n\r\n    /**\r\n     * @dev The number of proposals that an address who is qualified to propose can submit for this contest.\r\n     */\r\n    function numAllowedProposalSubmissions() public view virtual returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Max number of proposals allowed in this contest\r\n     */\r\n    function maxProposalCount() public view virtual returns (uint256) {\r\n        return 100;\r\n    }\r\n\r\n    /**\r\n     * @dev If downvoting is enabled in this contest.\r\n     */\r\n    function downvotingAllowed() public view virtual returns (uint256) {\r\n        return 0; // 0 == false, 1 == true\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve proposal data.\r\n     */\r\n    function getProposal(uint256 proposalId) public view virtual returns (ProposalCore memory) {\r\n        return proposals[proposalId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get the number of proposal submissions for a given address.\r\n     */\r\n    function getNumSubmissions(address account) public view virtual returns (uint256) {\r\n        return numSubmissions[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if a proposal has been deleted or not.\r\n     */\r\n    function isProposalDeleted(uint256 proposalId) public view virtual returns (bool) {\r\n        return proposalIsDeleted[proposalId];\r\n    }\r\n\r\n    /**\r\n     * @dev Register a vote with a given support and voting weight.\r\n     *\r\n     * Note: Support is generic and can represent various things depending on the voting system used.\r\n     */\r\n    function _countVote(uint256 proposalId, address account, uint8 support, uint256 numVotes, uint256 totalVotes)\r\n        internal\r\n        virtual;\r\n\r\n    /**\r\n     * @dev See {IGovernor-verifyProposer}.\r\n     */\r\n    function verifyProposer(address account, bytes32[] calldata proof) public override returns (bool verified) {\r\n        if (!addressSubmitterVerified[account]) {\r\n            if (submissionMerkleRoot == 0) {\r\n                // if the submission root is 0, then anyone can submit\r\n                return true;\r\n            }\r\n            checkProof(account, AMOUNT_FOR_SUMBITTER_PROOF, proof, false); // will revert with NotInMerkle if not valid\r\n            addressSubmitterVerified[account] = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-validateProposalData}.\r\n     */\r\n    function validateProposalData(ProposalCore memory proposal) public virtual override returns (bool dataValidated) {\r\n        require(proposal.author == msg.sender, \"Governor: the proposal author must be msg.sender\");\r\n        for (uint256 index = 0; index < METADATAS_COUNT; index++) {\r\n            Metadatas currentMetadata = Metadatas(index);\r\n            if (currentMetadata == Metadatas.Target) {\r\n                continue; // Nothing to check here since strictly typed to address\r\n            } else if (currentMetadata == Metadatas.Safe) {\r\n                require(\r\n                    proposal.safeMetadata.signers.length != 0,\r\n                    \"GovernorMetadataValidation: there cannot be zero signers in safeMetadata\"\r\n                );\r\n                require(\r\n                    proposal.safeMetadata.threshold != 0,\r\n                    \"GovernorMetadataValidation: threshold cannot be zero in safeMetadata\"\r\n                );\r\n            } else {\r\n                revert TooManyMetadatas();\r\n            }\r\n        }\r\n        require(bytes(proposal.description).length != 0, \"Governor: empty proposal descriptions are not allowed\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-propose}.\r\n     */\r\n    function propose(ProposalCore calldata proposal, bytes32[] calldata proof)\r\n        public\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(verifyProposer(msg.sender, proof), \"Governor: address is not permissioned to submit\");\r\n        require(validateProposalData(proposal), \"Governor: proposal content failed validation\");\r\n        return _castProposal(proposal);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-proposeWithoutProof}.\r\n     */\r\n    function proposeWithoutProof(ProposalCore calldata proposal) public virtual override returns (uint256) {\r\n        if (submissionMerkleRoot != 0) {\r\n            // if the submission root is 0, then anyone can submit; otherwise, this address needs to have been verified\r\n            require(addressSubmitterVerified[msg.sender], \"Governor: address is not permissioned to submit\");\r\n        }\r\n        require(validateProposalData(proposal), \"Governor: proposal content failed validation\");\r\n        return _castProposal(proposal);\r\n    }\r\n\r\n    function _castProposal(ProposalCore memory proposal) internal virtual returns (uint256) {\r\n        require(state() == ContestState.Queued, \"Governor: contest must be queued for proposals to be submitted\");\r\n        require(\r\n            numSubmissions[msg.sender] < numAllowedProposalSubmissions(),\r\n            \"Governor: the same address cannot submit more than the numAllowedProposalSubmissions for this contest\"\r\n        );\r\n        require(\r\n            (proposalIds.length - deletedProposalIds.length) < maxProposalCount(),\r\n            \"Governor: the max number of proposals have been submitted\"\r\n        );\r\n\r\n        uint256 proposalId = hashProposal(proposal);\r\n        require(!proposals[proposalId].exists, \"Governor: duplicate proposals not allowed\");\r\n\r\n        proposalIds.push(proposalId);\r\n        proposals[proposalId] = proposal;\r\n        numSubmissions[msg.sender] += 1;\r\n        proposalAuthors.push(msg.sender);\r\n\r\n        emit ProposalCreated(proposalId, msg.sender);\r\n\r\n        return proposalId;\r\n    }\r\n\r\n    /**\r\n     * @dev Delete proposals.\r\n     *\r\n     * Emits a {IGovernor-ProposalsDeleted} event.\r\n     */\r\n    function deleteProposals(uint256[] calldata proposalIdsToDelete) public virtual {\r\n        require(msg.sender == creator(), \"Governor: only the contest creator can delete proposals\");\r\n        require(\r\n            state() != ContestState.Completed,\r\n            \"Governor: deletion of proposals after the end of a contest is not allowed\"\r\n        );\r\n\r\n        for (uint256 index = 0; index < proposalIdsToDelete.length; index++) {\r\n            uint256 currentProposalId = proposalIdsToDelete[index];\r\n            if (!proposalIsDeleted[currentProposalId]) {\r\n                // if this proposal hasn't already been deleted\r\n                proposalIsDeleted[currentProposalId] = true;\r\n                // this proposal now won't count towards the total number allowed in the contest\r\n                // it will still count towards the total number of proposals that the user is allowed to submit though\r\n                deletedProposalIds.push(currentProposalId);\r\n            }\r\n        }\r\n\r\n        emit ProposalsDeleted(proposalIds);\r\n    }\r\n\r\n    /**\r\n     * @dev\r\n     *\r\n     * Emits a {IGovernor-ContestCanceled} event.\r\n     */\r\n    function cancel() public virtual {\r\n        require(\r\n            ((msg.sender == creator()) || (msg.sender == JK_LABS_ADDRESS)),\r\n            \"Governor: only creator or jk labs can cancel a contest\"\r\n        );\r\n\r\n        ContestState status = state();\r\n\r\n        require(status != ContestState.Canceled && status != ContestState.Completed, \"Governor: contest not active\");\r\n        canceled = true;\r\n\r\n        emit ContestCanceled();\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-verifyVoter}.\r\n     */\r\n    function verifyVoter(address account, uint256 totalVotes, bytes32[] calldata proof)\r\n        public\r\n        override\r\n        returns (bool verified)\r\n    {\r\n        if (!addressTotalVotesVerified[account]) {\r\n            checkProof(account, totalVotes, proof, true); // will revert with NotInMerkle if not valid\r\n            addressTotalVotes[account] = totalVotes;\r\n            addressTotalVotesVerified[account] = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-castVote}.\r\n     */\r\n    function castVote(uint256 proposalId, uint8 support, uint256 totalVotes, uint256 numVotes, bytes32[] calldata proof)\r\n        public\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        address voter = msg.sender;\r\n        require(!isProposalDeleted(proposalId), \"Governor: you cannot vote on a deleted proposal\");\r\n        require(verifyVoter(voter, totalVotes, proof), \"Governor: this address is not permissioned to vote\");\r\n        return _castVote(proposalId, voter, support, numVotes);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-castVoteWithoutProof}.\r\n     */\r\n    function castVoteWithoutProof(uint256 proposalId, uint8 support, uint256 numVotes)\r\n        public\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        address voter = msg.sender;\r\n        require(!isProposalDeleted(proposalId), \"Governor: you cannot vote on a deleted proposal\");\r\n        require(\r\n            addressTotalVotesVerified[voter],\r\n            \"Governor: you need to cast a vote with the proof at least once and you haven't yet\"\r\n        );\r\n        return _castVote(proposalId, voter, support, numVotes);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\r\n     * voting weight using addressTotalVotes() and call the {_countVote} internal function.\r\n     *\r\n     * Emits a {IGovernor-VoteCast} event.\r\n     */\r\n    function _castVote(uint256 proposalId, address account, uint8 support, uint256 numVotes)\r\n        internal\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        require(state() == ContestState.Active, \"Governor: vote not currently active\");\r\n        require(numVotes > 0, \"Governor: cannot vote with 0 or fewer votes\");\r\n\r\n        require(\r\n            addressTotalVotesVerified[account],\r\n            \"Governor: you need to verify your number of votes against the merkle root first\"\r\n        );\r\n        _countVote(proposalId, account, support, numVotes, addressTotalVotes[account]);\r\n\r\n        addressesThatHaveVoted.push(msg.sender);\r\n\r\n        emit VoteCast(account, proposalId, support, numVotes);\r\n\r\n        return addressTotalVotes[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\r\n     * through another contract such as a timelock.\r\n     */\r\n    function _executor() internal view virtual returns (address) {\r\n        return address(this);\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Timers.sol)\r\n\r\n/**\r\n * @dev Tooling for timepoints, timers and delays\r\n *\r\n * CAUTION: This file is deprecated as of 4.9 and will be removed in the next major release.\r\n */\r\nlibrary Timers {\r\n    struct Timestamp {\r\n        uint64 _deadline;\r\n    }\r\n\r\n    function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\r\n        return timer._deadline;\r\n    }\r\n\r\n    function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\r\n        timer._deadline = timestamp;\r\n    }\r\n\r\n    function reset(Timestamp storage timer) internal {\r\n        timer._deadline = 0;\r\n    }\r\n\r\n    function isUnset(Timestamp memory timer) internal pure returns (bool) {\r\n        return timer._deadline == 0;\r\n    }\r\n\r\n    function isStarted(Timestamp memory timer) internal pure returns (bool) {\r\n        return timer._deadline > 0;\r\n    }\r\n\r\n    function isPending(Timestamp memory timer) internal view returns (bool) {\r\n        return timer._deadline > block.timestamp;\r\n    }\r\n\r\n    function isExpired(Timestamp memory timer) internal view returns (bool) {\r\n        return isStarted(timer) && timer._deadline <= block.timestamp;\r\n    }\r\n\r\n    struct BlockNumber {\r\n        uint64 _deadline;\r\n    }\r\n\r\n    function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\r\n        return timer._deadline;\r\n    }\r\n\r\n    function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\r\n        timer._deadline = timestamp;\r\n    }\r\n\r\n    function reset(BlockNumber storage timer) internal {\r\n        timer._deadline = 0;\r\n    }\r\n\r\n    function isUnset(BlockNumber memory timer) internal pure returns (bool) {\r\n        return timer._deadline == 0;\r\n    }\r\n\r\n    function isStarted(BlockNumber memory timer) internal pure returns (bool) {\r\n        return timer._deadline > 0;\r\n    }\r\n\r\n    function isPending(BlockNumber memory timer) internal view returns (bool) {\r\n        return timer._deadline > block.number;\r\n    }\r\n\r\n    function isExpired(BlockNumber memory timer) internal view returns (bool) {\r\n        return isStarted(timer) && timer._deadline <= block.number;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Extension of {Governor} for settings updatable through governance.\r\n */\r\nabstract contract GovernorSettings is Governor {\r\n    uint256 private _contestStart;\r\n    uint256 private _votingDelay;\r\n    uint256 private _votingPeriod;\r\n    uint256 private _numAllowedProposalSubmissions;\r\n    uint256 private _maxProposalCount;\r\n    uint256 private _downvotingAllowed;\r\n    address private _creator;\r\n\r\n    event ContestStartSet(uint256 oldContestStart, uint256 newContestStart);\r\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\r\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\r\n    event NumAllowedProposalSubmissionsSet(\r\n        uint256 oldNumAllowedProposalSubmissions, uint256 newNumAllowedProposalSubmissions\r\n    );\r\n    event MaxProposalCountSet(uint256 oldMaxProposalCount, uint256 newMaxProposalCount);\r\n    event DownvotingAllowedSet(uint256 oldDownvotingAllowed, uint256 newDownvotingAllowed);\r\n    event CreatorSet(address oldCreator, address newCreator);\r\n\r\n    /**\r\n     * @dev Initialize the governance parameters.\r\n     */\r\n    constructor(\r\n        uint256 initialContestStart,\r\n        uint256 initialVotingDelay,\r\n        uint256 initialVotingPeriod,\r\n        uint256 initialNumAllowedProposalSubmissions,\r\n        uint256 initialMaxProposalCount,\r\n        uint256 initialDownvotingAllowed\r\n    ) {\r\n        _setContestStart(initialContestStart);\r\n        _setVotingDelay(initialVotingDelay);\r\n        _setVotingPeriod(initialVotingPeriod);\r\n        _setNumAllowedProposalSubmissions(initialNumAllowedProposalSubmissions);\r\n        _setMaxProposalCount(initialMaxProposalCount);\r\n        _setDownvotingAllowed(initialDownvotingAllowed);\r\n        _setCreator(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-contestStart}.\r\n     */\r\n    function contestStart() public view virtual override returns (uint256) {\r\n        return _contestStart;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-votingDelay}.\r\n     */\r\n    function votingDelay() public view virtual override returns (uint256) {\r\n        return _votingDelay;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-votingPeriod}.\r\n     */\r\n    function votingPeriod() public view virtual override returns (uint256) {\r\n        return _votingPeriod;\r\n    }\r\n\r\n    /**\r\n     * @dev See {Governor-numAllowedProposalSubmissions}.\r\n     */\r\n    function numAllowedProposalSubmissions() public view virtual override returns (uint256) {\r\n        return _numAllowedProposalSubmissions;\r\n    }\r\n\r\n    /**\r\n     * @dev Max number of proposals allowed in this contest\r\n     */\r\n    function maxProposalCount() public view virtual override returns (uint256) {\r\n        return _maxProposalCount;\r\n    }\r\n\r\n    /**\r\n     * @dev If downvoting is enabled in this contest\r\n     */\r\n    function downvotingAllowed() public view virtual override returns (uint256) {\r\n        return _downvotingAllowed;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IGovernor-creator}.\r\n     */\r\n    function creator() public view virtual override returns (address) {\r\n        return _creator;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal setter for the contestStart.\r\n     *\r\n     * Emits a {ContestStartSet} event.\r\n     */\r\n    function _setContestStart(uint256 newContestStart) internal virtual {\r\n        emit ContestStartSet(_contestStart, newContestStart);\r\n        _contestStart = newContestStart;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal setter for the voting delay.\r\n     *\r\n     * Emits a {VotingDelaySet} event.\r\n     */\r\n    function _setVotingDelay(uint256 newVotingDelay) internal virtual {\r\n        emit VotingDelaySet(_votingDelay, newVotingDelay);\r\n        _votingDelay = newVotingDelay;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal setter for the voting period.\r\n     *\r\n     * Emits a {VotingPeriodSet} event.\r\n     */\r\n    function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {\r\n        // voting period must be at least one block long\r\n        require(newVotingPeriod > 0, \"GovernorSettings: voting period too low\");\r\n        emit VotingPeriodSet(_votingPeriod, newVotingPeriod);\r\n        _votingPeriod = newVotingPeriod;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal setter for the number of allowed proposal submissions per permissioned address.\r\n     *\r\n     * Emits a {NumAllowedProposalSubmissionsSet} event.\r\n     */\r\n    function _setNumAllowedProposalSubmissions(uint256 newNumAllowedProposalSubmissions) internal virtual {\r\n        emit NumAllowedProposalSubmissionsSet(_numAllowedProposalSubmissions, newNumAllowedProposalSubmissions);\r\n        _numAllowedProposalSubmissions = newNumAllowedProposalSubmissions;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal setter for the max proposal count.\r\n     *\r\n     * Emits a {MaxProposalCountSet} event.\r\n     */\r\n    function _setMaxProposalCount(uint256 newMaxProposalCount) internal virtual {\r\n        emit MaxProposalCountSet(_maxProposalCount, newMaxProposalCount);\r\n        _maxProposalCount = newMaxProposalCount;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal setter for if downvoting is allowed.\r\n     *\r\n     * Emits a {DownvotingAllowedSet} event.\r\n     */\r\n    function _setDownvotingAllowed(uint256 newDownvotingAllowed) internal virtual {\r\n        emit DownvotingAllowedSet(_downvotingAllowed, newDownvotingAllowed);\r\n        _downvotingAllowed = newDownvotingAllowed;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal setter for creator.\r\n     *\r\n     * Emits a {CreatorSet} event.\r\n     */\r\n    function _setCreator(address newCreator) internal virtual {\r\n        emit CreatorSet(_creator, newCreator);\r\n        _creator = newCreator;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\r\n */\r\nabstract contract GovernorCountingSimple is Governor {\r\n    /**\r\n     * @dev Supported vote types. Matches Governor Bravo ordering.\r\n     */\r\n    enum VoteType {\r\n        For,\r\n        Against\r\n    }\r\n\r\n    struct VoteCounts {\r\n        uint256 forVotes;\r\n        uint256 againstVotes;\r\n    }\r\n\r\n    struct ProposalVote {\r\n        VoteCounts proposalVoteCounts;\r\n        address[] addressesVoted;\r\n        mapping(address => VoteCounts) addressVoteCounts;\r\n    }\r\n\r\n    uint256 public totalVotesCast; // Total votes cast in contest so far\r\n    mapping(address => uint256) public addressTotalCastVoteCounts;\r\n    mapping(uint256 => ProposalVote) public proposalVotesStructs;\r\n\r\n    /**\r\n     * @dev Accessor to the internal vote counts for a given proposal.\r\n     */\r\n    function proposalVotes(uint256 proposalId) public view virtual returns (uint256 forVotes, uint256 againstVotes) {\r\n        ProposalVote storage proposalvote = proposalVotesStructs[proposalId];\r\n        return (proposalvote.proposalVoteCounts.forVotes, proposalvote.proposalVoteCounts.againstVotes);\r\n    }\r\n\r\n    /**\r\n     * @dev Accessor to how many votes an address has cast for a given proposal.\r\n     */\r\n    function proposalAddressVotes(uint256 proposalId, address userAddress)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 forVotes, uint256 againstVotes)\r\n    {\r\n        ProposalVote storage proposalvote = proposalVotesStructs[proposalId];\r\n        return (\r\n            proposalvote.addressVoteCounts[userAddress].forVotes,\r\n            proposalvote.addressVoteCounts[userAddress].againstVotes\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Accessor to which addresses have cast a vote for a given proposal.\r\n     */\r\n    function proposalAddressesHaveVoted(uint256 proposalId) public view virtual returns (address[] memory) {\r\n        ProposalVote storage proposalvote = proposalVotesStructs[proposalId];\r\n        return proposalvote.addressesVoted;\r\n    }\r\n\r\n    /**\r\n     * @dev Accessor to how many votes an address has cast total for the contest so far.\r\n     */\r\n    function contestAddressTotalVotesCast(address userAddress)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 userTotalVotesCast)\r\n    {\r\n        return addressTotalCastVoteCounts[userAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\r\n     */\r\n    function _countVote(uint256 proposalId, address account, uint8 support, uint256 numVotes, uint256 totalVotes)\r\n        internal\r\n        virtual\r\n        override\r\n    {\r\n        ProposalVote storage proposalvote = proposalVotesStructs[proposalId];\r\n\r\n        require(\r\n            numVotes <= (totalVotes - addressTotalCastVoteCounts[account]),\r\n            \"GovernorVotingSimple: not enough votes left to cast\"\r\n        );\r\n\r\n        bool firstTimeVoting = (\r\n            proposalvote.addressVoteCounts[account].forVotes == 0\r\n                && proposalvote.addressVoteCounts[account].againstVotes == 0\r\n        );\r\n\r\n        if (support == uint8(VoteType.For)) {\r\n            proposalvote.proposalVoteCounts.forVotes += numVotes;\r\n            proposalvote.addressVoteCounts[account].forVotes += numVotes;\r\n        } else if (support == uint8(VoteType.Against)) {\r\n            require(downvotingAllowed() == 1, \"GovernorVotingSimple: downvoting is not enabled for this Contest\");\r\n            proposalvote.proposalVoteCounts.againstVotes += numVotes;\r\n            proposalvote.addressVoteCounts[account].againstVotes += numVotes;\r\n        } else {\r\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\r\n        }\r\n\r\n        if (firstTimeVoting) {\r\n            proposalvote.addressesVoted.push(account);\r\n        }\r\n        addressTotalCastVoteCounts[account] += numVotes;\r\n        totalVotesCast += numVotes;\r\n    }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\r\n     * 0 before setting it to a non-zero value.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Extension of {GovernorCountingSimple} for sorting and ranking.\r\n *\r\n * _Available since v4.3._\r\n */\r\nabstract contract GovernorSorting is GovernorCountingSimple {\r\n    bool public setSortedAndTiedProposalsHasBeenRun = false;\r\n    mapping(uint256 => uint256) public tiedAdjustedRankingPosition; // key is ranking, value is index of the last iteration of that ranking's value in the _sortedProposalIds array taking ties into account\r\n\r\n    mapping(uint256 => bool) private _isTied; // whether a ranking is tied. key is ranking.\r\n    uint256[] private _sortedProposalIds;\r\n    uint256 private _lowestRanking; // worst ranking (1 is the best possible ranking, 8 is a lower/worse ranking than 1)\r\n    uint256 private _highestTiedRanking; // best (1 is better than 8) ranking that is tied\r\n\r\n    /**\r\n     * @dev Getter if a given ranking is tied.\r\n     */\r\n    function isTied(uint256 ranking) public view returns (bool) {\r\n        require(\r\n            setSortedAndTiedProposalsHasBeenRun, \"RewardsModule: run setSortedAndTiedProposals() to populate this value\"\r\n        );\r\n        return _isTied[ranking];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for tiedAdjustedRankingPosition of a ranking.\r\n     */\r\n    function rankingPosition(uint256 ranking) public view returns (uint256) {\r\n        require(\r\n            setSortedAndTiedProposalsHasBeenRun, \"RewardsModule: run setSortedAndTiedProposals() to populate this value\"\r\n        );\r\n        return tiedAdjustedRankingPosition[ranking];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for _sortedProposalIds.\r\n     */\r\n    function sortedProposalIds() public view returns (uint256[] memory) {\r\n        require(\r\n            setSortedAndTiedProposalsHasBeenRun, \"RewardsModule: run setSortedAndTiedProposals() to populate this value\"\r\n        );\r\n        return _sortedProposalIds;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the lowest ranking.\r\n     */\r\n    function lowestRanking() public view returns (uint256) {\r\n        require(\r\n            setSortedAndTiedProposalsHasBeenRun, \"RewardsModule: run setSortedAndTiedProposals() to populate this value\"\r\n        );\r\n        return _lowestRanking;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for highest tied ranking.\r\n     */\r\n    function highestTiedRanking() public view returns (uint256) {\r\n        require(\r\n            setSortedAndTiedProposalsHasBeenRun, \"RewardsModule: run setSortedAndTiedProposals() to populate this value\"\r\n        );\r\n        return _highestTiedRanking;\r\n    }\r\n\r\n    /**\r\n     * @dev Accessor to the internal vote counts for a given proposal.\r\n     */\r\n    function allProposalTotalVotes()\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256[] memory proposalIdsReturn, VoteCounts[] memory proposalVoteCountsArrayReturn)\r\n    {\r\n        uint256[] memory proposalIdsMemVar = proposalIds;\r\n        VoteCounts[] memory proposalVoteCountsArray = new VoteCounts[](proposalIdsMemVar.length);\r\n        for (uint256 i = 0; i < proposalIdsMemVar.length; i++) {\r\n            proposalVoteCountsArray[i] = proposalVotesStructs[proposalIdsMemVar[i]].proposalVoteCounts;\r\n        }\r\n        return (proposalIdsMemVar, proposalVoteCountsArray);\r\n    }\r\n\r\n    /**\r\n     * @dev Accessor to the internal vote counts for a given proposal that excludes deleted proposals.\r\n     */\r\n    function allProposalTotalVotesWithoutDeleted()\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256[] memory proposalIdsReturn, VoteCounts[] memory proposalVoteCountsArrayReturn)\r\n    {\r\n        uint256[] memory proposalIdsMemVar = proposalIds;\r\n        uint256[] memory proposalIdsWithoutDeleted = new uint256[](proposalIdsMemVar.length);\r\n        VoteCounts[] memory proposalVoteCountsArray = new VoteCounts[](proposalIdsMemVar.length);\r\n\r\n        uint256 newArraysIndexCounter = 0;\r\n        for (uint256 i = 0; i < proposalIdsMemVar.length; i++) {\r\n            if (!isProposalDeleted(proposalIdsMemVar[i])) {\r\n                proposalIdsWithoutDeleted[newArraysIndexCounter] = proposalIdsMemVar[i];\r\n                proposalVoteCountsArray[newArraysIndexCounter] =\r\n                    proposalVotesStructs[proposalIdsMemVar[i]].proposalVoteCounts;\r\n                newArraysIndexCounter += 1;\r\n            }\r\n        }\r\n        return (proposalIdsWithoutDeleted, proposalVoteCountsArray);\r\n    }\r\n\r\n    function _sortItem(uint256 pos, int256[] memory netProposalVotes, uint256[] memory proposalIds)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 wMin = pos;\r\n        for (uint256 i = pos; i < netProposalVotes.length; i++) {\r\n            if (netProposalVotes[i] < netProposalVotes[wMin]) {\r\n                wMin = i;\r\n            }\r\n        }\r\n        if (wMin == pos) return false;\r\n        int256 votesTmp = netProposalVotes[pos];\r\n        netProposalVotes[pos] = netProposalVotes[wMin];\r\n        netProposalVotes[wMin] = votesTmp;\r\n        uint256 proposalIdsTmp = proposalIds[pos];\r\n        proposalIds[pos] = proposalIds[wMin];\r\n        proposalIds[wMin] = proposalIdsTmp;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Accessor to sorted list of proposalIds in ascending order.\r\n     */\r\n    function sortedProposals(bool excludeDeletedProposals)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256[] memory sortedProposalIdsReturn)\r\n    {\r\n        (uint256[] memory proposalIdList, VoteCounts[] memory proposalVoteCountsArray) =\r\n            excludeDeletedProposals ? allProposalTotalVotesWithoutDeleted() : allProposalTotalVotes();\r\n        require(proposalIdList.length > 0, \"GovernorSorting: cannot sort a list of zero length\");\r\n        int256[] memory netProposalVotes = new int256[](proposalIdList.length);\r\n        for (uint256 i = 0; i < proposalVoteCountsArray.length; i++) {\r\n            netProposalVotes[i] = SafeCast.toInt256(proposalVoteCountsArray[i].forVotes)\r\n                - SafeCast.toInt256(proposalVoteCountsArray[i].againstVotes);\r\n        }\r\n        for (uint256 i = 0; i < proposalIdList.length - 1; i++) {\r\n            // Only goes to length minus 1 because sorting the last item would be redundant\r\n            _sortItem(i, netProposalVotes, proposalIdList);\r\n        }\r\n        return proposalIdList;\r\n    }\r\n\r\n    /**\r\n     * @dev Setter for _sortedProposalIds, tiedAdjustedRankingPosition, _isTied, _lowestRanking,\r\n     * and _highestTiedRanking. Will only be called once and only needs to be called once because once the contest\r\n     * is complete these values don't change. Determines if a ranking is tied and also where the last\r\n     * iteration of a ranking is in the _sortedProposalIds list taking ties into account.\r\n     */\r\n    function setSortedAndTiedProposals() public virtual {\r\n        require(\r\n            state() == IGovernor.ContestState.Completed,\r\n            \"GovernorSorting: contest must be to calculate sorted and tied proposals\"\r\n        );\r\n        require(\r\n            !setSortedAndTiedProposalsHasBeenRun,\r\n            \"GovernorSorting: setSortedAndTiedProposals() has already been run and its respective values set\"\r\n        );\r\n\r\n        _sortedProposalIds = sortedProposals(true);\r\n\r\n        int256 lastTotalVotes;\r\n        uint256 rankingBeingChecked = 1;\r\n        _highestTiedRanking = _sortedProposalIds.length + 1; // set as default so that it isn't 0 if no ties are found\r\n        uint256 sortedProposalIdsLength = _sortedProposalIds.length;\r\n        for (uint256 i = 0; i < sortedProposalIdsLength; i++) {\r\n            uint256 lastSortedItemIndex = _sortedProposalIds.length - 1;\r\n\r\n            // decrement through the ascending sorted list\r\n            (uint256 currentForVotes, uint256 currentAgainstVotes) =\r\n                proposalVotes(_sortedProposalIds[lastSortedItemIndex - i]);\r\n            int256 currentTotalVotes = SafeCast.toInt256(currentForVotes) - SafeCast.toInt256(currentAgainstVotes);\r\n\r\n            // if on first item, set lastTotalVotes and continue\r\n            if (i == 0) {\r\n                lastTotalVotes = currentTotalVotes;\r\n\r\n                // if on last item, then the value at the current index is\r\n                // the last iteration of the last ranking's value\r\n                if (_sortedProposalIds.length == 1) {\r\n                    tiedAdjustedRankingPosition[rankingBeingChecked] = lastSortedItemIndex;\r\n                    _lowestRanking = rankingBeingChecked;\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            // if there is a tie, mark that this ranking is tied\r\n            if (currentTotalVotes == lastTotalVotes) {\r\n                if (!_isTied[rankingBeingChecked]) {\r\n                    // if this is not already set\r\n                    _isTied[rankingBeingChecked] = true;\r\n                }\r\n                if (_highestTiedRanking == _sortedProposalIds.length + 1) {\r\n                    // if this is the first tie found, set it as the highest tied ranking\r\n                    _highestTiedRanking = rankingBeingChecked;\r\n                }\r\n            } else {\r\n                // otherwise, mark that the last iteration of this ranking's value is at the index\r\n                // above the current index in the sorted list, then increment the ranking being checked\r\n\r\n                // index we last decremented from is the last iteration of the current rank's value\r\n                tiedAdjustedRankingPosition[rankingBeingChecked] = lastSortedItemIndex - i + 1;\r\n                rankingBeingChecked++;\r\n            }\r\n\r\n            // if on last item, then the value at the current index is the last iteration of the last ranking's value\r\n            if (i + 1 == _sortedProposalIds.length) {\r\n                tiedAdjustedRankingPosition[rankingBeingChecked] = lastSortedItemIndex - i;\r\n                _lowestRanking = rankingBeingChecked;\r\n            }\r\n\r\n            lastTotalVotes = currentTotalVotes;\r\n        }\r\n\r\n        setSortedAndTiedProposalsHasBeenRun = true;\r\n    }\r\n}\r\n\r\n/**\r\n * @title RewardsModule\r\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\r\n * that the Ether will be split in this way, since it is handled transparently by the contract.\r\n *\r\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\r\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\r\n * an amount proportional to the percentage of total shares they were assigned. The distribution of shares is set at the\r\n * time of contract deployment and can't be updated thereafter.\r\n *\r\n * `RewardsModule` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\r\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\r\n * function.\r\n *\r\n * NOTE: This contract assumes that ERC20 tokens will behave similarly to native tokens (Ether). Rebasing tokens, and\r\n * tokens that apply fees during transfers, are likely to not be supported as expected. If in doubt, we encourage you\r\n * to run tests before sending real value to this contract.\r\n */\r\ncontract RewardsModule is Context {\r\n    event PayeeAdded(uint256 ranking, uint256 shares);\r\n    event PaymentReleased(address to, uint256 amount);\r\n    event ERC20PaymentReleased(IERC20 indexed token, address to, uint256 amount);\r\n    event PaymentReceived(address from, uint256 amount);\r\n    event RewardWithdrawn(address by, uint256 amount);\r\n    event ERC20RewardWithdrawn(IERC20 indexed token, address by, uint256 amount);\r\n\r\n    uint256 private _totalShares;\r\n    uint256 private _totalReleased;\r\n\r\n    mapping(uint256 => uint256) private _shares;\r\n    mapping(uint256 => uint256) private _released;\r\n    uint256[] private _payees;\r\n\r\n    mapping(IERC20 => uint256) private _erc20TotalReleased;\r\n    mapping(IERC20 => mapping(uint256 => uint256)) private _erc20Released;\r\n\r\n    GovernorSorting private immutable _underlyingContest;\r\n    address private immutable _creator;\r\n    bool private immutable _paysOutTarget; // if true, pay out target address; if false, pay out proposal author\r\n\r\n    /**\r\n     * @dev Creates an instance of `RewardsModule` where each ranking in `payees` is assigned the number of shares at\r\n     * the matching position in the `shares` array.\r\n     *\r\n     * All rankings in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\r\n     * duplicates in `payees`.\r\n     */\r\n    constructor(\r\n        uint256[] memory payees,\r\n        uint256[] memory shares_,\r\n        GovernorSorting underlyingContest_,\r\n        bool paysOutTarget_\r\n    ) payable {\r\n        require(payees.length == shares_.length, \"RewardsModule: payees and shares length mismatch\");\r\n        require(payees.length > 0, \"RewardsModule: no payees\");\r\n\r\n        for (uint256 i = 0; i < payees.length; i++) {\r\n            _addPayee(payees[i], shares_[i]);\r\n        }\r\n\r\n        require(_totalShares != 0, \"RewardsModule: the total number of shares cannot equal 0\");\r\n\r\n        _paysOutTarget = paysOutTarget_;\r\n        _underlyingContest = underlyingContest_;\r\n        _creator = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\r\n     * reliable: it's possible for a contract to receive Ether without triggering this function. This only affects the\r\n     * reliability of the events, and not the actual splitting of Ether.\r\n     */\r\n    receive() external payable virtual {\r\n        emit PaymentReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Version of the rewards module. Default: \"1\"\r\n     */\r\n    function version() public view virtual returns (string memory) {\r\n        return \"3.18\";\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the total shares held by payees.\r\n     */\r\n    function totalShares() public view returns (uint256) {\r\n        return _totalShares;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the creator of this rewards contract.\r\n     */\r\n    function creator() public view returns (address) {\r\n        return _creator;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the total amount of Ether already released.\r\n     */\r\n    function totalReleased() public view returns (uint256) {\r\n        return _totalReleased;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the total amount of `token` already released. `token` should be the address of an IERC20\r\n     * contract.\r\n     */\r\n    function totalReleased(IERC20 token) public view returns (uint256) {\r\n        return _erc20TotalReleased[token];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of shares held by a ranking.\r\n     */\r\n    function shares(uint256 ranking) public view returns (uint256) {\r\n        return _shares[ranking];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of Ether already released to a payee.\r\n     */\r\n    function released(uint256 ranking) public view returns (uint256) {\r\n        return _released[ranking];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of `token` tokens already released to a payee. `token` should be the address of an\r\n     * IERC20 contract.\r\n     */\r\n    function released(IERC20 token, uint256 ranking) public view returns (uint256) {\r\n        return _erc20Released[token][ranking];\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for list of rankings that will be paid out.\r\n     */\r\n    function getPayees() public view returns (uint256[] memory) {\r\n        return _payees;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for whether this pays out the target address or author of a proposal.\r\n     */\r\n    function paysOutTarget() public view returns (bool) {\r\n        return _paysOutTarget;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the underlying contest.\r\n     */\r\n    function underlyingContest() public view returns (GovernorCountingSimple) {\r\n        return _underlyingContest;\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of payee's releasable Ether.\r\n     */\r\n    function releasable(uint256 ranking) public view returns (uint256) {\r\n        uint256 totalReceived = address(this).balance + totalReleased();\r\n        return _pendingPayment(ranking, totalReceived, released(ranking));\r\n    }\r\n\r\n    /**\r\n     * @dev Getter for the amount of payee's releasable `token` tokens. `token` should be the address of an\r\n     * IERC20 contract.\r\n     */\r\n    function releasable(IERC20 token, uint256 ranking) public view returns (uint256) {\r\n        uint256 totalReceived = token.balanceOf(address(this)) + totalReleased(token);\r\n        return _pendingPayment(ranking, totalReceived, released(token, ranking));\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers a transfer to `ranking` of the amount of Ether they are owed, according to their percentage of the\r\n     * total shares and their previous withdrawals.\r\n     */\r\n    function release(uint256 ranking) public virtual {\r\n        require(ranking != 0, \"RewardsModule: ranking must be 1 or greater\");\r\n        require(\r\n            _underlyingContest.state() == IGovernor.ContestState.Completed,\r\n            \"RewardsModule: contest must be completed for rewards to be paid out\"\r\n        );\r\n        require(_shares[ranking] > 0, \"RewardsModule: ranking has no shares\");\r\n\r\n        uint256 payment = releasable(ranking);\r\n\r\n        require(\r\n            payment != 0,\r\n            \"RewardsModule: account isn't due payment as there isn't any native currency in the module to pay out\"\r\n        );\r\n\r\n        // _totalReleased is the sum of all values in _released.\r\n        // If \"_totalReleased += payment\" does not overflow, then \"_released[account] += payment\" cannot overflow.\r\n        _totalReleased += payment;\r\n        unchecked {\r\n            _released[ranking] += payment;\r\n        }\r\n\r\n        // if not already set, set _sortedProposalIds, _tiedAdjustedRankingPosition, _isTied,\r\n        // _lowestRanking, and _highestTiedRanking\r\n        if (!_underlyingContest.setSortedAndTiedProposalsHasBeenRun()) {\r\n            _underlyingContest.setSortedAndTiedProposals();\r\n        }\r\n\r\n        require(\r\n            ranking <= _underlyingContest.lowestRanking(),\r\n            \"RewardsModule: there are not enough proposals for that ranking to exist, taking ties into account\"\r\n        );\r\n\r\n        IGovernor.ProposalCore memory rankingProposal = _underlyingContest.getProposal(\r\n            _underlyingContest.sortedProposalIds()[_underlyingContest.tiedAdjustedRankingPosition(ranking)]\r\n        );\r\n\r\n        // send rewards to winner only if the ranking is higher than the highest tied ranking\r\n        address payable addressToPayOut = ranking < _underlyingContest.highestTiedRanking()\r\n            ? _paysOutTarget ? payable(rankingProposal.targetMetadata.targetAddress) : payable(rankingProposal.author)\r\n            : payable(creator());\r\n\r\n        require(addressToPayOut != address(0), \"RewardsModule: account is the zero address\");\r\n\r\n        emit PaymentReleased(addressToPayOut, payment);\r\n        Address.sendValue(addressToPayOut, payment);\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers a transfer to `ranking` of the amount of `token` tokens they are owed, according to their\r\n     * percentage of the total shares and their previous withdrawals. `token` must be the address of an IERC20\r\n     * contract.\r\n     */\r\n    function release(IERC20 token, uint256 ranking) public virtual {\r\n        require(ranking != 0, \"RewardsModule: ranking must be 1 or greater\");\r\n        require(\r\n            _underlyingContest.state() == IGovernor.ContestState.Completed,\r\n            \"RewardsModule: contest must be completed for rewards to be paid out\"\r\n        );\r\n        require(_shares[ranking] > 0, \"RewardsModule: ranking has no shares\");\r\n\r\n        uint256 payment = releasable(token, ranking);\r\n\r\n        require(\r\n            payment != 0,\r\n            \"RewardsModule: account isn't due payment as there isn't any native currency in the module to pay out\"\r\n        );\r\n\r\n        // _erc20TotalReleased[token] is the sum of all values in _erc20Released[token].\r\n        // If \"_erc20TotalReleased[token] += payment\" does not overflow, then \"_erc20Released[token][account] += payment\" cannot overflow.\r\n        _erc20TotalReleased[token] += payment;\r\n        unchecked {\r\n            _erc20Released[token][ranking] += payment;\r\n        }\r\n\r\n        // if not already set, set _sortedProposalIds, _tiedAdjustedRankingPosition, _isTied,\r\n        // _lowestRanking, and _highestTiedRanking\r\n        if (!_underlyingContest.setSortedAndTiedProposalsHasBeenRun()) {\r\n            _underlyingContest.setSortedAndTiedProposals();\r\n        }\r\n\r\n        require(\r\n            ranking <= _underlyingContest.lowestRanking(),\r\n            \"RewardsModule: there are not enough proposals for that ranking to exist, taking ties into account\"\r\n        );\r\n\r\n        IGovernor.ProposalCore memory rankingProposal = _underlyingContest.getProposal(\r\n            _underlyingContest.sortedProposalIds()[_underlyingContest.tiedAdjustedRankingPosition(ranking)]\r\n        );\r\n\r\n        // send rewards to winner only if the ranking is higher than the highest tied ranking\r\n        address payable addressToPayOut = ranking < _underlyingContest.highestTiedRanking()\r\n            ? _paysOutTarget ? payable(rankingProposal.targetMetadata.targetAddress) : payable(rankingProposal.author)\r\n            : payable(creator());\r\n\r\n        require(addressToPayOut != address(0), \"RewardsModule: account is the zero address\");\r\n\r\n        emit ERC20PaymentReleased(token, addressToPayOut, payment);\r\n        SafeERC20.safeTransfer(token, addressToPayOut, payment);\r\n    }\r\n\r\n    function withdrawRewards() public virtual {\r\n        require(msg.sender == creator(), \"RewardsModule: only the creator can withdraw rewards\");\r\n\r\n        emit RewardWithdrawn(creator(), address(this).balance);\r\n        Address.sendValue(payable(creator()), address(this).balance);\r\n    }\r\n\r\n    function withdrawRewards(IERC20 token) public virtual {\r\n        require(msg.sender == creator(), \"RewardsModule: only the creator can withdraw rewards\");\r\n\r\n        emit ERC20RewardWithdrawn(token, creator(), token.balanceOf(address(this)));\r\n        SafeERC20.safeTransfer(token, payable(creator()), token.balanceOf(address(this)));\r\n    }\r\n\r\n    /**\r\n     * @dev internal logic for computing the pending payment of a `ranking` given the token historical balances and\r\n     * already released amounts.\r\n     */\r\n    function _pendingPayment(uint256 ranking, uint256 totalReceived, uint256 alreadyReleased)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return (totalReceived * _shares[ranking]) / _totalShares - alreadyReleased;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new payee to the contract.\r\n     * @param ranking The ranking of the payee to add.\r\n     * @param shares_ The number of shares owned by the payee.\r\n     */\r\n    function _addPayee(uint256 ranking, uint256 shares_) private {\r\n        require(ranking > 0, \"RewardsModule: ranking is 0, must be greater\");\r\n        require(shares_ > 0, \"RewardsModule: shares are 0\");\r\n        require(_shares[ranking] == 0, \"RewardsModule: account already has shares\");\r\n\r\n        _payees.push(ranking);\r\n        _shares[ranking] = shares_;\r\n        _totalShares = _totalShares + shares_;\r\n        emit PayeeAdded(ranking, shares_);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Extension of {Governor} for module management.\r\n *\r\n */\r\nabstract contract GovernorModuleRegistry is Governor {\r\n    event OfficialRewardsModuleSet(RewardsModule oldOfficialRewardsModule, RewardsModule newOfficialRewardsModule);\r\n\r\n    RewardsModule public officialRewardsModule;\r\n\r\n    /**\r\n     * @dev Get the official rewards module contract for this contest (effectively reverse record).\r\n     */\r\n    function setOfficialRewardsModule(RewardsModule officialRewardsModule_) public virtual {\r\n        require(msg.sender == creator(), \"GovernorModuleRegistry: only the creator can set the official rewards module\");\r\n        RewardsModule oldOfficialRewardsModule = officialRewardsModule;\r\n        officialRewardsModule = officialRewardsModule_;\r\n        emit OfficialRewardsModuleSet(oldOfficialRewardsModule, officialRewardsModule_);\r\n    }\r\n}\r\n\r\ncontract Contest is Governor, GovernorSettings, GovernorSorting, GovernorModuleRegistry {\r\n    constructor(\r\n        string memory _name,\r\n        string memory _prompt,\r\n        bytes32 _submissionMerkleRoot,\r\n        bytes32 _votingMerkleRoot,\r\n        uint256[] memory _constructorIntParams\r\n    )\r\n        Governor(_name, _prompt, _submissionMerkleRoot, _votingMerkleRoot)\r\n        GovernorSettings(\r\n            _constructorIntParams[0], // _initialContestStart\r\n            _constructorIntParams[1], // _initialVotingDelay,\r\n            _constructorIntParams[2], // _initialVotingPeriod,\r\n            _constructorIntParams[3], // _initialNumAllowedProposalSubmissions,\r\n            _constructorIntParams[4], // _initialMaxProposalCount\r\n            _constructorIntParams[5] // _initialDownvotingAllowed\r\n        )\r\n    {}\r\n\r\n    // The following functions are overrides required by Solidity.\r\n\r\n    function contestStart() public view override(IGovernor, GovernorSettings) returns (uint256) {\r\n        return super.contestStart();\r\n    }\r\n\r\n    function votingDelay() public view override(IGovernor, GovernorSettings) returns (uint256) {\r\n        return super.votingDelay();\r\n    }\r\n\r\n    function votingPeriod() public view override(IGovernor, GovernorSettings) returns (uint256) {\r\n        return super.votingPeriod();\r\n    }\r\n\r\n    function numAllowedProposalSubmissions() public view override(Governor, GovernorSettings) returns (uint256) {\r\n        return super.numAllowedProposalSubmissions();\r\n    }\r\n\r\n    function maxProposalCount() public view override(Governor, GovernorSettings) returns (uint256) {\r\n        return super.maxProposalCount();\r\n    }\r\n\r\n    function downvotingAllowed() public view override(Governor, GovernorSettings) returns (uint256) {\r\n        return super.downvotingAllowed();\r\n    }\r\n\r\n    function creator() public view override(IGovernor, GovernorSettings) returns (address) {\r\n        return super.creator();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_prompt\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"_submissionMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_votingMerkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"_constructorIntParams\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidShortString\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInMerkle\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"StringTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyMetadatas\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ContestCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldContestStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newContestStart\",\"type\":\"uint256\"}],\"name\":\"ContestStartSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldCreator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCreator\",\"type\":\"address\"}],\"name\":\"CreatorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDownvotingAllowed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDownvotingAllowed\",\"type\":\"uint256\"}],\"name\":\"DownvotingAllowedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EIP712DomainChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"}],\"name\":\"JokeraceCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxProposalCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxProposalCount\",\"type\":\"uint256\"}],\"name\":\"MaxProposalCountSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldNumAllowedProposalSubmissions\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newNumAllowedProposalSubmissions\",\"type\":\"uint256\"}],\"name\":\"NumAllowedProposalSubmissionsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract RewardsModule\",\"name\":\"oldOfficialRewardsModule\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract RewardsModule\",\"name\":\"newOfficialRewardsModule\",\"type\":\"address\"}],\"name\":\"OfficialRewardsModuleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"proposalIds\",\"type\":\"uint256[]\"}],\"name\":\"ProposalsDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numVotes\",\"type\":\"uint256\"}],\"name\":\"VoteCast\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVotingDelay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotingDelay\",\"type\":\"uint256\"}],\"name\":\"VotingDelaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVotingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotingPeriod\",\"type\":\"uint256\"}],\"name\":\"VotingPeriodSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AMOUNT_FOR_SUMBITTER_PROOF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"JK_LABS_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"METADATAS_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressSubmitterVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressTotalCastVoteCounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressTotalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressTotalVotesVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressesThatHaveVoted\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allProposalTotalVotes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"proposalIdsReturn\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"}],\"internalType\":\"struct GovernorCountingSimple.VoteCounts[]\",\"name\":\"proposalVoteCountsArrayReturn\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allProposalTotalVotesWithoutDeleted\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"proposalIdsReturn\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"}],\"internalType\":\"struct GovernorCountingSimple.VoteCounts[]\",\"name\":\"proposalVoteCountsArrayReturn\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canceled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numVotes\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"castVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"support\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numVotes\",\"type\":\"uint256\"}],\"name\":\"castVoteWithoutProof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToCheck\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"voting\",\"type\":\"bool\"}],\"name\":\"checkProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"verified\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"contestAddressTotalVotesCast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userTotalVotesCast\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contestDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contestStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"proposalIdsToDelete\",\"type\":\"uint256[]\"}],\"name\":\"deleteProposals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deletedProposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"downvotingAllowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"fields\",\"type\":\"bytes1\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"extensions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllAddressesThatHaveVoted\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllDeletedProposalIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllProposalAuthors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllProposalIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getNumSubmissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"internalType\":\"struct IGovernor.TargetMetadata\",\"name\":\"targetMetadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernor.SafeMetadata\",\"name\":\"safeMetadata\",\"type\":\"tuple\"}],\"internalType\":\"struct IGovernor.ProposalCore\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"internalType\":\"struct IGovernor.TargetMetadata\",\"name\":\"targetMetadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernor.SafeMetadata\",\"name\":\"safeMetadata\",\"type\":\"tuple\"}],\"internalType\":\"struct IGovernor.ProposalCore\",\"name\":\"proposal\",\"type\":\"tuple\"}],\"name\":\"hashProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"highestTiedRanking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"isProposalDeleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ranking\",\"type\":\"uint256\"}],\"name\":\"isTied\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowestRanking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxProposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numAllowedProposalSubmissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numSubmissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"officialRewardsModule\",\"outputs\":[{\"internalType\":\"contract RewardsModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prompt\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"proposalAddressVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"proposalAddressesHaveVoted\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalAuthors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalIsDeleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"proposalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalVotesStructs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"forVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"againstVotes\",\"type\":\"uint256\"}],\"internalType\":\"struct GovernorCountingSimple.VoteCounts\",\"name\":\"proposalVoteCounts\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"internalType\":\"struct IGovernor.TargetMetadata\",\"name\":\"targetMetadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernor.SafeMetadata\",\"name\":\"safeMetadata\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"internalType\":\"struct IGovernor.TargetMetadata\",\"name\":\"targetMetadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernor.SafeMetadata\",\"name\":\"safeMetadata\",\"type\":\"tuple\"}],\"internalType\":\"struct IGovernor.ProposalCore\",\"name\":\"proposal\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"propose\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"internalType\":\"struct IGovernor.TargetMetadata\",\"name\":\"targetMetadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernor.SafeMetadata\",\"name\":\"safeMetadata\",\"type\":\"tuple\"}],\"internalType\":\"struct IGovernor.ProposalCore\",\"name\":\"proposal\",\"type\":\"tuple\"}],\"name\":\"proposeWithoutProof\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ranking\",\"type\":\"uint256\"}],\"name\":\"rankingPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract RewardsModule\",\"name\":\"officialRewardsModule_\",\"type\":\"address\"}],\"name\":\"setOfficialRewardsModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSortedAndTiedProposals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSortedAndTiedProposalsHasBeenRun\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedProposalIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"excludeDeletedProposals\",\"type\":\"bool\"}],\"name\":\"sortedProposals\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"sortedProposalIdsReturn\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum IGovernor.ContestState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submissionMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tiedAdjustedRankingPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVotesCast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"}],\"internalType\":\"struct IGovernor.TargetMetadata\",\"name\":\"targetMetadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"internalType\":\"struct IGovernor.SafeMetadata\",\"name\":\"safeMetadata\",\"type\":\"tuple\"}],\"internalType\":\"struct IGovernor.ProposalCore\",\"name\":\"proposal\",\"type\":\"tuple\"}],\"name\":\"validateProposalData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"dataValidated\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyProposer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"verified\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalVotes\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyVoter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"verified\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Contest", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e09cd1e4f593d70f62b8b6871524ca8aec7133d59699621d6343c0e83112e6ccf87343c392feb8481d15cdb0897787a645f9dc411e17f6822303d298f04cc21fcd0000000000000000000000000000000000000000000000000000000000001a60000000000000000000000000000000000000000000000000000000000000001e456967656e4c61796572204c535420436f6e74657374204d61696e6e657400000000000000000000000000000000000000000000000000000000000000001955636f6e7465737420636f6d7065746974696f6e7c456967656e4c61796572204c535420456c656374696f6e7c3c703e3c7374726f6e673e53756d6d6172793c2f7374726f6e673e3c2f703e3c703e5468697320636f6e746573742073657276657320617320612062696e64696e67206f6e636861696e20766f746520746f20656c65637420746865206e657874204c53547320746f20626520616464656420746f2074686520456967656e4c617965722072657374616b696e6720706f6f6c2e266e6273703b3c2f703e3c703e5468697320697320746865204d61696e6e65742076657273696f6e2c20796f752063616e20766f7465206f6e20656974686572204d616e746c65206f7220457468657265756d204d61696e6e65742e20416c6c6f776c697374656420766f746572732063616e20766f746520666f7220616e79206f6620746865207375626d697373696f6e7320284c535473292e3c2f703e3c703e3c2f703e3c703e3c7374726f6e673e4d6f7469766174696f6e3c2f7374726f6e673e3c2f703e3c703e4f757220766973696f6e20666f7220456967656e4c61796572206973206175646163696f7573202d20776520656e766973696f6e20612066757475726520776865726520456967656e4c61796572207468726976657320696e20616e20756e63617070656420616e64207065726d697373696f6e6c6573732073746174652e2042757420746f2072656163682074686973206675747572652c207765206e65656420636f6d6d756e6974792070617274696369706174696f6e20616e64207468652072696768742061737365747320746f206261636b206f757220676f616c2e3c62723e3c2f703e3c703e546f6b656e732061726520656e636f75726167656420746f207072652d636f6d6d69742072657374616b696e6720766f6c756d652069662074686579e280997265207679696e6720666f72206265696e672061646465642e2054686520746f6b656e732077696c6c2062652072616e6b6564206261736564206f6e207468652045544820766f6c756d6520746865697220636f6d6d756e697469657320636f6d6d697420746f2072657374616b65206f6e207468697320636f6e7465737420616e642074686520766f7465206f6620746865206578697374696e6720456967656e4c617965722072657374616b657220636f6d6d756e6974792e3c2f703e3c703e3c2f703e3c703e3c7374726f6e673e436f6e74657374616e74204c5354733c2f7374726f6e673e3c2f703e3c703e3c2f703e3c703e416c6c20457468657265756d204c535420746f6b656e732c206261636b6564206279206f7665722031352c303030204554482c2061726520696e766974656420746f207375626d69742e20546f6b656e20686f6c64657273206f6e2074686520457468657265756d206d61696e6e65742c20657370656369616c6c792066726f6d207468652070726576696f75736c7920646973637573736564204c5020706f6f6c7320616e642074686f73652073746f72656420696e2077616c6c6574732c20686176652074686520726967687420746f20766f74652e3c2f703e3c703e3c2f703e3c703e416e79204c5354207468617420726563656976657320766f74657320657863656564696e672031352c303030204554482077696c6c20626520696e746567726174656420696e746f20456967656e4c6179657220696e20746865207570636f6d696e67206d6f6e7468732e2054686520696e636f72706f726174696f6e2077696c6c207374617274207769746820746865204c5354207468617420617474726163747320746865206d6f737420766f7465732c20726570726573656e74696e6720746865204c535420636f6d6d756e697479277320636f6d6d69746d656e7420746f2072657374616b652c20616e642077696c6c20636f6e74696e756520696e206f72646572206261736564206f6e20746865206e756d626572206f6620766f7465732066726f6d206869676865737420746f206c6f776573742e204164646974696f6e616c20636f6e74657374732077696c6c2062652072756e20696e20746865206675747572652c20696e766974696e67206e6577204c53547320746f2070617274696369706174652e3c62723e3c2f703e3c703e4261736564206f6e20746865736520706172616d65746572732c2074686520666f6c6c6f77696e6720746f6b656e732068617665206265656e20696e766974656420746f207375626d69743a3c2f703e3c6f6c3e3c6c693e3c703e3c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f65746865727363616e2e696f2f746f6b656e2f307861326533333536363130383430373031626466353631316135333937343531306165323765326531223e77424554483c2f613e202842696e616e636529266e6273703b3c2f703e3c2f6c693e3c6c693e3c703e3c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f65746865727363616e2e696f2f746f6b656e2f307861633365303138343537623232326439333131343435383437366633653334313661626265333866223e736672784554483c2f613e20284672617829266e6273703b3c2f703e3c2f6c693e3c6c693e3c703e3c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f65746865727363616e2e696f2f746f6b656e2f307846653265363337323032303536643330303136373235343737633564613038394162304130343341223e53455448323c2f613e20285374616b65776973652920286966205374616b6577697365206765747320656e6f75676820766f7465732c207468656972206e6577204c5354206f734554482077696c6c206265206164646564207768656e206c697665293c2f703e3c2f6c693e3c6c693e3c703e3c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f65746865727363616e2e696f2f746f6b656e2f307866393531453333356166623238393335336463323439653832393236313738456143374445643738223e73774554483c2f613e20285377656c6c29266e6273703b3c2f703e3c2f6c693e3c6c693e3c703e3c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f65746865727363616e2e696f2f746f6b656e2f307845393541323033423161393161393038463942394345343634353964313031303738633263336362223e416e6b724554483c2f613e2028416e6b7229266e6273703b3c2f703e3c2f6c693e3c6c693e3c703e3c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f65746865727363616e2e696f2f746f6b656e2f307832344165326441306633363141413442453436623438454231394339316530326335653466323745223e6d65764554483c2f613e20283c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d22687474703a2f2f6d65762e696f223e6d65762e696f3c2f613e29266e6273703b3c2f703e3c2f6c693e3c6c693e3c703e3c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f65746865727363616e2e696f2f746f6b656e2f307841333562314233314365303032464246323035384432324633306639354434303532303041313562223e457468583c2f613e202853746164657229266e6273703b3c2f703e3c2f6c693e3c6c693e3c703e3c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f65746865727363616e2e696f2f746f6b656e2f307838353663344566623736433144314145303265323043454230334132413661303862306238644333223e6f4554483c2f613e20284f726967696e20455448293c2f703e3c703e3c2f703e3c2f6c693e3c2f6f6c3e3c703e54686579206861766520756e74696c204e6f76203173742061742031706d2045535420746f207375626d69742074686569722070726f706f73616c732e3c2f703e3c703e3c62723e3c2f703e3c703e546865207465616d73206172652072657175657374656420746f20696e636c7564652074686520666f6c6c6f77696e6720696e207468656972207375626d697373696f6e733a3c2f703e3c703e3c62723e3c2f703e3c703e312e205075626c6963205477697474657220706f7374206c696e6b7320746861742064656d6f6e737472617465207468652064656469636174696f6e206f6620626f74682074686520636f7265207465616d20616e642074686520776964657220636f6d6d756e69747920746f2072657374616b65206f6e20456967656e4c617965722e3c2f703e3c703e322e2044657461696c732061626f7574207468652070726f6a65637420616e64206974732073796e65726779207769746820456967656e4c617965722e3c2f703e3c703e332e204120636c65617220726f61646d617020616e6420616e79206f7468657220656c656d656e747320746861742077696c6c2064697374696e677569736820796f7572204c535420696e207468652065796573206f662074686520456967656e4c6179657220636f6d6d756e69747920616e6420766f746572732e3c2f703e3c703e342e204f746865722069646561732077656c636f6d65213c2f703e3c703e3c2f703e3c703e3c7374726f6e673e566f74696e6720706f6f6c3c2f7374726f6e673e3c2f703e3c703e3c2f703e3c703e54686520736e617073686f74206f6620766f74657273207761732074616b656e206f6e20467269646179204f63742032377468206174203132706d204553542e2054686520666f6c6c6f77696e672044756e652064617368626f6172642069732074686520736f75726365206f6620747275746820666f722074686520736e617073686f742c20776869636820696e636c756465733a3c2f703e3c703e3c2f703e3c703e3c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f64756e652e636f6d2f7369786465677265652f656967656e6c617965722d6c73742d6164646974696f6e2d636f6e74657374223e68747470733a2f2f64756e652e636f6d2f7369786465677265652f656967656e6c617965722d6c73742d6164646974696f6e2d636f6e746573743c2f613e3c2f703e3c703e3c2f703e3c703e312e20486f6c64657273206f662074686520746f6b656e73206c69737465642061626f7665202b203c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f65746865727363616e2e696f2f746f6b656e2f307832306263383332636130383162393134333366663663313766383537303162366539323438366335223e72455448323c2f613e2c20626f7468206f6e2074686569722077616c6c65747320616e6420746865206d6f73742072656c6576616e74206c697175696469747920706f6f6c7320696e2074686520666f6c6c6f77696e672070726f746f636f6c733c2f703e3c703e3c2f703e3c756c3e3c6c693e3c703e556e6973776170202856322b5633293c2f703e3c2f6c693e3c6c693e3c703e43757276653c2f703e3c2f6c693e3c6c693e3c703e50656e646c653c2f703e3c2f6c693e3c6c693e3c703e42616c616e6365723c2f703e3c2f6c693e3c6c693e3c703e436f6d706f756e643c2f703e3c2f6c693e3c6c693e3c703e416176653c2f703e3c2f6c693e3c6c693e3c703e4d6176657269636b3c2f703e3c2f6c693e3c6c693e3c703e467261786c656e643c2f703e3c2f6c693e3c6c693e3c703e457175696c69627269613c2f703e3c2f6c693e3c6c693e3c703e50656e7069653c2f703e3c703e3c62723e3c2f703e3c2f6c693e3c2f756c3e3c703e322e20456967656e4c61796572206c69717569642072657374616b65727320616e642074686569722072657374616b6564206361706974616c3c2f703e3c703e3c62723e3c2f703e3c703e456163682077616c6c65742067657473203120766f746520706572204554482076616c7565206f6620746865697220686f6c64696e67732f72657374616b6564206361706974616c2e205468657265e2809973206120746f74616c206f662034342c34303920766f74657273207769746820312c3831392c3737352e333120766f74657320766f74657320746f20626520676976656e2e3c2f703e3c703e3c62723e3c2f703e3c703e3c7374726f6e673e4e6578742073746570733c2f7374726f6e673e3c2f703e3c703e3c2f703e3c703e5765e280997265206f7074696d69737469632061626f757420746865204c5354206c616e64736361706527732065766f6c7574696f6e2c2061696d696e6720746f20666163696c69746174652072657374616b696e6720666f72206576657279204c535420696e20746865206c6f6e67206861756c2e20486f77657665722c20696e2074686520696d6d656469617465206675747572652c2074686520696e746567726174696f6e2077696c6c2062652073657175656e7469616c2e20506f737420636f6e746573742c204c53547320746861742072656365697665206f7665722031352c3030302045544820696e20766f74656420696e7465726573742077696c6c20626520616464656420746f20456967656e4c617965722e20546865206a6f75726e65792077696c6c20636f6d6d656e6365207769746820746865206c656164696e67204c535420616e642070726f67726573732073657175656e7469616c6c792e204d6f726520636f6e746573747320616e64206f70706f7274756e697469657320666f72206e6577204c53547320617265206168656164213c2f703e3c703e3c62723e3c2f703e3c703e3c7374726f6e673e41626f757420456967656e4c617965723c2f7374726f6e673e3c2f703e3c703e3c2f703e3c703e456967656e4c6179657220697320612070726f746f636f6c207468617420696e74726f64756365732072657374616b696e672c207265766f6c7574696f6e697a696e672074686520776179207374616b6572732063616e2073656375726520616e6420706172746963697061746520696e206d756c7469706c652070726f746f636f6c732077697468696e2074686520457468657265756d2065636f73797374656d20616e64206265796f6e642e20456967656e4c617965722069732061742074686520666f726566726f6e74206f66206c657665726167696e6720457468657265756de2809973207374616b6564206361706974616c206261736520746f20656d706f77657220646576656c6f706572732c2076616c696461746f72732c20616e64207374616b6572732c20736f207061727469636970616e74732063616e206f7074696d697a65206361706974616c20656666696369656e63792c20656e68616e6365206e6574776f726b2073656375726974792c20616e6420756e6c6f636b2067726f756e64627265616b696e6720706f73736962696c697469657320696e206469766572736520626c6f636b636861696e2065636f73797374656d732e3c2f703e3c703e3c62723e3c2f703e3c703e466f6c6c6f77207573206f6e3a3c2f703e3c703e3c2f703e3c703e57656273697465203c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f7777772e656967656e6c617965722e78797a2f223e68747470733a2f2f7777772e656967656e6c617965722e78797a2f3c2f613e3c2f703e3c703e54776974746572203c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f747769747465722e636f6d2f656967656e6c61796572223e68747470733a2f2f747769747465722e636f6d2f656967656e6c617965723c2f613e3c2f703e3c703e446973636f7264203c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f646973636f72642e67672f656967656e6c61796572223e68747470733a2f2f646973636f72642e67672f656967656e6c617965723c2f613e3c2f703e3c703e466f72756d203c61207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f7265666572726572206e6f666f6c6c6f772220687265663d2268747470733a2f2f666f72756d2e656967656e6c617965722e78797a2f223e68747470733a2f2f666f72756d2e656967656e6c617965722e78797a2f3c2f613e3c2f703e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000653bfaa00000000000000000000000000000000000000000000000000000000000067b5f0000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000190000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fc91060814dbdaf1a29341323e99008a75154e369767bd36aa0417225c8f26c1"}