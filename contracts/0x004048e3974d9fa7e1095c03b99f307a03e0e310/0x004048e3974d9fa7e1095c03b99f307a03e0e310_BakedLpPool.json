{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2021-11-11\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.0;\r\n\r\n//import \"./nft.sol\";\r\n\r\n\r\nlibrary Math {\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n    }\r\n    \r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n    }\r\n    \r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n    \r\n    return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    \r\n    function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n    \r\n    return c;\r\n    }\r\n    \r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n    return 0;\r\n    }\r\n    \r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n    \r\n    return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    \r\n    function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    \r\n    return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    \r\n    function mod(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n    }\r\n}\r\n\r\ncontract Context1 {\r\n    constructor()  {}\r\n    \r\n    function _msgSender_() internal view returns (address payable) {\r\n    return payable(msg.sender);\r\n    }\r\n    \r\n    function _msgData_() internal view returns (bytes memory) {\r\n    this;\r\n    return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context1 {\r\n    address private _owner;\r\n    \r\n    event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n    );\r\n    \r\n    constructor()  {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n    \r\n    function owner() public view returns (address) {\r\n    return _owner;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n    require(isOwner(), \"Ownable: caller is not the owner\");\r\n    _;\r\n    }\r\n    \r\n    function isOwner() public view returns (bool) {\r\n    return msg.sender == _owner;\r\n    }\r\n    \r\n    function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n    }\r\n    \r\n    function _transferOwnership(address newOwner) internal {\r\n    require(\r\n    newOwner != address(0),\r\n    \"Ownable: new owner is the zero address\"\r\n    );\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n* @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n* the optional functions; to access them see {ERC20Detailed}.\r\n*/\r\ninterface IERC20 {\r\n    /**\r\n    * @dev Returns the amount of tokens in existence.\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    /**\r\n    * @dev Returns the token decimals.\r\n    */\r\n    function decimals() external view returns (uint8);\r\n    \r\n    /**\r\n    * @dev Returns the token symbol.\r\n    */\r\n    function symbol() external view returns (string memory);\r\n    \r\n    /**\r\n    * @dev Returns the token name.\r\n    */\r\n    function name() external view returns (string memory);\r\n    \r\n    /**\r\n    * @dev Returns the bep token owner.\r\n    */\r\n    function getOwner() external view returns (address);\r\n    \r\n    /**\r\n    * @dev Returns the amount of tokens owned by `account`.\r\n    */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n    * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    \r\n    /**\r\n    * @dev Returns the remaining number of tokens that `spender` will be\r\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n    * zero by default.\r\n    *\r\n    * This value changes when {approve} or {transferFrom} are called.\r\n    */\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    \r\n    /**\r\n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n    * that someone may use both the old and the new allowance by unfortunate\r\n    * transaction ordering. One possible solution to mitigate this race\r\n    * condition is to first reduce the spender's allowance to 0 and set the\r\n    * desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    *\r\n    * Emits an {Approval} event.\r\n    */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    \r\n    /**\r\n    * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n    * allowance mechanism. `amount` is then deducted from the caller's\r\n    * allowance.\r\n    *\r\n    * Returns a boolean value indicating whether the operation succeeded.\r\n    *\r\n    * Emits a {Transfer} event.\r\n    */\r\n    function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n    ) external returns (bool);\r\n    \r\n    /**\r\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n    * another (`to`).\r\n    *\r\n    * Note that `value` may be zero.\r\n    */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    /**\r\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n    * a call to {approve}. `value` is the new allowance.\r\n    */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address1 {\r\n    /**\r\n    * @dev Returns true if `account` is a contract.\r\n    *\r\n    * This test is non-exhaustive, and there may be false-negatives: during the\r\n    * execution of a contract's constructor, its address will be reported as\r\n    * not containing a contract.\r\n    *\r\n    * IMPORTANT: It is unsafe to assume that an address for which this\r\n    * function returns false is an externally-owned account (EOA) and not a\r\n    * contract.\r\n    */\r\n    function isContract(address account) internal view returns (bool) {\r\n    // This method relies in extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n    \r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly { codehash := extcodehash(account) }\r\n    return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n    \r\n    /**\r\n    * @dev Converts an `address` into `address payable`. Note that this is\r\n    * simply a type cast: the actual underlying value is not changed.\r\n    *\r\n    * Available since v2.4.0.\r\n    */\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n    return payable(address(uint160(account)));\r\n    }\r\n    \r\n    /**\r\n    * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n    * `recipient`, forwarding all available gas and reverting on errors.\r\n    *\r\n    * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n    * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n    * imposed by `transfer`, making them unable to receive funds via\r\n    * `transfer`. {sendValue} removes this limitation.\r\n    *\r\n    * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n    *\r\n    * IMPORTANT: because control is transferred to `recipient`, care must be\r\n    * taken to not create reentrancy vulnerabilities. Consider using\r\n    * {ReentrancyGuard} or the\r\n    * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n    *\r\n    * Available since v2.4.0.\r\n    */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n    \r\n    // solhint-disable-next-line avoid-call-value\r\n    (bool success, ) = recipient.call{value:amount}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// interface IPool {\r\n//     function notifyReward() external payable ;\r\n//     }\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n* @title SafeERC20\r\n* @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n* contract returns false). Tokens that return no value (and instead revert or\r\n* throw on failure) are also supported, non-reverting calls are assumed to be\r\n* successful.\r\n* To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n* which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n*/\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address1 for address;\r\n    \r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n    \r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    \r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    // solhint-disable-next-line max-line-length\r\n    require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n    \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n    );\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    \r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    \r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n    uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    \r\n    /**\r\n    * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n    * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n    * @param token The token targeted by the call.\r\n    * @param data The call data (encoded using abi.encode or one of its variants).\r\n    */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n    // we're implementing it ourselves.\r\n    \r\n    // A Solidity high level call has three parts:\r\n    // 1. The target address is checked to verify it contains contract code\r\n    // 2. The call itself is made, and success asserted\r\n    // 3. The return value is decoded, which in turn checks the size of the returned data.\r\n    // solhint-disable-next-line max-line-length\r\n    require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n    \r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = address(token).call(data);\r\n    require(success, \"SafeERC20: low-level call failed\");\r\n    \r\n    if (returndata.length > 0) { // Return data is optional\r\n    // solhint-disable-next-line max-line-length\r\n    require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n    }\r\n}\r\n\r\ncontract LPTokenWrapper is Ownable {\r\n    \r\n    \r\n    uint256 counter;\r\n    struct Stakepool {\r\n        uint256 timestamp;\r\n        uint256 amount;\r\n        address walletaddress;\r\n        bool iswhitelisted;\r\n        uint256 participationCount;\r\n        bool stakeStatus;\r\n        uint256 initialStakeTime;\r\n    }\r\n    \r\n    uint256 participationCount=0;\r\n    mapping(address => uint256)  Stakecount;\r\n    \r\n    mapping (uint256 => Stakepool) Stakemap;\r\n    uint256[] public stakeAccts;\r\n    \r\n    mapping (address => uint256[]) public toCheckList;\r\n\r\n    \r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    \r\n    //IERC20 public BAKED;\r\n    \r\n    IERC20 public BAKED = IERC20(0xa4cb0dCe4849BdcAd2d553E9e68644Cf40E26ccE); // BAKED Token\r\n    \r\n\r\n    \r\n    uint256 private _totalSupply;\r\n    //uint256 public counter=0;\r\n    mapping(address => uint256) private _balances;\r\n    \r\n    function totalSupply() public view returns (uint256) {\r\n    return _totalSupply.div(10 **18);\r\n    }\r\n    \r\n    function _balanceOf(address account) public view returns (uint256) {\r\n    return _balances[account].div(10**18);\r\n    }\r\n    \r\n    function stake(uint256 _stkId,uint256 amount) public virtual {\r\n        amount = amount.mul(10**18);\r\n    require(BAKED.balanceOf(msg.sender)>= amount,\"Error: User Token Balance is insufficient\");\r\n    _totalSupply = _totalSupply + amount;\r\n    _balances[msg.sender] = _balances[msg.sender].add(amount);\r\n    BAKED.safeTransferFrom\r\n    (msg.sender, address(this), amount);\r\n    }\r\n    \r\n    function withdraw(uint256 _stkId,uint256 amount) public virtual{\r\n        amount = amount.mul(10**18);\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    _balances[msg.sender] = _balances[msg.sender].sub(amount);\r\n    BAKED.safeTransfer(msg.sender, amount);\r\n    }\r\n    \r\n    function setStakePool(uint256 _stkId, uint256 _amount) public {\r\n        //var Stakepool = Stakemap[counter];\r\n        \r\n        Stakemap[_stkId].timestamp = block.timestamp;\r\n        Stakemap[_stkId].amount = _amount;\r\n        Stakemap[_stkId].walletaddress = msg.sender;\r\n        Stakemap[_stkId].stakeStatus = true;\r\n        Stakemap[_stkId].initialStakeTime = block.timestamp;\r\n        toCheckList[msg.sender].push(_stkId);\r\n\r\n    }\r\n    \r\n    function getStakes(uint256 _stakeid) view public returns (uint256, uint256, uint256, address, bool,bool,uint256) {\r\n        return (_stakeid,Stakemap[_stakeid].amount, Stakemap[_stakeid].timestamp, Stakemap[_stakeid].walletaddress,Stakemap[_stakeid].iswhitelisted,Stakemap[_stakeid].stakeStatus,Stakemap[_stakeid].initialStakeTime);\r\n    }\r\n    \r\n}\r\n\r\ncontract BakedLpPool is LPTokenWrapper {\r\n    \r\n    \r\n    uint256 public duration = 30 days; // 30 days;\r\n    uint256 starttime = 0; // trace startdate of staking pool\r\n    uint256 public minTokenValue= 25000;\r\n    uint256 trackStakeTime;\r\n    \r\n    uint256 whitelistedTime;\r\n    \r\n    \r\n    mapping(address => uint256) userRewardPerTokenPaid;\r\n    mapping(address => uint256) rewards;\r\n    \r\n    uint256 public totalparticipationCount=0;\r\n    mapping(address => uint256) public Totalticket;\r\n    \r\n    \r\n    event RewardAdded(uint256 reward);\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event Rewarded(address indexed from, address indexed to, uint256 value);\r\n    \r\n\r\n    function adminSetMinTokenAmount(uint256 _minTokenAmount) public onlyOwner {\r\n    minTokenValue = _minTokenAmount;\r\n    }\r\n    \r\n    function adminSetDuration(uint256 _duration) public onlyOwner {\r\n    duration = _duration;\r\n    }\r\n    \r\n    function stake(uint256 _stkId, uint256 amount) public  override {\r\n    require(amount > 0, \"Error : Cannot stake 0\");\r\n    require(amount >= minTokenValue, \"Error : Canot stake, need minimum Baked tokens\");\r\n    super.stake(_stkId,amount);\r\n    trackStakeTime=block.timestamp;\r\n    super.setStakePool(_stkId,amount);\r\n    }\r\n    \r\n    function withdraw(uint256 _stkId,uint256 amount) public override\r\n    {\r\n        uint256 stkTime = Stakemap[_stkId].initialStakeTime;\r\n        uint256 unstakeTime = stkTime + duration;\r\n    require(block.timestamp>=unstakeTime,\"Error:User not Completed the Lock duration\");\r\n    require(amount > 0, \"Error : Cannot withdraw 0\");\r\n    super.withdraw(_stkId,amount);\r\n    Stakemap[_stkId].stakeStatus = false;\r\n    \r\n    }\r\n    \r\n    \r\n    function whiteListed(uint256 _stakeid) public {\r\n        whitelistedTime = Stakemap[_stakeid].timestamp + duration;\r\n        require(block.timestamp >=whitelistedTime, \"Your Lock duration is not completed\" );\r\n        Stakemap[_stakeid].iswhitelisted = true;\r\n        \r\n        \r\n        uint256 rewardDuration =block.timestamp - Stakemap[_stakeid].timestamp;                                                                                                               \r\n        require(rewardDuration >= duration, \"Locking Period is not over\");\r\n        uint256 ticketonduration = rewardDuration/duration;\r\n        \r\n        require(Stakemap[_stakeid].amount >= minTokenValue,\"balance is low reward not applicable\");\r\n        uint256 ticketonamount = Stakemap[_stakeid].amount/minTokenValue;\r\n        \r\n        uint256 tempcount = Stakemap[_stakeid].participationCount;\r\n         Stakemap[_stakeid].participationCount = (ticketonamount * ticketonduration) + tempcount;\r\n        \r\n        address tempaddress = Stakemap[_stakeid].walletaddress;\r\n        Totalticket[tempaddress] = Totalticket[tempaddress] + (Stakemap[_stakeid].participationCount - tempcount);\r\n        \r\n       \r\n        Stakemap[_stakeid].timestamp = block.timestamp; \r\n    }\r\n    \r\n    function AllStakes(address _addr) public view returns(uint256[] memory)\r\n    {\r\n        return toCheckList[_addr];\r\n    }\r\n\r\n    \r\n    function iswhitelisted(uint256 _stakeid) public view returns(bool){\r\n        return Stakemap[_stakeid].iswhitelisted;\r\n    } \r\n    \r\n    function ticketcount(uint256 _stakeid) public view returns(uint256){\r\n        return Stakemap[_stakeid].participationCount;\r\n    }\r\n    \r\n    function changeAdmin(address newOwner) public onlyOwner{\r\n        transferOwnership(newOwner);\r\n    }\r\n    \r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Rewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"AllStakes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BAKED\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Totalticket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"adminSetDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTokenAmount\",\"type\":\"uint256\"}],\"name\":\"adminSetMinTokenAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"}],\"name\":\"getStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"}],\"name\":\"iswhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTokenValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setStakePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeAccts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"}],\"name\":\"ticketcount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"toCheckList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalparticipationCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeid\",\"type\":\"uint256\"}],\"name\":\"whiteListed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BakedLpPool", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e6e3af2e383f3eae417982a13495e425d23d9d78938d1f5887bd34aff4bd242e"}