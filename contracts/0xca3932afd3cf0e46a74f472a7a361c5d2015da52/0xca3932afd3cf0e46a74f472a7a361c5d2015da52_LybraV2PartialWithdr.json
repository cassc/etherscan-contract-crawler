{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"LybraV2PartialWithdraw.sol\": {\r\n      \"content\": \"// commit 4e7d762e04aa81475c87e0c4df5576bb983113e1\\npragma solidity ^0.8.19;\\n\\nimport \\\"BaseOwnable.sol\\\";\\n\\ninterface ILybraVault {\\n    function burn(address onBehalfOf, uint256 amount) external;\\n\\n    function withdraw(address onBehalfOf, uint256 amount) external;\\n\\n    function getBorrowedOf(address user) external view returns (uint256);\\n\\n    function depositedAsset(address user) external view returns (uint256);\\n\\n    function getAssetPrice() external returns (uint256);\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address _owner) external view returns (uint256);\\n}\\n\\ninterface IConfigurator {\\n    function getSafeCollateralRatio(address pool) external view returns (uint256);\\n}\\n\\ncontract LybraV2PartialWithdraw {\\n    bytes32 public constant NAME = \\\"LybraV2PartialWithdraw\\\";\\n    uint256 public constant VERSION = 1;\\n\\n    address public constant STETH_VAULT = 0xa980d4c0C2E48d305b582AA439a3575e3de06f0E;\\n    address public constant RETH_VAULT = 0x090B2787D6798000710a8e821EC6111d254bb958;\\n    address public constant WSTETH_VAULT = 0x5e28B5858DA2C6fb4E449D69EEb5B82e271c45Ce;\\n    address public constant WBETH_VAULT = 0xB72dA4A9866B0993b9a7d842E5060716F74BF262;\\n    address public constant PEUSD = 0xD585aaafA2B58b1CD75092B51ade9Fa4Ce52F247;\\n    address public constant EUSD = 0xdf3ac4F479375802A821f7b7b46Cd7EB5E4262cC;\\n    address public constant LYBRA_CONFIGURATOR = 0xC8353594Eeedc5ce5a4544D3D9907b694c4690Ff;\\n    uint256 public constant MAXIMUM_BUFFER = 5 * 10 ** 18;\\n\\n    function withdraw(address _vault, uint256 _buffer) external {\\n        require(\\n            _vault == STETH_VAULT || _vault == RETH_VAULT || _vault == WSTETH_VAULT || _vault == WBETH_VAULT,\\n            \\\"LybraV2Withdraw: vault not supported\\\"\\n        );\\n\\n        require(_buffer <= MAXIMUM_BUFFER, \\\"Exceed limit\\\");\\n\\n        if (_vault == address(STETH_VAULT)) {\\n            _handleRepayAndWithdraw(_vault, EUSD, _buffer);\\n        } else {\\n            _handleRepayAndWithdraw(_vault, PEUSD, _buffer);\\n        }\\n    }\\n\\n    function _handleRepayAndWithdraw(address _vault, address _token, uint256 _buffer) internal {\\n        (uint256 borrowedTokenAmount, uint256 collateralAmount) = _getSafeBorrowAndCollateral(_vault, address(this));\\n        uint256 remainingToken = _getSafeBorrowTokenBalance(_token);\\n        uint256 repayAmount = remainingToken < borrowedTokenAmount ? remainingToken : borrowedTokenAmount;\\n        uint256 maxCollateralWithdraw = _getMaxCollateralWithdraw(\\n            _vault,\\n            borrowedTokenAmount,\\n            repayAmount,\\n            collateralAmount,\\n            _buffer\\n        );\\n        _burnAndRepayVault(_vault, repayAmount, maxCollateralWithdraw - 1); // incase rounding error\\n    }\\n\\n    function _burnAndRepayVault(address _vault, uint256 borrowed, uint256 collateral) internal {\\n        if (borrowed > 0) {\\n            ILybraVault(_vault).burn(address(this), borrowed);\\n        }\\n\\n        if (collateral > 1) {\\n            ILybraVault(_vault).withdraw(address(this), collateral);\\n        }\\n    }\\n\\n    function _getMaxCollateralWithdraw(\\n        address _vault,\\n        uint256 _borrowed,\\n        uint256 _remainingBorrowedToken,\\n        uint256 _collateral,\\n        uint256 _buffer\\n    ) internal returns (uint256) {\\n        uint256 remainingBorrowedInLybra = _remainingBorrowedToken == _borrowed\\n            ? 0\\n            : _borrowed - _remainingBorrowedToken;\\n        if (remainingBorrowedInLybra == 0) {\\n            //@dev if repay all, return total collateral amount\\n            return _collateral;\\n        }\\n        uint256 safeCollateralRatio = IConfigurator(LYBRA_CONFIGURATOR).getSafeCollateralRatio(_vault);\\n        uint256 safeRatioWtihBuffer = safeCollateralRatio + _buffer;\\n        uint256 collateralPrice = ILybraVault(_vault).getAssetPrice();\\n        uint256 requireCollateralWithBuffer = (remainingBorrowedInLybra * safeRatioWtihBuffer) / collateralPrice / 100;\\n        uint256 maxCollateralWithdraw = requireCollateralWithBuffer > _collateral\\n            ? 0\\n            : _collateral - requireCollateralWithBuffer;\\n        return maxCollateralWithdraw;\\n    }\\n\\n    function _getSafeBorrowAndCollateral(\\n        address _vault,\\n        address _safe\\n    ) internal view returns (uint256 borrowed, uint256 collateral) {\\n        borrowed = ILybraVault(_vault).getBorrowedOf(_safe);\\n\\n        collateral = ILybraVault(_vault).depositedAsset(_safe);\\n    }\\n\\n    function _getSafeBorrowTokenBalance(address _token) internal view returns (uint256) {\\n        return IERC20(_token).balanceOf(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"BaseOwnable.sol\": {\r\n      \"content\": \"// commit 4e7d762e04aa81475c87e0c4df5576bb983113e1\\n// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"Errors.sol\\\";\\nimport \\\"BaseVersion.sol\\\";\\n\\n/// @title BaseOwnable - Simple ownership access control contract.\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\n/// @dev Can be used in both proxy and non-proxy mode.\\nabstract contract BaseOwnable is BaseVersion {\\n    address public owner;\\n    address public pendingOwner;\\n    bool private initialized = false;\\n\\n    event PendingOwnerSet(address indexed to);\\n    event NewOwnerSet(address indexed owner);\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, Errors.CALLER_IS_NOT_OWNER);\\n        _;\\n    }\\n\\n    /// @dev `owner` is set by argument, thus the owner can any address.\\n    ///      When used in non-proxy mode, `initialize` can not be called\\n    ///      after deployment.\\n    constructor(address _owner) {\\n        initialize(_owner);\\n    }\\n\\n    /// @dev When used in proxy mode, `initialize` can be called by anyone\\n    ///      to claim the ownership.\\n    ///      This function can be called only once.\\n    function initialize(address _owner) public {\\n        require(!initialized, \\\"Already initialized\\\");\\n        _setOwner(_owner);\\n        initialized = true;\\n    }\\n\\n    /// @notice User should ensure the corrent owner address set, or the\\n    ///         ownership may be transferred to blackhole. It is recommended to\\n    ///         take a safer way with setPendingOwner() + acceptOwner().\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        require(newOwner != address(0), \\\"New Owner is zero\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @notice The original owner calls `setPendingOwner(newOwner)` and the new\\n    ///         owner calls `acceptOwner()` to take the ownership.\\n    function setPendingOwner(address to) external onlyOwner {\\n        pendingOwner = to;\\n        emit PendingOwnerSet(pendingOwner);\\n    }\\n\\n    function acceptOwner() external {\\n        require(msg.sender == pendingOwner);\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /// @notice Make the contract immutable.\\n    function renounceOwnership() external onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    // Internal functions\\n\\n    /// @dev Clear pendingOwner to prevent from reclaiming the ownership.\\n    function _setOwner(address _owner) internal {\\n        owner = _owner;\\n        pendingOwner = address(0);\\n        emit NewOwnerSet(owner);\\n    }\\n}\\n\"\r\n    },\r\n    \"Errors.sol\": {\r\n      \"content\": \"// commit 4e7d762e04aa81475c87e0c4df5576bb983113e1\\n// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\n/// @dev Common errors. This helps reducing the contract size.\\nlibrary Errors {\\n    // \\\"E1\\\";\\n\\n    // Call/Static-call failed.\\n    string constant CALL_FAILED = \\\"E2\\\";\\n\\n    // Argument's type not supported in View Variant.\\n    string constant INVALID_VIEW_ARG_SOL_TYPE = \\\"E3\\\";\\n\\n    // Invalid length for variant raw data.\\n    string constant INVALID_VARIANT_RAW_DATA = \\\"E4\\\";\\n\\n    // \\\"E5\\\";\\n\\n    // Invalid variant type.\\n    string constant INVALID_VAR_TYPE = \\\"E6\\\";\\n\\n    // Rule not exists\\n    string constant RULE_NOT_EXISTS = \\\"E7\\\";\\n\\n    // Variant name not found.\\n    string constant VAR_NAME_NOT_FOUND = \\\"E8\\\";\\n\\n    // Rule: v1/v2 solType mismatch\\n    string constant SOL_TYPE_MISMATCH = \\\"E9\\\";\\n\\n    // \\\"E10\\\";\\n\\n    // Invalid rule OP.\\n    string constant INVALID_RULE_OP = \\\"E11\\\";\\n\\n    //  \\\"E12\\\";\\n\\n    // \\\"E13\\\";\\n\\n    //  \\\"E14\\\";\\n\\n    // \\\"E15\\\";\\n\\n    // \\\"E16\\\";\\n\\n    // \\\"E17\\\";\\n\\n    // \\\"E18\\\";\\n\\n    // \\\"E19\\\";\\n\\n    // \\\"E20\\\";\\n\\n    // checkCmpOp: OP not support\\n    string constant CMP_OP_NOT_SUPPORT = \\\"E21\\\";\\n\\n    // checkBySolType: Invalid op for bool\\n    string constant INVALID_BOOL_OP = \\\"E22\\\";\\n\\n    // checkBySolType: Invalid op\\n    string constant CHECK_INVALID_OP = \\\"E23\\\";\\n\\n    // Invalid solidity type.\\n    string constant INVALID_SOL_TYPE = \\\"E24\\\";\\n\\n    // computeBySolType: invalid vm op\\n    string constant INVALID_VM_BOOL_OP = \\\"E25\\\";\\n\\n    // computeBySolType: invalid vm arith op\\n    string constant INVALID_VM_ARITH_OP = \\\"E26\\\";\\n\\n    // onlyCaller: Invalid caller\\n    string constant INVALID_CALLER = \\\"E27\\\";\\n\\n    // \\\"E28\\\";\\n\\n    // Side-effect is not allowed here.\\n    string constant SIDE_EFFECT_NOT_ALLOWED = \\\"E29\\\";\\n\\n    // Invalid variant count for the rule op.\\n    string constant INVALID_VAR_COUNT = \\\"E30\\\";\\n\\n    // extractCallData: Invalid op.\\n    string constant INVALID_EXTRACTOR_OP = \\\"E31\\\";\\n\\n    // extractCallData: Invalid array index.\\n    string constant INVALID_ARRAY_INDEX = \\\"E32\\\";\\n\\n    // extractCallData: No extract op.\\n    string constant NO_EXTRACT_OP = \\\"E33\\\";\\n\\n    // extractCallData: No extract path.\\n    string constant NO_EXTRACT_PATH = \\\"E34\\\";\\n\\n    // BaseOwnable: caller is not owner\\n    string constant CALLER_IS_NOT_OWNER = \\\"E35\\\";\\n\\n    // BaseOwnable: Already initialized\\n    string constant ALREADY_INITIALIZED = \\\"E36\\\";\\n\\n    // \\\"E37\\\";\\n\\n    // \\\"E38\\\";\\n\\n    // BaseACL: ACL check method should not return anything.\\n    string constant ACL_FUNC_RETURNS_NON_EMPTY = \\\"E39\\\";\\n\\n    // \\\"E40\\\";\\n\\n    // BaseAccount: Invalid delegate.\\n    string constant INVALID_DELEGATE = \\\"E41\\\";\\n\\n    // RootAuthorizer: delegateCallAuthorizer not set\\n    string constant DELEGATE_CALL_AUTH_NOT_SET = \\\"E42\\\";\\n\\n    // RootAuthorizer: callAuthorizer not set.\\n    string constant CALL_AUTH_NOT_SET = \\\"E43\\\";\\n\\n    // BaseAccount: Authorizer not set.\\n    string constant AUTHORIZER_NOT_SET = \\\"E44\\\";\\n\\n    // BaseAccount: Invalid authorizer flag.\\n    string constant INVALID_AUTHORIZER_FLAG = \\\"E45\\\";\\n\\n    // BaseAuthorizer: Authorizer paused.\\n    string constant AUTHORIZER_PAUSED = \\\"E46\\\";\\n\\n    // Authorizer set: Invalid hint.\\n    string constant INVALID_HINT = \\\"E47\\\";\\n\\n    // Authorizer set: All auth deny.\\n    string constant ALL_AUTH_FAILED = \\\"E48\\\";\\n\\n    // BaseACL: Method not allow.\\n    string constant METHOD_NOT_ALLOW = \\\"E49\\\";\\n\\n    // AuthorizerUnionSet: Invalid hint collected.\\n    string constant INVALID_HINT_COLLECTED = \\\"E50\\\";\\n\\n    // AuthorizerSet: Empty auth set\\n    string constant EMPTY_AUTH_SET = \\\"E51\\\";\\n\\n    // AuthorizerSet: hint not implement.\\n    string constant HINT_NOT_IMPLEMENT = \\\"E52\\\";\\n\\n    // RoleAuthorizer: Empty role set\\n    string constant EMPTY_ROLE_SET = \\\"E53\\\";\\n\\n    // RoleAuthorizer: No auth for the role\\n    string constant NO_AUTH_FOR_THE_ROLE = \\\"E54\\\";\\n\\n    // BaseACL: No in contract white list.\\n    string constant NOT_IN_CONTRACT_LIST = \\\"E55\\\";\\n\\n    // BaseACL: Same process not allowed to install twice.\\n    string constant SAME_PROCESS_TWICE = \\\"E56\\\";\\n\\n    // BaseAuthorizer: Account not set (then can not find roleManger)\\n    string constant ACCOUNT_NOT_SET = \\\"E57\\\";\\n\\n    // BaseAuthorizer: roleManger not set\\n    string constant ROLE_MANAGER_NOT_SET = \\\"E58\\\";\\n}\\n\"\r\n    },\r\n    \"BaseVersion.sol\": {\r\n      \"content\": \"// commit 4e7d762e04aa81475c87e0c4df5576bb983113e1\\n// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\nimport \\\"IVersion.sol\\\";\\n\\n/// @title BaseVersion - Provides version information\\n/// @author Cobo Safe Dev Team https://www.cobo.com/\\n/// @dev\\n///    Implement NAME() and VERSION() methods according to IVersion interface.\\n///\\n///    Or just:\\n///      bytes32 public constant NAME = \\\"<Your contract name>\\\";\\n///      uint256 public constant VERSION = <Your contract version>;\\n///\\n///    Change the NAME when writing new kind of contract.\\n///    Change the VERSION when upgrading existing contract.\\nabstract contract BaseVersion is IVersion {\\n    /// @dev Convert to `string` which looks prettier on Etherscan viewer.\\n    function _NAME() external view virtual returns (string memory) {\\n        return string(abi.encodePacked(this.NAME()));\\n    }\\n}\\n\"\r\n    },\r\n    \"IVersion.sol\": {\r\n      \"content\": \"// commit 4e7d762e04aa81475c87e0c4df5576bb983113e1\\n// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.19;\\n\\ninterface IVersion {\\n    function NAME() external view returns (bytes32 name);\\n\\n    function VERSION() external view returns (uint256 version);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"LybraV2PartialWithdraw.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"EUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LYBRA_CONFIGURATOR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_BUFFER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PEUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RETH_VAULT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STETH_VAULT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBETH_VAULT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WSTETH_VAULT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_buffer\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LybraV2PartialWithdraw", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}