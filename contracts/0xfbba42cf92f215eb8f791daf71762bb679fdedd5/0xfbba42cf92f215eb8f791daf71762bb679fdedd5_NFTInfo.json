{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NFTInfo.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier:MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/****************************************************************************************************************\\r\\n *                                     Rug Redemption Wrapper Contract                                           *\\r\\n *                                               LordLabz                                                        *\\r\\n *   Designed: JoeSoap8308 (Dev of the Wrapped Companions - https://opensea.io/collection/wrappedcompanion-1)    *\\r\\n *                                 Modified: Dustin Turska | KronicLabz LLC                                      *\\r\\n *                                          https://kroniclabz.com                                               *\\r\\n *                                      https://twitter.com/KronicLabz                                           *\\r\\n *                               Securtiy contact: dustin.turska@kroniclabz.com                                  *\\r\\n ****************************************************************************************************************/\\r\\n/*\\r\\n-NFT data store to hold the following\\r\\n- Wrapped Status of Holder\\r\\n- Blocked NFT's (Ability to block founders/NFT's)\\r\\n- Stats\\r\\n*/\\r\\n\\r\\n//Interface to NFT contract which is the wrapper\\r\\ninterface wrapper {\\r\\n    function getArtApproval(uint256 _tokennumber, address _wallet)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function setStringArtPaths(\\r\\n        uint256 _pathno,\\r\\n        string memory _path,\\r\\n        uint256 _tokenid,\\r\\n        address _holder\\r\\n    ) external;\\r\\n}\\r\\n\\r\\n//Interface to Rugged NFT\\r\\ninterface ruggedNFT {\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n}\\r\\n\\r\\ncontract NFTInfo {\\r\\n    //Arrays///\\r\\n    uint256[] private blockednfts; //Array to handle a blocked nfts\\r\\n    //Std Variables///\\r\\n    address public wrapperaddress; //Address of Wrapper Contract\\r\\n    address public ruggedproject; //Address of the Rugged Project\\r\\n    address public Owner;\\r\\n    address public upgradecontract; //Additional contract which will be allowed to manage the TOKEN URI's\\r\\n    uint256 private numwraps;\\r\\n    uint256 public numholders;\\r\\n    uint256 public numblocked;\\r\\n    ///////Important Mappings///////\\r\\n    mapping(address => bool) internal wrapped; //Whether a holder has wrapped\\r\\n    mapping(address => bool) internal holder; //Whether they are a holder\\r\\n    mapping(uint256 => bool) internal blocked; //blocking due to mapping\\r\\n    mapping(uint256 => uint256) internal artenabled; //Dynamic mapping of art path selection\\r\\n    mapping(address => bool) internal blockedaddresses; //Additional addresses to blacklist\\r\\n    ///////Array for holders////////\\r\\n    address[] internal holderaddresses; //array to store the holders\\r\\n    ////////////////////////////////\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == Owner);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor() public {\\r\\n        Owner = msg.sender; //Owner of Contract\\r\\n    }\\r\\n\\r\\n    ///Configure the important addresses for the contract\\r\\n    function configNBAddresses(uint256 option, address _address)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        if (option == 1) {\\r\\n            wrapperaddress = _address;\\r\\n        }\\r\\n        if (option == 2) {\\r\\n            ruggedproject = _address;\\r\\n        }\\r\\n        if (option == 3) {\\r\\n            upgradecontract = _address;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Users to upgrade the TOKEN at a global level i.e Default URI\\r\\n    //The options are the following for _pathtype:\\r\\n    // 1) 0 =  Default URI for all tokens\\r\\n    // 2) 1 = Art Path 1 -> Customizable for all tokens\\r\\n    // 3) 2 = Art Path 1 -> Customizable for all tokens\\r\\n    // 4) 3 = Specifies custom art for a single token\\r\\n    // 5) 4 = Sets token back to default URI (negates option 3)\\r\\n    function setARTinWrapper(\\r\\n        uint256 _pathtype,\\r\\n        string memory _path,\\r\\n        uint256 _tokenid,\\r\\n        address _holder\\r\\n    ) public {\\r\\n        require(\\r\\n            msg.sender == Owner || msg.sender == upgradecontract,\\r\\n            \\\"Not Auth(U)\\\"\\r\\n        );\\r\\n        wrapper(wrapperaddress).setStringArtPaths(\\r\\n            _pathtype,\\r\\n            _path,\\r\\n            _tokenid,\\r\\n            _holder\\r\\n        );\\r\\n    }\\r\\n\\r\\n    //Obtain Art status for Token\\r\\n    function getArtStatus(uint256 _tokenid) public view returns (uint256) {\\r\\n        uint256 temp;\\r\\n        temp = artenabled[_tokenid];\\r\\n        return temp;\\r\\n    }\\r\\n\\r\\n    //This is slightly different from the above as this is used to set the ONLY the PATH for a token and not the Custom one (4)\\r\\n    //This is used when the token needs to be running a different path or reset back.\\r\\n    function setArtPath(\\r\\n        uint256 _tokennumber,\\r\\n        address _holder,\\r\\n        uint256 _pathno\\r\\n    ) external {\\r\\n        bool temp;\\r\\n        string memory dummy = \\\"\\\"; //dummy string to pass in\\r\\n        require(\\r\\n            msg.sender == Owner || msg.sender == upgradecontract,\\r\\n            \\\"Not Auth!\\\"\\r\\n        );\\r\\n        temp = wrapper(wrapperaddress).getArtApproval(_tokennumber, _holder); //requires the users approval to adjust the path!\\r\\n        require(temp == true, \\\"Owner not approved!\\\");\\r\\n        if (_pathno == 0) {\\r\\n            setARTinWrapper(4, dummy, _tokennumber, _holder); //Resets to default URI\\r\\n            artenabled[_tokennumber] = 0;\\r\\n        }\\r\\n        if (_pathno == 1) {\\r\\n            setARTinWrapper(4, dummy, _tokennumber, _holder); //Art path 1\\r\\n            artenabled[_tokennumber] = 1;\\r\\n        }\\r\\n        if (_pathno == 2) {\\r\\n            setARTinWrapper(4, dummy, _tokennumber, _holder); //Art path 2\\r\\n            artenabled[_tokennumber] = 2;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Function to Verify whether an NFT is blocked\\r\\n    function isBlockedNFT(uint256 _tokenID)\\r\\n        external\\r\\n        view\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        bool temp;\\r\\n        address tempaddress;\\r\\n        temp = blocked[_tokenID]; //Is the block at Token Level?\\r\\n        if (temp == false) // If not at token level,lets verify at address level\\r\\n        {\\r\\n            tempaddress = ownerOfToken(_tokenID);\\r\\n            temp = blockedaddresses[tempaddress]; // returns Bool dependant on block at address level\\r\\n        }\\r\\n\\r\\n        return (temp, 0);\\r\\n    }\\r\\n\\r\\n    //Function to return whether they are a holder or not\\r\\n    function isHolder(address _address) external view returns (bool) {\\r\\n        bool temp;\\r\\n        if (holder[_address] == true) {\\r\\n            temp = true;\\r\\n        }\\r\\n        return temp;\\r\\n    }\\r\\n\\r\\n    //Manage the user status i.e wrap=holder, unwarp=not a holder\\r\\n    function manageHolderAddresses(bool status, address _holder) external {\\r\\n        require(\\r\\n            msg.sender == wrapperaddress || msg.sender == Owner,\\r\\n            \\\"Not Oracle/Owner!\\\"\\r\\n        );\\r\\n        if (status == true) {\\r\\n            //Add user to array!\\r\\n            (bool _isholder, ) = isHolderInArray(_holder);\\r\\n            if (!_isholder) holderaddresses.push(_holder);\\r\\n        }\\r\\n        if (status == false) {\\r\\n            (bool _isholder, uint256 s) = isHolderInArray(_holder);\\r\\n            if (_isholder) {\\r\\n                holderaddresses[s] = holderaddresses[\\r\\n                    holderaddresses.length - 1\\r\\n                ];\\r\\n                holderaddresses.pop();\\r\\n            }\\r\\n            holder[_holder] = status;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /////To keep track of holders for future use\\r\\n    function manageNumHolders(uint256 _option) external {\\r\\n        require(\\r\\n            msg.sender == wrapperaddress || msg.sender == Owner,\\r\\n            \\\"Not Oracle/Owner!\\\"\\r\\n        );\\r\\n        if (_option == 1) //remove holder\\r\\n        {\\r\\n            numholders -= numholders - 1;\\r\\n        }\\r\\n        if (_option == 2) //add holder\\r\\n        {\\r\\n            numholders += 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /////Returns whether the user is stored in the array////////\\r\\n    function isHolderInArray(address _wallet)\\r\\n        public\\r\\n        view\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        for (uint256 s = 0; s < holderaddresses.length; s += 1) {\\r\\n            if (_wallet == holderaddresses[s]) return (true, s);\\r\\n        }\\r\\n        return (false, 0);\\r\\n    }\\r\\n\\r\\n    /////////////////////////\\r\\n\\r\\n    ///Function to manage addresses\\r\\n    function manageBlockedNFT(\\r\\n        int256 option,\\r\\n        uint256 _tokenID,\\r\\n        address _wallet,\\r\\n        uint256 _numNFT,\\r\\n        bool _onoroff\\r\\n    ) external onlyOwner {\\r\\n        address temp;\\r\\n        if (option == 1) // Add NFT to block list\\r\\n        {\\r\\n            blocked[_tokenID] = true;\\r\\n            numblocked += 1;\\r\\n        }\\r\\n        if (option == 2) //Remove from mapping\\r\\n        {\\r\\n            bool _isblocked = blocked[_tokenID];\\r\\n            if (_isblocked) {\\r\\n                blocked[_tokenID] = false;\\r\\n                if (numblocked > 0) {\\r\\n                    numblocked -= 1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (\\r\\n            option == 3\\r\\n        ) //Iterate through entire colletion and add. Added as a nice to have, but an iteration through an enite collection is expensive\\r\\n        {\\r\\n            for (uint256 s = 0; s < _numNFT; s += 1) {\\r\\n                if (s > 0) {\\r\\n                    temp = ownerOfToken(s);\\r\\n\\r\\n                    if (temp == _wallet) {\\r\\n                        blocked[s] = true;\\r\\n                        numblocked += 1;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if (option == 4) {\\r\\n            //setup blocking of addresses\\r\\n            blockedaddresses[_wallet] = _onoroff;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Set the status of a user if they have wrapped!\\r\\n    function setUserStatus(address _wrapper, bool _haswrapped) external {\\r\\n        require(\\r\\n            msg.sender == Owner || msg.sender == wrapperaddress,\\r\\n            \\\"Not Auth(WS)\\\"\\r\\n        );\\r\\n        wrapped[_wrapper] = _haswrapped;\\r\\n        numwraps += 1; //track number of wraps\\r\\n    }\\r\\n\\r\\n    //Returns whether a user has wrapped before..\\r\\n    function getWrappedStatus(address _migrator) external view returns (bool) {\\r\\n        bool temp;\\r\\n        if (wrapped[_migrator] == true) {\\r\\n            temp = true;\\r\\n        }\\r\\n        return temp;\\r\\n    }\\r\\n\\r\\n    //Returns stats based off\\r\\n    // 1) numholders based off the number of wrappers\\r\\n    // 2) The length of the array with addresss of wrappers\\r\\n    // 3) The number of current blockedNFT's\\r\\n    function getNumHolders(uint256 _feed) external view returns (uint256) {\\r\\n        uint256 temp;\\r\\n        if (_feed == 1) {\\r\\n            temp = numholders;\\r\\n        }\\r\\n        if (_feed == 2) {\\r\\n            temp = holderaddresses.length;\\r\\n        }\\r\\n        if (_feed == 3) {\\r\\n            temp = blockednfts.length;\\r\\n        }\\r\\n        return temp;\\r\\n    }\\r\\n\\r\\n    ///Returns the holder address given an Index\\r\\n    function getHolderAddress(uint256 _index)\\r\\n        external\\r\\n        view\\r\\n        returns (address payable)\\r\\n    {\\r\\n        address temp;\\r\\n        address payable temp2;\\r\\n        temp = holderaddresses[_index];\\r\\n        temp2 = payable(temp);\\r\\n        return temp2;\\r\\n    }\\r\\n\\r\\n    //Returns OwnerOf the original Rugged NFT itself\\r\\n    //Saves having to add an additional ABI in a webpage/contract to verify\\r\\n    function ownerOfToken(uint256 _tid) public view returns (address) {\\r\\n        address temp;\\r\\n        temp = ruggedNFT(ruggedproject).ownerOf(_tid);\\r\\n        return temp;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"option\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"configNBAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenid\",\"type\":\"uint256\"}],\"name\":\"getArtStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getHolderAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feed\",\"type\":\"uint256\"}],\"name\":\"getNumHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_migrator\",\"type\":\"address\"}],\"name\":\"getWrappedStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"isBlockedNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"isHolderInArray\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"option\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_numNFT\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_onoroff\",\"type\":\"bool\"}],\"name\":\"manageBlockedNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"manageHolderAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_option\",\"type\":\"uint256\"}],\"name\":\"manageNumHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numblocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numholders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"ownerOfToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ruggedproject\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pathtype\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_path\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"setARTinWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokennumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pathno\",\"type\":\"uint256\"}],\"name\":\"setArtPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrapper\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_haswrapped\",\"type\":\"bool\"}],\"name\":\"setUserStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upgradecontract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapperaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NFTInfo", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}