{"SourceCode": "// SPDX-License-Identifier: WTFPL\r\npragma solidity >=0.8.0;\r\n/**\r\n\r\n     \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \r\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557\r\n    \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2554\u255d\r\n    \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d \u255a\u2550\u2550\u2550\u2588\u2588\u2557\r\n    \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\r\n     \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d\r\n    \r\n    Concave Presale Token\r\n\r\n    pCNV to CNV mechanics\r\n    ---------------------\r\n    The contract features two vesting schedules to redeem pCNV into CNV. Both\r\n    schedules are linear, and have a duration of 2 years.\r\n\r\n    The first vesting schedule determines how many pCNV a holder can redeem at\r\n    any point in time. At contract inception - 0% of a holder's pCNV can be\r\n    redeemed. At the end of 2 years, 100% of a holder's pCNV can be redeemed.\r\n    It goes from 0% to 100% in a linear fashion.\r\n\r\n    The second vesting schedule determines the percent of CNV supply that pCNV\r\n    corresponds to. This vesting schedule also begins at 0% on day one, and\r\n    advances linearly to reach 10% at the end of year two.\r\n\r\n    The following is a breakdown of a pCNV to CNV redemption:\r\n\r\n    Assumptions:\r\n        - Alice holds 100 pCNV\r\n        - pCNV total supply is 200\r\n        - CNV total supply is 1000\r\n        - 1 year has passed and Alice has not made any previous redemptions\r\n\r\n    Then:\r\n        - The first vesting schedule tells us that users may redeem 50% of their\r\n          holdings, so Alice may redeem 50 pCNV.\r\n        - The second vesting schedule tells us that pCNV total supply corresponds\r\n          to 5% of total CNV supply.\r\n        - Since total CNV supply is 1000, 5% of it is 50, so 50 CNV are what\r\n          correspond to the 200 pCNV supply.\r\n        - Alice has 50% of total pCNV supply\r\n        - Thus, Alice is entitled to 50% of the claimable CNV supply, i.e Alice\r\n          is entitled to 25 CNV\r\n\r\n    Conclusion:\r\n        - Alice burns 50 pCNV\r\n        - Alice mints 25 CNV\r\n\r\n\r\n    ---------------------\r\n    @author 0xBarista & Dionysus (ConcaveFi)\r\n*/\r\n\r\n/* -------------------------------------------------------------------------- */\r\n/*                                   IMPORTS                                  */\r\n/* -------------------------------------------------------------------------- */\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                  EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\nlibrary SafeTransferLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                           ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 100 because the calldata length is 4 + 32 * 3.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                         INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\r\n        assembly {\r\n            // Get how many bytes the call returned.\r\n            let returnDataSize := returndatasize()\r\n\r\n            // If the call reverted:\r\n            if iszero(callStatus) {\r\n                // Copy the revert message into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Revert with the same message.\r\n                revert(0, returnDataSize)\r\n            }\r\n\r\n            switch returnDataSize\r\n            case 32 {\r\n                // Copy the return data into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Set success to whether it returned true.\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                // There was no return data.\r\n                success := 1\r\n            }\r\n            default {\r\n                // It returned some malformed input.\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\ninterface ICNV {\r\n    function mint(address to, uint256 amount) external returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n\r\n/// @notice Concave Presale Token\r\n/// @author 0xBarista & Dionysus (ConcaveFi)\r\ncontract pCNV is ERC20(\"Concave Presale Token\", \"pCNV\", 18) {\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                                DEPENDENCIES                            */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    using SafeTransferLib for ERC20;\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                             IMMUTABLE STATE                            */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    /// @notice UNIX timestamp when contact was created\r\n    uint256 public immutable GENESIS = block.timestamp;\r\n\r\n    /// @notice Two years in seconds\r\n    uint256 public immutable TWO_YEARS = 63072000;\r\n\r\n    /// @notice FRAX tokenIn address\r\n    ERC20 public immutable FRAX = ERC20(0x853d955aCEf822Db058eb8505911ED77F175b99e);\r\n\r\n    /// @notice DAI tokenIn address\r\n    ERC20 public immutable DAI = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);\r\n\r\n    /// @notice Error related to amount\r\n    string constant AMOUNT_ERROR = \"!AMOUNT\";\r\n\r\n    /// @notice Error related to token address\r\n    string constant TOKEN_IN_ERROR = \"!TOKEN_IN\";\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                              MUTABLE STATE                             */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    /// @notice CNV ERC20 token\r\n    /// @dev will be address(0) until redeemable = true\r\n    ICNV public CNV;\r\n\r\n    /// @notice Address that is recipient of raised funds + access control\r\n    address public treasury = 0x226e7AF139a0F34c6771DeB252F9988876ac1Ced;\r\n\r\n    /// @notice Returns the current merkle root being used\r\n    bytes32 public merkleRoot;\r\n\r\n    /// @notice Returns an array of all merkle roots used\r\n    bytes32[] public roots;\r\n\r\n    /// @notice Returns the current pCNV price in DAI/FRAX\r\n    uint256 public rate;\r\n\r\n    /// @notice Returns the max supply of pCNV that is allowed to be minted (in total)\r\n    uint256 public maxSupply = 33000000000000000000000000;\r\n\r\n    /// @notice Returns the total amount of pCNV that has cumulatively been minted\r\n    uint256 public totalMinted;\r\n\r\n    /// @notice Returns if pCNV are redeemable for CNV\r\n    bool public redeemable;\r\n\r\n    /// @notice Returns whether transfers are paused\r\n    bool public transfersPaused;\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                              STRUCTURED STATE                          */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    /// @notice Structure of Participant vesting storage\r\n    struct Participant {\r\n        uint256 purchased; // amount (in total) of pCNV that user has purchased\r\n        uint256 redeemed;  // amount (in total) of pCNV that user has redeemed\r\n    }\r\n\r\n    /// @notice             maps an account to vesting storage\r\n    /// address             - account to check\r\n    /// returns Participant - Structured vesting storage\r\n    mapping(address => Participant) public participants;\r\n\r\n    /// @notice             amount of DAI/FRAX user has spent for a specific root\r\n    /// bytes32             - merkle root\r\n    /// address             - account to check\r\n    /// returns uint256     - amount in DAI/FRAX (denominated in ether) spent purchasing pCNV\r\n    mapping(bytes32 => mapping(address => uint256)) public spentAmounts;\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                                  EVENTS                                */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    /// @notice Emitted when treasury changes treasury address\r\n    /// @param  treasury address of new treasury\r\n    event TreasurySet(address treasury);\r\n\r\n    /// @notice Emitted when redeemable is set to true and CNV address is set\r\n    /// @param  CNV address of CNV token\r\n    event RedeemableSet(address CNV);\r\n\r\n    /// @notice             Emitted when a new round is set by treasury\r\n    /// @param  merkleRoot  new merkle root\r\n    /// @param  rate        new price of pCNV in DAI/FRAX\r\n    event NewRound(bytes32 merkleRoot, uint256 rate);\r\n\r\n    /// @notice             Emitted when maxSupply of pCNV is burned or minted to target\r\n    /// @param  target      target to which to mint pCNV or burn if target = address(0)\r\n    /// @param  amount      amount of pCNV minted to target or burned\r\n    /// @param  maxSupply   new maxSupply\r\n    event Managed(address target, uint256 amount, uint256 maxSupply);\r\n\r\n    /// @notice                 Emitted when pCNV minted via \"mint()\" or \"mintWithPermit\"\r\n    /// @param  depositedFrom   address from which DAI/FRAX was deposited\r\n    /// @param  mintedTo        address to which pCNV were minted to\r\n    /// @param  amount          amount of pCNV minted\r\n    /// @param  deposited       amount of DAI/FRAX deposited\r\n    /// @param  totalMinted     total amount of pCNV minted so far\r\n    event Minted(\r\n        address indexed depositedFrom,\r\n        address indexed mintedTo,\r\n        uint256 amount,\r\n        uint256 deposited,\r\n        uint256 totalMinted\r\n    );\r\n\r\n    /// @notice             Emitted when pCNV redeemed for CNV by callign \"redeem()\"\r\n    /// @param  burnedFrom  address from which pCNV were burned\r\n    /// @param  mintedTo    address to which CNV were minted to\r\n    /// @param  burned      amount of pCNV burned\r\n    /// @param  minted      amount of CNV minted\r\n    event Redeemed(\r\n        address indexed burnedFrom,\r\n        address indexed mintedTo,\r\n        uint256 burned,\r\n        uint256 minted\r\n    );\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                                MODIFIERS                               */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    /// @notice only allows Concave treasury\r\n    modifier onlyConcave() {\r\n        require(msg.sender == treasury, \"!CONCAVE\");\r\n        _;\r\n    }\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                              ONLY CONCAVE                              */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    /// @notice Set a new treasury address if treasury\r\n    function setTreasury(\r\n        address _treasury\r\n    ) external onlyConcave {\r\n        treasury = _treasury;\r\n\r\n        emit TreasurySet(_treasury);\r\n    }\r\n\r\n    /// @notice         allow pCNV to be redeemed for CNV by setting redeemable as true and setting CNV address\r\n    /// @param  _CNV    address of CNV\r\n    function setRedeemable(\r\n        address _CNV\r\n    ) external onlyConcave {\r\n        // Allow tokens to be redeemed for CNV\r\n        redeemable = true;\r\n        // Set CNV address so tokens can be minted\r\n        CNV = ICNV(_CNV);\r\n\r\n        emit RedeemableSet(_CNV);\r\n    }\r\n\r\n    /// @notice             Update merkle root and rate\r\n    /// @param _merkleRoot  root of merkle tree\r\n    /// @param _rate        price of pCNV in DAI/FRAX\r\n    function setRound(\r\n        bytes32 _merkleRoot,\r\n        uint256 _rate\r\n    ) external onlyConcave {\r\n        require(_rate > 0, \"!RATE\");\r\n        // push new root to array of all roots - for viewing\r\n        roots.push(_merkleRoot);\r\n        // update merkle root\r\n        merkleRoot = _merkleRoot;\r\n        // update rate\r\n        rate = _rate;\r\n\r\n        emit NewRound(merkleRoot,rate);\r\n    }\r\n\r\n    /// @notice         Reduce an \"amount\" of available supply of pCNV or mint it to \"target\"\r\n    /// @param target   address to which to mint; if address(0), will burn\r\n    /// @param amount   to reduce from max supply or mint to \"target\"\r\n    function manage(\r\n        address target,\r\n        uint256 amount\r\n    ) external onlyConcave {\r\n        // declare new variable for totalMinted + amount (gas savings)\r\n        uint256 newAmount;\r\n        // if target is address 0, reduce supply\r\n        if (target == address(0)) {\r\n            // avoid subtracting into negatives\r\n            require(amount <= maxSupply, AMOUNT_ERROR);\r\n            // new maxSupply would be set to maxSupply minus amount\r\n            newAmount = maxSupply - amount;\r\n            // Make sure there's enough unminted supply to allow for supply reduction\r\n            require(newAmount >= totalMinted, AMOUNT_ERROR);\r\n            // Reduce max supply by \"amount\"\r\n            maxSupply = newAmount;\r\n            // end the function\r\n\r\n            emit Managed(target, amount, maxSupply);\r\n            return;\r\n        }\r\n        // new maxSupply would be set to totalMinted + amount\r\n        newAmount = totalMinted + amount;\r\n        // make sure total newAmount (totalMinted + amount) is less than or equal to maximum supply\r\n        require(newAmount <= maxSupply, AMOUNT_ERROR);\r\n        // set totalMinted to newAmount (totalMinted + amount)\r\n        totalMinted = newAmount;\r\n        // mint target amount\r\n        _mint(target, amount);\r\n\r\n        emit Managed(target, amount, maxSupply);\r\n    }\r\n\r\n    /// @notice         Allows Concave to pause transfers in the event of a bug\r\n    /// @param paused   if transfers should be paused or not\r\n    function setTransfersPaused(bool paused) external onlyConcave {\r\n        transfersPaused = paused;\r\n    }\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                              PUBLIC LOGIC                              */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    /// @notice               mint pCNV by providing merkle proof and depositing DAI/FRAX\r\n    /// @param to             whitelisted address pCNV will be minted to\r\n    /// @param tokenIn        address of tokenIn user wishes to deposit (DAI/FRAX)\r\n    /// @param maxAmount      max amount of DAI/FRAX sender can deposit for pCNV, to verify merkle proof\r\n    /// @param amountIn       amount of DAI/FRAX sender wishes to deposit for pCNV\r\n    /// @param proof          merkle proof to prove \"to\" and \"maxAmount\" are in merkle tree\r\n    function mint(\r\n        address to,\r\n        address tokenIn,\r\n        uint256 maxAmount,\r\n        uint256 amountIn,\r\n        bytes32[] calldata proof\r\n    ) external returns (uint256 amountOut) {\r\n        return _purchase(msg.sender, to, tokenIn, maxAmount, amountIn, proof);\r\n    }\r\n\r\n    /// @notice               mint pCNV by providing merkle proof and depositing DAI; uses EIP-2612 permit to save a transaction\r\n    /// @param to             whitelisted address pCNV will be minted to\r\n    /// @param tokenIn        address of tokenIn user wishes to deposit (DAI)\r\n    /// @param maxAmount      max amount of DAI sender can deposit for pCNV, to verify merkle proof\r\n    /// @param amountIn       amount of DAI sender wishes to deposit for pCNV\r\n    /// @param proof          merkle proof to prove \"to\" and \"maxAmount\" are in merkle tree\r\n    /// @param permitDeadline EIP-2612 : time when permit is no longer valid\r\n    /// @param v              EIP-2612 : part of EIP-2612 signature\r\n    /// @param r              EIP-2612 : part of EIP-2612 signature\r\n    /// @param s              EIP-2612 : part of EIP-2612 signature\r\n    function mintWithPermit(\r\n        address to,\r\n        address tokenIn,\r\n        uint256 maxAmount,\r\n        uint256 amountIn,\r\n        bytes32[] calldata proof,\r\n        uint256 permitDeadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountOut) {\r\n        // Make sure payment tokenIn is DAI\r\n        require(tokenIn == address(DAI), TOKEN_IN_ERROR);\r\n        // Approve tokens for spender - https://eips.ethereum.org/EIPS/eip-2612\r\n        ERC20(tokenIn).permit(msg.sender, address(this), amountIn, permitDeadline, v, r, s);\r\n        // allow sender to mint for \"to\"\r\n        return _purchase(msg.sender, to, tokenIn, maxAmount, amountIn, proof);\r\n    }\r\n\r\n    /// @notice         transfer \"amount\" of tokens from msg.sender to \"to\"\r\n    /// @dev            calls \"_beforeTransfer\" to update vesting storage for \"from\" and \"to\"\r\n    /// @param to       address tokens are being sent to\r\n    /// @param amount   number of tokens being transfered\r\n    function transfer(\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        // update vesting storage for both users\r\n        _beforeTransfer(msg.sender, to, amount);\r\n        // default ERC20 transfer\r\n        return super.transfer(to, amount);\r\n    }\r\n\r\n    /// @notice         transfer \"amount\" of tokens from \"from\" to \"to\"\r\n    /// @dev            calls \"_beforeTransfer\" to update vesting storage for \"from\" and \"to\"\r\n    /// @param from     address tokens are being transfered from\r\n    /// @param to       address tokens are being sent to\r\n    /// @param amount   number of tokens being transfered\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        // update vesting storage for both users\r\n        _beforeTransfer(from, to, amount);\r\n        // default ERC20 transfer\r\n        return super.transferFrom(from, to, amount);\r\n    }\r\n\r\n    /// @notice         redeem pCNV for CNV\r\n    /// @param to       address that will receive redeemed CNV\r\n    /// @param amountIn amount of pCNV to redeem\r\n    function redeem(\r\n        address to,\r\n        uint256 amountIn\r\n    ) external {\r\n        // Make sure pCNV is currently redeemable for CNV\r\n        require(redeemable, \"!REDEEMABLE\");\r\n\r\n        // Access participant storage\r\n        Participant storage participant = participants[msg.sender];\r\n\r\n        // Calculate CNV owed to sender for redeeming \"amountIn\"\r\n        uint256 amountOut = redeemAmountOut(msg.sender, amountIn);\r\n\r\n        // Increase participant.redeemed by amount being redeemed\r\n        participant.redeemed += amountIn;\r\n\r\n        // Burn users pCNV\r\n        _burn(msg.sender, amountIn);\r\n\r\n        // Mint user CNV\r\n        CNV.mint(to, amountOut);\r\n\r\n        emit Redeemed(msg.sender, to, amountIn, amountOut);\r\n    }\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                               PUBLIC VIEW                              */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    /// @notice         Returns the amount of CNV a user will receive for redeeming `amountIn` of pCNV\r\n    /// @param who      address that will receive redeemed CNV\r\n    /// @param amountIn amount of pCNV\r\n    function redeemAmountOut(address who, uint256 amountIn) public view returns (uint256) {\r\n        // Make sure amountIn is less than participants maximum redeem amount in\r\n        require(amountIn <= maxRedeemAmountIn(who), AMOUNT_ERROR);\r\n\r\n        // Calculate percentage of maxRedeemAmountIn that participant is redeeming\r\n        uint256 ratio = 1e18 * amountIn / maxRedeemAmountIn(who);\r\n\r\n        // Calculate portion of maxRedeemAmountOut to mint using above percentage\r\n        return maxRedeemAmountOut(who) * ratio / 1e18;\r\n    }\r\n\r\n    /// @notice     Returns amount of pCNV that user can redeem according to vesting schedule\r\n    /// @dev        Returns redeem * percentageVested / (eth normalized) - total already redeemed\r\n    /// @param who  address to check\r\n    function maxRedeemAmountIn(\r\n        address who\r\n    ) public view returns (uint256) {\r\n        // Make sure pCNV is currently redeemable for CNV\r\n        if (!redeemable) return 0;\r\n        // Make sure there's CNV supply\r\n        if (CNV.totalSupply() == 0) return 0;\r\n        // Access sender's participant memory\r\n        Participant memory participant = participants[who];\r\n        // return maximum amount of pCNV \"who\" can currently redeem\r\n        return participant.purchased * purchaseVested() / 1e18 - participant.redeemed;\r\n    }\r\n\r\n    /// @notice     Returns amount of CNV that an account can currently redeem for\r\n    /// @param who  address to check\r\n    function maxRedeemAmountOut(\r\n        address who\r\n    ) public view returns (uint256) {\r\n        return amountVested() * percentToRedeem(who) / 1e18;\r\n    }\r\n\r\n    /// @notice     Returns percentage (denominated in ether) of pCNV supply that a given account can currently redeem\r\n    /// @param who  address to check\r\n    function percentToRedeem(\r\n        address who\r\n    ) public view returns (uint256) {\r\n        return 1e18 * maxRedeemAmountIn(who) / maxSupply;\r\n    }\r\n\r\n    /// @notice Returns the amount of time (in seconds) that has passed since the contract was created\r\n    function elapsed() public view returns (uint256) {\r\n        return block.timestamp - GENESIS;\r\n    }\r\n\r\n    /// @notice Returns the percentage of CNV supply (denominated in ether) that all pCNV is currently redeemable for\r\n    function supplyVested() public view returns (uint256) {\r\n        return elapsed() > TWO_YEARS ? 1e17 : 1e17 * elapsed() / TWO_YEARS;\r\n    }\r\n\r\n    /// @notice Returns the percent of pCNV that is redeemable\r\n    function purchaseVested() public view returns (uint256) {\r\n        return elapsed() > TWO_YEARS ? 1e18 : 1e18 * elapsed() / TWO_YEARS;\r\n    }\r\n\r\n    /// @notice Returns total amount of CNV supply that is vested\r\n    function amountVested() public view returns (uint256) {\r\n        return CNV.totalSupply() * supplyVested() / 1e18;\r\n    }\r\n\r\n    /* ---------------------------------------------------------------------- */\r\n    /*                             INTERNAL LOGIC                             */\r\n    /* ---------------------------------------------------------------------- */\r\n\r\n    /// @notice               Deposits FRAX/DAI for pCNV if merkle proof exists in specified round\r\n    /// @param sender         address sending transaction\r\n    /// @param to             whitelisted address purchased pCNV will be sent to\r\n    /// @param tokenIn        address of tokenIn user wishes to deposit\r\n    /// @param maxAmount      max amount of DAI/FRAX sender can deposit for pCNV\r\n    /// @param amountIn       amount of DAI/FRAX sender wishes to deposit for pCNV\r\n    /// @param proof          merkle proof to prove address and amount are in tree\r\n    function _purchase(\r\n        address sender,\r\n        address to,\r\n        address tokenIn,\r\n        uint256 maxAmount,\r\n        uint256 amountIn,\r\n        bytes32[] calldata proof\r\n    ) internal returns(uint256 amountOut) {\r\n        // Make sure payment tokenIn is either DAI or FRAX\r\n        require(tokenIn == address(DAI) || tokenIn == address(FRAX), TOKEN_IN_ERROR);\r\n\r\n        // Require merkle proof with `to` and `maxAmount` to be successfully verified\r\n        require(MerkleProof.verify(proof, merkleRoot, keccak256(abi.encodePacked(to, maxAmount))), \"!PROOF\");\r\n\r\n        // Verify amount claimed by user does not surpass \"maxAmount\"\r\n        uint256 newAmount = spentAmounts[merkleRoot][to] + amountIn; // save gas\r\n        require(newAmount <= maxAmount, AMOUNT_ERROR);\r\n        spentAmounts[merkleRoot][to] = newAmount;\r\n\r\n        // Calculate rate of pCNV that should be returned for \"amountIn\"\r\n        amountOut = amountIn * 1e18 / rate;\r\n\r\n        // make sure total minted + amount is less than or equal to maximum supply\r\n        require(totalMinted + amountOut <= maxSupply, AMOUNT_ERROR);\r\n\r\n        // Interface storage for participant\r\n        Participant storage participant = participants[to];\r\n\r\n        // Increase participant.purchased to account for newly purchased tokens\r\n        participant.purchased += amountOut;\r\n\r\n        // Increase totalMinted to account for newly minted supply\r\n        totalMinted += amountOut;\r\n\r\n        // Transfer amountIn*ratio of tokenIn to treasury address\r\n        ERC20(tokenIn).safeTransferFrom(sender, treasury, amountIn);\r\n\r\n        // Mint tokens to address after pulling\r\n        _mint(to, amountOut);\r\n\r\n        emit Minted(sender, to, amountOut, amountIn, totalMinted);\r\n    }\r\n\r\n    /// @notice         Maintains total amount of redeemable tokens when pCNV is being transfered\r\n    /// @param from     address tokens are being transfered from\r\n    /// @param to       address tokens are being sent to\r\n    /// @param amount   number of tokens being transfered\r\n    function _beforeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        // transfers must not be paused\r\n        require(!transfersPaused, \"PAUSED\");\r\n\r\n        // Interface \"to\" participant storage\r\n        Participant storage toParticipant = participants[to];\r\n\r\n        // Interface \"from\" participant storage\r\n        Participant storage fromParticipant = participants[from];\r\n\r\n        // calculate amount to adjust redeem amounts by\r\n        uint256 adjustedAmount = amount * fromParticipant.redeemed / fromParticipant.purchased;\r\n\r\n        // reduce \"from\" redeemed by amount * \"from\" redeem purchase ratio\r\n        fromParticipant.redeemed -= adjustedAmount;\r\n\r\n        // reduce \"from\" purchased amount by the amount being sent\r\n        fromParticipant.purchased -= amount;\r\n\r\n        // increase \"to\" redeemed by amount * \"from\" redeem purchase ratio\r\n        toParticipant.redeemed += adjustedAmount;\r\n\r\n        // increase \"to\" purchased by amount received\r\n        toParticipant.purchased += amount;\r\n    }\r\n\r\n    /// @notice         Rescues accidentally sent tokens and ETH\r\n    /// @param token    address of token to rescue, if address(0) rescue ETH\r\n    function rescue(address token) external onlyConcave {\r\n        if (token == address(0)) payable(treasury).transfer( address(this).balance );\r\n        else ERC20(token).transfer(treasury, ERC20(token).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\n/**\r\n\r\n    \"someone spent a lot of computational power and time to bruteforce that contract address\r\n    so basically to have that many leading zeros\r\n    you can't just create a contract and get that, the odds are 1 in trillions to get something like that\r\n    there's a way to guess which contract address you will get, using a script.. and you have to bruteforce for a very long time to get that many leading 0's\r\n    fun fact, the more leading 0's a contract has, the cheaper gas will be for users to interact with the contract\"\r\n    \r\n        - some solidity dev\r\n\r\n    \u00a9 2022 WTFPL \u2013 Do What the Fuck You Want to Public License.\r\n*/", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"Managed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositedFrom\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mintedTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposited\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalMinted\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"CNV\",\"type\":\"address\"}],\"name\":\"RedeemableSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burnedFrom\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mintedTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"TreasurySet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CNV\",\"outputs\":[{\"internalType\":\"contract ICNV\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FRAX\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GENESIS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TWO_YEARS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"elapsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"manage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"maxRedeemAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"maxRedeemAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"permitDeadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mintWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"purchased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"percentToRedeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaseVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"redeemAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_CNV\",\"type\":\"address\"}],\"name\":\"setRedeemable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setTransfersPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"spentAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transfersPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "pCNV", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://217a641487b29466e91201f217f80331f68cd4f02432c373946b117282bb64f2"}