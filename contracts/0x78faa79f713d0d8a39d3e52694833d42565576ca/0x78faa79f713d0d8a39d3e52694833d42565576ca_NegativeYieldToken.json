{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity 0.8.13;\r\n\r\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\r\n// Simplified by BoringCrypto\r\n\r\ncontract BoringOwnableData {\r\n    address public owner;\r\n    address public pendingOwner;\r\n}\r\n\r\ncontract BoringOwnable is BoringOwnableData {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice `owner` defaults to msg.sender on construction.\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\r\n    /// Can only be invoked by the current `owner`.\r\n    /// @param newOwner Address of the new owner.\r\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\r\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\r\n    function transferOwnership(\r\n        address newOwner,\r\n        bool direct,\r\n        bool renounce\r\n    ) public onlyOwner {\r\n        if (direct) {\r\n            // Checks\r\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\r\n\r\n            // Effects\r\n            emit OwnershipTransferred(owner, newOwner);\r\n            owner = newOwner;\r\n            pendingOwner = address(0);\r\n        } else {\r\n            // Effects\r\n            pendingOwner = newOwner;\r\n        }\r\n    }\r\n\r\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\r\n    function claimOwnership() public {\r\n        address _pendingOwner = pendingOwner;\r\n\r\n        // Checks\r\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\r\n\r\n        // Effects\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /// @notice Only allows the `owner` to execute the function.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    event Debug(bool one, bool two, uint256 retsize);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"APPROVE_FAILED\");\r\n    }\r\n}\r\n\r\n/// @notice Arithmetic library with operations for fixed-point numbers.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\r\nlibrary FixedPointMathLib {\r\n    /*//////////////////////////////////////////////////////////////\r\n                    SIMPLIFIED FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\r\n\r\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\r\n    }\r\n\r\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\r\n    }\r\n\r\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\r\n    }\r\n\r\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    LOW LEVEL FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function mulDivDown(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // Divide z by the denominator.\r\n            z := div(z, denominator)\r\n        }\r\n    }\r\n\r\n    function mulDivUp(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // First, divide z - 1 by the denominator and add 1.\r\n            // We allow z - 1 to underflow if z is 0, because we multiply the\r\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\r\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\r\n        }\r\n    }\r\n\r\n    function rpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 scalar\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    // 0 ** 0 = 1\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // 0 ** n = 0\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    // If n is even, store scalar in z for now.\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // If n is odd, store x in z for now.\r\n                    z := x\r\n                }\r\n\r\n                // Shifting right by 1 is like dividing by 2.\r\n                let half := shr(1, scalar)\r\n\r\n                for {\r\n                    // Shift n right by 1 before looping to halve it.\r\n                    n := shr(1, n)\r\n                } n {\r\n                    // Shift n right by 1 each iteration to halve it.\r\n                    n := shr(1, n)\r\n                } {\r\n                    // Revert immediately if x ** 2 would overflow.\r\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\r\n                    if shr(128, x) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Store x squared.\r\n                    let xx := mul(x, x)\r\n\r\n                    // Round to the nearest number.\r\n                    let xxRound := add(xx, half)\r\n\r\n                    // Revert if xx + half overflowed.\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Set x to scaled xxRound.\r\n                    x := div(xxRound, scalar)\r\n\r\n                    // If n is even:\r\n                    if mod(n, 2) {\r\n                        // Compute z * x.\r\n                        let zx := mul(z, x)\r\n\r\n                        // If z * x overflowed:\r\n                        if iszero(eq(div(zx, x), z)) {\r\n                            // Revert if x is non-zero.\r\n                            if iszero(iszero(x)) {\r\n                                revert(0, 0)\r\n                            }\r\n                        }\r\n\r\n                        // Round to the nearest number.\r\n                        let zxRound := add(zx, half)\r\n\r\n                        // Revert if zx + half overflowed.\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n\r\n                        // Return properly scaled zxRound.\r\n                        z := div(zxRound, scalar)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        GENERAL NUMBER UTILITIES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Start off with z at 1.\r\n            z := 1\r\n\r\n            // Used below to help find a nearby power of 2.\r\n            let y := x\r\n\r\n            // Find the lowest power of 2 that is at least sqrt(x).\r\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\r\n                y := shr(128, y) // Like dividing by 2 ** 128.\r\n                z := shl(64, z) // Like multiplying by 2 ** 64.\r\n            }\r\n            if iszero(lt(y, 0x10000000000000000)) {\r\n                y := shr(64, y) // Like dividing by 2 ** 64.\r\n                z := shl(32, z) // Like multiplying by 2 ** 32.\r\n            }\r\n            if iszero(lt(y, 0x100000000)) {\r\n                y := shr(32, y) // Like dividing by 2 ** 32.\r\n                z := shl(16, z) // Like multiplying by 2 ** 16.\r\n            }\r\n            if iszero(lt(y, 0x10000)) {\r\n                y := shr(16, y) // Like dividing by 2 ** 16.\r\n                z := shl(8, z) // Like multiplying by 2 ** 8.\r\n            }\r\n            if iszero(lt(y, 0x100)) {\r\n                y := shr(8, y) // Like dividing by 2 ** 8.\r\n                z := shl(4, z) // Like multiplying by 2 ** 4.\r\n            }\r\n            if iszero(lt(y, 0x10)) {\r\n                y := shr(4, y) // Like dividing by 2 ** 4.\r\n                z := shl(2, z) // Like multiplying by 2 ** 2.\r\n            }\r\n            if iszero(lt(y, 0x8)) {\r\n                // Equivalent to 2 ** z.\r\n                z := shl(1, z)\r\n            }\r\n\r\n            // Shifting right by 1 is like dividing by 2.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // Compute a rounded down version of z.\r\n            let zRoundDown := div(x, z)\r\n\r\n            // If zRoundDown is smaller, use it.\r\n            if lt(zRoundDown, z) {\r\n                z := zRoundDown\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Minimal ERC4626 tokenized Vault implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\r\nabstract contract ERC4626 is ERC20 {\r\n    using SafeTransferLib for ERC20;\r\n    using FixedPointMathLib for uint256;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed caller,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               IMMUTABLES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    ERC20 public immutable asset;\r\n\r\n    constructor(\r\n        ERC20 _asset,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) ERC20(_name, _symbol, _asset.decimals()) {\r\n        asset = _asset;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        DEPOSIT/WITHDRAWAL LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\r\n        // Check for rounding error since we round down in previewDeposit.\r\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\r\n\r\n        // Need to transfer before minting or ERC777s could reenter.\r\n        asset.safeTransferFrom(msg.sender, address(this), assets);\r\n\r\n        _mint(receiver, shares);\r\n\r\n        emit Deposit(msg.sender, receiver, assets, shares);\r\n\r\n        afterDeposit(assets, shares);\r\n    }\r\n\r\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\r\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\r\n\r\n        // Need to transfer before minting or ERC777s could reenter.\r\n        asset.safeTransferFrom(msg.sender, address(this), assets);\r\n\r\n        _mint(receiver, shares);\r\n\r\n        emit Deposit(msg.sender, receiver, assets, shares);\r\n\r\n        afterDeposit(assets, shares);\r\n    }\r\n\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner\r\n    ) public virtual returns (uint256 shares) {\r\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\r\n\r\n        if (msg.sender != owner) {\r\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\r\n\r\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\r\n        }\r\n\r\n        beforeWithdraw(assets, shares);\r\n\r\n        _burn(owner, shares);\r\n\r\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\r\n\r\n        asset.safeTransfer(receiver, assets);\r\n    }\r\n\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner\r\n    ) public virtual returns (uint256 assets) {\r\n        if (msg.sender != owner) {\r\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\r\n\r\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\r\n        }\r\n\r\n        // Check for rounding error since we round down in previewRedeem.\r\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\r\n\r\n        beforeWithdraw(assets, shares);\r\n\r\n        _burn(owner, shares);\r\n\r\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\r\n\r\n        asset.safeTransfer(receiver, assets);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ACCOUNTING LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function totalAssets() public view virtual returns (uint256);\r\n\r\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\r\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\r\n\r\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\r\n    }\r\n\r\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\r\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\r\n\r\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\r\n    }\r\n\r\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\r\n        return convertToShares(assets);\r\n    }\r\n\r\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\r\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\r\n\r\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\r\n    }\r\n\r\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\r\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\r\n\r\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\r\n    }\r\n\r\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\r\n        return convertToAssets(shares);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function maxDeposit(address) public view virtual returns (uint256) {\r\n        return type(uint256).max;\r\n    }\r\n\r\n    function maxMint(address) public view virtual returns (uint256) {\r\n        return type(uint256).max;\r\n    }\r\n\r\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\r\n        return convertToAssets(balanceOf[owner]);\r\n    }\r\n\r\n    function maxRedeem(address owner) public view virtual returns (uint256) {\r\n        return balanceOf[owner];\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                          INTERNAL HOOKS LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\r\n\r\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\r\n}\r\n\r\n/// @notice Gas optimized reentrancy protection for smart contracts.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\r\nabstract contract ReentrancyGuard {\r\n    uint256 private locked = 1;\r\n\r\n    modifier nonReentrant() virtual {\r\n        require(locked == 1, \"REENTRANCY\");\r\n\r\n        locked = 2;\r\n\r\n        _;\r\n\r\n        locked = 1;\r\n    }\r\n}\r\n\r\n/// @notice Library for converting between addresses and bytes32 values.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\r\nlibrary Bytes32AddressLib {\r\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\r\n        return address(uint160(uint256(bytesValue)));\r\n    }\r\n\r\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\r\n        return bytes32(bytes20(addressValue));\r\n    }\r\n}\r\n\r\n/// @title BaseERC20\r\n/// @author zefram.eth\r\n/// @notice The base ERC20 contract used by NegativeYieldToken and PerpetualYieldToken\r\n/// @dev Uses the same number of decimals as the vault's underlying token\r\ncontract BaseERC20 is ERC20 {\r\n    /// -----------------------------------------------------------------------\r\n    /// Errors\r\n    /// -----------------------------------------------------------------------\r\n\r\n    error Error_NotGate();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Immutable parameters\r\n    /// -----------------------------------------------------------------------\r\n\r\n    Gate public immutable gate;\r\n    address public immutable vault;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Constructor\r\n    /// -----------------------------------------------------------------------\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        Gate gate_,\r\n        address vault_\r\n    ) ERC20(name_, symbol_, gate_.getUnderlyingOfVault(vault_).decimals()) {\r\n        gate = gate_;\r\n        vault = vault_;\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Gate-callable functions\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function gateMint(address to, uint256 amount) external virtual {\r\n        if (msg.sender != address(gate)) {\r\n            revert Error_NotGate();\r\n        }\r\n\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function gateBurn(address from, uint256 amount) external virtual {\r\n        if (msg.sender != address(gate)) {\r\n            revert Error_NotGate();\r\n        }\r\n\r\n        _burn(from, amount);\r\n    }\r\n}\r\n\r\n/// @title PerpetualYieldToken\r\n/// @author zefram.eth\r\n/// @notice The ERC20 contract representing perpetual yield tokens\r\ncontract PerpetualYieldToken is BaseERC20 {\r\n    /// -----------------------------------------------------------------------\r\n    /// Constructor\r\n    /// -----------------------------------------------------------------------\r\n\r\n    constructor(Gate gate_, address vault_)\r\n        BaseERC20(\r\n            gate_.perpetualYieldTokenName(vault_),\r\n            gate_.perpetualYieldTokenSymbol(vault_),\r\n            gate_,\r\n            vault_\r\n        )\r\n    {}\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ERC20 overrides\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        // load balances to save gas\r\n        uint256 fromBalance = balanceOf[msg.sender];\r\n        uint256 toBalance = balanceOf[to];\r\n\r\n        // call transfer hook\r\n        gate.beforePerpetualYieldTokenTransfer(\r\n            msg.sender,\r\n            to,\r\n            amount,\r\n            fromBalance,\r\n            toBalance\r\n        );\r\n\r\n        // do transfer\r\n        // skip during self transfers since toBalance is cached\r\n        // which leads to free minting, a critical issue\r\n        if (msg.sender != to) {\r\n            balanceOf[msg.sender] = fromBalance - amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] = toBalance + amount;\r\n            }\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        // load balances to save gas\r\n        uint256 fromBalance = balanceOf[from];\r\n        uint256 toBalance = balanceOf[to];\r\n\r\n        // call transfer hook\r\n        gate.beforePerpetualYieldTokenTransfer(\r\n            from,\r\n            to,\r\n            amount,\r\n            fromBalance,\r\n            toBalance\r\n        );\r\n\r\n        // update allowance\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max)\r\n            allowance[from][msg.sender] = allowed - amount;\r\n\r\n        // do transfer\r\n        // skip during self transfers since toBalance is cached\r\n        // which leads to free minting, a critical issue\r\n        if (from != to) {\r\n            balanceOf[from] = fromBalance - amount;\r\n\r\n            // Cannot overflow because the sum of all user\r\n            // balances can't exceed the max uint256 value.\r\n            unchecked {\r\n                balanceOf[to] = toBalance + amount;\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract Factory is BoringOwnable {\r\n    /// -----------------------------------------------------------------------\r\n    /// Library usage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    using Bytes32AddressLib for address;\r\n    using Bytes32AddressLib for bytes32;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Errors\r\n    /// -----------------------------------------------------------------------\r\n\r\n    error Error_ProtocolFeeRecipientIsZero();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Events\r\n    /// -----------------------------------------------------------------------\r\n\r\n    event SetProtocolFee(ProtocolFeeInfo protocolFeeInfo_);\r\n    event DeployYieldTokenPair(\r\n        Gate indexed gate,\r\n        address indexed vault,\r\n        NegativeYieldToken nyt,\r\n        PerpetualYieldToken pyt\r\n    );\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Storage variables\r\n    /// -----------------------------------------------------------------------\r\n\r\n    struct ProtocolFeeInfo {\r\n        uint8 fee; // each increment represents 0.1%, so max is 25.5%\r\n        address recipient;\r\n    }\r\n    /// @notice The protocol fee and the fee recipient address.\r\n    ProtocolFeeInfo public protocolFeeInfo;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Constructor\r\n    /// -----------------------------------------------------------------------\r\n\r\n    constructor(ProtocolFeeInfo memory protocolFeeInfo_) {\r\n        if (\r\n            protocolFeeInfo_.fee != 0 &&\r\n            protocolFeeInfo_.recipient == address(0)\r\n        ) {\r\n            revert Error_ProtocolFeeRecipientIsZero();\r\n        }\r\n        protocolFeeInfo = protocolFeeInfo_;\r\n        emit SetProtocolFee(protocolFeeInfo_);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// User actions\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Deploys the NegativeYieldToken and PerpetualYieldToken associated with a vault.\r\n    /// @dev Will revert if they have already been deployed.\r\n    /// @param gate The gate that will use the NYT and PYT\r\n    /// @param vault The vault to deploy NYT and PYT for\r\n    /// @return nyt The deployed NegativeYieldToken\r\n    /// @return pyt The deployed PerpetualYieldToken\r\n    function deployYieldTokenPair(Gate gate, address vault)\r\n        public\r\n        virtual\r\n        returns (NegativeYieldToken nyt, PerpetualYieldToken pyt)\r\n    {\r\n        // Use the CREATE2 opcode to deploy new NegativeYieldToken and PerpetualYieldToken contracts.\r\n        // This will revert if the contracts have already been deployed,\r\n        // as the salt & bytecode hash would be the same and we can't deploy with it twice.\r\n        nyt = new NegativeYieldToken{salt: bytes32(0)}(gate, vault);\r\n        pyt = new PerpetualYieldToken{salt: bytes32(0)}(gate, vault);\r\n\r\n        emit DeployYieldTokenPair(gate, vault, nyt, pyt);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Getters\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Returns the NegativeYieldToken associated with a gate & vault pair.\r\n    /// @dev Returns non-zero value even if the contract hasn't been deployed yet.\r\n    /// @param gate The gate to query\r\n    /// @param vault The vault to query\r\n    /// @return The NegativeYieldToken address\r\n    function getNegativeYieldToken(Gate gate, address vault)\r\n        public\r\n        view\r\n        virtual\r\n        returns (NegativeYieldToken)\r\n    {\r\n        return\r\n            NegativeYieldToken(_computeYieldTokenAddress(gate, vault, false));\r\n    }\r\n\r\n    /// @notice Returns the PerpetualYieldToken associated with a gate & vault pair.\r\n    /// @dev Returns non-zero value even if the contract hasn't been deployed yet.\r\n    /// @param gate The gate to query\r\n    /// @param vault The vault to query\r\n    /// @return The PerpetualYieldToken address\r\n    function getPerpetualYieldToken(Gate gate, address vault)\r\n        public\r\n        view\r\n        virtual\r\n        returns (PerpetualYieldToken)\r\n    {\r\n        return\r\n            PerpetualYieldToken(_computeYieldTokenAddress(gate, vault, true));\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Owner functions\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Updates the protocol fee and/or the protocol fee recipient.\r\n    /// Only callable by the owner.\r\n    /// @param protocolFeeInfo_ The new protocol fee info\r\n    function ownerSetProtocolFee(ProtocolFeeInfo calldata protocolFeeInfo_)\r\n        external\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        if (\r\n            protocolFeeInfo_.fee != 0 &&\r\n            protocolFeeInfo_.recipient == address(0)\r\n        ) {\r\n            revert Error_ProtocolFeeRecipientIsZero();\r\n        }\r\n        protocolFeeInfo = protocolFeeInfo_;\r\n\r\n        emit SetProtocolFee(protocolFeeInfo_);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Internal utilities\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev Computes the address of PYTs and NYTs using CREATE2.\r\n    function _computeYieldTokenAddress(\r\n        Gate gate,\r\n        address vault,\r\n        bool isPerpetualYieldToken\r\n    ) internal view virtual returns (address) {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    // Prefix:\r\n                    bytes1(0xFF),\r\n                    // Creator:\r\n                    address(this),\r\n                    // Salt:\r\n                    bytes32(0),\r\n                    // Bytecode hash:\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            // Deployment bytecode:\r\n                            isPerpetualYieldToken\r\n                                ? type(PerpetualYieldToken).creationCode\r\n                                : type(NegativeYieldToken).creationCode,\r\n                            // Constructor arguments:\r\n                            abi.encode(gate, vault)\r\n                        )\r\n                    )\r\n                )\r\n            ).fromLast20Bytes(); // Convert the CREATE2 hash into an address.\r\n    }\r\n}\r\n\r\nabstract contract IxPYT is ERC4626 {\r\n    function sweep(address receiver) external virtual returns (uint256 shares);\r\n}\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = a * b\r\n            // Compute the product mod 2**256 and mod 2**256 - 1\r\n            // then use the Chinese Remainder Theorem to reconstruct\r\n            // the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2**256 + prod0\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(a, b, not(0))\r\n                prod0 := mul(a, b)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division\r\n            if (prod1 == 0) {\r\n                require(denominator > 0);\r\n                assembly {\r\n                    result := div(prod0, denominator)\r\n                }\r\n                return result;\r\n            }\r\n\r\n            // Make sure the result is less than 2**256.\r\n            // Also prevents denominator == 0\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0]\r\n            // Compute remainder using mulmod\r\n            uint256 remainder;\r\n            assembly {\r\n                remainder := mulmod(a, b, denominator)\r\n            }\r\n            // Subtract 256 bit number from 512 bit number\r\n            assembly {\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator\r\n            // Compute largest power of two divisor of denominator.\r\n            // Always >= 1.\r\n            uint256 twos = (0 - denominator) & denominator;\r\n            // Divide denominator by power of two\r\n            assembly {\r\n                denominator := div(denominator, twos)\r\n            }\r\n\r\n            // Divide [prod1 prod0] by the factors of two\r\n            assembly {\r\n                prod0 := div(prod0, twos)\r\n            }\r\n            // Shift in bits from prod1 into prod0. For this we need\r\n            // to flip `twos` such that it is 2**256 / twos.\r\n            // If twos is zero, then it becomes one\r\n            assembly {\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2**256\r\n            // Now that denominator is an odd number, it has an inverse\r\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n            // Compute the inverse by starting with a seed that is correct\r\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n            uint256 inv = (3 * denominator) ^ 2;\r\n            // Now use Newton-Raphson iteration to improve the precision.\r\n            // Thanks to Hensel's lifting lemma, this also works in modular\r\n            // arithmetic, doubling the correct bits in each step.\r\n            inv *= 2 - denominator * inv; // inverse mod 2**8\r\n            inv *= 2 - denominator * inv; // inverse mod 2**16\r\n            inv *= 2 - denominator * inv; // inverse mod 2**32\r\n            inv *= 2 - denominator * inv; // inverse mod 2**64\r\n            inv *= 2 - denominator * inv; // inverse mod 2**128\r\n            inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n            // Because the division is now exact we can divide by multiplying\r\n            // with the modular inverse of denominator. This will give us the\r\n            // correct result modulo 2**256. Since the precoditions guarantee\r\n            // that the outcome is less than 2**256, this is the final result.\r\n            // We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inv;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            result = mulDiv(a, b, denominator);\r\n            if (mulmod(a, b, denominator) > 0) {\r\n                require(result < type(uint256).max);\r\n                result++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Multicall\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\nabstract contract Multicall {\r\n    function multicall(bytes[] calldata data)\r\n        external\r\n        payable\r\n        returns (bytes[] memory results)\r\n    {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(\r\n                data[i]\r\n            );\r\n\r\n            if (!success) {\r\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\r\n                if (result.length < 68) revert();\r\n                assembly {\r\n                    result := add(result, 0x04)\r\n                }\r\n                revert(abi.decode(result, (string)));\r\n            }\r\n\r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Self Permit\r\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\r\n/// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function\r\n/// that requires an approval in a single transaction.\r\nabstract contract SelfPermit {\r\n    function selfPermit(\r\n        ERC20 token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public payable {\r\n        token.permit(msg.sender, address(this), value, deadline, v, r, s);\r\n    }\r\n\r\n    function selfPermitIfNecessary(\r\n        ERC20 token,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable {\r\n        if (token.allowance(msg.sender, address(this)) < value)\r\n            selfPermit(token, value, deadline, v, r, s);\r\n    }\r\n}\r\n\r\n/// @title Gate\r\n/// @author zefram.eth\r\n/// @notice Gate is the main contract users interact with to mint/burn NegativeYieldToken\r\n/// and PerpetualYieldToken, as well as claim the yield earned by PYTs.\r\n/// @dev Gate is an abstract contract that should be inherited from in order to support\r\n/// a specific vault protocol (e.g. YearnGate supports YearnVault). Each Gate handles\r\n/// all vaults & associated NYTs/PYTs of a specific vault protocol.\r\n///\r\n/// Vaults are yield-generating contracts used by Gate. Gate makes several assumptions about\r\n/// a vault:\r\n/// 1) A vault has a single associated underlying token that is immutable.\r\n/// 2) A vault gives depositors yield denominated in the underlying token.\r\n/// 3) A vault depositor owns shares in the vault, which represents their deposit.\r\n/// 4) Vaults have a notion of \"price per share\", which is the amount of underlying tokens\r\n///    each vault share can be redeemed for.\r\n/// 5) If vault shares are represented using an ERC20 token, then the ERC20 token contract must be\r\n///    the vault contract itself.\r\nabstract contract Gate is\r\n    ReentrancyGuard,\r\n    Multicall,\r\n    SelfPermit,\r\n    BoringOwnable\r\n{\r\n    /// -----------------------------------------------------------------------\r\n    /// Library usage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    using SafeTransferLib for ERC20;\r\n    using SafeTransferLib for ERC4626;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Errors\r\n    /// -----------------------------------------------------------------------\r\n\r\n    error Error_InvalidInput();\r\n    error Error_VaultSharesNotERC20();\r\n    error Error_TokenPairNotDeployed();\r\n    error Error_EmergencyExitNotActivated();\r\n    error Error_SenderNotPerpetualYieldToken();\r\n    error Error_EmergencyExitAlreadyActivated();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Events\r\n    /// -----------------------------------------------------------------------\r\n\r\n    event EnterWithUnderlying(\r\n        address sender,\r\n        address indexed nytRecipient,\r\n        address indexed pytRecipient,\r\n        address indexed vault,\r\n        IxPYT xPYT,\r\n        uint256 underlyingAmount\r\n    );\r\n    event EnterWithVaultShares(\r\n        address sender,\r\n        address indexed nytRecipient,\r\n        address indexed pytRecipient,\r\n        address indexed vault,\r\n        IxPYT xPYT,\r\n        uint256 vaultSharesAmount\r\n    );\r\n    event ExitToUnderlying(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        address indexed vault,\r\n        IxPYT xPYT,\r\n        uint256 underlyingAmount\r\n    );\r\n    event ExitToVaultShares(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        address indexed vault,\r\n        IxPYT xPYT,\r\n        uint256 vaultSharesAmount\r\n    );\r\n    event ClaimYieldInUnderlying(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        address indexed vault,\r\n        uint256 underlyingAmount\r\n    );\r\n    event ClaimYieldInVaultShares(\r\n        address indexed sender,\r\n        address indexed recipient,\r\n        address indexed vault,\r\n        uint256 vaultSharesAmount\r\n    );\r\n    event ClaimYieldAndEnter(\r\n        address sender,\r\n        address indexed nytRecipient,\r\n        address indexed pytRecipient,\r\n        address indexed vault,\r\n        IxPYT xPYT,\r\n        uint256 amount\r\n    );\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Structs\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @param activated True if emergency exit has been activated, false if not\r\n    /// @param pytPriceInUnderlying The amount of underlying assets each PYT can redeem for.\r\n    /// Should be a value in the range [0, PRECISION]\r\n    struct EmergencyExitStatus {\r\n        bool activated;\r\n        uint96 pytPriceInUnderlying;\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Constants\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice The decimals of precision used by yieldPerTokenStored and pricePerVaultShareStored\r\n    uint256 internal constant PRECISION_DECIMALS = 27;\r\n\r\n    /// @notice The precision used by yieldPerTokenStored and pricePerVaultShareStored\r\n    uint256 internal constant PRECISION = 10**PRECISION_DECIMALS;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Immutable parameters\r\n    /// -----------------------------------------------------------------------\r\n\r\n    Factory public immutable factory;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Storage variables\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice The amount of underlying tokens each vault share is worth, at the time of the last update.\r\n    /// Uses PRECISION.\r\n    /// @dev vault => value\r\n    mapping(address => uint256) public pricePerVaultShareStored;\r\n\r\n    /// @notice The amount of yield each PYT has accrued, at the time of the last update.\r\n    /// Scaled by PRECISION.\r\n    /// @dev vault => value\r\n    mapping(address => uint256) public yieldPerTokenStored;\r\n\r\n    /// @notice The amount of yield each PYT has accrued, at the time when a user has last interacted\r\n    /// with the gate/PYT. Shifted by 1, so e.g. 3 represents 2, 10 represents 9.\r\n    /// @dev vault => user => value\r\n    /// The value is shifted to use 0 for representing uninitialized users.\r\n    mapping(address => mapping(address => uint256))\r\n        public userYieldPerTokenStored;\r\n\r\n    /// @notice The amount of yield a user has accrued, at the time when they last interacted\r\n    /// with the gate/PYT (without calling claimYieldInUnderlying()).\r\n    /// Shifted by 1, so e.g. 3 represents 2, 10 represents 9.\r\n    /// @dev vault => user => value\r\n    mapping(address => mapping(address => uint256)) public userAccruedYield;\r\n\r\n    /// @notice Stores info relevant to emergency exits of a vault.\r\n    /// @dev vault => value\r\n    mapping(address => EmergencyExitStatus) public emergencyExitStatusOfVault;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Initialization\r\n    /// -----------------------------------------------------------------------\r\n\r\n    constructor(Factory factory_) {\r\n        factory = factory_;\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// User actions\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Converts underlying tokens into NegativeYieldToken and PerpetualYieldToken.\r\n    /// The amount of NYT and PYT minted will be equal to the underlying token amount.\r\n    /// @dev The underlying tokens will be immediately deposited into the specified vault.\r\n    /// If the NYT and PYT for the specified vault haven't been deployed yet, this call will\r\n    /// deploy them before proceeding, which will increase the gas cost significantly.\r\n    /// @param nytRecipient The recipient of the minted NYT\r\n    /// @param pytRecipient The recipient of the minted PYT\r\n    /// @param vault The vault to mint NYT and PYT for\r\n    /// @param xPYT The xPYT contract to deposit the minted PYT into. Set to 0 to receive raw PYT instead.\r\n    /// @param underlyingAmount The amount of underlying tokens to use\r\n    /// @return mintAmount The amount of NYT and PYT minted (the amounts are equal)\r\n    function enterWithUnderlying(\r\n        address nytRecipient,\r\n        address pytRecipient,\r\n        address vault,\r\n        IxPYT xPYT,\r\n        uint256 underlyingAmount\r\n    ) external virtual nonReentrant returns (uint256 mintAmount) {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        if (underlyingAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates & effects\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // mint PYT and NYT\r\n        mintAmount = underlyingAmount;\r\n        _enter(\r\n            nytRecipient,\r\n            pytRecipient,\r\n            vault,\r\n            xPYT,\r\n            underlyingAmount,\r\n            getPricePerVaultShare(vault)\r\n        );\r\n\r\n        // transfer underlying from msg.sender to address(this)\r\n        ERC20 underlying = getUnderlyingOfVault(vault);\r\n        underlying.safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            underlyingAmount\r\n        );\r\n\r\n        // deposit underlying into vault\r\n        _depositIntoVault(underlying, underlyingAmount, vault);\r\n\r\n        emit EnterWithUnderlying(\r\n            msg.sender,\r\n            nytRecipient,\r\n            pytRecipient,\r\n            vault,\r\n            xPYT,\r\n            underlyingAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Converts vault share tokens into NegativeYieldToken and PerpetualYieldToken.\r\n    /// @dev Only available if vault shares are transferrable ERC20 tokens.\r\n    /// If the NYT and PYT for the specified vault haven't been deployed yet, this call will\r\n    /// deploy them before proceeding, which will increase the gas cost significantly.\r\n    /// @param nytRecipient The recipient of the minted NYT\r\n    /// @param pytRecipient The recipient of the minted PYT\r\n    /// @param vault The vault to mint NYT and PYT for\r\n    /// @param xPYT The xPYT contract to deposit the minted PYT into. Set to 0 to receive raw PYT instead.\r\n    /// @param vaultSharesAmount The amount of vault share tokens to use\r\n    /// @return mintAmount The amount of NYT and PYT minted (the amounts are equal)\r\n    function enterWithVaultShares(\r\n        address nytRecipient,\r\n        address pytRecipient,\r\n        address vault,\r\n        IxPYT xPYT,\r\n        uint256 vaultSharesAmount\r\n    ) external virtual nonReentrant returns (uint256 mintAmount) {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        if (vaultSharesAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // only supported if vault shares are ERC20\r\n        if (!vaultSharesIsERC20()) {\r\n            revert Error_VaultSharesNotERC20();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates & effects\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // mint PYT and NYT\r\n        uint256 updatedPricePerVaultShare = getPricePerVaultShare(vault);\r\n        mintAmount = _vaultSharesAmountToUnderlyingAmount(\r\n            vault,\r\n            vaultSharesAmount,\r\n            updatedPricePerVaultShare\r\n        );\r\n        _enter(\r\n            nytRecipient,\r\n            pytRecipient,\r\n            vault,\r\n            xPYT,\r\n            mintAmount,\r\n            updatedPricePerVaultShare\r\n        );\r\n\r\n        // transfer vault tokens from msg.sender to address(this)\r\n        ERC20(vault).safeTransferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            vaultSharesAmount\r\n        );\r\n\r\n        emit EnterWithVaultShares(\r\n            msg.sender,\r\n            nytRecipient,\r\n            pytRecipient,\r\n            vault,\r\n            xPYT,\r\n            vaultSharesAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Converts NegativeYieldToken and PerpetualYieldToken to underlying tokens.\r\n    /// The amount of NYT and PYT burned will be equal to the underlying token amount.\r\n    /// @dev The underlying tokens will be immediately withdrawn from the specified vault.\r\n    /// If the NYT and PYT for the specified vault haven't been deployed yet, this call will\r\n    /// revert.\r\n    /// @param recipient The recipient of the minted NYT and PYT\r\n    /// @param vault The vault to mint NYT and PYT for\r\n    /// @param xPYT The xPYT contract to use for burning PYT. Set to 0 to burn raw PYT instead.\r\n    /// @param underlyingAmount The amount of underlying tokens requested\r\n    /// @return burnAmount The amount of NYT and PYT burned (the amounts are equal)\r\n    function exitToUnderlying(\r\n        address recipient,\r\n        address vault,\r\n        IxPYT xPYT,\r\n        uint256 underlyingAmount\r\n    ) external virtual nonReentrant returns (uint256 burnAmount) {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        if (underlyingAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates & effects\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // burn PYT and NYT\r\n        uint256 updatedPricePerVaultShare = getPricePerVaultShare(vault);\r\n        burnAmount = underlyingAmount;\r\n        _exit(vault, xPYT, underlyingAmount, updatedPricePerVaultShare);\r\n\r\n        // withdraw underlying from vault to recipient\r\n        // don't check balance since user can just withdraw slightly less\r\n        // saves gas this way\r\n        underlyingAmount = _withdrawFromVault(\r\n            recipient,\r\n            vault,\r\n            underlyingAmount,\r\n            updatedPricePerVaultShare,\r\n            false\r\n        );\r\n\r\n        emit ExitToUnderlying(\r\n            msg.sender,\r\n            recipient,\r\n            vault,\r\n            xPYT,\r\n            underlyingAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Converts NegativeYieldToken and PerpetualYieldToken to vault share tokens.\r\n    /// The amount of NYT and PYT burned will be equal to the underlying token amount.\r\n    /// @dev Only available if vault shares are transferrable ERC20 tokens.\r\n    /// If the NYT and PYT for the specified vault haven't been deployed yet, this call will\r\n    /// revert.\r\n    /// @param recipient The recipient of the minted NYT and PYT\r\n    /// @param vault The vault to mint NYT and PYT for\r\n    /// @param xPYT The xPYT contract to use for burning PYT. Set to 0 to burn raw PYT instead.\r\n    /// @param vaultSharesAmount The amount of vault share tokens requested\r\n    /// @return burnAmount The amount of NYT and PYT burned (the amounts are equal)\r\n    function exitToVaultShares(\r\n        address recipient,\r\n        address vault,\r\n        IxPYT xPYT,\r\n        uint256 vaultSharesAmount\r\n    ) external virtual nonReentrant returns (uint256 burnAmount) {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        if (vaultSharesAmount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // only supported if vault shares are ERC20\r\n        if (!vaultSharesIsERC20()) {\r\n            revert Error_VaultSharesNotERC20();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates & effects\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // burn PYT and NYT\r\n        uint256 updatedPricePerVaultShare = getPricePerVaultShare(vault);\r\n        burnAmount = _vaultSharesAmountToUnderlyingAmountRoundingUp(\r\n            vault,\r\n            vaultSharesAmount,\r\n            updatedPricePerVaultShare\r\n        );\r\n        _exit(vault, xPYT, burnAmount, updatedPricePerVaultShare);\r\n\r\n        // transfer vault tokens to recipient\r\n        ERC20(vault).safeTransfer(recipient, vaultSharesAmount);\r\n\r\n        emit ExitToVaultShares(\r\n            msg.sender,\r\n            recipient,\r\n            vault,\r\n            xPYT,\r\n            vaultSharesAmount\r\n        );\r\n    }\r\n\r\n    /// @notice Claims the yield earned by the PerpetualYieldToken balance of msg.sender, in the underlying token.\r\n    /// @dev If the NYT and PYT for the specified vault haven't been deployed yet, this call will\r\n    /// revert.\r\n    /// @param recipient The recipient of the yield\r\n    /// @param vault The vault to claim yield from\r\n    /// @return yieldAmount The amount of yield claimed, in underlying tokens\r\n    function claimYieldInUnderlying(address recipient, address vault)\r\n        external\r\n        virtual\r\n        nonReentrant\r\n        returns (uint256 yieldAmount)\r\n    {\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // update storage variables and compute yield amount\r\n        uint256 updatedPricePerVaultShare = getPricePerVaultShare(vault);\r\n        yieldAmount = _claimYield(vault, updatedPricePerVaultShare);\r\n\r\n        // withdraw yield\r\n        if (yieldAmount != 0) {\r\n            /// -----------------------------------------------------------------------\r\n            /// Effects\r\n            /// -----------------------------------------------------------------------\r\n\r\n            (uint8 fee, address protocolFeeRecipient) = factory\r\n                .protocolFeeInfo();\r\n\r\n            if (fee != 0) {\r\n                uint256 protocolFee = (yieldAmount * fee) / 1000;\r\n                unchecked {\r\n                    // can't underflow since fee < 256\r\n                    yieldAmount -= protocolFee;\r\n                }\r\n\r\n                if (vaultSharesIsERC20()) {\r\n                    // vault shares are in ERC20\r\n                    // do share transfer\r\n                    protocolFee = _underlyingAmountToVaultSharesAmount(\r\n                        vault,\r\n                        protocolFee,\r\n                        updatedPricePerVaultShare\r\n                    );\r\n                    uint256 vaultSharesBalance = ERC20(vault).balanceOf(\r\n                        address(this)\r\n                    );\r\n                    if (protocolFee > vaultSharesBalance) {\r\n                        protocolFee = vaultSharesBalance;\r\n                    }\r\n                    if (protocolFee != 0) {\r\n                        ERC20(vault).safeTransfer(\r\n                            protocolFeeRecipient,\r\n                            protocolFee\r\n                        );\r\n                    }\r\n                } else {\r\n                    // vault shares are not in ERC20\r\n                    // withdraw underlying from vault\r\n                    // checkBalance is set to true to prevent getting stuck\r\n                    // due to rounding errors\r\n                    if (protocolFee != 0) {\r\n                        _withdrawFromVault(\r\n                            protocolFeeRecipient,\r\n                            vault,\r\n                            protocolFee,\r\n                            updatedPricePerVaultShare,\r\n                            true\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            // withdraw underlying to recipient\r\n            // checkBalance is set to true to prevent getting stuck\r\n            // due to rounding errors\r\n            yieldAmount = _withdrawFromVault(\r\n                recipient,\r\n                vault,\r\n                yieldAmount,\r\n                updatedPricePerVaultShare,\r\n                true\r\n            );\r\n\r\n            emit ClaimYieldInUnderlying(\r\n                msg.sender,\r\n                recipient,\r\n                vault,\r\n                yieldAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Claims the yield earned by the PerpetualYieldToken balance of msg.sender, in vault shares.\r\n    /// @dev Only available if vault shares are transferrable ERC20 tokens.\r\n    /// If the NYT and PYT for the specified vault haven't been deployed yet, this call will\r\n    /// revert.\r\n    /// @param recipient The recipient of the yield\r\n    /// @param vault The vault to claim yield from\r\n    /// @return yieldAmount The amount of yield claimed, in vault shares\r\n    function claimYieldInVaultShares(address recipient, address vault)\r\n        external\r\n        virtual\r\n        nonReentrant\r\n        returns (uint256 yieldAmount)\r\n    {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // only supported if vault shares are ERC20\r\n        if (!vaultSharesIsERC20()) {\r\n            revert Error_VaultSharesNotERC20();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // update storage variables and compute yield amount\r\n        uint256 updatedPricePerVaultShare = getPricePerVaultShare(vault);\r\n        yieldAmount = _claimYield(vault, updatedPricePerVaultShare);\r\n\r\n        // withdraw yield\r\n        if (yieldAmount != 0) {\r\n            /// -----------------------------------------------------------------------\r\n            /// Effects\r\n            /// -----------------------------------------------------------------------\r\n\r\n            // convert yieldAmount to be denominated in vault shares\r\n            yieldAmount = _underlyingAmountToVaultSharesAmount(\r\n                vault,\r\n                yieldAmount,\r\n                updatedPricePerVaultShare\r\n            );\r\n\r\n            (uint8 fee, address protocolFeeRecipient) = factory\r\n                .protocolFeeInfo();\r\n            uint256 vaultSharesBalance = getVaultShareBalance(vault);\r\n            if (fee != 0) {\r\n                uint256 protocolFee = (yieldAmount * fee) / 1000;\r\n                protocolFee = protocolFee > vaultSharesBalance\r\n                    ? vaultSharesBalance\r\n                    : protocolFee;\r\n                unchecked {\r\n                    // can't underflow since fee < 256\r\n                    yieldAmount -= protocolFee;\r\n                }\r\n\r\n                if (protocolFee > 0) {\r\n                    ERC20(vault).safeTransfer(\r\n                        protocolFeeRecipient,\r\n                        protocolFee\r\n                    );\r\n\r\n                    vaultSharesBalance -= protocolFee;\r\n                }\r\n            }\r\n\r\n            // transfer vault shares to recipient\r\n            // check if vault shares is enough to prevent getting stuck\r\n            // from rounding errors\r\n            yieldAmount = yieldAmount > vaultSharesBalance\r\n                ? vaultSharesBalance\r\n                : yieldAmount;\r\n            if (yieldAmount > 0) {\r\n                ERC20(vault).safeTransfer(recipient, yieldAmount);\r\n            }\r\n\r\n            emit ClaimYieldInVaultShares(\r\n                msg.sender,\r\n                recipient,\r\n                vault,\r\n                yieldAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @notice Claims the yield earned by the PerpetualYieldToken balance of msg.sender, and immediately\r\n    /// use the yield to mint NYT and PYT.\r\n    /// @dev Introduced to save gas for xPYT compounding, since it avoids vault withdraws/transfers.\r\n    /// If the NYT and PYT for the specified vault haven't been deployed yet, this call will\r\n    /// revert.\r\n    /// @param nytRecipient The recipient of the minted NYT\r\n    /// @param pytRecipient The recipient of the minted PYT\r\n    /// @param vault The vault to claim yield from\r\n    /// @param xPYT The xPYT contract to deposit the minted PYT into. Set to 0 to receive raw PYT instead.\r\n    /// @return yieldAmount The amount of yield claimed, in underlying tokens\r\n    function claimYieldAndEnter(\r\n        address nytRecipient,\r\n        address pytRecipient,\r\n        address vault,\r\n        IxPYT xPYT\r\n    ) external virtual nonReentrant returns (uint256 yieldAmount) {\r\n        // update storage variables and compute yield amount\r\n        uint256 updatedPricePerVaultShare = getPricePerVaultShare(vault);\r\n        yieldAmount = _claimYield(vault, updatedPricePerVaultShare);\r\n\r\n        // use yield to mint NYT and PYT\r\n        if (yieldAmount != 0) {\r\n            (uint8 fee, address protocolFeeRecipient) = factory\r\n                .protocolFeeInfo();\r\n\r\n            if (fee != 0) {\r\n                uint256 protocolFee = (yieldAmount * fee) / 1000;\r\n                unchecked {\r\n                    // can't underflow since fee < 256\r\n                    yieldAmount -= protocolFee;\r\n                }\r\n\r\n                if (vaultSharesIsERC20()) {\r\n                    // vault shares are in ERC20\r\n                    // do share transfer\r\n                    protocolFee = _underlyingAmountToVaultSharesAmount(\r\n                        vault,\r\n                        protocolFee,\r\n                        updatedPricePerVaultShare\r\n                    );\r\n                    uint256 vaultSharesBalance = ERC20(vault).balanceOf(\r\n                        address(this)\r\n                    );\r\n                    if (protocolFee > vaultSharesBalance) {\r\n                        protocolFee = vaultSharesBalance;\r\n                    }\r\n                    if (protocolFee != 0) {\r\n                        ERC20(vault).safeTransfer(\r\n                            protocolFeeRecipient,\r\n                            protocolFee\r\n                        );\r\n                    }\r\n                } else {\r\n                    // vault shares are not in ERC20\r\n                    // withdraw underlying from vault\r\n                    // checkBalance is set to true to prevent getting stuck\r\n                    // due to rounding errors\r\n                    if (protocolFee != 0) {\r\n                        _withdrawFromVault(\r\n                            protocolFeeRecipient,\r\n                            vault,\r\n                            protocolFee,\r\n                            updatedPricePerVaultShare,\r\n                            true\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            NegativeYieldToken nyt = getNegativeYieldTokenForVault(vault);\r\n            PerpetualYieldToken pyt = getPerpetualYieldTokenForVault(vault);\r\n\r\n            if (address(xPYT) == address(0)) {\r\n                // accrue yield to pytRecipient if they're not msg.sender\r\n                // no need to do it if the recipient is msg.sender, since\r\n                // we already accrued yield in _claimYield\r\n                if (pytRecipient != msg.sender) {\r\n                    _accrueYield(\r\n                        vault,\r\n                        pyt,\r\n                        pytRecipient,\r\n                        updatedPricePerVaultShare\r\n                    );\r\n                }\r\n            } else {\r\n                // accrue yield to xPYT contract since it gets minted PYT\r\n                _accrueYield(\r\n                    vault,\r\n                    pyt,\r\n                    address(xPYT),\r\n                    updatedPricePerVaultShare\r\n                );\r\n            }\r\n\r\n            // mint NYTs and PYTs\r\n            nyt.gateMint(nytRecipient, yieldAmount);\r\n            if (address(xPYT) == address(0)) {\r\n                // mint raw PYT to recipient\r\n                pyt.gateMint(pytRecipient, yieldAmount);\r\n            } else {\r\n                // mint PYT to xPYT contract\r\n                pyt.gateMint(address(xPYT), yieldAmount);\r\n\r\n                /// -----------------------------------------------------------------------\r\n                /// Effects\r\n                /// -----------------------------------------------------------------------\r\n\r\n                // call sweep to mint xPYT using the PYT\r\n                xPYT.sweep(pytRecipient);\r\n            }\r\n\r\n            emit ClaimYieldAndEnter(\r\n                msg.sender,\r\n                nytRecipient,\r\n                pytRecipient,\r\n                vault,\r\n                xPYT,\r\n                yieldAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Getters\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Returns the NegativeYieldToken associated with a vault.\r\n    /// @dev Returns non-zero value even if the contract hasn't been deployed yet.\r\n    /// @param vault The vault to query\r\n    /// @return The NegativeYieldToken address\r\n    function getNegativeYieldTokenForVault(address vault)\r\n        public\r\n        view\r\n        virtual\r\n        returns (NegativeYieldToken)\r\n    {\r\n        return factory.getNegativeYieldToken(this, vault);\r\n    }\r\n\r\n    /// @notice Returns the PerpetualYieldToken associated with a vault.\r\n    /// @dev Returns non-zero value even if the contract hasn't been deployed yet.\r\n    /// @param vault The vault to query\r\n    /// @return The PerpetualYieldToken address\r\n    function getPerpetualYieldTokenForVault(address vault)\r\n        public\r\n        view\r\n        virtual\r\n        returns (PerpetualYieldToken)\r\n    {\r\n        return factory.getPerpetualYieldToken(this, vault);\r\n    }\r\n\r\n    /// @notice Returns the amount of yield claimable by a PerpetualYieldToken holder from a vault.\r\n    /// Accounts for protocol fees.\r\n    /// @param vault The vault to query\r\n    /// @param user The PYT holder to query\r\n    /// @return yieldAmount The amount of yield claimable\r\n    function getClaimableYieldAmount(address vault, address user)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 yieldAmount)\r\n    {\r\n        PerpetualYieldToken pyt = getPerpetualYieldTokenForVault(vault);\r\n        uint256 userYieldPerTokenStored_ = userYieldPerTokenStored[vault][user];\r\n        if (userYieldPerTokenStored_ == 0) {\r\n            // uninitialized account\r\n            return 0;\r\n        }\r\n        yieldAmount = _getClaimableYieldAmount(\r\n            vault,\r\n            user,\r\n            _computeYieldPerToken(vault, pyt, getPricePerVaultShare(vault)),\r\n            userYieldPerTokenStored_,\r\n            pyt.balanceOf(user)\r\n        );\r\n        (uint8 fee, ) = factory.protocolFeeInfo();\r\n        if (fee != 0) {\r\n            uint256 protocolFee = (yieldAmount * fee) / 1000;\r\n            unchecked {\r\n                // can't underflow since fee < 256\r\n                yieldAmount -= protocolFee;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Computes the latest yieldPerToken value for a vault.\r\n    /// @param vault The vault to query\r\n    /// @return The latest yieldPerToken value\r\n    function computeYieldPerToken(address vault)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _computeYieldPerToken(\r\n                vault,\r\n                getPerpetualYieldTokenForVault(vault),\r\n                getPricePerVaultShare(vault)\r\n            );\r\n    }\r\n\r\n    /// @notice Returns the underlying token of a vault.\r\n    /// @param vault The vault to query\r\n    /// @return The underlying token\r\n    function getUnderlyingOfVault(address vault)\r\n        public\r\n        view\r\n        virtual\r\n        returns (ERC20);\r\n\r\n    /// @notice Returns the amount of underlying tokens each share of a vault is worth.\r\n    /// @param vault The vault to query\r\n    /// @return The pricePerVaultShare value\r\n    function getPricePerVaultShare(address vault)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256);\r\n\r\n    /// @notice Returns the amount of vault shares owned by the gate.\r\n    /// @param vault The vault to query\r\n    /// @return The gate's vault share balance\r\n    function getVaultShareBalance(address vault)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256);\r\n\r\n    /// @return True if the vaults supported by this gate use transferrable ERC20 tokens\r\n    /// to represent shares, false otherwise.\r\n    function vaultSharesIsERC20() public pure virtual returns (bool);\r\n\r\n    /// @notice Computes the ERC20 name of the NegativeYieldToken of a vault.\r\n    /// @param vault The vault to query\r\n    /// @return The ERC20 name\r\n    function negativeYieldTokenName(address vault)\r\n        external\r\n        view\r\n        virtual\r\n        returns (string memory);\r\n\r\n    /// @notice Computes the ERC20 symbol of the NegativeYieldToken of a vault.\r\n    /// @param vault The vault to query\r\n    /// @return The ERC20 symbol\r\n    function negativeYieldTokenSymbol(address vault)\r\n        external\r\n        view\r\n        virtual\r\n        returns (string memory);\r\n\r\n    /// @notice Computes the ERC20 name of the PerpetualYieldToken of a vault.\r\n    /// @param vault The vault to query\r\n    /// @return The ERC20 name\r\n    function perpetualYieldTokenName(address vault)\r\n        external\r\n        view\r\n        virtual\r\n        returns (string memory);\r\n\r\n    /// @notice Computes the ERC20 symbol of the NegativeYieldToken of a vault.\r\n    /// @param vault The vault to query\r\n    /// @return The ERC20 symbol\r\n    function perpetualYieldTokenSymbol(address vault)\r\n        external\r\n        view\r\n        virtual\r\n        returns (string memory);\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// PYT transfer hook\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice SHOULD NOT BE CALLED BY USERS, ONLY CALLED BY PERPETUAL YIELD TOKEN CONTRACTS\r\n    /// @dev Called by PYT contracts deployed by this gate before each token transfer, in order to\r\n    /// accrue the yield earned by the from & to accounts\r\n    /// @param from The token transfer from account\r\n    /// @param to The token transfer to account\r\n    /// @param fromBalance The token balance of the from account before the transfer\r\n    /// @param toBalance The token balance of the to account before the transfer\r\n    function beforePerpetualYieldTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 fromBalance,\r\n        uint256 toBalance\r\n    ) external virtual {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        address vault = PerpetualYieldToken(msg.sender).vault();\r\n        PerpetualYieldToken pyt = getPerpetualYieldTokenForVault(vault);\r\n        if (msg.sender != address(pyt)) {\r\n            revert Error_SenderNotPerpetualYieldToken();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // accrue yield\r\n        uint256 updatedPricePerVaultShare = getPricePerVaultShare(vault);\r\n        uint256 updatedYieldPerToken = _computeYieldPerToken(\r\n            vault,\r\n            pyt,\r\n            updatedPricePerVaultShare\r\n        );\r\n        yieldPerTokenStored[vault] = updatedYieldPerToken;\r\n        pricePerVaultShareStored[vault] = updatedPricePerVaultShare;\r\n\r\n        // we know the from account must have held PYTs before\r\n        // so we will always accrue the yield earned by the from account\r\n        userAccruedYield[vault][from] =\r\n            _getClaimableYieldAmount(\r\n                vault,\r\n                from,\r\n                updatedYieldPerToken,\r\n                userYieldPerTokenStored[vault][from],\r\n                fromBalance\r\n            ) +\r\n            1;\r\n        userYieldPerTokenStored[vault][from] = updatedYieldPerToken + 1;\r\n\r\n        // the to account might not have held PYTs before\r\n        // we only accrue yield if they have\r\n        uint256 toUserYieldPerTokenStored = userYieldPerTokenStored[vault][to];\r\n        if (toUserYieldPerTokenStored != 0) {\r\n            // to account has held PYTs before\r\n            userAccruedYield[vault][to] =\r\n                _getClaimableYieldAmount(\r\n                    vault,\r\n                    to,\r\n                    updatedYieldPerToken,\r\n                    toUserYieldPerTokenStored,\r\n                    toBalance\r\n                ) +\r\n                1;\r\n        }\r\n        userYieldPerTokenStored[vault][to] = updatedYieldPerToken + 1;\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Emergency exit\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Activates the emergency exit mode for a certain vault. Only callable by owner.\r\n    /// @dev Activating emergency exit allows PYT/NYT holders to do single-sided burns to redeem the underlying\r\n    /// collateral. This is to prevent cases where a large portion of PYT/NYT is locked up in a buggy/malicious contract\r\n    /// and locks up the underlying collateral forever.\r\n    /// @param vault The vault to activate emergency exit for\r\n    /// @param pytPriceInUnderlying The amount of underlying asset burning each PYT can redeem. Scaled by PRECISION.\r\n    function ownerActivateEmergencyExitForVault(\r\n        address vault,\r\n        uint96 pytPriceInUnderlying\r\n    ) external virtual onlyOwner {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // we only allow emergency exit to be activated once (until deactivation)\r\n        // because if pytPriceInUnderlying is ever modified after activation\r\n        // then PYT/NYT will become unbacked\r\n        if (emergencyExitStatusOfVault[vault].activated) {\r\n            revert Error_EmergencyExitAlreadyActivated();\r\n        }\r\n\r\n        // we need to ensure the PYT price value is within the range [0, PRECISION]\r\n        if (pytPriceInUnderlying > PRECISION) {\r\n            revert Error_InvalidInput();\r\n        }\r\n\r\n        // the PYT & NYT must have already been deployed\r\n        NegativeYieldToken nyt = getNegativeYieldTokenForVault(vault);\r\n        if (address(nyt).code.length == 0) {\r\n            revert Error_TokenPairNotDeployed();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        emergencyExitStatusOfVault[vault] = EmergencyExitStatus({\r\n            activated: true,\r\n            pytPriceInUnderlying: pytPriceInUnderlying\r\n        });\r\n    }\r\n\r\n    /// @notice Deactivates the emergency exit mode for a certain vault. Only callable by owner.\r\n    /// @param vault The vault to deactivate emergency exit for\r\n    function ownerDeactivateEmergencyExitForVault(address vault)\r\n        external\r\n        virtual\r\n        onlyOwner\r\n    {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // can only deactivate emergency exit when it's already activated\r\n        if (!emergencyExitStatusOfVault[vault].activated) {\r\n            revert Error_EmergencyExitNotActivated();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // reset the emergency exit status\r\n        delete emergencyExitStatusOfVault[vault];\r\n    }\r\n\r\n    /// @notice Emergency exit NYTs into the underlying asset. Only callable when emergency exit has\r\n    /// been activated for the vault.\r\n    /// @param vault The vault to exit NYT for\r\n    /// @param amount The amount of NYT to exit\r\n    /// @param recipient The recipient of the underlying asset\r\n    /// @return underlyingAmount The amount of underlying asset exited\r\n    function emergencyExitNegativeYieldToken(\r\n        address vault,\r\n        uint256 amount,\r\n        address recipient\r\n    ) external virtual returns (uint256 underlyingAmount) {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // ensure emergency exit is active\r\n        EmergencyExitStatus memory status = emergencyExitStatusOfVault[vault];\r\n        if (!status.activated) {\r\n            revert Error_EmergencyExitNotActivated();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        PerpetualYieldToken pyt = getPerpetualYieldTokenForVault(vault);\r\n        uint256 updatedPricePerVaultShare = getPricePerVaultShare(vault);\r\n\r\n        // accrue yield\r\n        _accrueYield(vault, pyt, msg.sender, updatedPricePerVaultShare);\r\n\r\n        // burn NYT from the sender\r\n        NegativeYieldToken nyt = getNegativeYieldTokenForVault(vault);\r\n        nyt.gateBurn(msg.sender, amount);\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Effects\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // compute how much of the underlying assets to give the recipient\r\n        // rounds down\r\n        underlyingAmount = FullMath.mulDiv(\r\n            amount,\r\n            PRECISION - status.pytPriceInUnderlying,\r\n            PRECISION\r\n        );\r\n\r\n        // withdraw underlying from vault to recipient\r\n        // don't check balance since user can just withdraw slightly less\r\n        // saves gas this way\r\n        underlyingAmount = _withdrawFromVault(\r\n            recipient,\r\n            vault,\r\n            underlyingAmount,\r\n            updatedPricePerVaultShare,\r\n            false\r\n        );\r\n    }\r\n\r\n    /// @notice Emergency exit PYTs into the underlying asset. Only callable when emergency exit has\r\n    /// been activated for the vault.\r\n    /// @param vault The vault to exit PYT for\r\n    /// @param xPYT The xPYT contract to use for burning PYT. Set to 0 to burn raw PYT instead.\r\n    /// @param amount The amount of PYT to exit\r\n    /// @param recipient The recipient of the underlying asset\r\n    /// @return underlyingAmount The amount of underlying asset exited\r\n    function emergencyExitPerpetualYieldToken(\r\n        address vault,\r\n        IxPYT xPYT,\r\n        uint256 amount,\r\n        address recipient\r\n    ) external virtual returns (uint256 underlyingAmount) {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // ensure emergency exit is active\r\n        EmergencyExitStatus memory status = emergencyExitStatusOfVault[vault];\r\n        if (!status.activated) {\r\n            revert Error_EmergencyExitNotActivated();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        PerpetualYieldToken pyt = getPerpetualYieldTokenForVault(vault);\r\n        uint256 updatedPricePerVaultShare = getPricePerVaultShare(vault);\r\n\r\n        // accrue yield\r\n        _accrueYield(vault, pyt, msg.sender, updatedPricePerVaultShare);\r\n\r\n        if (address(xPYT) == address(0)) {\r\n            // burn raw PYT from sender\r\n            pyt.gateBurn(msg.sender, amount);\r\n        } else {\r\n            /// -----------------------------------------------------------------------\r\n            /// Effects\r\n            /// -----------------------------------------------------------------------\r\n\r\n            // convert xPYT to PYT then burn\r\n            xPYT.withdraw(amount, address(this), msg.sender);\r\n            pyt.gateBurn(address(this), amount);\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// Effects\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // compute how much of the underlying assets to give the recipient\r\n        // rounds down\r\n        underlyingAmount = FullMath.mulDiv(\r\n            amount,\r\n            status.pytPriceInUnderlying,\r\n            PRECISION\r\n        );\r\n\r\n        // withdraw underlying from vault to recipient\r\n        // don't check balance since user can just withdraw slightly less\r\n        // saves gas this way\r\n        underlyingAmount = _withdrawFromVault(\r\n            recipient,\r\n            vault,\r\n            underlyingAmount,\r\n            updatedPricePerVaultShare,\r\n            false\r\n        );\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Internal utilities\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev Updates the yield earned globally and for a particular user.\r\n    function _accrueYield(\r\n        address vault,\r\n        PerpetualYieldToken pyt,\r\n        address user,\r\n        uint256 updatedPricePerVaultShare\r\n    ) internal virtual {\r\n        uint256 updatedYieldPerToken = _computeYieldPerToken(\r\n            vault,\r\n            pyt,\r\n            updatedPricePerVaultShare\r\n        );\r\n        uint256 userYieldPerTokenStored_ = userYieldPerTokenStored[vault][user];\r\n        if (userYieldPerTokenStored_ != 0) {\r\n            userAccruedYield[vault][user] =\r\n                _getClaimableYieldAmount(\r\n                    vault,\r\n                    user,\r\n                    updatedYieldPerToken,\r\n                    userYieldPerTokenStored_,\r\n                    pyt.balanceOf(user)\r\n                ) +\r\n                1;\r\n        }\r\n        yieldPerTokenStored[vault] = updatedYieldPerToken;\r\n        pricePerVaultShareStored[vault] = updatedPricePerVaultShare;\r\n        userYieldPerTokenStored[vault][user] = updatedYieldPerToken + 1;\r\n    }\r\n\r\n    /// @dev Mints PYTs and NYTs to the recipient given the amount of underlying deposited.\r\n    function _enter(\r\n        address nytRecipient,\r\n        address pytRecipient,\r\n        address vault,\r\n        IxPYT xPYT,\r\n        uint256 underlyingAmount,\r\n        uint256 updatedPricePerVaultShare\r\n    ) internal virtual {\r\n        NegativeYieldToken nyt = getNegativeYieldTokenForVault(vault);\r\n        if (address(nyt).code.length == 0) {\r\n            // token pair hasn't been deployed yet\r\n            // do the deployment now\r\n            // only need to check nyt since nyt and pyt are always deployed in pairs\r\n            factory.deployYieldTokenPair(this, vault);\r\n        }\r\n        PerpetualYieldToken pyt = getPerpetualYieldTokenForVault(vault);\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // accrue yield\r\n        _accrueYield(\r\n            vault,\r\n            pyt,\r\n            address(xPYT) == address(0) ? pytRecipient : address(xPYT),\r\n            updatedPricePerVaultShare\r\n        );\r\n\r\n        // mint NYTs and PYTs\r\n        nyt.gateMint(nytRecipient, underlyingAmount);\r\n        if (address(xPYT) == address(0)) {\r\n            // mint raw PYT to recipient\r\n            pyt.gateMint(pytRecipient, underlyingAmount);\r\n        } else {\r\n            // mint PYT to xPYT contract\r\n            pyt.gateMint(address(xPYT), underlyingAmount);\r\n\r\n            /// -----------------------------------------------------------------------\r\n            /// Effects\r\n            /// -----------------------------------------------------------------------\r\n\r\n            // call sweep to mint xPYT using the PYT\r\n            xPYT.sweep(pytRecipient);\r\n        }\r\n    }\r\n\r\n    /// @dev Burns PYTs and NYTs from msg.sender given the amount of underlying withdrawn.\r\n    function _exit(\r\n        address vault,\r\n        IxPYT xPYT,\r\n        uint256 underlyingAmount,\r\n        uint256 updatedPricePerVaultShare\r\n    ) internal virtual {\r\n        NegativeYieldToken nyt = getNegativeYieldTokenForVault(vault);\r\n        PerpetualYieldToken pyt = getPerpetualYieldTokenForVault(vault);\r\n        if (address(nyt).code.length == 0) {\r\n            revert Error_TokenPairNotDeployed();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // accrue yield\r\n        _accrueYield(\r\n            vault,\r\n            pyt,\r\n            address(xPYT) == address(0) ? msg.sender : address(this),\r\n            updatedPricePerVaultShare\r\n        );\r\n\r\n        // burn NYTs and PYTs\r\n        nyt.gateBurn(msg.sender, underlyingAmount);\r\n        if (address(xPYT) == address(0)) {\r\n            // burn raw PYT from sender\r\n            pyt.gateBurn(msg.sender, underlyingAmount);\r\n        } else {\r\n            /// -----------------------------------------------------------------------\r\n            /// Effects\r\n            /// -----------------------------------------------------------------------\r\n\r\n            // convert xPYT to PYT then burn\r\n            xPYT.withdraw(underlyingAmount, address(this), msg.sender);\r\n            pyt.gateBurn(address(this), underlyingAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Updates storage variables for when a PYT holder claims the accrued yield.\r\n    function _claimYield(address vault, uint256 updatedPricePerVaultShare)\r\n        internal\r\n        virtual\r\n        returns (uint256 yieldAmount)\r\n    {\r\n        /// -----------------------------------------------------------------------\r\n        /// Validation\r\n        /// -----------------------------------------------------------------------\r\n\r\n        PerpetualYieldToken pyt = getPerpetualYieldTokenForVault(vault);\r\n        if (address(pyt).code.length == 0) {\r\n            revert Error_TokenPairNotDeployed();\r\n        }\r\n\r\n        /// -----------------------------------------------------------------------\r\n        /// State updates\r\n        /// -----------------------------------------------------------------------\r\n\r\n        // accrue yield\r\n        uint256 updatedYieldPerToken = _computeYieldPerToken(\r\n            vault,\r\n            pyt,\r\n            updatedPricePerVaultShare\r\n        );\r\n        uint256 userYieldPerTokenStored_ = userYieldPerTokenStored[vault][\r\n            msg.sender\r\n        ];\r\n        if (userYieldPerTokenStored_ != 0) {\r\n            yieldAmount = _getClaimableYieldAmount(\r\n                vault,\r\n                msg.sender,\r\n                updatedYieldPerToken,\r\n                userYieldPerTokenStored_,\r\n                pyt.balanceOf(msg.sender)\r\n            );\r\n        }\r\n        yieldPerTokenStored[vault] = updatedYieldPerToken;\r\n        pricePerVaultShareStored[vault] = updatedPricePerVaultShare;\r\n        userYieldPerTokenStored[vault][msg.sender] = updatedYieldPerToken + 1;\r\n        if (yieldAmount != 0) {\r\n            userAccruedYield[vault][msg.sender] = 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of yield claimable by a PerpetualYieldToken holder from a vault.\r\n    /// Assumes userYieldPerTokenStored_ != 0. Does not account for protocol fees.\r\n    function _getClaimableYieldAmount(\r\n        address vault,\r\n        address user,\r\n        uint256 updatedYieldPerToken,\r\n        uint256 userYieldPerTokenStored_,\r\n        uint256 userPYTBalance\r\n    ) internal view virtual returns (uint256 yieldAmount) {\r\n        unchecked {\r\n            // the stored value is shifted by one\r\n            uint256 actualUserYieldPerToken = userYieldPerTokenStored_ - 1;\r\n\r\n            // updatedYieldPerToken - actualUserYieldPerToken won't underflow since we check updatedYieldPerToken > actualUserYieldPerToken\r\n            yieldAmount = FullMath.mulDiv(\r\n                userPYTBalance,\r\n                updatedYieldPerToken > actualUserYieldPerToken\r\n                    ? updatedYieldPerToken - actualUserYieldPerToken\r\n                    : 0,\r\n                PRECISION\r\n            );\r\n\r\n            uint256 accruedYield = userAccruedYield[vault][user];\r\n            if (accruedYield > 1) {\r\n                // won't overflow since the sum is at most the totalSupply of the vault's underlying, which\r\n                // is at most 256 bits.\r\n                // the stored accruedYield value is shifted by one\r\n                yieldAmount += accruedYield - 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Deposits underlying tokens into a vault\r\n    /// @param underlying The underlying token to deposit\r\n    /// @param underlyingAmount The amount of tokens to deposit\r\n    /// @param vault The vault to deposit into\r\n    function _depositIntoVault(\r\n        ERC20 underlying,\r\n        uint256 underlyingAmount,\r\n        address vault\r\n    ) internal virtual;\r\n\r\n    /// @dev Withdraws underlying tokens from a vault\r\n    /// @param recipient The recipient of the underlying tokens\r\n    /// @param vault The vault to withdraw from\r\n    /// @param underlyingAmount The amount of tokens to withdraw\r\n    /// @param pricePerVaultShare The latest price per vault share value\r\n    /// @param checkBalance Set to true to withdraw the entire balance if we're trying\r\n    /// to withdraw more than the balance (due to rounding errors)\r\n    /// @return withdrawnUnderlyingAmount The amount of underlying tokens withdrawn\r\n    function _withdrawFromVault(\r\n        address recipient,\r\n        address vault,\r\n        uint256 underlyingAmount,\r\n        uint256 pricePerVaultShare,\r\n        bool checkBalance\r\n    ) internal virtual returns (uint256 withdrawnUnderlyingAmount);\r\n\r\n    /// @dev Converts a vault share amount into an equivalent underlying asset amount\r\n    function _vaultSharesAmountToUnderlyingAmount(\r\n        address vault,\r\n        uint256 vaultSharesAmount,\r\n        uint256 pricePerVaultShare\r\n    ) internal view virtual returns (uint256);\r\n\r\n    /// @dev Converts a vault share amount into an equivalent underlying asset amount, rounding up\r\n    function _vaultSharesAmountToUnderlyingAmountRoundingUp(\r\n        address vault,\r\n        uint256 vaultSharesAmount,\r\n        uint256 pricePerVaultShare\r\n    ) internal view virtual returns (uint256);\r\n\r\n    /// @dev Converts an underlying asset amount into an equivalent vault shares amount\r\n    function _underlyingAmountToVaultSharesAmount(\r\n        address vault,\r\n        uint256 underlyingAmount,\r\n        uint256 pricePerVaultShare\r\n    ) internal view virtual returns (uint256);\r\n\r\n    /// @dev Computes the latest yieldPerToken value for a vault.\r\n    function _computeYieldPerToken(\r\n        address vault,\r\n        PerpetualYieldToken pyt,\r\n        uint256 updatedPricePerVaultShare\r\n    ) internal view virtual returns (uint256) {\r\n        uint256 pytTotalSupply = pyt.totalSupply();\r\n        if (pytTotalSupply == 0) {\r\n            return yieldPerTokenStored[vault];\r\n        }\r\n        uint256 pricePerVaultShareStored_ = pricePerVaultShareStored[vault];\r\n        if (updatedPricePerVaultShare <= pricePerVaultShareStored_) {\r\n            // rounding error in vault share or no yield accrued\r\n            return yieldPerTokenStored[vault];\r\n        }\r\n        uint256 newYieldPerTokenAccrued;\r\n        unchecked {\r\n            // can't underflow since we know updatedPricePerVaultShare > pricePerVaultShareStored_\r\n            newYieldPerTokenAccrued = FullMath.mulDiv(\r\n                updatedPricePerVaultShare - pricePerVaultShareStored_,\r\n                getVaultShareBalance(vault),\r\n                pytTotalSupply\r\n            );\r\n        }\r\n        return yieldPerTokenStored[vault] + newYieldPerTokenAccrued;\r\n    }\r\n}\r\n\r\n/// @title NegativeYieldToken\r\n/// @author zefram.eth\r\n/// @notice The ERC20 contract representing negative yield tokens\r\ncontract NegativeYieldToken is BaseERC20 {\r\n    /// -----------------------------------------------------------------------\r\n    /// Constructor\r\n    /// -----------------------------------------------------------------------\r\n\r\n    constructor(Gate gate_, address vault_)\r\n        BaseERC20(\r\n            gate_.negativeYieldTokenName(vault_),\r\n            gate_.negativeYieldTokenSymbol(vault_),\r\n            gate_,\r\n            vault_\r\n        )\r\n    {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract Gate\",\"name\":\"gate_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vault_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Error_NotGate\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gate\",\"outputs\":[{\"internalType\":\"contract Gate\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"gateBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"gateMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NegativeYieldToken", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000036b49ebf089be8860d7fc60f2553461e9cc8e9e2000000000000000000000000a258c4606ca8206d8aa700ce2143d7db854d168c", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a11195b24f792f2cb954969f59cfbfbceed801b77214aa564d22d213e9748519"}