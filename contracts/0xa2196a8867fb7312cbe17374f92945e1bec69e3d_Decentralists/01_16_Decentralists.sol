// SPDX-License-Identifier: MIT

/**
                                                                                               
                                       THE DECENTRALISTS                                       
                                                                                               
                                ·.::::iiiiiiiiiiiiiiiiiii::::.·                                
                           .:::iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii::.·                          
                       .::iiiiiiiii:::::..···      ··..:::::iiiiiiiiii::·                      
                   .::iiiiiii:::.·                            .:::iiiiiii::.                   
                .:iiiiiii::                                         .:iiiiiii:.                
             ·:iiiiii::·                                                ::iiiiii:·             
            :iiiiii:·                 ·.::::::::::::::..                   :iiiiii:·           
          :iiiii::               .:::iiiii:::::::::::iiiii:::.               .:iiiii:·         
        :iiiii:·            ·::iii:::·                   .:::iii::·             :iiiii:·       
      ·iiiii:·            ::iii:·                             .::ii::            ·:iiiii:      
     :iiiii:           ·:ii::·                                   ·:iii:·           .iiiii:     
    :iiiii·          ·:ii:.                                         ·:ii:           ·:iiii:    
   :iiii:          ·:ii:              ·.:::::::i:::::::.·             ·:ii:           :iiiii   
  :iiii:          ·iii:            .::iiiiiiiiiiiiiiiiii:::·            .ii:           .iiii:  
 ·iiiii          ·iii            .:ii:::::::iiiiiiiiiiiiiii::.           ·:i:·          :iiii: 
 :iiii:         ·:i:·          .:iii:      .:iiiiiiiiiiiiiiiii:.           iii           iiiii 
:iiii:          :ii           :iiiii:·     ::iiiiiiiiiiiiiiiiiii:          ·ii:          :iiii:
iiiii·         ·ii:          ::iiiiii::::::iiiiiiiiiiiiiiiiiiiiii.          :ii.         ·iiiii
iiiii          :ii           :iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:·         .ii:          :iiii
iiiii          :ii          .iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii.          ii:          :iiii
iiiii          :ii          .iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:.          ii:          :iiii
iiiii          :ii           :iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:·         .ii:          :iiii
iiiii·         ·ii:          ::iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:.          :ii.         ·iiiii
:iiii:          :ii           .:iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:          ·ii:          :iiii:
 :iiii:         ·:i:·          ·::iiiiiiiiiiiiiiiiiiiiiiiiiiii:·           ii:           iiiii 
 ·iiiii           iii·           ·::iiiiiiiiiiiiiiiiiiiiiii::.           .ii:·          :iiii: 
  :iiii:           iii:            ·:::iiiiiiiiiiiiiiiii:::·            :ii:           .iiii:  
   :iiii:           :ii:·              .::::::::::::::..              .:ii:           :iiii:   
    :iiiii·           :iii:                                         .:ii:           ·:iiii:    
     :iiiii:            :iii:·                                   .:iii:·           .iiiii:     
      ·iiiii:·            .:iii:.·                            ::iii::            ·:iiiii:      
        :iiiii:·             .:iiii::.·                 ·:::iiii:.              :iiiii:·       
          :iiiii::               ·:::iiiiiii:::::::iiiiiii:::·               .:iiiii:·         
            :iiiiii:·                   ..:::::::::::..·                   :iiiiii:·           
             ·:iiiiii::·                                                ::iiiiii:·             
                .:iiiiiii::                                         .:iiiiiii:.                
                   .::iiiiiii:::.·                            .:::iiiiiii::.                   
                       .::iiiiiiiii:::::..···      ··..:::::iiiiiiiiii::·                      
                           .:::iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii::.·                          
                                ·.::::iiiiiiiiiiiiiiiiiii::::.·                                


A Decentralist is represented by a set of eight traits:
  0 - Base
    [0] Human Male Black       [8] Vampire Male       [10] Metahuman Male       [12] Ape Male
    [1] Human Female Black     [9] Vampire Female     [11] Metahuman Female
    [2] Human Male Dark
    [3] Human Female Dark
    [4] Human Male Pale
    [5] Human Female Pale
    [6] Human Male White
    [7] Human Female White
  1 - Necklace
    [0] None        [2] Golden
    [1] Diamond     [3] Silver
  2 - Facial Male
    [0] None             [10] Long Gray           [20] Sideburns Blonde
    [1] Chivo Black      [11] Long Red            [21] Sideburns Brown
    [2] Chivo Blonde     [12] Long White          [22] Sideburns Gray
    [3] Chivo Brown      [13] Regular Black       [23] Sideburns Red
    [4] Chivo Gray       [14] Regular Blonde      [24] Sideburns White
    [5] Chivo Red        [15] Regular Brown
    [6] Chivo White      [16] Regular Gray
    [7] Long Black       [17] Regular Red
    [8] Long Blonde      [18] Regular White
    [9] Long Brown       [19] Sideburns Black
  2 - Facial Female
    [0]  None
  3 - Earring
    [0]  None      [2]  Diamond     [4]  Silver
    [1]  Cross     [3]  Golden
  4 - Head Male
    [0] None                [10] CapFront Red     [20] Punky Brown      [30] Short White
    [1] Afro                [11] Hat Black        [21] Punky Gray       [31] Trapper
    [2] CapUp Green         [12] Long Black       [22] Punky Purple     [32] Wool Blue
    [3] CapUp Red           [13] Long Blonde      [23] Punky Red        [33] Wool Green
    [4] Kangaroo Black      [14] Long Brown       [24] Punky White      [34] Wool Red
    [5] CapBack Blue        [15] Long Gray        [25] Short Black
    [6] CapBack Orange      [16] Long Red         [26] Short Blonde
    [7] Conspiracist        [17] Long White       [27] Short Brown
    [8] Cop                 [18] Punky Black      [28] Short Gray
    [9] CapFront Purple     [19] Punky Blonde     [29] Short Red
  4 - Head Female
    [0] None                [10] CapFront Red     [20] Punky Brown      [30] Short White           [40] Trapper
    [1] Afro                [11] Hat Black        [21] Punky Gray       [31] Straight Black        [41] Wool Blue
    [2] CapUp Green         [12] Long Black       [22] Punky Purple     [32] Straight Blonde       [42] Wool Green
    [3] CapUp Red           [13] Long Blonde      [23] Punky Red        [33] Straight Brown        [43] Wool Red
    [4] Kangaroo Black      [14] Long Brown       [24] Punky White      [34] Straight Gray
    [5] CapBack Blue        [15] Long Gray        [25] Short Black      [35] Straight Orange
    [6] CapBack Orange      [16] Long Red         [26] Short Blonde     [36] Straight Platinum
    [7] Conspiracist        [17] Long White       [27] Short Brown      [37] Straight Purple
    [8] Cop                 [18] Punky Black      [28] Short Gray       [38] Straight Red
    [9] CapFront Purple     [19] Punky Blonde     [29] Short Red        [39] Straight White
  5 - Glasses
    [0] None       [2] Nerd      [4] Pilot     [6] VR
    [1] Beetle     [3] Patch     [5] Surf
  6 - Lipstick Male
    [0] None
  6 - Lipstick Female
    [0] None      [2] Orange     [4] Purple
    [1] Green     [3] Pink       [5] Red
  7 - Smoking
    [0] None      [2] Cigarette
    [1] Cigar     [3] E-Cigarette

 */

pragma solidity 0.8.10;

import {ERC721Enumerable} from '../openzeppelin/ERC721Enumerable.sol';
import {ERC721} from '../openzeppelin/ERC721.sol';
import {IERC20} from '../openzeppelin/IERC20.sol';
import {IERC2981} from '../openzeppelin/IERC2981.sol';
import {IERC165} from '../openzeppelin/IERC165.sol';
import {SafeERC20} from '../openzeppelin/SafeERC20.sol';
import {IDescriptor} from './IDescriptor.sol';

contract Decentralists is IERC2981, ERC721Enumerable {
  using SafeERC20 for IERC20;

  // Minting price of each breed
  uint256 public constant MINT_PRICE_HUMAN = 0 ether;
  uint256 public constant MINT_PRICE_VAMPIRE = 0.15 ether;
  uint256 public constant MINT_PRICE_METAHUMAN = 0.05 ether;
  uint256 public constant MINT_PRICE_APE = 0.25 ether;

  // Minting price of each breed during presale
  uint256 private constant MINT_PRICE_PRESALE_VAMPIRE = 0.12 ether;
  uint256 private constant MINT_PRICE_PRESALE_METAHUMAN = 0.04 ether;
  uint256 private constant MINT_PRICE_PRESALE_APE = 0.2 ether;

  // Maximum total supply during presale
  uint24 private constant MAXIMUM_PRESALE_SUPPLY_VAMPIRE = 31;
  uint24 private constant MAXIMUM_PRESALE_SUPPLY_METAHUMAN = 21;
  uint24 private constant MAXIMUM_PRESALE_SUPPLY_APE = 53;

  // Maximum total supply of the collection
  uint24 public constant MAXIMUM_TOTAL_SUPPLY = 1000000;
  uint24 public constant MAXIMUM_TOTAL_SUPPLY_OF_MALE_HUMAN = 495000;
  uint24 public constant MAXIMUM_TOTAL_SUPPLY_OF_FEMALE_HUMAN = 495000;
  uint24 public constant MAXIMUM_TOTAL_SUPPLY_OF_MALE_VAMPIRE = 1500;
  uint24 public constant MAXIMUM_TOTAL_SUPPLY_OF_FEMALE_VAMPIRE = 1500;
  uint24 public constant MAXIMUM_TOTAL_SUPPLY_OF_MALE_METAHUMAN = 3000;
  uint24 public constant MAXIMUM_TOTAL_SUPPLY_OF_FEMALE_METAHUMAN = 3000;
  uint24 public constant MAXIMUM_TOTAL_SUPPLY_OF_APE = 1000;

  // Trait sizes
  uint256 private constant TRAIT_BASE_SIZE = 13;
  uint256 private constant TRAIT_NECKLACE_SIZE = 4;
  uint256 private constant TRAIT_FACIAL_MALE_SIZE = 25;
  uint256 private constant TRAIT_FACIAL_FEMALE_SIZE = 1;
  uint256 private constant TRAIT_EARRING_SIZE = 5;
  uint256 private constant TRAIT_HEAD_MALE_SIZE = 35;
  uint256 private constant TRAIT_HEAD_FEMALE_SIZE = 44;
  uint256 private constant TRAIT_GLASSES_SIZE = 7;
  uint256 private constant TRAIT_LIPSTICK_MALE_SIZE = 1;
  uint256 private constant TRAIT_LIPSTICK_FEMALE_SIZE = 6;
  uint256 private constant TRAIT_SMOKING_SIZE = 4;

  // Base trait separator for each breed
  uint256 private constant TRAIT_BASE_HUMAN_SEPARATOR = 8;
  uint256 private constant TRAIT_BASE_VAMPIRE_SEPARATOR = 10;
  uint256 private constant TRAIT_BASE_METAHUMAN_SEPARATOR = 12;
  uint256 private constant TRAIT_BASE_APE_SEPARATOR = 13;

  // Governance
  address public governance;
  address public emergencyAdmin;

  // Descriptor
  IDescriptor public descriptor;
  bool public isDescriptorLocked;

  // Royalties
  uint256 public royaltyBps;
  address public royaltyReceiver;

  struct Data {
    // Presale ends after 1 week
    uint40 presaleStartTime;
    // Emergency stop of the claiming process
    bool isStopped;
    // Decremental counters, from maximum total supply to zero
    uint24 count;
    uint24 femaleHumans;
    uint24 maleHumans;
    uint24 femaleVampires;
    uint24 maleVampires;
    uint24 femaleMetahumans;
    uint24 maleMetahumans;
    uint24 apes;
  }
  Data private data;

  // Combination of traits
  struct Combination {
    uint8 base;
    uint8 necklace;
    uint8 facial;
    uint8 earring;
    uint8 head;
    uint8 glasses;
    uint8 lipstick;
    uint8 smoking;
  }
  // Combinations: keccak256(combination) => tokenId
  mapping(bytes32 => uint256) private _combinationToId;
  // Combinations: tokenId => Combination
  mapping(uint256 => Combination) private _idToCombination;

  // Mapping of human minters
  mapping(address => bool) private _hasMintedHuman;

  /**
   * @dev Constructor
   * @param governance_ address of the governance
   * @param emergencyAdmin_ address of the emergency admin
   * @param descriptor_ address of the token descriptor
   * @param royaltyBps_ value of bps for royalties (e.g. 150 corresponds to 1.50%)
   * @param royaltyReceiver_ address of the royalties receiver
   * @param initialMintingRecipients_ array of recipients for the initial minting
   * @param initialMintingCombinations_ array of combinations for the initial minting
   */
  constructor(
    address governance_,
    address emergencyAdmin_,
    address descriptor_,
    uint256 royaltyBps_,
    address royaltyReceiver_,
    address[] memory initialMintingRecipients_,
    uint256[8][] memory initialMintingCombinations_
  ) ERC721('Decentralists', 'DCN') {
    governance = governance_;
    emergencyAdmin = emergencyAdmin_;
    descriptor = IDescriptor(descriptor_);
    royaltyBps = royaltyBps_;
    royaltyReceiver = royaltyReceiver_;

    // Decremental counters
    data.count = MAXIMUM_TOTAL_SUPPLY;
    data.femaleHumans = MAXIMUM_TOTAL_SUPPLY_OF_FEMALE_HUMAN;
    data.maleHumans = MAXIMUM_TOTAL_SUPPLY_OF_MALE_HUMAN;
    data.femaleVampires = MAXIMUM_TOTAL_SUPPLY_OF_FEMALE_VAMPIRE;
    data.maleVampires = MAXIMUM_TOTAL_SUPPLY_OF_MALE_VAMPIRE;
    data.femaleMetahumans = MAXIMUM_TOTAL_SUPPLY_OF_FEMALE_METAHUMAN;
    data.maleMetahumans = MAXIMUM_TOTAL_SUPPLY_OF_MALE_METAHUMAN;
    data.apes = MAXIMUM_TOTAL_SUPPLY_OF_APE;

    // Initial minting
    unchecked {
      uint256 size = initialMintingRecipients_.length;
      for (uint256 i = 0; i < size; i++) {
        _claim(initialMintingCombinations_[i], initialMintingRecipients_[i]);
      }
    }
  }

  /**
   * @notice Mint a token with given traits (array of 8 values)
   * @param traits set of traits of the token
   */
  function claim(uint256[8] calldata traits) external payable {
    require(!data.isStopped, 'CLAIM_STOPPED');
    require(!isPresale() && data.presaleStartTime != 0, 'SALE_NOT_ACTIVE');
    require(_validateCombination(traits), 'INVALID_COMBINATION');
    require(_checkValue(traits[0], false), 'INCORRECT_VALUE');

    _claim(traits, msg.sender);
  }

  /**
   * @notice Mint a token with given traits (array of 8 values) during presale
   * @param traits set of traits of the token
   */
  function presaleClaim(uint256[8] calldata traits) external payable {
    require(!data.isStopped, 'CLAIM_STOPPED');
    require(isPresale() && data.presaleStartTime != 0, 'PRESALE_NOT_ACTIVE');
    require(_validateCombination(traits), 'INVALID_COMBINATION');
    require(!_humanBase(traits[0]), 'HUMANS_NOT_AVAILABLE');
    require(_checkValue(traits[0], true), 'INCORRECT_VALUE');

    // Check breed counter during presale
    if (_vampireBase(traits[0])) {
      require(
        totalFemaleVampiresSupply() + totalMaleVampiresSupply() < MAXIMUM_PRESALE_SUPPLY_VAMPIRE,
        'NO_CLAIMS_AVAILABLE'
      );
    } else if (_metahumanBase(traits[0])) {
      require(
        totalFemaleMetahumansSupply() + totalMaleMetahumansSupply() <
          MAXIMUM_PRESALE_SUPPLY_METAHUMAN,
        'NO_CLAIMS_AVAILABLE'
      );
    } else {
      require(totalApesSupply() < MAXIMUM_PRESALE_SUPPLY_APE, 'NO_CLAIMS_AVAILABLE');
    }

    _claim(traits, msg.sender);
  }

  /**
   * @notice Returns whether the combination given is available or not
   * @param traits set of traits of the combination
   * @return true if the combination is available, false otherwise
   */
  function isCombinationAvailable(uint256[8] calldata traits) external view returns (bool) {
    require(_validateCombination(traits), 'INVALID_COMBINATION');
    bytes32 hashedCombination = keccak256(
      abi.encodePacked(
        traits[0], // base
        traits[1], // necklace
        traits[2], // facial
        traits[3], // earring
        traits[4], // head
        traits[5], // glasses
        traits[6], // lipstick
        traits[7] // smoking
      )
    );
    return _combinationToId[hashedCombination] == 0;
  }

  /**
   * @notice Returns whether the combination given is valid or not
   * @param traits set of traits of the combination to validate
   * @return true if the combination is valid, false otherwise
   */
  function isCombinationValid(uint256[8] calldata traits) external pure returns (bool) {
    return _validateCombination(traits);
  }

  /**
   * @notice Returns whether the presale is active or not (1 week duration)
   * @return true if the presale is active, false otherwise
   */
  function isPresale() public view returns (bool) {
    return block.timestamp <= data.presaleStartTime + 1 weeks;
  }

  /**
   * @notice Returns whether the claiming process is stopped or not
   * @return true if the claiming process is stop, false otherwise
   */
  function isEmergencyStopped() external view returns (bool) {
    return data.isStopped;
  }

  /**
   * @notice Returns the token id of a given set of traits
   * @param traits set of traits of the token
   * @return token id
   */
  function getTokenId(uint256[8] calldata traits) external view returns (uint256) {
    bytes32 hashedCombination = keccak256(
      abi.encodePacked(
        traits[0], // base
        traits[1], // necklace
        traits[2], // facial
        traits[3], // earring
        traits[4], // head
        traits[5], // glasses
        traits[6], // lipstick
        traits[7] // smoking
      )
    );
    require(_combinationToId[hashedCombination] != 0, 'NOT_EXISTS');
    return _combinationToId[hashedCombination];
  }

  /**
   * @notice Returns the set of traits given a token id
   * @param tokenId the id of the token
   * @return traits array
   */
  function getTraits(uint256 tokenId) external view returns (uint256[8] memory) {
    require(_exists(tokenId), 'NOT_EXISTS');
    return _getTraits(tokenId);
  }

  /**
   * @notice Returns the set of traits given a token id
   * @param tokenId the id of the token
   * @return traits array
   */
  function _getTraits(uint256 tokenId) internal view returns (uint256[8] memory traits) {
    Combination memory c = _idToCombination[tokenId];
    traits[0] = c.base;
    traits[1] = c.necklace;
    traits[2] = c.facial;
    traits[3] = c.earring;
    traits[4] = c.head;
    traits[5] = c.glasses;
    traits[6] = c.lipstick;
    traits[7] = c.smoking;
  }

  /**
   * @notice Returns the Uniform Resource Identifier (URI) for `tokenId` token
   * @param tokenId token id
   * @return uri of the given `tokenId`
   */
  function tokenURI(uint256 tokenId) public view override(ERC721) returns (string memory) {
    require(_exists(tokenId), 'NOT_EXISTS');
    return descriptor.tokenURI(_getTraits(tokenId));
  }

  /**
   * @notice Returns whether the given address of the user has already minted a human or not
   * @param user address of the user
   * @return true if `user` has minted a human, false otherwise
   */
  function hasMintedHuman(address user) external view returns (bool) {
    return _hasMintedHuman[user];
  }

  /**
   * @notice Returns the total amount of female human tokens
   * @return total supply of female humans
   */
  function totalFemaleHumansSupply() public view returns (uint256) {
    return MAXIMUM_TOTAL_SUPPLY_OF_FEMALE_HUMAN - data.femaleHumans;
  }

  /**
   * @notice Returns the total amount of male human tokens
   * @return total supply of male humans
   */
  function totalMaleHumansSupply() public view returns (uint256) {
    return MAXIMUM_TOTAL_SUPPLY_OF_MALE_HUMAN - data.maleHumans;
  }

  /**
   * @notice Returns the total amount of female vampire tokens
   * @return total supply of female vampires
   */
  function totalFemaleVampiresSupply() public view returns (uint256) {
    return MAXIMUM_TOTAL_SUPPLY_OF_FEMALE_VAMPIRE - data.femaleVampires;
  }

  /**
   * @notice Returns the total amount of male vampire tokens
   * @return total supply of male vampires
   */
  function totalMaleVampiresSupply() public view returns (uint256) {
    return MAXIMUM_TOTAL_SUPPLY_OF_MALE_VAMPIRE - data.maleVampires;
  }

  /**
   * @notice Returns the total amount of female metahuman tokens
   * @return total supply of female metahumans
   */
  function totalFemaleMetahumansSupply() public view returns (uint256) {
    return MAXIMUM_TOTAL_SUPPLY_OF_FEMALE_METAHUMAN - data.femaleMetahumans;
  }

  /**
   * @notice Returns the total amount of male metahuman tokens
   * @return total supply of male metahumans
   */
  function totalMaleMetahumansSupply() public view returns (uint256) {
    return MAXIMUM_TOTAL_SUPPLY_OF_MALE_METAHUMAN - data.maleMetahumans;
  }

  /**
   * @notice Returns the total amount of ape tokens
   * @return total supply of apes
   */
  function totalApesSupply() public view returns (uint256) {
    return MAXIMUM_TOTAL_SUPPLY_OF_APE - data.apes;
  }

  /**
   * @notice Returns the starting time of the presale (0 if it did not start yet)
   * @return starting time of the presale
   */
  function presaleStartTime() external view returns (uint256) {
    return uint256(data.presaleStartTime);
  }

  /**
   * @notice Returns how much royalty is owed and to whom, based on the sale price
   * @param tokenId token id of the NFT asset queried for royalty information
   * @param salePrice sale price of the NFT asset specified by `tokenId`
   * @return receiver address of the royalty payment
   * @return amount of the royalty payment for `salePrice`
   */
  function royaltyInfo(uint256 tokenId, uint256 salePrice)
    external
    view
    override(IERC2981)
    returns (address, uint256)
  {
    require(_exists(tokenId), 'NOT_EXISTS');
    return (royaltyReceiver, (salePrice * royaltyBps) / 10000);
  }

  /**
   * @dev Checks if the contract supports the given interface
   * @param interfaceId The identifier of the interface
   * @return True if the interface is supported, false otherwise
   */
  function supportsInterface(bytes4 interfaceId)
    public
    view
    virtual
    override(ERC721Enumerable, IERC165)
    returns (bool)
  {
    return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);
  }

  /**
   * @notice Activate the presale
   * @dev Only callable by governance
   */
  function startPresale() external onlyGovernance {
    require(data.presaleStartTime == 0, 'PRESALE_ALREADY_STARTED');
    data.presaleStartTime = uint40(block.timestamp);
    emit PresaleStart();
  }

  /**
   * @notice Pull ETH funds from the contract to the given recipient
   * @dev Only callable by governance
   * @param recipient address to transfer the funds to
   * @param amount amount of funds to transfer
   */
  function pullFunds(address recipient, uint256 amount) external onlyGovernance {
    (bool success, ) = recipient.call{value: amount}('');
    require(success, 'UNABLE_TO_PULL');
    emit FundsWithdrawal(recipient, amount);
  }

  /**
   * @notice Pull ERC20 token funds from the contract to the given recipient
   * @dev Only callable by governance
   * @param asset address of the ERC20 token to transfer
   * @param recipient address to transfer the funds to
   * @param amount amount of funds to transfer
   */
  function pullTokens(
    address asset,
    address recipient,
    uint256 amount
  ) external onlyGovernance {
    IERC20(asset).safeTransfer(recipient, amount);
  }

  /**
   * @notice Update the governance address
   * @dev Only callable by governance
   * @param newGovernance address of the new governance
   */
  function setGovernance(address newGovernance) external onlyGovernance {
    address oldGovernance = governance;
    governance = newGovernance;

    emit GovernanceUpdate(oldGovernance, newGovernance);
  }

  /**
   * @notice Update the descriptor address
   * @dev Only callable by governance when descriptor is not locked
   * @param newDescriptor address of the new descriptor
   */
  function setDescriptor(address newDescriptor) external onlyGovernance whenDescriptorNotLocked {
    address oldDescriptor = address(descriptor);
    descriptor = IDescriptor(newDescriptor);

    emit DescriptorUpdate(oldDescriptor, newDescriptor);
  }

  /**
   * @notice Lock the ability to update the descriptor address
   * @dev Only callable by governance when descriptor is not locked
   */
  function lockDescriptor() external onlyGovernance whenDescriptorNotLocked {
    isDescriptorLocked = true;

    emit DescriptorLock(address(descriptor));
  }

  /**
   * @notice Update the royalty basis points (e.g. a value of 150 corresponds to 1.50%)
   * @dev Only callable by governance
   * @param newRoyaltyBps value of the new royalty bps
   */
  function setRoyaltyBps(uint256 newRoyaltyBps) external onlyGovernance {
    uint256 oldRoyaltyBps = royaltyBps;
    royaltyBps = newRoyaltyBps;

    emit RoyaltyBpsUpdate(oldRoyaltyBps, newRoyaltyBps);
  }

  /**
   * @notice Update the royalty receiver
   * @dev Only callable by governance
   * @param newRoyaltyReceiver address of the new royalty receiver
   */
  function setRoyaltyReceiver(address newRoyaltyReceiver) external onlyGovernance {
    address oldRoyaltyReceiver = royaltyReceiver;
    royaltyReceiver = newRoyaltyReceiver;

    emit RoyaltyReceiverUpdate(oldRoyaltyReceiver, newRoyaltyReceiver);
  }

  /**
   * @notice Stops the claiming process of the contract in case of emergency
   * @dev Only callable by emergency admin
   * @param isStopped true to stop the claiming process, false otherwise
   */
  function emergencyStop(bool isStopped) external {
    require(msg.sender == emergencyAdmin, 'ONLY_BY_EMERGENCY_ADMIN');
    data.isStopped = isStopped;

    emit EmergencyStop(isStopped);
  }

  /**
   * @notice Update the emergency admin address
   * @dev Only callable by emergency admin
   * @param newEmergencyAdmin address of the new emergency admin
   */
  function setEmergencyAdmin(address newEmergencyAdmin) external {
    require(msg.sender == emergencyAdmin, 'ONLY_BY_EMERGENCY_ADMIN');

    address oldEmergencyAdmin = emergencyAdmin;
    emergencyAdmin = newEmergencyAdmin;

    emit EmergencyAdminUpdate(oldEmergencyAdmin, newEmergencyAdmin);
  }

  /**
   * @notice Mint a token to the receiver
   * @param traits set of traits of the token
   * @param receiver receiver address
   */
  function _claim(uint256[8] memory traits, address receiver) internal {
    require(msg.sender == tx.origin, 'ONLY_EOA');
    require(data.count > 0, 'NO_CLAIMS_AVAILABLE');

    uint256 base = traits[0];
    bytes32 hashedCombination = keccak256(
      abi.encodePacked(
        base, // base
        traits[1], // necklace
        traits[2], // facial
        traits[3], // earring
        traits[4], // head
        traits[5], // glasses
        traits[6], // lipstick
        traits[7] // smoking
      )
    );
    require(_combinationToId[hashedCombination] == 0, 'ALREADY_EXISTS');
    if (_humanBase(base)) {
      require(!_hasMintedHuman[msg.sender], 'INVALID_HUMAN_MINTER');
      _hasMintedHuman[msg.sender] = true;
    }

    // TokenId (0 is reserved)
    uint256 tokenId = MAXIMUM_TOTAL_SUPPLY - data.count + 1;

    // Update breed counter
    if (_humanBase(base)) {
      if (_isMale(base)) {
        data.maleHumans--;
      } else {
        data.femaleHumans--;
      }
    } else if (_vampireBase(base)) {
      if (_isMale(base)) {
        data.maleVampires--;
      } else {
        data.femaleVampires--;
      }
    } else if (_metahumanBase(base)) {
      if (_isMale(base)) {
        data.maleMetahumans--;
      } else {
        data.femaleMetahumans--;
      }
    } else {
      data.apes--;
    }
    data.count--;

    // Traits
    _combinationToId[hashedCombination] = tokenId;
    _idToCombination[tokenId] = Combination({
      base: uint8(base),
      necklace: uint8(traits[1]),
      facial: uint8(traits[2]),
      earring: uint8(traits[3]),
      head: uint8(traits[4]),
      glasses: uint8(traits[5]),
      lipstick: uint8(traits[6]),
      smoking: uint8(traits[7])
    });

    _mint(receiver, tokenId);

    emit DecentralistMint(tokenId, receiver, traits);
  }

  /**
   * @notice Check the transaction value is correct given a base and whether the presale is active
   * @param base value of the base trait
   * @param inPresale true if presale is active, false otherwise
   * @return true if the transaction value is correct, false otherwise
   */
  function _checkValue(uint256 base, bool inPresale) internal view returns (bool) {
    if (_humanBase(base)) {
      return msg.value == MINT_PRICE_HUMAN;
    } else if (_vampireBase(base)) {
      return inPresale ? msg.value == MINT_PRICE_PRESALE_VAMPIRE : msg.value == MINT_PRICE_VAMPIRE;
    } else if (_metahumanBase(base)) {
      return
        inPresale ? msg.value == MINT_PRICE_PRESALE_METAHUMAN : msg.value == MINT_PRICE_METAHUMAN;
    } else if (_apeBase(base)) {
      return inPresale ? msg.value == MINT_PRICE_PRESALE_APE : msg.value == MINT_PRICE_APE;
    } else {
      return false;
    }
  }

  /**
   * @notice Check whether a set of traits is a valid combination or not
   * @dev Even numbers of base trait corresponds to male
   * @param traits set of traits of the token
   * @return true if it is a valid combination, false otherwise
   */
  function _validateCombination(uint256[8] calldata traits) internal pure returns (bool) {
    bool isMale = _isMale(traits[0]);
    if (
      isMale &&
      traits[0] < TRAIT_BASE_SIZE &&
      traits[1] < TRAIT_NECKLACE_SIZE &&
      traits[2] < TRAIT_FACIAL_MALE_SIZE &&
      traits[3] < TRAIT_EARRING_SIZE &&
      traits[4] < TRAIT_HEAD_MALE_SIZE &&
      traits[5] < TRAIT_GLASSES_SIZE &&
      traits[6] < TRAIT_LIPSTICK_MALE_SIZE &&
      traits[7] < TRAIT_SMOKING_SIZE
    ) {
      return true;
    } else if (
      !isMale &&
      traits[0] < TRAIT_BASE_SIZE &&
      traits[1] < TRAIT_NECKLACE_SIZE &&
      traits[2] < TRAIT_FACIAL_FEMALE_SIZE &&
      traits[3] < TRAIT_EARRING_SIZE &&
      traits[4] < TRAIT_HEAD_FEMALE_SIZE &&
      traits[5] < TRAIT_GLASSES_SIZE &&
      traits[6] < TRAIT_LIPSTICK_FEMALE_SIZE &&
      traits[7] < TRAIT_SMOKING_SIZE
    ) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * @notice Returns true if the base trait corresponds to human breed
   * @param base value of the base trait
   * @return True if the base corresponds to human breed, false otherwise
   */
  function _humanBase(uint256 base) internal pure returns (bool) {
    return base < TRAIT_BASE_HUMAN_SEPARATOR;
  }

  /**
   * @notice Returns true if the base trait corresponds to vampire breed
   * @param base value of the base trait
   * @return True if the base corresponds to vampire breed, false otherwise
   */
  function _vampireBase(uint256 base) internal pure returns (bool) {
    return base >= TRAIT_BASE_HUMAN_SEPARATOR && base < TRAIT_BASE_VAMPIRE_SEPARATOR;
  }

  /**
   * @notice Returns true if the base trait corresponds to metahuman breed
   * @param base value of the base trait
   * @return True if the base corresponds to metahuman breed, false otherwise
   */
  function _metahumanBase(uint256 base) internal pure returns (bool) {
    return base >= TRAIT_BASE_VAMPIRE_SEPARATOR && base < TRAIT_BASE_METAHUMAN_SEPARATOR;
  }

  /**
   * @notice Returns true if the base trait corresponds to ape breed
   * @param base value of the base trait
   * @return True if the base corresponds to ape breed, false otherwise
   */
  function _apeBase(uint256 base) internal pure returns (bool) {
    return base >= TRAIT_BASE_METAHUMAN_SEPARATOR && base < TRAIT_BASE_APE_SEPARATOR;
  }

  /**
   * @notice Returns true if the base trait corresponds to male sex
   * @param base value of the base trait
   * @return True if the base corresponds to male sex, false otherwise
   */
  function _isMale(uint256 base) internal pure returns (bool) {
    return base % 2 == 0;
  }

  /**
   * @dev Hook that is called before any transfer of tokens
   * @param from origin address of the transfer
   * @param to recipient address of the transfer
   * @param tokenId id of the token to transfer
   */
  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal override(ERC721Enumerable) {
    super._beforeTokenTransfer(from, to, tokenId);
  }

  /**
   * @dev Functions marked by this modifier can only be called when descriptor is not locked
   **/
  modifier whenDescriptorNotLocked() {
    require(!isDescriptorLocked, 'DESCRIPTOR_LOCKED');
    _;
  }

  /**
   * @dev Functions marked by this modifier can only be called by governance
   **/
  modifier onlyGovernance() {
    require(msg.sender == governance, 'ONLY_BY_GOVERNANCE');
    _;
  }

  /**
   * @dev Emitted when a new token is minted
   * @param tokenId token id
   * @param recipient address of the recipient of the token
   * @param traits set of traits of the token
   */
  event DecentralistMint(uint256 indexed tokenId, address indexed recipient, uint256[8] traits);

  /**
   * @dev Emitted when the presale starts
   */
  event PresaleStart();

  /**
   * @dev Emitted when funds are withdraw
   * @param recipient address of the recipient of the funds
   * @param amount amount of the funds withdraw
   */
  event FundsWithdrawal(address indexed recipient, uint256 amount);

  /**
   * @dev Emitted when the governance address is updated
   * @param oldGovernance address of the old governance
   * @param newGovernance address of the new governance
   */
  event GovernanceUpdate(address indexed oldGovernance, address indexed newGovernance);

  /**
   * @dev Emitted when the emergency admin stops the claiming process
   * @param isStopped true if it is stopped, false otherwise
   */
  event EmergencyStop(bool isStopped);

  /**
   * @dev Emitted when the emergency admin address is updated
   * @param oldEmergencyAdmin address of the old emergency admin
   * @param newEmergencyAdmin address of the new emergency admin
   */
  event EmergencyAdminUpdate(address indexed oldEmergencyAdmin, address indexed newEmergencyAdmin);

  /**
   * @dev Emitted when the descriptor address is updated
   * @param oldDescriptor address of the old descriptor
   * @param newDescriptor address of the new descriptor
   */
  event DescriptorUpdate(address indexed oldDescriptor, address indexed newDescriptor);

  /**
   * @dev Emitted when the descriptor is locked
   * @param descriptor address of the descriptor
   */
  event DescriptorLock(address indexed descriptor);

  /**
   * @dev Emitted when the royalty bps value is updated
   * @param oldRoyaltyBps old value of the royalty bps
   * @param newRoyaltyBps new value of the royalty bps
   */
  event RoyaltyBpsUpdate(uint256 oldRoyaltyBps, uint256 newRoyaltyBps);

  /**
   * @dev Emitted when the royalty receiver is updated
   * @param oldRoyaltyReceiver address of the old royalty receiver
   * @param newRoyaltyReceiver address of the new royalty receiver
   */
  event RoyaltyReceiverUpdate(
    address indexed oldRoyaltyReceiver,
    address indexed newRoyaltyReceiver
  );
}