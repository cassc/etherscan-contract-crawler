{"SourceCode": "pragma solidity ^0.4.25;\r\n\r\n/* Interface for ERC20 Tokens */\r\ncontract Token {\r\n    bytes32 public standard;\r\n    bytes32 public name;\r\n    bytes32 public symbol;\r\n    uint256 public totalSupply;\r\n    uint8 public decimals;\r\n    bool public allowTransactions;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n}\r\n\r\n/* Interface for the DMEX base contract */\r\ncontract DMEX_Base {\r\n    function getReserve(address token, address user) returns (uint256);\r\n    function setReserve(address token, address user, uint256 amount) returns (bool);\r\n\r\n    function availableBalanceOf(address token, address user) returns (uint256);\r\n    function balanceOf(address token, address user) returns (uint256);\r\n\r\n\r\n    function setBalance(address token, address user, uint256 amount) returns (bool);\r\n    function getAffiliate(address user) returns (address);\r\n    function getInactivityReleasePeriod() returns (uint256);\r\n    function getMakerTakerBalances(address token, address maker, address taker) returns (uint256[4]);\r\n\r\n    function getEtmTokenAddress() returns (address);\r\n\r\n    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) returns (bool);\r\n    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) returns (bool);\r\n    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) returns (bool);\r\n\r\n}\r\n\r\n\r\n\r\n// The DMEX Futures Contract\r\ncontract Exchange {\r\n    function assert(bool assertion) pure {\r\n        \r\n        if (!assertion) {\r\n            throw;\r\n        }\r\n    }\r\n\r\n    // Safe Multiply Function - prevents integer overflow \r\n    function safeMul(uint a, uint b) pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    // Safe Subtraction Function - prevents integer overflow \r\n    function safeSub(uint a, uint b) pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    // Safe Addition Function - prevents integer overflow \r\n    function safeAdd(uint a, uint b) pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    address public owner; // holds the address of the contract owner\r\n\r\n    // Event fired when the owner of the contract is changed\r\n    event SetOwner(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // Allows only the owner of the contract to execute the function\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // Allows only the owner of the contract to execute the function\r\n    modifier onlyOracle {\r\n        assert(msg.sender == DmexOracleContract);\r\n        _;\r\n    }\r\n\r\n    // Changes the owner of the contract\r\n    function setOwner(address newOwner) onlyOwner {\r\n        emit SetOwner(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    // Owner getter function\r\n    function getOwner() view returns (address out) {\r\n        return owner;\r\n    }\r\n\r\n    mapping (address => bool) public admins;                    // mapping of admin addresses\r\n    mapping (address => uint256) public lastActiveTransaction;  // mapping of user addresses to last transaction block\r\n    mapping (bytes32 => uint256) public orderFills;             // mapping of orders to filled qunatity\r\n    \r\n    address public feeAccount;          // the account that receives the trading fees\r\n    address public exchangeContract;    // the address of the main DMEX_Base contract\r\n    address public DmexOracleContract;    // the address of the DMEX math contract used for some calculations\r\n\r\n    uint256 public makerFee;            // maker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\r\n    uint256 public takerFee;            // taker fee in percent expressed as a fraction of 1 ether (0.1 ETH = 10%)\r\n    \r\n    struct FuturesAsset {\r\n        string name;                    // the name of the traded asset (ex. ETHUSD)\r\n        address baseToken;              // the token for collateral\r\n        string priceUrl;                // the url where the price of the asset will be taken for settlement\r\n        string pricePath;               // price path in the returned JSON from the priceUrl (ex. path \"last\" will return tha value last from the json: {\"high\": \"156.49\", \"last\": \"154.31\", \"timestamp\": \"1556522201\", \"bid\": \"154.22\", \"vwap\": \"154.65\", \"volume\": \"25578.79138868\", \"low\": \"152.33\", \"ask\": \"154.26\", \"open\": \"152.99\"})\r\n        bool disabled;                  // if true, the asset cannot be used in contract creation (when price url no longer valid)\r\n    }\r\n\r\n    function createFuturesAsset(string name, address baseToken, string priceUrl, string pricePath) onlyAdmin returns (bytes32)\r\n    {    \r\n        bytes32 futuresAsset = keccak256(this, name, baseToken, priceUrl, pricePath);\r\n        if (futuresAssets[futuresAsset].disabled) throw; // asset already exists and is disabled\r\n\r\n        futuresAssets[futuresAsset] = FuturesAsset({\r\n            name                : name,\r\n            baseToken           : baseToken,\r\n            priceUrl            : priceUrl,\r\n            pricePath           : pricePath,\r\n            disabled            : false\r\n        });\r\n\r\n        emit FuturesAssetCreated(futuresAsset, name, baseToken, priceUrl, pricePath);\r\n        return futuresAsset;\r\n    }\r\n    \r\n    struct FuturesContract {\r\n        bytes32 asset;                  // the hash of the underlying asset object\r\n        uint256 expirationBlock;        // futures contract expiration block\r\n        uint256 closingPrice;           // the closing price for the futures contract\r\n        bool closed;                    // is the futures contract closed (0 - false, 1 - true)\r\n        bool broken;                    // if someone has forced release of funds the contract is marked as broken and can no longer close positions (0-false, 1-true)\r\n        uint256 floorPrice;             // the minimum price that can be traded on the contract, once price is reached the contract expires and enters settlement state \r\n        uint256 capPrice;               // the maximum price that can be traded on the contract, once price is reached the contract expires and enters settlement state\r\n        uint256 multiplier;             // the multiplier price, normally the ETHUSD price * 1e18\r\n        uint256 fundingRate;            // the funding rate in percent per block (number in WEI)\r\n    }\r\n\r\n    function createFuturesContract(bytes32 asset, uint256 expirationBlock, uint256 floorPrice, uint256 capPrice, uint256 multiplier, uint256 fundingRate) onlyAdmin returns (bytes32)\r\n    {    \r\n        bytes32 futuresContract = keccak256(this, asset, expirationBlock, floorPrice, capPrice, multiplier, fundingRate);\r\n        if (futuresContracts[futuresContract].expirationBlock > 0) return futuresContract; // contract already exists\r\n\r\n        futuresContracts[futuresContract] = FuturesContract({\r\n            asset           : asset,\r\n            expirationBlock : expirationBlock,\r\n            closingPrice    : 0,\r\n            closed          : false,\r\n            broken          : false,\r\n            floorPrice      : floorPrice,\r\n            capPrice        : capPrice,\r\n            multiplier      : multiplier,\r\n            fundingRate     : fundingRate\r\n        });\r\n\r\n        emit FuturesContractCreated(futuresContract, asset, expirationBlock, floorPrice, capPrice, multiplier);\r\n\r\n        return futuresContract;\r\n    }\r\n\r\n    function getContractExpiration (bytes32 futuresContractHash) view returns (uint256)\r\n    {\r\n        return futuresContracts[futuresContractHash].expirationBlock;\r\n    }\r\n\r\n    function getContractClosed (bytes32 futuresContractHash) returns (bool)\r\n    {\r\n        return futuresContracts[futuresContractHash].closed;\r\n    }\r\n\r\n    function getContractPriceUrl (bytes32 futuresContractHash) returns (string)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].priceUrl;\r\n    }\r\n\r\n    function getContractPricePath (bytes32 futuresContractHash) returns (string)\r\n    {\r\n        return futuresAssets[futuresContracts[futuresContractHash].asset].pricePath;\r\n    }\r\n\r\n    mapping (bytes32 => FuturesAsset)       public futuresAssets;      // mapping of futuresAsset hash to FuturesAsset structs\r\n    mapping (bytes32 => FuturesContract)    public futuresContracts;   // mapping of futuresContract hash to FuturesContract structs\r\n    mapping (bytes32 => uint256)            public positions;          // mapping of user addresses to position hashes to position\r\n\r\n\r\n    enum Errors {\r\n        INVALID_PRICE,                  // Order prices don't match\r\n        INVALID_SIGNATURE,              // Signature is invalid\r\n        ORDER_ALREADY_FILLED,           // Order was already filled\r\n        GAS_TOO_HIGH,                   // Too high gas fee\r\n        OUT_OF_BALANCE,                 // User doesn't have enough balance for the operation\r\n        FUTURES_CONTRACT_EXPIRED,       // Futures contract already expired\r\n        FLOOR_OR_CAP_PRICE_REACHED,     // The floor price or the cap price for the futures contract was reached\r\n        POSITION_ALREADY_EXISTS,        // User has an open position already \r\n        UINT48_VALIDATION,              // Size or price bigger than an Uint48\r\n        FAILED_ASSERTION                // Assertion failed\r\n    }\r\n\r\n    event FuturesTrade(bool side, uint256 size, uint256 price, bytes32 indexed futuresContract, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\r\n    event FuturesPositionClosed(bytes32 indexed positionHash, uint256 closingPrice);\r\n    event FuturesContractClosed(bytes32 indexed futuresContract, uint256 closingPrice);\r\n    event FuturesForcedRelease(bytes32 indexed futuresContract, bool side, address user);\r\n    event FuturesAssetCreated(bytes32 indexed futuresAsset, string name, address baseToken, string priceUrl, string pricePath);\r\n    event FuturesContractCreated(bytes32 indexed futuresContract, bytes32 asset, uint256 expirationBlock, uint256 floorPrice, uint256 capPrice, uint256 multiplier);\r\n \r\n    // Fee change event\r\n    event FeeChange(uint256 indexed makerFee, uint256 indexed takerFee);\r\n\r\n    // Log event, logs errors in contract execution (for internal use)\r\n    event LogError(uint8 indexed errorId, bytes32 indexed makerOrderHash, bytes32 indexed takerOrderHash);\r\n    event LogErrorLight(uint8 indexed errorId);\r\n    event LogUint(uint8 id, uint256 value);\r\n    event LogBool(uint8 id, bool value);\r\n    event LogAddress(uint8 id, address value);\r\n\r\n\r\n    // Constructor function, initializes the contract and sets the core variables\r\n    function Exchange(address feeAccount_, uint256 makerFee_, uint256 takerFee_, address exchangeContract_, address DmexOracleContract_) {\r\n        owner               = msg.sender;\r\n        feeAccount          = feeAccount_;\r\n        makerFee            = makerFee_;\r\n        takerFee            = takerFee_;\r\n\r\n        exchangeContract    = exchangeContract_;\r\n        DmexOracleContract    = DmexOracleContract_;\r\n    }\r\n\r\n    // Changes the fees\r\n    function setFees(uint256 makerFee_, uint256 takerFee_) onlyOwner {\r\n        require(makerFee_       < 10 finney && takerFee_ < 10 finney); // The fees cannot be set higher then 1%\r\n        makerFee                = makerFee_;\r\n        takerFee                = takerFee_;\r\n\r\n        emit FeeChange(makerFee, takerFee);\r\n    }\r\n\r\n    // Adds or disables an admin account\r\n    function setAdmin(address admin, bool isAdmin) onlyOwner {\r\n        admins[admin] = isAdmin;\r\n    }\r\n\r\n    // Allows for admins only to call the function\r\n    modifier onlyAdmin {\r\n        if (msg.sender != owner && !admins[msg.sender]) throw;\r\n        _;\r\n    }\r\n\r\n    function() external {\r\n        throw;\r\n    }   \r\n\r\n\r\n    function validateUint48(uint256 val) returns (bool)\r\n    {\r\n        if (val != uint48(val)) return false;\r\n        return true;\r\n    }\r\n\r\n    function validateUint64(uint256 val) returns (bool)\r\n    {\r\n        if (val != uint64(val)) return false;\r\n        return true;\r\n    }\r\n\r\n    function validateUint128(uint256 val) returns (bool)\r\n    {\r\n        if (val != uint128(val)) return false;\r\n        return true;\r\n    }\r\n\r\n\r\n    // Structure that holds order values, used inside the trade() function\r\n    struct FuturesOrderPair {\r\n        uint256 makerNonce;                 // maker order nonce, makes the order unique\r\n        uint256 takerNonce;                 // taker order nonce\r\n        uint256 takerGasFee;                // taker gas fee, taker pays the gas\r\n        uint256 takerIsBuying;              // true/false taker is the buyer\r\n\r\n        address maker;                      // address of the maker\r\n        address taker;                      // address of the taker\r\n\r\n        bytes32 makerOrderHash;             // hash of the maker order\r\n        bytes32 takerOrderHash;             // has of the taker order\r\n\r\n        uint256 makerAmount;                // trade amount for maker\r\n        uint256 takerAmount;                // trade amount for taker\r\n\r\n        uint256 makerPrice;                 // maker order price in wei (18 decimal precision)\r\n        uint256 takerPrice;                 // taker order price in wei (18 decimal precision)\r\n\r\n        bytes32 futuresContract;            // the futures contract being traded\r\n\r\n        address baseToken;                  // the address of the base token for futures contract\r\n        uint256 floorPrice;                 // floor price of futures contract\r\n        uint256 capPrice;                   // cap price of futures contract\r\n\r\n        bytes32 makerPositionHash;          // hash for maker position\r\n        bytes32 makerInversePositionHash;   // hash for inverse maker position \r\n\r\n        bytes32 takerPositionHash;          // hash for taker position\r\n        bytes32 takerInversePositionHash;   // hash for inverse taker position\r\n    }\r\n\r\n    // Structure that holds trade values, used inside the trade() function\r\n    struct FuturesTradeValues {\r\n        uint256 qty;                // amount to be trade\r\n        uint256 makerProfit;        // holds maker profit value\r\n        uint256 makerLoss;          // holds maker loss value\r\n        uint256 takerProfit;        // holds taker profit value\r\n        uint256 takerLoss;          // holds taker loss value\r\n        uint256 makerBalance;       // holds maker balance value\r\n        uint256 takerBalance;       // holds taker balance value\r\n        uint256 makerReserve;       // holds taker reserved value\r\n        uint256 takerReserve;       // holds taker reserved value\r\n    }\r\n\r\n    // Opens/closes futures positions\r\n    function futuresTrade(\r\n        uint8[2] v,\r\n        bytes32[4] rs,\r\n        uint256[8] tradeValues,\r\n        address[2] tradeAddresses,\r\n        bool takerIsBuying,\r\n        bytes32 futuresContractHash\r\n    ) onlyAdmin returns (uint filledTakerTokenAmount)\r\n    {\r\n        /* tradeValues\r\n          [0] makerNonce\r\n          [1] takerNonce\r\n          [2] takerGasFee\r\n          [3] takerIsBuying\r\n          [4] makerAmount\r\n          [5] takerAmount\r\n          [6] makerPrice\r\n          [7] takerPrice\r\n\r\n          tradeAddresses\r\n          [0] maker\r\n          [1] taker\r\n        */\r\n\r\n        FuturesOrderPair memory t  = FuturesOrderPair({\r\n            makerNonce      : tradeValues[0],\r\n            takerNonce      : tradeValues[1],\r\n            takerGasFee     : tradeValues[2],\r\n            takerIsBuying   : tradeValues[3],\r\n            makerAmount     : tradeValues[4],      \r\n            takerAmount     : tradeValues[5],   \r\n            makerPrice      : tradeValues[6],         \r\n            takerPrice      : tradeValues[7],\r\n\r\n            maker           : tradeAddresses[0],\r\n            taker           : tradeAddresses[1],\r\n\r\n            //                                futuresContract      user               amount          price           side             nonce\r\n            makerOrderHash  : keccak256(this, futuresContractHash, tradeAddresses[0], tradeValues[4], tradeValues[6], !takerIsBuying, tradeValues[0]),\r\n            takerOrderHash  : keccak256(this, futuresContractHash, tradeAddresses[1], tradeValues[5], tradeValues[7],  takerIsBuying, tradeValues[1]),            \r\n\r\n            futuresContract : futuresContractHash,\r\n\r\n            baseToken       : futuresAssets[futuresContracts[futuresContractHash].asset].baseToken,\r\n            floorPrice      : futuresContracts[futuresContractHash].floorPrice,\r\n            capPrice        : futuresContracts[futuresContractHash].capPrice,\r\n\r\n            //                                            user               futuresContractHash   side\r\n            makerPositionHash           : keccak256(this, tradeAddresses[0], futuresContractHash, !takerIsBuying),\r\n            makerInversePositionHash    : keccak256(this, tradeAddresses[0], futuresContractHash, takerIsBuying),\r\n\r\n            takerPositionHash           : keccak256(this, tradeAddresses[1], futuresContractHash, takerIsBuying),\r\n            takerInversePositionHash    : keccak256(this, tradeAddresses[1], futuresContractHash, !takerIsBuying)\r\n\r\n        });\r\n\r\n//--> 44 000\r\n    \r\n        // Valifate size and price values\r\n        if (!validateUint128(t.makerAmount) || !validateUint128(t.takerAmount) || !validateUint64(t.makerPrice) || !validateUint64(t.takerPrice))\r\n        {            \r\n            emit LogError(uint8(Errors.UINT48_VALIDATION), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; \r\n        }\r\n\r\n\r\n        // Check if futures contract has expired already\r\n        if (block.number > futuresContracts[t.futuresContract].expirationBlock || futuresContracts[t.futuresContract].closed == true || futuresContracts[t.futuresContract].broken == true)\r\n        {\r\n            emit LogError(uint8(Errors.FUTURES_CONTRACT_EXPIRED), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // futures contract is expired\r\n        }\r\n\r\n        // Checks the signature for the maker order\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.makerOrderHash), v[0], rs[0], rs[1]) != t.maker)\r\n        {\r\n            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n       \r\n        // Checks the signature for the taker order\r\n        if (ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", t.takerOrderHash), v[1], rs[2], rs[3]) != t.taker)\r\n        {\r\n            emit LogError(uint8(Errors.INVALID_SIGNATURE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n\r\n\r\n        // check prices\r\n        if ((!takerIsBuying && t.makerPrice < t.takerPrice) || (takerIsBuying && t.takerPrice < t.makerPrice))\r\n        {\r\n            emit LogError(uint8(Errors.INVALID_PRICE), t.makerOrderHash, t.takerOrderHash);\r\n            return 0; // prices don't match\r\n        }      \r\n\r\n//--> 54 000\r\n\r\n         \r\n        \r\n\r\n        uint256[4] memory balances = DMEX_Base(exchangeContract).getMakerTakerBalances(t.baseToken, t.maker, t.taker);\r\n\r\n        // Initializing trade values structure \r\n        FuturesTradeValues memory tv = FuturesTradeValues({\r\n            qty                 : 0,\r\n            makerProfit         : 0,\r\n            makerLoss           : 0,\r\n            takerProfit         : 0,\r\n            takerLoss           : 0,\r\n            makerBalance        : balances[0], \r\n            takerBalance        : balances[1],  \r\n            makerReserve        : balances[2],  \r\n            takerReserve        : balances[3] \r\n        });\r\n\r\n//--> 60 000\r\n\r\n\r\n         \r\n\r\n        // check if floor price or cap price was reached\r\n        if (futuresContracts[t.futuresContract].floorPrice >= t.makerPrice || futuresContracts[t.futuresContract].capPrice <= t.makerPrice)\r\n        {\r\n            // attepting price outside range\r\n            emit LogError(uint8(Errors.FLOOR_OR_CAP_PRICE_REACHED), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n        // traded quantity is the smallest quantity between the maker and the taker, takes into account amounts already filled on the orders\r\n        // and open inverse positions\r\n        tv.qty = min(safeSub(t.makerAmount, orderFills[t.makerOrderHash]), safeSub(t.takerAmount, orderFills[t.takerOrderHash]));\r\n        \r\n        if (positionExists(t.makerInversePositionHash) && positionExists(t.takerInversePositionHash))\r\n        {\r\n            tv.qty = min(tv.qty, min(retrievePosition(t.makerInversePositionHash)[0], retrievePosition(t.takerInversePositionHash)[0]));\r\n        }\r\n        else if (positionExists(t.makerInversePositionHash))\r\n        {\r\n            tv.qty = min(tv.qty, retrievePosition(t.makerInversePositionHash)[0]);\r\n        }\r\n        else if (positionExists(t.takerInversePositionHash))\r\n        {\r\n            tv.qty = min(tv.qty, retrievePosition(t.takerInversePositionHash)[0]);\r\n        }\r\n\r\n       \r\n\r\n\r\n\r\n//--> 64 000       \r\n        \r\n        if (tv.qty == 0)\r\n        {\r\n            // no qty left on orders\r\n            emit LogError(uint8(Errors.ORDER_ALREADY_FILLED), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        }\r\n\r\n        // Cheks that gas fee is not higher than 10%\r\n        if (safeMul(t.takerGasFee, 20) > calculateTradeValue(tv.qty, t.makerPrice, t.futuresContract))\r\n        {\r\n            emit LogError(uint8(Errors.GAS_TOO_HIGH), t.makerOrderHash, t.takerOrderHash);\r\n            return 0;\r\n        } // takerGasFee too high\r\n\r\n\r\n//--> 66 000\r\n        \r\n\r\n       \r\n\r\n        /*------------- Maker long, Taker short -------------*/\r\n        if (!takerIsBuying)\r\n        {     \r\n            \r\n      \r\n            // position actions for maker\r\n            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\r\n            {\r\n\r\n\r\n                // check if maker has enough balance   \r\n                if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\r\n                {\r\n                    // maker out of balance\r\n                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                    return 0; \r\n                }\r\n\r\n                \r\n                \r\n                // create new position\r\n                recordNewPosition(t.makerPositionHash, tv.qty, t.makerPrice, 1, block.number);\r\n\r\n\r\n\r\n                updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken, // base token\r\n                        t.maker // make address\r\n                    ], \r\n                    t.makerPositionHash,  // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice,  // price\r\n                        makerFee, // fee\r\n                        0, // profit\r\n                        0, // loss\r\n                        tv.makerBalance, // balance\r\n                        0, // gasFee\r\n                        tv.makerReserve // reserve\r\n                    ], \r\n                    [\r\n                        true, // newPostion (if true position is new)\r\n                        true, // side (if true - long)\r\n                        false // increase position (if true)\r\n                    ]\r\n                );\r\n\r\n            } else {               \r\n                \r\n                if (positionExists(t.makerPositionHash))\r\n                {\r\n                    // check if maker has enough balance            \r\n                    if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\r\n                    {\r\n                        // maker out of balance\r\n                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                        return 0; \r\n                    }\r\n\r\n                    // increase position size\r\n                    updatePositionSize(t.makerPositionHash, safeAdd(retrievePosition(t.makerPositionHash)[0], tv.qty), t.makerPrice);\r\n                \r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,  // base token\r\n                            t.maker // make address\r\n                        ], \r\n                        t.makerPositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            makerFee, // fee\r\n                            0, // profit\r\n                            0, // loss\r\n                            tv.makerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.makerReserve // reserve\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            true, // side (if true - long)\r\n                            true // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n                else\r\n                {\r\n\r\n                    // close/partially close existing position\r\n                    updatePositionSize(t.makerInversePositionHash, safeSub(retrievePosition(t.makerInversePositionHash)[0], tv.qty), 0);\r\n                    \r\n                    \r\n\r\n                    if (t.makerPrice < retrievePosition(t.makerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        //tv.makerProfit                    = safeMul(safeSub(retrievePosition(t.makerInversePositionHash)[1], t.makerPrice), tv.qty) / t.makerPrice;\r\n                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        //tv.makerLoss                      = safeMul(safeSub(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1]), tv.qty) / t.makerPrice;    \r\n                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                        \r\n                    }\r\n\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken, // base token\r\n                            t.maker // make address\r\n                        ], \r\n                        t.makerInversePositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            makerFee, // fee\r\n                            tv.makerProfit,  // profit\r\n                            tv.makerLoss,  // loss\r\n                            tv.makerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.makerReserve // reserve\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            true, // side (if true - long)\r\n                            false // increase position (if true)\r\n                        ]\r\n                    );\r\n                }                \r\n            }\r\n\r\n           \r\n\r\n\r\n            // position actions for taker\r\n            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\r\n            {\r\n                \r\n                // check if taker has enough balance\r\n                if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\r\n                {\r\n                    // maker out of balance\r\n                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                    return 0; \r\n                }\r\n                \r\n                // create new position\r\n                recordNewPosition(t.takerPositionHash, tv.qty, t.makerPrice, 0, block.number);\r\n                \r\n                updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken, // base token\r\n                        t.taker // make address\r\n                    ], \r\n                    t.takerPositionHash, // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice,  // price\r\n                        takerFee, // fee\r\n                        0, // profit\r\n                        0,  // loss\r\n                        tv.takerBalance,  // balance\r\n                        t.takerGasFee, // gasFee\r\n                        tv.takerReserve // reserve\r\n                    ], \r\n                    [\r\n                        true, // newPostion (if true position is new)\r\n                        false, // side (if true - long)\r\n                        false // increase position (if true)\r\n                    ]\r\n                );\r\n\r\n            } else {\r\n                if (positionExists(t.takerPositionHash))\r\n                {\r\n                    // check if taker has enough balance\r\n                    //if (safeAdd(safeAdd(safeMul(safeSub(t.capPrice, t.makerPrice), tv.qty)  / t.capPrice, safeMul(tv.qty, takerFee) / (1 ether))  * 1e10, t.takerGasFee) > safeSub(balances[1],tv.takerReserve))\r\n                    if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\r\n                    {\r\n                        // maker out of balance\r\n                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                        return 0; \r\n                    }\r\n\r\n                    // increase position size\r\n                    updatePositionSize(t.takerPositionHash, safeAdd(retrievePosition(t.takerPositionHash)[0], tv.qty), t.makerPrice);\r\n                \r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,  // base token\r\n                            t.taker // make address\r\n                        ], \r\n                        t.takerPositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            takerFee, // fee\r\n                            0, // profit\r\n                            0, // loss\r\n                            tv.takerBalance, // balance\r\n                            t.takerGasFee, // gasFee\r\n                            tv.takerReserve // reserve\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            false, // side (if true - long)\r\n                            true // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n                else\r\n                {    \r\n                    // close/partially close existing position\r\n                    updatePositionSize(t.takerInversePositionHash, safeSub(retrievePosition(t.takerInversePositionHash)[0], tv.qty), 0);\r\n                    \r\n                    if (t.makerPrice > retrievePosition(t.takerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, false); \r\n                    }\r\n\r\n                  \r\n\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken, // base token\r\n                            t.taker // make address\r\n                        ], \r\n                        t.takerInversePositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            takerFee, // fee\r\n                            tv.takerProfit, // profit\r\n                            tv.takerLoss, // loss\r\n                            tv.takerBalance,  // balance\r\n                            t.takerGasFee,  // gasFee\r\n                            tv.takerReserve // reserve\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            false, // side (if true - long)\r\n                            false // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        /*------------- Maker short, Taker long -------------*/\r\n\r\n        else\r\n        {      \r\n            // position actions for maker\r\n            if (!positionExists(t.makerInversePositionHash) && !positionExists(t.makerPositionHash))\r\n            {\r\n                // check if maker has enough balance\r\n                if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\r\n                {\r\n                    // maker out of balance\r\n                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                    return 0; \r\n                }\r\n\r\n                // create new position\r\n                recordNewPosition(t.makerPositionHash, tv.qty, t.makerPrice, 0, block.number);\r\n                updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken,   // base token\r\n                        t.maker // make address\r\n                    ], \r\n                    t.makerPositionHash, // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice, // price\r\n                        makerFee, // fee\r\n                        0, // profit\r\n                        0, // loss\r\n                        tv.makerBalance, // balance\r\n                        0, // gasFee\r\n                        tv.makerReserve // reserve\r\n                    ], \r\n                    [\r\n                        true, // newPostion (if true position is new)\r\n                        false, // side (if true - long)\r\n                        false // increase position (if true)\r\n                    ]\r\n                );\r\n\r\n            } else {\r\n                if (positionExists(t.makerPositionHash))\r\n                {\r\n                    // check if maker has enough balance\r\n                    if (!checkEnoughBalance(t.capPrice, t.makerPrice, tv.qty, false, makerFee, 0, futuresContractHash, safeSub(balances[0],tv.makerReserve)))\r\n                    {\r\n                        // maker out of balance\r\n                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                        return 0; \r\n                    }\r\n\r\n                    // increase position size\r\n                    updatePositionSize(t.makerPositionHash, safeAdd(retrievePosition(t.makerPositionHash)[0], tv.qty), t.makerPrice);\r\n                \r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,  // base token\r\n                            t.maker // make address\r\n                        ], \r\n                        t.makerPositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            makerFee, // fee\r\n                            0, // profit\r\n                            0, // loss\r\n                            tv.makerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.makerReserve // reserve\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            false, // side (if true - long)\r\n                            true // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n                else\r\n                {\r\n\r\n                    // close/partially close existing position\r\n                    updatePositionSize(t.makerInversePositionHash, safeSub(retrievePosition(t.makerInversePositionHash)[0], tv.qty), 0);       \r\n                    \r\n\r\n\r\n                    if (t.makerPrice > retrievePosition(t.makerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.makerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.makerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.makerInversePositionHash)[1], tv.qty, futuresContractHash, false);                               \r\n                    }\r\n\r\n                   \r\n\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken, // base token\r\n                            t.maker // user address\r\n                        ], \r\n                        t.makerInversePositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            makerFee, // fee\r\n                            tv.makerProfit,  // profit\r\n                            tv.makerLoss, // loss\r\n                            tv.makerBalance, // balance\r\n                            0, // gasFee\r\n                            tv.makerReserve // reserve\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            false, // side (if true - long)\r\n                            false // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n            }\r\n\r\n            // position actions for taker\r\n            if (!positionExists(t.takerInversePositionHash) && !positionExists(t.takerPositionHash))\r\n            {\r\n                // check if taker has enough balance\r\n                if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\r\n                {\r\n                    // maker out of balance\r\n                    emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                    return 0; \r\n                }\r\n\r\n                // create new position\r\n                recordNewPosition(t.takerPositionHash, tv.qty, t.makerPrice, 1, block.number);\r\n           \r\n                updateBalances(\r\n                    t.futuresContract, \r\n                    [\r\n                        t.baseToken,  // base token\r\n                        t.taker // user address\r\n                    ], \r\n                    t.takerPositionHash, // position hash\r\n                    [\r\n                        tv.qty, // qty\r\n                        t.makerPrice, // price\r\n                        takerFee, // fee\r\n                        0,  // profit\r\n                        0,  // loss\r\n                        tv.takerBalance, // balance\r\n                        t.takerGasFee, // gasFee\r\n                        tv.takerReserve // reserve\r\n                    ], \r\n                    [\r\n                        true, // newPostion (if true position is new)\r\n                        true, // side (if true - long)\r\n                        false // increase position (if true)\r\n                    ]\r\n                );\r\n\r\n            } else {\r\n                if (positionExists(t.takerPositionHash))\r\n                {\r\n                    // check if taker has enough balance\r\n                    if (!checkEnoughBalance(t.floorPrice, t.makerPrice, tv.qty, true, takerFee, t.takerGasFee, futuresContractHash, safeSub(balances[1],tv.takerReserve)))\r\n                    {\r\n                        // maker out of balance\r\n                        emit LogError(uint8(Errors.OUT_OF_BALANCE), t.makerOrderHash, t.takerOrderHash);\r\n                        return 0; \r\n                    }\r\n                    \r\n                    // increase position size\r\n                    updatePositionSize(t.takerPositionHash, safeAdd(retrievePosition(t.takerPositionHash)[0], tv.qty), t.makerPrice);\r\n                \r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,  // base token\r\n                            t.taker // user address\r\n                        ], \r\n                        t.takerPositionHash, // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            takerFee, // fee\r\n                            0, // profit\r\n                            0, // loss\r\n                            tv.takerBalance, // balance\r\n                            t.takerGasFee, // gasFee\r\n                            tv.takerReserve // reserve\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            true, // side (if true - long)\r\n                            true // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n                else\r\n                {\r\n\r\n                    // close/partially close existing position\r\n                    updatePositionSize(t.takerInversePositionHash, safeSub(retrievePosition(t.takerInversePositionHash)[0], tv.qty), 0);\r\n                                     \r\n                    if (t.makerPrice < retrievePosition(t.takerInversePositionHash)[1])\r\n                    {\r\n                        // user has made a profit\r\n                        tv.takerProfit                      = calculateProfit(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);\r\n                    }\r\n                    else\r\n                    {\r\n                        // user has made a loss\r\n                        tv.takerLoss                        = calculateLoss(t.makerPrice, retrievePosition(t.takerInversePositionHash)[1], tv.qty, futuresContractHash, true);                                  \r\n                    }\r\n\r\n                    \r\n\r\n                    updateBalances(\r\n                        t.futuresContract, \r\n                        [\r\n                            t.baseToken,   // base toke\r\n                            t.taker // user address\r\n                        ], \r\n                        t.takerInversePositionHash,  // position hash\r\n                        [\r\n                            tv.qty, // qty\r\n                            t.makerPrice, // price\r\n                            takerFee, // fee\r\n                            tv.takerProfit, // profit\r\n                            tv.takerLoss, // loss\r\n                            tv.takerBalance, // balance\r\n                            t.takerGasFee, // gasFee\r\n                            tv.takerReserve // reserve\r\n                        ], \r\n                        [\r\n                            false, // newPostion (if true position is new)\r\n                            true, // side (if true - long) \r\n                            false // increase position (if true)\r\n                        ]\r\n                    );\r\n                }\r\n            }           \r\n        }\r\n\r\n//--> 220 000\r\n        orderFills[t.makerOrderHash]            = safeAdd(orderFills[t.makerOrderHash], tv.qty); // increase the maker order filled amount\r\n        orderFills[t.takerOrderHash]            = safeAdd(orderFills[t.takerOrderHash], tv.qty); // increase the taker order filled amount\r\n\r\n//--> 264 000\r\n        emit FuturesTrade(takerIsBuying, tv.qty, t.makerPrice, t.futuresContract, t.makerOrderHash, t.takerOrderHash);\r\n\r\n        return tv.qty;\r\n    }\r\n\r\n\r\n    function calculateProfit(uint256 closingPrice, uint256 entryPrice, uint256 qty, bytes32 futuresContractHash, bool side) returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n\r\n        if (side)\r\n        {           \r\n            return safeMul(safeMul(safeSub(entryPrice, closingPrice), qty), multiplier)  / 1e8 / 1e18;            \r\n        }\r\n        else\r\n        {\r\n            return safeMul(safeMul(safeSub(closingPrice, entryPrice), qty), multiplier)  / 1e8 / 1e18; \r\n        }       \r\n    }\r\n\r\n    function calculateTradeValue(uint256 qty, uint256 price, bytes32 futuresContractHash) returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        return safeMul(safeMul(safeMul(qty, price), 1e2), multiplier) / 1e18 ;\r\n    }\r\n\r\n\r\n\r\n    function calculateLoss(uint256 closingPrice, uint256 entryPrice, uint256 qty,  bytes32 futuresContractHash, bool side) returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n\r\n        if (side)\r\n        {\r\n            return safeMul(safeMul(safeSub(closingPrice, entryPrice), qty), multiplier) / 1e8 / 1e18;\r\n        }\r\n        else\r\n        {\r\n            return safeMul(safeMul(safeSub(entryPrice, closingPrice), qty), multiplier) / 1e8 / 1e18; \r\n        }\r\n        \r\n    }\r\n\r\n    function calculateCollateral (uint256 limitPrice, uint256 tradePrice, uint256 qty, bool side, bytes32 futuresContractHash) view returns (uint256)\r\n    {\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        uint256 fundingCost;\r\n        uint256 collateral;\r\n\r\n        if (side)\r\n        {    \r\n            //fundingCost = calculateFundingCost(tradePrice, qty, fundingBlocks, futuresContractHash);\r\n            collateral = safeMul(safeMul(safeSub(tradePrice, limitPrice), qty), multiplier) / 1e8 / 1e18;\r\n\r\n            return collateral; //safeAdd(collateral, fundingCost);\r\n        }\r\n        else\r\n        {\r\n            //fundingCost = calculateFundingCost(tradePrice, qty, fundingBlocks, futuresContractHash);\r\n            collateral = safeMul(safeMul(safeSub(limitPrice, tradePrice), qty), multiplier) / 1e8 / 1e18;\r\n            \r\n            return collateral; // safeAdd(collateral, fundingCost);\r\n        }         \r\n    }\r\n\r\n    function calculateFundingCost (uint256 price, uint256 qty, uint256 fundingBlocks, bytes32 futuresContractHash) returns (uint256)\r\n    {\r\n        uint256 fundingRate = futuresContracts[futuresContractHash].fundingRate;\r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n\r\n        uint256 fundingCost = safeMul(safeMul(safeMul(min(0,fundingBlocks), fundingRate), safeMul(qty, price))/1e16, multiplier)/1e28;\r\n\r\n        return fundingCost;  \r\n    }\r\n\r\n    function calculateFee (uint256 qty, uint256 tradePrice, uint256 fee, bytes32 futuresContractHash) returns (uint256)\r\n    {\r\n        return safeMul(calculateTradeValue(qty, tradePrice, futuresContractHash), fee) / 1e18 / 1e10;\r\n    }\r\n\r\n\r\n    function checkEnoughBalance (uint256 limitPrice, uint256 tradePrice, uint256 qty, bool side, uint256 fee, uint256 gasFee, bytes32 futuresContractHash, uint256 availableBalance) view returns (bool)\r\n    {\r\n        \r\n        uint256 multiplier = futuresContracts[futuresContractHash].multiplier;\r\n        uint256 expirationBlock = futuresContracts[futuresContractHash].expirationBlock;\r\n\r\n        uint256 tradeFee = calculateFee(qty, tradePrice, fee, futuresContractHash);\r\n        uint256 collateral = calculateCollateral(limitPrice, tradePrice, qty, side, futuresContractHash);\r\n        uint256 fundingCost = calculateFundingCost(tradePrice, qty, safeSub(expirationBlock, min(block.number, expirationBlock)), futuresContractHash);\r\n\r\n        if (safeAdd(\r\n                safeMul(\r\n                    safeAdd(\r\n                        collateral, \r\n                        tradeFee\r\n                    ),\r\n                    1e10\r\n                ),                     \r\n                safeAdd(\r\n                    gasFee,\r\n                    safeMul(\r\n                        fundingCost,\r\n                        1e10\r\n                    )                        \r\n                ) \r\n            ) > availableBalance)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }  \r\n\r\n      \r\n\r\n    // Executes multiple trades in one transaction, saves gas fees\r\n    function batchFuturesTrade(\r\n        uint8[2][] v,\r\n        bytes32[4][] rs,\r\n        uint256[8][] tradeValues,\r\n        address[2][] tradeAddresses,\r\n        bool[] takerIsBuying,\r\n        bytes32[] assetHash,\r\n        uint256[5][] contractValues\r\n    ) onlyAdmin\r\n    {\r\n        // perform trades\r\n        for (uint i = 0; i < tradeAddresses.length; i++) {\r\n            futuresTrade(\r\n                v[i],\r\n                rs[i],\r\n                tradeValues[i],\r\n                tradeAddresses[i],\r\n                takerIsBuying[i],\r\n                createFuturesContract(assetHash[i], contractValues[i][0], contractValues[i][1], contractValues[i][2], contractValues[i][3], contractValues[i][4])\r\n            );\r\n        }\r\n    }\r\n\r\n    \r\n\r\n\r\n    // Update user balance\r\n    function updateBalances (bytes32 futuresContract, address[2] addressValues, bytes32 positionHash, uint256[8] uintValues, bool[3] boolValues) private\r\n    {\r\n        /*\r\n            addressValues\r\n            [0] baseToken\r\n            [1] user\r\n\r\n            uintValues\r\n            [0] qty\r\n            [1] price\r\n            [2] fee\r\n            [3] profit\r\n            [4] loss\r\n            [5] balance\r\n            [6] gasFee\r\n            [7] reserve\r\n\r\n            boolValues\r\n            [0] newPostion\r\n            [1] side\r\n            [2] increase position\r\n\r\n        */\r\n\r\n        // pam = [fee value, collateral, fundignCost, payableFundingCost]                        \r\n        uint256[4] memory pam = [\r\n            safeAdd(calculateFee(uintValues[0], uintValues[1], uintValues[2], futuresContract) * 1e10, uintValues[6]), \r\n            0,\r\n            0,\r\n            0\r\n        ];\r\n               \r\n        if (boolValues[0] || boolValues[2])  \r\n        {\r\n            // Position is new or position is increased\r\n            if (boolValues[1])\r\n            {\r\n                pam[1] = calculateCollateral(futuresContracts[futuresContract].floorPrice, uintValues[1], uintValues[0], true, futuresContract);\r\n            }\r\n            else\r\n            {\r\n                pam[1] = calculateCollateral(futuresContracts[futuresContract].capPrice, uintValues[1], uintValues[0], false, futuresContract);\r\n            }\r\n\r\n            pam[2] = calculateFundingCost(uintValues[1], uintValues[0], safeSub(futuresContracts[futuresContract].expirationBlock, block.number), futuresContract);\r\n\r\n            \r\n\r\n            subBalanceAddReserve(addressValues[0], addressValues[1], pam[0], safeAdd(safeAdd(pam[1], pam[2]),1));         \r\n        } \r\n        else \r\n        {\r\n            // Position exists, decreasing\r\n            if (retrievePosition(positionHash)[2] == 0)\r\n            {\r\n                // original position was short\r\n                pam[1] = calculateCollateral(futuresContracts[futuresContract].capPrice, retrievePosition(positionHash)[1], uintValues[0], false, futuresContract);                          \r\n            }\r\n            else\r\n            {                            \r\n                // original position was long\r\n                pam[1] = calculateCollateral(futuresContracts[futuresContract].floorPrice, retrievePosition(positionHash)[1], uintValues[0], true, futuresContract);\r\n            }\r\n\r\n            pam[2] = calculateFundingCost(retrievePosition(positionHash)[1], uintValues[0], safeSub(futuresContracts[futuresContract].expirationBlock, retrievePosition(positionHash)[3]+1), futuresContract); \r\n            pam[3] = safeMul(1e10, calculateFundingCost(retrievePosition(positionHash)[1], uintValues[0], safeSub(futuresContracts[futuresContract].expirationBlock, retrievePosition(positionHash)[3]), futuresContract));   \r\n\r\n\r\n            if (uintValues[3] > 0) \r\n            {\r\n                // profi > 0\r\n                if (safeAdd(pam[0], pam[2]) <= safeMul(uintValues[3],1e10))\r\n                {\r\n                    addBalanceSubReserve(addressValues[0], addressValues[1], safeSub(safeMul(uintValues[3],1e10), safeAdd(pam[0], pam[3])), safeAdd(pam[1], pam[2]));\r\n                }\r\n                else\r\n                {\r\n                    subBalanceSubReserve(addressValues[0], addressValues[1], safeSub(safeAdd(pam[0], pam[3]), safeMul(uintValues[3],1e10)), safeAdd(pam[1], pam[2]));\r\n                }                \r\n            } \r\n            else \r\n            {   \r\n                // loss >= 0\r\n                subBalanceSubReserve(addressValues[0], addressValues[1], safeAdd(safeMul(uintValues[4],1e10), safeAdd(pam[0], pam[3])), safeAdd(pam[1], pam[2])); // deduct loss from user balance\r\n            }           \r\n        }          \r\n        \r\n        addBalance(addressValues[0], feeAccount, DMEX_Base(exchangeContract).balanceOf(addressValues[0], feeAccount), safeAdd(pam[0], pam[3])); // send fee to feeAccount\r\n    }\r\n\r\n    function recordNewPosition (bytes32 positionHash, uint256 size, uint256 price, uint256 side, uint256 block) private\r\n    {\r\n        if (!validateUint128(size) || !validateUint64(price)) \r\n        {\r\n            throw;\r\n        }\r\n\r\n        uint256 character = uint128(size);\r\n        character |= price<<128;\r\n        character |= side<<192;\r\n        character |= block<<208;\r\n\r\n        positions[positionHash] = character;\r\n    }\r\n\r\n    function retrievePosition (bytes32 positionHash) public view returns (uint256[4])\r\n    {\r\n        uint256 character = positions[positionHash];\r\n        uint256 size = uint256(uint128(character));\r\n        uint256 price = uint256(uint64(character>>128));\r\n        uint256 side = uint256(uint16(character>>192));\r\n        uint256 entryBlock = uint256(uint48(character>>208));\r\n\r\n        return [size, price, side, entryBlock];\r\n    }\r\n\r\n    function updatePositionSize(bytes32 positionHash, uint256 size, uint256 price) private\r\n    {\r\n        uint256[4] memory pos = retrievePosition(positionHash);\r\n\r\n        if (size > pos[0])\r\n        {\r\n            uint256 totalValue = safeAdd(safeMul(pos[0], pos[1]), safeMul(price, safeSub(size, pos[0])));\r\n\r\n\r\n            // position is increasing in size\r\n            recordNewPosition(\r\n                positionHash, \r\n                size, \r\n                totalValue / size, \r\n                pos[2], \r\n                pos[3]//safeAdd(safeMul(safeMul(pos[0], pos[1]), pos[3]), safeMul(safeMul(price, safeSub(size, pos[0])), block.number)) / totalValue\r\n            );\r\n        }\r\n        else\r\n        {\r\n            // position is decreasing in size\r\n            recordNewPosition(\r\n                positionHash, \r\n                size, \r\n                pos[1], \r\n                pos[2], \r\n                pos[3]\r\n            );\r\n        }        \r\n    }\r\n\r\n    function positionExists (bytes32 positionHash) internal view returns (bool)\r\n    {\r\n        if (retrievePosition(positionHash)[0] == 0)\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    // This function allows the user to manually release collateral in case the oracle service does not provide the price during the inactivityReleasePeriod\r\n    function forceReleaseReserve (bytes32 futuresContract, bool side) public\r\n    {   \r\n        if (futuresContracts[futuresContract].expirationBlock == 0) throw;       \r\n        if (futuresContracts[futuresContract].expirationBlock > block.number) throw;\r\n        if (safeAdd(futuresContracts[futuresContract].expirationBlock, DMEX_Base(exchangeContract).getInactivityReleasePeriod()) > block.number) throw;  \r\n\r\n        bytes32 positionHash = keccak256(this, msg.sender, futuresContract, side);\r\n        if (retrievePosition(positionHash)[1] == 0) throw;    \r\n  \r\n\r\n        futuresContracts[futuresContract].broken = true;\r\n\r\n        uint256[4] memory pos = retrievePosition(positionHash);\r\n        FuturesContract cont = futuresContracts[futuresContract];\r\n        address baseToken = futuresAssets[cont.asset].baseToken;\r\n\r\n        uint256 reservedFunding = calculateFundingCost(pos[1], pos[0], safeSub(cont.expirationBlock, pos[3]+1), futuresContract);\r\n        uint256 collateral;\r\n\r\n        if (side)\r\n        {\r\n            collateral = calculateCollateral(cont.floorPrice, pos[1], pos[0], true, futuresContract);\r\n\r\n            subReserve(\r\n                baseToken, \r\n                msg.sender, \r\n                DMEX_Base(exchangeContract).getReserve(baseToken, msg.sender), \r\n                safeAdd(reservedFunding, collateral)\r\n            ); \r\n        }\r\n        else\r\n        {         \r\n            collateral = calculateCollateral(cont.capPrice, pos[1], pos[0], false, futuresContract);\r\n               \r\n            subReserve(\r\n                baseToken, \r\n                msg.sender, \r\n                DMEX_Base(exchangeContract).getReserve(baseToken, msg.sender), \r\n                safeAdd(reservedFunding, collateral)\r\n            ); \r\n        }\r\n\r\n        updatePositionSize(positionHash, 0, 0);\r\n\r\n        emit FuturesForcedRelease(futuresContract, side, msg.sender);\r\n\r\n    }\r\n\r\n    function addBalance(address token, address user, uint256 balance, uint256 amount) private\r\n    {\r\n        DMEX_Base(exchangeContract).setBalance(token, user, safeAdd(balance, amount));\r\n    }\r\n\r\n    function subBalance(address token, address user, uint256 balance, uint256 amount) private\r\n    {\r\n        DMEX_Base(exchangeContract).setBalance(token, user, safeSub(balance, amount));\r\n    }\r\n\r\n    function subBalanceAddReserve(address token, address user, uint256 subBalance, uint256 addReserve) private\r\n    {\r\n        DMEX_Base(exchangeContract).subBalanceAddReserve(token, user, subBalance, safeMul(addReserve, 1e10));\r\n    }\r\n\r\n    function addBalanceSubReserve(address token, address user, uint256 addBalance, uint256 subReserve) private\r\n    {\r\n\r\n        DMEX_Base(exchangeContract).addBalanceSubReserve(token, user, addBalance, safeMul(subReserve, 1e10));\r\n    }\r\n\r\n    function subBalanceSubReserve(address token, address user, uint256 subBalance, uint256 subReserve) private\r\n    {\r\n        DMEX_Base(exchangeContract).subBalanceSubReserve(token, user, subBalance, safeMul(subReserve, 1e10));\r\n    }\r\n\r\n    function addReserve(address token, address user, uint256 reserve, uint256 amount) private\r\n    {\r\n        DMEX_Base(exchangeContract).setReserve(token, user, safeAdd(reserve, safeMul(amount, 1e10)));\r\n    }\r\n\r\n    function subReserve(address token, address user, uint256 reserve, uint256 amount) private \r\n    {\r\n        DMEX_Base(exchangeContract).setReserve(token, user, safeSub(reserve, safeMul(amount, 1e10)));\r\n    }\r\n\r\n\r\n    function getMakerTakerBalances(address maker, address taker, address token) public view returns (uint256[4])\r\n    {\r\n        return [\r\n            DMEX_Base(exchangeContract).balanceOf(token, maker),\r\n            DMEX_Base(exchangeContract).getReserve(token, maker),\r\n            DMEX_Base(exchangeContract).balanceOf(token, taker),\r\n            DMEX_Base(exchangeContract).getReserve(token, taker)\r\n        ];\r\n    }\r\n\r\n    function getMakerTakerPositions(bytes32 makerPositionHash, bytes32 makerInversePositionHash, bytes32 takerPosition, bytes32 takerInversePosition) public view returns (uint256[4][4])\r\n    {\r\n        return [\r\n            retrievePosition(makerPositionHash),\r\n            retrievePosition(makerInversePositionHash),\r\n            retrievePosition(takerPosition),\r\n            retrievePosition(takerInversePosition)\r\n        ];\r\n    }\r\n\r\n\r\n    struct FuturesClosePositionValues {\r\n        uint256 reserve;                // amount to be trade\r\n        uint256 balance;                // holds maker profit value\r\n        uint256 floorPrice;             // holds maker loss value\r\n        uint256 capPrice;               // holds taker profit value\r\n        uint256 closingPrice;           // holds taker loss value\r\n        bytes32 futuresContract;        // the futures contract hash\r\n        uint256 expirationBlock;        // the expiration block for the contract\r\n        uint256 entryBlock;             // the entry block for the position\r\n        uint256 collateral;             // reserved collateral\r\n        uint256 reservedFunding;        // reserved funding cost\r\n        uint256 payableFunding;         // spent funding cost\r\n    }\r\n\r\n\r\n    function closeFuturesPosition(bytes32 futuresContract, bool side)\r\n    {\r\n        closeFuturesPositionInternal(futuresContract, side, msg.sender, 0);\r\n    }\r\n\r\n    function closeFuturesPositionInternal (bytes32 futuresContract, bool side, address user, uint256 gasFee) private returns (bool)\r\n    {\r\n        bytes32 positionHash = keccak256(this, user, futuresContract, side);        \r\n\r\n        if (futuresContracts[futuresContract].closed == false && futuresContracts[futuresContract].expirationBlock != 0) throw; // contract not yet settled\r\n        if (retrievePosition(positionHash)[1] == 0) throw; // position not found\r\n        if (retrievePosition(positionHash)[0] == 0) throw; // position already closed\r\n\r\n        // failsafe, gas fee cannot be greater than 5% of position value\r\n        if (safeMul(gasFee * 1e10, 20) > calculateTradeValue(retrievePosition(positionHash)[0], retrievePosition(positionHash)[1], futuresContract))\r\n        {\r\n            emit LogError(uint8(Errors.GAS_TOO_HIGH), futuresContract, positionHash);\r\n            return false;\r\n        }\r\n\r\n        uint256 profit;\r\n        uint256 loss;\r\n\r\n        address baseToken = futuresAssets[futuresContracts[futuresContract].asset].baseToken;\r\n\r\n        FuturesClosePositionValues memory v = FuturesClosePositionValues({\r\n            reserve         : DMEX_Base(exchangeContract).getReserve(baseToken, user),\r\n            balance         : DMEX_Base(exchangeContract).balanceOf(baseToken, user),\r\n            floorPrice      : futuresContracts[futuresContract].floorPrice,\r\n            capPrice        : futuresContracts[futuresContract].capPrice,\r\n            closingPrice    : futuresContracts[futuresContract].closingPrice,\r\n            futuresContract : futuresContract,\r\n            expirationBlock : futuresContracts[futuresContract].expirationBlock,\r\n            entryBlock      : retrievePosition(positionHash)[3],\r\n            collateral      : 0,\r\n            reservedFunding : 0,\r\n            payableFunding  : 0\r\n        });\r\n\r\n        \r\n        //uint256 fee = calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract);\r\n        uint256 fee = safeAdd(calculateFee(retrievePosition(positionHash)[0], v.closingPrice, takerFee, futuresContract), gasFee);\r\n\r\n\r\n        // close long position\r\n        if (side == true)\r\n        {     \r\n            \r\n            v.collateral = calculateCollateral(v.floorPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], true, v.futuresContract);\r\n            v.reservedFunding = calculateFundingCost(retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], safeSub(v.expirationBlock, v.entryBlock+1), futuresContract);\r\n            v.payableFunding = calculateFundingCost(retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], safeSub(min(v.expirationBlock, block.number), v.entryBlock+1), futuresContract);\r\n\r\n\r\n            subReserve(\r\n                baseToken, \r\n                user, \r\n                v.reserve, \r\n                safeAdd(v.collateral, v.reservedFunding)\r\n            );\r\n            \r\n\r\n            if (v.closingPrice > retrievePosition(positionHash)[1])\r\n            {   \r\n                \r\n                // user made a profit\r\n                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);\r\n          \r\n                if (profit > safeAdd(fee, v.payableFunding))\r\n                {\r\n                    addBalance(baseToken, user, v.balance, safeSub(safeMul(profit, 1e10), safeMul(safeAdd(fee, v.payableFunding), 1e10))); \r\n                }\r\n                else\r\n                {\r\n                    subBalance(baseToken, user, v.balance, safeSub(safeMul(safeAdd(fee, v.payableFunding), 1e10), safeMul(profit, 1e10))); \r\n                }\r\n            }\r\n            else\r\n            {\r\n                // user made a loss\r\n                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, false);  \r\n\r\n                subBalance(baseToken, user, v.balance, safeAdd(safeMul(loss, 1e10), safeMul(safeAdd(fee, v.payableFunding), 1e10))); \r\n\r\n            }\r\n        }   \r\n        // close short position \r\n        else\r\n        {\r\n            v.collateral = calculateCollateral(v.capPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], false, v.futuresContract);\r\n            v.reservedFunding = calculateFundingCost(retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], safeSub(v.expirationBlock, v.entryBlock+1), futuresContract);\r\n            v.payableFunding = calculateFundingCost(retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], safeSub(min(v.expirationBlock, block.number), v.entryBlock+1), futuresContract);\r\n\r\n\r\n            subReserve(\r\n                baseToken, \r\n                user,  \r\n                v.reserve, \r\n                safeAdd(v.collateral, v.reservedFunding)\r\n            );\r\n\r\n            \r\n\r\n            if (v.closingPrice < retrievePosition(positionHash)[1])\r\n            {\r\n\r\n                // user made a profit\r\n                profit = calculateProfit(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);\r\n \r\n                if (profit > safeAdd(fee, v.payableFunding))\r\n                {\r\n                    addBalance(baseToken, user, v.balance, safeSub(safeMul(profit, 1e10), safeMul(safeAdd(fee, v.payableFunding), 1e10))); \r\n                }\r\n                else\r\n                {\r\n                    subBalance(baseToken, user, v.balance, safeSub(safeMul(safeAdd(fee, v.payableFunding), 1e10), safeMul(profit, 1e10))); \r\n                }\r\n\r\n            }\r\n            else\r\n            {\r\n                // user made a loss\r\n                loss = calculateLoss(v.closingPrice, retrievePosition(positionHash)[1], retrievePosition(positionHash)[0], futuresContract, true);  \r\n\r\n                subBalance(baseToken, user, v.balance, safeAdd(safeMul(loss, 1e10), safeMul(safeAdd(fee, v.payableFunding), 1e10)));\r\n\r\n            }\r\n        }  \r\n\r\n        addBalance(baseToken, feeAccount, DMEX_Base(exchangeContract).balanceOf(baseToken, feeAccount), safeMul(safeAdd(fee, v.payableFunding), 1e10)); // send fee to feeAccount\r\n        \r\n\r\n        updatePositionSize(positionHash, 0, 0);\r\n\r\n        \r\n\r\n        emit FuturesPositionClosed(positionHash, v.closingPrice);\r\n\r\n        return true;\r\n    }\r\n\r\n    function closeFuturesContract (bytes32 futuresContract, uint256 price) onlyOracle returns (bool)\r\n    {\r\n        if (futuresContracts[futuresContract].expirationBlock == 0)  return false; // contract not found\r\n        if (futuresContracts[futuresContract].closed == true)  return false; // contract already closed\r\n\r\n        if (futuresContracts[futuresContract].expirationBlock > block.number\r\n            && price > futuresContracts[futuresContract].floorPrice\r\n            && price < futuresContracts[futuresContract].capPrice) return false; // contract not yet expired and the price did not leave the range\r\n                \r\n\r\n        if (price <= futuresContracts[futuresContract].floorPrice)  \r\n        {\r\n            futuresContracts[futuresContract].closingPrice = futuresContracts[futuresContract].floorPrice; \r\n        }  \r\n        else if (price >= futuresContracts[futuresContract].capPrice)\r\n        {\r\n            futuresContracts[futuresContract].closingPrice = futuresContracts[futuresContract].capPrice;\r\n        }   \r\n        else\r\n        {\r\n            futuresContracts[futuresContract].closingPrice = price;\r\n        }         \r\n        \r\n\r\n        futuresContracts[futuresContract].closed = true;\r\n\r\n        emit FuturesContractClosed(futuresContract, futuresContracts[futuresContract].closingPrice);\r\n    }  \r\n\r\n\r\n\r\n\r\n    // closes position for user\r\n    function closeFuturesPositionForUser (bytes32 futuresContract, bool side, address user, uint256 gasFee) onlyAdmin\r\n    {\r\n        closeFuturesPositionInternal(futuresContract, side, user, gasFee);\r\n    }\r\n\r\n    // Settle positions for closed contracts\r\n    function batchSettlePositions (\r\n        bytes32[] futuresContracts,\r\n        bool[] sides,\r\n        address[] users,\r\n        uint256 gasFeePerClose // baseToken with 8 decimals\r\n    ) onlyAdmin {\r\n        \r\n        for (uint i = 0; i < futuresContracts.length; i++) \r\n        {\r\n            closeFuturesPositionForUser(futuresContracts[i], sides[i], users[i], gasFeePerClose);\r\n        }\r\n    }\r\n\r\n\r\n    \r\n    \r\n\r\n    // Returns the smaller of two values\r\n    function min(uint a, uint b) private pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"assertion\",\"type\":\"bool\"}],\"name\":\"assert\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractPriceUrl\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DmexOracleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractPricePath\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastActiveTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"tradePrice\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"gasFee\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"availableBalance\",\"type\":\"uint256\"}],\"name\":\"checkEnoughBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"validateUint48\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"takerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"futuresContracts\",\"outputs\":[{\"name\":\"asset\",\"type\":\"bytes32\"},{\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"name\":\"closingPrice\",\"type\":\"uint256\"},{\"name\":\"closed\",\"type\":\"bool\"},{\"name\":\"broken\",\"type\":\"bool\"},{\"name\":\"floorPrice\",\"type\":\"uint256\"},{\"name\":\"capPrice\",\"type\":\"uint256\"},{\"name\":\"multiplier\",\"type\":\"uint256\"},{\"name\":\"fundingRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"positions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"validateUint128\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"limitPrice\",\"type\":\"uint256\"},{\"name\":\"tradePrice\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateCollateral\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"fundingBlocks\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateFundingCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"closeFuturesContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"asset\",\"type\":\"bytes32\"},{\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"name\":\"floorPrice\",\"type\":\"uint256\"},{\"name\":\"capPrice\",\"type\":\"uint256\"},{\"name\":\"multiplier\",\"type\":\"uint256\"},{\"name\":\"fundingRate\",\"type\":\"uint256\"}],\"name\":\"createFuturesContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"out\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getMakerTakerBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"gasFee\",\"type\":\"uint256\"}],\"name\":\"closeFuturesPositionForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"getContractExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2]\"},{\"name\":\"rs\",\"type\":\"bytes32[4]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[8]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[2]\"},{\"name\":\"takerIsBuying\",\"type\":\"bool\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"futuresTrade\",\"outputs\":[{\"name\":\"filledTakerTokenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"forceReleaseReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"makerPositionHash\",\"type\":\"bytes32\"},{\"name\":\"makerInversePositionHash\",\"type\":\"bytes32\"},{\"name\":\"takerPosition\",\"type\":\"bytes32\"},{\"name\":\"takerInversePosition\",\"type\":\"bytes32\"}],\"name\":\"getMakerTakerPositions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4][4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"priceUrl\",\"type\":\"string\"},{\"name\":\"pricePath\",\"type\":\"string\"}],\"name\":\"createFuturesAsset\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContracts\",\"type\":\"bytes32[]\"},{\"name\":\"sides\",\"type\":\"bool[]\"},{\"name\":\"users\",\"type\":\"address[]\"},{\"name\":\"gasFeePerClose\",\"type\":\"uint256\"}],\"name\":\"batchSettlePositions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"closingPrice\",\"type\":\"uint256\"},{\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"calculateLoss\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8[2][]\"},{\"name\":\"rs\",\"type\":\"bytes32[4][]\"},{\"name\":\"tradeValues\",\"type\":\"uint256[8][]\"},{\"name\":\"tradeAddresses\",\"type\":\"address[2][]\"},{\"name\":\"takerIsBuying\",\"type\":\"bool[]\"},{\"name\":\"assetHash\",\"type\":\"bytes32[]\"},{\"name\":\"contractValues\",\"type\":\"uint256[5][]\"}],\"name\":\"batchFuturesTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"closingPrice\",\"type\":\"uint256\"},{\"name\":\"entryPrice\",\"type\":\"uint256\"},{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"calculateProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateTradeValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"validateUint64\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"futuresAssets\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"baseToken\",\"type\":\"address\"},{\"name\":\"priceUrl\",\"type\":\"string\"},{\"name\":\"pricePath\",\"type\":\"string\"},{\"name\":\"disabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"qty\",\"type\":\"uint256\"},{\"name\":\"tradePrice\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"futuresContractHash\",\"type\":\"bytes32\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"name\":\"side\",\"type\":\"bool\"}],\"name\":\"closeFuturesPosition\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"positionHash\",\"type\":\"bytes32\"}],\"name\":\"retrievePosition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"makerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"feeAccount_\",\"type\":\"address\"},{\"name\":\"makerFee_\",\"type\":\"uint256\"},{\"name\":\"takerFee_\",\"type\":\"uint256\"},{\"name\":\"exchangeContract_\",\"type\":\"address\"},{\"name\":\"DmexOracleContract_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"side\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"size\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"FuturesTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"positionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"closingPrice\",\"type\":\"uint256\"}],\"name\":\"FuturesPositionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"closingPrice\",\"type\":\"uint256\"}],\"name\":\"FuturesContractClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"side\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"FuturesForcedRelease\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"futuresAsset\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"baseToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceUrl\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"pricePath\",\"type\":\"string\"}],\"name\":\"FuturesAssetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"futuresContract\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"asset\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"expirationBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"capPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"multiplier\",\"type\":\"uint256\"}],\"name\":\"FuturesContractCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"makerFee\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"takerFee\",\"type\":\"uint256\"}],\"name\":\"FeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"errorId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"makerOrderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"takerOrderHash\",\"type\":\"bytes32\"}],\"name\":\"LogError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"errorId\",\"type\":\"uint8\"}],\"name\":\"LogErrorLight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogUint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"LogBool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"address\"}],\"name\":\"LogAddress\",\"type\":\"event\"}]", "ContractName": "Exchange", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000095445852148540acb6fcb9e39856d15f1c41638100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008e1bc9bf0400000000000000000000000000010591b8e3e83cd9852172f022a5a70edfb66063d000000000000000000000000370564e70554c3a8ab919b0c7340b17680333141", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://7cd2f6ce607967e3af52dae1a15285a38fd121f882184bb5a4442e5b712fb182"}