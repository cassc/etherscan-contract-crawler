{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt\\n    ) internal view returns (address predicted) {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/FERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"./lib/ERC20.sol\\\";\\nimport \\\"./interfaces/IFERC20.sol\\\";\\nimport \\\"./interfaces/IFERC721.sol\\\";\\n\\ncontract FERC20 is ERC20, IFERC20 {\\n\\t\\taddress public immutable bridgeContract;\\n\\n\\t\\tconstructor() {\\n\\t\\t\\tbridgeContract = msg.sender;\\n\\t\\t}\\n\\n    function initialize(address _ferc721Address) public {\\n\\t\\t\\t\\trequire(msg.sender == bridgeContract, \\\"only bridge factory can initialize\\\");\\n\\t\\t\\t\\tname = string(abi.encodePacked(IFERC721(_ferc721Address).symbol(), \\\" {ferc-20}\\\"));\\n\\t\\t\\t  symbol = IFERC721(_ferc721Address).symbol();\\n\\t\\t\\t\\tdecimals = 18;\\n    }\\n\\n    function mint(address account, uint256 amount) public {\\n\\t\\t\\t\\trequire(msg.sender == bridgeContract, \\\"only bridge factory can mint\\\");\\n\\t\\t\\t\\t_mint(account, amount);\\n\\t\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/Ferc721Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n \\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"./interfaces/IFERC721.sol\\\";\\nimport \\\"./interfaces/IFERC20.sol\\\";\\nimport \\\"./FERC20.sol\\\";\\n\\nerror NotCreatedByFactory();\\nerror MintNotFinished();\\nerror NotApprovedForAll();\\nerror NotCreatedByBridge();\\nerror AllowanceNotEnough();\\nerror BalanceNotEnough();\\nerror NotMultipleOfLimit();\\nerror WithdrawAmountIsZero();\\n\\ncontract Ferc721Bridge {\\n\\t\\taddress public immutable factoryContractAddress;\\n\\t\\taddress public immutable tokenImplementation;\\n\\n\\t\\tmapping(address => uint64[]) public nftTokenIds;\\n\\t\\tmapping(address => address) public ferc20Addresses; // ferc-721 => ferc-20 address\\n\\t\\tmapping(address => address) public ferc721Addresses;  // ferc-20 => ferc-721 address\\n\\n\\t\\tevent DeployERC20(address operator, address indexed from, address indexed ferc721Address, address indexed ferc20Address, uint256 limit);\\n\\t\\tevent ReceivedNFT(address operator, address indexed from, uint256 tokenId, address indexed ferc721Address, address indexed ferc20Address, uint256 limit);\\n\\t\\tevent ReceivedToken(address indexed from, uint256 ferc20Amount, uint256 ferc721Amount, address indexed ferc20Address, address indexed ferc721Address, uint256 limit);\\n\\n\\t\\tconstructor(address _factoryContractAddress) {\\n\\t\\t\\tfactoryContractAddress = _factoryContractAddress;\\n\\t\\t\\ttokenImplementation = address(new FERC20());\\n\\t\\t}\\n\\n    function withdraw(address ferc20Address, uint256 amount) public returns (bool) {\\n\\t\\t\\t\\tIFERC20 ferc20 = IFERC20(ferc20Address);\\n\\t\\t\\t\\tif(ferc20.bridgeContract() != address(this)) revert NotCreatedByBridge();\\n\\t\\t\\t\\tif(ferc20.allowance(msg.sender, address(this)) < amount) revert AllowanceNotEnough();\\n\\t\\t\\t\\tif(ferc20.balanceOf(msg.sender) < amount) revert BalanceNotEnough();\\n\\n\\t\\t\\t\\taddress ferc721Address = ferc721Addresses[ferc20Address];\\n\\t\\t\\t\\tIFERC721 ferc721 = IFERC721(ferc721Address);\\n\\t\\t\\t\\tuint limit = ferc721.limit();\\n\\t\\t\\t\\tif(amount / 1e18 % limit != 0) revert NotMultipleOfLimit();\\n\\t\\t\\t\\tuint256 amountOfFERC721 = amount / limit / 1e18;\\n\\t\\t\\t\\tif(amountOfFERC721 == 0) revert WithdrawAmountIsZero();\\n\\t\\n\\t\\t\\t\\t// return back to depositer\\n\\t\\t\\t\\tfor(uint i; i < amountOfFERC721; i++) {\\n\\t\\t\\t\\t\\tferc721.safeTransferFrom(address(this), msg.sender, nftTokenIds[ferc721Address][nftTokenIds[ferc721Address].length - 1]);\\n\\t\\t\\t\\t\\tnftTokenIds[ferc721Address].pop();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// burn ferc20\\n\\t\\t\\t\\tferc20.transferFrom(msg.sender, address(this), amount);\\n\\t\\t\\t\\tferc20.transfer(address(0x0), amount);\\n\\n\\t\\t\\t\\temit ReceivedToken(msg.sender, amount, amountOfFERC721, msg.sender, ferc721Address, limit);\\n        return true;\\n    }\\n\\n\\t\\tfunction batchDeposit(address inscriptionAddress, uint[] calldata ids) public {\\n\\t\\t\\tIFERC721 inscription = IFERC721(inscriptionAddress);\\n\\t\\t\\tIFERC721.TokenData memory tokenData = inscription.tokenData();\\n\\t\\t\\tif(inscription.factoryContract() != factoryContractAddress) revert NotCreatedByFactory();\\n\\t\\t\\tif(tokenData.totalSupply < tokenData.max / tokenData.limit) revert MintNotFinished();\\n\\t\\t\\tif(!inscription.isApprovedForAll(msg.sender, address(this))) revert NotApprovedForAll();\\n\\n\\t\\t\\taddress ferc20Address = ferc20Addresses[inscriptionAddress];\\n\\t\\t\\tif(ferc20Address == address(0x0)) {\\n\\t\\t\\t\\tferc20Address = Clones.clone(tokenImplementation);\\n\\t\\t\\t\\tFERC20(ferc20Address).initialize(inscriptionAddress);\\n\\t\\t\\t\\tferc721Addresses[ferc20Address] = inscriptionAddress;\\n\\t\\t\\t\\tferc20Addresses[inscriptionAddress] = ferc20Address;\\n\\t\\t\\t\\temit DeployERC20(msg.sender, msg.sender, inscriptionAddress, ferc20Address, tokenData.limit);\\n\\t\\t\\t}\\n\\n\\t\\t\\tuint len = ids.length;\\n\\t\\t\\tfor(uint i; i < len; i++) {\\n\\t\\t\\t\\tinscription.transferFrom(msg.sender, address(this), ids[i]);\\n\\t\\t\\t\\tnftTokenIds[inscriptionAddress].push(uint64(ids[i]));\\n\\t\\t\\t\\temit ReceivedNFT(msg.sender, msg.sender, ids[i], inscriptionAddress, ferc20Address, tokenData.limit);\\n\\t\\t\\t}\\n\\t\\t\\tFERC20(ferc20Address).mint(msg.sender, uint(tokenData.limit) * 1e18 * ids.length);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) public returns (bytes4) {\\n\\t\\t\\t\\tif(IFERC721(msg.sender).factoryContract() != factoryContractAddress) revert NotCreatedByFactory();\\n\\t\\t\\t\\tif(IFERC721(msg.sender).totalSupply() < IFERC721(msg.sender).max() / IFERC721(msg.sender).limit()) revert MintNotFinished();\\n\\n\\t\\t\\t\\taddress ferc20Address = ferc20Addresses[msg.sender];\\n\\t\\t\\t\\tif(ferc20Address == address(0x0)) {\\n\\t\\t\\t\\t\\tferc20Address = Clones.clone(tokenImplementation);\\n\\t\\t\\t\\t\\tFERC20(ferc20Address).initialize(msg.sender);\\n\\t\\t\\t\\t\\tferc721Addresses[ferc20Address] = msg.sender;\\n\\t\\t\\t\\t\\tferc20Addresses[msg.sender] = ferc20Address;\\n\\t\\t\\t\\t\\temit DeployERC20(operator, from, msg.sender, ferc20Address, IFERC721(msg.sender).limit());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnftTokenIds[msg.sender].push(uint64(tokenId));\\n\\n\\t\\t\\t\\tFERC20(ferc20Address).mint(from, IFERC721(msg.sender).limit() * 1e18);\\n\\n\\t\\t\\t\\temit ReceivedNFT(operator, from, tokenId, msg.sender, ferc20Address, IFERC721(msg.sender).limit());\\n\\t\\t\\t\\treturn IERC721Receiver.onERC721Received.selector;\\n\\t\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFERC20 is IERC20 {\\n\\tfunction bridgeContract() external view returns(address);\\n\\tfunction mint(address account, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IFERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface IFERC721 is IERC721 {\\n\\tstruct TokenData {\\n\\t\\tuint64  max;\\n\\t\\tuint64  totalSupply;\\n\\t\\tbool    needFerc;\\n\\t\\tuint24  inscriptionId;\\n\\t\\tuint24  limit;\\n\\t\\tbytes9  tick;\\n\\t}\\n\\n\\tfunction factoryContract() external view returns(address);\\n\\tfunction swapContract() external view returns(address);\\n\\tfunction wethContract() external view returns(address);\\n\\tfunction name() external view returns(string memory);\\n\\tfunction symbol() external view returns(string memory);\\n\\tfunction totalSupply() external view returns(uint);\\n\\tfunction max() external view returns(uint);\\n\\tfunction limit() external view returns(uint);\\n\\tfunction needFerc() external view returns(bool);\\n\\tfunction inscriptionId() external view returns(uint);\\n\\tfunction tokenData() external view returns(TokenData memory);\\n\\tfunction lastMintTimestamp(address addr) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract ERC20 is IERC20 {\\n    uint public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    function transfer(address recipient, uint amount) external returns (bool) {\\n\\t\\t\\t\\tbalanceOf[msg.sender] -= amount;\\n        balanceOf[recipient] += amount;\\n        emit Transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint amount) external returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool) {\\n        allowance[sender][msg.sender] -= amount;\\n        balanceOf[sender] -= amount;\\n        balanceOf[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n        totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            balanceOf[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factoryContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AllowanceNotEnough\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceNotEnough\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotFinished\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedForAll\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCreatedByBridge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCreatedByFactory\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMultipleOfLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawAmountIsZero\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ferc721Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ferc20Address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"DeployERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ferc721Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ferc20Address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"ReceivedNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ferc20Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ferc721Amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ferc20Address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ferc721Address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"ReceivedToken\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inscriptionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"batchDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factoryContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ferc20Addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ferc721Addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftTokenIds\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ferc20Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Ferc721Bridge", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000015db8f98f9af25503846db14cb0869251878f4e9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}