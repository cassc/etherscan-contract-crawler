{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libraries/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overriden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\\n        internal\\n        returns (bool success)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to)\\n        internal\\n        returns (uint256 amount)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x6c.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and( // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount :=\\n                mul(\\n                    mload(0x20),\\n                    and( // The arguments of `and` are evaluated from right to left.\\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                    )\\n                )\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/MiningRig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Credits to 0xPauly, Pond0x, Pond Coin, and Pond D\ud83e\udd1dX\\npragma solidity ^0.8.17;\\n\\nimport {SafeTransferLib} from \\\"./libraries/SafeTransferLib.sol\\\";\\n\\ncontract MiningRig {\\n\\n    uint256 public PID; \\n\\n    address private immutable WETH;\\n    address private immutable PPEPE;\\n    address private immutable PEPE;\\n    address private immutable COSMIC_DISTILLERY;\\n\\n    INonfungiblePositionManager private immutable nonfungiblePositionManager;\\n\\n    struct Mining {\\n        uint blockno;\\n        uint256 mined;\\n        uint256 totalMinedPositions;\\n        uint256 difficulty;\\n        uint256 virtualWeight;\\n        uint256 vPool;\\n    }\\n\\n    struct MiningRewards {\\n        uint256 base;\\n        uint256 balance;\\n        uint256 frequency;\\n        uint256 held;\\n        uint256 debt;\\n        uint256 redeemable;\\n    }\\n\\n    mapping(address => MiningRewards) public scores;\\n\\n    Mining public rig;\\n\\n    constructor(\\n        INonfungiblePositionManager _nonfungiblePositionManager,\\n        address _ppepe,\\n        address _pepe,\\n        address _weth,\\n        address _cosmic_distillery\\n    ) {\\n        nonfungiblePositionManager = _nonfungiblePositionManager;\\n        PPEPE = _ppepe;\\n        PEPE = _pepe;\\n        WETH = _weth;\\n        COSMIC_DISTILLERY = _cosmic_distillery;\\n        SafeTransferLib.safeApprove(WETH, address(_nonfungiblePositionManager), type(uint256).max);\\n    }\\n\\n    function mineLiquidity(uint256 amountOutMinUniswap) payable external returns(uint128, uint newAllot, uint256 quote) {\\n        require(msg.value != 0, \\\"NONZERO\\\");\\n        if (rig.totalMinedPositions <= 1000) require(msg.value <= 5 ether, \\\"UNFAIR\\\");\\n        uint256 swappedAmtOut = _hopOnUniswap(amountOutMinUniswap);\\n        (uint128 liquidity, uint128 vliquidity ) = _addLiquidity(swappedAmtOut);\\n        uint256 _totalLiquidity = uint256(liquidity);\\n        uint256 _xt = _totalLiquidity + (_totalLiquidity+uint256(vliquidity));\\n        quote = (_totalLiquidity * 4) + (swappedAmtOut * 8);\\n        MINEABLE(PPEPE).mintSupplyFromMinedLP(msg.sender, quote);\\n        if (scores[msg.sender].base == 0 && rig.blockno <= 9 ) scores[msg.sender].redeemable =  rig.blockno + 1;\\n        scores[msg.sender].base += _xt + (_totalLiquidity * rig.difficulty);\\n        scores[msg.sender].balance = IERC20(PPEPE).balanceOf(msg.sender);\\n        ++scores[msg.sender].frequency;\\n        scores[msg.sender].held = IERC20(PEPE).balanceOf(msg.sender);\\n        newAllot = _calculate(msg.sender);\\n        scores[msg.sender].debt += newAllot;\\n        rig.mined += newAllot;\\n        if (rig.difficulty != 0){  --rig.difficulty; }\\n        rig.vPool += swappedAmtOut;\\n        ++rig.totalMinedPositions;\\n        return (liquidity, newAllot, quote);\\n    }  \\n\\n    function _calculate(address _address) internal view returns(uint) {\\n        uint256 _alloc = scores[_address].base;\\n        _alloc += 1 << scores[_address].frequency;\\n        _alloc += scores[_address].held;\\n        _alloc += scores[_address].balance;\\n        return _alloc;\\n    }\\n\\n    function score(address _address) external view returns(uint) {\\n        require(scores[_address].base != 0, \\\"COPE\\\");\\n        return _calculate(_address);\\n    }\\n\\n    function _hopOnUniswap(\\n        uint256 amountOutMin\\n    ) internal returns (uint amountOut) {\\n        amountOut = ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564).exactInputSingle{value: msg.value >> 1}(\\n        ISwapRouter.ExactInputSingleParams({\\n            tokenIn: WETH,\\n            tokenOut: PEPE,\\n            fee: 3000,\\n            recipient: address(this),\\n            deadline: block.timestamp + 300,\\n            amountIn: msg.value >> 1,\\n            amountOutMinimum: amountOutMin,\\n            sqrtPriceLimitX96: 0\\n        })\\n        );\\n        return amountOut;\\n    }\\n    function _addLiquidity(\\n        uint256 amountIn\\n    ) internal returns (uint128 liquidity, uint128 vliquidity) {\\n        IWETH(WETH).deposit{ value: msg.value >> 1 }();\\n        IERC20(PEPE).approve(address(nonfungiblePositionManager), type(uint256).max);\\n        IWETH(WETH).approve(address(nonfungiblePositionManager), type(uint256).max);\\n        INonfungiblePositionManager.IncreaseLiquidityParams memory params = INonfungiblePositionManager.IncreaseLiquidityParams({\\n            tokenId: PID,\\n            amount0Desired: amountIn / rig.virtualWeight,\\n            amount1Desired: (msg.value >> 1) / rig.virtualWeight,\\n            amount0Min: 0,\\n            amount1Min: 0,\\n            deadline:  block.timestamp + 300\\n        });\\n        uint256 amount0;\\n        uint256 amount1;\\n        (liquidity, amount0, amount1) = nonfungiblePositionManager.increaseLiquidity(params);\\n        return (liquidity,  uint128(liquidity * uint128(rig.virtualWeight)) - liquidity);\\n    }\\n    function bootUp(uint256 amountOutMinUniswap ) payable external returns(uint256 lpTokenId, uint256 liquidity, uint amount0, uint amount1 ) {\\n        require(msg.value != 0, \\\"Must pass non 0 ETH amount\\\");\\n        require(rig.virtualWeight == 0, \\\"Set\\\");\\n        uint256 swappedAmtOut = _hopOnUniswap(amountOutMinUniswap);\\n        rig.difficulty = 1000;\\n        rig.virtualWeight = 16;\\n        (lpTokenId, liquidity, amount0, amount1) = _bootLiquidityPosition(swappedAmtOut, msg.value >> 1, 60, -211140, -210120);\\n        MINEABLE(PPEPE).activate();\\n        PID = lpTokenId;\\n        return (liquidity, lpTokenId, amount0, amount1);\\n    }  \\n\\n    function _bootLiquidityPosition(\\n        uint amount0ToAdd,\\n        uint amount1ToAdd,\\n        int24 tickspacing,\\n        int24 mintick,\\n        int24 maxtick\\n    ) internal returns (uint tokenId, uint128 liquidity, uint amount0, uint amount1) {\\n        IWETH(WETH).deposit{ value: msg.value >> 1 }();\\n        IERC20(PEPE).approve(address(nonfungiblePositionManager), amount0ToAdd);\\n        IWETH(WETH).approve(address(nonfungiblePositionManager), amount1ToAdd);\\n        INonfungiblePositionManager.MintParams\\n            memory params = INonfungiblePositionManager.MintParams({\\n                token0: PEPE,\\n                token1: WETH,\\n                fee: 3000,\\n                tickLower: (mintick / tickspacing) * tickspacing,\\n                tickUpper: (maxtick / tickspacing) * tickspacing,\\n                amount0Desired: amount0ToAdd,\\n                amount1Desired: amount1ToAdd,\\n                amount0Min: 0,\\n                amount1Min: 0,\\n                recipient: address(this),\\n                deadline: block.timestamp\\n            });\\n        (tokenId, liquidity, amount0, amount1) = nonfungiblePositionManager.mint(\\n            params\\n        );\\n        return (tokenId, liquidity, amount0, amount1);\\n    }\\n    \\n    receive() external payable {}\\n\\n    function sqrt96Tick(\\n        uint24 _fee, \\n        address _factory,\\n        address _token\\n    ) internal view returns (uint, int24) {\\n        (address _pool) = IUniswapV3Factory(_factory).getPool(_token, WETH, _fee);\\n        (uint160 sqrtPriceX96, int24 tick, , , , , ) = IUniswapV3Pool(_pool).slot0();\\n        return ((uint(sqrtPriceX96) ** 2) * (1**18) / (192**2), tick);\\n    }\\n\\n    function deltaNeutralLPContinuum(\\n        address _factory,\\n        uint128 _liquidity,\\n        uint amountOutMinUniswap,\\n        uint256 _virtualWeight, \\n        int24 _delta,\\n        uint24 _fee\\n    ) external payable returns(uint tokenId, uint128 liquidity ) {\\n            require(msg.value > 1 ether, \\\"FEE\\\");\\n            (, int24 tick) = sqrt96Tick(_fee, _factory, PEPE);\\n            _collectLpFees(PID);\\n            uint256 swappedAmtOut = _hopOnUniswap(amountOutMinUniswap);\\n            int24 TICK_SPACING = 60;\\n            IWETH(WETH).deposit{ value: msg.value >> 1 }();\\n            IERC20(PEPE).approve(address(nonfungiblePositionManager), swappedAmtOut);\\n            IWETH(WETH).approve(address(nonfungiblePositionManager), msg.value >> 1);\\n            INonfungiblePositionManager.MintParams\\n                memory params = INonfungiblePositionManager.MintParams({\\n                    token0: PEPE,\\n                    token1: WETH,\\n                    fee: _fee,\\n                    tickLower: ((tick - _delta) / TICK_SPACING) * TICK_SPACING,\\n                    tickUpper: ((tick + _delta) / TICK_SPACING) * TICK_SPACING,\\n                    amount0Desired: swappedAmtOut,\\n                    amount1Desired: msg.value >> 1,\\n                    amount0Min: 0,\\n                    amount1Min: 0,\\n                    recipient: address(this),\\n                    deadline: block.timestamp + 300\\n                });\\n            (tokenId, liquidity, , ) = nonfungiblePositionManager.mint(\\n                params\\n            );\\n            _produceLevelsFromPools(_liquidity, PID);\\n            _observeVirtualPoolCardinality();\\n            PID = tokenId;\\n            rig.virtualWeight = _virtualWeight;\\n            _convertWETHforETH();\\n            return (tokenId, liquidity);\\n    }\\n\\n    function precision(uint a, uint b, uint _precision) internal pure returns ( uint) {\\n     return a*(10**_precision)/b;\\n    }\\n    function calculateBlock() internal view returns (uint) {\\n        uint256 _supply = IERC20(PPEPE).totalSupply();\\n        uint256 _complete = precision(_supply, 100000000000000000000000000000000, 1);\\n        return _complete;\\n    }\\n\\n    function finalizeBlock(\\n        uint128 liquidity,\\n        uint256 tokenId\\n    ) external returns(uint){\\n        uint256 _block = calculateBlock();\\n        require(_block != rig.blockno, 'UNMET');\\n        _produceLevelsFromPools(liquidity, tokenId);\\n        rig.blockno = uint(_block);\\n        _observeVirtualPoolCardinality();\\n        return _block;\\n    }\\n\\n    function bribeForLevelReward() external payable returns (uint128 liquidity, uint256 amount0, uint256 amount1){\\n        require(msg.value > 0.25 ether, \\\"NONZERO\\\");\\n        uint256 _block = calculateBlock();\\n        (,,,,,,,liquidity,,,,) = nonfungiblePositionManager.positions(PID);\\n        INonfungiblePositionManager.DecreaseLiquidityParams\\n            memory params = INonfungiblePositionManager.DecreaseLiquidityParams({\\n                tokenId: PID,\\n                liquidity: liquidity,\\n                amount0Min: 0,\\n                amount1Min: 0,\\n                deadline: block.timestamp\\n            });\\n        (amount0, amount1) = nonfungiblePositionManager.decreaseLiquidity(params);\\n        _observeVirtualPoolCardinality();\\n        _convertWETHforETH();\\n        rig.blockno = uint(_block);\\n        return (liquidity, amount0, amount1);\\n    }\\n    function _observeVirtualPoolCardinality() internal returns (uint){\\n        SafeTransferLib.safeTransferETH(address(COSMIC_DISTILLERY), address(this).balance);\\n        uint256 _pepeBalance = IERC20(PEPE).balanceOf(address(this));\\n        SafeTransferLib.safeApprove(PEPE, address(COSMIC_DISTILLERY), type(uint256).max);\\n        SafeTransferLib.safeTransfer(PEPE,  address(COSMIC_DISTILLERY), _pepeBalance >> 1);\\n        return _pepeBalance;\\n    }\\n    function _convertWETHforETH() internal returns (bool){\\n        IWETH(WETH).withdraw(IWETH(WETH).balanceOf(address(this)));\\n        SafeTransferLib.safeTransferETH(address(COSMIC_DISTILLERY), address(this).balance);\\n        return true;\\n    }\\n    function _produceLevelsFromPools(\\n        uint128 liquidity,\\n        uint256 tokenId\\n    ) internal returns (uint amount0, uint amount1) {\\n        INonfungiblePositionManager.DecreaseLiquidityParams\\n            memory params = INonfungiblePositionManager.DecreaseLiquidityParams({\\n                tokenId: tokenId,\\n                liquidity: liquidity,\\n                amount0Min: 0,\\n                amount1Min: 0,\\n                deadline: block.timestamp\\n            });\\n        (amount0, amount1) = nonfungiblePositionManager.decreaseLiquidity(params);\\n        return (amount0, amount1);\\n    }\\n    function _collectLpFees (uint256 tokenId) internal returns (uint amount0, uint amount1) {\\n        INonfungiblePositionManager.CollectParams\\n            memory params = INonfungiblePositionManager.CollectParams({\\n                tokenId: tokenId,\\n                recipient: address(this),\\n                amount0Max: type(uint128).max,\\n                amount1Max: type(uint128).max\\n            });\\n        (amount0, amount1) = nonfungiblePositionManager.collect(params);\\n    }\\n    function unifee(uint256 tokenId) external payable returns (uint amount0, uint amount1) {\\n       (amount0, amount1) = _collectLpFees(tokenId);\\n    }\\n    function locked() external payable returns (uint){\\n        require(rig.blockno >= 9, \\\"LOCKED\\\");\\n        require(msg.value > 0.25 ether, \\\"NONZERO\\\");\\n        _collectLpFees(PID);\\n        _observeVirtualPoolCardinality();\\n        _convertWETHforETH();\\n        return PID;\\n    }\\n \\n}\\n\\ninterface IUniswapV3Factory {\\n     function getPool(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) external view returns (address pool);\\n}\\ninterface IUniswapV3PoolState {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// observationIndex The index of the last oracle observation that was written,\\n    /// observationCardinality The current maximum number of observations stored in the pool,\\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\n    /// tick upper,\\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n    /// a specific position.\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128,\\n            int56 tickCumulativeOutside,\\n            uint160 secondsPerLiquidityOutsideX128,\\n            uint32 secondsOutside,\\n            bool initialized\\n        );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\\n    /// @return _liquidity The amount of liquidity in the position,\\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\n    function positions(bytes32 key)\\n        external\\n        view\\n        returns (\\n            uint128 _liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    /// @notice Returns data about a specific observation index\\n    /// @param index The element of the observations array to fetch\\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n    /// ago, rather than at a specific index in the array.\\n    /// @return blockTimestamp The timestamp of the observation,\\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 secondsPerLiquidityCumulativeX128,\\n            bool initialized\\n        );\\n}\\n\\ninterface IUniswapV3Pool is\\n    IUniswapV3PoolState\\n{}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\\ninterface INonfungiblePositionManager {\\n    struct MintParams {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint amount0Desired;\\n        uint amount1Desired;\\n        uint amount0Min;\\n        uint amount1Min;\\n        address recipient;\\n        uint deadline;\\n    }\\n\\n    function mint(\\n        MintParams calldata params\\n    )\\n        external\\n        payable\\n        returns (uint tokenId, uint128 liquidity, uint amount0, uint amount1);\\n\\n    struct IncreaseLiquidityParams {\\n        uint tokenId;\\n        uint amount0Desired;\\n        uint amount1Desired;\\n        uint amount0Min;\\n        uint amount1Min;\\n        uint deadline;\\n    }\\n\\n    function increaseLiquidity(\\n        IncreaseLiquidityParams calldata params\\n    ) external payable returns (uint128 liquidity, uint amount0, uint amount1);\\n\\n    struct DecreaseLiquidityParams {\\n        uint tokenId;\\n        uint128 liquidity;\\n        uint amount0Min;\\n        uint amount1Min;\\n        uint deadline;\\n    }\\n\\n    function decreaseLiquidity(\\n        DecreaseLiquidityParams calldata params\\n    ) external payable returns (uint amount0, uint amount1);\\n\\n    struct CollectParams {\\n        uint tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    function positions(uint256 tokenId)\\n        external\\n        view\\n        returns (\\n            uint96 nonce,\\n            address operator,\\n            address token0,\\n            address token1,\\n            uint24 fee,\\n            int24 tickLower,\\n            int24 tickUpper,\\n            uint128 liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n    );\\n\\n    function collect(\\n        CollectParams calldata params\\n    ) external payable returns (uint amount0, uint amount1);\\n\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n}\\ninterface ISwapRouter {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint deadline;\\n        uint amountIn;\\n        uint amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n    function exactInputSingle(\\n        ExactInputSingleParams calldata params\\n    ) external payable returns (uint amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint deadline;\\n        uint amountIn;\\n        uint amountOutMinimum;\\n    }\\n    function exactInput(\\n        ExactInputParams calldata params\\n    ) external payable returns (uint amountOut);\\n}\\n\\ninterface MINEABLE { \\n    function mintSupplyFromMinedLP(address miner, uint256 value) external; \\n    function activate() external;\\n}\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n    function withdraw(uint amount) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"_nonfungiblePositionManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ppepe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pepe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cosmic_distillery\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMinUniswap\",\"type\":\"uint256\"}],\"name\":\"bootUp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bribeForLevelReward\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinUniswap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_virtualWeight\",\"type\":\"uint256\"},{\"internalType\":\"int24\",\"name\":\"_delta\",\"type\":\"int24\"},{\"internalType\":\"uint24\",\"name\":\"_fee\",\"type\":\"uint24\"}],\"name\":\"deltaNeutralLPContinuum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"finalizeBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMinUniswap\",\"type\":\"uint256\"}],\"name\":\"mineLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"newAllot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quote\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"blockno\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mined\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMinedPositions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"difficulty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"virtualWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vPool\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"score\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"scores\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frequency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"held\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unifee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MiningRig", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "000000000000000000000000c36442b4a4522e871399cd717abdd847ab11fe8800000000000000000000000098830a6cc6f8964cec4ffd65f19edebba6fef8650000000000000000000000006982508145454ce325ddbe47a25d4ec3d2311933000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000c11ddc53d75b03eaa8bafddb795572059eceb324", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}