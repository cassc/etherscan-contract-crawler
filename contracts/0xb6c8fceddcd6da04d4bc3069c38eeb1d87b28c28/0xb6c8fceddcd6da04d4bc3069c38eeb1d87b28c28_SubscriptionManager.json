{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/SubscriptionManager.sol\": {\r\n      \"content\": \"/**\\n * Nchart Subscription Manager\\n *\\n * Website: nchart.io\\n * Docs: docs.nchart.io\\n * twitter.com/Nchart_\\n * twitter.com/Kekotron_\\n */\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"@solady/auth/OwnableRoles.sol\\\";\\nimport \\\"@solady/utils/LibMap.sol\\\";\\nimport {Nchart} from \\\"./Nchart.sol\\\";\\nimport \\\"./IUniswapV2Router02.sol\\\";\\n\\n/**\\n *             ........\\n *         ..::::::::::::.  .\\n *       .:::::::::::::::.  =+-.\\n *     --::::::::::::::::.  =+++-\\n *    *##*+::::::::::::::.  =+++++\\n *   *#####:  .::::::::::.  =++++++\\n *  -######:     .:::::::.  =++++++-\\n *  *######:  :.    .::::.  =+++++++\\n *  #######:  -=-:.    .:.  =+++++++\\n *  +######:  -=====:.      =++++++=\\n *  :######:  -========-.   =++++++:\\n *   +#####:  -===========-.-+++++=\\n *    =####:  -==============-==+-\\n *     :*##:  -================-.\\n *       :+:  -==============-.\\n *            :==========-:.\\n *               ......\\n *\\n *\\n * @dev Contract which accepts ETH to pay for a subscription, which is used to buy and burn CHART from\\n * @dev the UniswapV2 LP Pool\\n */\\ncontract SubscriptionManager is OwnableRoles {\\n    uint40 internal constant MAX_UINT40 = type(uint40).max;\\n    uint256 public constant KEEPER_ROLE = uint256(1);\\n\\n    Nchart public immutable chart;\\n    IUniswapV2Router02 public immutable router;\\n\\n    LibMap.Uint40Map private expiration;\\n\\n    uint256 public subscriptionPrice = 0.015 ether; // Price is 0.015e to start\\n    uint256 public referralFeePriceReduction = 0.001 ether; // Reduction of fee per address if referral is provided\\n    uint40 public subscriptionLength; // Lifetime subscription to start\\n    // Percent of fees to use to buy and burn CHART\\n    uint8 public burnPercent = 99;\\n    // Percent of fees to send to referrer if they have an active subscription\\n    uint8 public referralPercent = 5;\\n\\n    event BurnPercentUpdated(uint8 newPercent, uint8 oldPercent);\\n    event ReferralPaid(address indexed referrer, uint256 amount);\\n    event ReferralFeePriceReductionUpdated(uint256 newAmount, uint256 oldAmount);\\n    event ReferralPercentUpdated(uint8 newPercent, uint8 oldPercent);\\n    event SubscriptionLengthUpdated(uint256 newLength, uint256 oldLength);\\n    event SubscriptionPaid(address indexed subscriber, uint40 expirationTimestamp, uint256 price);\\n    event SubscriptionPriceUpdated(uint256 newPrice, uint256 oldPrice);\\n\\n    error SubscriptionManager__BurnPercentMustBeGreaterThan50();\\n    error SubscriptionManager__BurnPercentMustBeLessThan100();\\n    error SubscriptionManager__CannotReferSelf();\\n    error SubscriptionManager__CannotReduceMoreThanSubscriptionPrice();\\n    error SubscriptionManager__CannotRegisterAddressZero();\\n    error SubscriptionManager__CanOnlyIncreaseExpiration();\\n    error SubscriptionManager__ErrorRetrievingPriceFromDataFeed();\\n    error SubscriptionManager__ErrorSendingKeeperFunds();\\n    error SubscriptionManager__InvalidETHAmountProvided(uint256 msgValue, uint256 ethRequired);\\n    error SubscriptionManager__MaxFiftyPercentReferralPercent();\\n    error SubscriptionManager__MustProvideAtLeastOneAddress();\\n    error SubscriptionManager__OnlyOwner();\\n    error SubscriptionManager__UseRegisterAddressesFunction();\\n\\n    constructor(address payable chart_, address owner_, address router_) {\\n        _initializeOwner(owner_);\\n        chart = Nchart(chart_);\\n        router = IUniswapV2Router02(router_);\\n    }\\n\\n    receive() external payable {\\n        revert SubscriptionManager__UseRegisterAddressesFunction();\\n    }\\n\\n    fallback() external payable {\\n        revert SubscriptionManager__UseRegisterAddressesFunction();\\n    }\\n\\n    /**\\n     * @notice Sets the length of the subscription period.\\n     *\\n     * @dev    The subscription length is either added to the remaining time of a user's subscription or block.timestamp if unset\\n     * @dev    Passing in a value of 0 will set the subscription to unlimited, and expiration will be set to MAX_UINT40\\n     * @dev    - Throws if caller is not owner\\n     *\\n     * @dev    On completion:\\n     * @dev    - `subscriptionLength` = `newSubscriptionLength`\\n     * @dev    - Emits {SubscriptionLengthUpdated} event\\n     *\\n     * @param  newSubscriptionLength Length to update future subscriptions to\\n     */\\n    function setSubscriptionLength(uint40 newSubscriptionLength) external {\\n        _requireIsOwner();\\n\\n        uint40 oldSubscriptionLength = subscriptionLength;\\n        subscriptionLength = newSubscriptionLength;\\n        emit SubscriptionLengthUpdated(newSubscriptionLength, oldSubscriptionLength);\\n    }\\n\\n    /**\\n     * @notice Sets the percentage of fees to send to referrers if they have an active subscription\\n     *\\n     * @dev    - Throws if `msg.sender` != `owner()`\\n     * @dev    - Throws if provided percent is > 5\\n     *\\n     * @dev    On completion:\\n     * @dev    - `referralPercent` = `newPercent`\\n     * @dev    - Emits {ReferralPercentUpdated} event\\n     *\\n     * @param newPercent Percentage of fees to send to referrers\\n     */\\n    function setReferralPercent(uint8 newPercent) external {\\n        _requireIsOwner();\\n\\n        if (newPercent > 50) {\\n            revert SubscriptionManager__MaxFiftyPercentReferralPercent();\\n        }\\n\\n        uint8 oldPercent = referralPercent;\\n        referralPercent = newPercent;\\n        emit ReferralPercentUpdated(newPercent, oldPercent);\\n    }\\n\\n    /**\\n     * @notice Sets the amount fees are reduced per account when providing a referral\\n     *\\n     * @dev    - Throws if `msg.sender` != `owner()`\\n     * @dev    - Throws if provided reduction amount is greater than subscription price\\n     *\\n     * @dev    On completion:\\n     * @dev    - `referralFeePriceReduction` = `newAmount`\\n     * @dev    - Emits {ReferralFeePriceReductionUpdated} event\\n     *\\n     * @param newAmount Amount to reduce fees per address if referral provided\\n     */\\n    function setReferralFeePriceReduction(uint256 newAmount) external {\\n        _requireIsOwner();\\n\\n        if (newAmount >= subscriptionPrice) {\\n            revert SubscriptionManager__CannotReduceMoreThanSubscriptionPrice();\\n        }\\n\\n        uint256 oldReferralFeePriceReduction = referralFeePriceReduction;\\n        referralFeePriceReduction = newAmount;\\n        emit ReferralFeePriceReductionUpdated(newAmount, oldReferralFeePriceReduction);\\n    }\\n\\n    /**\\n     * @notice Sets the price of new subscriptions.  Users will be charged this amount per address to use premium features\\n     *\\n     * @dev    Price of subscription is set in ETH, stored in 1e18 (wei)\\n     * @dev    Passing in a value of 0 will set premium features to free.\\n     * @dev    - Throws if caller is not owner\\n     *\\n     * @dev    On completion:\\n     * @dev    - `subscriptionPrice` = `newSubscriptionPrice`\\n     * @dev    - Emits {SubscriptionPriceUpdated} event\\n     *\\n     * @param  newSubscriptionPrice Price to update future subscriptions to\\n     */\\n    function setSubscriptionPrice(uint256 newSubscriptionPrice) external {\\n        _requireIsOwner();\\n\\n        uint256 oldSubscriptionPrice = subscriptionPrice;\\n        subscriptionPrice = newSubscriptionPrice;\\n        emit SubscriptionPriceUpdated(newSubscriptionPrice, oldSubscriptionPrice);\\n    }\\n\\n    /**\\n     * @notice Sets the percentage of fees used to buy and burn CHART\\n     *\\n     * @dev    - Throws if `msg.sender` != `owner()`\\n     * @dev    - Throws if provided percent is > 100\\n     *\\n     * @dev    On completion:\\n     * @dev    - `burnPercent` = `newPercent`\\n     * @dev    - Emits {BurnPercentUpdated} event\\n     *\\n     * @param newPercent Percentage of fees to be used to buy and burn CHART\\n     */\\n    function setBurnPercent(uint8 newPercent) external {\\n        _requireIsOwner();\\n\\n        if (newPercent > 100) {\\n            revert SubscriptionManager__BurnPercentMustBeLessThan100();\\n        }\\n\\n        if (newPercent < 50) {\\n            revert SubscriptionManager__BurnPercentMustBeGreaterThan50();\\n        }\\n\\n        uint8 oldPercent = burnPercent;\\n        burnPercent = newPercent;\\n        emit BurnPercentUpdated(newPercent, oldPercent);\\n    }\\n\\n    /**\\n     * @notice Allows owner to increase the expiration timestamp for a provided user in case of \\n     * @notice giveaways.\\n     *\\n     * @dev    - Throws if `newExpiration` < current expiration \\n     * @dev    - Throws if `msg.sender` != `owner()\\n     *\\n     * @dev    On completion:\\n     * @dev    - User expiration is set to `newExpiration`\\n     */\\n    function setExpirationTimestamp(uint40 newExpiration, address user) external {\\n        _requireIsOwner();\\n\\n        if (newExpiration < LibMap.get(expiration, uint256(uint160(user)))){ \\n            revert SubscriptionManager__CanOnlyIncreaseExpiration();\\n        }\\n        LibMap.set(expiration, uint256(uint160(user)), newExpiration);\\n    }\\n\\n    /**\\n     * @notice Grants the KEEPER_ROLE to the provided user.\\n     *\\n     * @dev    - Throws if the `msg.sender` is not `owner()`\\n     *\\n     * @dev    On completion:\\n     * @dev    - `newKeeper` is assigned the `KEEPER_ROLE`\\n     *\\n     * @param newKeeper Address to assign the `KEEPER_ROLE`\\n     */\\n    function grantKeeperRole(address newKeeper) external {\\n        grantRoles(newKeeper, KEEPER_ROLE);\\n    }\\n\\n    /**\\n     * @notice Revokes the KEEPER_ROLE from the provided user.\\n     *\\n     * @dev    - Throws if the `msg.sender` is not `owner()`\\n     *\\n     * @dev    On completion:\\n     * @dev    - `toRevoke` is no longer assigned the `KEEPER_ROLE`\\n     *\\n     * @param toRevoke Address to revoke the `KEEPER_ROLE` from\\n     */\\n    function revokeKeeperRole(address toRevoke) external {\\n        revokeRoles(toRevoke, KEEPER_ROLE);\\n    }\\n\\n    /**\\n     * @notice Registers a list of addresses for premium features.  There is an optional referrer address\\n     * @notice which will receive a percentage of the fees paid by the registered addresses if they have an active subscription.\\n     *\\n     * @dev    - Throws if the length of the provided addresses is 0\\n     * @dev    - Throws if `msg.value` is not equal to the exact amount required to pay for the subscriptions\\n     * @dev    - Throws if any address provided is address(0)\\n     * @dev    - Throws if the referrer address executes code > 2300 gas\\n     * @dev    - If the provided referral address is not subscribed, it is a no-op\\n     *\\n     * @dev    On completion:\\n     * @dev    - `expiration` mapping for each address is updated to add on an additional `subLength` seconds\\n     * @dev    - If `expiration` + the current length of subscriptions is > uint256 max, set to uint256 max\\n     * @dev    - If the current length of subscription is 0, set `expiration` to uint256 max\\n     * @dev    - The contract has `subLength` * `subPrice` - `referralAmount` more ETH\\n     * @dev    - If the referrer is subscribed, they receive `referralAmount` ETH\\n     * @dev    - Emits `addresses.length` {SubscriptionPaid} events\\n     * @dev    - Emits {ReferralPaid} event if referrer is subscribed\\n     *\\n     * @param  addresses A list of addresses to register\\n     * @param  referrer  Optional address of referrer\\n     */\\n    function registerAddresses(address[] calldata addresses, address referrer) external payable {\\n        uint256 numSubs = addresses.length;\\n        if (numSubs == 0) {\\n            revert SubscriptionManager__MustProvideAtLeastOneAddress();\\n        }\\n        if (referrer == msg.sender) {\\n            revert SubscriptionManager__CannotReferSelf();\\n        }\\n\\n        uint256 subPrice = subscriptionPrice;\\n        uint256 referralFeeReduction = referrer != address(0) ? referralFeePriceReduction * numSubs : 0;\\n        uint256 ethRequired = numSubs * subPrice;\\n        uint256 referralAmount;\\n\\n        if (block.timestamp <= LibMap.get(expiration, uint256(uint160(referrer)))) {\\n            if (referralPercent > 0) {\\n                referralAmount = ethRequired * referralPercent / 100;\\n            }\\n        }\\n\\n        if (referralFeeReduction > 0) {\\n            ethRequired -= referralFeeReduction;\\n        }\\n\\n        if (msg.value != ethRequired) {\\n            revert SubscriptionManager__InvalidETHAmountProvided(msg.value, ethRequired);\\n        }\\n\\n        uint40 subLength = subscriptionLength;\\n\\n        if (subLength == 0) {\\n            for (uint256 i = 0; i < numSubs;) {\\n                address addr = addresses[i];\\n                _requireValidAddress(addr);\\n                LibMap.set(expiration, uint256(uint160(addr)), type(uint40).max);\\n\\n                emit SubscriptionPaid(addr, MAX_UINT40, subPrice);\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        } else {\\n            uint40 maxExpiration = type(uint40).max - subLength;\\n            for (uint256 i = 0; i < numSubs;) {\\n                address addr = addresses[i];\\n                _requireValidAddress(addr);\\n                uint40 addrExpiration = LibMap.get(expiration, uint256(uint160(addr)));\\n                uint40 timestamp = uint40(block.timestamp);\\n\\n                if (addrExpiration < timestamp) {\\n                    if (timestamp > maxExpiration) {\\n                        addrExpiration = type(uint40).max;\\n                    } else {\\n                        addrExpiration = timestamp + subLength;\\n                    }\\n                } else if (addrExpiration < maxExpiration) {\\n                    // Unchecked is safe here as we know that expiration + subLength < MAX_UINT40\\n                    unchecked {\\n                        addrExpiration += subLength;\\n                    }\\n                } else {\\n                    addrExpiration = type(uint40).max;\\n                }\\n\\n                LibMap.set(expiration, uint256(uint160(addr)), addrExpiration);\\n\\n                emit SubscriptionPaid(addr, addrExpiration, subPrice);\\n\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        if (referralAmount > 0) {\\n            // We use `transfer` here to limit the amount of gas forwarded to the referrer\\n            // As such, referrer addresses should be EOAs or contracts without fallback / receive functionality\\n            payable(referrer).transfer(referralAmount);\\n            emit ReferralPaid(referrer, referralAmount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Uses fees from subscriptions to buyback and burn CHART from the uniswap v2 pair\\n     *\\n     * @dev    This is a high risk function, anyone with KEEPER_ROLE could potentially sandwich this call\\n     * @dev    Do not give KEEPER_ROLE to addresses unless you fully trust them\\n     * @dev    If you would like to ignore slippage, pass in 0 for amountOutMin\\n     * @dev    - Throws if `msg.sender` does not have owner or `KEEPER_ROLE`\\n     * @dev    - Throws if there is an error sending funds to `msg.sender`\\n     *\\n     * @dev    On completion:\\n     * @dev    - `burnPercent`% of the balance of the contract is used to buy and burn CHART\\n     * @dev    - The remaining balance is sent to the `msg.sender` to cover operational expenses\\n     * @dev    - address(this).balance == 0\\n     *\\n     * @param  amountOutMin Minimum amount of CHART to receive from `burnPercent`% * balance ETH\\n     */\\n    function burnETH(uint256 amountOutMin) external {\\n        _checkRolesOrOwner(KEEPER_ROLE);\\n        uint256 balance = address(this).balance;\\n\\n        uint256 amountToBurn = balance * burnPercent / 100;\\n        uint256 amountToSend = balance - amountToBurn;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = router.WETH();\\n        path[1] = address(chart);\\n\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amountToBurn}(\\n            amountOutMin,\\n            path,\\n            address(0xdead),\\n            block.timestamp\\n        );\\n\\n        // Gated role, do not need to worry about gas to forward\\n        (bool success,) = payable(msg.sender).call{value: amountToSend}(\\\"\\\");\\n        if (!success) {\\n            revert SubscriptionManager__ErrorSendingKeeperFunds();\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns if an address has a current subscription\\n     *\\n     * @param  user Address of user\\n     * @return True if user has an active subscription, false if not\\n     */\\n    function isAddressRegistered(address user) external view returns (bool) {\\n        return block.timestamp <= LibMap.get(expiration, uint256(uint160(user)));\\n    }\\n\\n    function getExpiration(address user) external view returns (uint40) {\\n        return LibMap.get(expiration, uint256(uint160(user)));\\n    }\\n\\n    /// @dev Convenience function to require user is owner\\n    function _requireIsOwner() internal view {\\n        if (msg.sender != owner()) {\\n            revert SubscriptionManager__OnlyOwner();\\n        }\\n    }\\n\\n    /// @dev Convenience function to validate address input\\n    function _requireValidAddress(address addr) internal pure {\\n        if (addr == address(0)) {\\n            revert SubscriptionManager__CannotRegisterAddressZero();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/OwnableRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\n\\n/// @notice Simple single owner and multiroles authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\\n/// may be unique to this codebase.\\nabstract contract OwnableRoles is Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `user`'s roles is updated to `roles`.\\n    /// Each bit of `roles` represents whether the role is set.\\n    event RolesUpdated(address indexed user, uint256 indexed roles);\\n\\n    /// @dev `keccak256(bytes(\\\"RolesUpdated(address,uint256)\\\"))`.\\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The role slot of `user` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _ROLE_SLOT_SEED))\\n    ///     let roleSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// This automatically ignores the upper bits of the `user` in case\\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\\n    ///\\n    /// Note: This is equal to `_OWNER_SLOT_NOT` in for gas efficiency.\\n    uint256 private constant _ROLE_SLOT_SEED = 0x8b78c6d8;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Overwrite the roles directly without authorization guard.\\n    function _setRoles(address user, uint256 roles) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            // Store the new value.\\n            sstore(keccak256(0x0c, 0x20), roles)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), roles)\\n        }\\n    }\\n\\n    /// @dev Updates the roles directly without authorization guard.\\n    /// If `on` is true, each set bit of `roles` will be turned on,\\n    /// otherwise, each set bit of `roles` will be turned off.\\n    function _updateRoles(address user, uint256 roles, bool on) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            let roleSlot := keccak256(0x0c, 0x20)\\n            // Load the current value.\\n            let current := sload(roleSlot)\\n            // Compute the updated roles if `on` is true.\\n            let updated := or(current, roles)\\n            // Compute the updated roles if `on` is false.\\n            // Use `and` to compute the intersection of `current` and `roles`,\\n            // `xor` it with `current` to flip the bits in the intersection.\\n            if iszero(on) { updated := xor(current, and(current, roles)) }\\n            // Then, store the new value.\\n            sstore(roleSlot, updated)\\n            // Emit the {RolesUpdated} event.\\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, mload(0x0c)), updated)\\n        }\\n    }\\n\\n    /// @dev Grants the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn on.\\n    function _grantRoles(address user, uint256 roles) internal virtual {\\n        _updateRoles(user, roles, true);\\n    }\\n\\n    /// @dev Removes the roles directly without authorization guard.\\n    /// Each bit of `roles` represents the role to turn off.\\n    function _removeRoles(address user, uint256 roles) internal virtual {\\n        _updateRoles(user, roles, false);\\n    }\\n\\n    /// @dev Throws if the sender does not have any of the `roles`.\\n    function _checkRoles(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner,\\n    /// and does not have any of the `roles`.\\n    /// Checks for ownership first, then lazily checks for roles.\\n    function _checkOwnerOrRoles(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner.\\n            // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\\n            if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\\n                // Compute the role slot.\\n                mstore(0x0c, _ROLE_SLOT_SEED)\\n                mstore(0x00, caller())\\n                // Load the stored value, and if the `and` intersection\\n                // of the value and `roles` is zero, revert.\\n                if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender does not have any of the `roles`,\\n    /// and is not the owner.\\n    /// Checks for roles first, then lazily checks for ownership.\\n    function _checkRolesOrOwner(uint256 roles) internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            // Load the stored value, and if the `and` intersection\\n            // of the value and `roles` is zero, revert.\\n            if iszero(and(sload(keccak256(0x0c, 0x20)), roles)) {\\n                // If the caller is not the stored owner.\\n                // Note: `_ROLE_SLOT_SEED` is equal to `_OWNER_SLOT_NOT`.\\n                if iszero(eq(caller(), sload(not(_ROLE_SLOT_SEED)))) {\\n                    mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function to return a `roles` bitmap from an array of `ordinals`.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _rolesFromOrdinals(uint8[] memory ordinals) internal pure returns (uint256 roles) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let i := shl(5, mload(ordinals)) } i { i := sub(i, 0x20) } {\\n                // We don't need to mask the values of `ordinals`, as Solidity\\n                // cleans dirty upper bits when storing variables into memory.\\n                roles := or(shl(mload(add(ordinals, i)), 1), roles)\\n            }\\n        }\\n    }\\n\\n    /// @dev Convenience function to return an array of `ordinals` from the `roles` bitmap.\\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\\n    /// Not recommended to be called on-chain.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ordinalsFromRoles(uint256 roles) internal pure returns (uint8[] memory ordinals) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the pointer to the free memory.\\n            ordinals := mload(0x40)\\n            let ptr := add(ordinals, 0x20)\\n            let o := 0\\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\\n            // smaller bytecode, as this function is not meant to be called on-chain.\\n            for { let t := roles } 1 {} {\\n                mstore(ptr, o)\\n                // `shr` 5 is equivalent to multiplying by 0x20.\\n                // Push back into the ordinals array if the bit is set.\\n                ptr := add(ptr, shl(5, and(t, 1)))\\n                o := add(o, 1)\\n                t := shr(o, roles)\\n                if iszero(t) { break }\\n            }\\n            // Store the length of `ordinals`.\\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\\n            // Allocate the memory.\\n            mstore(0x40, ptr)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to grant `user` `roles`.\\n    /// If the `user` already has a role, then it will be an no-op for the role.\\n    function grantRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _grantRoles(user, roles);\\n    }\\n\\n    /// @dev Allows the owner to remove `user` `roles`.\\n    /// If the `user` does not have a role, then it will be an no-op for the role.\\n    function revokeRoles(address user, uint256 roles) public payable virtual onlyOwner {\\n        _removeRoles(user, roles);\\n    }\\n\\n    /// @dev Allow the caller to remove their own roles.\\n    /// If the caller does not have a role, then it will be an no-op for the role.\\n    function renounceRoles(uint256 roles) public payable virtual {\\n        _removeRoles(msg.sender, roles);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the roles of `user`.\\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the role slot.\\n            mstore(0x0c, _ROLE_SLOT_SEED)\\n            mstore(0x00, user)\\n            // Load the stored value.\\n            roles := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns whether `user` has any of `roles`.\\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool) {\\n        return rolesOf(user) & roles != 0;\\n    }\\n\\n    /// @dev Returns whether `user` has all of `roles`.\\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool) {\\n        return rolesOf(user) & roles == roles;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by an account with `roles`.\\n    modifier onlyRoles(uint256 roles) virtual {\\n        _checkRoles(roles);\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by the owner or by an account\\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\\n        _checkOwnerOrRoles(roles);\\n        _;\\n    }\\n\\n    /// @dev Marks a function as only callable by an account with `roles`\\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\\n        _checkRolesOrOwner(roles);\\n        _;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ROLE CONSTANTS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // IYKYK\\n\\n    uint256 internal constant _ROLE_0 = 1 << 0;\\n    uint256 internal constant _ROLE_1 = 1 << 1;\\n    uint256 internal constant _ROLE_2 = 1 << 2;\\n    uint256 internal constant _ROLE_3 = 1 << 3;\\n    uint256 internal constant _ROLE_4 = 1 << 4;\\n    uint256 internal constant _ROLE_5 = 1 << 5;\\n    uint256 internal constant _ROLE_6 = 1 << 6;\\n    uint256 internal constant _ROLE_7 = 1 << 7;\\n    uint256 internal constant _ROLE_8 = 1 << 8;\\n    uint256 internal constant _ROLE_9 = 1 << 9;\\n    uint256 internal constant _ROLE_10 = 1 << 10;\\n    uint256 internal constant _ROLE_11 = 1 << 11;\\n    uint256 internal constant _ROLE_12 = 1 << 12;\\n    uint256 internal constant _ROLE_13 = 1 << 13;\\n    uint256 internal constant _ROLE_14 = 1 << 14;\\n    uint256 internal constant _ROLE_15 = 1 << 15;\\n    uint256 internal constant _ROLE_16 = 1 << 16;\\n    uint256 internal constant _ROLE_17 = 1 << 17;\\n    uint256 internal constant _ROLE_18 = 1 << 18;\\n    uint256 internal constant _ROLE_19 = 1 << 19;\\n    uint256 internal constant _ROLE_20 = 1 << 20;\\n    uint256 internal constant _ROLE_21 = 1 << 21;\\n    uint256 internal constant _ROLE_22 = 1 << 22;\\n    uint256 internal constant _ROLE_23 = 1 << 23;\\n    uint256 internal constant _ROLE_24 = 1 << 24;\\n    uint256 internal constant _ROLE_25 = 1 << 25;\\n    uint256 internal constant _ROLE_26 = 1 << 26;\\n    uint256 internal constant _ROLE_27 = 1 << 27;\\n    uint256 internal constant _ROLE_28 = 1 << 28;\\n    uint256 internal constant _ROLE_29 = 1 << 29;\\n    uint256 internal constant _ROLE_30 = 1 << 30;\\n    uint256 internal constant _ROLE_31 = 1 << 31;\\n    uint256 internal constant _ROLE_32 = 1 << 32;\\n    uint256 internal constant _ROLE_33 = 1 << 33;\\n    uint256 internal constant _ROLE_34 = 1 << 34;\\n    uint256 internal constant _ROLE_35 = 1 << 35;\\n    uint256 internal constant _ROLE_36 = 1 << 36;\\n    uint256 internal constant _ROLE_37 = 1 << 37;\\n    uint256 internal constant _ROLE_38 = 1 << 38;\\n    uint256 internal constant _ROLE_39 = 1 << 39;\\n    uint256 internal constant _ROLE_40 = 1 << 40;\\n    uint256 internal constant _ROLE_41 = 1 << 41;\\n    uint256 internal constant _ROLE_42 = 1 << 42;\\n    uint256 internal constant _ROLE_43 = 1 << 43;\\n    uint256 internal constant _ROLE_44 = 1 << 44;\\n    uint256 internal constant _ROLE_45 = 1 << 45;\\n    uint256 internal constant _ROLE_46 = 1 << 46;\\n    uint256 internal constant _ROLE_47 = 1 << 47;\\n    uint256 internal constant _ROLE_48 = 1 << 48;\\n    uint256 internal constant _ROLE_49 = 1 << 49;\\n    uint256 internal constant _ROLE_50 = 1 << 50;\\n    uint256 internal constant _ROLE_51 = 1 << 51;\\n    uint256 internal constant _ROLE_52 = 1 << 52;\\n    uint256 internal constant _ROLE_53 = 1 << 53;\\n    uint256 internal constant _ROLE_54 = 1 << 54;\\n    uint256 internal constant _ROLE_55 = 1 << 55;\\n    uint256 internal constant _ROLE_56 = 1 << 56;\\n    uint256 internal constant _ROLE_57 = 1 << 57;\\n    uint256 internal constant _ROLE_58 = 1 << 58;\\n    uint256 internal constant _ROLE_59 = 1 << 59;\\n    uint256 internal constant _ROLE_60 = 1 << 60;\\n    uint256 internal constant _ROLE_61 = 1 << 61;\\n    uint256 internal constant _ROLE_62 = 1 << 62;\\n    uint256 internal constant _ROLE_63 = 1 << 63;\\n    uint256 internal constant _ROLE_64 = 1 << 64;\\n    uint256 internal constant _ROLE_65 = 1 << 65;\\n    uint256 internal constant _ROLE_66 = 1 << 66;\\n    uint256 internal constant _ROLE_67 = 1 << 67;\\n    uint256 internal constant _ROLE_68 = 1 << 68;\\n    uint256 internal constant _ROLE_69 = 1 << 69;\\n    uint256 internal constant _ROLE_70 = 1 << 70;\\n    uint256 internal constant _ROLE_71 = 1 << 71;\\n    uint256 internal constant _ROLE_72 = 1 << 72;\\n    uint256 internal constant _ROLE_73 = 1 << 73;\\n    uint256 internal constant _ROLE_74 = 1 << 74;\\n    uint256 internal constant _ROLE_75 = 1 << 75;\\n    uint256 internal constant _ROLE_76 = 1 << 76;\\n    uint256 internal constant _ROLE_77 = 1 << 77;\\n    uint256 internal constant _ROLE_78 = 1 << 78;\\n    uint256 internal constant _ROLE_79 = 1 << 79;\\n    uint256 internal constant _ROLE_80 = 1 << 80;\\n    uint256 internal constant _ROLE_81 = 1 << 81;\\n    uint256 internal constant _ROLE_82 = 1 << 82;\\n    uint256 internal constant _ROLE_83 = 1 << 83;\\n    uint256 internal constant _ROLE_84 = 1 << 84;\\n    uint256 internal constant _ROLE_85 = 1 << 85;\\n    uint256 internal constant _ROLE_86 = 1 << 86;\\n    uint256 internal constant _ROLE_87 = 1 << 87;\\n    uint256 internal constant _ROLE_88 = 1 << 88;\\n    uint256 internal constant _ROLE_89 = 1 << 89;\\n    uint256 internal constant _ROLE_90 = 1 << 90;\\n    uint256 internal constant _ROLE_91 = 1 << 91;\\n    uint256 internal constant _ROLE_92 = 1 << 92;\\n    uint256 internal constant _ROLE_93 = 1 << 93;\\n    uint256 internal constant _ROLE_94 = 1 << 94;\\n    uint256 internal constant _ROLE_95 = 1 << 95;\\n    uint256 internal constant _ROLE_96 = 1 << 96;\\n    uint256 internal constant _ROLE_97 = 1 << 97;\\n    uint256 internal constant _ROLE_98 = 1 << 98;\\n    uint256 internal constant _ROLE_99 = 1 << 99;\\n    uint256 internal constant _ROLE_100 = 1 << 100;\\n    uint256 internal constant _ROLE_101 = 1 << 101;\\n    uint256 internal constant _ROLE_102 = 1 << 102;\\n    uint256 internal constant _ROLE_103 = 1 << 103;\\n    uint256 internal constant _ROLE_104 = 1 << 104;\\n    uint256 internal constant _ROLE_105 = 1 << 105;\\n    uint256 internal constant _ROLE_106 = 1 << 106;\\n    uint256 internal constant _ROLE_107 = 1 << 107;\\n    uint256 internal constant _ROLE_108 = 1 << 108;\\n    uint256 internal constant _ROLE_109 = 1 << 109;\\n    uint256 internal constant _ROLE_110 = 1 << 110;\\n    uint256 internal constant _ROLE_111 = 1 << 111;\\n    uint256 internal constant _ROLE_112 = 1 << 112;\\n    uint256 internal constant _ROLE_113 = 1 << 113;\\n    uint256 internal constant _ROLE_114 = 1 << 114;\\n    uint256 internal constant _ROLE_115 = 1 << 115;\\n    uint256 internal constant _ROLE_116 = 1 << 116;\\n    uint256 internal constant _ROLE_117 = 1 << 117;\\n    uint256 internal constant _ROLE_118 = 1 << 118;\\n    uint256 internal constant _ROLE_119 = 1 << 119;\\n    uint256 internal constant _ROLE_120 = 1 << 120;\\n    uint256 internal constant _ROLE_121 = 1 << 121;\\n    uint256 internal constant _ROLE_122 = 1 << 122;\\n    uint256 internal constant _ROLE_123 = 1 << 123;\\n    uint256 internal constant _ROLE_124 = 1 << 124;\\n    uint256 internal constant _ROLE_125 = 1 << 125;\\n    uint256 internal constant _ROLE_126 = 1 << 126;\\n    uint256 internal constant _ROLE_127 = 1 << 127;\\n    uint256 internal constant _ROLE_128 = 1 << 128;\\n    uint256 internal constant _ROLE_129 = 1 << 129;\\n    uint256 internal constant _ROLE_130 = 1 << 130;\\n    uint256 internal constant _ROLE_131 = 1 << 131;\\n    uint256 internal constant _ROLE_132 = 1 << 132;\\n    uint256 internal constant _ROLE_133 = 1 << 133;\\n    uint256 internal constant _ROLE_134 = 1 << 134;\\n    uint256 internal constant _ROLE_135 = 1 << 135;\\n    uint256 internal constant _ROLE_136 = 1 << 136;\\n    uint256 internal constant _ROLE_137 = 1 << 137;\\n    uint256 internal constant _ROLE_138 = 1 << 138;\\n    uint256 internal constant _ROLE_139 = 1 << 139;\\n    uint256 internal constant _ROLE_140 = 1 << 140;\\n    uint256 internal constant _ROLE_141 = 1 << 141;\\n    uint256 internal constant _ROLE_142 = 1 << 142;\\n    uint256 internal constant _ROLE_143 = 1 << 143;\\n    uint256 internal constant _ROLE_144 = 1 << 144;\\n    uint256 internal constant _ROLE_145 = 1 << 145;\\n    uint256 internal constant _ROLE_146 = 1 << 146;\\n    uint256 internal constant _ROLE_147 = 1 << 147;\\n    uint256 internal constant _ROLE_148 = 1 << 148;\\n    uint256 internal constant _ROLE_149 = 1 << 149;\\n    uint256 internal constant _ROLE_150 = 1 << 150;\\n    uint256 internal constant _ROLE_151 = 1 << 151;\\n    uint256 internal constant _ROLE_152 = 1 << 152;\\n    uint256 internal constant _ROLE_153 = 1 << 153;\\n    uint256 internal constant _ROLE_154 = 1 << 154;\\n    uint256 internal constant _ROLE_155 = 1 << 155;\\n    uint256 internal constant _ROLE_156 = 1 << 156;\\n    uint256 internal constant _ROLE_157 = 1 << 157;\\n    uint256 internal constant _ROLE_158 = 1 << 158;\\n    uint256 internal constant _ROLE_159 = 1 << 159;\\n    uint256 internal constant _ROLE_160 = 1 << 160;\\n    uint256 internal constant _ROLE_161 = 1 << 161;\\n    uint256 internal constant _ROLE_162 = 1 << 162;\\n    uint256 internal constant _ROLE_163 = 1 << 163;\\n    uint256 internal constant _ROLE_164 = 1 << 164;\\n    uint256 internal constant _ROLE_165 = 1 << 165;\\n    uint256 internal constant _ROLE_166 = 1 << 166;\\n    uint256 internal constant _ROLE_167 = 1 << 167;\\n    uint256 internal constant _ROLE_168 = 1 << 168;\\n    uint256 internal constant _ROLE_169 = 1 << 169;\\n    uint256 internal constant _ROLE_170 = 1 << 170;\\n    uint256 internal constant _ROLE_171 = 1 << 171;\\n    uint256 internal constant _ROLE_172 = 1 << 172;\\n    uint256 internal constant _ROLE_173 = 1 << 173;\\n    uint256 internal constant _ROLE_174 = 1 << 174;\\n    uint256 internal constant _ROLE_175 = 1 << 175;\\n    uint256 internal constant _ROLE_176 = 1 << 176;\\n    uint256 internal constant _ROLE_177 = 1 << 177;\\n    uint256 internal constant _ROLE_178 = 1 << 178;\\n    uint256 internal constant _ROLE_179 = 1 << 179;\\n    uint256 internal constant _ROLE_180 = 1 << 180;\\n    uint256 internal constant _ROLE_181 = 1 << 181;\\n    uint256 internal constant _ROLE_182 = 1 << 182;\\n    uint256 internal constant _ROLE_183 = 1 << 183;\\n    uint256 internal constant _ROLE_184 = 1 << 184;\\n    uint256 internal constant _ROLE_185 = 1 << 185;\\n    uint256 internal constant _ROLE_186 = 1 << 186;\\n    uint256 internal constant _ROLE_187 = 1 << 187;\\n    uint256 internal constant _ROLE_188 = 1 << 188;\\n    uint256 internal constant _ROLE_189 = 1 << 189;\\n    uint256 internal constant _ROLE_190 = 1 << 190;\\n    uint256 internal constant _ROLE_191 = 1 << 191;\\n    uint256 internal constant _ROLE_192 = 1 << 192;\\n    uint256 internal constant _ROLE_193 = 1 << 193;\\n    uint256 internal constant _ROLE_194 = 1 << 194;\\n    uint256 internal constant _ROLE_195 = 1 << 195;\\n    uint256 internal constant _ROLE_196 = 1 << 196;\\n    uint256 internal constant _ROLE_197 = 1 << 197;\\n    uint256 internal constant _ROLE_198 = 1 << 198;\\n    uint256 internal constant _ROLE_199 = 1 << 199;\\n    uint256 internal constant _ROLE_200 = 1 << 200;\\n    uint256 internal constant _ROLE_201 = 1 << 201;\\n    uint256 internal constant _ROLE_202 = 1 << 202;\\n    uint256 internal constant _ROLE_203 = 1 << 203;\\n    uint256 internal constant _ROLE_204 = 1 << 204;\\n    uint256 internal constant _ROLE_205 = 1 << 205;\\n    uint256 internal constant _ROLE_206 = 1 << 206;\\n    uint256 internal constant _ROLE_207 = 1 << 207;\\n    uint256 internal constant _ROLE_208 = 1 << 208;\\n    uint256 internal constant _ROLE_209 = 1 << 209;\\n    uint256 internal constant _ROLE_210 = 1 << 210;\\n    uint256 internal constant _ROLE_211 = 1 << 211;\\n    uint256 internal constant _ROLE_212 = 1 << 212;\\n    uint256 internal constant _ROLE_213 = 1 << 213;\\n    uint256 internal constant _ROLE_214 = 1 << 214;\\n    uint256 internal constant _ROLE_215 = 1 << 215;\\n    uint256 internal constant _ROLE_216 = 1 << 216;\\n    uint256 internal constant _ROLE_217 = 1 << 217;\\n    uint256 internal constant _ROLE_218 = 1 << 218;\\n    uint256 internal constant _ROLE_219 = 1 << 219;\\n    uint256 internal constant _ROLE_220 = 1 << 220;\\n    uint256 internal constant _ROLE_221 = 1 << 221;\\n    uint256 internal constant _ROLE_222 = 1 << 222;\\n    uint256 internal constant _ROLE_223 = 1 << 223;\\n    uint256 internal constant _ROLE_224 = 1 << 224;\\n    uint256 internal constant _ROLE_225 = 1 << 225;\\n    uint256 internal constant _ROLE_226 = 1 << 226;\\n    uint256 internal constant _ROLE_227 = 1 << 227;\\n    uint256 internal constant _ROLE_228 = 1 << 228;\\n    uint256 internal constant _ROLE_229 = 1 << 229;\\n    uint256 internal constant _ROLE_230 = 1 << 230;\\n    uint256 internal constant _ROLE_231 = 1 << 231;\\n    uint256 internal constant _ROLE_232 = 1 << 232;\\n    uint256 internal constant _ROLE_233 = 1 << 233;\\n    uint256 internal constant _ROLE_234 = 1 << 234;\\n    uint256 internal constant _ROLE_235 = 1 << 235;\\n    uint256 internal constant _ROLE_236 = 1 << 236;\\n    uint256 internal constant _ROLE_237 = 1 << 237;\\n    uint256 internal constant _ROLE_238 = 1 << 238;\\n    uint256 internal constant _ROLE_239 = 1 << 239;\\n    uint256 internal constant _ROLE_240 = 1 << 240;\\n    uint256 internal constant _ROLE_241 = 1 << 241;\\n    uint256 internal constant _ROLE_242 = 1 << 242;\\n    uint256 internal constant _ROLE_243 = 1 << 243;\\n    uint256 internal constant _ROLE_244 = 1 << 244;\\n    uint256 internal constant _ROLE_245 = 1 << 245;\\n    uint256 internal constant _ROLE_246 = 1 << 246;\\n    uint256 internal constant _ROLE_247 = 1 << 247;\\n    uint256 internal constant _ROLE_248 = 1 << 248;\\n    uint256 internal constant _ROLE_249 = 1 << 249;\\n    uint256 internal constant _ROLE_250 = 1 << 250;\\n    uint256 internal constant _ROLE_251 = 1 << 251;\\n    uint256 internal constant _ROLE_252 = 1 << 252;\\n    uint256 internal constant _ROLE_253 = 1 << 253;\\n    uint256 internal constant _ROLE_254 = 1 << 254;\\n    uint256 internal constant _ROLE_255 = 1 << 255;\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/utils/LibMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for storage of packed unsigned integers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibMap.sol)\\nlibrary LibMap {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STRUCTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev A uint8 map in storage.\\n    struct Uint8Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint16 map in storage.\\n    struct Uint16Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint32 map in storage.\\n    struct Uint32Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint40 map in storage. Useful for storing timestamps up to 34841 A.D.\\n    struct Uint40Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint64 map in storage.\\n    struct Uint64Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /// @dev A uint128 map in storage.\\n    struct Uint128Map {\\n        mapping(uint256 => uint256) map;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         OPERATIONS                         */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the uint8 value at `index` in `map`.\\n    function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(5, index))\\n            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))\\n        }\\n    }\\n\\n    /// @dev Updates the uint8 value at `index` in `map`.\\n    function set(Uint8Map storage map, uint256 index, uint8 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(5, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            mstore(0x00, sload(s))\\n            mstore8(and(31, not(index)), value)\\n            sstore(s, mload(0x00))\\n        }\\n    }\\n\\n    /// @dev Returns the uint16 value at `index` in `map`.\\n    function get(Uint16Map storage map, uint256 index) internal view returns (uint16 result) {\\n        result = uint16(map.map[index >> 4] >> ((index & 15) << 4));\\n    }\\n\\n    /// @dev Updates the uint16 value at `index` in `map`.\\n    function set(Uint16Map storage map, uint256 index, uint16 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(4, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(4, and(index, 15)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint32 value at `index` in `map`.\\n    function get(Uint32Map storage map, uint256 index) internal view returns (uint32 result) {\\n        result = uint32(map.map[index >> 3] >> ((index & 7) << 5));\\n    }\\n\\n    /// @dev Updates the uint32 value at `index` in `map`.\\n    function set(Uint32Map storage map, uint256 index, uint32 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(3, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint40 value at `index` in `map`.\\n    function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {\\n        unchecked {\\n            result = uint40(map.map[index / 6] >> ((index % 6) * 40));\\n        }\\n    }\\n\\n    /// @dev Updates the uint40 value at `index` in `map`.\\n    function set(Uint40Map storage map, uint256 index, uint40 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, div(index, 6))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint64 value at `index` in `map`.\\n    function get(Uint64Map storage map, uint256 index) internal view returns (uint64 result) {\\n        result = uint64(map.map[index >> 2] >> ((index & 3) << 6));\\n    }\\n\\n    /// @dev Updates the uint64 value at `index` in `map`.\\n    function set(Uint64Map storage map, uint256 index, uint64 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(2, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(6, and(index, 3)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n\\n    /// @dev Returns the uint128 value at `index` in `map`.\\n    function get(Uint128Map storage map, uint256 index) internal view returns (uint128 result) {\\n        result = uint128(map.map[index >> 1] >> ((index & 1) << 7));\\n    }\\n\\n    /// @dev Updates the uint128 value at `index` in `map`.\\n    function set(Uint128Map storage map, uint256 index, uint128 value) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, map.slot)\\n            mstore(0x00, shr(1, index))\\n            let s := keccak256(0x00, 0x40) // Storage slot.\\n            let o := shl(7, and(index, 1)) // Storage slot offset (bits).\\n            let v := sload(s) // Storage slot value.\\n            let m := 0xffffffffffffffffffffffffffffffff // Value mask.\\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Nchart.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\nimport \\\"@solady/tokens/ERC20.sol\\\";\\nimport \\\"@solady/auth/Ownable.sol\\\";\\nimport \\\"@openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IUniswapV2Factory.sol\\\";\\nimport \\\"./IUniswapV2Router02.sol\\\";\\n\\ncontract Nchart is ERC20, Ownable {\\n    struct User {\\n        bool isBlacklisted;\\n        bool isAutomatedMarketMaker;\\n        bool isExcludedFromFees;\\n        bool isExcludedFromMaxTransactionAmount;\\n    }\\n\\n    struct Fees {\\n        uint8 buy;\\n        uint8 sell;\\n        uint8 liquidity;\\n        uint8 revShare;\\n        uint8 team;\\n    }\\n\\n    struct Settings {\\n        bool limitsInEffect;\\n        bool swapEnabled;\\n        bool blacklistRenounced;\\n        bool feeChangeRenounced;\\n        bool tradingActive;\\n        /// @dev Upon enabling trading, record the end block for bot protection fee\\n        /// @dev This fee is a 90% fee that is reduced by 5% every block for 18 blocks.\\n        uint216 endBlock;\\n    }\\n\\n    IUniswapV2Router02 public immutable uniswapV2Router;\\n    address public immutable uniswapV2Pair;\\n\\n    /// @dev Constant to access the allowance slot\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n    uint256 public constant MAX_SUPPLY = 10_000_000 * 1e18;\\n    uint256 public constant MIN_SWAP_AMOUNT = MAX_SUPPLY / 100_000; // 0.001%\\n    uint256 public constant MAX_SWAP_AMOUNT = MAX_SUPPLY * 5 / 1_000; // 0.5%\\n\\n    uint256 public maxTransactionAmount;\\n    uint256 public swapTokensAtAmount;\\n    uint256 public maxWallet;\\n\\n    address public revShareWallet;\\n    address public teamWallet;\\n\\n    bool private _swapping;\\n\\n    uint256 public tokensForBotProtection;\\n\\n    Fees public feeAmounts;\\n\\n    Settings private settings = Settings({\\n        limitsInEffect: true,\\n        swapEnabled: true,\\n        blacklistRenounced: false,\\n        feeChangeRenounced: false,\\n        tradingActive: false,\\n        endBlock: uint216(0)\\n    });\\n\\n    mapping(address => User) private _users;\\n\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event ExcludeFromMaxTransaction(address indexed account, bool isExcluded);\\n    event FailedSwapBackTransfer(address indexed destination, uint256 amount);\\n    event FeesUpdated(uint8 buyFee, uint8 sellFee, uint8 revSharePercent, uint8 liquidityPercent, uint8 teamPercent);\\n    event MaxTransactionAmountUpdated(uint256 newAmount, uint256 oldAmount);\\n    event MaxWalletAmountUpdated(uint256 newAmount, uint256 oldAmount);\\n    event RevShareWalletUpdated(address indexed newWallet, address indexed oldWallet);\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool value);\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived);\\n    event SwapTokensAtAmountUpdated(uint256 newAmount, uint256 oldAmount);\\n    event TeamWalletUpdated(address indexed newWallet, address indexed oldWallet);\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\n\\n    error Nchart__BlacklistModificationDisabled();\\n    error Nchart__BuyAmountGreaterThanMax();\\n    error Nchart__CannotBlacklistLPPair();\\n    error Nchart__CannotBlacklistRouter();\\n    error Nchart__CannotRemovePairFromAMMs();\\n    error Nchart__CannotSetWalletToAddressZero();\\n    error Nchart__CannotTransferFromAddressZero();\\n    error Nchart__CannotTransferToAddressZero();\\n    error Nchart__ErrorWithdrawingEth();\\n    error Nchart__FeeChangeRenounced();\\n    error Nchart__MaxFeeFivePercent();\\n    error Nchart__MaxTransactionTooLow();\\n    error Nchart__MaxWalletAmountExceeded();\\n    error Nchart__MaxWalletAmountTooLow();\\n    error Nchart__OnlyOwner();\\n    error Nchart__ReceiverBlacklisted();\\n    error Nchart__ReceiverCannotBeAddressZero();\\n    error Nchart__SellAmountGreaterThanMax();\\n    error Nchart__SenderBlacklisted();\\n    error Nchart__StuckEthWithdrawError();\\n    error Nchart__SwapAmountGreaterThanMaximum();\\n    error Nchart__SwapAmountLowerThanMinimum();\\n    error Nchart__TokenAddressCannotBeAddressZero();\\n    error Nchart__TradingNotActive();\\n\\n    constructor(address ownerWallet, address teamWallet_, address revShareWallet_, address routerAddress) {\\n        _initializeOwner(ownerWallet);\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerAddress);\\n\\n        uniswapV2Router = _uniswapV2Router;\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\\n\\n        maxTransactionAmount = MAX_SUPPLY / 100; // 1%\\n        maxWallet = MAX_SUPPLY / 100; // 1%\\n        swapTokensAtAmount = MAX_SUPPLY * 5 / 10_000; // 0.05%\\n\\n        feeAmounts = Fees({buy: 5, sell: 5, revShare: 0, liquidity: 25, team: 75});\\n\\n        revShareWallet = revShareWallet_;\\n        teamWallet = teamWallet_;\\n\\n        _users[teamWallet_] = User({\\n            isExcludedFromFees: true,\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: false,\\n            isBlacklisted: false\\n        });\\n        _users[address(this)] = User({\\n            isExcludedFromFees: true,\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: false,\\n            isBlacklisted: false\\n        });\\n        _users[address(0xdead)] = User({\\n            isExcludedFromFees: true,\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: false,\\n            isBlacklisted: false\\n        });\\n        _users[address(ownerWallet)] = User({\\n            isExcludedFromFees: true,\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: false,\\n            isBlacklisted: false\\n        });\\n\\n        _users[address(uniswapV2Router)] = User({\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: false,\\n            isExcludedFromFees: false,\\n            isBlacklisted: false\\n        });\\n        _users[address(uniswapV2Pair)] = User({\\n            isExcludedFromMaxTransactionAmount: true,\\n            isAutomatedMarketMaker: true,\\n            isExcludedFromFees: false,\\n            isBlacklisted: false\\n        });\\n\\n        _mint(ownerWallet, MAX_SUPPLY);\\n    }\\n\\n    receive() external payable {}\\n\\n    function name() public pure override returns (string memory) {\\n        return \\\"Nchart\\\";\\n    }\\n\\n    function symbol() public pure override returns (string memory) {\\n        return \\\"CHART\\\";\\n    }\\n\\n    function enableTrading() public {\\n        _requireIsOwner();\\n        settings.endBlock = uint216(block.number) + 19;\\n        settings.tradingActive = true;\\n    }\\n\\n    // remove limits after token is stable\\n    function removeLimits() external {\\n        _requireIsOwner();\\n        settings.limitsInEffect = false;\\n    }\\n\\n    // change the minimum amount of tokens to sell from fees\\n    function updateSwapTokensAtAmount(uint256 newAmount) external {\\n        _requireIsOwner();\\n        if (newAmount < MIN_SWAP_AMOUNT) {\\n            revert Nchart__SwapAmountLowerThanMinimum();\\n        }\\n        if (newAmount > MAX_SWAP_AMOUNT) {\\n            revert Nchart__SwapAmountGreaterThanMaximum();\\n        }\\n        uint256 oldSwapAmount = swapTokensAtAmount;\\n        swapTokensAtAmount = newAmount;\\n        emit SwapTokensAtAmountUpdated(newAmount, oldSwapAmount);\\n    }\\n\\n    function updateMaxTransactionAmount(uint256 newAmount) external {\\n        _requireIsOwner();\\n        if (newAmount < MAX_SUPPLY * 5 / 1000) {\\n            revert Nchart__MaxTransactionTooLow();\\n        }\\n        uint256 oldMaxTransactionAmount = maxTransactionAmount;\\n        maxTransactionAmount = newAmount;\\n        emit MaxTransactionAmountUpdated(newAmount, oldMaxTransactionAmount);\\n    }\\n\\n    function updateMaxWalletAmount(uint256 newNum) external {\\n        _requireIsOwner();\\n        if (newNum < MAX_SUPPLY / 100) {\\n            revert Nchart__MaxWalletAmountTooLow();\\n        }\\n        uint256 oldMaxWallet = maxWallet;\\n        maxWallet = newNum;\\n        emit MaxWalletAmountUpdated(newNum, oldMaxWallet);\\n    }\\n\\n    // only use to disable contract sales if absolutely necessary (emergency use only)\\n    function updateSwapEnabled(bool enabled) external {\\n        _requireIsOwner();\\n        settings.swapEnabled = enabled;\\n    }\\n\\n    function updateBuyFees(uint8 revShareFee, uint8 liquidityFee, uint8 teamFee) external {\\n        _requireIsOwner();\\n\\n        if (settings.feeChangeRenounced) {\\n            revert Nchart__FeeChangeRenounced();\\n        }\\n\\n        uint8 totalFees = revShareFee + liquidityFee + teamFee;\\n        if (totalFees > 5) {\\n            revert Nchart__MaxFeeFivePercent();\\n        }\\n\\n        uint8 sellFee = feeAmounts.sell;\\n        uint8 revPercent = revShareFee * 100 / totalFees;\\n        uint8 liqPercent = liquidityFee * 100 / totalFees;\\n        uint8 teamPercent = 100 - revPercent - liqPercent;\\n\\n        feeAmounts =\\n            Fees({buy: totalFees, sell: sellFee, revShare: revPercent, liquidity: liqPercent, team: teamPercent});\\n        emit FeesUpdated(totalFees, sellFee, revPercent, liqPercent, teamPercent);\\n    }\\n\\n    function updateSellFees(uint8 revShareFee, uint8 liquidityFee, uint8 teamFee) external {\\n        _requireIsOwner();\\n\\n        if (settings.feeChangeRenounced) {\\n            revert Nchart__FeeChangeRenounced();\\n        }\\n\\n        uint8 totalFees = revShareFee + liquidityFee + teamFee;\\n        if (totalFees > 5) {\\n            revert Nchart__MaxFeeFivePercent();\\n        }\\n\\n        uint8 buyFee = feeAmounts.buy;\\n        uint8 revPercent = revShareFee * 100 / totalFees;\\n        uint8 liqPercent = liquidityFee * 100 / totalFees;\\n        uint8 teamPercent = 100 - revPercent - liqPercent;\\n\\n        feeAmounts =\\n            Fees({buy: buyFee, sell: totalFees, revShare: revPercent, liquidity: liqPercent, team: teamPercent});\\n        emit FeesUpdated(buyFee, totalFees, revPercent, liqPercent, teamPercent);\\n    }\\n\\n    function excludeFromFees(address account, bool excluded) external {\\n        _requireIsOwner();\\n        _users[account].isExcludedFromFees = excluded;\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n\\n    function excludeFromMaxTransaction(address account, bool isExcluded) external {\\n        _requireIsOwner();\\n        _users[account].isExcludedFromMaxTransactionAmount = isExcluded;\\n        emit ExcludeFromMaxTransaction(account, isExcluded);\\n    }\\n\\n    function setAutomatedMarketMakerPair(address pair, bool value) external {\\n        _requireIsOwner();\\n        if (pair == uniswapV2Pair) {\\n            revert Nchart__CannotRemovePairFromAMMs();\\n        }\\n\\n        _users[pair].isAutomatedMarketMaker = value;\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function updateRevShareWallet(address newWallet) external {\\n        _requireIsOwner();\\n        if (newWallet == address(0)) {\\n            revert Nchart__CannotSetWalletToAddressZero();\\n        }\\n        address oldWallet = revShareWallet;\\n        revShareWallet = newWallet;\\n        emit RevShareWalletUpdated(newWallet, oldWallet);\\n    }\\n\\n    function updateTeamWallet(address newWallet) external {\\n        _requireIsOwner();\\n        if (newWallet == address(0)) {\\n            revert Nchart__CannotSetWalletToAddressZero();\\n        }\\n        address oldWallet = teamWallet;\\n        teamWallet = newWallet;\\n        emit TeamWalletUpdated(newWallet, oldWallet);\\n    }\\n\\n    function withdrawStuckChart(uint256 amount) external {\\n        _requireIsOwner();\\n        uint256 transferAmount;\\n        if (amount == 0) {\\n            transferAmount = balanceOf(address(this));\\n        } else {\\n            transferAmount = amount;\\n        }\\n        super._transfer(address(this), msg.sender, transferAmount);\\n    }\\n\\n    function withdrawStuckToken(address _token) external {\\n        _requireIsOwner();\\n        if (_token == address(0)) {\\n            revert Nchart__TokenAddressCannotBeAddressZero();\\n        }\\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).transfer(msg.sender, _contractBalance);\\n    }\\n\\n    function withdrawStuckEth() external {\\n        _requireIsOwner();\\n        (bool success,) = msg.sender.call{value: address(this).balance}(\\\"\\\");\\n        if (!success) {\\n            revert Nchart__ErrorWithdrawingEth();\\n        }\\n    }\\n\\n    function renounceBlacklist() external {\\n        _requireIsOwner();\\n        settings.blacklistRenounced = true;\\n    }\\n\\n    function renounceFeeChange() external {\\n        _requireIsOwner();\\n        settings.feeChangeRenounced = true;\\n    }\\n\\n    function blacklist(address account) external {\\n        _requireIsOwner();\\n        if (settings.blacklistRenounced) {\\n            revert Nchart__BlacklistModificationDisabled();\\n        }\\n        if (account == uniswapV2Pair) {\\n            revert Nchart__CannotBlacklistLPPair();\\n        }\\n        if (account == address(uniswapV2Router)) {\\n            revert Nchart__CannotBlacklistRouter();\\n        }\\n        _users[account].isBlacklisted = true;\\n    }\\n\\n    // @dev unblacklist address; not affected by blacklistRenounced incase team wants to unblacklist v3 pools down the\\n    // @dev road\\n    function unblacklist(address account) external {\\n        _requireIsOwner();\\n        _users[account].isBlacklisted = false;\\n    }\\n\\n    function isExcludedFromFees(address account) external view returns (bool) {\\n        return _users[account].isExcludedFromFees;\\n    }\\n\\n    function isExcludedFromMaxTransactionAmount(address account) external view returns (bool) {\\n        return _users[account].isExcludedFromMaxTransactionAmount;\\n    }\\n\\n    function isAutomatedMarketMakerPair(address pair) external view returns (bool) {\\n        return _users[pair].isAutomatedMarketMaker;\\n    }\\n\\n    function isBlacklisted(address account) external view returns (bool) {\\n        return _users[account].isBlacklisted;\\n    }\\n\\n    function isSwapEnabled() external view returns (bool) {\\n        return settings.swapEnabled;\\n    }\\n\\n    function isBlacklistRenounced() external view returns (bool) {\\n        return settings.blacklistRenounced;\\n    }\\n\\n    function isFeeChangeRenounced() external view returns (bool) {\\n        return settings.feeChangeRenounced;\\n    }\\n\\n    function isTradingActive() external view returns (bool) {\\n        return settings.tradingActive;\\n    }\\n\\n    function isLimitInEffect() external view returns (bool) {\\n        return settings.limitsInEffect;\\n    }\\n\\n    function transfer(address to, uint256 amount) public override returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\\n        // Check allowance and reduce it if used, reverts with `InsufficientAllowance()` if not approved.\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, caller())\\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if iszero(eq(allowance_, not(0))) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 amount) internal override {\\n        // Ignore mints, burns not enabled\\n        if (from == address(0)) {\\n            revert Nchart__CannotTransferFromAddressZero();\\n        }\\n        if (to == address(0)) {\\n            revert Nchart__CannotTransferToAddressZero();\\n        }\\n\\n        User memory fromData = _users[from];\\n        User memory toData = _users[to];\\n        Settings memory settingCache = settings;\\n\\n        if (!settingCache.tradingActive) {\\n            if (!fromData.isExcludedFromFees) {\\n                if (!toData.isExcludedFromFees) {\\n                    revert Nchart__TradingNotActive();\\n                }\\n            }\\n        }\\n\\n        // Apply blacklist protection\\n        if (fromData.isBlacklisted) {\\n            revert Nchart__SenderBlacklisted();\\n        }\\n        if (toData.isBlacklisted) {\\n            revert Nchart__ReceiverBlacklisted();\\n        }\\n\\n        // If zero amount, continue\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        bool excludedFromFees = fromData.isExcludedFromFees || toData.isExcludedFromFees;\\n\\n        // Cache transaction type for reference.\\n        // 1 = Buy\\n        // 2 = Sell\\n        // 3 = Transfer\\n        uint8 txType = 3;\\n\\n        if (fromData.isAutomatedMarketMaker) {\\n            // Buys originate from the AMM pair\\n            txType = 1;\\n        } else if (toData.isAutomatedMarketMaker) {\\n            // Sells send funds to AMM pair\\n            txType = 2;\\n        }\\n\\n        if (!_swapping) {\\n            if (settingCache.limitsInEffect) {\\n                //when buy\\n                if (txType == 1 && !toData.isExcludedFromMaxTransactionAmount) {\\n                    if (amount > maxTransactionAmount) {\\n                        revert Nchart__BuyAmountGreaterThanMax();\\n                    }\\n                    if (amount + balanceOf(to) > maxWallet) {\\n                        revert Nchart__MaxWalletAmountExceeded();\\n                    }\\n                }\\n                //when sell\\n                else if (txType == 2 && !fromData.isExcludedFromMaxTransactionAmount) {\\n                    if (amount > maxTransactionAmount) {\\n                        revert Nchart__SellAmountGreaterThanMax();\\n                    }\\n                } else if (!toData.isExcludedFromMaxTransactionAmount) {\\n                    if (amount + balanceOf(to) > maxWallet) {\\n                        revert Nchart__MaxWalletAmountExceeded();\\n                    }\\n                }\\n            }\\n\\n            if (settingCache.swapEnabled) {\\n                // Only sells will trigger the fee swap\\n                if (txType == 2) {\\n                    if (balanceOf(address(this)) >= swapTokensAtAmount) {\\n                        _swapping = true;\\n                        _swapBack();\\n                        _swapping = false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (txType < 3) {\\n            bool takeFee = !_swapping;\\n\\n            // if any account belongs to _isExcludedFromFee account then remove the fee\\n            if (excludedFromFees) {\\n                takeFee = false;\\n            }\\n            uint256 fees = 0;\\n            // only take fees on buys/sells, do not take on wallet transfers\\n            if (takeFee) {\\n                Fees memory feeCache = feeAmounts;\\n                // on sell\\n                if (txType == 2) {\\n                    if (feeCache.sell > 0) {\\n                        fees = amount * feeCache.sell / 100;\\n                    }\\n                }\\n                // on buy\\n                else if (txType == 1) {\\n                    if (feeCache.buy > 0) {\\n                        fees = amount * feeCache.buy / 100;\\n                    }\\n                }\\n\\n                if (block.number < settingCache.endBlock) {\\n                    uint256 blocksLeft = settingCache.endBlock - block.number;\\n                    uint256 botFeeMultiplier = 90;\\n\\n                    // Apply sniper protection - first 18 blocks have a fee reduced 5% each block.\\n                    if (blocksLeft < 18) {\\n                        botFeeMultiplier -= (5 * (18 - blocksLeft));\\n                    }\\n                    uint256 botFee = (amount * botFeeMultiplier) / 100;\\n                    super._transfer(from, teamWallet, botFee);\\n                    amount -= botFee;\\n                    tokensForBotProtection += botFee;\\n                }\\n\\n                amount -= fees;\\n\\n                if (fees > 0) {\\n                    super._transfer(from, address(this), fees);\\n                }\\n            }\\n        }\\n        super._transfer(from, to, amount);\\n    }\\n\\n    function _swapTokensForEth(uint256 tokenAmount) internal {\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {\\n        // approve token transfer to cover all possible scenarios\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n\\n        // add the liquidity\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            owner(),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _swapBack() internal {\\n        // Cache values\\n        uint256 contractBalance = balanceOf(address(this));\\n        Fees memory feeCache = feeAmounts;\\n        bool success;\\n\\n        if (contractBalance == 0) {\\n            return;\\n        }\\n\\n        // Prevent too many tokens from being swapped\\n        uint256 maxAmount = swapTokensAtAmount * 20;\\n        if (contractBalance > maxAmount) {\\n            contractBalance = maxAmount;\\n        }\\n\\n        uint256 liquidityAmount = contractBalance * feeCache.liquidity / 100;\\n\\n        // Halve the amount of liquidity tokens\\n        uint256 liquidityTokens = liquidityAmount - (liquidityAmount / 2);\\n        uint256 amountToSwapForETH = contractBalance - liquidityTokens;\\n\\n        uint256 initialETHBalance = address(this).balance;\\n\\n        _swapTokensForEth(amountToSwapForETH);\\n\\n        uint256 ethBalance = address(this).balance - initialETHBalance;\\n\\n        uint256 ethForRevShare = ethBalance * feeCache.revShare / 100;\\n        uint256 ethForTeam = ethBalance * feeCache.team / 100;\\n        uint256 ethForLiquidity = ethBalance - ethForRevShare - ethForTeam;\\n\\n        if (liquidityTokens > 0 && ethForLiquidity > 0) {\\n            _addLiquidity(liquidityTokens, ethForLiquidity);\\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity);\\n        }\\n\\n        address teamWallet_ = teamWallet;\\n\\n        (success,) = address(teamWallet_).call{value: ethForTeam}(\\\"\\\");\\n        if (!success) {\\n            emit FailedSwapBackTransfer(teamWallet_, ethForTeam);\\n        }\\n\\n        if (ethForRevShare > 0) {\\n            (success,) = address(revShareWallet).call{value: ethForRevShare}(\\\"\\\");\\n            if (!success) {\\n                emit FailedSwapBackTransfer(revShareWallet, ethForRevShare);\\n            }\\n        }\\n    }\\n\\n    function _requireIsOwner() internal view {\\n        if (msg.sender != owner()) {\\n            revert Nchart__OnlyOwner();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\nimport \\\"./IUniswapV2Router01.sol\\\";\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/auth/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n/// @dev While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Store the new value.\\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ownerSlot := not(_OWNER_SLOT_NOT)\\n            // Clean the upper 96 bits.\\n            newOwner := shr(96, shl(96, newOwner))\\n            // Emit the {OwnershipTransferred} event.\\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n            // Store the new value.\\n            sstore(ownerSlot, newOwner)\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(not(_OWNER_SLOT_NOT))\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solady/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple ERC20 + EIP-2612 implementation.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\\n///\\n/// @dev Note:\\n/// The ERC20 standard allows minting and transferring to and from the zero address,\\n/// minting and transferring zero tokens, as well as self-approvals.\\n/// For performance, this implementation WILL NOT revert for such actions.\\n/// Please add any checks with overrides if desired.\\nabstract contract ERC20 {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The total supply has overflowed.\\n    error TotalSupplyOverflow();\\n\\n    /// @dev The allowance has overflowed.\\n    error AllowanceOverflow();\\n\\n    /// @dev The allowance has underflowed.\\n    error AllowanceUnderflow();\\n\\n    /// @dev Insufficient balance.\\n    error InsufficientBalance();\\n\\n    /// @dev Insufficient allowance.\\n    error InsufficientAllowance();\\n\\n    /// @dev The permit is invalid.\\n    error InvalidPermit();\\n\\n    /// @dev The permit has expired.\\n    error PermitExpired();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /// @dev `keccak256(bytes(\\\"Transfer(address,address,uint256)\\\"))`.\\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\\n\\n    /// @dev `keccak256(bytes(\\\"Approval(address,address,uint256)\\\"))`.\\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The storage slot for the total supply.\\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\\n\\n    /// @dev The balance slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\\n\\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\\n    /// ```\\n    ///     mstore(0x20, spender)\\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\\n    /// ```\\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\\n\\n    /// @dev The nonce slot of `owner` is given by:\\n    /// ```\\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\\n    ///     mstore(0x00, owner)\\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\\n    /// ```\\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ERC20 METADATA                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the name of the token.\\n    function name() public view virtual returns (string memory);\\n\\n    /// @dev Returns the symbol of the token.\\n    function symbol() public view virtual returns (string memory);\\n\\n    /// @dev Returns the decimals places of the token.\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                           ERC20                            */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the amount of tokens in existence.\\n    function totalSupply() public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_TOTAL_SUPPLY_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens owned by `owner`.\\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x34))\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n    ///\\n    /// Emits a {Approval} event.\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Atomically increases the allowance granted to `spender` by the caller.\\n    ///\\n    /// Emits a {Approval} event.\\n    function increaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowanceBefore := sload(allowanceSlot)\\n            // Add to the allowance.\\n            let allowanceAfter := add(allowanceBefore, difference)\\n            // Revert upon overflow.\\n            if lt(allowanceAfter, allowanceBefore) {\\n                mstore(0x00, 0xf9067066) // `AllowanceOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated allowance.\\n            sstore(allowanceSlot, allowanceAfter)\\n            // Emit the {Approval} event.\\n            mstore(0x00, allowanceAfter)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Atomically decreases the allowance granted to `spender` by the caller.\\n    ///\\n    /// Emits a {Approval} event.\\n    function decreaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowanceBefore := sload(allowanceSlot)\\n            // Revert if will underflow.\\n            if lt(allowanceBefore, difference) {\\n                mstore(0x00, 0x8301ab38) // `AllowanceUnderflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated allowance.\\n            let allowanceAfter := sub(allowanceBefore, difference)\\n            sstore(allowanceSlot, allowanceAfter)\\n            // Emit the {Approval} event.\\n            mstore(0x00, allowanceAfter)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Transfer `amount` tokens from the caller to `to`.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(msg.sender, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, caller())\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @dev Transfers `amount` tokens from `from` to `to`.\\n    ///\\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\\n    ///\\n    /// Requirements:\\n    /// - `from` must at least have `amount`.\\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, caller())\\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if iszero(eq(allowance_, not(0))) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          EIP-2612                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the current nonce for `owner`.\\n    /// This value is used to compute the signature for EIP-2612 permit.\\n    function nonces(address owner) public view virtual returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\\n    /// authorized by a signed approval by `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        bytes32 domainSeparator = DOMAIN_SEPARATOR();\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Grab the free memory pointer.\\n            let m := mload(0x40)\\n            // Revert if the block timestamp greater than `deadline`.\\n            if gt(timestamp(), deadline) {\\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Clean the upper 96 bits.\\n            owner := shr(96, shl(96, owner))\\n            spender := shr(96, shl(96, spender))\\n            // Compute the nonce slot and load its value.\\n            mstore(0x0c, _NONCES_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let nonceSlot := keccak256(0x0c, 0x20)\\n            let nonceValue := sload(nonceSlot)\\n            // Increment and store the updated nonce.\\n            sstore(nonceSlot, add(nonceValue, 1))\\n            // Prepare the inner hash.\\n            // `keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")`.\\n            // forgefmt: disable-next-item\\n            mstore(m, 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9)\\n            mstore(add(m, 0x20), owner)\\n            mstore(add(m, 0x40), spender)\\n            mstore(add(m, 0x60), value)\\n            mstore(add(m, 0x80), nonceValue)\\n            mstore(add(m, 0xa0), deadline)\\n            // Prepare the outer hash.\\n            mstore(0, 0x1901)\\n            mstore(0x20, domainSeparator)\\n            mstore(0x40, keccak256(m, 0xc0))\\n            // Prepare the ecrecover calldata.\\n            mstore(0, keccak256(0x1e, 0x42))\\n            mstore(0x20, and(0xff, v))\\n            mstore(0x40, r)\\n            mstore(0x60, s)\\n            pop(staticcall(gas(), 1, 0, 0x80, 0x20, 0x20))\\n            // If the ecrecover fails, the returndatasize will be 0x00,\\n            // `owner` will be be checked if it equals the hash at 0x00,\\n            // which evaluates to false (i.e. 0), and we will revert.\\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\\n            // `owner` will be compared against the returned address at 0x20.\\n            if iszero(eq(mload(returndatasize()), owner)) {\\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Compute the allowance slot and store the value.\\n            // The `owner` is already at slot 0x20.\\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\\n            sstore(keccak256(0x2c, 0x34), value)\\n            // Emit the {Approval} event.\\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\\n            mstore(0x40, m) // Restore the free memory pointer.\\n            mstore(0x60, 0) // Restore the zero pointer.\\n        }\\n    }\\n\\n    /// @dev Returns the EIP-2612 domains separator.\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40) // Grab the free memory pointer.\\n        }\\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\\n        bytes32 nameHash = keccak256(bytes(name()));\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := result\\n            // `keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\")`.\\n            // forgefmt: disable-next-item\\n            mstore(m, 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f)\\n            mstore(add(m, 0x20), nameHash)\\n            // `keccak256(\\\"1\\\")`.\\n            // forgefmt: disable-next-item\\n            mstore(add(m, 0x40), 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6)\\n            mstore(add(m, 0x60), chainid())\\n            mstore(add(m, 0x80), address())\\n            result := keccak256(m, 0xa0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL MINT FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _mint(address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(address(0), to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\\n            // Revert if the total supply overflows.\\n            if lt(totalSupplyAfter, totalSupplyBefore) {\\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(address(0), to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  INTERNAL BURN FUNCTIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\\n    ///\\n    /// Emits a {Transfer} event.\\n    function _burn(address from, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, address(0), amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, _BALANCE_SLOT_SEED)\\n            mstore(0x00, from)\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Subtract and store the updated total supply.\\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\\n        }\\n        _afterTokenTransfer(from, address(0), amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Moves `amount` of tokens from `from` to `to`.\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        _beforeTokenTransfer(from, to, amount);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let from_ := shl(96, from)\\n            // Compute the balance slot and load its value.\\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\\n            let fromBalance := sload(fromBalanceSlot)\\n            // Revert if insufficient balance.\\n            if gt(amount, fromBalance) {\\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Subtract and store the updated balance.\\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\\n            // Compute the balance slot of `to`.\\n            mstore(0x00, to)\\n            let toBalanceSlot := keccak256(0x0c, 0x20)\\n            // Add and store the updated balance of `to`.\\n            // Will not overflow because the sum of all user balances\\n            // cannot exceed the maximum uint256 value.\\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\\n            // Emit the {Transfer} event.\\n            mstore(0x20, amount)\\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\\n        }\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the allowance slot and load its value.\\n            mstore(0x20, spender)\\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\\n            mstore(0x00, owner)\\n            let allowanceSlot := keccak256(0x0c, 0x34)\\n            let allowance_ := sload(allowanceSlot)\\n            // If the allowance is not the maximum uint256 value.\\n            if iszero(eq(allowance_, not(0))) {\\n                // Revert if the amount to be transferred exceeds the allowance.\\n                if gt(amount, allowance_) {\\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Subtract and store the updated allowance.\\n                sstore(allowanceSlot, sub(allowance_, amount))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\\n    ///\\n    /// Emits a {Approval} event.\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let owner_ := shl(96, owner)\\n            // Compute the allowance slot and store the amount.\\n            mstore(0x20, spender)\\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\\n            sstore(keccak256(0x0c, 0x34), amount)\\n            // Emit the {Approval} event.\\n            mstore(0x00, amount)\\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     HOOKS TO OVERRIDE                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Hook that is called before any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /// @dev Hook that is called after any transfer of tokens.\\n    /// This includes minting and burning.\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint256) external view returns (address pair);\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"src/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external returns (address);\\n    function WETH() external returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)\\n        external\\n        payable\\n        returns (uint256[] memory amounts);\\n\\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\\n        external\\n        pure\\n        returns (uint256 amountOut);\\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\\n        external\\n        pure\\n        returns (uint256 amountIn);\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@solady/=lib/solady/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solady/=lib/solady/\",\r\n      \"lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/\",\r\n      \"lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/\",\r\n      \"lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"lib/solady:ds-test/=lib/solady/lib/ds-test/src/\",\r\n      \"lib/solady:forge-std/=lib/solady/test/utils/forge-std/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"chart_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__BurnPercentMustBeGreaterThan50\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__BurnPercentMustBeLessThan100\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__CanOnlyIncreaseExpiration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__CannotReduceMoreThanSubscriptionPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__CannotReferSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__CannotRegisterAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__ErrorRetrievingPriceFromDataFeed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__ErrorSendingKeeperFunds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"msgValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethRequired\",\"type\":\"uint256\"}],\"name\":\"SubscriptionManager__InvalidETHAmountProvided\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__MaxFiftyPercentReferralPercent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__MustProvideAtLeastOneAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SubscriptionManager__UseRegisterAddressesFunction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newPercent\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldPercent\",\"type\":\"uint8\"}],\"name\":\"BurnPercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralFeePriceReductionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newPercent\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldPercent\",\"type\":\"uint8\"}],\"name\":\"ReferralPercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"RolesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLength\",\"type\":\"uint256\"}],\"name\":\"SubscriptionLengthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"expirationTimestamp\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"SubscriptionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPrice\",\"type\":\"uint256\"}],\"name\":\"SubscriptionPriceUpdated\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"KEEPER_ROLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"}],\"name\":\"burnETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chart\",\"outputs\":[{\"internalType\":\"contract Nchart\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getExpiration\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newKeeper\",\"type\":\"address\"}],\"name\":\"grantKeeperRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"grantRoles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"hasAllRoles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"hasAnyRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isAddressRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralFeePriceReduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"registerAddresses\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"renounceRoles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toRevoke\",\"type\":\"address\"}],\"name\":\"revokeKeeperRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"name\":\"revokeRoles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"rolesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roles\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newPercent\",\"type\":\"uint8\"}],\"name\":\"setBurnPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"newExpiration\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"setExpirationTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setReferralFeePriceReduction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newPercent\",\"type\":\"uint8\"}],\"name\":\"setReferralPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"newSubscriptionLength\",\"type\":\"uint40\"}],\"name\":\"setSubscriptionLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSubscriptionPrice\",\"type\":\"uint256\"}],\"name\":\"setSubscriptionPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionLength\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SubscriptionManager", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "500000", "ConstructorArguments": "000000000000000000000000f62ac0fcae17f9195280ced4de978313effe2daa000000000000000000000000ae010a324281de301d1bfb2611ef8873d88436220000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}