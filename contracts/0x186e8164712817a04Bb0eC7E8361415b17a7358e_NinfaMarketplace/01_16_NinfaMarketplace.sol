/*----------------------------------------------------------*|
|*          ███    ██ ██ ███    ██ ███████  █████           *|
|*          ████   ██ ██ ████   ██ ██      ██   ██          *|
|*          ██ ██  ██ ██ ██ ██  ██ █████   ███████          *|
|*          ██  ██ ██ ██ ██  ██ ██ ██      ██   ██          *|
|*          ██   ████ ██ ██   ████ ██      ██   ██          *|
|*----------------------------------------------------------*/

// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import "./utils/Counters.sol";
import "./utils/RoyaltyEngineV1.sol";
import "./access/AccessControl.sol";

/*************************************************************
 * @title NinfaMarketplace                                   *
 *                                                           *
 * @notice On-chain NFT marketplace                          *
 *                                                           *
 * @custom:security-contact [email protected]                    *
 ************************************************************/

contract NinfaMarketplace is AccessControl, RoyaltyEngineV1 {
    /*----------------------------------------------------------*|
    |*  # VARIABLES                                             *|
    |*----------------------------------------------------------*/

    using Counters for Counters.Counter;
    Counters.Counter private _orderCount; // orders counter
    Counters.Counter private _offerCount; // offers counter
    address private _feeAccount; // Multisig contract that receives fees generated by the marketplace
    address private _ninfaFactory;
    uint256 private _primaryMarketOrdersFeeBps; // Ninfa Marketplace fee percentage for primary sales for orders, expressed in basis points.
    uint256 private _primaryMarketOffersFeeBps; // Ninfa Marketplace fee percentage for primary sales for offers, expressed in basis points.
    mapping(address => uint256) private _secondaryMarketFeeBps; // In order to be traded on Ninfa marketplace, collections MUST be manually approved by Ninfa's multisig contract.
    mapping(uint256 => _Order) public orders; // mapping order id to `_Order` struct.
    mapping(uint256 => _Offer) public offers; // mapping offer id to `_Offer` struct

    /*----------------------------------------------------------*|
    |*  # STRUCTS                                               *|
    |*----------------------------------------------------------*/

    /**
     * @param collection address of the ERC721 or ERC1155 contract. Doesn't require any access control besides the collection being whitelisted, i.e. msg.sender may be any address.
     * @param tokenId the NFT id, for now we only allow trading NINFA NFT's so no erc721 address is needed
     * @param unitPrice ERC-1155 unit price in ETH, or total price if ERC-721 since there is only 1 unit of each token.
     * @param erc1155Value the NFT amount, _amount == 0 for ERC721 and _amount > 0 for ERC1155
     * @param commissionReceiver receiver of commission on sales (primary AND secondary)
     * @param commissionBps commission amount, expressed in basis points 0 - 10000
     * @param operator needed in case a token operator or owner sets a payment splitter contract as the `commissionReceiver` or `seller` address respectively,
     *        an extra parameter is needed for storing the address of the token operator or owner, required for access control in case they'd want to change or cancel an order.
     * @dev therefore an additional parameter is needed to store the address of `msg.sender`
     */
    struct _Order {
        uint256 tokenId;
        uint256 unitPrice;
        uint256 erc1155Value;
        uint256 commissionBps;
        address commissionReceiver;
        address collection;
        address from;
        address operator;
    }

    struct _Offer {
        uint256 tokenId;
        uint256 unitPrice;
        uint256 erc1155Value;
        address collection;
        address from; // buyer
    }

    /*----------------------------------------------------------*|
    |*  # EVENTS                                                *|
    |*----------------------------------------------------------*/

    event OrderCreated(uint256 orderId);

    event OrderUpdated(uint256 orderId);

    event OrderDeleted(uint256 orderId);

    event OfferCreated(uint256 offerId);

    event OfferUpdated(uint256 offerId);

    event OfferDeleted(uint256 offerId);

    event CollectionWhitelisted(
        address collection,
        uint256 secondaryMarketFeeBps
    );

    event Trade(
        address indexed collection,
        uint256 indexed tokenId,
        address indexed from, // seller
        uint256 id, // we have order/offer id and all the related data stored in db.
        uint256 price,
        uint256 erc1155Value
    );

    /*----------------------------------------------------------*|
    |*  # MODIFIERS                                             *|
    |*----------------------------------------------------------*/

    /**
     * @notice ERC721 and ERC1155 collections must be whitelisted.
     * @dev if the collection has not been whitelisted, check if it is one of Ninfa's factory clones (Ninfa's self-sovreign collections)
     * @dev by checking the whitelist first with nested `if`s avoids having to make an external call unnecessarily
     */
    modifier isWhitelisted(address _collection) {
        if (_secondaryMarketFeeBps[_collection] == 0) {
            (, bytes memory authorized) = _ninfaFactory.staticcall(
                abi.encodeWithSelector(0xf6a3d24e, _collection) // function selector: 0xf6a3d24e or bytes4(keccak256("exists(address)"));
            );
            if (abi.decode(authorized, (bool)) == false) revert Unauthorized();
        }
        _;
    }

    /*----------------------------------------------------------*|
    |*  # ORDERS                                                *|
    |*----------------------------------------------------------*/

    /**
     * @notice create a new order on the marketplace by transfering an NFT to it.
     * @dev Will create a new order by sending tokens with data bytes containing function parameters
     *
     * Require:
     *
     * - can only be called by an NFT smart contract transfering an NFT to the marketplace
     * - collection must be whitelisted
     *
     */
    function _createOrder(
        address _operator, //  either the previous owner or operator, i.e. whichever address called safeTransferFrom on the ERC1155 contract
        address _from, // previous owner, i.e. seller
        uint256 _id,
        uint256 _value,
        uint256 _unitPrice,
        uint256 _commissionBps,
        address _commissionRecipient
    ) private isWhitelisted(msg.sender) {
        // `_orderCount` starts at 1
        _orderCount.increment();
        uint256 _orderId = _orderCount.current();

        // create order with new `_orderId` in orders mapping
        orders[_orderId] = _Order(
            _id,
            _unitPrice,
            _value,
            _commissionBps,
            _commissionRecipient,
            msg.sender, // collection
            _from,
            _operator
        );
        emit OrderCreated(_orderId);
    }

    //only for 1155 for updating the price and LOWER the amount
    function updateOrder(
        uint256 _erc1155RedeemAmount,
        uint256 _unitPrice,
        uint256 _orderId
    ) external {
        lowerOrderErc1155Amount(_orderId, _erc1155RedeemAmount);

        orders[_orderId].unitPrice = _unitPrice;
    }

    /**
     * @notice cancels order and transfers NFT back to owner
     * @param _orderId the Id of the order
     * @dev delete `orders[_orderId]` from storage BEFORE making external calls for transfering the NFT back to the seller (check-effects pattern)
     *
     *
     * SHOULD:
     *
     * This function does not check whether the order exists or not
     *
     */
    function deleteOrder(uint256 _orderId) external {
        _Order memory order = orders[_orderId];
        require(msg.sender == order.operator);

        delete orders[_orderId];

        _transferNFT(
            order.collection,
            address(this),
            msg.sender,
            order.tokenId,
            order.erc1155Value
        );

        emit OrderDeleted(_orderId);
    }

    /**
     * @param _unitPrice will override the old price, note that it may be 0 although this could only mean that a mistake was made
     * @dev this function doesn't enforce a positive value for `_unitPrice` in order to save a little gas for the users.
     * @dev if `_unitPrice` is set to 0, the order will be deleted from the database (not from the smart contract), see {NinfaMarketplace-OrderUpdated} modifier
     */
    function updateOrderPrice(uint256 _orderId, uint256 _unitPrice) external {
        _Order storage order = orders[_orderId];
        require(msg.sender == order.operator);

        order.unitPrice = _unitPrice;

        emit OrderUpdated(_orderId);
    }

    /**
     * @notice function to lower an order's amount of the ERC-1155 tokenId on sale, doesn't apply to ERC-721 because it is non-fungible
     * @param _erc1155RedeemAmount is the (negative) difference of tokens to be withdrawn by the seller. Should be different from 0, although not strictly required.
     */
    function lowerOrderErc1155Amount(
        uint256 _orderId,
        uint256 _erc1155RedeemAmount
    ) public {
        _Order storage order = orders[_orderId];
        require(msg.sender == order.operator);

        /// @dev warning, make changes to storage BEFORE making external calls for transfering the NFT back to the seller (check-effects-interactions pattern)
        order.erc1155Value -= _erc1155RedeemAmount;

        (bool success, ) = order.collection.call(
            abi.encodeWithSelector(
                0xf242432a, // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a
                address(this),
                msg.sender,
                order.tokenId,
                _erc1155RedeemAmount,
                ""
            )
        );
        require(success);

        if (order.erc1155Value == 0) {
            delete orders[_orderId]; // it is not possible to delete using storage pointers https://docs.soliditylang.org/en/develop/types.html#data-location
            emit OrderDeleted(_orderId);
        } else {
            emit OrderUpdated(_orderId);
        }
    }

    /*----------------------------------------------------------*|
    |*  # OFFERS                                                *|
    |*----------------------------------------------------------*/

    /**
     * @dev offers can be made independently of whether the token is on sale or not, the msg.value is used to determine the offer amount, so no function parameter is needed for that
     * @dev there is no require to check that an offer or offer doesn't already exist and if so, that the offer amount is not greater than the order itself, this was omitted in order to save gas; the frontend should check this in order to prevent mistakes from the user
     * @param _collection address of the erc721 implementation contract or proxy contract
     * @param _tokenId the token Id to make an offer to
     * @param _amount the NFT amount, _amount == 0 for ERC721 and _amount > 0 for ERC1155
     * @param _from needed in order to integrate Wert payment solution, because in every txn Wert is the `msg.sender`.
     *      using _msgSender does not represent a security risk, on the other hand, it is possible for the buyer to use this parameter simply in order to transfer the NFT to an address other than their own, this can be useful for external contract buying NFTs.
     */
    function createOffer(
        address _collection,
        uint256 _tokenId,
        uint256 _amount,
        address _from,
        uint256 _unitPrice
    ) external payable isWhitelisted(_collection) {
        _offerCount.increment(); // start count at 1
        // this has been added in order to avoid division when calculating how much should the marketplace pay a seller for accepting this offer
        require(
            msg.value == _unitPrice * _amount ||
                (_amount == 0 && msg.value == _unitPrice)
        );

        offers[_offerCount.current()] = _Offer(
            _tokenId, // uint256 tokenId;
            _unitPrice, // uint256 unitPrice;
            _amount, // uint256 amount;
            _collection, // address collection;
            _from // address from;
        );

        emit OfferCreated(_offerCount.current());
    }

    /**
     * @dev cancels offer and refunds ETH back to bidder. When an order gets filled, the offer isn't marked as cancelled, in order to allow users to claim back their money.
     * @param _offerId the Id of the offer.
     */
    function deleteOffer(uint256 _offerId) external {
        // in memory copy needed so that it is possible to delete the struct inside the storage offers mapping, while keeping check effects interact pattern intact
        _Offer memory offer = offers[_offerId];

        uint256 refund;

        if (offer.erc1155Value == 0) {
            refund = offer.unitPrice;
        } else {
            refund = offer.unitPrice * offer.erc1155Value;
        }
        require(msg.sender == offer.from);
        // mark offer as cancelled forever, updating offer price before external call, Checks Effects Interactions pattern
        delete offers[_offerId];
        // transfer the offer amount back to bidder
        _sendValue(offer.from, refund);

        emit OfferDeleted(_offerId);
    }

    /**
     * @dev this is one of two functions called by a buyer in order to modify their offer, there are two functions, `raiseOffer()` and `lowerOffer()`, because they expect different parameters depending on whether the offer is being raised or lowerd.
     *      A `msg.value` is required, this function will add the amount sent to the old offer amount. The frontend needs to calculate the difference between the old and new offer.
     *      E.g. A buyer calls createOffer() and pays 0.1 ETH. The same buyer later wants to raise the offer to 0.3 ETH, therefore they now need to send 0.2 ETH, because 0.1 was was sent before.
     * @dev anyone can call this function, i.e. requiring that caller is offer creator is not needed
     * @param _offerId the id of the offer
     * call this function only if the new total price is greater than the old total price
     */
    function raiseOfferPrice(
        uint256 _offerId,
        uint256 _erc1155Value,
        uint256 _unitPrice
    ) external payable {
        _Offer storage _offer = offers[_offerId];

        require(
            msg.sender == _offer.from &&
                (msg.value ==
                    (_unitPrice * _erc1155Value) -
                        (_offer.unitPrice * _offer.erc1155Value) ||
                    (_erc1155Value == 0 &&
                        msg.value == _unitPrice - _offer.unitPrice))
        );

        _offer.unitPrice = _unitPrice; // transfer extra amount needed on top of older offer
        _offer.erc1155Value = _erc1155Value;

        emit OfferUpdated(_offerId);
    }

    /**
     * @dev this is one of two functions called by a buyer in order to modify their offer, there are two functions, `raiseOffer()` and `lowerOffer()`, because they expect different parameters depending on whether the offer is being raised or lowerd.
     *      In contrast with `raiseOffer()`, instead of `msg.value` this function expects a uint parameter representing the new (lower) offer; the buyer will get refunded the difference.
     *      E.g. A buyer calls createOffer() and pays 0.3 ETH. The same buyer later wants to lower the offer to 0.1 ETH, therefore they will get refunded 0.2 ETH. I.e. The amount expected by the `_newAmount` paramer is 0.1 ETH (1^17).
     * @param _offerId the id of the offer
     */
    function lowerOfferPrice(
        uint256 _offerId,
        uint256 _erc1155Amount,
        uint256 _unitPrice
    ) external {
        _Offer storage _offer = offers[_offerId];

        require(msg.sender == _offer.from);

        uint256 refund;

        if (_erc1155Amount == 0) {
            refund = _offer.unitPrice - _unitPrice;
        } else {
            refund =
                (_offer.unitPrice * _offer.erc1155Value) -
                (_unitPrice * _erc1155Amount);
            _offer.erc1155Value = _erc1155Amount;
        }

        _offer.unitPrice = _unitPrice; // needed to store result before offer price is updated
        // transfer the difference between old and new lower offer to the user
        _sendValue(msg.sender, refund);

        emit OfferUpdated(_offerId);
    }

    function acceptListedTokenOffer(
        uint256 _orderId,
        uint256 _offerId,
        uint256 _commissionBps,
        address _commissionRecipient
    ) external {
        _Order memory order = orders[_orderId];
        _Offer memory offer = offers[_offerId];

        require(
            order.operator == msg.sender &&
                order.tokenId == offer.tokenId &&
                order.collection == offer.collection
        );

        delete orders[_orderId];
        delete offers[_offerId];

        _trade(
            _Order(
                order.tokenId, // uint256 tokenId
                offer.unitPrice, // offer price, not order price
                0,
                _commissionBps, // uint256 commissionBps
                _commissionRecipient,
                order.collection, // address collection
                msg.sender, // seller
                offer.from // buyer / nft recipient
            ),
            _orderId,
            _primaryMarketOffersFeeBps
        );
    }

    /*----------------------------------------------------------*|
    |*  # TRADING                                               *|
    |*----------------------------------------------------------*/

    /**
     * @notice the collector calls this function to buy an NFT at the ask price, only if an order exists
     * @notice if someone has an open offer but calls fillOrder, the offer will remain open, meaning they will need to call cancelOffer() to get a refund. This is unlikely, as users will likely be aware of this and use the refund in order to pay for part of the order.
     * @param _id avoids having to store a mapping to order id like the deprecated `mapping(address => mapping(uint256 => uint256)) private _tokenToOrderId` which would have not worked for erc1155 as each token has a supply.
     * _orderId does not constitute a vulnerability as it is user provided, since A) a regular user will go through the frontend which gets orderId from events
     * @param _buyer needed in order to integrate Wert payment solution, because in every txn Wert is the msg.sender, although using msg.sender would cost less gas.
     * using _msgSender does not represent a security risk, on the other hand, it is possible for the buyer to use this parameter simply in order to transfer the NFT to an address other than their own, this can be useful for external contract buying NFTs.
     + @param _erc1155Value market order amount (total or partial fill).
     * `_erc1155Value == 0` corresponds to one erc721 tokenId, `_erc1155Value > 0` for erc1155 tokenIds
     *
     * MUST:
     *
     * - `msg.value` must be equal to `orders[_orderId]der.unitPrice * buyAmount`
     * - `orders[_orderId].sellAmount >= buyAmount`
     *
     */
    function fillOrder(
        uint256 _id,
        address _buyer,
        uint256 _erc1155Value
    ) external payable {
        _Order memory order = orders[_id];

        require(
            msg.value ==
                order.unitPrice * (_erc1155Value == 0 ? 1 : _erc1155Value)
        );

        // subtracting user-suplied `_erc1155Value` from order amount, transaction will revert if underflow, implicitly requiring `orders[_id]._erc1155Value >= _erc1155Value`
        if (orders[_id].erc1155Value - _erc1155Value == 0) delete orders[_id];
        else orders[_id].erc1155Value -= _erc1155Value;

        _trade(
            _Order(
                order.tokenId, // uint256 tokenId
                msg.value, // price
                _erc1155Value,
                order.commissionBps, // uint256 commissionBps
                order.commissionReceiver, // address commissionReceiver
                order.collection, // address collection
                order.from, // seller or from
                _buyer // address buyer used for nft transfer
            ),
            _id,
            _primaryMarketOrdersFeeBps // uint256 primaryFee
        );
    }

    /**
     *
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a `safeTransferFrom` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * @param _operator The address which initiated the transfer (i.e. msg.sender)
     * @param _from     The address which previously owned the token
     * @param _tokenId  The ID of the token being transferred
     * @param _value    The amount of tokens being transferred
     * @param _data     Additional data with no specified format
     * @param _data     `uint256 id` corresponding to an order to be updated or an offer to be accepted, if the `id` parameter is 0 create a new order.
     * @param _data     `uint256 unitPrice` is only required for updating an order, i.e. if `unitPrice == 0` `id` an offer id, if `unitPrice > 0` `id` is an order id
     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address _operator, //  either the previous owner or operator, whoever called safeTransferFrom on the ERC1155 contract
        address _from, // previous owner
        uint256 _tokenId,
        uint256 _value,
        bytes memory _data
    ) external returns (bytes4) {
        (
            uint256 id,
            uint256 unitPrice,
            uint256 commissionBps,
            address commissionReceiver
        ) = abi.decode(_data, (uint256, uint256, uint256, address));

        if (unitPrice == 0) {
            /*----------------------------------------------------------*|
            |*  # ACCEPT OFFER                                          *|
            |*----------------------------------------------------------*/
            // if `_value` is more than the amount the following if check will revert due to underflow,
            // intended to stop someone from sending more erc1155 tokens then there are available in the order

            _Offer memory offer = offers[id];

            require(
                offer.collection == msg.sender && offer.tokenId == _tokenId
            );

            // subtracting `_value` from offer amount, transaction will revert if underflow, implicitly requiring `offers[id]._erc1155Value >= _value`
            if (offers[id].erc1155Value - _value == 0) delete offers[id];
            else offers[id].erc1155Value -= _value;

            _trade(
                _Order(
                    _tokenId, // uint256 tokenId
                    offer.unitPrice * _value, // uint256 price (unitPrice * value)
                    _value,
                    commissionBps, // uint256 commissionBps
                    commissionReceiver, // address commissionReceiver
                    msg.sender, // address collection
                    _from, // seller
                    offer.from // buyer or operator
                ),
                id,
                _primaryMarketOffersFeeBps
            );
        } else if (id == 0) {
            /*----------------------------------------------------------*|
            |*  # CREATE ORDER                                          *|
            |*----------------------------------------------------------*/
            // if the order/offer id parameter is 0, create a new order

            _createOrder(
                _operator,
                _from,
                _tokenId,
                _value,
                unitPrice,
                commissionBps,
                commissionReceiver
            );
        } else {
            /*----------------------------------------------------------*|
            |*  # UPDATE ORDER                                          *|
            |*----------------------------------------------------------*/
            // if the user supplied a non-zero value for `unitPrice` then the `id` parameter must correspond to an order that needs to be updated
            // the operator, collection and tokenId of the NFT received by the marketplace must match the ones stored at the id provided by the operator
            // in order to avoid operators increasing allowance for orders with different (more valuable) NFTs
            _Order storage order = orders[id];

            require(
                order.operator == _operator &&
                    order.collection == msg.sender &&
                    order.tokenId == _tokenId
            );
            order.erc1155Value += _value;
            order.unitPrice = unitPrice;

            emit OrderUpdated(id);
        }

        return 0xf23a6e61;
    }

    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
     * @param _operator The address which called `safeTransferFrom` function
     * @param _from The address which previously owned the token
     * @param _tokenId The NFT identifier which is being transferred
     * @param _data Additional data with no specified format
     */
    function onERC721Received(
        address _operator,
        address _from,
        uint256 _tokenId,
        bytes calldata _data
    ) external returns (bytes4) {
        (
            uint256 id,
            uint256 unitPrice,
            uint256 commissionBps,
            address commissionReceiver
        ) = abi.decode(_data, (uint256, uint256, uint256, address));

        if (id == 0) {
            /*----------------------------------------------------------*|
            |*  # CREATE ORDER                                          *|
            |*----------------------------------------------------------*/
            // if the order/offer id parameter is 0, create a new order
            _createOrder(
                _operator,
                _from,
                _tokenId,
                0,
                unitPrice,
                commissionBps,
                commissionReceiver
            );
        } else {
            /*----------------------------------------------------------*|
            |*  # ACCEPT OFFER                                          *|
            |*----------------------------------------------------------*/
            // if `_value` is more than the amount the following if check will revert due to underflow,
            // intended to stop someone from sending more erc1155 tokens then there are available in the order
            _Offer memory offer = offers[id];

            require(
                offer.collection == msg.sender && offer.tokenId == _tokenId
            );

            delete offers[id]; // ERC-721 doesn't have any supply therefore the offer may be deleted after accepting the offer

            _trade(
                _Order(
                    _tokenId, // uint256 tokenId
                    offer.unitPrice, // uint256 price
                    0,
                    commissionBps, // uint256 commissionBps
                    commissionReceiver,
                    msg.sender, // address collection
                    _from, // address buyer or from
                    offer.from // seller
                ),
                id,
                _primaryMarketOffersFeeBps //uint256 primaryFee
            );
        }

        return 0x150b7a02;
    }

    function _transferNFT(
        address _collection,
        address _from,
        address _to,
        uint256 _tokenId,
        uint256 _erc1155Value
    ) private {
        bool success;
        if (_erc1155Value == 0)
            (success, ) = _collection.call(
                abi.encodeWithSelector(
                    0x42842e0e, // bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e
                    _from,
                    _to,
                    _tokenId
                )
            );
        else
            (success, ) = _collection.call(
                abi.encodeWithSelector(
                    0xf242432a, // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a
                    _from,
                    _to,
                    _tokenId,
                    _erc1155Value,
                    ""
                )
            );

        require(success);
    }

    /**
     * param _buyer order or offer creator, depending on who `msg.sender` is
     * param _price NFT's price
     * param _tokenId NFT's Id
     *
     * @dev the check-effects-interactions pattern is not fully applied although this is not a security issue;
     *  the first external untrusted call is to the royalties receiver address, however reentrancy is not an issue as all global state variables have already been set at that point, and subsequent state changes only affect local function variables that cannot be modified by reentering the contract.
     *  ETH transfers (external calls) are paid out in this order: royalties receiver (if any), marketplace fees receiver, commissions receiver (if any) , seller
     *  The worst case is that royalty receiver of an external collection sets royalties bps equal to price - fees in order to receive/steal the entire seller's profit. Arguably this would harm the artist, given Ninfa is a curated marketplace, that is why we accept this risk.
     *
     * Requires:
     *
     * - Requires that `(royaltyAmount +  marketplaceAmount + _commissionBps) < _order.unitPrice`.
     *
     */
    function _trade(
        _Order memory _order,
        uint256 _id,
        uint256 _primaryMarketFeeBps
    ) private {
        uint256 royaltyAmount;
        uint256 marketplaceAmount; // declare `marketplaceAmount`, its value will be calculated based on whether it is a primary or secondary sale
        uint256 commissionAmount;
        if (_order.commissionBps > 0)
            commissionAmount =
                (_order.commissionBps * _order.unitPrice) /
                10000; // calculate commission amount
        uint256 sellerAmount = _order.unitPrice; // sellerAmount is set equal to price and reduced at each step by subtracting fees, royalties and commissions, if any.
        // `getRoyalty()` is a getter function from a modified implementation of `RoyaltyEngineV1`, it only checks that `royaltyAmount < price`.
        // arrays are returned so that their length may be checked before accessing their elements at index 0; an empty array is returned when royalties are not supported.
        (
            address payable[] memory royaltyRecipients,
            uint256[] memory royaltyAmounts
        ) = getRoyalty(_order.collection, _order.tokenId, _order.unitPrice);

        if (royaltyAmounts.length > 0) {
            /*----------------------------------------------------------*|
            |*  # IF ROYALTIES SUPPORTED                                *|
            |*----------------------------------------------------------*/
            // The collection implements some royalty standard, otherwise the length of the arrays returned would be 0.

            royaltyAmount = royaltyAmounts[0];

            if (royaltyAmount == 0) {
                /*----------------------------------------------------------*|
                |*  # IF PRIMARY MARKET (NINFA'S ERC-721 COLLECTIONS)       *|
                |*----------------------------------------------------------*/
                // If the array has a length and AND the content of `royaltyAmount` equals 0, the collection has
                // explicitly implemented royalties and set them to 0, i.e. it is a primary sale.
                // > "Marketplaces that support this standard SHOULD NOT send a zero-value transaction if the royaltyAmount returned is 0." https://eips.ethereum.org/EIPS/eip-2981

                marketplaceAmount =
                    (_order.unitPrice * _primaryMarketFeeBps) /
                    10000;
            } else {
                /*----------------------------------------------------------*|
                |*  # IF SECONDARY MARKET                                   *|
                |*----------------------------------------------------------*/
                //  `_secondaryMarketFeeBps[_ninfaFactory]` is used as a fees BPS placeholder for all Ninfa self sovereign erc1155 collections.
                //  if it can't be found in the _secondaryMarketFeeBps (whitelist) then it must be one of Ninfa's communal collections (721 or 1155).
                //  Ninfa factory clones, defaults to whatever bps stored at address(0) that is used as placeholder, currently 500 or 5%.

                /*----------------------------------------------------------*|
                |*  # PAY ROYALTIES                                         *|
                |*----------------------------------------------------------*/
                // > "Marketplaces that support this standard MUST pay royalties no matter where the sale occurred or in what currency" - https://eips.ethereum.org/EIPS/eip-2981.

                sellerAmount -= royaltyAmount; // subtract before external call.
                _sendValue(royaltyRecipients[0], royaltyAmount);

                /*----------------------------------------------------------*|
                |*  # CALCULATE MARKETPLACE FEE AMOUNT                      *|
                |*----------------------------------------------------------*/

                marketplaceAmount =
                    (_order.unitPrice *
                        (
                            _secondaryMarketFeeBps[_order.collection] > 0
                                ? _secondaryMarketFeeBps[_order.collection] // NINFA_ERC721_V2 or any external whitelisted collection
                                : _secondaryMarketFeeBps[_ninfaFactory]
                        )) /
                    10000;
            }
        }

        /*----------------------------------------------------------*|
        |*  # PAY MARKETPLACE FEE                                   *|
        |*----------------------------------------------------------*/

        // subtracting primary or secondary fee amount from seller amount, this is a security check (will revert on underflow) as well as a variable assignment.
        sellerAmount -= marketplaceAmount; // subtract before external call.

        _sendValue(_feeAccount, marketplaceAmount);

        /*----------------------------------------------------------*|
        |*  # PAY ORDER COMMISSIONS (if any)                         *|
        |*----------------------------------------------------------*/
        //TODO: calculate commission amount based on price and commission bps
        if (commissionAmount > 0) {
            sellerAmount -= commissionAmount;
            _sendValue(_order.commissionReceiver, commissionAmount);
        }

        /*----------------------------------------------------------*|
        |*  # PAY SELLER                                            *|
        |*----------------------------------------------------------*/
        _sendValue(_order.from, sellerAmount);

        _transferNFT(
            _order.collection,
            address(this),
            _order.operator, // buyer
            _order.tokenId,
            _order.erc1155Value
        );

        emit Trade(
            _order.collection,
            _order.tokenId,
            _order.from, // seller
            _id,
            _order.unitPrice,
            _order.erc1155Value
        );
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `_amount` wei to
     * `_receiver`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] raises the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {_sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `_receiver`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function _sendValue(address _receiver, uint256 _amount) private {
        // solhint-disable-next-line avoid-low-level-calls
        (bool success, ) = payable(_receiver).call{value: _amount}("");
        require(success);
    }

    /*----------------------------------------------------------*|
    |*  # ONLY ADMIN                                            *|
    |*----------------------------------------------------------*/

    /**
     * @notice setter function only callable by contract admin used to change any or all addresses used by the Marketplace,
     * @dev if only one address needs to be set, make sure you are passing all other past addresses as parameters, i.e. not changing any of the other addresses' preveious value.
     * @dev the reason there is only one setter function rather many is to save bytecode, because the Marketplace is very close to contract size limit
     * @param feeAccount_ is the address owned by NINFA that will collect sales fees
     */
    function setAdminContracts(
        address feeAccount_,
        address ninfaFactory_
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        // set address for receiving marketplace fees
        _feeAccount = feeAccount_;
        // set address of ERC1155 factory
        _ninfaFactory = ninfaFactory_;
    }

    /**
     * @notice whitelist collection to be traded on marketplace
     * @dev this function needs to be called immediately after deployment in order to set marketplace fees for NINFA_ERC721_V2 to 500bps or 5%. Required for access control by `isWhitelisted` modifier, also required in order to set secondary sales fees for NINFA_ERC721_V2 and all NinfaERC1155 to 5%.
     * @param _collection address of collection ERC721 or ERC1155
     * address(0) is used as a placeholder to store secondary fees amount for Ninfa's self-sovreign collections, as a matter of fact,
     * _collection calling this function and setting collection fees for address(0) is the only way there is in order to change secondary fees for all of Ninfa's self sovreign collections
     * in order to set or reset secondary fees for Ninfa's communal collections or any other, this function must be called for every collection that requires changing fees
     * this can be tedious and expensive but it allows to set fine-grained fees on a per-collection basis
     * @param secondaryMarketFeeBps_ adds a uint to a mapping, if uint is positive the isWhitelisted modifier will return true, the uint corresponds to the secondary fee basis points, the maximum should be < 8501.
     */
    function whitelistCollection(
        address _collection,
        uint256 secondaryMarketFeeBps_
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _secondaryMarketFeeBps[_collection] = secondaryMarketFeeBps_;

        emit CollectionWhitelisted(_collection, secondaryMarketFeeBps_);
    }

    /**
     * @notice sets primary sale fees for NINFA_ERC721_V2 communal collection.
     * @dev primary fees may be 0%, this is the default when not set.
     */
    function setPrimaryMarketFeeBps(
        uint256 primaryMarketOrdersFeeBps_,
        uint256 primaryMarketOffersFeeBps_
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _primaryMarketOrdersFeeBps = primaryMarketOrdersFeeBps_;
        _primaryMarketOffersFeeBps = primaryMarketOffersFeeBps_;
    }

    /*----------------------------------------------------------*|
    |*  # VIEW FUNCTIONS                                        *|
    |*----------------------------------------------------------*/

    /**
     * @dev See {IERC165-supportsInterface}.
     * @dev supportsInterface is only needed to signal support for onERC1155Received, not onERC721Received. The interface is probably needed because a contract may implement onERC1155Received, onERC1155BatchReceived, or both. See https://forum.openzeppelin.com/t/erc721holder-ierc721receiver-and-onerc721received/11828
     */
    function supportsInterface(
        bytes4 interfaceId
    ) external pure returns (bool) {
        return
            interfaceId == 0x01ffc9a7 || // Interface ID for IERC165
            interfaceId == 0xf23a6e61; // Return value from `onERC1155Received` call if a contract accepts receipt (i.e `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`).
        // todo interfaceId == 0x150b7a02; // Interface ID for IERC721Receiver
    }

    function setOrderCommission(
        uint256 _orderId,
        uint256 _commissionBps,
        address _commissionRecipient
    ) external {
        require(msg.sender == orders[_orderId].operator);
        orders[_orderId].commissionBps = _commissionBps;
        orders[_orderId].commissionReceiver = _commissionRecipient;
        emit OrderUpdated(_orderId);
    }

    /*----------------------------------------------------------*|
    |*  # CONSTRUCTOR                                           *|
    |*----------------------------------------------------------*/

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`
     * @dev after deployment need to manually call setAddresses.
     * @param _royaltyRegistry see https://royaltyregistry.xyz/lookup for public addresses
     * @param primaryMarketOffersFeeBps_ is set to 500 BPS (5% shares) at deployment and is used for secondary market fees (`_secondaryMarketFeeBps`) also.
     * @param ninfaFactory_ is used as a placeholder to store secondary fees BPS for all of Ninfa's self-sovreign ERC-721 and ERC-1155 collections
     */
    constructor(
        address _royaltyRegistry,
        address _ninfaERC721v1,
        address _ninfaERC721v2,
        address _ninfaERC1155,
        address feeAccount_,
        address ninfaFactory_,
        uint256 primaryMarketOrdersFeeBps_,
        uint256 primaryMarketOffersFeeBps_
    ) RoyaltyEngineV1(_royaltyRegistry) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);

        _feeAccount = feeAccount_;
        _ninfaFactory = ninfaFactory_;

        _secondaryMarketFeeBps[_ninfaERC721v1] = primaryMarketOffersFeeBps_;
        emit CollectionWhitelisted(_ninfaERC721v1, primaryMarketOffersFeeBps_);
        _secondaryMarketFeeBps[_ninfaERC721v2] = primaryMarketOffersFeeBps_;
        emit CollectionWhitelisted(_ninfaERC721v2, primaryMarketOffersFeeBps_);
        _secondaryMarketFeeBps[_ninfaERC1155] = primaryMarketOffersFeeBps_;
        emit CollectionWhitelisted(_ninfaERC1155, primaryMarketOffersFeeBps_);

        _secondaryMarketFeeBps[_ninfaFactory] = primaryMarketOffersFeeBps_;
        emit CollectionWhitelisted(_ninfaFactory, primaryMarketOffersFeeBps_);

        _primaryMarketOrdersFeeBps = primaryMarketOrdersFeeBps_;
        _primaryMarketOffersFeeBps = primaryMarketOffersFeeBps_;
    }
}