{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/blueberry-core/contracts/spell/IchiSpell.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n*/\\n\\npragma solidity 0.8.22;\\n\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport { IUniswapV3Pool } from \\\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\\\";\\nimport { UniversalERC20, IERC20 } from \\\"../libraries/UniversalERC20.sol\\\";\\n\\nimport \\\"../utils/BlueberryErrors.sol\\\" as Errors;\\n\\nimport { BasicSpell } from \\\"./BasicSpell.sol\\\";\\n\\nimport { IBank } from \\\"../interfaces/IBank.sol\\\";\\nimport { IICHIVault } from \\\"../interfaces/ichi/IICHIVault.sol\\\";\\nimport { IUniswapV3Router } from \\\"../interfaces/uniswap/IUniswapV3Router.sol\\\";\\nimport { IWIchiFarm } from \\\"../interfaces/IWIchiFarm.sol\\\";\\nimport { IIchiSpell } from \\\"../interfaces/spell/IIchiSpell.sol\\\";\\n\\n/**\\n * @title IchiSpell\\n * @author BlueberryProtocol\\n * @notice Factory contract that defines the interaction between the\\n *         Blueberry Protocol and Ichi Vaults.\\n */\\ncontract IchiSpell is IIchiSpell, BasicSpell {\\n    using SafeCast for uint256;\\n    using SafeCast for int256;\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n    using UniversalERC20 for IERC20;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      STORAGE\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Address of the Uniswap V3 router.\\n    IUniswapV3Router private _uniV3Router;\\n    /// @dev Address of the ICHI farm wrapper.\\n    IWIchiFarm private _wIchiFarm;\\n    /// @dev Address of the ICHI token.\\n    address private _ichiV2;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Initializes the contract with required parameters.\\n     * @param bank Reference to the Bank contract.\\n     * @param werc20 Reference to the WERC20 contract.\\n     * @param weth Address of the wrapped Ether token.\\n     * @param wichiFarm Address of the wrapped Ichi Farm contract.\\n     * @param augustusSwapper Address of the paraswap AugustusSwapper.\\n     * @param tokenTransferProxy Address of the paraswap TokenTransferProxy.\\n     * @param owner Address of the owner of the contract.\\n     */\\n    function initialize(\\n        IBank bank,\\n        address werc20,\\n        address weth,\\n        address wichiFarm,\\n        address uniV3Router,\\n        address augustusSwapper,\\n        address tokenTransferProxy,\\n        address owner\\n    ) external initializer {\\n        __BasicSpell_init(bank, werc20, weth, augustusSwapper, tokenTransferProxy, owner);\\n        if (wichiFarm == address(0)) revert Errors.ZERO_ADDRESS();\\n\\n        _wIchiFarm = IWIchiFarm(wichiFarm);\\n        _ichiV2 = address(IWIchiFarm(wichiFarm).getIchiV2());\\n        _wIchiFarm.setApprovalForAll(address(bank), true);\\n\\n        _uniV3Router = IUniswapV3Router(uniV3Router);\\n    }\\n\\n    /// @inheritdoc IIchiSpell\\n    function addStrategy(address vault, uint256 minPosSize, uint256 maxPosSize) external onlyOwner {\\n        _addStrategy(vault, minPosSize, maxPosSize);\\n    }\\n\\n    /// @inheritdoc IIchiSpell\\n    function openPosition(\\n        OpenPosParam calldata param\\n    ) external existingStrategy(param.strategyId) existingCollateral(param.strategyId, param.collToken) {\\n        /// 1-5 Deposit on ichi vault\\n        _deposit(param);\\n\\n        /// 6. Put collateral - ICHI Vault Lp Token\\n        address vault = _strategies[param.strategyId].vault;\\n        _doPutCollateral(vault, IERC20Upgradeable(vault).balanceOf(address(this)));\\n    }\\n\\n    /// @inheritdoc IIchiSpell\\n    function openPositionFarm(\\n        OpenPosParam calldata param\\n    ) external existingStrategy(param.strategyId) existingCollateral(param.strategyId, param.collToken) {\\n        Strategy memory strategy = _strategies[param.strategyId];\\n\\n        IWIchiFarm wIchiFarm = getWIchiFarm();\\n\\n        address lpToken = wIchiFarm.getIchiFarm().lpToken(param.farmingPoolId);\\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\\n\\n        /// 1-5 Deposit on ichi vault\\n        _deposit(param);\\n\\n        IBank bank = getBank();\\n        /// 6. Take out collateral and burn\\n        {\\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\\n            address posCollToken = pos.collToken;\\n            uint256 collId = pos.collId;\\n            uint256 collSize = pos.collateralSize;\\n\\n            if (collSize > 0) {\\n                (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\\n                if (param.farmingPoolId != decodedPid) revert Errors.INCORRECT_PID(param.farmingPoolId);\\n                if (posCollToken != address(wIchiFarm)) revert Errors.INCORRECT_COLTOKEN(posCollToken);\\n\\n                bank.takeCollateral(collSize);\\n                wIchiFarm.burn(collId, collSize);\\n\\n                _doRefundRewards(getIchiV2());\\n            }\\n        }\\n\\n        /// 5. Deposit on farming pool, put collateral\\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\\n        IERC20(lpToken).universalApprove(address(wIchiFarm), lpAmount);\\n        uint256 id = wIchiFarm.mint(param.farmingPoolId, lpAmount);\\n        bank.putCollateral(address(wIchiFarm), id, lpAmount);\\n    }\\n\\n    /// @inheritdoc IIchiSpell\\n    function closePosition(\\n        ClosePosParam calldata param\\n    ) external existingStrategy(param.strategyId) existingCollateral(param.strategyId, param.collToken) {\\n        /// 1. Take out collateral\\n        _doTakeCollateral(_strategies[param.strategyId].vault, param.amountPosRemove);\\n\\n        /// 2-8. Remove liquidity\\n        _withdraw(getBank(), param);\\n    }\\n\\n    /// @inheritdoc IIchiSpell\\n    function closePositionFarm(\\n        ClosePosParam calldata param\\n    ) external existingStrategy(param.strategyId) existingCollateral(param.strategyId, param.collToken) {\\n        IBank bank = getBank();\\n        address vault = _strategies[param.strategyId].vault;\\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\\n        address posCollToken = pos.collToken;\\n        uint256 collId = pos.collId;\\n\\n        IWIchiFarm wIchiFarm = getWIchiFarm();\\n        address ichiV2 = getIchiV2();\\n\\n        if (IWIchiFarm(posCollToken).getUnderlyingToken(collId) != vault) revert Errors.INCORRECT_UNDERLYING(vault);\\n        if (posCollToken != address(wIchiFarm)) revert Errors.INCORRECT_COLTOKEN(posCollToken);\\n\\n        /// 1. Take out collateral\\n        bank.takeCollateral(param.amountPosRemove);\\n        wIchiFarm.burn(collId, param.amountPosRemove);\\n        _doRefundRewards(ichiV2);\\n\\n        /// 2-8. Remove liquidity\\n        _withdraw(bank, param);\\n\\n        /// 9. Refund ichi token\\n        _doRefund(ichiV2);\\n    }\\n\\n    /// @inheritdoc IIchiSpell\\n    function getUniswapV3Router() public view override returns (IUniswapV3Router) {\\n        return _uniV3Router;\\n    }\\n\\n    /// @inheritdoc IIchiSpell\\n    function getWIchiFarm() public view override returns (IWIchiFarm) {\\n        return _wIchiFarm;\\n    }\\n\\n    /// @inheritdoc IIchiSpell\\n    function getIchiV2() public view returns (address) {\\n        return _ichiV2;\\n    }\\n\\n    /**\\n     * @notice Handles the deposit logic, including lending and borrowing\\n     *         operations, and depositing borrowed tokens in the ICHI vault.\\n     * @param param Parameters required for the deposit operation.\\n     */\\n    function _deposit(OpenPosParam calldata param) internal {\\n        Strategy memory strategy = _strategies[param.strategyId];\\n\\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\\n        _doLend(param.collToken, param.collAmount);\\n\\n        /// 2. Borrow specific amounts\\n        IICHIVault vault = IICHIVault(strategy.vault);\\n        if (vault.token0() != param.borrowToken && vault.token1() != param.borrowToken) {\\n            revert Errors.INCORRECT_DEBT(param.borrowToken);\\n        }\\n\\n        uint256 borrowBalance = _doBorrow(param.borrowToken, param.borrowAmount);\\n\\n        /// 3. Add liquidity - Deposit on ICHI Vault\\n        bool isTokenA = vault.token0() == param.borrowToken;\\n        IERC20(param.borrowToken).universalApprove(address(vault), borrowBalance);\\n\\n        uint ichiVaultShare;\\n        if (isTokenA) {\\n            ichiVaultShare = vault.deposit(borrowBalance, 0, address(this));\\n        } else {\\n            ichiVaultShare = vault.deposit(0, borrowBalance, address(this));\\n        }\\n\\n        /// 4. Validate MAX LTV\\n        _validateMaxLTV(param.strategyId);\\n\\n        /// 5. Validate Max Pos Size\\n        _validatePosSize(param.strategyId);\\n    }\\n\\n    /**\\n     * @notice Handles the withdrawal logic, including withdrawing\\n     *         from the ICHI vault, swapping tokens, and repaying the debt.\\n     * @param bank Reference to the Bank contract.\\n     * @param param Parameters required for the close position operation.\\n     */\\n    function _withdraw(IBank bank, ClosePosParam calldata param) internal {\\n        Strategy memory strategy = _strategies[param.strategyId];\\n        IICHIVault vault = IICHIVault(strategy.vault);\\n\\n        /// 1. Compute repay amount if MAX_INT is supplied (max debt)\\n        uint256 amountRepay = param.amountRepay;\\n        if (amountRepay == type(uint256).max) {\\n            amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\\n        }\\n\\n        /// 2. Calculate actual amount to remove\\n        uint256 amountPosRemove = param.amountPosRemove;\\n        if (amountPosRemove == type(uint256).max) {\\n            amountPosRemove = vault.balanceOf(address(this));\\n        }\\n\\n        /// 3. Withdraw liquidity from ICHI vault\\n        vault.withdraw(amountPosRemove, address(this));\\n\\n        /// 4. Swap withdrawn tokens to debt token\\n        bool isTokenA = vault.token0() == param.borrowToken;\\n        uint256 amountIn = IERC20Upgradeable(isTokenA ? vault.token1() : vault.token0()).balanceOf(address(this));\\n\\n        if (amountIn > 0) {\\n            address[] memory swapPath = new address[](2);\\n            swapPath[0] = isTokenA ? vault.token1() : vault.token0();\\n            swapPath[1] = isTokenA ? vault.token0() : vault.token1();\\n\\n            IUniswapV3Router.ExactInputSingleParams memory params = IUniswapV3Router.ExactInputSingleParams({\\n                tokenIn: swapPath[0],\\n                tokenOut: swapPath[1],\\n                fee: IUniswapV3Pool(vault.pool()).fee(),\\n                recipient: address(this),\\n                deadline: block.timestamp,\\n                amountIn: amountIn,\\n                amountOutMinimum: param.amountOutMin,\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n            IUniswapV3Router uniV3Router = getUniswapV3Router();\\n\\n            IERC20(params.tokenIn).universalApprove(address(uniV3Router), amountIn);\\n            uniV3Router.exactInputSingle(params);\\n        }\\n\\n        /// 5. Withdraw isolated collateral from Bank\\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\\n\\n        /// 6. Swap some collateral to repay debt(for negative PnL)\\n        _swapCollToDebt(param.collToken, param.amountToSwap, param.swapData);\\n\\n        /// 7. Repay\\n        _doRepay(param.borrowToken, amountRepay);\\n\\n        _validateMaxLTV(param.strategyId);\\n\\n        /// 8. Refund\\n        _doRefund(param.borrowToken);\\n        _doRefund(param.collToken);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\n\\n    /**\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\n     */\\n    error SafeCastOverflowedIntToUint(int256 value);\\n\\n    /**\\n     * @dev Value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\n\\n    /**\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\n     */\\n    error SafeCastOverflowedUintToInt(uint256 value);\\n\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        if (value > type(uint248).max) {\\n            revert SafeCastOverflowedUintDowncast(248, value);\\n        }\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        if (value > type(uint240).max) {\\n            revert SafeCastOverflowedUintDowncast(240, value);\\n        }\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        if (value > type(uint232).max) {\\n            revert SafeCastOverflowedUintDowncast(232, value);\\n        }\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        if (value > type(uint224).max) {\\n            revert SafeCastOverflowedUintDowncast(224, value);\\n        }\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        if (value > type(uint216).max) {\\n            revert SafeCastOverflowedUintDowncast(216, value);\\n        }\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        if (value > type(uint208).max) {\\n            revert SafeCastOverflowedUintDowncast(208, value);\\n        }\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        if (value > type(uint200).max) {\\n            revert SafeCastOverflowedUintDowncast(200, value);\\n        }\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        if (value > type(uint192).max) {\\n            revert SafeCastOverflowedUintDowncast(192, value);\\n        }\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        if (value > type(uint184).max) {\\n            revert SafeCastOverflowedUintDowncast(184, value);\\n        }\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        if (value > type(uint176).max) {\\n            revert SafeCastOverflowedUintDowncast(176, value);\\n        }\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        if (value > type(uint168).max) {\\n            revert SafeCastOverflowedUintDowncast(168, value);\\n        }\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        if (value > type(uint160).max) {\\n            revert SafeCastOverflowedUintDowncast(160, value);\\n        }\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        if (value > type(uint152).max) {\\n            revert SafeCastOverflowedUintDowncast(152, value);\\n        }\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        if (value > type(uint144).max) {\\n            revert SafeCastOverflowedUintDowncast(144, value);\\n        }\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        if (value > type(uint136).max) {\\n            revert SafeCastOverflowedUintDowncast(136, value);\\n        }\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        if (value > type(uint128).max) {\\n            revert SafeCastOverflowedUintDowncast(128, value);\\n        }\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        if (value > type(uint120).max) {\\n            revert SafeCastOverflowedUintDowncast(120, value);\\n        }\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        if (value > type(uint112).max) {\\n            revert SafeCastOverflowedUintDowncast(112, value);\\n        }\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        if (value > type(uint104).max) {\\n            revert SafeCastOverflowedUintDowncast(104, value);\\n        }\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        if (value > type(uint96).max) {\\n            revert SafeCastOverflowedUintDowncast(96, value);\\n        }\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        if (value > type(uint88).max) {\\n            revert SafeCastOverflowedUintDowncast(88, value);\\n        }\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        if (value > type(uint80).max) {\\n            revert SafeCastOverflowedUintDowncast(80, value);\\n        }\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        if (value > type(uint72).max) {\\n            revert SafeCastOverflowedUintDowncast(72, value);\\n        }\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > type(uint64).max) {\\n            revert SafeCastOverflowedUintDowncast(64, value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        if (value > type(uint56).max) {\\n            revert SafeCastOverflowedUintDowncast(56, value);\\n        }\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        if (value > type(uint48).max) {\\n            revert SafeCastOverflowedUintDowncast(48, value);\\n        }\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        if (value > type(uint40).max) {\\n            revert SafeCastOverflowedUintDowncast(40, value);\\n        }\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > type(uint32).max) {\\n            revert SafeCastOverflowedUintDowncast(32, value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        if (value > type(uint24).max) {\\n            revert SafeCastOverflowedUintDowncast(24, value);\\n        }\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > type(uint16).max) {\\n            revert SafeCastOverflowedUintDowncast(16, value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        if (value > type(uint8).max) {\\n            revert SafeCastOverflowedUintDowncast(8, value);\\n        }\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        if (value < 0) {\\n            revert SafeCastOverflowedIntToUint(value);\\n        }\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(248, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(240, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(232, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(224, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(216, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(208, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(200, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(192, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(184, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(176, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(168, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(160, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(152, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(144, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(136, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(128, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(120, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(112, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(104, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(96, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(88, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(80, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(72, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(64, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(56, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(48, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(40, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(32, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(24, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(16, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        if (downcasted != value) {\\n            revert SafeCastOverflowedIntDowncast(8, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        if (value > uint256(type(int256).max)) {\\n            revert SafeCastOverflowedUintToInt(value);\\n        }\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport './pool/IUniswapV3PoolImmutables.sol';\\nimport './pool/IUniswapV3PoolState.sol';\\nimport './pool/IUniswapV3PoolDerivedState.sol';\\nimport './pool/IUniswapV3PoolActions.sol';\\nimport './pool/IUniswapV3PoolOwnerActions.sol';\\nimport './pool/IUniswapV3PoolEvents.sol';\\n\\n/// @title The interface for a Uniswap V3 Pool\\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\\n/// to the ERC20 specification\\n/// @dev The pool interface is broken up into many smaller pieces\\ninterface IUniswapV3Pool is\\n    IUniswapV3PoolImmutables,\\n    IUniswapV3PoolState,\\n    IUniswapV3PoolDerivedState,\\n    IUniswapV3PoolActions,\\n    IUniswapV3PoolOwnerActions,\\n    IUniswapV3PoolEvents\\n{\\n\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/libraries/UniversalERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n*/\\n\\npragma solidity 0.8.22;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * @title UniversalERC20\\n * @dev UniversalERC20 is a helper contract that allows to work around ERC20\\n *      limitations when dealing with missing return values.\\n *      UniversalERC20 executes a low level call to the token contract.\\n *      If it fails, it assumes that the token does not implement the method.\\n *      If it succeeds, it returns the value returned by the method.\\n *      Also supports if the token address is native ETH.\\n */\\nlibrary UniversalERC20 {\\n    using SafeERC20 for IERC20;\\n\\n    address private constant _ZERO_ADDRESS = address(0);\\n    address private constant _ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n\\n    /// @notice UniversalERC20's safeTransfer function that is similar to ERC20's transfer function.\\n    /// @dev Works around non-standard ERC20's that throw on 0 transfer and supports Native ETH.\\n    function universalTransfer(IERC20 token, address to, uint256 amount) internal returns (bool) {\\n        if (amount == 0) {\\n            return true;\\n        }\\n        if (isETH(token)) {\\n            (bool success, ) = to.call{ value: amount }(\\\"\\\");\\n            require(success, \\\"ETH transfer failed\\\");\\n            return true;\\n        } else {\\n            token.safeTransfer(to, amount);\\n            return true;\\n        }\\n    }\\n\\n    /// @notice UniversalERC20's safeTransferFrom function that is similar to ERC20's transferFrom function.\\n    /// @dev Works around non-standard ERC20's that throw on 0 transfer and supports native ETH.\\n    function universalTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        if (amount == 0) {\\n            return;\\n        }\\n\\n        if (isETH(token)) {\\n            require(from == msg.sender && msg.value == amount, \\\"Wrong useage of ETH.universalTransferFrom()\\\");\\n            if (to != address(this)) {\\n                (bool success, ) = to.call{ value: amount }(\\\"\\\");\\n                require(success, \\\"ETH transfer failed\\\");\\n            }\\n        } else {\\n            token.safeTransferFrom(from, to, amount);\\n        }\\n    }\\n\\n    function universalApprove(IERC20 token, address to, uint256 amount) internal {\\n        if (!isETH(token)) {\\n            token.forceApprove(to, amount);\\n        }\\n    }\\n\\n    /// @notice UniversalBalanceOf returns the balance of a token for an address.\\n    /// @dev Is able to tell the balance of a token or natie ETH.\\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\\n        if (isETH(token)) {\\n            return who.balance;\\n        } else {\\n            return token.balanceOf(who);\\n        }\\n    }\\n\\n    /// @notice returns if the token is ETH or not.\\n    function isETH(IERC20 token) internal pure returns (bool) {\\n        return (address(token) == address(_ZERO_ADDRESS) || address(token) == address(_ETH_ADDRESS));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/utils/BlueberryErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n*/\\n/**\\n * @title BlueberryErrors\\n * @author BlueberryProtocol\\n * @notice containing all errors used in Blueberry protocol\\n */\\n/// title BlueberryErrors\\n/// @notice containing all errors used in Blueberry protocol\\npragma solidity 0.8.22;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                COMMON ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when an action involves zero amount of tokens.\\nerror ZERO_AMOUNT();\\n\\n/// @notice Thrown when the address provided is the zero address.\\nerror ZERO_ADDRESS();\\n\\n/// @notice Thrown when the lengths of input arrays do not match.\\nerror INPUT_ARRAY_MISMATCH();\\n\\n/// @notice Thrown when the caller is not authorized to call the function.\\nerror UNAUTHORIZED();\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                ORACLE ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when the delay time exceeds allowed limits.\\nerror TOO_LONG_DELAY(uint256 delayTime);\\n\\n/// @notice Thrown when there's no maximum delay set for a token.\\nerror NO_MAX_DELAY(address token);\\n\\n/// @notice Thrown when the price information for a token is outdated.\\nerror PRICE_OUTDATED(address token);\\n\\n/// @notice Thrown when the price obtained is negative.\\nerror PRICE_NEGATIVE(address token);\\n\\n/// @notice Thrown when the sequencer is offline\\nerror SEQUENCER_DOWN(address sequencer);\\n\\n/// @notice Thrown when the grace period for a sequencer is not over yet.\\nerror SEQUENCER_GRACE_PERIOD_NOT_OVER(address sequencer);\\n\\n/// @notice Thrown when the price deviation exceeds allowed limits.\\nerror OUT_OF_DEVIATION_CAP(uint256 deviation);\\n\\n/// @notice Thrown when the number of sources exceeds the allowed length.\\nerror EXCEED_SOURCE_LEN(uint256 length);\\n\\n/// @notice Thrown when no primary source is available for the token.\\nerror NO_PRIMARY_SOURCE(address token);\\n\\n/// @notice Thrown when no valid price source is available for the token.\\nerror NO_VALID_SOURCE(address token);\\n\\n/// @notice Thrown when the deviation value exceeds the threshold.\\nerror EXCEED_DEVIATION();\\n\\n/// @notice Thrown when the mean price is below the acceptable threshold.\\nerror TOO_LOW_MEAN(uint256 mean);\\n\\n/// @notice Thrown when no mean price is set for the token.\\nerror NO_MEAN(address token);\\n\\n/// @notice Thrown when no stable pool exists for the token.\\nerror NO_STABLEPOOL(address token);\\n\\n/// @notice Thrown when the price fetch process fails for a token.\\nerror PRICE_FAILED(address token);\\n\\n/// @notice Thrown when the liquidation threshold is set too high.\\nerror LIQ_THRESHOLD_TOO_HIGH(uint256 threshold);\\n\\n/// @notice Thrown when the liquidation threshold is set too low.\\nerror LIQ_THRESHOLD_TOO_LOW(uint256 threshold);\\n\\n/// @notice Thrown when the oracle doesn't support a specific token.\\nerror ORACLE_NOT_SUPPORT(address token);\\n\\n/// @notice Thrown when the oracle doesn't support a specific LP pair token.\\nerror ORACLE_NOT_SUPPORT_LP(address lp);\\n\\n/// @notice Thrown when the oracle doesn't support a specific wToken.\\nerror ORACLE_NOT_SUPPORT_WTOKEN(address wToken);\\n\\n/// @notice Thrown when there is no route to fetch data for the oracle\\nerror NO_ORACLE_ROUTE(address token);\\n\\n/// @notice Thrown when a value is out of an acceptable range.\\nerror VALUE_OUT_OF_RANGE();\\n\\n/// @notice Thrown when specified limits are incorrect.\\nerror INCORRECT_LIMITS();\\n\\n/// @notice Thrown when Curve LP is already registered.\\nerror CRV_LP_ALREADY_REGISTERED(address lp);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            GENERAL SPELL ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when the caller isn't recognized as a bank.\\nerror NOT_BANK(address caller);\\n\\n/// @notice Thrown when the collateral doesn't exist for a strategy.\\nerror COLLATERAL_NOT_EXIST(uint256 strategyId, address colToken);\\n\\n/// @notice Thrown when the strategy ID doesn't correspond to an existing strategy.\\nerror STRATEGY_NOT_EXIST(address spell, uint256 strategyId);\\n\\n/// @notice Thrown when the position size exceeds maximum limits.\\nerror EXCEED_MAX_POS_SIZE(uint256 strategyId);\\n\\n/// @notice Thrown when the position size is below minimum requirements.\\nerror EXCEED_MIN_POS_SIZE(uint256 strategyId);\\n\\n/// @notice Thrown when the loan-to-value ratio exceeds allowed maximum.\\nerror EXCEED_MAX_LTV();\\n\\n/// @notice Thrown when the strategy ID provided is incorrect.\\nerror INCORRECT_STRATEGY_ID(uint256 strategyId);\\n\\n/// @notice Thrown when the position size is invalid.\\nerror INVALID_POS_SIZE();\\n\\n/// @notice Thrown when an incorrect liquidity pool token is provided.\\nerror INCORRECT_LP(address lpToken);\\n\\n/// @notice Thrown when an incorrect pool ID is provided.\\nerror INCORRECT_PID(uint256 pid);\\n\\n/// @notice Thrown when an incorrect collateral token is provided.\\nerror INCORRECT_COLTOKEN(address colToken);\\n\\n/// @notice Thrown when an incorrect underlying token is provided.\\nerror INCORRECT_UNDERLYING(address uToken);\\n\\n/// @notice Thrown when an incorrect debt token is provided.\\nerror INCORRECT_DEBT(address debtToken);\\n\\n/// @notice Thrown when a swap fails.\\nerror SWAP_FAILED(address swapToken);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                VAULT ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when borrowing from the vault fails.\\nerror BORROW_FAILED(uint256 amount);\\n\\n/// @notice Thrown when repaying to the vault fails.\\nerror REPAY_FAILED(uint256 amount);\\n\\n/// @notice Thrown when lending to the vault fails.\\nerror LEND_FAILED(uint256 amount);\\n\\n/// @notice Thrown when redeeming from the vault fails.\\nerror REDEEM_FAILED(uint256 amount);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                WRAPPER ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when a duplicate tokenId is added.\\nerror DUPLICATE_TOKEN_ID(uint256 tokenId);\\n\\n/// @notice Thrown when an invalid token ID is provided.\\nerror INVALID_TOKEN_ID(uint256 tokenId);\\n\\n/// @notice Thrown when an incorrect pool ID is provided.\\nerror BAD_PID(uint256 pid);\\n\\n/// @notice Thrown when a mismatch in reward per share is detected.\\nerror BAD_REWARD_PER_SHARE(uint256 rewardPerShare);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                BANK ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when a function is called without a required execution flag.\\nerror NOT_UNDER_EXECUTION();\\n\\n/// @notice Thrown when a transaction isn't initiated by the expected spell.\\nerror NOT_FROM_SPELL(address from);\\n\\n/// @notice Thrown when the sender is not the owner of a given position ID.\\nerror NOT_FROM_OWNER(uint256 positionId, address sender);\\n\\n/// @notice Thrown when a spell address isn't whitelisted.\\nerror SPELL_NOT_WHITELISTED(address spell);\\n\\n/// @notice Thrown when a token isn't whitelisted.\\nerror TOKEN_NOT_WHITELISTED(address token);\\n\\n/// @notice Thrown when a bank isn't listed for a given token.\\nerror BANK_NOT_LISTED(address token);\\n\\n/// @notice Thrown when a bank doesn't exist for an index.\\nerror BANK_NOT_EXIST(uint8 index);\\n\\n/// @notice Thrown when a bank is already listed for a given token.\\nerror BANK_ALREADY_LISTED();\\n\\n/// @notice Thrown when the bank limit is reached.\\nerror BANK_LIMIT();\\n\\n/// @notice Thrown when the BTOKEN is already added.\\nerror BTOKEN_ALREADY_ADDED();\\n\\n/// @notice Thrown when the lending action isn't allowed.\\nerror LEND_NOT_ALLOWED();\\n\\n/// @notice Thrown when the borrowing action isn't allowed.\\nerror BORROW_NOT_ALLOWED();\\n\\n/// @notice Thrown when the repaying action isn't allowed.\\nerror REPAY_NOT_ALLOWED();\\n\\n/// @notice Thrown when the redeeming action isn't allowed.\\nerror WITHDRAW_LEND_NOT_ALLOWED();\\n\\n/// @notice Thrown when certain actions are locked.\\nerror LOCKED();\\n\\n/// @notice Thrown when an action isn't executed.\\nerror NOT_IN_EXEC();\\n\\n/// @notice Thrown when the repayment allowance hasn't been warmed up.\\nerror REPAY_ALLOW_NOT_WARMED_UP();\\n\\n/// @notice Thrown when a different collateral type exists.\\nerror DIFF_COL_EXIST(address collToken);\\n\\n/// @notice Thrown when a position is not eligible for liquidation.\\nerror NOT_LIQUIDATABLE(uint256 positionId);\\n\\n/// @notice Thrown when a position is flagged as bad or invalid.\\nerror BAD_POSITION(uint256 posId);\\n\\n/// @notice Thrown when collateral for a specific position is flagged as bad or invalid.\\nerror BAD_COLLATERAL(uint256 positionId);\\n\\n/// @notice Thrown when there's insufficient collateral for an operation.\\nerror INSUFFICIENT_COLLATERAL();\\n\\n/// @notice Thrown when an attempted repayment exceeds the actual debt.\\nerror REPAY_EXCEEDS_DEBT(uint256 repay, uint256 debt);\\n\\n/// @notice Thrown when an invalid utility token is provided.\\nerror INVALID_UTOKEN(address uToken);\\n\\n/// @notice Thrown when a borrow operation results in zero shares.\\nerror BORROW_ZERO_SHARE(uint256 borrowAmount);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            CONFIGURATION ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when a certain ratio is too high for an operation.\\nerror RATIO_TOO_HIGH(uint256 ratio);\\n\\n/// @notice Thrown when an invalid fee distribution is detected.\\nerror INVALID_FEE_DISTRIBUTION();\\n\\n/// @notice Thrown when no treasury is set for fee distribution.\\nerror NO_TREASURY_SET();\\n\\n/// @notice Thrown when a fee window has already started.\\nerror FEE_WINDOW_ALREADY_STARTED();\\n\\n/// @notice Thrown when a fee window duration is too long.\\nerror FEE_WINDOW_TOO_LONG(uint256 windowTime);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                UTILITY ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Thrown when an operation has surpassed its deadline.\\nerror EXPIRED(uint256 deadline);\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/spell/BasicSpell.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n*/\\n\\npragma solidity 0.8.22;\\n\\n/* solhint-disable max-line-length */\\nimport { IERC20MetadataUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\n/* solhint-enable max-line-length */\\n\\nimport { PSwapLib } from \\\"../libraries/Paraswap/PSwapLib.sol\\\";\\nimport { UniversalERC20, IERC20 } from \\\"../libraries/UniversalERC20.sol\\\";\\n\\nimport \\\"../utils/BlueberryConst.sol\\\" as Constants;\\nimport \\\"../utils/BlueberryErrors.sol\\\" as Errors;\\nimport { ERC1155NaiveReceiver } from \\\"../utils/ERC1155NaiveReceiver.sol\\\";\\n\\nimport { IBank } from \\\"../interfaces/IBank.sol\\\";\\nimport { IERC20Wrapper } from \\\"../interfaces/IERC20Wrapper.sol\\\";\\nimport { IWERC20 } from \\\"../interfaces/IWERC20.sol\\\";\\nimport { IWETH } from \\\"../interfaces/IWETH.sol\\\";\\nimport { IBasicSpell } from \\\"../interfaces/spell/IBasicSpell.sol\\\";\\n\\n/**\\n * @title BasicSpell\\n * @author BlueberryProtocol\\n * @notice BasicSpell is the abstract contract that other spells utilize\\n * @dev Inherits from IBasicSpell, ERC1155NaiveReceiver, Ownable2StepUpgradeable\\n */\\nabstract contract BasicSpell is IBasicSpell, ERC1155NaiveReceiver, Ownable2StepUpgradeable {\\n    using UniversalERC20 for IERC20;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                    STORAGE\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Reference to the bank contract interface.\\n    IBank internal _bank;\\n    /// @dev Reference to the WERC20 contract interface.\\n    IWERC20 internal _werc20;\\n    /// @dev Address of the Wrapped Ether contract.\\n    address internal _weth;\\n    /// @dev paraswap AugustusSwapper Address\\n    address internal _augustusSwapper;\\n    /// @dev paraswap TokenTransferProxy Address\\n    address internal _tokenTransferProxy;\\n    /// @dev strategyId => vault\\n    Strategy[] internal _strategies;\\n\\n    /// @dev Mapping from strategy ID to collateral token and its maximum Loan-To-Value ratio.\\n    /// Note: LTV is in base 1e4 to provide precision.\\n    mapping(uint256 => mapping(address => uint256)) internal _maxLTV;\\n    /// @dev ETH address\\n    address internal constant _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      MODIFIERS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Modifier to ensure the provided strategyId exists within the strategies array.\\n     * @param strategyId The ID of the strategy to validate.\\n     */\\n    modifier existingStrategy(uint256 strategyId) {\\n        if (strategyId >= _strategies.length) {\\n            revert Errors.STRATEGY_NOT_EXIST(address(this), strategyId);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to ensure the provided collateral address exists within the given strategy.\\n     * @param strategyId The ID of the strategy to validate.\\n     * @param col Address of the collateral token.\\n     */\\n    modifier existingCollateral(uint256 strategyId, address col) {\\n        if (_maxLTV[strategyId][col] == 0) {\\n            revert Errors.COLLATERAL_NOT_EXIST(strategyId, col);\\n        }\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                     CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n    /* solhint-disable func-name-mixedcase */\\n    /**\\n     * @notice Initializes the contract and sets the deployer as the initial owner.\\n     * @param bank The address of the bank contract.\\n     * @param werc20 The address of the wrapped ERC20 contract.\\n     * @param weth The address of the wrapped Ether token.\\n     * @param augustusSwapper Address of the paraswap AugustusSwapper.\\n     * @param tokenTransferProxy Address of the paraswap TokenTransferProxy.\\n     * @param owner Address of the owner of the contract.\\n     */\\n    function __BasicSpell_init(\\n        IBank bank,\\n        address werc20,\\n        address weth,\\n        address augustusSwapper,\\n        address tokenTransferProxy,\\n        address owner\\n    ) internal onlyInitializing {\\n        if (address(bank) == address(0) || address(werc20) == address(0) || address(weth) == address(0)) {\\n            revert Errors.ZERO_ADDRESS();\\n        }\\n\\n        __Ownable2Step_init();\\n        _transferOwnership(owner);\\n\\n        _bank = bank;\\n        _werc20 = IWERC20(werc20);\\n        _weth = weth;\\n        _augustusSwapper = augustusSwapper;\\n        _tokenTransferProxy = tokenTransferProxy;\\n\\n        IWERC20(werc20).setApprovalForAll(address(bank), true);\\n    }\\n\\n    /* solhint-enable func-name-mixedcase */\\n\\n    /**\\n     * @notice Adds a new strategy to the list of available strategies.\\n     * @dev Internal function that appends to the strategies array.\\n     * @dev Emit {StrategyAdded} event.\\n     * @param vault The address of the vault associated with this strategy.\\n     * @param minPosSize The minimum position size (USD value) for this strategy. Value is based on 1e18.\\n     * @param maxPosSize The maximum position size (USD value) for this strategy. Value is based on 1e18.\\n     */\\n    function _addStrategy(address vault, uint256 minPosSize, uint256 maxPosSize) internal {\\n        if (vault == address(0)) revert Errors.ZERO_ADDRESS();\\n        if (maxPosSize == 0) revert Errors.ZERO_AMOUNT();\\n        if (minPosSize >= maxPosSize) revert Errors.INVALID_POS_SIZE();\\n\\n        _strategies.push(Strategy({ vault: vault, minPositionSize: minPosSize, maxPositionSize: maxPosSize }));\\n\\n        emit StrategyAdded(_strategies.length - 1, vault, minPosSize, maxPosSize);\\n    }\\n\\n    /// @inheritdoc IBasicSpell\\n    function setPosSize(\\n        uint256 strategyId,\\n        uint256 minPosSize,\\n        uint256 maxPosSize\\n    ) external existingStrategy(strategyId) onlyOwner {\\n        if (maxPosSize == 0) revert Errors.ZERO_AMOUNT();\\n        if (minPosSize >= maxPosSize) revert Errors.INVALID_POS_SIZE();\\n\\n        _strategies[strategyId].minPositionSize = minPosSize;\\n        _strategies[strategyId].maxPositionSize = maxPosSize;\\n\\n        emit StrategyPosSizeUpdated(strategyId, minPosSize, maxPosSize);\\n    }\\n\\n    /// @inheritdoc IBasicSpell\\n    function setCollateralsMaxLTVs(\\n        uint256 strategyId,\\n        address[] memory collaterals,\\n        uint256[] memory maxLTVs\\n    ) external existingStrategy(strategyId) onlyOwner {\\n        if (collaterals.length != maxLTVs.length || collaterals.length == 0) {\\n            revert Errors.INPUT_ARRAY_MISMATCH();\\n        }\\n\\n        for (uint256 i = 0; i < collaterals.length; ++i) {\\n            if (collaterals[i] == address(0)) revert Errors.ZERO_ADDRESS();\\n            if (maxLTVs[i] == 0) revert Errors.ZERO_AMOUNT();\\n            _maxLTV[strategyId][collaterals[i]] = maxLTVs[i];\\n        }\\n\\n        emit CollateralsMaxLTVSet(strategyId, collaterals, maxLTVs);\\n    }\\n\\n    /**\\n     * @notice Increase isolated collateral to support the position\\n     * @param token Isolated collateral token address\\n     * @param amount Amount of token to deposit and increase position\\n     */\\n    function increasePosition(address token, uint256 amount) external {\\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\\n        _doLend(token, amount);\\n    }\\n\\n    /**\\n     * @dev Reduce the isolated collateral of a position.\\n     * @param strategyId The ID of the strategy being used.\\n     * @param collToken Address of the isolated collateral token.\\n     * @param collShareAmount Amount of isolated collateral to reduce.\\n     */\\n    function reducePosition(uint256 strategyId, address collToken, uint256 collShareAmount) external {\\n        // Validate strategy id\\n        IBank.Position memory pos = _bank.getCurrentPositionInfo();\\n        address unwrappedCollToken = IERC20Wrapper(pos.collToken).getUnderlyingToken(pos.collId);\\n        if (_strategies[strategyId].vault != unwrappedCollToken) {\\n            revert Errors.INCORRECT_STRATEGY_ID(strategyId);\\n        }\\n\\n        _doWithdraw(collToken, collShareAmount);\\n        _doRefund(collToken);\\n        _validateMaxLTV(strategyId);\\n    }\\n\\n    /// @notice Fetch the bank contract address.\\n    function getBank() public view returns (IBank) {\\n        return _bank;\\n    }\\n\\n    /// @notice Fetch the WERC20 contract address.\\n    function getWrappedERC20() public view returns (IWERC20) {\\n        return _werc20;\\n    }\\n\\n    /// @notice Fetch the WETH contract address.\\n    function getWETH() public view returns (address) {\\n        return _weth;\\n    }\\n\\n    /// @notice Fetch the AugustusSwapper contract address.\\n    function getAugustusSwapper() external view returns (address) {\\n        return _augustusSwapper;\\n    }\\n\\n    /// @notice Fetch the TokenTransferProxy contract address.\\n    function getTokenTransferProxy() external view returns (address) {\\n        return _tokenTransferProxy;\\n    }\\n\\n    /**\\n     * @notice Fetch the strategy by its strategyId.\\n     * @param strategyId The ID of the strategy to fetch.\\n     * @return Strategy struct containing the vault address, min/max position sizes.\\n     */\\n    function getStrategy(uint256 strategyId) external view returns (Strategy memory) {\\n        return _strategies[strategyId];\\n    }\\n\\n    /**\\n     * @notice Fetch the maximum Loan-To-Value (LTV) ratio for a given collateral token.\\n     * @param strategyId The ID of the strategy to fetch the LTV for.\\n     * @param collateral The address of the collateral token.\\n     * @return The maximum LTV ratio for the given collateral token.\\n     */\\n    function getMaxLTV(uint256 strategyId, address collateral) public view returns (uint256) {\\n        return _maxLTV[strategyId][collateral];\\n    }\\n\\n    /**\\n     * @notice Internal function to validate if the current position adheres to the maxLTV of the strategy.\\n     * @dev If the debtValue of the position is greater than permissible, the transaction will revert.\\n     * @param strategyId Strategy ID to validate against.\\n     */\\n    function _validateMaxLTV(uint256 strategyId) internal {\\n        IBank bank = getBank();\\n\\n        uint256 positionId = bank.POSITION_ID();\\n        IBank.Position memory pos = bank.getPositionInfo(positionId);\\n        uint256 debtValue = bank.getDebtValue(positionId);\\n        uint256 uValue = bank.getIsolatedCollateralValue(positionId);\\n\\n        if (debtValue > (uValue * getMaxLTV(strategyId, pos.underlyingToken)) / Constants.DENOMINATOR) {\\n            revert Errors.EXCEED_MAX_LTV();\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to validate if the current position size is within the strategy's bounds.\\n     * @param strategyId Strategy ID to validate against.\\n     */\\n    function _validatePosSize(uint256 strategyId) internal {\\n        IBank bank = getBank();\\n        Strategy memory strategy = _strategies[strategyId];\\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\\n\\n        /// Get previous position size\\n        uint256 prevPosSize;\\n        if (pos.collToken != address(0)) {\\n            prevPosSize = bank.getOracle().getWrappedTokenValue(pos.collToken, pos.collId, pos.collateralSize);\\n        }\\n\\n        /// Get newly added position size\\n        uint256 addedPosSize;\\n        IERC20 lpToken = IERC20(strategy.vault);\\n        uint256 lpBalance = lpToken.balanceOf(address(this));\\n        uint256 lpPrice = bank.getOracle().getPrice(address(lpToken));\\n\\n        addedPosSize = (lpPrice * lpBalance) / 10 ** IERC20MetadataUpgradeable(address(lpToken)).decimals();\\n\\n        // Check if position size is within bounds\\n        if (prevPosSize + addedPosSize > strategy.maxPositionSize) {\\n            revert Errors.EXCEED_MAX_POS_SIZE(strategyId);\\n        }\\n        if (prevPosSize + addedPosSize < strategy.minPositionSize) {\\n            revert Errors.EXCEED_MIN_POS_SIZE(strategyId);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to refund the specified tokens to the current executor of the bank.\\n     * @param token Address of the token to refund.\\n     */\\n    function _doRefund(address token) internal {\\n        uint256 balance = IERC20(token).universalBalanceOf(address(this));\\n        if (balance > 0) {\\n            IERC20(token).universalTransfer(_bank.EXECUTOR(), balance);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to cut a fee from the rewards.\\n     * @param token Address of the reward token.\\n     * @return left Amount remaining after the fee cut.\\n     */\\n    function _doCutRewardsFee(address token) internal returns (uint256 left) {\\n        uint256 rewardsBalance = IERC20(token).balanceOf(address(this));\\n        if (rewardsBalance > 0) {\\n            IBank bank = getBank();\\n            IERC20(token).universalApprove(address(bank.getFeeManager()), rewardsBalance);\\n            left = bank.getFeeManager().doCutRewardsFee(token, rewardsBalance);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to cut the reward fee and refund the remaining rewards to the current bank executor.\\n     * @param token Address of the reward token.\\n     */\\n    function _doRefundRewards(address token) internal {\\n        _doCutRewardsFee(token);\\n        _doRefund(token);\\n    }\\n\\n    /**\\n     * @notice Internall function Deposit specified collateral into the bank.\\n     * @dev Only deposits the collateral if the amount specified is greater than zero.\\n     * @param token Address of the isolated collateral token to be deposited.\\n     * @param amount Amount of tokens to be deposited.\\n     */\\n    function _doLend(address token, uint256 amount) internal {\\n        if (amount > 0) {\\n            _bank.lend(token, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function Withdraw specified collateral from the bank.\\n     * @dev Only withdraws the collateral if the amount specified is greater than zero.\\n     * @param token Address of the isolated collateral token to be withdrawn.\\n     * @param amount Amount of tokens to be withdrawn.\\n     */\\n    function _doWithdraw(address token, uint256 amount) internal {\\n        if (amount > 0) {\\n            _bank.withdrawLend(token, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function Withdraw specified collateral from the bank.\\n     * @dev Only withdraws the collateral if the amount specified is greater than zero.\\n     * @param collToken Address of the isolated collateral token to be withdrawn.\\n     * @param amount Amount of tokens to be withdrawn.\\n     * @param swapData Paraswap calldata\\n     */\\n    function _swapCollToDebt(address collToken, uint256 amount, bytes calldata swapData) internal {\\n        if (amount > 0 && swapData.length != 0) {\\n            PSwapLib.swap(_augustusSwapper, _tokenTransferProxy, collToken, amount, swapData);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function Borrow specified tokens from the bank for the current executor.\\n     * @dev The borrowing happens only if the specified amount is greater than zero.\\n     * @param token Address of the token to be borrowed.\\n     * @param amount Amount of tokens to borrow.\\n     * @return borrowedAmount Actual amount of tokens borrowed.\\n     */\\n    function _doBorrow(address token, uint256 amount) internal returns (uint256 borrowedAmount) {\\n        if (amount > 0) {\\n            bool isETH = IERC20(token).isETH();\\n\\n            IBank bank = getBank();\\n            address weth = getWETH();\\n\\n            if (isETH) {\\n                borrowedAmount = bank.borrow(weth, amount);\\n                IWETH(weth).withdraw(borrowedAmount);\\n            } else {\\n                borrowedAmount = bank.borrow(token, amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Internall function Repay specified tokens to the bank for the current executor.\\n     * @dev Ensures approval of tokens to the bank and repays them.\\n     *      Only repays if the specified amount is greater than zero.\\n     * @param token Address of the token to be repaid to the bank.\\n     * @param amount Amount of tokens to repay.\\n     */\\n    function _doRepay(address token, uint256 amount) internal {\\n        if (amount > 0) {\\n            address t;\\n            bool isETH = IERC20(token).isETH();\\n\\n            address weth = getWETH();\\n\\n            if (isETH) {\\n                IWETH(weth).deposit{ value: amount }();\\n                t = weth;\\n            } else {\\n                t = token;\\n            }\\n\\n            IBank bank = getBank();\\n            IERC20(t).universalApprove(address(bank), amount);\\n            bank.repay(t, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function Deposit collateral tokens into the bank.\\n     * @dev Ensures approval of tokens to the werc20 contract, mints them,\\n     *      and then deposits them as collateral in the bank.\\n     *      Only deposits if the specified amount is greater than zero.\\n     * @param token Address of the collateral token to be deposited.\\n     * @param amount Amount of collateral tokens to deposit.\\n     */\\n    function _doPutCollateral(address token, uint256 amount) internal {\\n        if (amount > 0) {\\n            IWERC20 werc20 = getWrappedERC20();\\n            IERC20(token).universalApprove(address(werc20), amount);\\n            werc20.mint(token, amount);\\n            _bank.putCollateral(address(werc20), uint256(uint160(token)), amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function Withdraw collateral tokens from the bank.\\n     * @dev Burns the withdrawn tokens from werc20 contract after retrieval.\\n     *      Only withdraws if the specified amount is greater than zero.\\n     * @param token Address of the collateral token to be withdrawn.\\n     * @param amount Amount of collateral tokens to withdraw.\\n     */\\n    function _doTakeCollateral(address token, uint256 amount) internal {\\n        if (amount > 0) {\\n            amount = _bank.takeCollateral(amount);\\n            _werc20.burn(token, amount);\\n        }\\n    }\\n\\n    /// @dev Fallback function.\\n    /// NOTE: may remove this function in the future\\n    receive() external payable {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     *      variables without shifting down storage in the inheritance chain.\\n     *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[43] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/IBank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\nimport { IProtocolConfig } from \\\"./IProtocolConfig.sol\\\";\\nimport { IFeeManager } from \\\"./IFeeManager.sol\\\";\\nimport { ICoreOracle } from \\\"./ICoreOracle.sol\\\";\\n\\n/**\\n * @title IBank\\n * @notice Interface for the bank operations, including lending, borrowing, and management of collateral positions.\\n */\\ninterface IBank {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       STRUCTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Represents the configuration and current state of a bank.\\n    struct Bank {\\n        bool isListed; /// @dev Indicates if this bank is active.\\n        uint8 index; /// @dev Index for reverse lookups.\\n        address hardVault; /// @dev Address of the hard vault.\\n        address softVault; /// @dev Address of the soft vault.\\n        address bToken; /// @dev Address of the bToken associated with the bank.\\n        uint256 totalShare; /// @dev Total shares of debt across all open positions.\\n        uint256 liqThreshold; /// @dev Liquidation threshold (e.g., 85% for volatile tokens,\\n        /// 90% for stablecoins). Base: 1e4\\n    }\\n\\n    /// @notice Represents a position in the bank, including both debt and collateral.\\n    struct Position {\\n        address owner; /// @dev Address of the position's owner.\\n        address collToken; /// @dev Address of the ERC1155 token used as collateral.\\n        address underlyingToken; /// @dev Address of the isolated underlying collateral token.\\n        address debtToken; /// @dev Address of the debt token.\\n        uint256 underlyingVaultShare; /// @dev Amount of vault share for isolated underlying collateral.\\n        uint256 collId; /// @dev Token ID of the ERC1155 collateral.\\n        uint256 collateralSize; /// @dev Amount of wrapped token used as collateral.\\n        uint256 debtShare; /// @dev Debt share of the given debt token for the bank.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted when a new bank is added by the owner.\\n    event AddBank(\\n        address token, /// @dev The primary token associated with the bank.\\n        address bToken, /// @dev The corresponding bToken for the bank.\\n        address softVault, /// @dev Address of the soft vault.\\n        address hardVault /// @dev Address of the hard vault.\\n    );\\n\\n    /// @notice Emitted when a bank is modified by the owner.\\n    event ModifyBank(\\n        address token, /// @dev The primary token associated with the bank.\\n        address bToken, /// @dev The corresponding bToken for the bank.\\n        address softVault, /// @dev Address of the soft vault.\\n        address hardVault /// @dev Address of the hard vault.\\n    );\\n\\n    /// @notice Emitted when the oracle's address is updated by the owner.\\n    event SetOracle(address oracle); /// New address of the oracle.\\n\\n    /// @notice Emitted when a Wrapped ERC1155 token is whitelisted or removed by the owner.\\n    event SetWhitelistERC1155(\\n        address indexed token, /// Address of the Wrapped ERC1155 token.\\n        bool isWhitelisted /// True if whitelisted, false otherwise.\\n    );\\n\\n    /// @notice Emitted when a token is whitelisted or removed by the owner.\\n    event SetWhitelistToken(\\n        address indexed token, /// Address of the token.\\n        bool isWhitelisted /// True if whitelisted, false otherwise.\\n    );\\n\\n    /// @notice Emitted when tokens are lent to the bank.\\n    event Lend(\\n        uint256 positionId, /// Position ID associated with the lending.\\n        address caller, /// Address of the spell caller.\\n        address token, /// Address of the lent token.\\n        uint256 amount /// Amount of tokens lent.\\n    );\\n\\n    /// @notice Emitted when lent tokens are withdrawn from the bank.\\n    event WithdrawLend(\\n        uint256 positionId, /// Position ID associated with the withdrawal.\\n        address caller, /// Address of the spell caller.\\n        address token, ///Address of the token being withdrawn.\\n        uint256 amount /// Amount of tokens withdrawn.\\n    );\\n\\n    /// @notice Emitted when a user borrows tokens from a bank.\\n    event Borrow(\\n        uint256 positionId, /// Position ID associated with the borrowing.\\n        address caller, /// Address of the spell caller that initiates the borrowing.\\n        address token, /// Token being borrowed.\\n        uint256 amount, /// Amount of tokens borrowed.\\n        uint256 share /// Debt share associated with the borrowed amount.\\n    );\\n\\n    /// @notice Emitted when a user repays borrowed tokens to a bank.\\n    event Repay(\\n        uint256 positionId, /// Position ID associated with the repayment.\\n        address caller, /// Address of the spell caller initiating the repayment.\\n        address token, /// Token being repaid.\\n        uint256 amount, /// Amount of tokens repaid.\\n        uint256 share /// Debt share associated with the repaid amount.\\n    );\\n\\n    /// @notice Emitted when a user adds tokens as collateral.\\n    event PutCollateral(\\n        uint256 positionId, /// Position ID associated with the collateral.\\n        address owner, /// Owner of the collateral position.\\n        address caller, /// Address of the spell caller adding the collateral.\\n        address token, /// Token used as collateral.\\n        uint256 id, /// ID of the wrapped token.\\n        uint256 amount /// Amount of tokens put as collateral.\\n    );\\n\\n    /// @notice Emitted when a user retrieves tokens from their collateral.\\n    event TakeCollateral(\\n        uint256 positionId, /// Position ID associated with the collateral.\\n        address caller, /// Address of the spell caller retrieving the collateral.\\n        address token, /// Token taken from the collateral.\\n        uint256 id, /// ID of the wrapped token.\\n        uint256 amount /// Amount of tokens taken from collateral.\\n    );\\n\\n    /// @notice Emitted when a position is liquidated.\\n    event Liquidate(\\n        uint256 positionId, /// Position ID being liquidated.\\n        address liquidator, /// Address of the user performing the liquidation.\\n        address debtToken, /// Debt token associated with the position.\\n        uint256 amount, /// Amount used for liquidation.\\n        uint256 share, /// Debt share associated with the liquidation.\\n        uint256 positionSize, /// Size of the position being liquidated.\\n        uint256 underlyingVaultSize /// Vault size underlying the liquidated position.\\n    );\\n\\n    /// @notice Emitted when a position is executed.\\n    event Execute(\\n        uint256 positionId, /// Position ID being executed.\\n        address owner /// Owner of the position.\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Returns the next available position ID.\\n     * @return Next position ID.\\n     */\\n    function getNextPositionId() external view returns (uint256);\\n\\n    /// @notice Provides the protocol configuration settings.\\n    function getConfig() external view returns (IProtocolConfig);\\n\\n    /// @notice Provides the current oracle responsible for price feeds.\\n    function getOracle() external view returns (ICoreOracle);\\n\\n    /// @notice Provides all banks in the Blueberry Bank.\\n    function getAllBanks() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Get the current FeeManager interface from the configuration.\\n     * @return An interface representing the current FeeManager.\\n     */\\n    function getFeeManager() external view returns (IFeeManager);\\n\\n    /**\\n     * @notice Returns whitelist status of a given token.\\n     * @param token Address of the token.\\n     */\\n    function isTokenWhitelisted(address token) external view returns (bool);\\n\\n    /**\\n     * @notice Returns whitelist status of a given wrapped token.\\n     * @param token Address of the wrapped token.\\n     */\\n    function isWrappedTokenWhitelisted(address token) external view returns (bool);\\n\\n    /**\\n     * @notice Returns whitelist status of a given spell.\\n     * @param spell Address of the spell.\\n     */\\n    function isSpellWhitelisted(address spell) external view returns (bool);\\n\\n    /**\\n     * @dev Determine if lending is currently allowed based on the bank's status flags.\\n     * @notice Check the third-to-last bit of _bankStatus.\\n     * @return A boolean indicating whether lending is permitted.\\n     */\\n    function isLendAllowed() external view returns (bool);\\n\\n    /**\\n     * @dev Determine if withdrawing from lending is currently allowed based on the bank's status flags.\\n     * @notice Check the fourth-to-last bit of _bankStatus.\\n     * @return A boolean indicating whether withdrawing from lending is permitted.\\n     */\\n    function isWithdrawLendAllowed() external view returns (bool);\\n\\n    /**\\n     * @dev Determine if repayments are currently allowed based on the bank's status flags.\\n     * @notice Check the second-to-last bit of _bankStatus.\\n     * @return A boolean indicating whether repayments are permitted.\\n     */\\n    function isRepayAllowed() external view returns (bool);\\n\\n    /**\\n     * @dev Determine if borrowing is currently allowed based on the bank's status flags.\\n     * @notice Check the last bit of _bankStatus.\\n     * @return A boolean indicating whether borrowing is permitted.\\n     */\\n    function isBorrowAllowed() external view returns (bool);\\n\\n    /// @notice Fetches details of a bank given its token.\\n    function getBankInfo(address token) external view returns (Bank memory bank);\\n\\n    /**\\n     * @notice Gets the status of the bank\\n     * @return The status of the bank\\n     * @dev 1: Borrow is allowed\\n     *      2: Repay is allowed\\n     *      4: Lend is allowed\\n     *      8: WithdrawLend is allowed\\n     */\\n    function getBankStatus() external view returns (uint256);\\n\\n    /**\\n     * @dev Computes the total USD value of the debt of a given position.\\n     * @notice Ensure to call `accrue` beforehand to account for any interest changes.\\n     * @param positionId ID of the position to compute the debt value for.\\n     * @return debtValue Total USD value of the position's debt.\\n     */\\n    function getDebtValue(uint256 positionId) external returns (uint256 debtValue);\\n\\n    /**\\n     * @notice Gets the repay resumed timestamp of the bank\\n     * @return The timestamp when repay is resumed\\n     */\\n    function getRepayResumedTimestamp() external view returns (uint256);\\n\\n    /**\\n     * @dev Computes the risk ratio of a specified position.\\n     * @notice A higher risk ratio implies greater risk associated with the position.\\n     * @dev    when:  riskRatio = (ov - pv) / cv\\n     *         where: riskRatio = (debt - positionValue) / isolatedCollateralValue\\n     * @param positionId ID of the position to assess risk for.\\n     * @return risk The risk ratio of the position (based on a scale of 1e4).\\n     */\\n    function getPositionRisk(uint256 positionId) external returns (uint256 risk);\\n\\n    /**\\n     * @notice Retrieve the debt of a given position, considering the stored debt interest.\\n     * @dev Should call accrue first to obtain the current debt.\\n     * @param positionId The ID of the position to query.\\n     */\\n    function getPositionDebt(uint256 positionId) external view returns (uint256 debt);\\n\\n    /**\\n     * @notice Determines if a given position can be liquidated based on its risk ratio.\\n     * @param positionId ID of the position to check.\\n     * @return True if the position can be liquidated; otherwise, false.\\n     */\\n    function isLiquidatable(uint256 positionId) external returns (bool);\\n\\n    /**\\n     * @notice Computes the total USD value of the collateral of a given position.\\n     * @dev The returned value includes both the collateral and any pending rewards.\\n     * @param positionId ID of the position to compute the value for.\\n     * @return positionValue Total USD value of the collateral and pending rewards.\\n     */\\n    function getPositionValue(uint256 positionId) external returns (uint256);\\n\\n    /**\\n     * @notice Computes the isolated collateral value for a particular position.\\n     * @dev Should call accrue first to get current debt.\\n     * @param positionId The unique ID of the position.\\n     * @return icollValue The value of the isolated collateral in USD.\\n     */\\n    function getIsolatedCollateralValue(uint256 positionId) external returns (uint256 icollValue);\\n\\n    /**\\n     * @notice Provides comprehensive details about a position using its ID.\\n     * @param positionId The unique ID of the position.\\n     * @return A Position struct containing details of the position.\\n     */\\n    function getPositionInfo(uint256 positionId) external view returns (Position memory);\\n\\n    /**\\n     * @notice Fetches information about the currently active position.\\n     * @return A Position struct with details of the current position.\\n     */\\n    function getCurrentPositionInfo() external view returns (Position memory);\\n\\n    /**\\n     * @notice Triggers interest accumulation and fetches the updated borrow balance.\\n     * @param positionId The unique ID of the position.\\n     * @return The updated debt balance after accruing interest.\\n     */\\n    function currentPositionDebt(uint256 positionId) external returns (uint256);\\n\\n    /**\\n     * @dev Lend tokens to the bank as isolated collateral.\\n     * @dev Emit a {Lend} event.\\n     * @notice The tokens lent will be used as collateral in the bank and might earn interest or other rewards.\\n     * @param token The address of the token to lend.\\n     * @param amount The number of tokens to lend.\\n     */\\n    function lend(address token, uint256 amount) external;\\n\\n    /**\\n     * @dev Withdraw isolated collateral tokens previously lent to the bank.\\n     * @dev Emit a {WithdrawLend} event.\\n     * @notice This will reduce the isolated collateral and might also reduce the position's overall health.\\n     * @param token The address of the isolated collateral token to withdraw.\\n     * @param shareAmount The number of vault share tokens to withdraw.\\n     */\\n    function withdrawLend(address token, uint256 shareAmount) external;\\n\\n    /**\\n     * @notice Allows users to borrow tokens from the specified bank.\\n     * @dev This function must only be called from a spell while under execution.\\n     * @dev Emit a {Borrow} event.\\n     * @param token The token to borrow from the bank.\\n     * @param amount The amount of tokens the user wishes to borrow.\\n     * @return borrowedAmount Returns the actual amount borrowed from the bank.\\n     */\\n    function borrow(address token, uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @dev Executes a specific action on a position.\\n     * @dev Emit an {Execute} event.\\n     * @notice This can be used for various operations like adjusting collateral, repaying debt, etc.\\n     * @param positionId Unique identifier of the position, or zero for a new position.\\n     * @param spell Address of the contract (\\\"spell\\\") that contains the logic for the action to be executed.\\n     * @param data Data payload to pass to the spell for execution.\\n     */\\n    function execute(uint256 positionId, address spell, bytes memory data) external returns (uint256);\\n\\n    /**\\n     * @notice Allows users to repay their borrowed tokens to the bank.\\n     * @dev This function must only be called while under execution.\\n     * @dev Emit a {Repay} event.\\n     * @param token The token to repay to the bank.\\n     * @param amountCall The amount of tokens to be repaid.\\n     */\\n    function repay(address token, uint256 amountCall) external;\\n\\n    /**\\n     * @notice Allows users to provide additional collateral.\\n     * @dev Must only be called during execution.\\n     * @param collToken The ERC1155 token wrapped for collateral (i.e., Wrapped token of LP).\\n     * @param collId The token ID for collateral (i.e., uint256 format of LP address).\\n     * @param amountCall The amount of tokens to add as collateral.\\n     */\\n    function putCollateral(address collToken, uint256 collId, uint256 amountCall) external;\\n\\n    /**\\n     * @notice Allows users to withdraw a portion of their collateral.\\n     * @dev Must only be called during execution.\\n     * @param amount The amount of tokens to be withdrawn as collateral.\\n     * @return Returns the amount of collateral withdrawn.\\n     */\\n    function takeCollateral(uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @dev Liquidates a position by repaying its debt and taking the collateral.\\n     * @dev Emit a {Liquidate} event.\\n     * @notice Liquidation can only be triggered if the position is deemed liquidatable\\n     *         and other conditions are met.\\n     * @param positionId The unique identifier of the position to liquidate.\\n     * @param debtToken The token in which the debt is denominated.\\n     * @param amountCall The amount of debt to be repaid when calling transferFrom.\\n     */\\n    function liquidate(uint256 positionId, address debtToken, uint256 amountCall) external;\\n\\n    /**\\n     * @notice Accrues interest for a given token.\\n     * @param token Address of the token to accrue interest for.\\n     */\\n    function accrue(address token) external;\\n\\n    /**\\n     * @notice Accrues interest for a given list of tokens.\\n     * @param tokens An array of token addresses to accrue interest for.\\n     */\\n    function accrueAll(address[] memory tokens) external;\\n\\n    /* solhint-disable func-name-mixedcase */\\n\\n    /**\\n     * @notice Returns the current executor's address, which is the owner of the current position.\\n     * @return Address of the current executor.\\n     */\\n    function EXECUTOR() external view returns (address);\\n\\n    /**\\n     * @notice Returns the ID of the currently executed position.\\n     * @return Current position ID.\\n     */\\n    function POSITION_ID() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the address of the currently executed bank.\\n     * @return Current bank address.\\n     */\\n    function SPELL() external view returns (address);\\n\\n    /* solhint-enable func-name-mixedcase */\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/ichi/IICHIVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ninterface IICHIVault is IERC20, IERC20Metadata {\\n    function ichiVaultFactory() external view returns (address);\\n\\n    function pool() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function allowToken0() external view returns (bool);\\n\\n    function allowToken1() external view returns (bool);\\n\\n    function fee() external view returns (uint24);\\n\\n    function tickSpacing() external view returns (int24);\\n\\n    function currentTick() external view returns (int24);\\n\\n    function twapPeriod() external view returns (uint32);\\n\\n    function affiliate() external view returns (address);\\n\\n    function baseLower() external view returns (int24);\\n\\n    function baseUpper() external view returns (int24);\\n\\n    function limitLower() external view returns (int24);\\n\\n    function limitUpper() external view returns (int24);\\n\\n    function deposit0Max() external view returns (uint256);\\n\\n    function deposit1Max() external view returns (uint256);\\n\\n    function maxTotalSupply() external view returns (uint256);\\n\\n    function hysteresis() external view returns (uint256);\\n\\n    function getTotalAmounts() external view returns (uint256, uint256);\\n\\n    function deposit(uint256, uint256, address) external returns (uint256);\\n\\n    function withdraw(uint256, address) external returns (uint256, uint256);\\n\\n    function rebalance(\\n        int24 _baseLower,\\n        int24 _baseUpper,\\n        int24 _limitLower,\\n        int24 _limitUpper,\\n        int256 swapQuantity\\n    ) external;\\n\\n    function setDepositMax(uint256 _deposit0Max, uint256 _deposit1Max) external;\\n\\n    function setAffiliate(address _affiliate) external;\\n\\n    event DeployICHIVault(\\n        address indexed sender,\\n        address indexed pool,\\n        bool allowToken0,\\n        bool allowToken1,\\n        address owner,\\n        uint256 twapPeriod\\n    );\\n\\n    event SetTwapPeriod(address sender, uint32 newTwapPeriod);\\n\\n    event Deposit(address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1);\\n\\n    event Withdraw(address indexed sender, address indexed to, uint256 shares, uint256 amount0, uint256 amount1);\\n\\n    event Rebalance(\\n        int24 tick,\\n        uint256 totalAmount0,\\n        uint256 totalAmount1,\\n        uint256 feeAmount0,\\n        uint256 feeAmount1,\\n        uint256 totalSupply\\n    );\\n\\n    event MaxTotalSupply(address indexed sender, uint256 maxTotalSupply);\\n\\n    event Hysteresis(address indexed sender, uint256 hysteresis);\\n\\n    event DepositMax(address indexed sender, uint256 deposit0Max, uint256 deposit1Max);\\n\\n    event Affiliate(address indexed sender, address affiliate);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/uniswap/IUniswapV3Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\nimport \\\"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface IUniswapV3Router is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/IWIchiFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n*/\\n\\npragma solidity 0.8.22;\\n\\n/* solhint-disable max-line-length */\\nimport { IERC1155Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n/* solhint-enable max-line-length */\\n\\nimport { IERC20Wrapper } from \\\"./IERC20Wrapper.sol\\\";\\nimport { IIchiV2 } from \\\"./ichi/IIchiV2.sol\\\";\\nimport { IIchiFarm } from \\\"./ichi/IIchiFarm.sol\\\";\\n\\n/**\\n * @title IWIchiFarm\\n * @author BlueberryProtocol\\n * @notice This is the interface for the WIchiFarm contract\\n */\\ninterface IWIchiFarm is IERC1155Upgradeable, IERC20Wrapper {\\n    /// @notice Emitted when a user stakes liquidity provider tokens and a new ERC1155 token is minted.\\n    event Minted(uint256 indexed id, uint256 indexed pid, uint256 amount);\\n\\n    /// @notice Emitted when a user burns an ERC1155 token to claim rewards and close their position.\\n    event Burned(uint256 indexed id, uint256 indexed pid, uint256 amount);\\n\\n    /**\\n     * @notice Encodes pool id and ICHI per share into an ERC1155 token id\\n     * @param pid The pool id (The first 16-bits)\\n     * @param ichiPerShare Amount of ICHI per share, multiplied by 1e18 (The last 240-bits)\\n     * @return id The resulting ERC1155 token id\\n     */\\n    function encodeId(uint256 pid, uint256 ichiPerShare) external pure returns (uint256);\\n\\n    /**\\n     * @notice Decode an encoded ID into two separate uint values.\\n     * @param id The encoded uint ID to decode.\\n     * @return The two individual uint values decoded from the provided ID.\\n     */\\n    function decodeId(uint256 id) external pure returns (uint256, uint256);\\n\\n    /**\\n     * @notice Mint an ERC1155 token corresponding to a staked amount in a specific ICHI farm.\\n     * @param pid The pool ID representing the specific ICHI farm.\\n     * @param amount The amount of liquidity provider tokens to stake.\\n     * @return id The ID of the newly minted ERC1155 token representing the staked position.\\n     */\\n    function mint(uint256 pid, uint256 amount) external returns (uint256 id);\\n\\n    /**\\n     * @notice Burn an ERC1155 token to redeem staked liquidity provider tokens and any earned rewards.\\n     * @param id The Id of the ERC1155 token representing the staked position.\\n     * @param amount The amount of ERC1155 tokens to burn.\\n     * @return rewardAmount Returns the amount of ICHI rewards claimed.\\n     */\\n    function burn(uint256 id, uint256 amount) external returns (uint256);\\n\\n    /// @notice Fetch the address of the legacy ICHI token.\\n    function getIchiV1() external view returns (IERC20Upgradeable);\\n\\n    /// @notice Fetch the address of the ICHIV2 token.\\n    function getIchiV2() external view returns (IIchiV2);\\n\\n    /// @notice Fetch the address of the ICHI farming contract.\\n    function getIchiFarm() external view returns (IIchiFarm);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/spell/IIchiSpell.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\nimport { IBasicSpell } from \\\"./IBasicSpell.sol\\\";\\nimport { IUniswapV3Router } from \\\"../uniswap/IUniswapV3Router.sol\\\";\\nimport { IWIchiFarm } from \\\"../IWIchiFarm.sol\\\";\\n\\n/**\\n * @title IIchiSpell\\n * @notice Interface for the Ichi Spell contract.\\n */\\ninterface IIchiSpell is IBasicSpell {\\n    /**\\n     * @notice Adds a strategy to the contract.\\n     * @param vault Address of the vault linked to the strategy.\\n     * @param minPosSize Minimum position size in USD, normalized to 1e18.\\n     * @param maxPosSize Maximum position size in USD, normalized to 1e18.\\n     */\\n    function addStrategy(address vault, uint256 minPosSize, uint256 maxPosSize) external;\\n\\n    /**\\n     * @notice Deposits assets into an IchiVault.\\n     * @param param Parameters required for the open position operation.\\n     */\\n    function openPosition(OpenPosParam calldata param) external;\\n\\n    /**\\n     * @notice Deposits assets into an IchiVault and then farms them in Ichi Farm.\\n     * @param param Parameters required for the open position operation.\\n     */\\n    function openPositionFarm(OpenPosParam calldata param) external;\\n\\n    /**\\n     * @notice Withdraws assets from an ICHI Vault.\\n     * @param param Parameters required for the close position operation.\\n     */\\n    function closePosition(ClosePosParam calldata param) external;\\n\\n    /**\\n     * @notice Withdraws assets from an ICHI Vault and from Ichi Farm.\\n     * @param param Parameters required for the close position operation.\\n     */\\n    function closePositionFarm(ClosePosParam calldata param) external;\\n\\n    /// @notice Returns the Uniswap V3 router.\\n    function getUniswapV3Router() external view returns (IUniswapV3Router);\\n\\n    /// @notice Returns the ICHI Farm wrapper.\\n    function getWIchiFarm() external view returns (IWIchiFarm);\\n\\n    /// @notice Returns the address of the ICHIV2 token.\\n    function getIchiV2() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that never changes\\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\\ninterface IUniswapV3PoolImmutables {\\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\\n    /// @return The contract address\\n    function factory() external view returns (address);\\n\\n    /// @notice The first of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token1() external view returns (address);\\n\\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\\n    /// @return The fee\\n    function fee() external view returns (uint24);\\n\\n    /// @notice The pool tick spacing\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// This value is an int24 to avoid casting even though it is always positive.\\n    /// @return The tick spacing\\n    function tickSpacing() external view returns (int24);\\n\\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n    /// @return The max amount of liquidity per tick\\n    function maxLiquidityPerTick() external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that can change\\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\\n/// per transaction\\ninterface IUniswapV3PoolState {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// observationIndex The index of the last oracle observation that was written,\\n    /// observationCardinality The current maximum number of observations stored in the pool,\\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\n    /// tick upper,\\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n    /// a specific position.\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128,\\n            int56 tickCumulativeOutside,\\n            uint160 secondsPerLiquidityOutsideX128,\\n            uint32 secondsOutside,\\n            bool initialized\\n        );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\\n    /// @return _liquidity The amount of liquidity in the position,\\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\n    function positions(bytes32 key)\\n        external\\n        view\\n        returns (\\n            uint128 _liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    /// @notice Returns data about a specific observation index\\n    /// @param index The element of the observations array to fetch\\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n    /// ago, rather than at a specific index in the array.\\n    /// @return blockTimestamp The timestamp of the observation,\\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 secondsPerLiquidityCumulativeX128,\\n            bool initialized\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that is not stored\\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\n/// blockchain. The functions here may have variable gas costs.\\ninterface IUniswapV3PoolDerivedState {\\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\n    /// you must call it with secondsAgos = [3600, 0].\\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\\n    /// timestamp\\n    function observe(uint32[] calldata secondsAgos)\\n        external\\n        view\\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\\n\\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\\n    /// snapshot is taken and the second snapshot is taken.\\n    /// @param tickLower The lower tick of the range\\n    /// @param tickUpper The upper tick of the range\\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\\n        external\\n        view\\n        returns (\\n            int56 tickCumulativeInside,\\n            uint160 secondsPerLiquidityInsideX128,\\n            uint32 secondsInside\\n        );\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissionless pool actions\\n/// @notice Contains pool methods that can be called by anyone\\ninterface IUniswapV3PoolActions {\\n    /// @notice Sets the initial price for the pool\\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\\n    function initialize(uint160 sqrtPriceX96) external;\\n\\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\\n    /// @param recipient The address for which the liquidity will be created\\n    /// @param tickLower The lower tick of the position in which to add liquidity\\n    /// @param tickUpper The upper tick of the position in which to add liquidity\\n    /// @param amount The amount of liquidity to mint\\n    /// @param data Any data that should be passed through to the callback\\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    function mint(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount,\\n        bytes calldata data\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Collects tokens owed to a position\\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\n    /// @param recipient The address which should receive the fees collected\\n    /// @param tickLower The lower tick of the position for which to collect fees\\n    /// @param tickUpper The upper tick of the position for which to collect fees\\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\n    /// @dev Fees must be collected separately via a call to #collect\\n    /// @param tickLower The lower tick of the position for which to burn liquidity\\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\\n    /// @param amount How much liquidity to burn\\n    /// @return amount0 The amount of token0 sent to the recipient\\n    /// @return amount1 The amount of token1 sent to the recipient\\n    function burn(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Swap token0 for token1, or token1 for token0\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\\n    /// @param recipient The address to receive the output of the swap\\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n    /// @param data Any data to be passed through to the callback\\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\\n    /// @param recipient The address which will receive the token0 and token1 amounts\\n    /// @param amount0 The amount of token0 to send\\n    /// @param amount1 The amount of token1 to send\\n    /// @param data Any data to be passed through to the callback\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\n    /// the input observationCardinalityNext.\\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissioned pool actions\\n/// @notice Contains pool methods that may only be called by the factory owner\\ninterface IUniswapV3PoolOwnerActions {\\n    /// @notice Set the denominator of the protocol's % share of the fees\\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\\n\\n    /// @notice Collect the protocol fee accrued to the pool\\n    /// @param recipient The address to which collected protocol fees should be sent\\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\\n    /// @return amount0 The protocol fee collected in token0\\n    /// @return amount1 The protocol fee collected in token1\\n    function collectProtocol(\\n        address recipient,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Events emitted by a pool\\n/// @notice Contains all events emitted by the pool\\ninterface IUniswapV3PoolEvents {\\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\\n\\n    /// @notice Emitted when liquidity is minted for a given position\\n    /// @param sender The address that minted the liquidity\\n    /// @param owner The owner of the position and recipient of any minted liquidity\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity minted to the position range\\n    /// @param amount0 How much token0 was required for the minted liquidity\\n    /// @param amount1 How much token1 was required for the minted liquidity\\n    event Mint(\\n        address sender,\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted when fees are collected by the owner of a position\\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\\n    /// @param owner The owner of the position for which fees are collected\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount0 The amount of token0 fees collected\\n    /// @param amount1 The amount of token1 fees collected\\n    event Collect(\\n        address indexed owner,\\n        address recipient,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount0,\\n        uint128 amount1\\n    );\\n\\n    /// @notice Emitted when a position's liquidity is removed\\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\\n    /// @param owner The owner of the position for which liquidity is removed\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity to remove\\n    /// @param amount0 The amount of token0 withdrawn\\n    /// @param amount1 The amount of token1 withdrawn\\n    event Burn(\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted by the pool for any swaps between token0 and token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the output of the swap\\n    /// @param amount0 The delta of the token0 balance of the pool\\n    /// @param amount1 The delta of the token1 balance of the pool\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\\n    /// @param liquidity The liquidity of the pool after the swap\\n    /// @param tick The log base 1.0001 of price of the pool after the swap\\n    event Swap(\\n        address indexed sender,\\n        address indexed recipient,\\n        int256 amount0,\\n        int256 amount1,\\n        uint160 sqrtPriceX96,\\n        uint128 liquidity,\\n        int24 tick\\n    );\\n\\n    /// @notice Emitted by the pool for any flashes of token0/token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the tokens from flash\\n    /// @param amount0 The amount of token0 that was flashed\\n    /// @param amount1 The amount of token1 that was flashed\\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\\n    event Flash(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint256 paid0,\\n        uint256 paid1\\n    );\\n\\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\\n    /// just before a mint/swap/burn.\\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\n    event IncreaseObservationCardinalityNext(\\n        uint16 observationCardinalityNextOld,\\n        uint16 observationCardinalityNextNew\\n    );\\n\\n    /// @notice Emitted when the protocol fee is changed by the pool\\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\\n\\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\\n    /// @param sender The address that collects the protocol fees\\n    /// @param recipient The address that receives the collected protocol fees\\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\nimport {Address} from \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/libraries/Paraswap/PSwapLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../../interfaces/paraswap/IParaswap.sol\\\";\\nimport \\\"../../libraries/UniversalERC20.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\nlibrary PSwapLib {\\n    function _approve(\\n        IERC20 inToken,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        // approve zero before reset allocation\\n        UniversalERC20.universalApprove(inToken, spender, 0);\\n        UniversalERC20.universalApprove(inToken, spender, amount);\\n    }\\n\\n    function swap(\\n        address augustusSwapper,\\n        address tokenTransferProxy,\\n        address fromToken,\\n        uint256 fromAmount,\\n        bytes calldata data\\n    ) internal returns (bool success) {\\n        _approve(IERC20(fromToken), tokenTransferProxy, fromAmount);\\n\\n        bytes memory returndata;\\n\\n        (success, returndata) = augustusSwapper.call(data);\\n\\n        UniversalERC20.universalApprove(IERC20(fromToken), tokenTransferProxy, 0);\\n\\n        if (returndata.length > 0) {\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        }\\n    }\\n\\n    function megaSwap(\\n        address augustusSwapper,\\n        address tokenTransferProxy,\\n        Utils.MegaSwapSellData calldata data\\n    ) internal returns (uint256) {\\n        _approve(IERC20(data.fromToken), tokenTransferProxy, data.fromAmount);\\n\\n        uint256 result = IParaswap(augustusSwapper).megaSwap(data);\\n\\n        UniversalERC20.universalApprove(IERC20(data.fromToken), tokenTransferProxy, 0);\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/utils/BlueberryConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n*/\\n\\n/**\\n * @title BlueberryErrors\\n * @author BlueberryProtocol\\n * @notice This contract contains the error messages for Blueberry Protocol.\\n */\\npragma solidity 0.8.22;\\n\\n/// @dev Common denominator for percentage-based calculations.\\nuint256 constant DENOMINATOR = 10000;\\n\\n/// @dev Minimum threshold for liquidity operations, represented as a fraction of the DENOMINATOR.\\nuint256 constant MIN_LIQ_THRESHOLD = 8000; // represent 80%\\n\\n/// @dev Precision factor to maintain price accuracy.\\nuint256 constant PRICE_PRECISION = 1e18;\\n\\n/// @dev Maximum allowed price deviation, represented as a fraction of the DENOMINATOR.\\nuint256 constant MAX_PRICE_DEVIATION = 1000; // represent 10%\\n\\n/// @dev Minimum time interval for specific time-dependent operations.\\nuint32 constant MIN_TIME_GAP = 1 hours;\\n\\n/// @dev Maximum time interval for specific time-dependent operations.\\nuint32 constant MAX_TIME_GAP = 2 days;\\n\\n/// @dev Maximum allowed fee rate, represented as a fraction of the DENOMINATOR.\\nuint256 constant MAX_FEE_RATE = 2000; // represent 20%\\n\\n/// @dev Maximum allowed time for vault withdrawal fee calculations.\\nuint256 constant MAX_WITHDRAW_VAULT_FEE_WINDOW = 60 days;\\n\\n/// @dev Maximum delay permitted for swap operations.\\nuint32 constant MAX_DELAY_ON_SWAP = 2 hours;\\n\\n/// @dev Allowed grace period time for sequencer operations.\\nuint32 constant SEQUENCER_GRACE_PERIOD_TIME = 3600;\\n\\n/// @dev Precision factor for Chainlink price feed values.\\nuint256 constant CHAINLINK_PRICE_FEED_PRECISION = 1e8;\\n\\n/// @dev Warm-up period before a liquidation repayment can be initiated.\\nuint256 constant LIQUIDATION_REPAY_WARM_UP_PERIOD = 4 hours;\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/utils/ERC1155NaiveReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/*\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2588\u2588\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557  \u255a\u2588\u2588\u2554\u255d\\n\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551   \u2588\u2588\u2551\\n\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d   \u255a\u2550\u255d\\n*/\\n\\npragma solidity 0.8.22;\\n\\nimport { IERC1155Receiver } from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\n/**\\n * @title ERC1155NaiveReceiver\\n * @author BlueberryProtocol\\n * @notice A receiver contract that naively accepts all ERC1155 transfers.\\n */\\ncontract ERC1155NaiveReceiver is IERC1155Receiver {\\n    /// @notice Handle the receipt of a single ERC1155 token type.\\n    /// @dev This function is called at the end of a\\n    /// `safeTransferFrom` after the balance has been updated.\\n    function onERC1155Received(\\n        address /* operator */,\\n        address /* from */,\\n        uint256 /* id */,\\n        uint256 /* value */,\\n        bytes calldata /* data */\\n    ) external pure override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    /// @notice Handle the receipt of multiple ERC1155 token types.\\n    /// @dev This function is called at the end of a\\n    /// `safeBatchTransferFrom` after the balances have been updated.\\n    function onERC1155BatchReceived(\\n        address /* operator */,\\n        address /* from */,\\n        uint256[] calldata /* ids */,\\n        uint256[] calldata /* values */,\\n        bytes calldata /* data */\\n    ) external pure override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    /// @notice Checks if the contract supports a given interface.\\n    /// @dev Returns true if the interfaceId is 0x01ffc9a7 (IERC1155Receiver).\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/IERC20Wrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\n/**\\n * @title IERC20Wrapper\\n * @author BlueberryProtocol\\n * @notice Interface for the ERC20Wrapper contract which allows the wrapping\\n *         of ERC-20 tokens with associated ERC-1155 token IDs.\\n */\\ninterface IERC20Wrapper {\\n    /**\\n     * @notice Fetches the underlying ERC-20 token address associated with the provided ERC-1155 token ID.\\n     * @param tokenId The ERC-1155 token ID for which the underlying ERC-20 token address is to be fetched.\\n     * @return The address of the underlying ERC-20 token.\\n     */\\n    function getUnderlyingToken(uint256 tokenId) external view returns (address);\\n\\n    /**\\n     * @notice Fetches pending rewards for a particular ERC-1155 token ID and given amount.\\n     * @param id The ERC-1155 token ID for which the pending rewards are to be fetched.\\n     * @param amount The amount for which pending rewards are to be calculated.\\n     * @return tokens A list of addresses representing reward tokens.\\n     * @return amounts A list of amounts corresponding to each reward token in the `tokens` list.\\n     */\\n    function pendingRewards(uint256 id, uint256 amount) external returns (address[] memory, uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/IWERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\n/* solhint-disable max-line-length */\\nimport { IERC1155Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\n/* solhint-enable max-line-length */\\n\\nimport { IERC20Wrapper } from \\\"./IERC20Wrapper.sol\\\";\\n\\n/**\\n * @title IWERC20\\n * @author This interface defines the functionality of the Wrapped ERC20 (WERC20) token.\\n * @notice WERC20 tokens enable ERC20 tokens to be represented\\n *         as ERC1155 tokens, providing batch transfer capabilities and more.\\n */\\ninterface IWERC20 is IERC1155Upgradeable, IERC20Wrapper {\\n    /// @notice Emitted when a token is minted.\\n    event Minted(uint256 indexed id, uint256 amount);\\n\\n    /// @notice Emitted when a token is burned.\\n    event Burned(uint256 indexed id, uint256 amount);\\n\\n    /**\\n     * @notice Fetches the balance of the underlying ERC20 token for a specific user.\\n     * @param token The ERC20 token address.\\n     * @param user The user's address.\\n     * @return The user's balance of the specified ERC20 token.\\n     */\\n    function balanceOfERC20(address token, address user) external view returns (uint256);\\n\\n    /**\\n     * @notice Allows users to wrap their ERC20 tokens into the corresponding ERC1155 tokenId.\\n     * @param token The address of the ERC20 token to wrap.\\n     * @param amount The amount of the ERC20 token to wrap.\\n     * @return id The tokenId of the wrapped ERC20 token.\\n     */\\n    function mint(address token, uint256 amount) external returns (uint256 id);\\n\\n    /**\\n     * @notice Allows users to burn their ERC1155 token to retrieve the original ERC20 tokens.\\n     * @param token The address of the ERC20 token to unwrap.\\n     * @param amount The amount of the ERC20 token to unwrap.\\n     */\\n    function burn(address token, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\n/// @title IWETH\\n/// @notice This is the interface for the Wrapped Ether (WETH) contract.\\n/// @dev WETH is an ERC20-compatible version of Ether, facilitating interactions in smart contracts.\\ninterface IWETH {\\n    /// @notice Fetch the balance of `user` in terms of WETH.\\n    /// @param user The address of the account whose balance will be retrieved.\\n    /// @return The balance of the given user's address.\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    /// @notice Approve an address to spend WETH on behalf of the message sender.\\n    /// @param to The address to grant spending rights.\\n    /// @param value The amount of WETH the spender is allowed to transfer.\\n    /// @return A boolean value indicating whether the operation succeeded.\\n    function approve(address to, uint256 value) external returns (bool);\\n\\n    /// @notice Transfer WETH from the message sender to another address.\\n    /// @param to The recipient address.\\n    /// @param value The amount of WETH to be transferred.\\n    /// @return A boolean value indicating whether the transfer was successful.\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /// @notice Convert Ether to WETH by sending Ether to the contract.\\n    /// @dev This function should be called with a payable modifier to attach Ether.\\n    function deposit() external payable;\\n\\n    /// @notice Convert WETH back into Ether and send it to the message sender.\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/spell/IBasicSpell.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\n/**\\n * @title IBasicSpell\\n * @notice Interface for the Basic Spell contract.\\n */\\ninterface IBasicSpell {\\n    /**\\n     * @dev Defines strategies for Blueberry Protocol.\\n     * @param vault Address of the vault where assets are held.\\n     * @param minPositionSize Minimum size of the position in USD.\\n     * @param maxPositionSize Maximum size of the position in USD.\\n     */\\n    struct Strategy {\\n        address vault;\\n        uint256 minPositionSize;\\n        uint256 maxPositionSize;\\n    }\\n\\n    /**\\n     * @dev Defines parameters required for opening a new position.\\n     * @param strategyId Identifier for the strategy.\\n     * @param collToken Address of the collateral token (e.g., USDC).\\n     * @param collAmount Amount of user's collateral to deposit.\\n     * @param borrowToken Address of the token to borrow.\\n     * @param borrowAmount Amount to borrow from the bank.\\n     * @param farmingPoolId Identifier for the farming pool.\\n     */\\n    struct OpenPosParam {\\n        uint256 strategyId;\\n        address collToken;\\n        uint256 collAmount;\\n        address borrowToken;\\n        uint256 borrowAmount;\\n        uint256 farmingPoolId;\\n    }\\n\\n    /**\\n     * @dev Defines parameters required for closing a position.\\n     * @param strategyId Identifier for the strategy to close.\\n     * @param collToken Address of the isolated collateral token.\\n     * @param borrowToken Address of the token representing the debt.\\n     * @param amountRepay Amount of debt to repay.\\n     * @param amountPosRemove Amount of position to withdraw.\\n     * @param amountShareWithdraw Amount of isolated collateral tokens to withdraw.\\n     * @param amountOutMin Minimum amount to receive after the operation (used to handle slippage).\\n     * @param amountToSwap Collateral amount to swap to repay debt for negative PnL\\n     * @param swapData Paraswap sawp data to swap collateral to borrow token\\n     */\\n    struct ClosePosParam {\\n        uint256 strategyId;\\n        address collToken;\\n        address borrowToken;\\n        uint256 amountRepay;\\n        uint256 amountPosRemove;\\n        uint256 amountShareWithdraw;\\n        uint256 amountOutMin;\\n        uint256 amountToSwap;\\n        bytes swapData;\\n    }\\n\\n    /**\\n     * @notice This event is emitted when a new strategy is added.\\n     * @param strategyId Unique identifier for the strategy.\\n     * @param vault Address of the vault where assets are held.\\n     * @param minPosSize Minimum size of the position in USD.\\n     * @param maxPosSize Maximum size of the position in USD.\\n     */\\n    event StrategyAdded(uint256 strategyId, address vault, uint256 minPosSize, uint256 maxPosSize);\\n\\n    /**\\n     * @notice This event is emitted when a strategy's min/max position size is updated.\\n     * @param strategyId Unique identifier for the strategy.\\n     * @param minPosSize Minimum size of the position in USD.\\n     * @param maxPosSize Maximum size of the position in USD.\\n     */\\n    event StrategyPosSizeUpdated(uint256 strategyId, uint256 minPosSize, uint256 maxPosSize);\\n\\n    /**\\n     * @notice This event is emitted when a strategy's collateral max LTV is updated.\\n     * @param strategyId Unique identifier for the strategy.\\n     * @param collaterals Array of collateral token addresses.\\n     * @param maxLTVs Array of maximum LTVs corresponding to the collaterals. (base 1e4)\\n     */\\n    event CollateralsMaxLTVSet(uint256 strategyId, address[] collaterals, uint256[] maxLTVs);\\n\\n    /**\\n     * @notice Update the position sizes for a specific strategy.\\n     * @dev This function validates the inputs, updates the strategy's position sizes, and emits an event.\\n     * @param strategyId ID of the strategy to be updated.\\n     * @param minPosSize New minimum position size for the strategy.\\n     * @param maxPosSize New maximum position size for the strategy.\\n     */\\n    function setPosSize(uint256 strategyId, uint256 minPosSize, uint256 maxPosSize) external;\\n\\n    /**\\n     * @notice Set maximum Loan-To-Value (LTV) ratios for collaterals in a given strategy.\\n     * @dev This function validates the input arrays, sets the maxLTVs for each collateral, and emits an event.\\n     * @param strategyId ID of the strategy for which the maxLTVs are being set.\\n     * @param collaterals Array of addresses for each collateral token.\\n     * @param maxLTVs Array of maxLTV values corresponding to each collateral token.\\n     */\\n    function setCollateralsMaxLTVs(uint256 strategyId, address[] memory collaterals, uint256[] memory maxLTVs) external;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/IProtocolConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\nimport { IFeeManager } from \\\"./IFeeManager.sol\\\";\\n\\n/**\\n * @title IProtocolConfig\\n * @author BlueberryProtocol\\n * @notice Interface for the Protocol Configuration,\\n *         encapsulating various fees and related configuration parameters.\\n * @dev This interface defines methods to retrieve fees\\n *      and related parameters that govern the behavior of the protocol.\\n */\\ninterface IProtocolConfig {\\n    /**\\n     * @notice Retrieve the deposit fee rate applied when users deposit into the protocol.\\n     * @return The deposit fee rate.\\n     */\\n    function getDepositFee() external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieve the withdrawal fee rate applied when users withdraw from the protocol.\\n     * @return The withdrawal fee rate.\\n     */\\n    function getWithdrawFee() external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieve the reward fee rate applied when users claim rewards from the protocol.\\n     * @return The reward fee rate.\\n     */\\n    function getRewardFee() external view returns (uint256);\\n\\n    /**\\n     * @notice Get the address where protocol's collected fees are stored and managed.\\n     * @return The treasury address of the protocol.\\n     */\\n    function getTreasury() external view returns (address);\\n\\n    /**\\n     * @notice Retrieve the fee rate applied for withdrawals from vaults.\\n     * @return The fee rate for vault withdrawals.\\n     */\\n    function getTreasuryFeeRate() external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieve the fee rate applied for withdrawals from vaults.\\n     * @return The fee rate for vault withdrawals.\\n     */\\n    function getWithdrawVaultFee() external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieve the window of time where the vault withdrawal fee is applied.\\n     * @return The window of time where the vault withdrawal fee is applied.\\n     */\\n    function getWithdrawVaultFeeWindow() external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieve the start time of the window of time where the vault withdrawal fee is applied.\\n     * @return The start time of the window of time where the vault withdrawal fee is applied.\\n     */\\n    function getWithdrawVaultFeeWindowStartTime() external view returns (uint256);\\n\\n    /**\\n     * @notice Get the fee manager that handles fee calculations and distributions.\\n     * @return An instance of the IFeeManager interface that manages fees within the protocol.\\n     */\\n    function getFeeManager() external view returns (IFeeManager);\\n\\n    /**\\n     * @notice Get the address of the $BLB-ICHI vault.\\n     * @return The address of the $BLB-ICHI vault.\\n     */\\n    function getBlbUsdcIchiVault() external view returns (address);\\n\\n    /**\\n     * @notice Get the address of the $BLB stability pool.\\n     * @return The address of the $BLB stability pool.\\n     */\\n    function getBlbStabilityPool() external view returns (address);\\n\\n    /**\\n     * @notice Get the fee rate applied for withdrawals from the $BLB-ICHI vault.\\n     * @return The fee rate for $BLB-ICHI vault withdrawals.\\n     */\\n    function getBlbIchiVaultFeeRate() external view returns (uint256);\\n\\n    /**\\n     * @notice Get the fee rate applied for withdrawals from the $BLB-ICHI vault.\\n     * @return The fee rate for $BLB-ICHI vault withdrawals.\\n     */\\n    function getBlbStablePoolFeeRate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/IFeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.22;\\n\\nimport { IProtocolConfig } from \\\"./IProtocolConfig.sol\\\";\\n\\n/**\\n * @title IFeeManager\\n * @notice Interface for FeeManager, the central fee management contract in the Blueberry Protocol.\\n * @dev FeeManager is responsible for cutting various fees in the protocol and sending them to the treasury.\\n */\\ninterface IFeeManager {\\n    /**\\n     * @notice Calculates and deducts the deposit fee when lending\\n     *         isolated underlying assets to Blueberry Money Market.\\n     * @param token The address of the underlying token for which the deposit fee is to be calculated.\\n     * @param amount The gross deposit amount before fees.\\n     * @return The net deposit amount after the fee deduction.\\n     */\\n    function doCutDepositFee(address token, uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @notice Calculates and deducts the withdrawal fee when redeeming\\n     *         isolated underlying tokens from Blueberry Money Market.\\n     * @param token The address of the underlying token for which the withdrawal fee is to be calculated.\\n     * @param amount The gross withdrawal amount before fees.\\n     * @return The net withdrawal amount after the fee deduction.\\n     */\\n    function doCutWithdrawFee(address token, uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @notice Calculates and deducts the performance fee from the\\n     *         rewards generated due to the leveraged position.\\n     * @param token The address of the reward token for which the reward fee is to be calculated.\\n     * @param amount The gross reward amount before fees.\\n     * @return The net reward amount after the fee deduction.\\n     */\\n    function doCutRewardsFee(address token, uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @notice Calculates and deducts the vault withdrawal fee if\\n     *         the withdrawal occurs within the specified fee window in the Blueberry Money Market.\\n     * @param token The address of the underlying token for which the vault withdrawal fee is to be calculated.\\n     * @param amount The gross vault withdrawal amount before fees.\\n     * @return The net vault withdrawal amount after the fee deduction.\\n     */\\n    function doCutVaultWithdrawFee(address token, uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @notice Gets the protocol config contract address.\\n     */\\n    function getConfig() external view returns (IProtocolConfig);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/ICoreOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\nimport { IBaseOracle } from \\\"./IBaseOracle.sol\\\";\\n\\n/**\\n *  @title ICoreOracle\\n *  @notice Interface for the CoreOracle contract which provides price feed data for assets in the Blueberry protocol.\\n */\\ninterface ICoreOracle is IBaseOracle {\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                       EVENTS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Event emitted when the owner sets a new oracle route for a given token.\\n     * @param token The ERC20 token for which the oracle route is set.\\n     * @param route The address of the oracle route.\\n     */\\n    event SetRoute(address indexed token, address route);\\n\\n    /*//////////////////////////////////////////////////////////////////////////\\n                                      FUNCTIONS\\n    //////////////////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @notice Check if the given ERC20 token is supported by the oracle.\\n     * @param token The ERC20 token to check support for.\\n     * @return A boolean indicating whether the token is supported or not.\\n     */\\n    function isTokenSupported(address token) external returns (bool);\\n\\n    /**\\n     * @notice Check if the oracle supports the underlying token of a given ERC1155 wrapper.\\n     * @dev Only meant to validate wrappers of the Blueberry protocol, such as WERC20.\\n     * @param token ERC1155 token address to check support for.\\n     * @param tokenId ERC1155 token id to check support for.\\n     * @return A boolean indicating whether the wrapped token is supported or not.\\n     */\\n    function isWrappedTokenSupported(address token, uint256 tokenId) external returns (bool);\\n\\n    /**\\n     * @notice Returns the USD value of a specific wrapped ERC1155 token.\\n     * @param token ERC1155 token address.\\n     * @param id ERC1155 token id.\\n     * @param amount Amount of the token for which to get the USD value, normalized to 1e18 decimals.\\n     * @return The USD value of the given wrapped token amount.\\n     */\\n    function getWrappedTokenValue(address token, uint256 id, uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @notice Returns the USD value of a given amount of a specific ERC20 token.\\n     * @param token ERC20 token address.\\n     * @param amount Amount of the ERC20 token for which to get the USD value.\\n     * @return The USD value of the given token amount.\\n     */\\n    function getTokenValue(address token, uint256 amount) external returns (uint256);\\n\\n    /**\\n     * @notice Fetches the oracle route for the given token.\\n     * @param token Address of the token to get the route for.\\n     * @return The address of the oracle route for the given token.\\n     */\\n    function getRoute(address token) external returns (address);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/ichi/IIchiV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.22;\\n\\n/* solhint-disable func-name-mixedcase */\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\\\";\\n\\ninterface IIchiV2 is IERC20Upgradeable, IERC20PermitUpgradeable {\\n    // EIP-20 token name for this token\\n    function name() external view returns (string memory);\\n\\n    // EIP-20 token symbol for this token\\n    function symbol() external view returns (string memory);\\n\\n    // EIP-20 token decimals for this token\\n    function decimals() external view returns (uint8);\\n\\n    // ICHI V1 address\\n    function ichiV1() external view returns (address);\\n\\n    // Address which may mint inflationary tokens\\n    function minter() external view returns (address);\\n\\n    // The timestamp after which inflationary minting may occur\\n    function mintingAllowedAfter() external view returns (uint256);\\n\\n    // Minimum time between inflationary mints\\n    function minimumTimeBetweenMints() external view returns (uint32);\\n\\n    // Cap on the percentage of totalSupply that can be minted at each inflationary mint\\n    function mintCap() external view returns (uint8);\\n\\n    // ICHI V2 to ICHI V1 conversion fee (default is 0%)\\n    function conversionFee() external view returns (uint256);\\n\\n    // A record of each accounts delegate\\n    function delegates(address) external view returns (address);\\n\\n    // A record of votes checkpoints for each account, by index\\n    function checkpoints(address, uint32) external view returns (uint32, uint96);\\n\\n    // The number of checkpoints for each account\\n    function numCheckpoints(address) external view returns (uint32);\\n\\n    // The EIP-712 typehash for the contract's domain\\n    function DOMAIN_TYPEHASH() external view returns (bytes32);\\n\\n    // The EIP-712 typehash for the delegation struct used by the contract\\n    function DELEGATION_TYPEHASH() external view returns (bytes32);\\n\\n    // The EIP-712 typehash for the permit struct used by the contract\\n    function PERMIT_TYPEHASH() external view returns (bytes32);\\n\\n    // An event thats emitted when the minter address is changed\\n    event MinterChanged(address minter, address newMinter);\\n\\n    // An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    // An event thats emitted when a delegate account's vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\\n\\n    // An event thats emitted when ICHI V1 tokens are converted into ICHI V2 tokens\\n    event ConvertedToV2(address indexed from, uint256 amountIn, uint256 amountOut);\\n\\n    // An event thats emitted when ICHI V2 tokens are converted into ICHI V1 tokens\\n    event ConvertedToV1(address indexed from, uint256 amountIn, uint256 amountOut);\\n\\n    // An event thats emitted when the conversion fee is changed\\n    event ConversionFeeChanged(address minter, uint256 fee);\\n\\n    /**\\n     * @notice Change the minter address\\n     * @param minter_ The address of the new minter\\n     */\\n    function setMinter(address minter_) external;\\n\\n    /**\\n     * @notice Mint new tokens\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to be minted\\n     */\\n    function mint(address dst, uint256 rawAmount) external;\\n\\n    /**\\n     * @notice Change the ICHI V2 to ICHI V1 conversion fee\\n     * @param fee_ New conversion fee\\n     */\\n    function setConversionFee(uint256 fee_) external;\\n\\n    /**\\n     * @notice Convert ICHI V1 tokens to ICHI V2 tokens\\n     * @param rawAmount The number of ICHI V1 tokens to be converted (using 9 decimals representation)\\n     */\\n    function convertToV2(uint256 rawAmount) external;\\n\\n    /**\\n     * @notice Convert ICHI V2 tokens back to ICHI V1 tokens\\n     * @param rawAmount The number of ICHI V2 tokens to be converted (using 18 decimals representation)\\n     */\\n    function convertToV1(uint256 rawAmount) external;\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     */\\n    function delegate(address delegatee) external;\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96);\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/ichi/IIchiFarm.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\ninterface IIchiFarm {\\n    function lpToken(uint256 pid) external view returns (address);\\n\\n    function pendingIchi(uint256 pid, address user) external view returns (uint256);\\n\\n    function poolInfo(\\n        uint256 pid\\n    ) external view returns (uint256 accIchiPerShare, uint256 lastRewardBlock, uint256 allocPoint);\\n\\n    function userInfo(uint256 pid, address to) external view returns (uint256 amount, int256 rewardDebt);\\n\\n    function deposit(uint256 pid, uint256 amount, address to) external;\\n\\n    function withdraw(uint256 pid, uint256 amount, address to) external;\\n\\n    function harvest(uint256 pid, address to) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1363.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {FailedInnerCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\\n     * unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {FailedInnerCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/paraswap/IParaswap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../../libraries/Paraswap/Utils.sol\\\";\\n\\ninterface IParaswap {\\n    event Swapped(\\n        bytes16 uuid,\\n        address initiator,\\n        address indexed beneficiary,\\n        address indexed srcToken,\\n        address indexed destToken,\\n        uint256 srcAmount,\\n        uint256 receivedAmount,\\n        uint256 expectedAmount\\n    );\\n\\n    event Bought(\\n        bytes16 uuid,\\n        address initiator,\\n        address indexed beneficiary,\\n        address indexed srcToken,\\n        address indexed destToken,\\n        uint256 srcAmount,\\n        uint256 receivedAmount\\n    );\\n\\n    event FeeTaken(uint256 fee, uint256 partnerShare, uint256 paraswapShare);\\n\\n    function multiSwap(Utils.SellData calldata data) external payable returns (uint256);\\n\\n    function megaSwap(Utils.MegaSwapSellData calldata data) external payable returns (uint256);\\n\\n    function protectedMultiSwap(Utils.SellData calldata data) external payable returns (uint256);\\n\\n    function protectedMegaSwap(Utils.MegaSwapSellData calldata data) external payable returns (uint256);\\n\\n    function protectedSimpleSwap(Utils.SimpleData calldata data) external payable returns (uint256 receivedAmount);\\n\\n    function protectedSimpleBuy(Utils.SimpleData calldata data) external payable;\\n\\n    function simpleSwap(Utils.SimpleData calldata data) external payable returns (uint256 receivedAmount);\\n\\n    function simpleBuy(Utils.SimpleData calldata data) external payable;\\n\\n    function swapOnUniswap(uint256 amountIn, uint256 amountOutMin, address[] calldata path) external payable;\\n\\n    function swapOnUniswapFork(\\n        address factory,\\n        bytes32 initCode,\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path\\n    ) external payable;\\n\\n    function buyOnUniswap(uint256 amountInMax, uint256 amountOut, address[] calldata path) external payable;\\n\\n    function buyOnUniswapFork(\\n        address factory,\\n        bytes32 initCode,\\n        uint256 amountInMax,\\n        uint256 amountOut,\\n        address[] calldata path\\n    ) external payable;\\n\\n    function swapOnUniswapV2Fork(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address weth,\\n        uint256[] calldata pools\\n    ) external payable;\\n\\n    function buyOnUniswapV2Fork(\\n        address tokenIn,\\n        uint256 amountInMax,\\n        uint256 amountOut,\\n        address weth,\\n        uint256[] calldata pools\\n    ) external payable;\\n\\n    function swapOnZeroXv2(\\n        IERC20 fromToken,\\n        IERC20 toToken,\\n        uint256 fromAmount,\\n        uint256 amountOutMin,\\n        address exchange,\\n        bytes calldata payload\\n    ) external payable;\\n\\n    function swapOnZeroXv4(\\n        IERC20 fromToken,\\n        IERC20 toToken,\\n        uint256 fromAmount,\\n        uint256 amountOutMin,\\n        address exchange,\\n        bytes calldata payload\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/libraries/Paraswap/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\nlibrary Utils {\\n    /**\\n   * @param fromToken Address of the source token\\n   * @param fromAmount Amount of source tokens to be swapped\\n   * @param toAmount Minimum destination token amount expected out of this swap\\n   * @param expectedAmount Expected amount of destination tokens without slippage\\n   * @param beneficiary Beneficiary address\\n   * 0 then 100% will be transferred to beneficiary. Pass 10000 for 100%\\n   * @param path Route to be taken for this swap to take place\\n   */\\n    struct SellData {\\n        address fromToken;\\n        uint256 fromAmount;\\n        uint256 toAmount;\\n        uint256 expectedAmount;\\n        address payable beneficiary;\\n        Utils.Path[] path;\\n        address payable partner;\\n        uint256 feePercent;\\n        bytes permit;\\n        uint256 deadline;\\n        bytes16 uuid;\\n    }\\n\\n    struct MegaSwapSellData {\\n        address fromToken;\\n        uint256 fromAmount;\\n        uint256 toAmount;\\n        uint256 expectedAmount;\\n        address payable beneficiary;\\n        Utils.MegaSwapPath[] path;\\n        address payable partner;\\n        uint256 feePercent;\\n        bytes permit;\\n        uint256 deadline;\\n        bytes16 uuid;\\n    }\\n\\n    struct SimpleData {\\n        address fromToken;\\n        address toToken;\\n        uint256 fromAmount;\\n        uint256 toAmount;\\n        uint256 expectedAmount;\\n        address[] callees;\\n        bytes exchangeData;\\n        uint256[] startIndexes;\\n        uint256[] values;\\n        address payable beneficiary;\\n        address payable partner;\\n        uint256 feePercent;\\n        bytes permit;\\n        uint256 deadline;\\n        bytes16 uuid;\\n    }\\n\\n    struct Adapter {\\n        address payable adapter;\\n        uint256 percent;\\n        uint256 networkFee;\\n        Route[] route;\\n    }\\n\\n    struct Route {\\n        uint256 index; //Adapter at which index needs to be used\\n        address targetExchange;\\n        uint256 percent;\\n        bytes payload;\\n        uint256 networkFee; //Network fee is associated with 0xv3 trades\\n    }\\n\\n    struct MegaSwapPath {\\n        uint256 fromAmountPercent;\\n        Path[] path;\\n    }\\n\\n    struct Path {\\n        address to;\\n        uint256 totalNetworkFee; //Network fee is associated with 0xv3 trades\\n        Adapter[] adapters;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface that must be implemented by smart contracts in order to receive\\n * ERC-1155 token transfers.\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/contracts/interfaces/IBaseOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.22;\\n\\n/**\\n * @title IBaseOracle\\n * @author BlueberryProtocol\\n * @notice Interface for a basic oracle that provides price data for assets.\\n */\\ninterface IBaseOracle {\\n    /**\\n     * @notice Event emitted when a new LP token is registered within its respective implementation.\\n     * @param token Address of the LP token being registered\\n     */\\n    event RegisterLpToken(address token);\\n\\n    /**\\n     * @notice Fetches the price of the given token in USD with 18 decimals precision.\\n     * @param token Address of the ERC-20 token for which the price is requested.\\n     * @return The USD price of the given token, multiplied by 10**18.\\n     */\\n    function getPrice(address token) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\\n\\nimport \\\"./IERC20PermitUpgradeable.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@blueberry/=lib/blueberry-core/contracts/\",\r\n      \"@blueberry-stakevest/=lib/blueberry-stakevest/src/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/contracts-upgradeable/=lib/blueberry-core/node_modules/@openzeppelin/contracts-upgradeable/\",\r\n      \"src/=src/BlueberryContracts/\",\r\n      \"openzeppelin-contracts-upgradeable/contracts/=lib/blueberry-stakevest/lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"solady/=lib/blueberry-stakevest/lib/solady/\",\r\n      \"@chainlink/=lib/blueberry-core/node_modules/@chainlink/\",\r\n      \"@eth-optimism/=lib/blueberry-core/node_modules/@eth-optimism/contracts/\",\r\n      \"@uniswap/=lib/blueberry-core/node_modules/@uniswap/\",\r\n      \"base64-sol/=lib/blueberry-core/node_modules/base64-sol/\",\r\n      \"blueberry-core/=lib/blueberry-core/contracts/\",\r\n      \"blueberry-stakevest/=lib/blueberry-stakevest/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\r\n      \"eth-gas-reporter/=lib/blueberry-core/node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat-deploy/=lib/blueberry-core/node_modules/hardhat-deploy/\",\r\n      \"hardhat/=lib/blueberry-core/node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/\",\r\n      \"openzeppelin/=lib/blueberry-stakevest/lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/\",\r\n      \"v3-core/=lib/blueberry-stakevest/lib/v3-core/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"}],\"name\":\"COLLATERAL_NOT_EXIST\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EXCEED_MAX_LTV\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"EXCEED_MAX_POS_SIZE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"EXCEED_MIN_POS_SIZE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"colToken\",\"type\":\"address\"}],\"name\":\"INCORRECT_COLTOKEN\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"debtToken\",\"type\":\"address\"}],\"name\":\"INCORRECT_DEBT\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"}],\"name\":\"INCORRECT_LP\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"INCORRECT_PID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"INCORRECT_STRATEGY_ID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"}],\"name\":\"INCORRECT_UNDERLYING\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INPUT_ARRAY_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_POS_SIZE\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spell\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"STRATEGY_NOT_EXIST\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_AMOUNT\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"collaterals\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"maxLTVs\",\"type\":\"uint256[]\"}],\"name\":\"CollateralsMaxLTVSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPosSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxPosSize\",\"type\":\"uint256\"}],\"name\":\"StrategyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minPosSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxPosSize\",\"type\":\"uint256\"}],\"name\":\"StrategyPosSizeUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minPosSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPosSize\",\"type\":\"uint256\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountRepay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPosRemove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountShareWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwap\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"internalType\":\"struct IBasicSpell.ClosePosParam\",\"name\":\"param\",\"type\":\"tuple\"}],\"name\":\"closePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountRepay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPosRemove\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountShareWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwap\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"internalType\":\"struct IBasicSpell.ClosePosParam\",\"name\":\"param\",\"type\":\"tuple\"}],\"name\":\"closePositionFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAugustusSwapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBank\",\"outputs\":[{\"internalType\":\"contract IBank\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIchiV2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"getMaxLTV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"}],\"name\":\"getStrategy\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minPositionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPositionSize\",\"type\":\"uint256\"}],\"internalType\":\"struct IBasicSpell.Strategy\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenTransferProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniswapV3Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV3Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWIchiFarm\",\"outputs\":[{\"internalType\":\"contract IWIchiFarm\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWrappedERC20\",\"outputs\":[{\"internalType\":\"contract IWERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increasePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBank\",\"name\":\"bank\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"werc20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wichiFarm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniV3Router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"augustusSwapper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenTransferProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"farmingPoolId\",\"type\":\"uint256\"}],\"internalType\":\"struct IBasicSpell.OpenPosParam\",\"name\":\"param\",\"type\":\"tuple\"}],\"name\":\"openPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrowToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"farmingPoolId\",\"type\":\"uint256\"}],\"internalType\":\"struct IBasicSpell.OpenPosParam\",\"name\":\"param\",\"type\":\"tuple\"}],\"name\":\"openPositionFarm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collShareAmount\",\"type\":\"uint256\"}],\"name\":\"reducePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"collaterals\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"maxLTVs\",\"type\":\"uint256[]\"}],\"name\":\"setCollateralsMaxLTVs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPosSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPosSize\",\"type\":\"uint256\"}],\"name\":\"setPosSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "IchiSpell", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}