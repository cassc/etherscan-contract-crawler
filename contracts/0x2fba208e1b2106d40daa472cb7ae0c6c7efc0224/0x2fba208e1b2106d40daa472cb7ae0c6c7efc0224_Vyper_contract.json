{"SourceCode": "# @version 0.3.7\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface AggregatorV3Interface:\r\n    def latestRoundData() -> (uint80, int256, uint256, uint256, uint80): view\r\n\r\ninterface IDYFI:\r\n    def burn(owner: address, amount: uint256): nonpayable\r\n\r\ninterface CurvePoolInterface:\r\n    def price_oracle() -> uint256: view\r\n\r\nUNIT: constant(uint256) = 10**18\r\nSLIPPAGE_TOLERANCE: constant(uint256) = 3\r\nSLIPPAGE_DENOMINATOR: constant(uint256) = 1000\r\n\r\nDYFI: immutable(IDYFI)\r\nYFI: immutable(ERC20)\r\nVEYFI: immutable(ERC20)\r\nCURVE_POOL: immutable(CurvePoolInterface)\r\nPRICE_FEED: immutable(AggregatorV3Interface)\r\n\r\n# @dev Returns the address of the current owner.\r\nowner: public(address)\r\n# @dev Returns the address of the pending owner.\r\npending_owner: public(address)\r\n# @dev when the contract is killed, redemptions aren't possible\r\nkilled: public(bool)\r\n# @dev recipient of the ETH used for redemptions\r\npayee: public(address)\r\n# @dev scaling factor parameters packed into a single slot\r\npacked_scaling_factor: uint256\r\n\r\n# @dev Emitted when contract is killed\r\nevent Killed:\r\n    yfi_recovered: uint256\r\n\r\nevent Sweep:\r\n    token: indexed(address)\r\n    amount: uint256\r\n\r\n# @dev Emitted when the ownership transfer from\r\n# `previous_owner` to `pending_owner` is initiated.\r\nevent PendingOwnershipTransfer:\r\n    previous_owner: indexed(address)\r\n    pending_owner: indexed(address)\r\n\r\n\r\n# @dev Emitted when the ownership is transferred\r\n# from `previous_owner` to `new_owner`.\r\nevent OwnershipTransferred:\r\n    previous_owner: indexed(address)\r\n    new_owner: indexed(address)\r\n\r\nevent SetPayee:\r\n    payee: indexed(address)\r\n\r\n\r\nMASK: constant(uint256) = 2**64 - 1\r\n\r\n# powers of 10\r\nE3: constant(int256)               = 1_000\r\nE6: constant(int256)               = E3 * E3\r\nE9: constant(int256)               = E3 * E6\r\nE12: constant(int256)              = E3 * E9\r\nE15: constant(int256)              = E3 * E12\r\nE17: constant(int256)              = 100 * E15\r\nE18: constant(int256)              = E3 * E15\r\nE20: constant(int256)              = 100 * E18\r\nMIN_NAT_EXP: constant(int256)      = -41 * E18\r\nMAX_NAT_EXP: constant(int256)      = 130 * E18\r\n\r\n# x_n = 2^(7-n), a_n = exp(x_n)\r\n# in 20 decimals for n >= 2\r\nX0: constant(int256)  = 128 * E18 # 18 decimals\r\nA0: constant(int256)  = 38_877_084_059_945_950_922_200 * E15 * E18 # no decimals\r\nX1: constant(int256)  = X0 / 2 # 18 decimals\r\nA1: constant(int256)  = 6_235_149_080_811_616_882_910 * E6 # no decimals\r\nX2: constant(int256)  = X1 * 100 / 2\r\nA2: constant(int256)  = 7_896_296_018_268_069_516_100 * E12\r\nX3: constant(int256)  = X2 / 2\r\nA3: constant(int256)  = 888_611_052_050_787_263_676 * E6\r\nX4: constant(int256)  = X3 / 2\r\nA4: constant(int256)  = 298_095_798_704_172_827_474 * E3\r\nX5: constant(int256)  = X4 / 2\r\nA5: constant(int256)  = 5_459_815_003_314_423_907_810\r\nX6: constant(int256)  = X5 / 2\r\nA6: constant(int256)  = 738_905_609_893_065_022_723\r\nX7: constant(int256)  = X6 / 2\r\nA7: constant(int256)  = 271_828_182_845_904_523_536\r\nX8: constant(int256)  = X7 / 2\r\nA8: constant(int256)  = 164_872_127_070_012_814_685\r\nX9: constant(int256)  = X8 / 2\r\nA9: constant(int256)  = 128_402_541_668_774_148_407\r\nX10: constant(int256) = X9 / 2\r\nA10: constant(int256) = 11_331_4845_306_682_631_683\r\nX11: constant(int256) = X10 / 2\r\nA11: constant(int256) = 1_064_49_445_891_785_942_956\r\n\r\n@external\r\ndef __init__(\r\n    yfi: address, d_yfi: address, ve_yfi: address, owner: address, \r\n    price_feed: address, curve_pool: address, scaling_factor: uint256,\r\n):\r\n    assert scaling_factor >= UNIT and scaling_factor <= 12 * UNIT\r\n    YFI = ERC20(yfi)\r\n    DYFI = IDYFI(d_yfi)\r\n    VEYFI = ERC20(ve_yfi)\r\n    PRICE_FEED = AggregatorV3Interface(price_feed)\r\n    CURVE_POOL = CurvePoolInterface(curve_pool)\r\n    self._transfer_ownership(owner)\r\n    self.payee = owner\r\n    self.packed_scaling_factor = shift(scaling_factor, 128) | shift(scaling_factor, 192)\r\n\r\n\r\n@payable\r\n@external\r\ndef redeem(amount: uint256, recipient: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    @notice Redeem your dYFI for YFI using ETH.\r\n    @dev Redemption tolerates a 0.3% negative or positive slippage.\r\n    @param amount amount of dYFI to spend\r\n    @param recipient of the exercised YFI\r\n    \"\"\"\r\n    self._check_killed()\r\n    assert YFI.balanceOf(self) >= amount, \"not enough YFI\"\r\n    eth_required: uint256 = self._eth_required(amount)\r\n    assert eth_required > 0\r\n    tolerance: uint256 = eth_required * SLIPPAGE_TOLERANCE / SLIPPAGE_DENOMINATOR\r\n    if msg.value < (eth_required - tolerance) or msg.value > (eth_required + tolerance):\r\n        raise \"price out of tolerance\"\r\n    DYFI.burn(msg.sender, amount)\r\n    raw_call(self.payee, b\"\", value=msg.value)\r\n    YFI.transfer(recipient, amount)\r\n    return amount\r\n\r\n\r\n@external\r\n@view\r\ndef discount() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current dYFI redemption discount\r\n    @return Redemption discount (18 decimals)\r\n    @dev \r\n        Discount formula is `1/(1 + 10 e^(4.7(s*x - 1)))`,\r\n        with `x = veyfi supply / yfi supply`\r\n    \"\"\"\r\n    return self._discount()\r\n\r\n\r\n@internal\r\n@view\r\ndef _discount() -> uint256:\r\n    yfi_supply: uint256 = YFI.totalSupply()\r\n    veyfi_supply: uint256 = VEYFI.totalSupply()\r\n    x: int256 = convert(veyfi_supply * UNIT / yfi_supply, int256)\r\n    x = self._exp(47 * (self._scaling_factor()[0] * x / E18 - E18) / 10)\r\n    return convert(E18 * E18 / (E18 + 10 * x), uint256)\r\n\r\n\r\n@external\r\n@view\r\ndef eth_required(amount: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Estimate the required amount of ETH to redeem the amount of dYFI for YFI\r\n    @param amount Amount of dYFI\r\n    @return Amount of ETH required\r\n    \"\"\"\r\n    return self._eth_required(amount)\r\n\r\n\r\n@internal\r\n@view\r\ndef _eth_required(amount: uint256) -> uint256:\r\n    return amount * self._get_latest_price() / UNIT * (UNIT - self._discount()) / UNIT\r\n\r\n\r\n@external\r\n@view\r\ndef get_latest_price() -> uint256:\r\n    \"\"\"\r\n    @notice Get the latest price of YFI in ETH\r\n    @return Price of YFI in ETH (18 decimals)\r\n    \"\"\"\r\n    return self._get_latest_price()\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_latest_price() -> uint256:\r\n    oracle_price: uint256 = convert(self._get_oracle_price(), uint256)\r\n    pool_price: uint256 = CURVE_POOL.price_oracle()\r\n    if pool_price < oracle_price:\r\n        return oracle_price\r\n    return pool_price\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_oracle_price() -> int256:\r\n    round_id: uint80 = 0\r\n    price: int256 = 0\r\n    started_at: uint256 = 0\r\n    updated_at: uint256 = 0\r\n    answered_in_round: uint80 = 0\r\n    (round_id, price, started_at, updated_at, answered_in_round) = PRICE_FEED.latestRoundData()\r\n    assert updated_at + 3600 > block.timestamp, \"price too old\"\r\n    return price\r\n\r\n\r\n@external\r\n@view\r\ndef scaling_factor() -> uint256:\r\n    \"\"\"\r\n    @notice Get the current discount curve scaling factor\r\n    @return Scaling factor (18 decimals)\r\n    \"\"\"\r\n    return convert(self._scaling_factor()[0], uint256)\r\n\r\n@external\r\n@view\r\ndef scaling_factor_ramp() -> (uint256, uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the current discount curve scaling factor ramp parameters\r\n    @return Tuple of ramp start timestamp, ramp end timestamp, ramp start scaling factor, ramp end scaling factor\r\n    \"\"\"\r\n    ramp_start: uint256 = 0\r\n    ramp_end: uint256 = 0\r\n    old: int256 = 0\r\n    new: int256 = 0\r\n    ramp_start, ramp_end, old, new = self._unpack_scaling_factor(self.packed_scaling_factor)\r\n    return ramp_start, ramp_end, convert(old, uint256), convert(new, uint256)\r\n\r\n\r\n@internal\r\n@view\r\ndef _scaling_factor() -> (int256, bool):\r\n    ramp_start: uint256 = 0\r\n    ramp_end: uint256 = 0\r\n    old: int256 = 0\r\n    new: int256 = 0\r\n    ramp_start, ramp_end, old, new = self._unpack_scaling_factor(self.packed_scaling_factor)\r\n    if ramp_end <= block.timestamp:\r\n        return new, False\r\n    if ramp_start > block.timestamp:\r\n        return old, False\r\n    \r\n    duration: int256 = convert(ramp_end - ramp_start, int256)\r\n    time: int256 = convert(block.timestamp - ramp_start, int256)\r\n    return old + (new - old) * time / duration, True\r\n\r\n\r\n@external\r\ndef set_payee(new_payee: address):\r\n    \"\"\"\r\n    @dev set the payee of the ETH used for redemptions\r\n    @param new_payee the new payee\r\n    \"\"\"\r\n    self._check_owner()\r\n    assert new_payee != empty(address)\r\n    self.payee = new_payee\r\n    log SetPayee(new_payee)\r\n\r\n\r\n@external\r\ndef start_ramp(new: uint256, duration: uint256 = 604_800, start: uint256 = block.timestamp):\r\n    \"\"\"\r\n    @notice Start ramping of scaling factor\r\n    @param new New scaling factor (18 decimals)\r\n    @param duration Ramp duration (seconds)\r\n    @param start Ramp start timestamp\r\n    \"\"\"\r\n    self._check_owner()\r\n    assert new >= UNIT and new <= 12 * UNIT\r\n    assert start >= block.timestamp\r\n    scaling_factor: int256 = 0\r\n    active: bool = False\r\n    scaling_factor, active = self._scaling_factor()\r\n    assert not active\r\n    self.packed_scaling_factor = self._pack_scaling_factor(\r\n        start, start + duration, scaling_factor, convert(new, int256)\r\n    )\r\n\r\n@external\r\ndef stop_ramp():\r\n    \"\"\"\r\n    @notice Stop a currently active ramp\r\n    \"\"\"\r\n    self._check_owner()\r\n    scaling_factor: int256 = 0\r\n    active: bool = False\r\n    scaling_factor, active = self._scaling_factor()\r\n    assert active\r\n    self.packed_scaling_factor = self._pack_scaling_factor(0, 0, scaling_factor, scaling_factor)\r\n\r\n\r\n@external\r\ndef kill():\r\n    \"\"\"\r\n    @dev stop the contract from being used and reclaim YFI\r\n    \"\"\"\r\n    self._check_killed()\r\n    self._check_owner()\r\n    self.killed = True\r\n    yfi_balance: uint256 = YFI.balanceOf(self)\r\n    YFI.transfer(self.owner, yfi_balance)\r\n\r\n    log Killed(yfi_balance)\r\n\r\n@internal\r\ndef _check_killed():\r\n    \"\"\"\r\n    @dev Throws if contract was killed\r\n    \"\"\"\r\n    assert self.killed == False, \"killed\"\r\n\r\n@external\r\ndef sweep(token: address) -> uint256:\r\n    assert self.killed or token != YFI.address, \"protected token\"\r\n    self._check_owner()\r\n    amount: uint256 = 0\r\n    if token == empty(address):\r\n        amount = self.balance\r\n        raw_call(self.owner, b\"\", value=amount)\r\n    else:\r\n        amount = ERC20(token).balanceOf(self)\r\n        assert ERC20(token).transfer(self.owner, amount, default_return_value=True)\r\n    log Sweep(token, amount)\r\n    return amount\r\n\r\n\r\n### Ownable2Step ###\r\n@external\r\ndef transfer_ownership(new_owner: address):\r\n    \"\"\"\r\n    @dev Starts the ownership transfer of the contract\r\n         to a new account `new_owner`.\r\n    @notice Note that this function can only be\r\n            called by the current `owner`. Also, there is\r\n            no security risk in setting `new_owner` to the\r\n            zero address as the default value of `pending_owner`\r\n            is in fact already the zero address and the zero\r\n            address cannot call `accept_ownership`. Eventually,\r\n            the function replaces the pending transfer if\r\n            there is one.\r\n    @param new_owner The 20-byte address of the new owner.\r\n    \"\"\"\r\n    self._check_owner()\r\n    self.pending_owner = new_owner\r\n    log PendingOwnershipTransfer(self.owner, new_owner)\r\n\r\n\r\n@external\r\ndef accept_ownership():\r\n    \"\"\"\r\n    @dev The new owner accepts the ownership transfer.\r\n    @notice Note that this function can only be\r\n            called by the current `pending_owner`.\r\n    \"\"\"\r\n    assert self.pending_owner == msg.sender, \"Ownable2Step: caller is not the new owner\"\r\n    self._transfer_ownership(msg.sender)\r\n\r\n\r\n@internal\r\ndef _check_owner():\r\n    \"\"\"\r\n    @dev Throws if the sender is not the owner.\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"Ownable2Step: caller is not the owner\"\r\n\r\n\r\n@internal\r\ndef _transfer_ownership(new_owner: address):\r\n    \"\"\"\r\n    @dev Transfers the ownership of the contract\r\n         to a new account `new_owner` and deletes\r\n         any pending owner.\r\n    @notice This is an `internal` function without\r\n            access restriction.\r\n    @param new_owner The 20-byte address of the new owner.\r\n    \"\"\"\r\n    self.pending_owner = empty(address)\r\n    old_owner: address = self.owner\r\n    self.owner = new_owner\r\n    log OwnershipTransferred(old_owner, new_owner)\r\n\r\n\r\n@internal\r\n@pure\r\ndef _pack_scaling_factor(_ramp_start: uint256, _ramp_end: uint256, _old: int256, _new: int256) -> uint256:\r\n    assert _ramp_start <= MASK and _ramp_end <= MASK\r\n    assert _old <= convert(MASK, int256) and _new > 0 and _new <= convert(MASK, int256)\r\n    return _ramp_start | shift(_ramp_end, 64) | \\\r\n        shift(convert(_old, uint256), 128) | shift(convert(_new, uint256), 192)\r\n\r\n@internal\r\n@pure\r\ndef _unpack_scaling_factor(_packed: uint256) -> (uint256, uint256, int256, int256):\r\n    return _packed & MASK, shift(_packed, -64) & MASK, \\\r\n        convert(shift(_packed, -128) & MASK, int256), convert(shift(_packed, -192), int256)\r\n\r\n# From https://github.com/yearn/yETH/blob/main/contracts/Pool.vy, based on Balancer code\r\n\r\n@internal\r\n@pure\r\ndef _exp(_x: int256) -> int256:\r\n    \"\"\"\r\n    @notice Calculate natural exponent `e^x`\r\n    @param _x Exponent (18 decimals)\r\n    @return Natural exponent in 18 decimals\r\n    \"\"\"\r\n    assert _x >= MIN_NAT_EXP and _x <= MAX_NAT_EXP\r\n    if _x < 0:\r\n        # exp(-x) = 1/exp(x)\r\n        return unsafe_mul(E18, E18) / self.__exp(-_x)\r\n    return self.__exp(_x)\r\n\r\n@internal\r\n@pure\r\ndef __exp(_x: int256) -> int256:\r\n    \"\"\"\r\n    @notice Calculate natural exponent `e^x`, assuming exponent is positive\r\n    @param _x Exponent (18 decimals)\r\n    @return Natural exponent in 18 decimals\r\n    @dev Caller should perform bounds checks before calling this function\r\n    \"\"\"\r\n    \r\n    # e^x = e^(sum(k_n x_n) + rem)\r\n    #     = product(e^(k_n x_n)) * e^(rem)\r\n    #     = product(a_n^k_n) * e^(rem)\r\n    # k_n = {0,1}, x_n = 2^(7-n), a_n = exp(x_n)\r\n    x: int256 = _x\r\n\r\n    # subtract out x_ns\r\n    f: int256 = 1\r\n    if x >= X0:\r\n        x = unsafe_sub(x, X0)\r\n        f = A0\r\n    elif x >= X1:\r\n        x = unsafe_sub(x, X1)\r\n        f = A1\r\n\r\n    # other terms are in 20 decimals\r\n    x = unsafe_mul(x, 100)\r\n\r\n    p: int256 = E20\r\n    if x >= X2:\r\n        x = unsafe_sub(x, X2)\r\n        p = unsafe_div(unsafe_mul(p, A2), E20) # p * A2 / E20\r\n    if x >= X3:\r\n        x = unsafe_sub(x, X3)\r\n        p = unsafe_div(unsafe_mul(p, A3), E20)\r\n    if x >= X4:\r\n        x = unsafe_sub(x, X4)\r\n        p = unsafe_div(unsafe_mul(p, A4), E20)\r\n    if x >= X5:\r\n        x = unsafe_sub(x, X5)\r\n        p = unsafe_div(unsafe_mul(p, A5), E20)\r\n    if x >= X6:\r\n        x = unsafe_sub(x, X6)\r\n        p = unsafe_div(unsafe_mul(p, A6), E20)\r\n    if x >= X7:\r\n        x = unsafe_sub(x, X7)\r\n        p = unsafe_div(unsafe_mul(p, A7), E20)\r\n    if x >= X8:\r\n        x = unsafe_sub(x, X8)\r\n        p = unsafe_div(unsafe_mul(p, A8), E20)\r\n    if x >= X9:\r\n        x = unsafe_sub(x, X9)\r\n        p = unsafe_div(unsafe_mul(p, A9), E20)\r\n    \r\n    # x < X9 (0.25), taylor series for remainder\r\n    # c = e^x = sum(x^n / n!)\r\n    n: int256 = x\r\n    c: int256 = unsafe_add(E20, x)\r\n\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 2) # n * x / E20 / 2\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 3)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 4)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 5)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 6)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 7)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 8)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 9)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 10)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 11)\r\n    c = unsafe_add(c, n)\r\n    n = unsafe_div(unsafe_div(unsafe_mul(n, x), E20), 12)\r\n    c = unsafe_add(c, n)\r\n\r\n    # p * c / E20 * f / 100\r\n    return unsafe_div(unsafe_mul(unsafe_div(unsafe_mul(p, c), E20), f), 100)", "ABI": "[{\"name\":\"Killed\",\"inputs\":[{\"name\":\"yfi_recovered\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Sweep\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PendingOwnershipTransfer\",\"inputs\":[{\"name\":\"previous_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"pending_owner\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OwnershipTransferred\",\"inputs\":[{\"name\":\"previous_owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"new_owner\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetPayee\",\"inputs\":[{\"name\":\"payee\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"yfi\",\"type\":\"address\"},{\"name\":\"d_yfi\",\"type\":\"address\"},{\"name\":\"ve_yfi\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"price_feed\",\"type\":\"address\"},{\"name\":\"curve_pool\",\"type\":\"address\"},{\"name\":\"scaling_factor\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"redeem\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"redeem\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"recipient\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"discount\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"eth_required\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_latest_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"scaling_factor\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"scaling_factor_ramp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_payee\",\"inputs\":[{\"name\":\"new_payee\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"start_ramp\",\"inputs\":[{\"name\":\"new\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"start_ramp\",\"inputs\":[{\"name\":\"new\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"start_ramp\",\"inputs\":[{\"name\":\"new\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"start\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"kill\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"sweep\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer_ownership\",\"inputs\":[{\"name\":\"new_owner\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_ownership\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pending_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"payee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e00000000000000000000000041252e8691e964f7de35156b68493bab6797a27500000000000000000000000090c1f9220d90d3966fbee24045edd73e1d588ad5000000000000000000000000dddddddd0005d49d9b508bf034b036aab5818bcf0000000000000000000000003ebeaca272ce4f60e800f6c5ee678f50d2882fd4000000000000000000000000c26b89a667578ec7b3f11b2f98d6fd15c07c54ba0000000000000000000000000000000000000000000000008ac7230489e80000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}