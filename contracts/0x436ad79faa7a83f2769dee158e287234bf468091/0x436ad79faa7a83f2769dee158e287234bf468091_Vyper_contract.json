{"SourceCode": "# @version 0.2.7\r\n# (c) CoinFLEX\r\n# Pipeline to change Pool LP Tokens to unified vLP Token for the Geyser\r\n\r\n'''\r\n@title Pipeline\r\n@author CoinFLEX\r\n@license Copyright (c) CoinFLEX, 2021 - all rights reserved\r\n@notice Pipeline to change Pool LP Tokens to unified vLP Token for the Geyser\r\n@dev Swaps between LP Tokens from admin-verfified Liquidity Pool Tokens to get vLP Token\r\n'''\r\nfrom vyper.interfaces import ERC20\r\n\r\n### Interfaces ###\r\ninterface ERC20LP:\r\n  def mint(_to: address, _value: uint256) -> bool: nonpayable\r\n  def burnFrom(_to: address, _value: uint256) -> bool: nonpayable\r\n\r\ninterface TokenGeyser:\r\n  def totalStakedFor(_addr: address) -> uint256:view\r\n  def totalStaked() -> uint256:view\r\n  def token() -> address:view\r\n  def totalLocked() -> uint256:view\r\n  def totalUnlocked() -> uint256:view\r\n  def getStakingToken() -> address:view\r\n  def getDistributionToken() -> address:view\r\n  def stake(_amount: uint256, _data: Bytes[32]): nonpayable\r\n  def stakeFor(_user: address, _amount: uint256, _data: Bytes[32]): nonpayable\r\n  def unstake(_amount: uint256, _data: Bytes[32]): nonpayable\r\n  def unstakeQuery(_amount: uint256) -> uint256: payable\r\n\r\ninterface Ownable: # OpenZeppelin Ownable\r\n  def transferOwnership(_new_owner:address): nonpayable\r\n\r\n### Events ###\r\nevent LiquidityPoolTokenAdded:\r\n  _lp_addr: indexed(address)\r\n\r\nevent LiquidityPoolTokenRemoved:\r\n  _lp_addr: indexed(address)\r\n\r\nevent TokenStakedAtGeyser:\r\n  _lp_addr: indexed(address)\r\n  _staked_for: indexed(address)\r\n  _amount: indexed(uint256)\r\n\r\nevent TokenRedeemed:\r\n  _lp_addr: indexed(address)\r\n  _staked_for: indexed(address)\r\n  _amount: indexed(uint256)\r\n\r\nevent TokenRecovery:\r\n  _lp_addr: indexed(address)\r\n  _amount: indexed(uint256)\r\n\r\n### Member Variables ###\r\nlp_tokens: public(HashMap[address, bool])\r\nlp_balances: public(HashMap[address, HashMap[address, uint256]])\r\nhas_staked: public(HashMap[address, bool])\r\nowner: public(address)\r\npipeline_token: public(address)\r\ngeyser: public(address)\r\nrecovery_timelock: public(uint256)\r\n\r\n@external\r\ndef __init__(_plt_addr: address, _geyser_addr: address, _timelock: uint256):\r\n  '''\r\n  @notice Contract constructor\r\n  @param _plt_addr  address to Pipeline Token\r\n  @param _geyser_addr  address to Token Geyser where Pipeline Token will be staked/locked\r\n  @param _timelock  set timelock until tokens stuck within pipeline can be recovered by admin starting from deployment blocktime\r\n  '''\r\n  self.pipeline_token = _plt_addr\r\n  self.geyser = _geyser_addr\r\n  self.owner = msg.sender\r\n  assert _timelock > 0, 'Recovery Timelock cannot be below zero.' # dev: recovery timelock cannot be below zero\r\n  self.recovery_timelock = block.timestamp + _timelock\r\n\r\n@external\r\ndef add_lp_token(_lp_addr: address) -> bool:\r\n  '''\r\n  @notice this function is protected from re-entrancy  \r\n  @param _lp_addr  address to liquidity pool token to be added to verified list  \r\n  '''\r\n  assert msg.sender == self.owner, 'You are not allowed here.' # dev: only owner\r\n  self.lp_tokens[_lp_addr] = True\r\n  return True\r\n\r\n@external\r\ndef remove_lp_token(_lp_addr: address) -> bool:\r\n  '''\r\n  @notice this function is protected from re-entrancy  \r\n  @param _lp_addr  address to liquidity pool token to be removed to verified list  \r\n  '''\r\n  assert msg.sender == self.owner, 'You are not allowed here.' # dev: only owner\r\n  self.lp_tokens[_lp_addr] = False\r\n  return False\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef stake(_lp_addr: address, _amount: uint256) -> bool:\r\n  '''\r\n  @notice Receives and hold verified Liquidity Pool Token from user, mints equivalent in Pipeline Token to stakeFor at geyser  \r\n  @param _lp_addr  address to liquidity pool token previously verified to be held at pipeline and have equivalent stakedFor at geyser  \r\n  @param _amount  the amount of tokens to be staked  \r\n  '''\r\n  assert self.lp_tokens[_lp_addr] == True, 'Token Not Verified by Admin' # dev: token not verified by admin\r\n  assert ERC20(_lp_addr).transferFrom(msg.sender, self, _amount)         # dev: transfer failed\r\n  assert TokenGeyser(self.geyser).getStakingToken() == self.pipeline_token    # dev: unmatched staking token failed\r\n  assert ERC20LP(self.pipeline_token).mint(self, _amount)                     # dev: mint failed\r\n  assert ERC20(self.pipeline_token).approve(self.geyser, _amount)             # dev: approve failed\r\n  assert self.has_staked[msg.sender] == False, 'Do not stake twice from the same address' # dev: user address tries to stake twice\r\n  TokenGeyser(self.geyser).stakeFor(msg.sender, _amount, 0x00)\r\n  _lp_balance: uint256 = self.lp_balances[_lp_addr][msg.sender]\r\n  assert _lp_balance + _amount != MAX_UINT256, 'Amount Overflow'         # dev: overflow\r\n  self.lp_balances[_lp_addr][msg.sender] = _lp_balance + _amount\r\n  self.has_staked[msg.sender] = True\r\n  log TokenStakedAtGeyser(_lp_addr, msg.sender, _amount)\r\n  return True\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef redeem(_lp_addr: address, _amount: uint256) -> bool:\r\n  '''\r\n  @notice Receives and burns Pipeline Token user sends back to receive their Liquidity Pool Token held  \r\n  @param _lp_addr  address to liquidity pool token to be returned to user  \r\n  @param _amount  the amount of tokens to be redeemed  \r\n  '''\r\n  assert ERC20(_lp_addr).transfer(msg.sender, _amount)                   # dev: lp token transfer failed\r\n  assert ERC20(self.pipeline_token).transferFrom(msg.sender, self, _amount)   # dev: pipeline token transfer failed\r\n  assert ERC20LP(self.pipeline_token).burnFrom(self, _amount)                 # dev: burn failed\r\n  _lp_balance: uint256 = self.lp_balances[_lp_addr][msg.sender]\r\n  assert _lp_balance != MAX_UINT256, 'Amount Overflow'                   # dev: overflow\r\n  _lp_balance = _lp_balance - _amount\r\n  assert _lp_balance >= 0, 'Token Amount Invalid'                        # dev: token amount cannot be below zero\r\n  self.lp_balances[_lp_addr][msg.sender] = _lp_balance\r\n  log TokenRedeemed(_lp_addr, msg.sender, _amount)\r\n  return True\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef renounce_geyser_ownership() -> bool:\r\n  '''\r\n  @notice this function is protected from re-entrancy  \r\n  '''\r\n  assert msg.sender == self.owner, 'You are not the Admin.' # dev: you are not the admin\r\n  Ownable(self.geyser).transferOwnership(self.owner)        # dev: ownership transfer failed\r\n  return True\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef rescue_funds(_lp_addr: address) -> bool:\r\n  assert msg.sender == self.owner, 'You are not the Admin.' # dev: you are not the admin\r\n  assert block.timestamp > self.recovery_timelock, 'Tokens can only be recovered after time-locked period.' # dev: tokens can be recovered after timelock\r\n  _amount: uint256 = ERC20(_lp_addr).balanceOf(self)\r\n  assert _amount > 0, 'Token not held by contract.'    # dev: token not held by contract\r\n  assert ERC20(_lp_addr).transfer(msg.sender, _amount) # dev: transfer failed\r\n  log TokenRecovery(_lp_addr, _amount)\r\n  return True", "ABI": "[{\"name\":\"LiquidityPoolTokenAdded\",\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LiquidityPoolTokenRemoved\",\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenStakedAtGeyser\",\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_staked_for\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenRedeemed\",\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_staked_for\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"TokenRecovery\",\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_amount\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_plt_addr\"},{\"type\":\"address\",\"name\":\"_geyser_addr\"},{\"type\":\"uint256\",\"name\":\"_timelock\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"add_lp_token\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":36404},{\"name\":\"remove_lp_token\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":21434},{\"name\":\"stake\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":164127},{\"name\":\"redeem\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\"},{\"type\":\"uint256\",\"name\":\"_amount\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":119823},{\"name\":\"renounce_geyser_ownership\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":81253},{\"name\":\"rescue_funds\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_lp_addr\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":81314},{\"name\":\"lp_tokens\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1456},{\"name\":\"lp_balances\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"},{\"type\":\"address\",\"name\":\"arg1\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1701},{\"name\":\"has_staked\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1516},{\"name\":\"owner\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1331},{\"name\":\"pipeline_token\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1361},{\"name\":\"geyser\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1391},{\"name\":\"recovery_timelock\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1421}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.2.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000009d64ba027734d2ca68705de0a5eb495f0af4860400000000000000000000000050f1db33d52d8a44affa893952d7c93be495c3de000000000000000000000000000000000000000000000000000000000076a700", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}