{"SourceCode": "// File: @redstone-finance/evm-connector/contracts/libs/SignatureLib.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary SignatureLib {\r\n  uint256 constant ECDSA_SIG_R_BS = 32;\r\n  uint256 constant ECDSA_SIG_S_BS = 32;\r\n\r\n  function recoverSignerAddress(bytes32 signedHash, uint256 signatureCalldataNegativeOffset)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    assembly {\r\n      let signatureCalldataStartPos := sub(calldatasize(), signatureCalldataNegativeOffset)\r\n      r := calldataload(signatureCalldataStartPos)\r\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_R_BS)\r\n      s := calldataload(signatureCalldataStartPos)\r\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_S_BS)\r\n      v := byte(0, calldataload(signatureCalldataStartPos)) // last byte of the signature memory array\r\n    }\r\n    return ecrecover(signedHash, v, r, s);\r\n  }\r\n}\r\n\r\n// File: @redstone-finance/evm-connector/contracts/libs/BitmapLib.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary BitmapLib {\r\n  function setBitInBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (uint256) {\r\n    return bitmap | (1 << bitIndex);\r\n  }\r\n\r\n  function getBitFromBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (bool) {\r\n    uint256 bitAtIndex = bitmap & (1 << bitIndex);\r\n    return bitAtIndex > 0;\r\n  }\r\n}\r\n\r\n// File: @redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @title The base contract with helpful constants\r\n * @author The Redstone Oracles team\r\n * @dev It mainly contains redstone-related values, which improve readability\r\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\r\n */\r\ncontract RedstoneConstants {\r\n  // === Abbreviations ===\r\n  // BS - Bytes size\r\n  // PTR - Pointer (memory location)\r\n  // SIG - Signature\r\n\r\n  // Solidity and YUL constants\r\n  uint256 internal constant STANDARD_SLOT_BS = 32;\r\n  uint256 internal constant FREE_MEMORY_PTR = 0x40;\r\n  uint256 internal constant BYTES_ARR_LEN_VAR_BS = 32;\r\n  uint256 internal constant FUNCTION_SIGNATURE_BS = 4;\r\n  uint256 internal constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\r\n  uint256 internal constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\r\n\r\n  // RedStone protocol consts\r\n  uint256 internal constant SIG_BS = 65;\r\n  uint256 internal constant TIMESTAMP_BS = 6;\r\n  uint256 internal constant DATA_PACKAGES_COUNT_BS = 2;\r\n  uint256 internal constant DATA_POINTS_COUNT_BS = 3;\r\n  uint256 internal constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\r\n  uint256 internal constant DATA_POINT_SYMBOL_BS = 32;\r\n  uint256 internal constant DEFAULT_DATA_POINT_VALUE_BS = 32;\r\n  uint256 internal constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\r\n  uint256 internal constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\r\n  uint256 internal constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\r\n\r\n  // Derived values (based on consts)\r\n  uint256 internal constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\r\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\r\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\r\n  uint256 internal constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\r\n\r\n  // Error messages\r\n  error CalldataOverOrUnderFlow();\r\n  error IncorrectUnsignedMetadataSize();\r\n  error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\r\n  error EachSignerMustProvideTheSameValue();\r\n  error EmptyCalldataPointersArr();\r\n  error InvalidCalldataPointer();\r\n  error CalldataMustHaveValidPayload();\r\n  error SignerNotAuthorised(address receivedSigner);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @redstone-finance/evm-connector/contracts/core/CalldataExtractor.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n/**\r\n * @title The base contract with the main logic of data extraction from calldata\r\n * @author The Redstone Oracles team\r\n * @dev This contract was created to reuse the same logic in the RedstoneConsumerBase\r\n * and the ProxyConnector contracts\r\n */\r\ncontract CalldataExtractor is RedstoneConstants {\r\n  using SafeMath for uint256;\r\n\r\n  function _extractByteSizeOfUnsignedMetadata() internal pure returns (uint256) {\r\n    // Checking if the calldata ends with the RedStone marker\r\n    bool hasValidRedstoneMarker;\r\n    assembly {\r\n      let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\r\n      hasValidRedstoneMarker := eq(\r\n        REDSTONE_MARKER_MASK,\r\n        and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\r\n      )\r\n    }\r\n    if (!hasValidRedstoneMarker) {\r\n      revert CalldataMustHaveValidPayload();\r\n    }\r\n\r\n    // Using uint24, because unsigned metadata byte size number has 3 bytes\r\n    uint24 unsignedMetadataByteSize;\r\n    if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\r\n      revert CalldataOverOrUnderFlow();\r\n    }\r\n    assembly {\r\n      unsignedMetadataByteSize := calldataload(\r\n        sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS)\r\n      )\r\n    }\r\n    uint256 calldataNegativeOffset = unsignedMetadataByteSize\r\n      + UNSIGNED_METADATA_BYTE_SIZE_BS\r\n      + REDSTONE_MARKER_BS;\r\n    if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\r\n      revert IncorrectUnsignedMetadataSize();\r\n    }\r\n    return calldataNegativeOffset;\r\n  }\r\n\r\n  // We return uint16, because unsigned metadata byte size number has 2 bytes\r\n  function _extractDataPackagesCountFromCalldata(uint256 calldataNegativeOffset)\r\n    internal\r\n    pure\r\n    returns (uint16 dataPackagesCount)\r\n  {\r\n    uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\r\n    if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\r\n      revert CalldataOverOrUnderFlow();\r\n    }\r\n    assembly {\r\n      dataPackagesCount := calldataload(\r\n        sub(calldatasize(), calldataNegativeOffsetWithStandardSlot)\r\n      )\r\n    }\r\n    return dataPackagesCount;\r\n  }\r\n\r\n  function _extractDataPointValueAndDataFeedId(\r\n    uint256 calldataNegativeOffsetForDataPackage,\r\n    uint256 defaultDataPointValueByteSize,\r\n    uint256 dataPointIndex\r\n  ) internal pure virtual returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\r\n    uint256 negativeOffsetToDataPoints = calldataNegativeOffsetForDataPackage + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\r\n    uint256 dataPointNegativeOffset = negativeOffsetToDataPoints.add(\r\n      (1 + dataPointIndex).mul((defaultDataPointValueByteSize + DATA_POINT_SYMBOL_BS))\r\n    );\r\n    uint256 dataPointCalldataOffset = msg.data.length.sub(dataPointNegativeOffset);\r\n    assembly {\r\n      dataPointDataFeedId := calldataload(dataPointCalldataOffset)\r\n      dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\r\n    }\r\n  }\r\n\r\n  function _extractDataPointsDetailsForDataPackage(uint256 calldataNegativeOffsetForDataPackage)\r\n    internal\r\n    pure\r\n    returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize)\r\n  {\r\n    // Using uint24, because data points count byte size number has 3 bytes\r\n    uint24 dataPointsCount_;\r\n\r\n    // Using uint32, because data point value byte size has 4 bytes\r\n    uint32 eachDataPointValueByteSize_;\r\n\r\n    // Extract data points count\r\n    uint256 negativeCalldataOffset = calldataNegativeOffsetForDataPackage + SIG_BS;\r\n    uint256 calldataOffset = msg.data.length.sub(negativeCalldataOffset + STANDARD_SLOT_BS);\r\n    assembly {\r\n      dataPointsCount_ := calldataload(calldataOffset)\r\n    }\r\n\r\n    // Extract each data point value size\r\n    calldataOffset = calldataOffset.sub(DATA_POINTS_COUNT_BS);\r\n    assembly {\r\n      eachDataPointValueByteSize_ := calldataload(calldataOffset)\r\n    }\r\n\r\n    // Prepare returned values\r\n    dataPointsCount = dataPointsCount_;\r\n    eachDataPointValueByteSize = eachDataPointValueByteSize_;\r\n  }\r\n}\r\n\r\n// File: @redstone-finance/evm-connector/contracts/libs/NumericArrayLib.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\nlibrary NumericArrayLib {\r\n  // This function sort array in memory using bubble sort algorithm,\r\n  // which performs even better than quick sort for small arrays\r\n\r\n  uint256 constant BYTES_ARR_LEN_VAR_BS = 32;\r\n  uint256 constant UINT256_VALUE_BS = 32;\r\n\r\n  error CanNotPickMedianOfEmptyArray();\r\n\r\n  // This function modifies the array\r\n  function pickMedian(uint256[] memory arr) internal pure returns (uint256) {\r\n    if (arr.length == 0) {\r\n      revert CanNotPickMedianOfEmptyArray();\r\n    }\r\n    sort(arr);\r\n    uint256 middleIndex = arr.length / 2;\r\n    if (arr.length % 2 == 0) {\r\n      uint256 sum = SafeMath.add(arr[middleIndex - 1], arr[middleIndex]);\r\n      return sum / 2;\r\n    } else {\r\n      return arr[middleIndex];\r\n    }\r\n  }\r\n\r\n  function sort(uint256[] memory arr) internal pure {\r\n    assembly {\r\n      let arrLength := mload(arr)\r\n      let valuesPtr := add(arr, BYTES_ARR_LEN_VAR_BS)\r\n      let endPtr := add(valuesPtr, mul(arrLength, UINT256_VALUE_BS))\r\n      for {\r\n        let arrIPtr := valuesPtr\r\n      } lt(arrIPtr, endPtr) {\r\n        arrIPtr := add(arrIPtr, UINT256_VALUE_BS) // arrIPtr += 32\r\n      } {\r\n        for {\r\n          let arrJPtr := valuesPtr\r\n        } lt(arrJPtr, arrIPtr) {\r\n          arrJPtr := add(arrJPtr, UINT256_VALUE_BS) // arrJPtr += 32\r\n        } {\r\n          let arrI := mload(arrIPtr)\r\n          let arrJ := mload(arrJPtr)\r\n          if lt(arrI, arrJ) {\r\n            mstore(arrIPtr, arrJ)\r\n            mstore(arrJPtr, arrI)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File: @redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n/**\r\n * @title Default implementations of virtual redstone consumer base functions\r\n * @author The Redstone Oracles team\r\n */\r\nlibrary RedstoneDefaultsLib {\r\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 3 minutes;\r\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 1 minutes;\r\n\r\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\r\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\r\n\r\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\r\n    // Getting data timestamp from future seems quite unlikely\r\n    // But we've already spent too much time with different cases\r\n    // Where block.timestamp was less than dataPackage.timestamp.\r\n    // Some blockchains may case this problem as well.\r\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\r\n    // and allow data \"from future\" but with a small delay\r\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\r\n\r\n    if (block.timestamp < receivedTimestampSeconds) {\r\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\r\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\r\n      }\r\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\r\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\r\n    }\r\n  }\r\n\r\n  function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\r\n    return NumericArrayLib.pickMedian(values);\r\n  }\r\n}\r\n\r\n// File: @redstone-finance/evm-connector/contracts/core/RedstoneConsumerBase.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The base contract with the main Redstone logic\r\n * @author The Redstone Oracles team\r\n * @dev Do not use this contract directly in consumer contracts, take a\r\n * look at `RedstoneConsumerNumericBase` and `RedstoneConsumerBytesBase` instead\r\n */\r\nabstract contract RedstoneConsumerBase is CalldataExtractor {\r\n  using SafeMath for uint256;\r\n\r\n  /* ========== VIRTUAL FUNCTIONS (MAY BE OVERRIDDEN IN CHILD CONTRACTS) ========== */\r\n\r\n  /**\r\n   * @dev This function must be implemented by the child consumer contract.\r\n   * It should return a unique index for a given signer address if the signer\r\n   * is authorised, otherwise it should revert\r\n   * @param receivedSigner The address of a signer, recovered from ECDSA signature\r\n   * @return Unique index for a signer in the range [0..255]\r\n   */\r\n  function getAuthorisedSignerIndex(address receivedSigner) public view virtual returns (uint8);\r\n\r\n  /**\r\n   * @dev This function may be overridden by the child consumer contract.\r\n   * It should validate the timestamp against the current time (block.timestamp)\r\n   * It should revert with a helpful message if the timestamp is not valid\r\n   * @param receivedTimestampMilliseconds Timestamp extracted from calldata\r\n   */\r\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual {\r\n    RedstoneDefaultsLib.validateTimestamp(receivedTimestampMilliseconds);\r\n  }\r\n\r\n  /**\r\n   * @dev This function should be overridden by the child consumer contract.\r\n   * @return The minimum required value of unique authorised signers\r\n   */\r\n  function getUniqueSignersThreshold() public view virtual returns (uint8) {\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n   * @dev This function may be overridden by the child consumer contract.\r\n   * It should aggregate values from different signers to a single uint value.\r\n   * By default, it calculates the median value\r\n   * @param values An array of uint256 values from different signers\r\n   * @return Result of the aggregation in the form of a single number\r\n   */\r\n  function aggregateValues(uint256[] memory values) public view virtual returns (uint256) {\r\n    return RedstoneDefaultsLib.aggregateValues(values);\r\n  }\r\n\r\n  /* ========== FUNCTIONS WITH IMPLEMENTATION (CAN NOT BE OVERRIDDEN) ========== */\r\n\r\n  /**\r\n   * @dev This is an internal helpful function for secure extraction oracle values\r\n   * from the tx calldata. Security is achieved by signatures verification, timestamp\r\n   * validation, and aggregating values from different authorised signers into a\r\n   * single numeric value. If any of the required conditions (e.g. too old timestamp or\r\n   * insufficient number of authorised signers) do not match, the function will revert.\r\n   *\r\n   * Note! You should not call this function in a consumer contract. You can use\r\n   * `getOracleNumericValuesFromTxMsg` or `getOracleNumericValueFromTxMsg` instead.\r\n   *\r\n   * @param dataFeedIds An array of unique data feed identifiers\r\n   * @return An array of the extracted and verified oracle values in the same order\r\n   * as they are requested in dataFeedIds array\r\n   */\r\n  function _securelyExtractOracleValuesFromTxMsg(bytes32[] memory dataFeedIds)\r\n    internal\r\n    view\r\n    returns (uint256[] memory)\r\n  {\r\n    // Initializing helpful variables and allocating memory\r\n    uint256[] memory uniqueSignerCountForDataFeedIds = new uint256[](dataFeedIds.length);\r\n    uint256[] memory signersBitmapForDataFeedIds = new uint256[](dataFeedIds.length);\r\n    uint256[][] memory valuesForDataFeeds = new uint256[][](dataFeedIds.length);\r\n    for (uint256 i = 0; i < dataFeedIds.length; i++) {\r\n      // The line below is commented because newly allocated arrays are filled with zeros\r\n      // But we left it for better readability\r\n      // signersBitmapForDataFeedIds[i] = 0; // <- setting to an empty bitmap\r\n      valuesForDataFeeds[i] = new uint256[](getUniqueSignersThreshold());\r\n    }\r\n\r\n    // Extracting the number of data packages from calldata\r\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\r\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\r\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\r\n\r\n    // Saving current free memory pointer\r\n    uint256 freeMemPtr;\r\n    assembly {\r\n      freeMemPtr := mload(FREE_MEMORY_PTR)\r\n    }\r\n\r\n    // Data packages extraction in a loop\r\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\r\n      // Extract data package details and update calldata offset\r\n      uint256 dataPackageByteSize = _extractDataPackage(\r\n        dataFeedIds,\r\n        uniqueSignerCountForDataFeedIds,\r\n        signersBitmapForDataFeedIds,\r\n        valuesForDataFeeds,\r\n        calldataNegativeOffset\r\n      );\r\n      calldataNegativeOffset += dataPackageByteSize;\r\n\r\n      // Shifting memory pointer back to the \"safe\" value\r\n      assembly {\r\n        mstore(FREE_MEMORY_PTR, freeMemPtr)\r\n      }\r\n    }\r\n\r\n    // Validating numbers of unique signers and calculating aggregated values for each dataFeedId\r\n    return _getAggregatedValues(valuesForDataFeeds, uniqueSignerCountForDataFeedIds);\r\n  }\r\n\r\n  /**\r\n   * @dev This is a private helpful function, which extracts data for a data package based\r\n   * on the given negative calldata offset, verifies them, and in the case of successful\r\n   * verification updates the corresponding data package values in memory\r\n   *\r\n   * @param dataFeedIds an array of unique data feed identifiers\r\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\r\n   * for each data feed\r\n   * @param signersBitmapForDataFeedIds an array of signer bitmaps for data feeds\r\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\r\n   * j-th value for the i-th data feed\r\n   * @param calldataNegativeOffset negative calldata offset for the given data package\r\n   *\r\n   * @return An array of the aggregated values\r\n   */\r\n  function _extractDataPackage(\r\n    bytes32[] memory dataFeedIds,\r\n    uint256[] memory uniqueSignerCountForDataFeedIds,\r\n    uint256[] memory signersBitmapForDataFeedIds,\r\n    uint256[][] memory valuesForDataFeeds,\r\n    uint256 calldataNegativeOffset\r\n  ) private view returns (uint256) {\r\n    uint256 signerIndex;\r\n\r\n    (\r\n      uint256 dataPointsCount,\r\n      uint256 eachDataPointValueByteSize\r\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\r\n\r\n    // We use scopes to resolve problem with too deep stack\r\n    {\r\n      uint48 extractedTimestamp;\r\n      address signerAddress;\r\n      bytes32 signedHash;\r\n      bytes memory signedMessage;\r\n      uint256 signedMessageBytesCount;\r\n\r\n      signedMessageBytesCount = dataPointsCount.mul(eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS)\r\n        + DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS; //DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\r\n\r\n      uint256 timestampCalldataOffset = msg.data.length.sub(\r\n        calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\r\n\r\n      uint256 signedMessageCalldataOffset = msg.data.length.sub(\r\n        calldataNegativeOffset + SIG_BS + signedMessageBytesCount);\r\n\r\n      assembly {\r\n        // Extracting the signed message\r\n        signedMessage := extractBytesFromCalldata(\r\n          signedMessageCalldataOffset,\r\n          signedMessageBytesCount\r\n        )\r\n\r\n        // Hashing the signed message\r\n        signedHash := keccak256(add(signedMessage, BYTES_ARR_LEN_VAR_BS), signedMessageBytesCount)\r\n\r\n        // Extracting timestamp\r\n        extractedTimestamp := calldataload(timestampCalldataOffset)\r\n\r\n        function initByteArray(bytesCount) -> ptr {\r\n          ptr := mload(FREE_MEMORY_PTR)\r\n          mstore(ptr, bytesCount)\r\n          ptr := add(ptr, BYTES_ARR_LEN_VAR_BS)\r\n          mstore(FREE_MEMORY_PTR, add(ptr, bytesCount))\r\n        }\r\n\r\n        function extractBytesFromCalldata(offset, bytesCount) -> extractedBytes {\r\n          let extractedBytesStartPtr := initByteArray(bytesCount)\r\n          calldatacopy(\r\n            extractedBytesStartPtr,\r\n            offset,\r\n            bytesCount\r\n          )\r\n          extractedBytes := sub(extractedBytesStartPtr, BYTES_ARR_LEN_VAR_BS)\r\n        }\r\n      }\r\n\r\n      // Validating timestamp\r\n      validateTimestamp(extractedTimestamp);\r\n\r\n      // Verifying the off-chain signature against on-chain hashed data\r\n      signerAddress = SignatureLib.recoverSignerAddress(\r\n        signedHash,\r\n        calldataNegativeOffset + SIG_BS\r\n      );\r\n      signerIndex = getAuthorisedSignerIndex(signerAddress);\r\n    }\r\n\r\n    // Updating helpful arrays\r\n    {\r\n      bytes32 dataPointDataFeedId;\r\n      uint256 dataPointValue;\r\n      for (uint256 dataPointIndex = 0; dataPointIndex < dataPointsCount; dataPointIndex++) {\r\n        // Extracting data feed id and value for the current data point\r\n        (dataPointDataFeedId, dataPointValue) = _extractDataPointValueAndDataFeedId(\r\n          calldataNegativeOffset,\r\n          eachDataPointValueByteSize,\r\n          dataPointIndex\r\n        );\r\n\r\n        for (\r\n          uint256 dataFeedIdIndex = 0;\r\n          dataFeedIdIndex < dataFeedIds.length;\r\n          dataFeedIdIndex++\r\n        ) {\r\n          if (dataPointDataFeedId == dataFeedIds[dataFeedIdIndex]) {\r\n            uint256 bitmapSignersForDataFeedId = signersBitmapForDataFeedIds[dataFeedIdIndex];\r\n\r\n            if (\r\n              !BitmapLib.getBitFromBitmap(bitmapSignersForDataFeedId, signerIndex) && /* current signer was not counted for current dataFeedId */\r\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex] < getUniqueSignersThreshold()\r\n            ) {\r\n              // Increase unique signer counter\r\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex]++;\r\n\r\n              // Add new value\r\n              valuesForDataFeeds[dataFeedIdIndex][\r\n                uniqueSignerCountForDataFeedIds[dataFeedIdIndex] - 1\r\n              ] = dataPointValue;\r\n\r\n              // Update signers bitmap\r\n              signersBitmapForDataFeedIds[dataFeedIdIndex] = BitmapLib.setBitInBitmap(\r\n                bitmapSignersForDataFeedId,\r\n                signerIndex\r\n              );\r\n            }\r\n\r\n            // Breaking, as there couldn't be several indexes for the same feed ID\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Return total data package byte size\r\n    return\r\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS +\r\n      (eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS) *\r\n      dataPointsCount;\r\n  }\r\n\r\n  /**\r\n   * @dev This is a private helpful function, which aggregates values from different\r\n   * authorised signers for the given arrays of values for each data feed\r\n   *\r\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\r\n   * j-th value for the i-th data feed\r\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\r\n   * for each data feed\r\n   *\r\n   * @return An array of the aggregated values\r\n   */\r\n  function _getAggregatedValues(\r\n    uint256[][] memory valuesForDataFeeds,\r\n    uint256[] memory uniqueSignerCountForDataFeedIds\r\n  ) private view returns (uint256[] memory) {\r\n    uint256[] memory aggregatedValues = new uint256[](valuesForDataFeeds.length);\r\n    uint256 uniqueSignersThreshold = getUniqueSignersThreshold();\r\n\r\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < valuesForDataFeeds.length; dataFeedIndex++) {\r\n      if (uniqueSignerCountForDataFeedIds[dataFeedIndex] < uniqueSignersThreshold) {\r\n        revert InsufficientNumberOfUniqueSigners(\r\n          uniqueSignerCountForDataFeedIds[dataFeedIndex],\r\n          uniqueSignersThreshold);\r\n      }\r\n      uint256 aggregatedValueForDataFeedId = aggregateValues(valuesForDataFeeds[dataFeedIndex]);\r\n      aggregatedValues[dataFeedIndex] = aggregatedValueForDataFeedId;\r\n    }\r\n\r\n    return aggregatedValues;\r\n  }\r\n}\r\n\r\n// File: @redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n/**\r\n * @title The base contract for Redstone consumers' contracts that allows to\r\n * securely calculate numeric redstone oracle values\r\n * @author The Redstone Oracles team\r\n * @dev This contract can extend other contracts to allow them\r\n * securely fetch Redstone oracle data from transactions calldata\r\n */\r\nabstract contract RedstoneConsumerNumericBase is RedstoneConsumerBase {\r\n  /**\r\n   * @dev This function can be used in a consumer contract to securely extract an\r\n   * oracle value for a given data feed id. Security is achieved by\r\n   * signatures verification, timestamp validation, and aggregating values\r\n   * from different authorised signers into a single numeric value. If any of the\r\n   * required conditions do not match, the function will revert.\r\n   * Note! This function expects that tx calldata contains redstone payload in the end\r\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\r\n   * @param dataFeedId bytes32 value that uniquely identifies the data feed\r\n   * @return Extracted and verified numeric oracle value for the given data feed id\r\n   */\r\n  function getOracleNumericValueFromTxMsg(bytes32 dataFeedId)\r\n    internal\r\n    view\r\n    virtual\r\n    returns (uint256)\r\n  {\r\n    bytes32[] memory dataFeedIds = new bytes32[](1);\r\n    dataFeedIds[0] = dataFeedId;\r\n    return getOracleNumericValuesFromTxMsg(dataFeedIds)[0];\r\n  }\r\n\r\n  /**\r\n   * @dev This function can be used in a consumer contract to securely extract several\r\n   * numeric oracle values for a given array of data feed ids. Security is achieved by\r\n   * signatures verification, timestamp validation, and aggregating values\r\n   * from different authorised signers into a single numeric value. If any of the\r\n   * required conditions do not match, the function will revert.\r\n   * Note! This function expects that tx calldata contains redstone payload in the end\r\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\r\n   * @param dataFeedIds An array of unique data feed identifiers\r\n   * @return An array of the extracted and verified oracle values in the same order\r\n   * as they are requested in the dataFeedIds array\r\n   */\r\n  function getOracleNumericValuesFromTxMsg(bytes32[] memory dataFeedIds)\r\n    internal\r\n    view\r\n    virtual\r\n    returns (uint256[] memory)\r\n  {\r\n    return _securelyExtractOracleValuesFromTxMsg(dataFeedIds);\r\n  }\r\n\r\n  /**\r\n   * @dev This function works similarly to the `getOracleNumericValuesFromTxMsg` with the\r\n   * only difference that it allows to request oracle data for an array of data feeds\r\n   * that may contain duplicates\r\n   * \r\n   * @param dataFeedIdsWithDuplicates An array of data feed identifiers (duplicates are allowed)\r\n   * @return An array of the extracted and verified oracle values in the same order\r\n   * as they are requested in the dataFeedIdsWithDuplicates array\r\n   */\r\n  function getOracleNumericValuesWithDuplicatesFromTxMsg(bytes32[] memory dataFeedIdsWithDuplicates) internal view returns (uint256[] memory) {\r\n    // Building an array without duplicates\r\n    bytes32[] memory dataFeedIdsWithoutDuplicates = new bytes32[](dataFeedIdsWithDuplicates.length);\r\n    bool alreadyIncluded;\r\n    uint256 uniqueDataFeedIdsCount = 0;\r\n\r\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\r\n      // Checking if current element is already included in `dataFeedIdsWithoutDuplicates`\r\n      alreadyIncluded = false;\r\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < uniqueDataFeedIdsCount; indexWithoutDup++) {\r\n        if (dataFeedIdsWithoutDuplicates[indexWithoutDup] == dataFeedIdsWithDuplicates[indexWithDup]) {\r\n          alreadyIncluded = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Adding if not included\r\n      if (!alreadyIncluded) {\r\n        dataFeedIdsWithoutDuplicates[uniqueDataFeedIdsCount] = dataFeedIdsWithDuplicates[indexWithDup];\r\n        uniqueDataFeedIdsCount++;\r\n      }\r\n    }\r\n\r\n    // Overriding dataFeedIdsWithoutDuplicates.length\r\n    // Equivalent to: dataFeedIdsWithoutDuplicates.length = uniqueDataFeedIdsCount;\r\n    assembly {\r\n      mstore(dataFeedIdsWithoutDuplicates, uniqueDataFeedIdsCount)\r\n    }\r\n\r\n    // Requesting oracle values (without duplicates)\r\n    uint256[] memory valuesWithoutDuplicates = getOracleNumericValuesFromTxMsg(dataFeedIdsWithoutDuplicates);\r\n\r\n    // Preparing result values array\r\n    uint256[] memory valuesWithDuplicates = new uint256[](dataFeedIdsWithDuplicates.length);\r\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\r\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < dataFeedIdsWithoutDuplicates.length; indexWithoutDup++) {\r\n        if (dataFeedIdsWithDuplicates[indexWithDup] == dataFeedIdsWithoutDuplicates[indexWithoutDup]) {\r\n          valuesWithDuplicates[indexWithDup] = valuesWithoutDuplicates[indexWithoutDup];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return valuesWithDuplicates;\r\n  }\r\n}\r\n\r\n// File: @redstone-finance/evm-connector/contracts/data-services/RapidDemoConsumerBase.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\ncontract RapidDemoConsumerBase is RedstoneConsumerNumericBase {\r\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\r\n    return 1;\r\n  }\r\n\r\n  function getAuthorisedSignerIndex(address signerAddress)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint8)\r\n  {\r\n    if (signerAddress == 0xf786a909D559F5Dee2dc6706d8e5A81728a39aE9) {\r\n      return 0;\r\n    } else {\r\n      revert SignerNotAuthorised(signerAddress);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/NewExample.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\ncontract ExampleRedstoneShowroom is RapidDemoConsumerBase {\r\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 60 minutes;\r\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 5 minutes;\r\n\r\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\r\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\r\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) public view override {\r\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\r\n\r\n    if (block.timestamp < receivedTimestampSeconds) {\r\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\r\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\r\n      }\r\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\r\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\r\n    }\r\n  }\r\n\r\n  function getPrices() public view returns(uint256[] memory) {\r\n    bytes32[] memory dataFeedIds = new bytes32[](6);\r\n    dataFeedIds[0] = bytes32(\"BTC\");\r\n    dataFeedIds[1] = bytes32(\"ETH\");\r\n    dataFeedIds[2] = bytes32(\"BNB\");\r\n    dataFeedIds[3] = bytes32(\"AR\");\r\n    dataFeedIds[4] = bytes32(\"AVAX\");\r\n    dataFeedIds[5] = bytes32(\"CELO\");\r\n    return getOracleNumericValuesFromTxMsg(dataFeedIds);\r\n  }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"CalldataMustHaveValidPayload\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CalldataOverOrUnderFlow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CanNotPickMedianOfEmptyArray\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EachSignerMustProvideTheSameValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmptyCalldataPointersArr\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectUnsignedMetadataSize\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"receivedSignersCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredSignersCount\",\"type\":\"uint256\"}],\"name\":\"InsufficientNumberOfUniqueSigners\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCalldataPointer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receivedSigner\",\"type\":\"address\"}],\"name\":\"SignerNotAuthorised\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"receivedTimestampSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"TimestampFromTooLongFuture\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"receivedTimestampSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"TimestampIsTooOld\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"aggregateValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"getAuthorisedSignerIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUniqueSignersThreshold\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"receivedTimestampMilliseconds\",\"type\":\"uint256\"}],\"name\":\"validateTimestamp\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ExampleRedstoneShowroom", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ea32add6293fa9b904e5cbf09585847cec751c9439b548accc950e825c73ab17"}