{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LiquidityGauge.sol\": {\r\n      \"content\": \"pragma solidity 0.8.10;\\n\\n/***\\n *@title Liquidity Gauge\\n *@author InsureDAO\\n * SPDX-License-Identifier: MIT\\n *@notice Used for measuring liquidity and insurance\\n */\\n\\n//dao-contracts\\nimport \\\"./interfaces/dao/IGaugeController.sol\\\";\\nimport \\\"./interfaces/dao/IInsureToken.sol\\\";\\nimport \\\"./interfaces/dao/IMinter.sol\\\";\\nimport \\\"./interfaces/dao/IVotingEscrow.sol\\\";\\n\\nimport \\\"./interfaces/pool/IOwnership.sol\\\";\\n\\n//libraries\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\ncontract LiquidityGauge is ReentrancyGuard {\\n    event Deposit(address indexed provider, uint256 value);\\n    event Withdraw(address indexed provider, uint256 value);\\n    event UpdateLiquidityLimit(\\n        address user,\\n        uint256 original_balance,\\n        uint256 original_supply,\\n        uint256 working_balance,\\n        uint256 working_supply,\\n        uint256 voting_balance,\\n        uint256 voting_total\\n    );\\n\\n    uint256 constant TOKENLESS_PRODUCTION = 40;\\n    uint256 constant BOOST_WARMUP = 86400 * 14;\\n    uint256 constant WEEK = 604800;\\n\\n    //Contracts\\n    IMinter public minter;\\n    IInsureToken public insure_token;\\n    IERC20 public template;\\n    IGaugeController public controller;\\n    IVotingEscrow public voting_escrow;\\n\\n    mapping(address => uint256) public balanceOf;\\n    uint256 public totalSupply;\\n    uint256 public future_epoch_time;\\n\\n    // caller -> recipient -> can deposit?\\n    mapping(address => mapping(address => bool)) public approved_to_deposit;\\n\\n    mapping(address => uint256) public working_balances;\\n    uint256 public working_supply;\\n\\n    // The goal is to be able to calculate \u222b(rate * balance / totalSupply dt) from 0 till checkpoint\\n    // All values are kept in units of being multiplied by 1e18\\n    uint256 public period; //modified from \\\"int256 public period\\\" since it never be minus.\\n\\n    uint256[100000000000000000000000000000] public period_timestamp;\\n\\n    // 1e18 * \u222b(rate(t) / totalSupply(t) dt) from 0 till checkpoint\\n    uint256[100000000000000000000000000000] public integrate_inv_supply; // bump epoch when rate() changes. Iis(t)=int(r'(t)/S(t))dt (from CurveDAO whitepaper)\\n\\n    // 1e18 * \u222b(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\\n    mapping(address => uint256) public integrate_inv_supply_of;\\n    mapping(address => uint256) public integrate_checkpoint_of;\\n\\n    // \u222b(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\\n    // Units rate * t = already number of coins per address to issue\\n    mapping(address => uint256) public integrate_fraction; //Mintable Token amount (include minted amount)\\n\\n    uint256 public inflation_rate;\\n    bool public is_killed;\\n\\n    IOwnership public immutable ownership;\\n\\n    modifier onlyOwner() {\\n        require(\\n            ownership.owner() == msg.sender,\\n            \\\"Caller is not allowed to operate\\\"\\n        );\\n        _;\\n    }\\n\\n    /***\\n     *@notice Contract constructor\\n     *@param _lp_addr Liquidity Pool contract address\\n     *@param _minter Minter contract address\\n     *@param _admin Admin who can kill the gauge\\n     */\\n    constructor(\\n        address _lp_addr,\\n        address _minter,\\n        address _ownership\\n    ) {\\n        require(_lp_addr != address(0));\\n        require(_minter != address(0));\\n\\n        template = IERC20(_lp_addr);\\n        minter = IMinter(_minter);\\n        address _insure_addr = minter.insure_token();\\n        insure_token = IInsureToken(_insure_addr);\\n        controller = IGaugeController(minter.gauge_controller());\\n        voting_escrow = IVotingEscrow(controller.get_voting_escrow());\\n        period_timestamp[0] = block.timestamp;\\n        inflation_rate = insure_token.rate();\\n        future_epoch_time = insure_token.future_epoch_time_write();\\n        ownership = IOwnership(_ownership);\\n    }\\n\\n    /***\\n     *@notice Calculate limits which depend on the amount of INSURE Token per-user.\\n     *        Effectively it calculates working balances to apply amplification\\n     *        of INSURE production by INSURE\\n     *@param _addr User address\\n     *@param _l User's amount of liquidity (LP tokens)\\n     *@param _L Total amount of liquidity (LP tokens)\\n     */\\n    function _update_liquidity_limit(\\n        address _addr,\\n        uint256 _l,\\n        uint256 _L\\n    ) internal {\\n        // To be called after totalSupply is updated\\n        uint256 _voting_balance = voting_escrow.balanceOf(\\n            _addr,\\n            block.timestamp\\n        );\\n        uint256 _voting_total = voting_escrow.totalSupply(block.timestamp);\\n\\n        uint256 _lim = (_l * TOKENLESS_PRODUCTION) / 100;\\n        if (\\n            (_voting_total > 0) &&\\n            (block.timestamp > period_timestamp[0] + BOOST_WARMUP)\\n        ) {\\n            _lim +=\\n                (_L * _voting_balance * (100 - TOKENLESS_PRODUCTION)) /\\n                _voting_total /\\n                100;\\n        }\\n\\n        _lim = min(_l, _lim);\\n        uint256 _old_bal = working_balances[_addr];\\n        working_balances[_addr] = _lim;\\n        uint256 _working_supply = working_supply + _lim - _old_bal;\\n        working_supply = _working_supply;\\n\\n        emit UpdateLiquidityLimit(\\n            _addr,\\n            _l,\\n            _L,\\n            _lim,\\n            _working_supply,\\n            _voting_balance,\\n            _voting_total\\n        );\\n    }\\n\\n    //to avoid \\\"stack too deep\\\"\\n    struct CheckPointParameters {\\n        uint256 period;\\n        uint256 period_time;\\n        uint256 integrate_inv_supply;\\n        uint256 rate;\\n        uint256 new_rate;\\n        uint256 prev_future_epoch;\\n        uint256 working_balance;\\n        uint256 working_supply;\\n    }\\n\\n    /***\\n     *@notice Checkpoint for a user\\n     *@param _addr User address\\n     *\\n     *This function does,\\n     *1. Calculate Iis for All: Calc and add Iis for every week. Iis only increses over time.\\n     *2. Calculate Iu for _addr: Calc by (defferece between Iis(last time) and Iis(this time))* LP deposit amount of _addr(include INSURE locking boost)\\n     *\\n     * working_supply & working_balance = total_supply & total_balance with INSURE locking boost\u3002\\n     * Check whitepaper about Iis and Iu.\\n     */\\n    function _checkpoint(address _addr) internal {\\n        CheckPointParameters memory _st;\\n\\n        _st.period = period;\\n        _st.period_time = period_timestamp[_st.period];\\n        _st.integrate_inv_supply = integrate_inv_supply[_st.period];\\n        _st.rate = inflation_rate;\\n        _st.new_rate = _st.rate;\\n        _st.prev_future_epoch = future_epoch_time;\\n        if (_st.prev_future_epoch >= _st.period_time) {\\n            //update future_epoch_time & inflation_rate\\n            future_epoch_time = insure_token.future_epoch_time_write();\\n            _st.new_rate = insure_token.rate();\\n            inflation_rate = _st.new_rate;\\n        }\\n        controller.checkpoint_gauge(address(this));\\n\\n        uint256 _working_balance = working_balances[_addr];\\n        uint256 _working_supply = working_supply;\\n\\n        if (is_killed) {\\n            _st.rate = 0; // Stop distributing inflation as soon as killed\\n        }\\n\\n        // Update integral of 1/supply\\n        if (block.timestamp > _st.period_time) {\\n            uint256 _prev_week_time = _st.period_time;\\n            uint256 _week_time;\\n            unchecked {\\n                _week_time = min(\\n                    ((_st.period_time + WEEK) / WEEK) * WEEK,\\n                    block.timestamp\\n                );\\n            }\\n\\n            for (uint256 i; i < 500;) {\\n                uint256 _dt = _week_time - _prev_week_time;\\n                uint256 _w = controller.gauge_relative_weight(\\n                    address(this),\\n                    (_prev_week_time / WEEK) * WEEK\\n                );\\n\\n                if (_working_supply > 0) {\\n                    if (\\n                        _st.prev_future_epoch >= _prev_week_time &&\\n                        _st.prev_future_epoch < _week_time\\n                    ) {\\n                        // If we went across one or multiple epochs, apply the rate\\n                        // of the first epoch until it ends, and then the rate of\\n                        // the last epoch.\\n                        // If more than one epoch is crossed - the gauge gets less,\\n                        // but that'd meen it wasn't called for more than 1 year\\n                        _st.integrate_inv_supply +=\\n                            (_st.rate *\\n                                _w *\\n                                (_st.prev_future_epoch - _prev_week_time)) /\\n                            _working_supply;\\n                        _st.rate = _st.new_rate;\\n                        _st.integrate_inv_supply +=\\n                            (_st.rate *\\n                                _w *\\n                                (_week_time - _st.prev_future_epoch)) /\\n                            _working_supply;\\n                    } else {\\n                        _st.integrate_inv_supply +=\\n                            (_st.rate * _w * _dt) /\\n                            _working_supply;\\n                    }\\n                    // On precisions of the calculation\\n                    // rate ~= 10e18\\n                    // last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\\n                    // _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\\n                    // The largest loss is at dt = 1\\n                    // Loss is 1e-9 - acceptable\\n                }\\n                if (_week_time == block.timestamp) {\\n                    break;\\n                }\\n                _prev_week_time = _week_time;\\n                _week_time = min(_week_time + WEEK, block.timestamp);\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        _st.period += 1;\\n        period = _st.period;\\n        period_timestamp[_st.period] = block.timestamp;\\n        integrate_inv_supply[_st.period] = _st.integrate_inv_supply;\\n\\n        // Update user-specific integrals\\n        // Calc the \u0394Iu of _addr and add it to Iu.\\n        integrate_fraction[_addr] +=\\n            (_working_balance *\\n                (_st.integrate_inv_supply - integrate_inv_supply_of[_addr])) /\\n            10 ** 18;\\n        integrate_inv_supply_of[_addr] = _st.integrate_inv_supply;\\n        integrate_checkpoint_of[_addr] = block.timestamp;\\n    }\\n\\n    /***\\n     *@notice Record a checkpoint for `_addr`\\n     *@param _addr User address\\n     *@return bool success\\n     */\\n    function user_checkpoint(address _addr) external returns(bool) {\\n        require(\\n            (msg.sender == _addr) || (msg.sender == address(minter)),\\n            \\\"dev: unauthorized\\\"\\n        );\\n        _checkpoint(_addr);\\n        _update_liquidity_limit(_addr, balanceOf[_addr], totalSupply);\\n        return true;\\n    }\\n\\n    /***\\n     *@notice Get the number of claimable tokens per user\\n     *@dev This function should be manually changed to \\\"view\\\" in the ABI\\n     *@return uint256 number of claimable tokens per user\\n     */\\n    function claimable_tokens(address _addr) external returns(uint256) {\\n        _checkpoint(_addr);\\n        return (integrate_fraction[_addr] -\\n            minter.minted(_addr, address(this)));\\n    }\\n\\n    /***\\n     *@notice Kick `_addr` for abusing their boost\\n     *@dev Only if either they had another voting event, or their voting escrow lock expired\\n     *@param _addr Address to kick\\n     */\\n    function kick(address _addr) external {\\n        uint256 _t_last = integrate_checkpoint_of[_addr];\\n        uint256 _t_ve = voting_escrow.user_point_history__ts(\\n            _addr,\\n            voting_escrow.get_user_point_epoch(_addr)\\n        );\\n        uint256 _balance = balanceOf[_addr];\\n\\n        require(\\n            voting_escrow.balanceOf(_addr, block.timestamp) == 0 ||\\n            _t_ve > _t_last,\\n            \\\"dev: kick not allowed\\\"\\n        );\\n        require(\\n            working_balances[_addr] > (_balance * TOKENLESS_PRODUCTION) / 100,\\n            \\\"dev: kick not needed\\\"\\n        );\\n\\n        _checkpoint(_addr);\\n        _update_liquidity_limit(_addr, balanceOf[_addr], totalSupply);\\n    }\\n\\n    /***\\n     *@notice Set whether `_addr` can deposit tokens for `msg.sender`\\n     *@param _addr Address to set approval on\\n     *@param can_deposit bool - can this account deposit for `msg.sender`?\\n     */\\n    function set_approve_deposit(address _addr, bool can_deposit) external {\\n        approved_to_deposit[_addr][msg.sender] = can_deposit;\\n    }\\n\\n    /***\\n     *@notice Deposit `_value` LP tokens\\n     *@param _value Number of tokens to deposit\\n     *@param _addr Address to deposit for\\n     */\\n    function deposit(uint256 _value, address _addr) external nonReentrant {\\n        if (_addr != msg.sender) {\\n            require(approved_to_deposit[msg.sender][_addr], \\\"Not approved\\\");\\n        }\\n\\n        _checkpoint(_addr);\\n\\n        if (_value != 0) {\\n            uint256 _balance = balanceOf[_addr] + _value;\\n            uint256 _supply = totalSupply + _value;\\n            balanceOf[_addr] = _balance;\\n            totalSupply = _supply;\\n\\n            _update_liquidity_limit(_addr, _balance, _supply);\\n\\n            require(template.transferFrom(msg.sender, address(this), _value));\\n        }\\n        emit Deposit(_addr, _value);\\n    }\\n\\n    /***\\n     *@notice Withdraw `_value` LP tokens\\n     *@param _value Number of tokens to withdraw\\n     */\\n    function withdraw(uint256 _value) external nonReentrant {\\n        _checkpoint(msg.sender);\\n\\n        uint256 _balance = balanceOf[msg.sender] - _value;\\n        uint256 _supply = totalSupply - _value;\\n        balanceOf[msg.sender] = _balance;\\n        totalSupply = _supply;\\n\\n        _update_liquidity_limit(msg.sender, _balance, _supply);\\n\\n        require(template.transfer(msg.sender, _value));\\n\\n        emit Withdraw(msg.sender, _value);\\n    }\\n\\n    function integrate_checkpoint() external view returns(uint256) {\\n        return period_timestamp[period];\\n    }\\n\\n    function kill_me() external onlyOwner {\\n        is_killed = !is_killed;\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns(uint256) {\\n        return a < b ? a : b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/dao/IGaugeController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\ninterface IGaugeController {\\n    function gauge_types(address _addr)external view returns(uint256);\\n    function get_voting_escrow()external view returns(address);\\n    function checkpoint_gauge(address addr)external;\\n    function gauge_relative_weight(address addr, uint256 time)external view returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/dao/IInsureToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\ninterface IInsureToken {\\n    function mint(address _to, uint256 _value)external returns(bool);\\n    function emergency_mint(uint256 _amountOut, address _to)external;\\n    function approve(address _spender, uint256 _value)external;\\n    function rate()external view returns(uint256);\\n    function future_epoch_time_write() external returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/dao/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport \\\"./IGaugeController.sol\\\";\\ninterface IMinter {\\n    function insure_token()external view returns(address);\\n    function controller()external view returns(address);\\n    function minted(address user, address gauge) external view returns(uint256);\\n    function gauge_controller()external view returns(address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/dao/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\ninterface IVotingEscrow {\\n    function get_last_user_slope(address _addr) external view returns (uint256);\\n\\n    function locked__end(address _addr) external view returns (uint256);\\n\\n    function balanceOf(address _addr, uint256 _t)\\n        external\\n        view\\n        returns (uint256);\\n\\n    //function balanceOf(address addr)external view returns (uint256);\\n    function totalSupply(uint256 _t) external view returns (uint256);\\n\\n    function get_user_point_epoch(address _user)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function user_point_history__ts(address _addr, uint256 _idx)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/pool/IOwnership.sol\": {\r\n      \"content\": \"pragma solidity 0.8.10;\\n\\n//SPDX-License-Identifier: MIT\\n\\ninterface IOwnership {\\n    function owner() external view returns (address);\\n\\n    function futureOwner() external view returns (address);\\n\\n    function commitTransferOwnership(address newOwner) external;\\n\\n    function acceptTransferOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ownership\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"original_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"original_supply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"working_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"working_supply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voting_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voting_total\",\"type\":\"uint256\"}],\"name\":\"UpdateLiquidityLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approved_to_deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"claimable_tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IGaugeController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"future_epoch_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inflation_rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insure_token\",\"outputs\":[{\"internalType\":\"contract IInsureToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"integrate_checkpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"integrate_checkpoint_of\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"integrate_fraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"integrate_inv_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"integrate_inv_supply_of\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"is_killed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"kick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kill_me\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"contract IMinter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownership\",\"outputs\":[{\"internalType\":\"contract IOwnership\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"period_timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"can_deposit\",\"type\":\"bool\"}],\"name\":\"set_approve_deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"template\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"user_checkpoint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voting_escrow\",\"outputs\":[{\"internalType\":\"contract IVotingEscrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"working_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"working_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LiquidityGauge", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200000", "ConstructorArguments": "000000000000000000000000a12ab76a82d118e33682acb242180b4cc0d19e2900000000000000000000000076e8b82ea3450fa598e5e164c7e28af172debdc000000000000000000000000056246e83f3148b05ce2d90b44fbb4e9fa9eaf5bb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}