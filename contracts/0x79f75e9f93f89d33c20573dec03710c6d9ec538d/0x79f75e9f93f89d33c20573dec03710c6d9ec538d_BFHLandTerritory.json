{"SourceCode": "// Copyright (c) 2018-2020 double jump.tokyo inc.\r\npragma solidity 0.5.17;\r\n\r\ninterface IERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string memory _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string memory _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function toPayable(address account) internal pure returns (address payable) {\r\n        return address(uint160(account));\r\n    }\r\n\r\n    function toHex(address account) internal pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(account));\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(42);\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n        for (uint i = 0; i < 20; i++) {\r\n            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n}\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    )\r\n        external\r\n        returns(bytes4);\r\n}\r\n\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping (address => bool) bearer;\r\n    }\r\n\r\n    function add(Role storage role, address account) internal {\r\n        require(!has(role, account), \"role already has the account\");\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    function remove(Role storage role, address account) internal {\r\n        require(has(role, account), \"role dosen't have the account\");\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    function has(Role storage role, address account) internal view returns (bool) {\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ninterface IApprovalProxy {\r\n  function setApprovalForAll(address _owner, address _spender, bool _approved) external;\r\n  function isApprovedForAll(address _owner, address _spender, bool _original) external view returns (bool);\r\n}\r\nlibrary String {\r\n\r\n    function compare(string memory _a, string memory _b) public pure returns (bool) {\r\n        return (keccak256(abi.encodePacked(_a)) == keccak256(abi.encodePacked(_b)));\r\n    }\r\n\r\n    function cut(string memory _s, uint256 _from, uint256 _range) public pure returns (string memory) {\r\n        bytes memory s = bytes(_s);\r\n        require(s.length >= _from + _range, \"_s length must be longer than _from + _range\");\r\n        bytes memory ret = new bytes(_range);\r\n\r\n        for (uint256 i = 0; i < _range; i++) {\r\n            ret[i] = s[_from+i];\r\n        }\r\n        return string(ret);\r\n    }\r\n\r\n    function concat(string memory _a, string memory _b) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(_a, _b));\r\n    }\r\n}\r\n\r\ninterface IERC721 /* is ERC165 */ {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-165 Standard Interface Detection\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-165\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\nlibrary Uint32 {\r\n\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        require(c >= a, \"addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(a >= b, \"subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint32 c = a * b;\r\n        require(c / a == b, \"multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b != 0, \"division by 0\");\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b != 0, \"modulo by 0\");\r\n        return a % b;\r\n    }\r\n\r\n}\r\n\r\nlibrary Uint256 {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(a >= b, \"subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"division by 0\");\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"modulo by 0\");\r\n        return a % b;\r\n    }\r\n\r\n    function toString(uint256 a) internal pure returns (string memory) {\r\n        bytes32 retBytes32;\r\n        uint256 len = 0;\r\n        if (a == 0) {\r\n            retBytes32 = \"0\";\r\n            len++;\r\n        } else {\r\n            uint256 value = a;\r\n            while (value > 0) {\r\n                retBytes32 = bytes32(uint256(retBytes32) / (2 ** 8));\r\n                retBytes32 |= bytes32(((value % 10) + 48) * 2 ** (8 * 31));\r\n                value /= 10;\r\n                len++;\r\n            }\r\n        }\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint256 i;\r\n\r\n        for (i = 0; i < len; i++) {\r\n            ret[i] = retBytes32[i];\r\n        }\r\n        return string(ret);\r\n    }\r\n}\r\n\r\ncontract ERC721 is IERC721, ERC165 {\r\n    using Uint256 for uint256;\r\n    using Address for address;\r\n\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n    bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\r\n\r\n    mapping (uint256 => address) private _tokenOwner;\r\n    mapping (address => uint256) private _balance;\r\n    mapping (uint256 => address) private _tokenApproved;\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    constructor () public {\r\n        _registerInterface(_InterfaceId_ERC721);\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return _balance[_owner];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        require(_exist(_tokenId),\r\n                \"`_tokenId` is not a valid NFT.\");\r\n        return _tokenOwner[_tokenId];\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public payable {\r\n        require(_data.length == 0, \"data is not implemented\");\r\n        safeTransferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable {\r\n        require(_checkOnERC721Received(_from, _to, _tokenId, \"\"),\r\n                \"`_to` is a smart contract and onERC721Received is invalid\");\r\n        transferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public payable {\r\n        require(_transferable(msg.sender, _tokenId),\r\n                \"Unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\"); // solhint-disable-line\r\n        require(ownerOf(_tokenId) == _from,\r\n                \"`_from` is not the current owner.\");\r\n        require(_to != address(0),\r\n                \"`_to` is the zero address.\");\r\n        require(_exist(_tokenId),\r\n                \"`_tokenId` is not a valid NFT.\");\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) public payable {\r\n        address owner = ownerOf(_tokenId);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender),\r\n                \"Unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\");\r\n\r\n        _tokenApproved[_tokenId] = _approved;\r\n        emit Approval(msg.sender, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public {\r\n        _setApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function _setApprovalForAll(address _owner, address _operator, bool _approved) internal {\r\n        _operatorApprovals[_owner][_operator] = _approved;\r\n        emit ApprovalForAll(_owner, _operator, _approved);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        require(_exist(_tokenId),\r\n                \"`_tokenId` is not a valid NFT.\");\r\n        return _tokenApproved[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return _isApprovedForAll(_owner, _operator);\r\n    }\r\n    \r\n    function _isApprovedForAll(address _owner, address _operator) internal view returns (bool) {\r\n        return _operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    function _transferable(address _spender, uint256 _tokenId) internal view returns (bool){\r\n        address owner = ownerOf(_tokenId);\r\n        return (_spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender));\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        _clearApproval(_tokenId);\r\n        _tokenOwner[_tokenId] = _to;\r\n        _balance[_from] = _balance[_from].sub(1);\r\n        _balance[_to] = _balance[_to].add(1);\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n  \r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(!_exist(_tokenId), \"mint token already exists\");\r\n        _tokenOwner[_tokenId] = _to;\r\n        _balance[_to] = _balance[_to].add(1);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n  \r\n    function _burn(uint256 _tokenId) internal {\r\n        require(_exist(_tokenId), \"burn token does not already exists\");\r\n        address owner = ownerOf(_tokenId);\r\n        _clearApproval(_tokenId);\r\n        _tokenOwner[_tokenId] = address(0);\r\n        _balance[owner] = _balance[owner].sub(1);\r\n        emit Transfer(owner, address(0), _tokenId);\r\n    }\r\n\r\n    function _exist(uint256 _tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) \r\n        internal\r\n        returns (bool) \r\n    {\r\n        if (!_to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes4 retval = IERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    function _clearApproval(uint256 tokenId) internal {\r\n        if (_tokenApproved[tokenId] != address(0)) {\r\n            _tokenApproved[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC173 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return The address of the owner.\r\n    function owner() external view returns (address);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\ncontract ERC173 is IERC173, ERC165  {\r\n    address private _owner;\r\n\r\n    constructor() public {\r\n        _registerInterface(0x7f5828d0);\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner(), \"Must be owner\");\r\n        _;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner() {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address _newOwner) internal {\r\n        address previousOwner = owner();\r\n\t_owner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n}\r\n\r\ncontract Operatable is ERC173 {\r\n    using Roles for Roles.Role;\r\n\r\n    event OperatorAdded(address indexed account);\r\n    event OperatorRemoved(address indexed account);\r\n\r\n    event Paused(address account);\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n    Roles.Role private operators;\r\n\r\n    constructor() public {\r\n        operators.add(msg.sender);\r\n        _paused = false;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(isOperator(msg.sender), \"Must be operator\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOperator() {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    function isOperator(address account) public view returns (bool) {\r\n        return operators.has(account);\r\n    }\r\n\r\n    function addOperator(address account) public onlyOperator() {\r\n        operators.add(account);\r\n        emit OperatorAdded(account);\r\n    }\r\n\r\n    function removeOperator(address account) public onlyOperator() {\r\n        operators.remove(account);\r\n        emit OperatorRemoved(account);\r\n    }\r\n\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function pause() public onlyOperator() whenNotPaused() {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function unpause() public onlyOperator() whenPaused() {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n\r\n    function withdrawEther() public onlyOperator() {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n}\r\n\r\ncontract ERC721Metadata is IERC721Metadata, ERC721, Operatable {\r\n    using Uint256 for uint256;\r\n    using String for string;\r\n\r\n    event UpdateTokenURIPrefix(\r\n        string tokenUriPrefix\r\n    );\r\n\r\n    // Metadata\r\n    string private __name;\r\n    string private __symbol;\r\n    string private __tokenUriPrefix;\r\n\r\n    constructor(string memory _name,\r\n                string memory _symbol,\r\n                string memory _tokenUriPrefix) public {\r\n        // ERC721Metadata\r\n        __name = _name;\r\n        __symbol = _symbol;\r\n        setTokenURIPrefix(_tokenUriPrefix);\r\n    }\r\n\r\n    function setTokenURIPrefix(string memory _tokenUriPrefix) public onlyOperator() {\r\n        __tokenUriPrefix = _tokenUriPrefix;\r\n        emit UpdateTokenURIPrefix(_tokenUriPrefix);\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return __name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return __symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory) {\r\n        return __tokenUriPrefix.concat(_tokenId.toString());\r\n    }\r\n}\r\n\r\ninterface IERC721Mintable {\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n    function exist(uint256 _tokenId) external view returns (bool);\r\n    function mint(address _to, uint256 _tokenId) external;\r\n    function isMinter(address account) external view returns (bool);\r\n    function addMinter(address account) external;\r\n    function removeMinter(address account) external;\r\n}\r\n\r\ncontract ERC721Mintable is ERC721, IERC721Mintable, Operatable {\r\n    using Roles for Roles.Role;\r\n    Roles.Role private minters;\r\n\r\n    constructor() public {\r\n        addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender), \"Must be minter\");\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyOperator() {\r\n        minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function removeMinter(address account) public onlyOperator() {\r\n        minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n    \r\n    function exist(uint256 tokenId) public view returns (bool) {\r\n        return _exist(tokenId);\r\n    }\r\n\r\n    function mint(address to, uint256 tokenId) public onlyMinter() {\r\n        _mint(to, tokenId);\r\n    }\r\n}\r\ninterface IERC721CappedSupply /* IERC721Mintable, IERC721 */ {\r\n    event SetUnitCap(uint32 _assetType, uint32 _unitCap);\r\n    event SetTypeCap(uint256 _typeCap);\r\n    function totalSupply() external view returns (uint256);\r\n    function getTypeOffset() external view returns (uint256);\r\n    function getTypeCap() external view returns (uint256);\r\n    function setTypeCap(uint32 _newTypeCap) external;\r\n    function getTypeCount() external view returns (uint256);\r\n    function existingType(uint32 _assetType) external view returns (bool);\r\n    function getUnitCap(uint32 _assetType) external view returns (uint32);\r\n    function setUnitCap(uint32 _assetType, uint32 _newUnitCap) external;\r\n    function mint(address _to, uint256 _tokenId) external;\r\n}\r\n\r\n/// @title ERC-721 Capped Supply\r\n/// @author double jump.tokyo inc.\r\n/// @dev see https://medium.com/@makzent/the-2x2-matrix-for-blockchain-game-ecosystems-2645be502704\r\ncontract ERC721CappedSupply is IERC721CappedSupply, ERC721Mintable {\r\n    using Uint256 for uint256;\r\n    using Uint32 for uint32;\r\n\r\n    uint32 private assetTypeOffset;\r\n    mapping(uint32 => uint32) private unitCap;\r\n    mapping(uint32 => uint32) private unitCount;\r\n    mapping(uint32 => bool) private unitCapIsSet;\r\n    uint256 private assetTypeCap = 2**256-1;\r\n    uint256 private assetTypeCount = 0;\r\n    uint256 private totalCount = 0;\r\n\r\n    constructor(uint32 _assetTypeOffset) public {\r\n        setTypeOffset(_assetTypeOffset);\r\n    }\r\n\r\n    function isValidOffset(uint32 _offset) private pure returns (bool) {\r\n        for (uint32 i = _offset; i > 0; i = i.div(10)) {\r\n            if (i == 10) {\r\n                return true;\r\n            }\r\n            if (i.mod(10) != 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalCount;\r\n    }\r\n\r\n    function setTypeOffset(uint32 _assetTypeOffset) private {\r\n        require(isValidOffset(_assetTypeOffset),  \"Offset is invalid\");\r\n        assetTypeCap = assetTypeCap / _assetTypeOffset;\r\n        assetTypeOffset = _assetTypeOffset;\r\n    }\r\n\r\n    function getTypeOffset() public view returns (uint256) {\r\n        return assetTypeOffset;\r\n    }\r\n\r\n    function setTypeCap(uint32 _newTypeCap) public onlyMinter() {\r\n        require(_newTypeCap < assetTypeCap, \"New type cap cannot be less than existing type cap\");\r\n        require(_newTypeCap >= assetTypeCount, \"New type cap must be more than current type count\");\r\n        assetTypeCap = _newTypeCap;\r\n        emit SetTypeCap(_newTypeCap);\r\n    }\r\n\r\n    function getTypeCap() public view returns (uint256) {\r\n        return assetTypeCap;\r\n    }\r\n\r\n    function getTypeCount() public view returns (uint256) {\r\n        return assetTypeCount;\r\n    }\r\n\r\n    function existingType(uint32 _assetType) public view returns (bool) {\r\n        return unitCapIsSet[_assetType];\r\n    }\r\n\r\n    function setUnitCap(uint32 _assetType, uint32 _newUnitCap) public onlyMinter() {\r\n        require(_assetType != 0, \"Asset Type must not be 0\");\r\n        require(_newUnitCap < assetTypeOffset, \"New unit cap must be less than asset type offset\");\r\n\r\n        if (!existingType(_assetType)) {\r\n            unitCapIsSet[_assetType] = true;\r\n            assetTypeCount = assetTypeCount.add(1);\r\n            require(assetTypeCount <= assetTypeCap, \"Asset type cap is exceeded\");\r\n        } else {\r\n            require(_newUnitCap < getUnitCap(_assetType), \"New unit cap must be less than previous unit cap\");\r\n            require(_newUnitCap >= getUnitCount(_assetType), \"New unit cap must be more than current unit count\");\r\n        }\r\n\r\n        unitCap[_assetType] = _newUnitCap;\r\n        emit SetUnitCap(_assetType, _newUnitCap);\r\n    }\r\n\r\n    function getUnitCap(uint32 _assetType) public view returns (uint32) {\r\n        require(existingType(_assetType), \"Asset type does not exist\");\r\n        return unitCap[_assetType];\r\n    }\r\n\r\n    function getUnitCount(uint32 _assetType) public view returns (uint32) {\r\n        return unitCount[_assetType];\r\n    }\r\n\r\n    function mint(address _to, uint256 _tokenId) public onlyMinter() {\r\n        require(_tokenId.mod(assetTypeOffset) != 0, \"Index must not be 0\");\r\n        uint32 assetType = uint32(_tokenId.div(assetTypeOffset));\r\n        unitCount[assetType] = unitCount[assetType].add(1);\r\n        totalCount = totalCount.add(1);\r\n        require(unitCount[assetType] <= getUnitCap(assetType), \"Asset unit cap is exceed\");\r\n        super.mint(_to, _tokenId);\r\n    }\r\n}\r\n\r\ncontract ERC721TokenPausable is ERC721,Operatable {\r\n    using Roles for Roles.Role;\r\n    Roles.Role private tokenPauser;\r\n\r\n    event TokenPauserAdded(address indexed account);\r\n    event TokenPauserRemoved(address indexed account);\r\n\r\n    event TokenPaused(uint256 indexed tokenId);\r\n    event TokenUnpaused(uint256 indexed tokenId);\r\n\r\n    mapping (uint256 => bool) private _tokenPaused;\r\n\r\n    constructor() public {\r\n        tokenPauser.add(msg.sender);\r\n    }\r\n\r\n    modifier onlyTokenPauser() {\r\n        require(isTokenPauser(msg.sender), \"Only token pauser can call this method\");\r\n        _;\r\n    }\r\n\r\n    modifier whenNotTokenPaused(uint256 _tokenId) {\r\n        require(!isTokenPaused(_tokenId), \"TokenPausable: paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenTokenPaused(uint256 _tokenId) {\r\n        require(isTokenPaused(_tokenId), \"TokenPausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function pauseToken(uint256 _tokenId) public onlyTokenPauser() {\r\n        require(!isTokenPaused(_tokenId), \"Token is already paused\");\r\n        _tokenPaused[_tokenId] = true;\r\n        emit TokenPaused(_tokenId);\r\n    }\r\n\r\n    function unpauseToken(uint256 _tokenId) public onlyTokenPauser() {\r\n        require(isTokenPaused(_tokenId), \"Token is not paused\");\r\n        _tokenPaused[_tokenId] = false;\r\n        emit TokenUnpaused(_tokenId);\r\n    }\r\n\r\n    function isTokenPaused(uint256 _tokenId) public view returns (bool) {\r\n        return _tokenPaused[_tokenId];\r\n    }\r\n\r\n    function isTokenPauser(address account) public view returns (bool) {\r\n        return tokenPauser.has(account);\r\n    }\r\n\r\n    function addTokenPauser(address account) public onlyOperator() {\r\n        tokenPauser.add(account);\r\n        emit TokenPauserAdded(account);\r\n    }\r\n\r\n    function removeTokenPauser(address account) public onlyOperator() {\r\n        tokenPauser.remove(account);\r\n        emit TokenPauserRemoved(account);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public payable\r\n                            whenNotPaused() whenNotTokenPaused(_tokenId) {\r\n        super.safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public payable\r\n                            whenNotPaused() whenNotTokenPaused(_tokenId) {\r\n        super.safeTransferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public payable\r\n                            whenNotPaused() whenNotTokenPaused(_tokenId) {\r\n        super.transferFrom(_from, _to, _tokenId);\r\n    }\r\n}\r\n\r\ncontract BFHLandTerritory is\r\n                    ERC721TokenPausable,\r\n                    ERC721CappedSupply(10000),\r\n                    ERC721Metadata(\"BFH:LandTerritory\", \"BFHL\", \"https://bravefrontierheroes.com/metadata/landterritories/\")\r\n                    {\r\n\r\n    event UpdateApprovalProxy(address _newProxyContract);\r\n    IApprovalProxy public approvalProxy;\r\n    constructor(address _approvalProxy) public {\r\n        setApprovalProxy(_approvalProxy);\r\n    }\r\n\r\n    function setApprovalProxy(address _new) public onlyOperator() {\r\n        approvalProxy = IApprovalProxy(_new);\r\n        emit UpdateApprovalProxy(_new);\r\n    }\r\n\r\n    function setApprovalForAll(address _spender, bool _approved) public {\r\n        if (address(approvalProxy) != address(0x0) && _spender.isContract()) {\r\n            approvalProxy.setApprovalForAll(msg.sender, _spender, _approved);\r\n        }\r\n        super.setApprovalForAll(_spender, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _spender) public view returns (bool) {\r\n        bool original = super.isApprovedForAll(_owner, _spender);\r\n        if (address(approvalProxy) != address(0x0)) {\r\n            return approvalProxy.isApprovedForAll(_owner, _spender, original);\r\n        }\r\n        return original;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approvalProxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_typeCap\",\"type\":\"uint256\"}],\"name\":\"SetTypeCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_assetType\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_unitCap\",\"type\":\"uint32\"}],\"name\":\"SetUnitCap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TokenPauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"TokenPauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newProxyContract\",\"type\":\"address\"}],\"name\":\"UpdateApprovalProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"tokenUriPrefix\",\"type\":\"string\"}],\"name\":\"UpdateTokenURIPrefix\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addTokenPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"approvalProxy\",\"outputs\":[{\"internalType\":\"contract IApprovalProxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_assetType\",\"type\":\"uint32\"}],\"name\":\"existingType\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTypeCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTypeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTypeOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_assetType\",\"type\":\"uint32\"}],\"name\":\"getUnitCap\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_assetType\",\"type\":\"uint32\"}],\"name\":\"getUnitCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isTokenPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isTokenPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"pauseToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeTokenPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"setApprovalProxy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenUriPrefix\",\"type\":\"string\"}],\"name\":\"setTokenURIPrefix\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_newTypeCap\",\"type\":\"uint32\"}],\"name\":\"setTypeCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_assetType\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_newUnitCap\",\"type\":\"uint32\"}],\"name\":\"setUnitCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unpauseToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BFHLandTerritory", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000aa06e5c117dbe8bc52dbaa18aaf447eda556b13c", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://ba2ee7403bc3ef745afefe5c6351f6fb712469b15b2177655d00f8b181f927b5"}