{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n\n\n\ncontract MainnetLiquityAddresses {\n    address internal constant LUSD_TOKEN_ADDRESS = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;\n    address internal constant LQTY_TOKEN_ADDRESS = 0x6DEA81C8171D0bA574754EF6F8b412F2Ed88c54D;\n    address internal constant PRICE_FEED_ADDRESS = 0x4c517D4e2C851CA76d7eC94B805269Df0f2201De;\n    address internal constant BORROWER_OPERATIONS_ADDRESS = 0x24179CD81c9e782A4096035f7eC97fB8B783e007;\n    address internal constant TROVE_MANAGER_ADDRESS = 0xA39739EF8b0231DbFA0DcdA07d7e29faAbCf4bb2;\n    address internal constant SORTED_TROVES_ADDRESS = 0x8FdD3fbFEb32b28fb73555518f8b361bCeA741A6;\n    address internal constant HINT_HELPERS_ADDRESS = 0xE84251b93D9524E0d2e621Ba7dc7cb3579F997C0;\n    address internal constant COLL_SURPLUS_POOL_ADDRESS = 0x3D32e8b97Ed5881324241Cf03b2DA5E2EBcE5521;\n    address internal constant STABILITY_POOL_ADDRESS = 0x66017D22b0f8556afDd19FC67041899Eb65a21bb;\n    address internal constant LQTY_STAKING_ADDRESS = 0x4f9Fbb3f1E99B56e0Fe2892e623Ed36A76Fc605d;\n    address internal constant LQTY_FRONT_END_ADDRESS = 0x76720aC2574631530eC8163e4085d6F98513fb27;\n    \n    address internal constant CB_MANAGER_ADDRESS = 0x57619FE9C539f890b19c61812226F9703ce37137;\n    address internal constant BLUSD_ADDRESS = 0xB9D7DdDca9a4AC480991865EfEf82E01273F79C3;\n    address internal constant BOND_NFT_ADDRESS = 0xa8384862219188a8f03c144953Cf21fc124029Ee;\n    address internal constant BLUSD_AMM_ADDRESS = 0x74ED5d42203806c8CDCf2F04Ca5F60DC777b901c;\n    address internal constant LUSD_3CRV_POOL_ADDRESS = 0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA;\n    address internal constant CURVE_REGISTRY_SWAP_ADDRESS = 0x81C46fECa27B31F3ADC2b91eE4be9717d1cd3DD7;\n}\n\n\n\n\n\ninterface IBorrowerOperations {\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n\n    // --- Functions ---\n\n    function openTrove(uint _maxFee, uint _LUSDAmount, address _upperHint, address _lowerHint) external payable;\n\n    function addColl(address _upperHint, address _lowerHint) external payable;\n\n    function moveETHGainToTrove(address _user, address _upperHint, address _lowerHint) external payable;\n\n    function withdrawColl(uint _amount, address _upperHint, address _lowerHint) external;\n\n    function withdrawLUSD(uint _maxFee, uint _amount, address _upperHint, address _lowerHint) external;\n\n    function repayLUSD(uint _amount, address _upperHint, address _lowerHint) external;\n\n    function closeTrove() external;\n\n    function adjustTrove(uint _maxFee, uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _upperHint, address _lowerHint) external payable;\n\n    function claimCollateral() external;\n\n    function getCompositeDebt(uint _debt) external pure returns (uint);\n}\n\n\n\n\n\n\ninterface IChickenBondManager {\n    // Valid values for `status` returned by `getBondData()`\n    enum BondStatus {\n        nonExistent,\n        active,\n        chickenedOut,\n        chickenedIn\n    }\n\n    struct BondData {\n        uint256 lusdAmount;\n        uint64 claimedBLUSD; // In BLUSD units without decimals\n        uint64 startTime;\n        uint64 endTime; // Timestamp of chicken in/out event\n        BondStatus status;\n    }\n\n    function lusdToken() external view returns (address);\n    function bLUSDToken() external view returns (address);\n    function curvePool() external view returns (address);\n    function bammSPVault() external view returns (address);\n    function yearnCurveVault() external view returns (address);\n\n    function countChickenIn() external view returns (uint256);\n    function countChickenOut() external view returns (uint256);\n\n    // constants\n    function INDEX_OF_LUSD_TOKEN_IN_CURVE_POOL() external pure returns (int128);\n    function CHICKEN_IN_AMM_FEE() external view returns (uint256);\n\n    function createBond(uint256 _lusdAmount) external returns (uint256);\n    function createBondWithPermit(\n        address owner, \n        uint256 amount, \n        uint256 deadline, \n        uint8 v, \n        bytes32 r, \n        bytes32 s\n    ) external  returns (uint256);\n    function chickenOut(uint256 _bondID, uint256 _minLUSD) external;\n    function chickenIn(uint256 _bondID) external;\n    function redeem(uint256 _bLUSDToRedeem, uint256 _minLUSDFromBAMMSPVault) external returns (uint256, uint256);\n\n    // getters\n    function calcRedemptionFeePercentage(uint256 _fractionOfBLUSDToRedeem) external view returns (uint256);\n    function getBondData(uint256 _bondID) external view returns (BondData memory);\n    function getLUSDToAcquire(uint256 _bondID) external view returns (uint256);\n    function calcAccruedBLUSD(uint256 _bondID) external view returns (uint256);\n    function calcBondBLUSDCap(uint256 _bondID) external view returns (uint256);\n    function getLUSDInBAMMSPVault() external view returns (uint256);\n    function calcTotalYearnCurveVaultShareValue() external view returns (uint256);\n    function calcTotalLUSDValue() external view returns (uint256);\n    function getPendingLUSD() external view returns (uint256);\n    function getAcquiredLUSDInSP() external view returns (uint256);\n    function getAcquiredLUSDInCurve() external view returns (uint256);\n    function getTotalAcquiredLUSD() external view returns (uint256);\n    function getPermanentLUSD() external view returns (uint256);\n    function getOwnedLUSDInSP() external view returns (uint256);\n    function getOwnedLUSDInCurve() external view returns (uint256);\n    function calcSystemBackingRatio() external view returns (uint256);\n    function calcUpdatedAccrualParameter() external view returns (uint256);\n    function getBAMMLUSDDebt() external view returns (uint256);\n    function getOpenBondCount() external view returns (uint256);\n    function getTreasury()\n        external\n        view\n        returns (\n            uint256 _pendingLUSD,\n            uint256 _totalAcquiredLUSD,\n            uint256 _permanentLUSD\n        );\n}\n\n\n\n\ninterface ICollSurplusPool {\n\n    // --- Events ---\n    \n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\n    event EtherSent(address _to, uint _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external;\n\n    function getETH() external view returns (uint);\n\n    function getCollateral(address _account) external view returns (uint);\n\n    function accountSurplus(address _account, uint _amount) external;\n\n    function claimColl(address _account) external;\n}\n\n\n\n\n\ninterface IHintHelpers {\n\n    function getRedemptionHints(\n        uint _LUSDamount, \n        uint _price,\n        uint _maxIterations\n    )\n        external\n        view\n        returns (\n            address firstRedemptionHint,\n            uint partialRedemptionHintNICR,\n            uint truncatedLUSDamount\n        );\n\n    function getApproxHint(uint _CR, uint _numTrials, uint _inputRandomSeed)\n        external\n        view\n        returns (address hintAddress, uint diff, uint latestRandomSeed);\n\n    function computeNominalCR(uint _coll, uint _debt) external pure returns (uint);\n\n    function computeCR(uint _coll, uint _debt, uint _price) external pure returns (uint);\n}\n\n\n\n\n\ninterface ILQTYStaking {\n\n    // --- Events --\n    \n    event LQTYTokenAddressSet(address _lqtyTokenAddress);\n    event LUSDTokenAddressSet(address _lusdTokenAddress);\n    event TroveManagerAddressSet(address _troveManager);\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\n    event ActivePoolAddressSet(address _activePoolAddress);\n\n    event StakeChanged(address indexed staker, uint newStake);\n    event StakingGainsWithdrawn(address indexed staker, uint LUSDGain, uint ETHGain);\n    event F_ETHUpdated(uint _F_ETH);\n    event F_LUSDUpdated(uint _F_LUSD);\n    event TotalLQTYStakedUpdated(uint _totalLQTYStaked);\n    event EtherSent(address _account, uint _amount);\n    event StakerSnapshotsUpdated(address _staker, uint _F_ETH, uint _F_LUSD);\n\n    // --- Functions ---\n\n    function setAddresses\n    (\n        address _lqtyTokenAddress,\n        address _lusdTokenAddress,\n        address _troveManagerAddress, \n        address _borrowerOperationsAddress,\n        address _activePoolAddress\n    )  external;\n\n    function stake(uint _LQTYamount) external;\n\n    function unstake(uint _LQTYamount) external;\n\n    function increaseF_ETH(uint _ETHFee) external; \n\n    function increaseF_LUSD(uint _LQTYFee) external;  \n\n    function getPendingETHGain(address _user) external view returns (uint);\n\n    function getPendingLUSDGain(address _user) external view returns (uint);\n\n    function stakes(address) external view returns (uint256);\n}\n\n\n\n\n\ninterface IPriceFeed {\n    function lastGoodPrice() external pure returns (uint256);\n    function fetchPrice() external returns (uint);\n}\n\n\n\n\n\ninterface ISortedTroves {\n\n    // --- Events ---\n    \n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\n    event NodeAdded(address _id, uint _NICR);\n    event NodeRemoved(address _id);\n\n    // --- Functions ---\n    \n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\n\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\n\n    function remove(address _id) external;\n\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\n\n    function contains(address _id) external view returns (bool);\n\n    function isFull() external view returns (bool);\n\n    function isEmpty() external view returns (bool);\n\n    function getSize() external view returns (uint256);\n\n    function getMaxSize() external view returns (uint256);\n\n    function getFirst() external view returns (address);\n\n    function getLast() external view returns (address);\n\n    function getNext(address _id) external view returns (address);\n\n    function getPrev(address _id) external view returns (address);\n\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\n\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\n}\n\n\n\n\ninterface IStabilityPool {\n\n    // --- Events ---\n    \n    event StabilityPoolETHBalanceUpdated(uint _newBalance);\n    event StabilityPoolLUSDBalanceUpdated(uint _newBalance);\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\n\n    event P_Updated(uint _P);\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\n    event EpochUpdated(uint128 _currentEpoch);\n    event ScaleUpdated(uint128 _currentScale);\n\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\n\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\n\n    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _LUSDLoss);\n    event LQTYPaidToDepositor(address indexed _depositor, uint _LQTY);\n    event LQTYPaidToFrontEnd(address indexed _frontEnd, uint _LQTY);\n    event EtherSent(address _to, uint _amount);\n\n    // --- Functions ---\n\n    /*\n     * Called only once on init, to set addresses of other Liquity contracts\n     * Callable only by owner, renounces ownership at the end\n     */\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _lusdTokenAddress,\n        address _sortedTrovesAddress,\n        address _priceFeedAddress,\n        address _communityIssuanceAddress\n    ) external;\n\n    /*\n     * Initial checks:\n     * - Frontend is registered or zero address\n     * - Sender is not a registered frontend\n     * - _amount is not zero\n     * ---\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\n     * - Sends depositor's accumulated gains (LQTY, ETH) to depositor\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\n     */\n    function provideToSP(uint _amount, address _frontEndTag) external;\n\n    /*\n     * Initial checks:\n     * - _amount is zero or there are no under collateralized troves left in the system\n     * - User has a non zero deposit\n     * ---\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\n     * - Removes the deposit's front end tag if it is a full withdrawal\n     * - Sends all depositor's accumulated gains (LQTY, ETH) to depositor\n     * - Sends the tagged front end's accumulated LQTY gains to the tagged front end\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\n     *\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\n     */\n    function withdrawFromSP(uint _amount) external;\n\n    /*\n     * Initial checks:\n     * - User has a non zero deposit\n     * - User has an open trove\n     * - User has some ETH gain\n     * ---\n     * - Triggers a LQTY issuance, based on time passed since the last issuance. The LQTY issuance is shared between *all* depositors and front ends\n     * - Sends all depositor's LQTY gain to  depositor\n     * - Sends all tagged front end's LQTY gain to the tagged front end\n     * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\n     * - Leaves their compounded deposit in the Stability Pool\n     * - Updates snapshots for deposit and tagged front end stake\n     */\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external;\n\n    /*\n     * Initial checks:\n     * - Frontend (sender) not already registered\n     * - User (sender) has no deposit\n     * - _kickbackRate is in the range [0, 100%]\n     * ---\n     * Front end makes a one-time selection of kickback rate upon registering\n     */\n    function registerFrontEnd(uint _kickbackRate) external;\n\n    /*\n     * Initial checks:\n     * - Caller is TroveManager\n     * ---\n     * Cancels out the specified debt against the LUSD contained in the Stability Pool (as far as possible)\n     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\n     * Only called by liquidation functions in the TroveManager.\n     */\n    function offset(uint _debt, uint _coll) external;\n\n    /*\n     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\n     * to exclude edge cases like ETH received from a self-destruct.\n     */\n    function getETH() external view returns (uint);\n\n    /*\n     * Returns LUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\n     */\n    function getTotalLUSDDeposits() external view returns (uint);\n\n    /*\n     * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\n     */\n    function getDepositorETHGain(address _depositor) external view returns (uint);\n\n    /*\n     * Calculate the LQTY gain earned by a deposit since its last snapshots were taken.\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\n     * which they made their deposit.\n     */\n    function getDepositorLQTYGain(address _depositor) external view returns (uint);\n\n    /*\n     * Return the LQTY gain earned by the front end.\n     */\n    function getFrontEndLQTYGain(address _frontEnd) external view returns (uint);\n\n    /*\n     * Return the user's compounded deposit.\n     */\n    function getCompoundedLUSDDeposit(address _depositor) external view returns (uint);\n\n    /*\n     * Return the front end's compounded stake.\n     *\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\n     */\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\n}\n\n\n\n\n\n\ninterface ITroveManager {\n    \n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LQTYTokenAddressChanged(address _lqtyTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\n    event LTermsUpdated(uint _L_ETH, uint _L_LUSDDebt);\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_LUSDDebt);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n\n    function getTroveOwnersCount() external view returns (uint);\n\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\n\n    function getNominalICR(address _borrower) external view returns (uint);\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\n\n    function liquidate(address _borrower) external;\n\n    function liquidateTroves(uint _n) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        uint _LUSDAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFee\n    ) external; \n\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\n\n    function updateTroveRewardSnapshots(address _borrower) external;\n\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\n\n    function applyPendingRewards(address _borrower) external;\n\n    function getPendingETHReward(address _borrower) external view returns (uint);\n\n    function getPendingLUSDDebtReward(address _borrower) external view returns (uint);\n\n     function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function getEntireDebtAndColl(address _borrower) external view returns (\n        uint debt, \n        uint coll, \n        uint pendingLUSDDebtReward, \n        uint pendingETHReward\n    );\n\n    function closeTrove(address _borrower) external;\n\n    function removeStake(address _borrower) external;\n\n    function getRedemptionRate() external view returns (uint);\n    function getRedemptionRateWithDecay() external view returns (uint);\n\n    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view returns (uint);\n\n    function getBorrowingRate() external view returns (uint);\n    function getBorrowingRateWithDecay() external view returns (uint);\n\n    function getBorrowingFee(uint LUSDDebt) external view returns (uint);\n    function getBorrowingFeeWithDecay(uint _LUSDDebt) external view returns (uint);\n\n    function decayBaseRateFromBorrowing() external;\n\n    function getTroveStatus(address _borrower) external view returns (uint);\n    \n    function getTroveStake(address _borrower) external view returns (uint);\n\n    function getTroveDebt(address _borrower) external view returns (uint);\n\n    function getTroveColl(address _borrower) external view returns (uint);\n\n    function setTroveStatus(address _borrower, uint num) external;\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \n\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \n\n    function getTCR(uint _price) external view returns (uint);\n\n    function checkRecoveryMode(uint _price) external view returns (bool);\n}\n\n\n\n\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint256 digits);\n    function totalSupply() external view returns (uint256 supply);\n\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external returns (bool success);\n\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\n\n\nabstract contract IWETH {\n    function allowance(address, address) public virtual view returns (uint256);\n\n    function balanceOf(address) public virtual view returns (uint256);\n\n    function approve(address, uint256) public virtual;\n\n    function transfer(address, uint256) public virtual returns (bool);\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual returns (bool);\n\n    function deposit() public payable virtual;\n\n    function withdraw(uint256) public virtual;\n}\n\n\n\n\n\nlibrary Address {\n    //insufficient balance\n    error InsufficientBalance(uint256 available, uint256 required);\n    //unable to send value, recipient may have reverted\n    error SendingValueFail();\n    //insufficient balance for call\n    error InsufficientBalanceForCall(uint256 available, uint256 required);\n    //call to non-contract\n    error NonContractCall();\n    \n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    function sendValue(address payable recipient, uint256 amount) internal {\n        uint256 balance = address(this).balance;\n        if (balance < amount){\n            revert InsufficientBalance(balance, amount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!(success)){\n            revert SendingValueFail();\n        }\n    }\n\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        uint256 balance = address(this).balance;\n        if (balance < value){\n            revert InsufficientBalanceForCall(balance, value);\n        }\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        if (!(isContract(target))){\n            revert NonContractCall();\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n\n\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n\n\n\n\n\n\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /// @dev Edited so it always first approves 0 and then the value, because of non standard tokens\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n        );\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n\n\n\n\n\nlibrary TokenUtils {\n    using SafeERC20 for IERC20;\n\n    address public constant WSTETH_ADDR = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address public constant STETH_ADDR = 0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n\n    address public constant WETH_ADDR = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address public constant ETH_ADDR = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    function approveToken(\n        address _tokenAddr,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_tokenAddr == ETH_ADDR) return;\n\n        if (IERC20(_tokenAddr).allowance(address(this), _to) < _amount) {\n            IERC20(_tokenAddr).safeApprove(_to, _amount);\n        }\n    }\n\n    function pullTokensIfNeeded(\n        address _token,\n        address _from,\n        uint256 _amount\n    ) internal returns (uint256) {\n        // handle max uint amount\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, _from);\n        }\n\n        if (_from != address(0) && _from != address(this) && _token != ETH_ADDR && _amount != 0) {\n            IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n        }\n\n        return _amount;\n    }\n\n    function withdrawTokens(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256) {\n        if (_amount == type(uint256).max) {\n            _amount = getBalance(_token, address(this));\n        }\n\n        if (_to != address(0) && _to != address(this) && _amount != 0) {\n            if (_token != ETH_ADDR) {\n                IERC20(_token).safeTransfer(_to, _amount);\n            } else {\n                (bool success, ) = _to.call{value: _amount}(\"\");\n                require(success, \"Eth send fail\");\n            }\n        }\n\n        return _amount;\n    }\n\n    function depositWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).deposit{value: _amount}();\n    }\n\n    function withdrawWeth(uint256 _amount) internal {\n        IWETH(WETH_ADDR).withdraw(_amount);\n    }\n\n    function getBalance(address _tokenAddr, address _acc) internal view returns (uint256) {\n        if (_tokenAddr == ETH_ADDR) {\n            return _acc.balance;\n        } else {\n            return IERC20(_tokenAddr).balanceOf(_acc);\n        }\n    }\n\n    function getTokenDecimals(address _token) internal view returns (uint256) {\n        if (_token == ETH_ADDR) return 18;\n\n        return IERC20(_token).decimals();\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract LiquityHelper is MainnetLiquityAddresses {\n    using TokenUtils for address;\n\n    uint64 constant LIQUITY_PAYBACK_BUNDLE_ID = 7;\n\n    uint constant public LUSD_GAS_COMPENSATION = 200e18;\n    uint constant public MIN_DEBT = 2000e18; // MIN_NET_DEBT (1800e18) + LUSD_GAS_COMP (200e18)\n\n    IPriceFeed constant public PriceFeed = IPriceFeed(PRICE_FEED_ADDRESS);\n    IBorrowerOperations constant public BorrowerOperations = IBorrowerOperations(BORROWER_OPERATIONS_ADDRESS);\n    ITroveManager constant public TroveManager = ITroveManager(TROVE_MANAGER_ADDRESS);\n    ISortedTroves constant public SortedTroves = ISortedTroves(SORTED_TROVES_ADDRESS);\n    IHintHelpers constant public HintHelpers = IHintHelpers(HINT_HELPERS_ADDRESS);\n    ICollSurplusPool constant public CollSurplusPool = ICollSurplusPool(COLL_SURPLUS_POOL_ADDRESS);\n    IStabilityPool constant public StabilityPool = IStabilityPool(STABILITY_POOL_ADDRESS);\n    ILQTYStaking constant public LQTYStaking = ILQTYStaking(LQTY_STAKING_ADDRESS);\n    IChickenBondManager constant public CBManager = IChickenBondManager(CB_MANAGER_ADDRESS);\n\n    function withdrawStaking(uint256 _ethGain, uint256 _lusdGain, address _wethTo, address _lusdTo) internal {\n        if (_ethGain > 0) {\n            TokenUtils.depositWeth(_ethGain);\n            TokenUtils.WETH_ADDR.withdrawTokens(_wethTo, _ethGain);\n        }\n        if (_lusdGain > 0) {\n            LUSD_TOKEN_ADDRESS.withdrawTokens(_lusdTo, _lusdGain);\n        }\n    }\n    \n    function withdrawStabilityGains(uint256 _ethGain, uint256 _lqtyGain, address _wethTo, address _lqtyTo) internal {\n        if (_ethGain > 0) {\n            TokenUtils.depositWeth(_ethGain);\n            TokenUtils.WETH_ADDR.withdrawTokens(_wethTo, _ethGain);\n        }      \n        if (_lqtyGain > 0) {\n            LQTY_TOKEN_ADDRESS.withdrawTokens(_lqtyTo, _lqtyGain);\n        }\n    }\n}\n\n\n\n\ncontract DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x + y;\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x - y;\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n    }\n\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x / y;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\ncontract LiquityView is LiquityHelper, DSMath {\n    using TokenUtils for address;\n    using SafeMath for uint256;\n\n    enum CollChange { SUPPLY, WITHDRAW }\n    enum DebtChange { PAYBACK, BORROW }\n\n    function isRecoveryMode() public view returns (bool) {\n        uint256 price = PriceFeed.lastGoodPrice();\n        return TroveManager.checkRecoveryMode(price);\n    }\n\n    function computeNICR(uint256 _coll, uint256 _debt) public pure returns (uint256) {\n        if (_debt > 0) {\n            return _coll.mul(1e20).div(_debt);\n        }\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\n        else {\n            // if (_debt == 0)\n            return 2**256 - 1;\n        }\n    }\n\n    function predictNICRForAdjust(\n        address _troveOwner,\n        CollChange collChangeAction,\n        DebtChange debtChangeAction,\n        address _from,\n        uint256 _collAmount,\n        uint256 _lusdAmount\n    ) external view returns (uint256 NICR) {\n\n        (uint256 debt, uint256 coll, , ) = TroveManager.getEntireDebtAndColl(_troveOwner);\n        uint256 wholeDebt = TroveManager.getTroveDebt(_troveOwner);\n\n        uint256 newColl;\n        uint256 newDebt;\n\n        //  LiquitySupply\n        if (collChangeAction == CollChange.SUPPLY) {\n            if (_collAmount == type(uint256).max)\n                _collAmount = TokenUtils.WETH_ADDR.getBalance(_from);\n\n            newColl = coll.add(_collAmount);\n        }\n\n        //  LiquityWithdraw\n        if (collChangeAction == CollChange.WITHDRAW) {\n            newColl = coll.sub(_collAmount);\n        }\n              \n        //  LiquityBorrow\n        if (debtChangeAction == DebtChange.BORROW) {\n            if (!isRecoveryMode())\n                _lusdAmount = _lusdAmount.add(TroveManager.getBorrowingFeeWithDecay(_lusdAmount));\n\n            newDebt = debt.add(_lusdAmount);\n        }\n\n        //  LiquityPayback\n        if (debtChangeAction == DebtChange.PAYBACK) {\n            if (_lusdAmount == type(uint256).max) {\n                _lusdAmount = LUSD_TOKEN_ADDRESS.getBalance(_from);\n            }\n\n            // can't close with payback, pull amount to payback to MIN_DEBT\n            if (wholeDebt < (_lusdAmount + MIN_DEBT)) {\n                _lusdAmount = wholeDebt - MIN_DEBT;\n            }\n\n            newDebt = debt.sub(_lusdAmount);\n        }\n        return computeNICR(newColl, newDebt);\n    }\n\n    function getApproxHint(\n        uint256 _CR,\n        uint256 _numTrials,\n        uint256 _inputRandomSeed\n    )\n        external\n        view\n        returns (\n            address hintAddress,\n            uint256 diff,\n            uint256 latestRandomSeed\n        )\n    {\n        return HintHelpers.getApproxHint(_CR, _numTrials, _inputRandomSeed);\n    }\n\n    function findInsertPosition(\n        uint256 _ICR,\n        address _prevId,\n        address _nextId\n    ) external view returns (address upperHint, address lowerHint) {\n        return SortedTroves.findInsertPosition(_ICR, _prevId, _nextId);\n    }\n\n    function getTroveInfo(address _troveOwner)\n        external\n        view\n        returns (\n            uint256 troveStatus,\n            uint256 collAmount,\n            uint256 debtAmount,\n            uint256 collPrice,\n            uint256 TCRatio,\n            uint256 borrowingFeeWithDecay,\n            bool recoveryMode\n        )\n    {\n        troveStatus = TroveManager.getTroveStatus(_troveOwner);\n        collAmount = TroveManager.getTroveColl(_troveOwner);\n        debtAmount = TroveManager.getTroveDebt(_troveOwner);\n        collPrice = PriceFeed.lastGoodPrice();\n        TCRatio = TroveManager.getTCR(collPrice);\n        borrowingFeeWithDecay = TroveManager.getBorrowingRateWithDecay();\n        recoveryMode = TroveManager.checkRecoveryMode(collPrice);\n    }\n\n    function getInsertPosition(\n        uint256 _collAmount,\n        uint256 _debtAmount,\n        uint256 _numTrials,\n        uint256 _inputRandomSeed\n    ) external view returns (address upperHint, address lowerHint) {\n        uint256 NICR = _collAmount.mul(1e20).div(_debtAmount);\n        (address hintAddress, , ) = HintHelpers.getApproxHint(NICR, _numTrials, _inputRandomSeed);\n        (upperHint, lowerHint) = SortedTroves.findInsertPosition(NICR, hintAddress, hintAddress);\n    }\n\n    function getInsertPositionForTrove(\n        uint256 _collAmount,\n        uint256 _debtAmount,\n        uint256 _numTrials,\n        uint256 _inputRandomSeed,\n        address _troveOwner\n    ) external view returns (address upperHint, address lowerHint) {\n        uint256 NICR = _collAmount.mul(1e20).div(_debtAmount);\n        (address hintAddress, , ) = HintHelpers.getApproxHint(NICR, _numTrials, _inputRandomSeed);\n        (upperHint, lowerHint) = SortedTroves.findInsertPosition(NICR, hintAddress, hintAddress);\n\n        if (upperHint == _troveOwner) upperHint = SortedTroves.getPrev(_troveOwner);\n        if (lowerHint == _troveOwner) lowerHint = SortedTroves.getNext(_troveOwner);\n    }\n\n    function getRedemptionHints(\n        uint _LUSDamount, \n        uint _price,\n        uint _maxIterations\n    )\n        external\n        view\n        returns (\n        address firstRedemptionHint,\n        uint partialRedemptionHintNICR,\n        uint truncatedLUSDamount\n    ) {\n        return HintHelpers.getRedemptionHints(_LUSDamount, _price, _maxIterations);\n    }\n    \n    function getStakeInfo(address _user) external view returns (uint256 stake, uint256 ethGain, uint256 lusdGain) {\n        stake = LQTYStaking.stakes(_user);\n        ethGain = LQTYStaking.getPendingETHGain(_user);\n        lusdGain = LQTYStaking.getPendingLUSDGain(_user);\n    }\n    \n    function getDepositorInfo(address _depositor) external view returns(uint256 compoundedLUSD, uint256 ethGain, uint256 lqtyGain) {\n        compoundedLUSD = StabilityPool.getCompoundedLUSDDeposit(_depositor);\n        ethGain = StabilityPool.getDepositorETHGain(_depositor);\n        lqtyGain = StabilityPool.getDepositorLQTYGain(_depositor);\n    }\n\n    /// @notice Returns the debt in front of the users trove in the sorted list\n    /// @param _of Address of the trove owner\n    /// @param _acc Accumulated sum used in subsequent calls, 0 for first call\n    /// @param _iterations Maximum number of troves to traverse\n    /// @return next Trove owner address to be used in the subsequent call, address(0) at the end of list\n    /// @return debt Accumulated debt to be used in the subsequent call\n    function getDebtInFront(address _of, uint256 _acc, uint256 _iterations) external view returns (address next, uint256 debt) {\n        next = _of;\n        debt = _acc;\n        for (uint256 i = 0; i < _iterations && next != address(0); i++) {\n            next = SortedTroves.getNext(next);\n            debt = debt.add(TroveManager.getTroveDebt(next));\n        }\n    }\n\n    /// @notice Returns the debt in front of the potential trove with a targetRatio\n    /// @param _of Address of the trove from which we are starting (either address(0) or what this function return in next)\n    /// @param _acc Accumulated sum used in subsequent calls, 0 for first call\n    /// @param _iterations Maximum number of troves to traverse\n    /// @param _targetRatio Ratio * 1e16\n    /// @return next Trove owner address to be used in the subsequent call, address(0) if debtInFront is calculated fully for inputted ratio\n    /// @return debt Accumulated debt to be used in the subsequent call\n    function getDebtInFrontByRatio(address _of, uint256 _acc, uint256 _iterations, uint256 _targetRatio) external returns (address next, uint256 debt) {\n        uint256 collPrice = PriceFeed.fetchPrice();\n        if (_of == address(0)) {\n            next = SortedTroves.getLast();\n        } else {\n            next = _of;\n        }\n        debt = _acc;\n        for (uint256 i = 0; i < _iterations && next != address(0); i++) {\n            uint256 collAmount = TroveManager.getTroveColl(next);\n            uint256 debtAmount = TroveManager.getTroveDebt(next);\n            uint256 ratio = wdiv(wmul(collAmount, collPrice), debtAmount);\n\n            if (ratio > _targetRatio) return (address(0), debt);\n\n            debt = debt + debtAmount;\n            next = SortedTroves.getPrev(next);\n        }\n    }\n}\n", "ABI": "[{\"inputs\":[],\"name\":\"BorrowerOperations\",\"outputs\":[{\"internalType\":\"contract IBorrowerOperations\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CBManager\",\"outputs\":[{\"internalType\":\"contract IChickenBondManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CollSurplusPool\",\"outputs\":[{\"internalType\":\"contract ICollSurplusPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HintHelpers\",\"outputs\":[{\"internalType\":\"contract IHintHelpers\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LQTYStaking\",\"outputs\":[{\"internalType\":\"contract ILQTYStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LUSD_GAS_COMPENSATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DEBT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PriceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StabilityPool\",\"outputs\":[{\"internalType\":\"contract IStabilityPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TroveManager\",\"outputs\":[{\"internalType\":\"contract ITroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"}],\"name\":\"computeNICR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ICR\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_prevId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nextId\",\"type\":\"address\"}],\"name\":\"findInsertPosition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upperHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lowerHint\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_CR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numTrials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputRandomSeed\",\"type\":\"uint256\"}],\"name\":\"getApproxHint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"hintAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"diff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestRandomSeed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_acc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_iterations\",\"type\":\"uint256\"}],\"name\":\"getDebtInFront\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_of\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_acc\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_iterations\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_targetRatio\",\"type\":\"uint256\"}],\"name\":\"getDebtInFrontByRatio\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"getDepositorInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"compoundedLUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethGain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lqtyGain\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numTrials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputRandomSeed\",\"type\":\"uint256\"}],\"name\":\"getInsertPosition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upperHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lowerHint\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numTrials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputRandomSeed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_troveOwner\",\"type\":\"address\"}],\"name\":\"getInsertPositionForTrove\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upperHint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lowerHint\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_LUSDamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxIterations\",\"type\":\"uint256\"}],\"name\":\"getRedemptionHints\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"firstRedemptionHint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"partialRedemptionHintNICR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"truncatedLUSDamount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStakeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethGain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lusdGain\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_troveOwner\",\"type\":\"address\"}],\"name\":\"getTroveInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"troveStatus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TCRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowingFeeWithDecay\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"recoveryMode\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRecoveryMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_troveOwner\",\"type\":\"address\"},{\"internalType\":\"enum LiquityView.CollChange\",\"name\":\"collChangeAction\",\"type\":\"uint8\"},{\"internalType\":\"enum LiquityView.DebtChange\",\"name\":\"debtChangeAction\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_collAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lusdAmount\",\"type\":\"uint256\"}],\"name\":\"predictNICRForAdjust\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"NICR\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LiquityView", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}