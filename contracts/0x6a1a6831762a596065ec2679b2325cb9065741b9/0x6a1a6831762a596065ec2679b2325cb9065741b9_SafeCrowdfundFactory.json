{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/funding/simpleproxy/SafeI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.15;\\n\\ninterface SafeI {\\n    function isOwner(address owner) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/funding/simpleproxy/SafeProxyFactoryI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface SafeProxyFactoryI {\\n    function createProxyWithCallback(address mastercopy, bytes memory initializer, uint256 saltNonce, address callback) external returns (address proxy);\\n}\\n\"\r\n    },\r\n    \"contracts/funding/simpleproxy/v3/IMembershipNftV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.15;\\n\\nimport \\\"../SafeI.sol\\\";\\n\\ninterface MembershipNftV3I {\\n    struct TokenEdition {\\n        // The maximum number of tokens that can be sold. 0 for open edition.\\n        uint256 tokenId;\\n        // block.timestamp when the sale end. 0 for no ending time.\\n        uint256 editionId;\\n        // current owner of this token\\n        address owner;\\n        // block.timestamp when the sale starts. 0 for immediate mint availability.\\n        uint256 serialNumber;\\n        // The voting power to be used by another smart contract interactions\\n        uint256 votingPower;\\n    }\\n\\n    function getTokenById(uint256 tokenId) external view returns (TokenEdition memory);\\n\\n    function getTokenByIndex(uint256 index) external view returns (TokenEdition memory);\\n\\n    function version() external pure returns (string memory);\\n\\n    struct Edition {\\n        // The maximum number of tokens that can be sold. 0 for open edition.\\n        uint256 quantity;\\n        // block.timestamp when the sale end. 0 for no ending time.\\n        uint closedAt;\\n        // block.timestamp when the sale starts. 0 for immediate mint availability.\\n        uint opensAt;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        // The number of tokens sold so far.\\n        uint256 numSold;\\n        // The voting power to be used by another smart contract interactions\\n        uint256 votingPower;\\n        // optional root hash of the allowlist merkle tree\\n        bytes32 allowlistRoot;\\n        // The maximum number of tokens that can be minted per wallet. 0 for no limit.\\n        uint256 maxMintPerWallet;\\n    }\\n\\n    /// @notice Create a new edition with a tier struct\\n    struct EditionTier {\\n        /// The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        /// The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        // The voting power to be used by another smart contract interactions\\n        uint256 votingPower;\\n        /// block.timestamp when the sale end. 0 for no ending time.\\n        uint closedAt;\\n        /// block.timestamp when the sale starts. 0 for no starting time.\\n        uint opensAt;\\n        // optional root hash of the allowlist merkle tree\\n        bytes32 allowlistRoot;\\n        // The maximum number of tokens that can be minted per wallet. 0 for no limit.\\n        uint256 maxMintPerWallet;\\n    }\\n\\n    /// @notice Create one or more editions. Only vault signers can call this\\n    /// @param tiers The tiers to create\\n    /// @param minter The address that will be able to mint tokens\\n    function createEditions(\\n        EditionTier[] memory tiers,\\n        address minter\\n    ) external;\\n\\n    /// @notice Mint tokens from an edition.\\n    function buyEdition(uint256 editionId, address recipient, uint256 amount)\\n    external\\n    returns (uint256 tokenId);\\n\\n    // @notice The owning vault of this contract\\n    function vault() external view returns (SafeI);\\n\\n    /// @notice initialize the contract with no tiers\\n    function initialize(\\n        address _owner,\\n        address _vault,\\n        string memory name,\\n        string memory symbol,\\n        string memory baseUrlIn)\\n    external;\\n\\n    /// @notice initialize the contract with tiers\\n    function initializeEditions(\\n        address _owner,\\n        address _vault,\\n        string memory name,\\n        string memory symbol,\\n        string memory baseUrlIn,\\n        EditionTier[] memory tiers,\\n        address _minter)\\n    external;\\n\\n    /// @notice Get edition info about an edition\\n    function getEdition(uint256 editionId) external view returns (Edition memory);\\n\\n    /// @notice Get the number of tokens a wallet has minted from an edition.\\n    function getWalletMintCount(address wallet, uint256 editionId) external view returns (uint256);\\n\\n    function adminAirdrop(address[] memory wallets, uint256[] memory editionIds, uint256[] memory amounts) external;\\n}\"\r\n    },\r\n    \"contracts/funding/simpleproxy/v3/MNFTFactoryV3I.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.15;\\n\\ninterface MNFTFactoryV3I {\\n    // @notice Create a clone of a contract and call an initializer function on it\\n    function createWithInitializer(bytes calldata callData) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/funding/simpleproxy/v3/SafeCrowdfundFactoryV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.15;\\n\\nimport \\\"../SafeProxyFactoryI.sol\\\";\\nimport \\\"./MNFTFactoryV3I.sol\\\";\\nimport \\\"./IMembershipNftV3.sol\\\";\\n\\n/// @notice Create a safe and lore crowdfund in one transaction\\ncontract SafeCrowdfundFactoryV3 {\\n    function create(\\n        address safeFactory,\\n        bytes calldata safeFactoryCalldata,\\n        address mnftFactory,\\n        address owner, string memory name, string memory symbol, string memory baseUrlIn\\n    )\\n    external\\n    returns (MembershipNftV3I){\\n        address safeProxy = callAndGetAddress(safeFactory, safeFactoryCalldata);\\n        //create the crowdfund with the new safe address passed in\\n\\n        MNFTFactoryV3I crowdfundFactory = MNFTFactoryV3I(mnftFactory);\\n\\n        bytes memory encodedCall = abi.encodeWithSignature(\\\"initialize(address,address,string,string,string)\\\", owner, safeProxy, name, symbol, baseUrlIn);\\n        return MembershipNftV3I(crowdfundFactory.createWithInitializer(encodedCall));\\n    }\\n\\n    function createWithEditions(\\n        address safeFactory,\\n        bytes calldata safeFactoryCalldata,\\n        address mnftFactory,\\n        address owner, string memory name, string memory symbol, string memory baseUrlIn,\\n        MembershipNftV3I.EditionTier[] memory tiers,\\n        address _minter\\n    )\\n    external\\n    returns (MembershipNftV3I){\\n        address safeProxy = callAndGetAddress(safeFactory, safeFactoryCalldata);\\n        //create the crowdfund with the new safe address passed in\\n        MNFTFactoryV3I crowdfundFactory = MNFTFactoryV3I(mnftFactory);\\n        // map uint->uint256 and struct->tuple[]\\n        bytes memory encodedCall = abi.encodeWithSignature(\\\"initializeEditions(address,address,string,string,string,(uint256,uint256,uint256,uint256,uint256,bytes32,uint256)[],address)\\\", owner, safeProxy, name, symbol, baseUrlIn, tiers, _minter);\\n        return MembershipNftV3I(crowdfundFactory.createWithInitializer(encodedCall));\\n    }\\n\\n    function callAndGetAddress(\\n        address contractAddress,\\n        bytes calldata callData\\n    ) internal returns (address){\\n        (bool success, bytes memory data) = contractAddress.call{value: 0}(callData);\\n        require(success, \\\"call failed\\\");\\n        (address addr) = abi.decode(data, (address));\\n        return addr;\\n    }\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeFactory\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"safeFactoryCalldata\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"mnftFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseUrlIn\",\"type\":\"string\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"contract MembershipNftV3I\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"safeFactory\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"safeFactoryCalldata\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"mnftFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseUrlIn\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votingPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"opensAt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"allowlistRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxMintPerWallet\",\"type\":\"uint256\"}],\"internalType\":\"struct MembershipNftV3I.EditionTier[]\",\"name\":\"tiers\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"createWithEditions\",\"outputs\":[{\"internalType\":\"contract MembershipNftV3I\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SafeCrowdfundFactoryV3", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}