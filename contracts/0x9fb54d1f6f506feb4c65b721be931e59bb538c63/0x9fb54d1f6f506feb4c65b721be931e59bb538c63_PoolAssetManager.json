{"SourceCode": "// Sources flattened with hardhat v2.11.1 https://hardhat.org\r\n\r\n// File src/base/Multicall.sol\r\n\r\nuint256 constant NUM_STABLE_COINS = 2;\r\n\r\npragma solidity 0.8.13;\r\n\r\n/// @title  Multicall\r\n/// @author Uniswap Labs\r\n///\r\n/// @notice Enables calling multiple methods in a single call to the contract\r\nabstract contract Multicall {\r\n    error MulticallFailed(bytes data, bytes result);\r\n\r\n    function multicall(\r\n        bytes[] calldata data\r\n    ) external payable returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        for (uint256 i = 0; i < data.length; ++i) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n            if (!success) {\r\n                revert MulticallFailed(data[i], result);\r\n            }\r\n\r\n            results[i] = result;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File src/base/ErrorMessages.sol\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice An error used to indicate that an argument passed to a function is illegal or\r\n///         inappropriate.\r\n///\r\n/// @param message The error message.\r\nerror IllegalArgument(string message);\r\n\r\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\r\n///\r\n/// @param message The error message.\r\nerror IllegalState(string message);\r\n\r\n/// @notice An error used to indicate that an operation is unsupported.\r\n///\r\n/// @param message The error message.\r\nerror UnsupportedOperation(string message);\r\n\r\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\r\n///\r\n/// @param message The error message.\r\nerror Unauthorized(string message);\r\n\r\n\r\n// File src/base/MutexLock.sol\r\n\r\npragma solidity 0.8.13;\r\n\r\n/// @title  Mutex\r\n/// @author Alchemix Finance\r\n///\r\n/// @notice Provides a mutual exclusion lock for implementing contracts.\r\nabstract contract MutexLock {\r\n    enum State {\r\n        RESERVED,\r\n        UNLOCKED,\r\n        LOCKED\r\n    }\r\n\r\n    /// @notice The lock state.\r\n    State private _lockState = State.UNLOCKED;\r\n\r\n    /// @dev A modifier which acquires the mutex.\r\n    modifier lock() {\r\n        _claimLock();\r\n\r\n        _;\r\n\r\n        _freeLock();\r\n    }\r\n\r\n    /// @dev Gets if the mutex is locked.\r\n    ///\r\n    /// @return if the mutex is locked.\r\n    function _isLocked() internal view returns (bool) {\r\n        return _lockState == State.LOCKED;\r\n    }\r\n\r\n    /// @dev Claims the lock. If the lock is already claimed, then this will revert.\r\n    function _claimLock() internal {\r\n        // Check that the lock has not been claimed yet.\r\n        if (_lockState != State.UNLOCKED) {\r\n            revert IllegalState(\"Lock already claimed\");\r\n        }\r\n\r\n        // Claim the lock.\r\n        _lockState = State.LOCKED;\r\n    }\r\n\r\n    /// @dev Frees the lock.\r\n    function _freeLock() internal {\r\n        _lockState = State.UNLOCKED;\r\n    }\r\n}\r\n\r\n\r\n// File src/interfaces/IERC20Metadata.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/// @title  IERC20Metadata\r\n/// @author Alchemix Finance\r\ninterface IERC20Metadata {\r\n    /// @notice Gets the name of the token.\r\n    ///\r\n    /// @return The name.\r\n    function name() external view returns (string memory);\r\n\r\n    /// @notice Gets the symbol of the token.\r\n    ///\r\n    /// @return The symbol.\r\n    function symbol() external view returns (string memory);\r\n\r\n    /// @notice Gets the number of decimals that the token has.\r\n    ///\r\n    /// @return The number of decimals.\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File src/libraries/SafeERC20.sol\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @title  SafeERC20\r\n/// @author Alchemix Finance\r\nlibrary SafeERC20 {\r\n    /// @notice An error used to indicate that a call to an ERC20 contract failed.\r\n    ///\r\n    /// @param target  The target address.\r\n    /// @param success If the call to the token was a success.\r\n    /// @param data    The resulting data from the call. This is error data when the call was not a\r\n    ///                success. Otherwise, this is malformed data when the call was a success.\r\n    error ERC20CallFailed(address target, bool success, bytes data);\r\n\r\n    /// @dev A safe function to get the decimals of an ERC20 token.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token The target token.\r\n    ///\r\n    /// @return The amount of decimals of the token.\r\n    function expectDecimals(address token) internal view returns (uint8) {\r\n        (bool success, bytes memory data) = token.staticcall(\r\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\r\n        );\r\n\r\n        if (!success || data.length < 32) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n\r\n        return abi.decode(data, (uint8));\r\n    }\r\n\r\n    /// @dev Transfers tokens to another address.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer failed or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token     The token to transfer.\r\n    /// @param recipient The address of the recipient.\r\n    /// @param amount    The amount of tokens to transfer.\r\n    function safeTransfer(address token, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, recipient, amount)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n\r\n    /// @dev Approves tokens for the smart contract.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the approval fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token   The token to approve.\r\n    /// @param spender The contract to spend the tokens.\r\n    /// @param value   The amount of tokens to approve.\r\n    function safeApprove(address token, address spender, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, spender, value)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another address.\r\n    ///\r\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer fails or returns an\r\n    ///      unexpected value.\r\n    ///\r\n    /// @param token     The token to transfer.\r\n    /// @param owner     The address of the owner.\r\n    /// @param recipient The address of the recipient.\r\n    /// @param amount    The amount of tokens to transfer.\r\n    function safeTransferFrom(address token, address owner, address recipient, uint256 amount) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(IERC20.transferFrom.selector, owner, recipient, amount)\r\n        );\r\n\r\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\r\n            revert ERC20CallFailed(token, success, data);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File src/interfaces/IERC20TokenReceiver.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n/// @title  IERC20TokenReceiver\r\n/// @author Alchemix Finance\r\ninterface IERC20TokenReceiver {\r\n    /// @notice Informs implementors of this interface that an ERC20 token has been transferred.\r\n    ///\r\n    /// @param token The token that was transferred.\r\n    /// @param value The amount of the token that was transferred.\r\n    function onERC20Received(address token, uint256 value) external;\r\n}\r\n\r\n\r\n// File src/interfaces/external/convex/IConvexStakingWrapper.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IConvexStakingWrapper {\r\n    function deposit(uint256 amount, address to) external;\r\n    function withdraw(uint256 amount) external;\r\n    function withdrawAndUnwrap(uint256 _amount) external;\r\n}\r\n\r\n\r\n// File src/interfaces/external/curve/IStableSwap2Pool.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\nuint256 constant N_COINS = 2;\r\n\r\ninterface IStableSwap2Pool {\r\n    function coins(uint256 index) external view returns (address);\r\n\r\n    function A() external view returns (uint256);\r\n\r\n    function get_virtual_price() external view returns (uint256);\r\n\r\n    function calc_token_amount(\r\n        uint256[N_COINS] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256 amount);\r\n\r\n    function add_liquidity(uint256[N_COINS] calldata amounts, uint256 minimumMintAmount) external;\r\n\r\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\r\n\r\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\r\n\r\n    function exchange(\r\n        int128 i,\r\n        int128 j,\r\n        uint256 dx,\r\n        uint256 minimumDy\r\n    ) external payable returns (uint256);\r\n\r\n    function remove_liquidity(uint256 amount, uint256[N_COINS] calldata minimumAmounts, address receiver) external returns (uint256[] memory);\r\n\r\n    function remove_liquidity_imbalance(\r\n        uint256[N_COINS] calldata amounts,\r\n        uint256 maximumBurnAmount\r\n    ) external;\r\n\r\n    function calc_withdraw_one_coin(uint256 tokenAmount, int128 i) external view returns (uint256);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256 tokenAmount,\r\n        int128 i,\r\n        uint256 minimumAmount\r\n    ) external;\r\n}\r\n\r\n\r\n// File src/interfaces/external/convex/IConvexFraxFarm.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IConvexFraxFarm {\r\n    function withdrawLocked(bytes32 kek_id, address destination_address)  external returns (uint256);\r\n    function stakeLocked(uint256 liquidity, uint256 secs) external returns (bytes32);\r\n    function earned(address account) external view returns (uint256[] memory);\r\n    function getReward(address destination_address) external returns (uint256[] memory);\r\n    function combinedWeightOf(address account) external view returns (uint256);\r\n    function lockedLiquidityOf(address account) external view returns (uint256);\r\n}\r\n\r\n\r\n// File src/interfaces/external/convex/IConvexFraxVault.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IConvexFraxVault {\r\n    function stakeLockedCurveLp(uint256 liquidity, uint256 secs) external returns (bytes32 kekId);\r\n    function stakeLocked(uint256 liquidity, uint256 secs) external returns (bytes32 kekId);\r\n    function withdrawLockedAndUnwrap(bytes32 kekId) external;\r\n    function getReward() external;\r\n    function earned() external view returns (address[] memory tokenAddresses, uint256[] memory totalEarned);\r\n}\r\n\r\n\r\n// File src/interfaces/external/convex/IConvexRewards.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IConvexRewards {\r\n    function rewardToken() external view returns (IERC20);\r\n    function earned(address account) external view returns (uint256);\r\n    function extraRewards(uint256 index) external view returns (address);\r\n    function balanceOf(address account) external returns(uint256);\r\n    function withdraw(uint256 amount, bool claim) external returns (bool);\r\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);\r\n    function getReward() external returns (bool);\r\n    function getReward(address recipient, bool claim) external returns (bool);\r\n    function stake(uint256 amount) external returns (bool);\r\n    function stakeFor(address account, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\n// File src/interfaces/external/convex/IConvexFraxBooster.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IConvexFraxBooster {\r\n    function createVault(uint256 _pid) external returns (address);\r\n}\r\n\r\n\r\n// File src/interfaces/external/convex/IConvexToken.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IConvexToken is IERC20 {\r\n    function maxSupply() external view returns (uint256);\r\n    function totalCliffs() external view returns (uint256);\r\n    function reductionPerCliff() external view returns (uint256);\r\n}\r\n\r\n\r\n// File src/PoolAssetManager.sol\r\n\r\npragma solidity 0.8.13;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @notice A struct used to define initialization parameters. This is not included\r\n///         in the contract to prevent naming collisions.\r\nstruct InitializationParams {\r\n    address admin;\r\n    address operator;\r\n    address rewardReceiver;\r\n    address transmuterBuffer;\r\n    IERC20 fraxShareToken;\r\n    IERC20 curveToken;\r\n    IStableSwap2Pool twoPool;\r\n    uint256 twoPoolSlippage;\r\n    IConvexToken convexToken;\r\n    IConvexStakingWrapper convexStakingWrapper;\r\n    IConvexFraxBooster convexFraxBooster;\r\n    uint256 convexPoolId;\r\n}\r\n\r\nstruct LockParams {\r\n    uint256 amount;\r\n    uint256 timeLocked;\r\n}\r\n\r\n/// @dev The amount of precision that slippage parameters have.\r\nuint256 constant SLIPPAGE_PRECISION = 1e4;\r\n\r\n/// @dev The amount of precision that curve pools use for price calculations.\r\nuint256 constant CURVE_PRECISION = 1e18;\r\n\r\nuint256 constant MINIMUM_LOCK_TIME = 604800;\r\n\r\n/// @notice Enumerations for FRAX/USDC two pool assets.\r\n///\r\n/// @dev Do not change the order of these fields.\r\nenum PoolAsset {\r\n    ALETH, FRXETH\r\n}\r\n\r\n/// @title  PoolAssetManager\r\n/// @author Alchemix Finance\r\ncontract PoolAssetManager is Multicall, MutexLock, IERC20TokenReceiver {\r\n    /// @notice Emitted when the admin is updated.\r\n    ///\r\n    /// @param admin The admin.\r\n    event AdminUpdated(address admin);\r\n\r\n    /// @notice Emitted when the pending admin is updated.\r\n    ///\r\n    /// @param pendingAdmin The pending admin.\r\n    event PendingAdminUpdated(address pendingAdmin);\r\n\r\n    /// @notice Emitted when the operator is updated.\r\n    ///\r\n    /// @param operator The operator.\r\n    event OperatorUpdated(address operator);\r\n\r\n    /// @notice Emitted when the reward receiver is updated.\r\n    ///\r\n    /// @param rewardReceiver The reward receiver.\r\n    event RewardReceiverUpdated(address rewardReceiver);\r\n\r\n    /// @notice Emitted when the transmuter buffer is updated.\r\n    ///\r\n    /// @param transmuterBuffer The transmuter buffer.\r\n    event TransmuterBufferUpdated(address transmuterBuffer);\r\n\r\n    /// @notice Emitted when the 2pool slippage is updated.\r\n    ///\r\n    /// @param twoPoolSlippage The 2pool slippage.\r\n    event TwoPoolSlippageUpdated(uint256 twoPoolSlippage);\r\n\r\n    /// @notice Emitted when 2pool tokens are minted.\r\n    ///\r\n    /// @param amounts               The amounts of each 2pool asset used to mint liquidity.\r\n    /// @param mintedTwoPoolTokens The amount of 2pool tokens minted.\r\n    event MintTwoPoolTokens(uint256[NUM_STABLE_COINS] amounts, uint256 mintedTwoPoolTokens);\r\n\r\n    /// @notice Emitted when 2pool tokens are minted.\r\n    ///\r\n    /// @param asset                 The 2pool asset used to mint 2pool tokens.\r\n    /// @param amount                The amount of the asset used to mint 2pool tokens.\r\n    /// @param mintedTwoPoolTokens The amount of 2pool tokens minted.\r\n    event MintTwoPoolTokens(PoolAsset asset, uint256 amount, uint256 mintedTwoPoolTokens);\r\n\r\n    /// @notice Emitted when 2pool tokens are burned.\r\n    ///\r\n    /// @param asset     The 2pool asset that was received.\r\n    /// @param amount    The amount of 2pool tokens that were burned.\r\n    /// @param withdrawn The amount of the 2pool asset that was withdrawn.\r\n    event BurnTwoPoolTokens(PoolAsset asset, uint256 amount, uint256 withdrawn);\r\n\r\n    /// @notice Emitted when meta pool tokens are deposited into convex.\r\n    ///\r\n    /// @param amount  The amount of meta pool tokens that were deposited.\r\n    /// @param id      The ID of the new lock.\r\n    /// @param success If the operation was successful.\r\n    event DepositTwoPoolTokens(uint256 amount, bytes32 id, bool success);\r\n\r\n    /// @notice Emitted when meta pool tokens are withdrawn from convex.\r\n    ///\r\n    /// @param amount  The amount of meta pool tokens that were withdrawn.\r\n    /// @param success If the operation was successful.\r\n    event WithdrawTwoPoolTokens(uint256 amount, bool success);\r\n\r\n    /// @notice Emitted when convex rewards are claimed.\r\n    ///\r\n    /// @param success      If the operation was successful.\r\n    /// @param amountFxs    The amount of frax share tokens sent to the reward recipient.\r\n    /// @param amountCurve  The amount of curve tokens sent to the reward recipient.\r\n    /// @param amountConvex The amount of convex tokens sent to the reward recipient.\r\n    event ClaimRewards(bool success, uint256 amountFxs, uint256 amountCurve, uint256 amountConvex);\r\n\r\n    /// @notice Emitted when 2pool assets are sent to the transmuter buffer.\r\n    ///\r\n    /// @param asset  The 2pool asset that was reclaimed.\r\n    /// @param amount The amount of the asset that was reclaimed.\r\n    event ReclaimTwoPoolAsset(PoolAsset asset, uint256 amount);\r\n\r\n    /// @notice The admin.\r\n    address public admin;\r\n\r\n    /// @notice The current pending admin.\r\n    address public pendingAdmin;\r\n\r\n    /// @notice The operators.\r\n    mapping(address => bool) public operators;\r\n\r\n    // @notice The reward receiver.\r\n    address public rewardReceiver;\r\n\r\n    /// @notice The transmuter buffer.\r\n    address public transmuterBuffer;\r\n\r\n    /// @notice The frax share token.\r\n    IERC20 public immutable fraxShareToken;\r\n\r\n    /// @notice The curve token.\r\n    IERC20 public immutable curveToken;\r\n\r\n    /// @notice The 2pool contract.\r\n    IStableSwap2Pool public immutable twoPool;\r\n\r\n    /// @notice The amount of slippage that will be tolerated when depositing and withdrawing assets\r\n    ///         from the stable swap pool. In units of basis points.\r\n    uint256 public twoPoolSlippage;\r\n\r\n    /// @notice The convex token.\r\n    IConvexToken public immutable convexToken;\r\n\r\n    /// @notice The staking wrapper.\r\n    IConvexStakingWrapper public immutable convexStakingWrapper;\r\n\r\n    /// @notice The convex booster contract.\r\n    IConvexFraxBooster public immutable convexFraxBooster;\r\n\r\n    /// @notice The address of the vault created during the contructor.\r\n    IConvexFraxVault public convexFraxVault;\r\n\r\n    /// @notice The convex pool identifier.\r\n    uint256 public immutable convexPoolId;\r\n\r\n    /// @notice the kek_id of the twoPool token deposit.\r\n    mapping (bytes32 => LockParams) public kekId;\r\n\r\n    /// @dev A cache of the tokens that the stable swap pool supports.\r\n    IERC20[NUM_STABLE_COINS] private _twoPoolAssetCache;\r\n\r\n    /// @dev A modifier which reverts if the message sender is not the admin.\r\n    modifier onlyAdmin() {\r\n        if (msg.sender != admin) {\r\n            revert Unauthorized(\"Not admin\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev A modifier which reverts if the message sender is not the operator.\r\n    modifier onlyOperator() {\r\n        if (!operators[msg.sender]) {\r\n            revert Unauthorized(\"Not operator\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(InitializationParams memory params) {\r\n        admin                   = params.admin;\r\n        rewardReceiver          = params.rewardReceiver;\r\n        transmuterBuffer        = params.transmuterBuffer;\r\n        fraxShareToken          = params.fraxShareToken;\r\n        curveToken              = params.curveToken;\r\n        twoPool                 = params.twoPool;\r\n        twoPoolSlippage         = params.twoPoolSlippage;\r\n        convexToken             = params.convexToken;\r\n        convexStakingWrapper    = params.convexStakingWrapper;\r\n        convexFraxBooster       = params.convexFraxBooster;\r\n        convexPoolId            = params.convexPoolId;\r\n\r\n        operators[params.operator] = true;\r\n\r\n        convexFraxVault = IConvexFraxVault(convexFraxBooster.createVault(convexPoolId));\r\n\r\n        for (uint256 i = 0; i < NUM_STABLE_COINS; i++) {\r\n            _twoPoolAssetCache[i] = IERC20(params.twoPool.coins(i));\r\n        }\r\n\r\n        emit AdminUpdated(admin);\r\n        emit OperatorUpdated(params.operator);\r\n        emit RewardReceiverUpdated(rewardReceiver);\r\n        emit TransmuterBufferUpdated(transmuterBuffer);\r\n        emit TwoPoolSlippageUpdated(twoPoolSlippage);\r\n    }\r\n\r\n    /// @notice Gets the amount of a 2pool asset that this contract has in reserves.\r\n    ///\r\n    /// @param asset The 2pool asset.\r\n    ///\r\n    /// @return The reserves.\r\n    function twoPoolAssetReserves(PoolAsset asset) external view returns (uint256) {\r\n        IERC20 token = getTokenForTwoPoolAsset(asset);\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /// @notice Gets the amount of a 2pool asset that one alUSD is worth.\r\n    ///\r\n    /// @param asset The 2pool asset.\r\n    ///\r\n    /// @return The amount of the underying.\r\n    function exchangeRate(PoolAsset asset) public view returns (uint256) {\r\n        return twoPool.calc_withdraw_one_coin(1e18, int128(uint128(uint256(asset))));\r\n    }\r\n\r\n    /// @notice Gets the ERC20 token associated with a 2pool asset.\r\n    ///\r\n    /// @param asset The asset to get the token for.\r\n    ///\r\n    /// @return The token.\r\n    function getTokenForTwoPoolAsset(PoolAsset asset) public view returns (IERC20) {\r\n        uint256 index = uint256(asset);\r\n        if (index >= NUM_STABLE_COINS) {\r\n            revert IllegalArgument(\"Asset index out of bounds\");\r\n        }\r\n        return _twoPoolAssetCache[index];\r\n    }\r\n\r\n    /// @notice Begins the 2-step process of setting the administrator.\r\n    ///\r\n    /// The caller must be the admin. Setting the pending timelock to the zero address will stop\r\n    /// the process of setting a new timelock.\r\n    ///\r\n    /// @param value The value to set the pending timelock to.\r\n    function setPendingAdmin(address value) external onlyAdmin {\r\n        pendingAdmin = value;\r\n        emit PendingAdminUpdated(value);\r\n    }\r\n\r\n    /// @notice Completes the 2-step process of setting the administrator.\r\n    ///\r\n    /// The pending admin must be set and the caller must be the pending admin. After this function\r\n    /// is successfully executed, the admin will be set to the pending admin and the pending admin\r\n    /// will be reset.\r\n    function acceptAdmin() external {\r\n        if (pendingAdmin == address(0)) {\r\n            revert IllegalState(\"Pending admin unset\");\r\n        }\r\n\r\n        if (pendingAdmin != msg.sender) {\r\n            revert Unauthorized(\"Not pending admin\");\r\n        }\r\n\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n\r\n        emit AdminUpdated(admin);\r\n        emit PendingAdminUpdated(address(0));\r\n    }\r\n\r\n    /// @notice Sets the operator.\r\n    ///\r\n    /// The caller must be the admin.\r\n    ///\r\n    /// @param operator The address to set\r\n    /// @param value The value to set the admin to.\r\n    function setOperator(address operator, bool value) external onlyAdmin {\r\n        operators[operator] = value;\r\n        emit OperatorUpdated(operator);\r\n    }\r\n\r\n    /// @notice Sets the reward receiver.\r\n    ///\r\n    /// @param value The value to set the reward receiver to.\r\n    function setRewardReceiver(address value) external onlyAdmin {\r\n        rewardReceiver = value;\r\n        emit RewardReceiverUpdated(value);\r\n    }\r\n\r\n    /// @notice Sets the transmuter buffer.\r\n    ///\r\n    /// @param value The value to set the transmuter buffer to.\r\n    function setTransmuterBuffer(address value) external onlyAdmin {\r\n        transmuterBuffer = value;\r\n        emit TransmuterBufferUpdated(value);\r\n    }\r\n\r\n    /// @notice Sets the slippage that will be tolerated when depositing and withdrawing 2pool\r\n    ///         assets. The slippage has a resolution of 6 decimals.\r\n    ///\r\n    /// The operator is allowed to set the slippage because it is a volatile parameter that may need\r\n    /// fine adjustment in a short time window.\r\n    ///\r\n    /// @param value The value to set the slippage to.\r\n    function setTwoPoolSlippage(uint256 value) external onlyOperator {\r\n        if (value > SLIPPAGE_PRECISION) {\r\n            revert IllegalArgument(\"Slippage not in range\");\r\n        }\r\n        twoPoolSlippage = value;\r\n        emit TwoPoolSlippageUpdated(value);\r\n    }\r\n\r\n    /// @notice Mints 2pool tokens with a combination of assets.\r\n    ///\r\n    /// @param amounts The amounts of the assets to deposit.\r\n    ///\r\n    /// @return minted The number of 2pool tokens minted.\r\n    function mintTwoPoolTokens(\r\n        uint256[NUM_STABLE_COINS] calldata amounts\r\n    ) external lock onlyOperator returns (uint256 minted) {\r\n        return _mintTwoPoolTokens(amounts);\r\n    }\r\n\r\n    /// @notice Mints 2pool tokens with an asset.\r\n    ///\r\n    /// @param asset  The asset to deposit into the 2pool.\r\n    /// @param amount The amount of the asset to deposit.\r\n    ///\r\n    /// @return minted The number of 2pool tokens minted.\r\n    function mintTwoPoolTokens(\r\n        PoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256 minted) {\r\n        return _mintTwoPoolTokens(asset, amount);\r\n    }\r\n\r\n    /// @notice Burns 2pool tokens to withdraw an asset.\r\n    ///\r\n    /// @param asset  The asset to withdraw.\r\n    /// @param amount The amount of 2pool tokens to burn.\r\n    ///\r\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\r\n    function burnTwoPoolTokens(\r\n        PoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256 withdrawn) {\r\n        return _burnTwoPoolTokens(asset, amount);\r\n    }\r\n\r\n    /// @notice Deposits and stakes meta pool tokens into convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to deposit.\r\n    ///\r\n    /// @return success If the tokens were successfully deposited.\r\n    /// @return id      The ID of the new lock.\r\n    function depositTwoPoolTokens(\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (bool success, bytes32 id) {\r\n        return _depositTwoPoolTokens(amount, MINIMUM_LOCK_TIME);\r\n    }\r\n\r\n    /// @notice Deposits and stakes meta pool tokens into convex.\r\n    ///\r\n    /// @param amount The amount of meta pool tokens to deposit.\r\n    ///\r\n    /// @return success If the tokens were successfully deposited.\r\n    /// @return id      The ID of the new lock.\r\n    function depositTwoPoolTokensCustomLock(\r\n        uint256 amount,\r\n        uint256 lockTime\r\n    ) external lock onlyOperator returns (bool success, bytes32 id) {\r\n        return _depositTwoPoolTokens(amount, lockTime);\r\n    }\r\n\r\n    /// @notice Withdraws and unwraps meta pool tokens from convex.\r\n    ///\r\n    /// @param  amount  The amount of meta pool tokens to withdraw.\r\n    /// @param  id      The id of the lock to withdraw from.  \r\n    ///\r\n    /// @return success If the tokens were successfully withdrawn.\r\n    function withdrawTwoPoolTokens(\r\n        uint256 amount,\r\n        bytes32 id\r\n    ) external lock onlyOperator returns (bool success) {\r\n        return _withdrawTwoPoolTokens(amount, id);\r\n    }\r\n\r\n    /// @notice Claims convex, curve, and auxiliary rewards.\r\n    ///\r\n    /// @return success If the claim was successful.\r\n    function claimRewards() external lock onlyOperator returns (bool success) {\r\n        convexFraxVault.getReward();\r\n        success = true;\r\n\r\n        uint256 fxsBalance    = fraxShareToken.balanceOf(address(this));\r\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\r\n        uint256 convexBalance = convexToken.balanceOf(address(this));\r\n\r\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\r\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\r\n        SafeERC20.safeTransfer(address(fraxShareToken), rewardReceiver, fxsBalance);\r\n\r\n        emit ClaimRewards(success, fxsBalance, curveBalance, convexBalance);\r\n    }\r\n\r\n    /// @notice Flushes two pool assets into convex by minting 2pool tokens from the assets,\r\n    ///         minting meta pool tokens using the 2pool tokens, and then depositing the meta pool\r\n    ///         tokens into convex.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param amounts The amounts of the 2pool assets to flush.\r\n    ///\r\n    /// @return The amount of meta pool tokens deposited into convex.\r\n    function flush(\r\n        uint256[NUM_STABLE_COINS] calldata amounts\r\n    ) external lock onlyOperator returns (uint256) {\r\n        uint256 mintedTwoPoolTokens = _mintTwoPoolTokens(amounts);\r\n\r\n        (bool success,) = _depositTwoPoolTokens(mintedTwoPoolTokens, MINIMUM_LOCK_TIME);\r\n\r\n        if (!success) {\r\n            revert IllegalState(\"Deposit into convex failed\");\r\n        }\r\n\r\n        return mintedTwoPoolTokens;\r\n    }\r\n\r\n    /// @notice Flushes two pool assets into convex by minting 2pool tokens from the assets,\r\n    ///         minting meta pool tokens using the 2pool tokens, and then depositing the meta pool\r\n    ///         tokens into convex. Allows specification of locking period.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param amounts The amounts of the 2pool assets to flush.\r\n    /// @param lockTime The amount of time to lock the staked tokens.\r\n    ///\r\n    /// @return The amount of meta pool tokens deposited into convex.\r\n    function flushCustomLock(\r\n        uint256[NUM_STABLE_COINS] calldata amounts,\r\n        uint256 lockTime\r\n    ) external lock onlyOperator returns (uint256) {\r\n        uint256 mintedTwoPoolTokens = _mintTwoPoolTokens(amounts);\r\n\r\n        (bool success, ) = _depositTwoPoolTokens(mintedTwoPoolTokens, lockTime);\r\n\r\n        if (!success) {\r\n            revert IllegalState(\"Deposit into convex failed\");\r\n        }\r\n\r\n        return mintedTwoPoolTokens;\r\n    }\r\n\r\n    /// @notice Flushes a two pool asset into convex by minting 2pool tokens using the asset,\r\n    ///         minting meta pool tokens using the 2pool tokens, and then depositing the meta pool\r\n    ///         tokens into convex.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param asset  The 2pool asset to flush.\r\n    /// @param amount The amount of the 2pool asset to flush.\r\n    ///\r\n    /// @return The amount of meta pool tokens deposited into convex.\r\n    function flush(\r\n        PoolAsset asset,\r\n        uint256 amount\r\n    ) external lock onlyOperator returns (uint256) {\r\n        uint256 mintedTwoPoolTokens = _mintTwoPoolTokens(asset, amount);\r\n\r\n        (bool success,) = _depositTwoPoolTokens(mintedTwoPoolTokens, MINIMUM_LOCK_TIME);\r\n\r\n        if (!success) {\r\n            revert IllegalState(\"Deposit into convex failed\");\r\n        }\r\n\r\n        return mintedTwoPoolTokens;\r\n    }\r\n\r\n    /// @notice Flushes a two pool asset into convex by minting 2pool tokens using the asset,\r\n    ///         minting meta pool tokens using the 2pool tokens, and then depositing the meta pool\r\n    ///         tokens into convex. Allows specification of locking period.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param asset    The 2pool asset to flush.\r\n    /// @param amount   The amount of the 2pool asset to flush.\r\n    /// @param lockTime The amount of time to lock the staked tokens.\r\n    ///\r\n    /// @return The amount of meta pool tokens deposited into convex.\r\n    function flushCustomLock(\r\n        PoolAsset asset,\r\n        uint256 amount,\r\n        uint256 lockTime\r\n    ) external lock onlyOperator returns (uint256) {\r\n        uint256 mintedTwoPoolTokens = _mintTwoPoolTokens(asset, amount);\r\n\r\n        (bool success, bytes32 id) = _depositTwoPoolTokens(mintedTwoPoolTokens, lockTime);\r\n\r\n        if (!success) {\r\n            revert IllegalState(\"Deposit into convex failed\");\r\n        }\r\n\r\n        return mintedTwoPoolTokens;\r\n    }\r\n\r\n    /// @notice Recalls a two pool asset into reserves by withdrawing meta pool tokens from\r\n    ///         convex, burning the meta pool tokens for 2pool tokens, and then burning the 2pool\r\n    ///         tokens for an asset.\r\n    ///\r\n    /// This function is provided for ease of use.\r\n    ///\r\n    /// @param asset  The 2pool asset to recall.\r\n    /// @param amount The amount of the meta pool tokens to withdraw from convex and burn.\r\n    /// @param  id      The id of the lock to withdraw from.  \r\n    ///\r\n    /// @return The amount of the 2pool asset recalled.\r\n    function recall(\r\n        PoolAsset asset,\r\n        uint256 amount,\r\n        bytes32 id\r\n    ) external lock onlyOperator returns (uint256) {\r\n\r\n        if (!_withdrawTwoPoolTokens(amount, id)) {\r\n            revert IllegalState(\"Withdraw from convex failed\");\r\n        }\r\n        return _burnTwoPoolTokens(asset, amount);\r\n    }\r\n\r\n    /// @notice Recalls tokens in a balanced manner in case of an emergency\r\n    function emergencyRecall(uint256 amount, bytes32 id) external lock onlyOperator {\r\n        if (!_withdrawTwoPoolTokens(amount, id)) {\r\n            revert IllegalState(\"Withdraw from convex failed\");\r\n        }        \r\n\r\n        IERC20 twoPoolToken = IERC20(address(twoPool));\r\n\r\n        SafeERC20.safeApprove(address(twoPoolToken), address(twoPool), 0);\r\n        SafeERC20.safeApprove(address(twoPoolToken), address(twoPool), amount);\r\n\r\n        // Remove the liquidity from the pool.\r\n        uint256[2] memory minAmounts = [uint256(0), uint256(0)];\r\n        twoPool.remove_liquidity(amount, minAmounts, address(this));\r\n    }\r\n\r\n    /// @notice Reclaims a two pool asset to the transmuter buffer.\r\n    ///\r\n    /// @param asset  The 2pool asset to reclaim.\r\n    /// @param amount The amount to reclaim.\r\n    function reclaimTwoPoolAsset(PoolAsset asset, uint256 amount) public lock onlyAdmin {\r\n        IERC20 token = getTokenForTwoPoolAsset(asset);\r\n        SafeERC20.safeTransfer(address(token), transmuterBuffer, amount);\r\n\r\n        IERC20TokenReceiver(transmuterBuffer).onERC20Received(address(token), amount);\r\n\r\n        emit ReclaimTwoPoolAsset(asset, amount);\r\n    }\r\n\r\n    /// @notice Sweeps a token out of the contract to the admin.\r\n    ///\r\n    /// @param token  The token to sweep.\r\n    /// @param amount The amount of the token to sweep.\r\n    function sweep(address token, uint256 amount) external lock onlyAdmin {\r\n        SafeERC20.safeTransfer(address(token), msg.sender, amount);\r\n    }\r\n\r\n    /// @inheritdoc IERC20TokenReceiver\r\n    ///\r\n    /// @dev This function is required in order to receive tokens from the conduit.\r\n    function onERC20Received(address token, uint256 value) external { /* noop */ }\r\n\r\n    /// @dev Mints 2pool tokens with a combination of assets.\r\n    ///\r\n    /// @param amounts The amounts of the assets to deposit.\r\n    ///\r\n    /// @return minted The number of 2pool tokens minted.\r\n    function _mintTwoPoolTokens(\r\n        uint256[NUM_STABLE_COINS] calldata amounts\r\n    ) internal returns (uint256 minted) {\r\n        IERC20[NUM_STABLE_COINS] memory tokens = _twoPoolAssetCache;\r\n\r\n        IERC20 twoPoolToken = IERC20(address(twoPool));\r\n\r\n        uint256 twoPoolDecimals = SafeERC20.expectDecimals(address(twoPoolToken));\r\n        uint256 normalizedTotal   = 0;\r\n\r\n        for (uint256 i = 0; i < NUM_STABLE_COINS; i++) {\r\n            if (amounts[i] == 0) continue;\r\n\r\n            uint256 tokenDecimals   = SafeERC20.expectDecimals(address(tokens[i]));\r\n            uint256 missingDecimals = twoPoolDecimals - tokenDecimals;\r\n\r\n            normalizedTotal += amounts[i] * 10**missingDecimals;\r\n\r\n            // For assets like USDT, the approval must be first set to zero before updating it.\r\n            SafeERC20.safeApprove(address(tokens[i]), address(twoPool), 0);\r\n            SafeERC20.safeApprove(address(tokens[i]), address(twoPool), amounts[i]);\r\n        }\r\n\r\n        // Calculate what the normalized value of the tokens is.\r\n        uint256 expectedOutput = normalizedTotal * CURVE_PRECISION / twoPool.get_virtual_price();\r\n\r\n        // Calculate the minimum amount of 2pool lp tokens that we are expecting out when\r\n        // adding liquidity for all of the assets. This value is twod off the optimistic\r\n        // assumption that one of each token is approximately equal to one 2pool lp token.\r\n        uint256 minimumMintAmount = expectedOutput * twoPoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        // Record the amount of 2pool lp tokens that we start with before adding liquidity\r\n        // so that we can determine how many we minted.\r\n        uint256 startingBalance = twoPoolToken.balanceOf(address(this));\r\n\r\n        // Add the liquidity to the pool.\r\n        twoPool.add_liquidity(amounts, minimumMintAmount);\r\n\r\n        // Calculate how many 2pool lp tokens were minted.\r\n        minted = twoPoolToken.balanceOf(address(this)) - startingBalance;\r\n\r\n        emit MintTwoPoolTokens(amounts, minted);\r\n    }\r\n\r\n    /// @dev Mints 2pool tokens with an asset.\r\n    ///\r\n    /// @param asset  The asset to deposit into the 2pool.\r\n    /// @param amount The amount of the asset to deposit.\r\n    ///\r\n    /// @return minted The number of 2pool tokens minted.\r\n    function _mintTwoPoolTokens(\r\n        PoolAsset asset,\r\n        uint256 amount\r\n    ) internal returns (uint256 minted) {\r\n        IERC20 token          = getTokenForTwoPoolAsset(asset);\r\n        IERC20 twoPoolToken = IERC20(address(twoPool));\r\n\r\n        uint256 twoPoolDecimals = SafeERC20.expectDecimals(address(twoPoolToken));\r\n        uint256 missingDecimals   = twoPoolDecimals - SafeERC20.expectDecimals(address(token));\r\n\r\n        uint256[NUM_STABLE_COINS] memory amounts;\r\n        amounts[uint256(asset)] = amount;\r\n\r\n        // Calculate the minimum amount of 2pool lp tokens that we are expecting out when\r\n        // adding single sided liquidity. This value is twod off the optimistic assumption that\r\n        // one of each token is approximately equal to one 2pool lp token.\r\n        uint256 expectedOutput    = amount * CURVE_PRECISION / twoPool.get_virtual_price();\r\n        uint256 minimumMintAmount = expectedOutput * twoPoolSlippage / SLIPPAGE_PRECISION;\r\n\r\n        // Record the amount of 2pool lp tokens that we start with before adding liquidity\r\n        // so that we can determine how many we minted.\r\n        uint256 startingBalance = twoPoolToken.balanceOf(address(this));\r\n\r\n        // For assets like USDT, the approval must be first set to zero before updating it.\r\n        SafeERC20.safeApprove(address(token), address(twoPool), 0);\r\n        SafeERC20.safeApprove(address(token), address(twoPool), amount);\r\n\r\n        // Add the liquidity to the pool.\r\n        twoPool.add_liquidity(amounts, minimumMintAmount);\r\n\r\n        // Calculate how many 2pool lp tokens were minted.\r\n        minted = twoPoolToken.balanceOf(address(this)) - startingBalance;\r\n\r\n        emit MintTwoPoolTokens(asset, amount, minted);\r\n    }\r\n\r\n    /// @dev Burns 2pool tokens to withdraw an asset.\r\n    ///\r\n    /// @param asset  The asset to withdraw.\r\n    /// @param amount The amount of 2pool tokens to burn.\r\n    ///\r\n    /// @return withdrawn The amount of the asset withdrawn from the pool.\r\n    function _burnTwoPoolTokens(\r\n        PoolAsset asset,\r\n        uint256 amount\r\n    ) internal returns (uint256 withdrawn) {\r\n        IERC20 token          = getTokenForTwoPoolAsset(asset);\r\n        IERC20 twoPoolToken = IERC20(address(twoPool));\r\n\r\n        uint256 index = uint256(asset);\r\n\r\n        // Calculate the minimum amount of underlying tokens that we are expecting out when\r\n        // removing single sided liquidity. This value is twod off the optimistic assumption that\r\n        // one of each token is approximately equal to one 2pool lp token.\r\n        uint256 normalizedAmount = amount * twoPoolSlippage / SLIPPAGE_PRECISION;\r\n        uint256 minimumAmountOut   = normalizedAmount * twoPool.get_virtual_price() / CURVE_PRECISION;\r\n\r\n        // Record the amount of underlying tokens that we start with before removing liquidity\r\n        // so that we can determine how many we withdrew from the pool.\r\n        uint256 startingBalance = token.balanceOf(address(this));\r\n\r\n        SafeERC20.safeApprove(address(twoPoolToken), address(twoPool), 0);\r\n        SafeERC20.safeApprove(address(twoPoolToken), address(twoPool), amount);\r\n\r\n        // Remove the liquidity from the pool.\r\n        twoPool.remove_liquidity_one_coin(amount, int128(uint128(index)), minimumAmountOut);\r\n\r\n        // Calculate how many underlying tokens that were withdrawn.\r\n        withdrawn = token.balanceOf(address(this)) - startingBalance;\r\n\r\n        emit BurnTwoPoolTokens(asset, amount, withdrawn);\r\n    }\r\n\r\n    // /// @dev Burns 2pool tokens to withdraw an asset.\r\n    // ///\r\n    // /// @param amount The amount of 2pool tokens to burn.\r\n    // function _burnTwoPoolTokensBalanced(\r\n    //     uint256 amount,\r\n    //     uint256[2] calldata minAmounts\r\n    // ) internal {\r\n    //     IERC20 twoPoolToken = IERC20(address(twoPool));\r\n\r\n    //     SafeERC20.safeApprove(address(twoPoolToken), address(twoPool), 0);\r\n    //     SafeERC20.safeApprove(address(twoPoolToken), address(twoPool), amount);\r\n\r\n    //     // Remove the liquidity from the pool.\r\n    //     twoPool.remove_liquidity(amount, minAmounts, address(this));\r\n    // }\r\n\r\n    /// @dev Deposits and stakes meta pool tokens into convex.\r\n    ///\r\n    /// @param amount   The amount of meta pool tokens to deposit.\r\n    /// @param lockTime The time of the new lock.\r\n    ///\r\n    /// @return success If the tokens were successfully deposited.\r\n    /// @return id      The id of the new lock.\r\n    function _depositTwoPoolTokens(uint256 amount, uint256 lockTime) internal returns (bool success, bytes32 id) {\r\n        SafeERC20.safeApprove(address(twoPool), address(convexFraxVault), amount);\r\n        id = convexFraxVault.stakeLockedCurveLp(amount, lockTime);\r\n        kekId[id] = LockParams({amount: amount, timeLocked: lockTime});\r\n\r\n        success = true;\r\n\r\n        emit DepositTwoPoolTokens(amount, id, success);\r\n    }\r\n\r\n    /// @dev Withdraws and unwraps meta pool tokens from convex.\r\n    ///\r\n    /// @param amount   The amount of meta pool tokens to withdraw.\r\n    /// @param id       The id of the lock you wish to withdraw from.\r\n    ///\r\n    /// @return success If the tokens were successfully withdrawn.\r\n    function _withdrawTwoPoolTokens(uint256 amount, bytes32 id) internal returns (bool success) {\r\n        uint256 originalBalance = IERC20(address(twoPool)).balanceOf(address(this));\r\n\r\n        convexFraxVault.withdrawLockedAndUnwrap(id);\r\n\r\n        uint256 newBalance = IERC20(address(twoPool)).balanceOf(address(this));\r\n\r\n        // Frax vaults require to withdraw all meta tokens.\r\n        // We must re-stake any remaining tokens.\r\n        uint256 restakeAmount = newBalance - originalBalance - amount;\r\n\r\n        if (restakeAmount > 1) {\r\n            SafeERC20.safeApprove(address(twoPool), address(convexFraxVault), restakeAmount);\r\n            bytes32 newId = convexFraxVault.stakeLockedCurveLp(restakeAmount, MINIMUM_LOCK_TIME);\r\n            kekId[newId] = LockParams({amount: restakeAmount, timeLocked: MINIMUM_LOCK_TIME});\r\n            emit DepositTwoPoolTokens(restakeAmount, newId, success);\r\n        }\r\n\r\n        success = true;\r\n        emit WithdrawTwoPoolTokens(IERC20(address(twoPool)).balanceOf(address(this)), success);\r\n    }\r\n\r\n    /// @dev Claims convex, curve, and auxiliary rewards.\r\n    ///\r\n    /// @return success If the claim was successful.\r\n    function _claimRewards() internal returns (bool) {\r\n        convexFraxVault.getReward();\r\n\r\n        uint256 fxsBalance    = fraxShareToken.balanceOf(address(this));\r\n        uint256 curveBalance  = curveToken.balanceOf(address(this));\r\n        uint256 convexBalance = convexToken.balanceOf(address(this));\r\n\r\n        SafeERC20.safeTransfer(address(curveToken), rewardReceiver, curveBalance);\r\n        SafeERC20.safeTransfer(address(convexToken), rewardReceiver, convexBalance);\r\n        \r\n        emit ClaimRewards(true, fxsBalance, curveBalance, convexBalance);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev Gets the minimum of two integers.\r\n    ///\r\n    /// @param x The first integer.\r\n    /// @param y The second integer.\r\n    ///\r\n    /// @return The minimum value.\r\n    function min(uint256 x , uint256 y) private pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /// @dev Gets the absolute value of the difference of two integers.\r\n    ///\r\n    /// @param x The first integer.\r\n    /// @param y The second integer.\r\n    ///\r\n    /// @return The absolute value.\r\n    function abs(uint256 x , uint256 y) private pure returns (uint256) {\r\n        return x > y ? x - y : y - x;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"transmuterBuffer\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"fraxShareToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"curveToken\",\"type\":\"address\"},{\"internalType\":\"contract IStableSwap2Pool\",\"name\":\"twoPool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"twoPoolSlippage\",\"type\":\"uint256\"},{\"internalType\":\"contract IConvexToken\",\"name\":\"convexToken\",\"type\":\"address\"},{\"internalType\":\"contract IConvexStakingWrapper\",\"name\":\"convexStakingWrapper\",\"type\":\"address\"},{\"internalType\":\"contract IConvexFraxBooster\",\"name\":\"convexFraxBooster\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"convexPoolId\",\"type\":\"uint256\"}],\"internalType\":\"struct InitializationParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC20CallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalArgument\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"name\":\"MulticallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"AdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"name\":\"BurnTwoPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountFxs\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountCurve\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountConvex\",\"type\":\"uint256\"}],\"name\":\"ClaimRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"DepositTwoPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedTwoPoolTokens\",\"type\":\"uint256\"}],\"name\":\"MintTwoPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintedTwoPoolTokens\",\"type\":\"uint256\"}],\"name\":\"MintTwoPoolTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"PendingAdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReclaimTwoPoolAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardReceiver\",\"type\":\"address\"}],\"name\":\"RewardReceiverUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"transmuterBuffer\",\"type\":\"address\"}],\"name\":\"TransmuterBufferUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"twoPoolSlippage\",\"type\":\"uint256\"}],\"name\":\"TwoPoolSlippageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"WithdrawTwoPoolTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnTwoPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexFraxBooster\",\"outputs\":[{\"internalType\":\"contract IConvexFraxBooster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexFraxVault\",\"outputs\":[{\"internalType\":\"contract IConvexFraxVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexPoolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexStakingWrapper\",\"outputs\":[{\"internalType\":\"contract IConvexStakingWrapper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexToken\",\"outputs\":[{\"internalType\":\"contract IConvexToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTwoPoolTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"depositTwoPoolTokensCustomLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"emergencyRecall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"name\":\"flush\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"flush\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"flushCustomLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"flushCustomLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fraxShareToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"getTokenForTwoPoolAsset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"kekId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintTwoPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"name\":\"mintTwoPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"onERC20Received\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"recall\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reclaimTwoPoolAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setRewardReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setTransmuterBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setTwoPoolSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transmuterBuffer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twoPool\",\"outputs\":[{\"internalType\":\"contract IStableSwap2Pool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum PoolAsset\",\"name\":\"asset\",\"type\":\"uint8\"}],\"name\":\"twoPoolAssetReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twoPoolSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"withdrawTwoPoolTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PoolAssetManager", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008392f6669292fa56123f71949b52d883ae57e2250000000000000000000000009e2b6378ee8ad2a4a95fe481d63caba8fb0ebbf90000000000000000000000009e2b6378ee8ad2a4a95fe481d63caba8fb0ebbf9000000000000000000000000bc2fb245594a68c927c930fbe2d00680a8c90b9e0000000000000000000000003432b6a60d23ca0dfca7761b7ab56459d9c964d0000000000000000000000000d533a949740bb3306d119cc777fa900ba034cd52000000000000000000000000b657b895b265c38c53fff00166cf7f6a3c70587d00000000000000000000000000000000000000000000000000000000000026fc0000000000000000000000004e3fbd56cd56c3e72c1403e103b45db9da5b9d2b0000000000000000000000008a59781b415288f9e633b948618726cb6e47e9800000000000000000000000002b8b301b90eb8801f1eefe73285eec117d2ffc950000000000000000000000000000000000000000000000000000000000000036", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://251a6c160b472c1629c1866b390108437c06adfc2e17b178cc5c8a998d60d67f"}