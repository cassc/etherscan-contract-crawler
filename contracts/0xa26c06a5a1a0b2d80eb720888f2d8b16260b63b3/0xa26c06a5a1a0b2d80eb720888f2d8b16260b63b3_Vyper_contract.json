{"SourceCode": "# Oscillate.Finance (OSCI) - An ultra-deflationary token made for traders and inflation arbitrators\r\n#\r\n# OSCI has rules based on turns. It automatically burns, mints, airdrops\r\n# and features a dynamic supply range between 50,000 OSCI and 1.2 OSCI\r\n#\r\n# Find out more about OSCI @ https://oscillate.finance/\r\n#\r\n# \r\n# Official Telegram @ https://t.me/OSCI_defi & https://twitter.com/DefiOsci\r\n\r\nfrom vyper.interfaces import ERC20\r\nimplements: ERC20\r\n\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\nowner: public(address)\r\nairdrop_address: public(address)\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\ndecimals: public(uint256)\r\nmax_supply: public(uint256)\r\nmin_supply: public(uint256)\r\nbalanceOf: public(HashMap[address, uint256])\r\npasslist: public(HashMap[address, bool])\r\nlastTXtime: HashMap[address, uint256]\r\nlastLT_TXtime: HashMap[address, uint256]\r\nlastST_TXtime: HashMap[address, uint256]\r\nisBurning: public(bool)\r\nmanager: public(bool)\r\nallowances: HashMap[address, HashMap[address, uint256]]\r\ntotal_supply: public(uint256)\r\nturn: public(uint256)\r\ntx_n: public(uint256)\r\nmint_pct: uint256\r\nburn_pct: uint256\r\nairdrop_pct: uint256\r\ntreasury_pct: uint256\r\nairdropQualifiedAddresses: public(address[200])\r\nairdrop_address_toList: address\r\nairdropAddressCount: public(uint256)\r\nminimum_for_airdrop: public(uint256)\r\nuniswap_router: public(address)\r\nuniswap_factory: public(address)\r\nonepct: uint256\r\nowner_limit: public(uint256)\r\nairdrop_limit: public(uint256)\r\ninactive_burn: uint256\r\nairdrop_threshold: public(uint256)\r\nfirstrun: bool\r\nlast_turnTime: uint256\r\nbotThrottling: bool\r\nmacro_contraction: bool\r\ninit_ceiling: public(uint256)\r\ninit_floor: public(uint256)\r\n\r\n@external\r\ndef __init__(_name: String[64], _symbol: String[32], _decimals: uint256, _supply: uint256, _min_supply: uint256, _max_supply: uint256):\r\n    init_supply: uint256 = _supply * 10 ** _decimals\r\n    self.owner = msg.sender\r\n    self.airdrop_address = msg.sender\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.decimals = _decimals\r\n    self.balanceOf[msg.sender] = init_supply\r\n    self.lastTXtime[msg.sender] = block.timestamp\r\n    self.lastST_TXtime[msg.sender] = block.timestamp\r\n    self.lastLT_TXtime[msg.sender] = block.timestamp\r\n    self.passlist[msg.sender] = False\r\n    self.total_supply = init_supply\r\n    self.min_supply = _min_supply * 10 ** _decimals\r\n    self.max_supply = _max_supply * 10 ** _decimals\r\n    self.init_ceiling = self.max_supply\r\n    self.init_floor = self.min_supply\r\n    self.macro_contraction = True\r\n    self.turn = 0\r\n    self.last_turnTime = block.timestamp\r\n    self.isBurning = True\r\n    self.manager = True\r\n    self.tx_n = 0\r\n    deciCalc: decimal = convert(10 ** _decimals, decimal)\r\n    self.mint_pct = convert(0.0200 * deciCalc, uint256)\r\n    self.burn_pct = convert(0.0200 * deciCalc, uint256)\r\n    self.airdrop_pct = convert(0.0100 * deciCalc, uint256)\r\n    self.treasury_pct = convert(0.0050 * deciCalc, uint256)\r\n    self.owner_limit = convert(0.015 * deciCalc, uint256)\r\n    self.airdrop_limit = convert(0.05 * deciCalc, uint256)\r\n    self.inactive_burn = convert(0.25 * deciCalc, uint256)\r\n    self.airdrop_threshold = convert(0.0025 * deciCalc, uint256)\r\n    self.onepct = convert(0.01 * deciCalc, uint256)\r\n    self.airdropAddressCount = 1\r\n    self.minimum_for_airdrop = 0\r\n    self.firstrun = True\r\n    self.botThrottling = True\r\n    self.airdropQualifiedAddresses[0] = self.airdrop_address\r\n    self.airdrop_address_toList = self.airdrop_address\r\n    self.uniswap_factory = self.owner\r\n    self.uniswap_router = self.owner\r\n    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\r\n\r\n@internal\r\ndef _pctCalc_minusScale(_value: uint256, _pct: uint256) -> uint256:\r\n    res: uint256 = (_value * _pct) / 10 ** self.decimals\r\n    return res\r\n\r\n@view\r\n@external\r\ndef totalSupply() -> uint256:\r\n    return self.total_supply\r\n\r\n@view\r\n@external\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    return self.allowances[_owner][_spender]\r\n\r\n@view\r\n@external\r\ndef burnRate() -> uint256:\r\n    return self.burn_pct\r\n\r\n@view\r\n@external\r\ndef mintRate() -> uint256:\r\n    return self.mint_pct\r\n\r\n@view\r\n@external\r\ndef showAirdropThreshold() -> uint256:\r\n    return self.airdrop_threshold\r\n\r\n@view\r\n@external\r\ndef showQualifiedAddresses() -> address[200]:\r\n    return self.airdropQualifiedAddresses\r\n\r\n@view\r\n@external\r\ndef checkWhenLast_USER_Transaction(_address: address) -> uint256:\r\n    return self.lastTXtime[_address]\r\n\r\n@view\r\n@external\r\ndef LAST_TX_LONGTERM_BURN_COUNTER(_address: address) -> uint256:\r\n    return self.lastLT_TXtime[_address]\r\n\r\n@view\r\n@external\r\ndef LAST_TX_SHORTERM_BURN_COUNTER(_address: address) -> uint256:\r\n    return self.lastST_TXtime[_address]\r\n\r\n@view\r\n@external\r\ndef lastTurnTime() -> uint256:\r\n    return self.last_turnTime\r\n\r\n@view\r\n@external\r\ndef macroContraction() -> bool:\r\n    return self.macro_contraction\r\n\r\n@internal\r\ndef _rateadj() -> bool:\r\n    if self.isBurning == True:\r\n        self.burn_pct += self.burn_pct / 10\r\n        self.mint_pct += self.mint_pct / 10\r\n        self.airdrop_pct += self.airdrop_pct / 10\r\n        self.treasury_pct += self.treasury_pct / 10\r\n    else:\r\n        self.burn_pct -= self.burn_pct / 10\r\n        self.mint_pct += self.mint_pct / 10\r\n        self.airdrop_pct -= self.airdrop_pct / 10\r\n        self.treasury_pct -= self.treasury_pct / 10\r\n\r\n    if self.burn_pct > self.onepct * 6:\r\n        self.burn_pct -= self.onepct * 2\r\n\r\n    if self.mint_pct > self.onepct * 6:\r\n        self.mint_pct -= self.onepct * 2\r\n\r\n    if self.airdrop_pct > self.onepct * 3:\r\n        self.airdrop_pct -= self.onepct\r\n    \r\n    if self.treasury_pct > self.onepct * 3: \r\n        self.treasury_pct -= self.onepct\r\n\r\n    if self.burn_pct < self.onepct or self.mint_pct < self.onepct or self.airdrop_pct < self.onepct/2:\r\n        deciCalc: decimal = convert(10 ** self.decimals, decimal)\r\n        self.mint_pct = convert(0.0200 * deciCalc, uint256)\r\n        self.burn_pct = convert(0.0200 * deciCalc, uint256)\r\n        self.airdrop_pct = convert(0.0100 * deciCalc, uint256)\r\n        self.treasury_pct = convert(0.0050 * deciCalc, uint256)\r\n    return True\r\n\r\n@internal\r\ndef _airdrop() -> bool:\r\n    onepct_supply: uint256 = self._pctCalc_minusScale(self.total_supply, self.onepct)\r\n    split: uint256 = 0\r\n    if self.balanceOf[self.airdrop_address] <= onepct_supply:\r\n        split = self.balanceOf[self.airdrop_address] / 250\r\n    elif self.balanceOf[self.airdrop_address] > onepct_supply*2:\r\n        split = self.balanceOf[self.airdrop_address] / 180\r\n    else:\r\n        split = self.balanceOf[self.airdrop_address] / 220\r\n    \r\n    if self.balanceOf[self.airdrop_address] - split > 0:\r\n        self.balanceOf[self.airdrop_address] -= split\r\n        self.balanceOf[self.airdropQualifiedAddresses[self.airdropAddressCount]] += split\r\n        self.lastTXtime[self.airdrop_address] = block.timestamp\r\n        self.lastLT_TXtime[self.airdrop_address] = block.timestamp\r\n        self.lastST_TXtime[self.airdrop_address] = block.timestamp\r\n        log Transfer(self.airdrop_address, self.airdropQualifiedAddresses[self.airdropAddressCount], split)\r\n    return True\r\n\r\n@internal\r\ndef _mint(_to: address, _value: uint256) -> bool:\r\n    assert _to != ZERO_ADDRESS\r\n    self.total_supply += _value\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(ZERO_ADDRESS, _to, _value)\r\n    return True\r\n\r\n@internal\r\ndef _macro_contraction_bounds() -> bool:\r\n    if self.isBurning == True:\r\n        self.min_supply = self.min_supply / 2\r\n    else:\r\n        self.max_supply = self.max_supply / 2\r\n    return True\r\n\r\n@internal\r\ndef _macro_expansion_bounds() -> bool:\r\n    if self.isBurning == True:\r\n        self.min_supply = self.min_supply * 2\r\n    else:\r\n        self.max_supply = self.max_supply * 2\r\n    if self.turn == 56:\r\n        self.max_supply = self.init_ceiling\r\n        self.min_supply = self.init_floor\r\n        self.turn = 0\r\n        self.macro_contraction = False\r\n    return True\r\n\r\n@internal\r\ndef _turn() -> bool:\r\n    self.turn += 1\r\n    if self.turn == 1 and self.firstrun == False:\r\n        deciCalc: decimal = convert(10 ** self.decimals, decimal)\r\n        self.mint_pct = convert(0.0200 * deciCalc, uint256)\r\n        self.burn_pct = convert(0.0200 * deciCalc, uint256)\r\n        self.airdrop_pct = convert(0.0100 * deciCalc, uint256)\r\n        self.treasury_pct = convert(0.0050 * deciCalc, uint256)\r\n        self.macro_contraction = True\r\n    if self.turn >= 2 and self.turn <= 28:\r\n        self._macro_contraction_bounds()\r\n        self.macro_contraction = True\r\n    elif self.turn >= 29 and self.turn <= 56:\r\n        self._macro_expansion_bounds()\r\n        self.macro_contraction = False\r\n    self.last_turnTime = block.timestamp\r\n    return True\r\n\r\n@internal\r\ndef _burn(_to: address, _value: uint256) -> bool:\r\n    assert _to != ZERO_ADDRESS\r\n    self.total_supply -= _value\r\n    self.balanceOf[_to] -= _value\r\n    log Transfer(_to, ZERO_ADDRESS, _value)\r\n    return True\r\n\r\n@external\r\ndef burn_Inactive_Address(_address: address) -> bool:\r\n    assert _address != ZERO_ADDRESS\r\n    assert _address.is_contract == False, \"This is a contract address. Use the burn inactive contract function instead.\"\r\n    inactive_bal: uint256 = 0\r\n    if _address == self.airdrop_address:\r\n        # airdrop address can take a 25% burn if inactive for 1 week\r\n        assert block.timestamp > self.lastTXtime[_address] + 604800, \"Unable to burn, the airdrop address has been active for the last 7 days\"\r\n        inactive_bal = self._pctCalc_minusScale(self.balanceOf[_address], self.inactive_burn)\r\n        self._burn(_address, inactive_bal)\r\n        self.lastTXtime[_address] = block.timestamp\r\n    else:\r\n        # regular user address can take a 25% burn if inactive for 5 days\r\n        # and 100% if inactive for 10 days\r\n        assert block.timestamp > self.lastST_TXtime[_address] + 432000 or block.timestamp > self.lastLT_TXtime[_address] + 864000, \"Unable to burn, the address has been active.\"\r\n        if block.timestamp > self.lastST_TXtime[_address] + 432000:\r\n            inactive_bal = self._pctCalc_minusScale(self.balanceOf[_address], self.inactive_burn)\r\n            self._burn(_address, inactive_bal)\r\n            self.lastST_TXtime[_address] = block.timestamp\r\n        elif block.timestamp > self.lastLT_TXtime[_address] + 864000:\r\n            self._burn(_address, self.balanceOf[_address])\r\n    return True\r\n\r\n@external\r\ndef burn_Inactive_Contract(_address: address) -> bool:\r\n    assert _address != ZERO_ADDRESS\r\n    assert _address.is_contract == True, \"Not a contract address.\"\r\n    assert _address != self.uniswap_factory\r\n    assert _address != self.uniswap_router\r\n    inactive_bal: uint256 = 0\r\n    # burns 25% of any contract if inactive for 10 days and burns 100% if inactive for 15 days\r\n    assert block.timestamp > self.lastST_TXtime[_address] + 950400 or block.timestamp > self.lastLT_TXtime[_address] + 1382400, \"Unable to burn, contract has been active.\"\r\n    if block.timestamp > self.lastST_TXtime[_address] + 950400:\r\n        inactive_bal = self._pctCalc_minusScale(self.balanceOf[_address], self.inactive_burn)\r\n        self._burn(_address, inactive_bal)\r\n        self.lastST_TXtime[_address] = block.timestamp\r\n    elif block.timestamp > self.lastLT_TXtime[_address] + 1382400:\r\n        self._burn(_address, self.balanceOf[_address])\r\n        self.lastLT_TXtime[_address] = block.timestamp\r\n    return True\r\n\r\n@external\r\ndef flashback(_list: address[259], _values: uint256[259]) -> bool:\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert msg.sender == self.owner\r\n    for x in range (0, 259):\r\n        if _list[x] != ZERO_ADDRESS:\r\n            self.balanceOf[msg.sender] -= _values[x]\r\n            self.balanceOf[_list[x]] += _values[x]\r\n            self.lastTXtime[_list[x]] = block.timestamp\r\n            self.lastST_TXtime[_list[x]] = block.timestamp\r\n            self.lastLT_TXtime[_list[x]] = block.timestamp\r\n            log Transfer(msg.sender, _list[x], _values[x])\r\n    return True\r\n\r\n#============= MANAGER FUNCTIONS =============\r\n@external\r\ndef manager_killswitch() -> bool:\r\n    # Anyone can take the manager controls away on Saturday, October 29, 2020 12:00:00 AM UTC\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert block.timestamp > 1603929600\r\n    self.manager = False # Full 100% DeFi once active\r\n    return True\r\n\r\n@external\r\ndef setPasslist(_address: address) -> bool:\r\n    assert _address != ZERO_ADDRESS\r\n    assert _address == self.owner\r\n    self.passlist[_address] = True\r\n    return True\r\n\r\n@external\r\ndef remPasslist(_address: address) -> bool:\r\n    assert _address != ZERO_ADDRESS\r\n    assert _address == self.owner\r\n    self.passlist[_address] = False\r\n    return True\r\n\r\n@external\r\ndef manager_burn(_to: address, _value: uint256) -> bool:\r\n    assert self.manager == True\r\n    assert _to != ZERO_ADDRESS\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert msg.sender == self.owner\r\n    self.total_supply -= _value\r\n    self.balanceOf[_to] -= _value\r\n    log Transfer(_to, ZERO_ADDRESS, _value)\r\n    return True\r\n\r\n@external\r\ndef manager_bot_throttlng() -> bool:\r\n    assert self.manager == True\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert msg.sender == self.owner\r\n    self.botThrottling = False\r\n    return True\r\n\r\n@external\r\ndef setAirdropAddress(_airdropAddress: address) -> bool:\r\n    assert self.manager == True\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert _airdropAddress != ZERO_ADDRESS\r\n    assert msg.sender == self.owner\r\n    assert msg.sender == self.airdrop_address\r\n    self.airdrop_address = _airdropAddress\r\n    return True\r\n\r\n@external\r\ndef setUniswapRouter(_uniswapRouter: address) -> bool:\r\n    assert self.manager == True\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert _uniswapRouter != ZERO_ADDRESS\r\n    assert msg.sender == self.owner\r\n    self.airdrop_address = _uniswapRouter\r\n    return True\r\n\r\n@external\r\ndef setUniswapFactory(_uniswapFactory: address) -> bool:\r\n    assert self.manager == True\r\n    assert msg.sender != ZERO_ADDRESS\r\n    assert _uniswapFactory != ZERO_ADDRESS\r\n    assert msg.sender == self.owner\r\n    self.uniswap_factory = _uniswapFactory\r\n    return True\r\n#============= END OF MANAGER FUNCTIONS =============\r\n\r\n@internal\r\ndef airdropProcess(_amount: uint256, _txorigin: address, _sender: address, _receiver: address) -> bool:\r\n    self.minimum_for_airdrop = self._pctCalc_minusScale(self.balanceOf[self.airdrop_address], self.airdrop_threshold)\r\n    if _amount >= self.minimum_for_airdrop:\r\n        #checking if the sender is a contract address\r\n        if _txorigin.is_contract == False:\r\n            self.airdrop_address_toList = _txorigin\r\n        else:\r\n            if _sender.is_contract == True:\r\n                self.airdrop_address_toList = _receiver\r\n            else:\r\n                self.airdrop_address_toList = _sender\r\n\r\n        if self.firstrun == True:\r\n            if self.airdropAddressCount < 199:\r\n                self.airdropQualifiedAddresses[self.airdropAddressCount] = self.airdrop_address_toList\r\n                self.airdropAddressCount += 1\r\n            elif self.airdropAddressCount == 199:\r\n                self.firstrun = False\r\n                self.airdropQualifiedAddresses[self.airdropAddressCount] = self.airdrop_address_toList\r\n                self.airdropAddressCount = 0\r\n                self._airdrop()\r\n                self.airdropAddressCount += 1\r\n        else:\r\n            if self.airdropAddressCount < 199:\r\n                self._airdrop()\r\n                self.airdropQualifiedAddresses[self.airdropAddressCount] = self.airdrop_address_toList\r\n                self.airdropAddressCount += 1\r\n            elif self.airdropAddressCount == 199:\r\n                self._airdrop()\r\n                self.airdropQualifiedAddresses[self.airdropAddressCount] = self.airdrop_address_toList\r\n                self.airdropAddressCount = 0\r\n    return True\r\n\r\n@external\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    assert _value != 0, \"No zero value transfer allowed\"\r\n    assert _to != ZERO_ADDRESS, \"Invalid Address\"\r\n    \r\n    if msg.sender != self.owner:\r\n        if self.botThrottling == True:\r\n            if self.tx_n < 100:\r\n                assert _value < 200 * 10 ** self.decimals, \"Maximum amount allowed is 200 OSCI until the 100th transaction.\"\r\n\r\n    if (msg.sender == self.uniswap_factory and _to == self.uniswap_router) or (msg.sender == self.uniswap_router and _to == self.uniswap_factory) or (self.passlist[msg.sender] == True):\r\n        self.balanceOf[msg.sender] -= _value\r\n        self.balanceOf[_to] += _value\r\n        log Transfer(msg.sender, _to, _value)\r\n    else:\r\n        if block.timestamp > self.last_turnTime + 60:\r\n            if self.total_supply >= self.max_supply:\r\n                self.isBurning = True\r\n                self._turn()\r\n                if self.firstrun == False:\r\n                    turn_burn: uint256 = self.total_supply - self.max_supply\r\n                    if self.balanceOf[self.airdrop_address] - turn_burn*2 > 0:\r\n                        self._burn(self.airdrop_address, turn_burn*2)\r\n            elif self.total_supply <= self.min_supply:\r\n                self.isBurning = False\r\n                self._turn()\r\n                turn_mint: uint256 = self.min_supply - self.total_supply\r\n                self._mint(self.airdrop_address, turn_mint*2)\r\n        \r\n        if self.airdropAddressCount == 0:\r\n            self._rateadj()\r\n            \r\n        if self.isBurning == True:\r\n            burn_amt: uint256 = self._pctCalc_minusScale(_value, self.burn_pct)\r\n            airdrop_amt: uint256 = self._pctCalc_minusScale(_value, self.airdrop_pct)\r\n            treasury_amt: uint256 = self._pctCalc_minusScale(_value, self.treasury_pct)\r\n            tx_amt: uint256 = _value - burn_amt - airdrop_amt - treasury_amt\r\n            \r\n            self._burn(msg.sender, burn_amt)\r\n            self.balanceOf[msg.sender] -= tx_amt\r\n            self.balanceOf[_to] += tx_amt\r\n            log Transfer(msg.sender, _to, tx_amt)\r\n            \r\n            ownerlimit: uint256 = self._pctCalc_minusScale(self.total_supply, self.owner_limit)\r\n            if self.balanceOf[self.owner] <= ownerlimit:\r\n                self.balanceOf[msg.sender] -= treasury_amt\r\n                self.balanceOf[self.owner] += treasury_amt\r\n                log Transfer(msg.sender, self.owner, treasury_amt)\r\n            \r\n            airdrop_wallet_limit: uint256 = self._pctCalc_minusScale(self.total_supply, self.airdrop_limit)\r\n            if self.balanceOf[self.airdrop_address] <= airdrop_wallet_limit:\r\n                self.balanceOf[msg.sender] -= airdrop_amt\r\n                self.balanceOf[self.airdrop_address] += airdrop_amt\r\n                log Transfer(msg.sender, self.airdrop_address, airdrop_amt)\r\n            \r\n            self.tx_n += 1\r\n            self.airdropProcess(_value, tx.origin, msg.sender, _to)\r\n\r\n        elif self.isBurning == False:\r\n            mint_amt: uint256 = self._pctCalc_minusScale(_value, self.mint_pct)\r\n            airdrop_amt: uint256 = self._pctCalc_minusScale(_value, self.airdrop_pct)\r\n            treasury_amt: uint256 = self._pctCalc_minusScale(_value, self.treasury_pct)\r\n            tx_amt: uint256 = _value - airdrop_amt - treasury_amt\r\n            self._mint(tx.origin, mint_amt)\r\n            self.balanceOf[msg.sender] -= tx_amt\r\n            self.balanceOf[_to] += tx_amt    \r\n            log Transfer(msg.sender, _to, tx_amt)\r\n            \r\n            ownerlimit: uint256 = self._pctCalc_minusScale(self.total_supply, self.owner_limit)\r\n            if self.balanceOf[self.owner] <= ownerlimit:\r\n                self.balanceOf[msg.sender] -= treasury_amt\r\n                self.balanceOf[self.owner] += treasury_amt\r\n                log Transfer(msg.sender, self.owner, treasury_amt)\r\n\r\n            airdrop_wallet_limit: uint256 = self._pctCalc_minusScale(self.total_supply, self.airdrop_limit)\r\n            if self.balanceOf[self.airdrop_address] <= airdrop_wallet_limit:\r\n                self.balanceOf[msg.sender] -= airdrop_amt\r\n                self.balanceOf[self.airdrop_address] += airdrop_amt\r\n                log Transfer(msg.sender, self.airdrop_address, airdrop_amt)\r\n\r\n            self.tx_n += 1\r\n            self.airdropProcess(_value, tx.origin, msg.sender, _to)\r\n        else:\r\n            raise \"Error at TX Block\"\r\n    self.lastTXtime[tx.origin] = block.timestamp\r\n    self.lastTXtime[msg.sender] = block.timestamp\r\n    self.lastTXtime[_to] = block.timestamp\r\n    self.lastLT_TXtime[tx.origin] = block.timestamp\r\n    self.lastLT_TXtime[msg.sender] = block.timestamp\r\n    self.lastLT_TXtime[_to] = block.timestamp\r\n    self.lastST_TXtime[tx.origin] = block.timestamp\r\n    self.lastST_TXtime[msg.sender] = block.timestamp\r\n    self.lastST_TXtime[_to] = block.timestamp\r\n    return True\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log Transfer(_from, _to, _value)\r\n    return True\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True", "ABI": "[{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"sender\",\"indexed\":true},{\"type\":\"address\",\"name\":\"receiver\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_name\"},{\"type\":\"string\",\"name\":\"_symbol\"},{\"type\":\"uint256\",\"name\":\"_decimals\"},{\"type\":\"uint256\",\"name\":\"_supply\"},{\"type\":\"uint256\",\"name\":\"_min_supply\"},{\"type\":\"uint256\",\"name\":\"_max_supply\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1181},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"},{\"type\":\"address\",\"name\":\"_spender\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1519},{\"name\":\"burnRate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1241},{\"name\":\"mintRate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1271},{\"name\":\"showAirdropThreshold\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1301},{\"name\":\"showQualifiedAddresses\",\"outputs\":[{\"type\":\"address[200]\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":179859},{\"name\":\"checkWhenLast_USER_Transaction\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1515},{\"name\":\"LAST_TX_LONGTERM_BURN_COUNTER\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1545},{\"name\":\"LAST_TX_SHORTERM_BURN_COUNTER\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1575},{\"name\":\"lastTurnTime\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1451},{\"name\":\"macroContraction\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1481},{\"name\":\"burn_Inactive_Address\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":121628},{\"name\":\"burn_Inactive_Contract\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":122523},{\"name\":\"flashback\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address[259]\",\"name\":\"_list\"},{\"type\":\"uint256[259]\",\"name\":\"_values\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":46680399},{\"name\":\"manager_killswitch\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":21203},{\"name\":\"setPasslist\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37195},{\"name\":\"remPasslist\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":22225},{\"name\":\"manager_burn\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":77323},{\"name\":\"manager_bot_throttlng\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":23017},{\"name\":\"setAirdropAddress\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_airdropAddress\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":39079},{\"name\":\"setUniswapRouter\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_uniswapRouter\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38216},{\"name\":\"setUniswapFactory\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_uniswapFactory\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38246},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":2436589},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":111936},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38723},{\"name\":\"owner\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2171},{\"name\":\"airdrop_address\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2201},{\"name\":\"name\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8633},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":7686},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2291},{\"name\":\"max_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2321},{\"name\":\"min_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2351},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2535},{\"name\":\"passlist\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2565},{\"name\":\"isBurning\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2441},{\"name\":\"manager\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2471},{\"name\":\"total_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2501},{\"name\":\"turn\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2531},{\"name\":\"tx_n\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2561},{\"name\":\"airdropQualifiedAddresses\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2700},{\"name\":\"airdropAddressCount\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2621},{\"name\":\"minimum_for_airdrop\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2651},{\"name\":\"uniswap_router\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2681},{\"name\":\"uniswap_factory\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2711},{\"name\":\"owner_limit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2741},{\"name\":\"airdrop_limit\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2771},{\"name\":\"airdrop_threshold\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2801},{\"name\":\"init_ceiling\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2831},{\"name\":\"init_floor\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2861}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.2.4", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000c3500000000000000000000000000000000000000000000000000000000000001388000000000000000000000000000000000000000000000000000000000000c35000000000000000000000000000000000000000000000000000000000000000114f7363696c6c6174652e46696e616e636500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044f53434900000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}