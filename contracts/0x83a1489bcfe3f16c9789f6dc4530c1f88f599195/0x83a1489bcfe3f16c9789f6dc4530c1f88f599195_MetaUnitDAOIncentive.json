{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Platform/MetaUnit/Incentive/MetaUnitDAOIncentive.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\r\\nimport {IDAO} from \\\"../../DAO/Dao/interfaces/IDAO.sol\\\";\\r\\nimport {IMetaUnitTracker} from \\\"../Tracker/IMetaUnitTracker.sol\\\";\\r\\nimport {Pausable} from \\\"../../../Pausable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @author MetaPlayerOne DAO\\r\\n * @title MetaUnitDAOIncentive\\r\\n * @notice Manages token distribution to DAO \\r\\n */\\r\\ncontract MetaUnitDAOIncentive is Pausable {\\r\\n    struct OwnerShip { address dao_address; address owner_of; }\\r\\n    struct Token { address token_address; uint256 token_id; bool is_single; }\\r\\n\\r\\n    address private immutable _meta_unit_address;\\r\\n    address private immutable _meta_unit_tracker_address;\\r\\n    address private immutable _dao_factory_address;\\r\\n    uint256 private immutable _contract_deployment_timestamp;\\r\\n\\r\\n    uint256 private _coeficient = 0.01 ether;\\r\\n    mapping(address => bool) private _is_committee;\\r\\n\\r\\n    mapping(address => uint256) private _dao_claim_timestamp;\\r\\n    address[] private _voted;\\r\\n\\r\\n    /**\\r\\n    * @dev setup MetaUnit address and owner of this contract.\\r\\n    */\\r\\n    constructor(address owner_of_, address meta_unit_address_, address dao_factory_address_, address meta_unit_tracker_address_, address[] memory committee_) Pausable(owner_of_) {\\r\\n        _meta_unit_address = meta_unit_address_;\\r\\n        _dao_factory_address = dao_factory_address_;\\r\\n        _contract_deployment_timestamp = block.timestamp;\\r\\n        _meta_unit_tracker_address = meta_unit_tracker_address_;\\r\\n        for(uint256 i = 0; i < committee_.length; i++) {\\r\\n            _is_committee[committee_[i]] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @return value multiplied by the time factor.\\r\\n     */\\r\\n    function getReducedValue(uint256 value) private view returns (uint256) {\\r\\n        return (((value * _contract_deployment_timestamp) / (((block.timestamp - _contract_deployment_timestamp) * (_contract_deployment_timestamp / 547 days)) + _contract_deployment_timestamp)) * _coeficient / 1 ether);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev helps get coverage ratio of dao by address.\\r\\n     * @param dao_address address of dao, which coverage ratio should be calculated.\\r\\n     * @return value coverage ratio.\\r\\n     */\\r\\n    function getCoverageByDaoAddress(address dao_address) public view returns (uint256) {\\r\\n        uint256 value = 0;\\r\\n        IMetaUnitTracker tracker = IMetaUnitTracker(_meta_unit_tracker_address);\\r\\n        address[] memory addresses;\\r\\n        uint256[] memory values;\\r\\n        (addresses, values) = tracker.getTransactionsForPeriod(block.timestamp - 90 days, block.timestamp);\\r\\n        uint256 addresses_len = addresses.length;\\r\\n        uint256 quantity = 0;\\r\\n        for (uint256 i = 0; i < addresses_len; i++) {\\r\\n            if (IERC20(dao_address).balanceOf(addresses[i]) > 0) {\\r\\n                value += values[i];\\r\\n            }\\r\\n        }\\r\\n        for (uint256 i = 0; i < addresses.length; i++) {\\r\\n            for (uint256 j = 0; j < addresses.length; j++) {\\r\\n                if (i != j && addresses[i] == addresses[j] && addresses[i] != address(0)) {\\r\\n                    addresses[i] = address(0);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        for (uint256 i = 0; i < addresses.length; i++) {\\r\\n            if (addresses[i] != address(0)) {\\r\\n                quantity++;\\r\\n            }\\r\\n        }\\r\\n        return getReducedValue(value * quantity);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev manages mint of MetaUnit token for DAOs.\\r\\n     */\\r\\n    function claim() public {\\r\\n        IDAO daos = IDAO(_dao_factory_address);\\r\\n        address[] memory daos_addresses = daos.getDaosByOwner(msg.sender);\\r\\n        uint256 dao_len = daos_addresses.length;\\r\\n        require(dao_len > 0, \\\"You had no DAO on MetaPlayerOne\\\");\\r\\n        uint256 current_timestamp = block.timestamp;\\r\\n        require(_dao_claim_timestamp[msg.sender] + 90 days <= current_timestamp, \\\"You already claim metaunit in this month\\\");\\r\\n        uint256 value = 0;\\r\\n        for (uint256 i = 0; i < dao_len; i++) {\\r\\n             value += getCoverageByDaoAddress(daos_addresses[i]);\\r\\n        }\\r\\n        _dao_claim_timestamp[msg.sender] = current_timestamp;\\r\\n        IERC20(_meta_unit_address).transfer(msg.sender, value / 1000);\\r\\n    }\\r\\n\\r\\n    function setCoeficient(uint256 coeficient_) public {\\r\\n        require(msg.sender == _owner_of, \\\"Permission denied\\\");\\r\\n        _coeficient = coeficient_;\\r\\n    }\\r\\n\\r\\n    function withdraw() public {\\r\\n        require(_is_committee[msg.sender], \\\"Permission denied\\\");\\r\\n        uint256 voted_length = _voted.length;\\r\\n        for (uint256 i; i < voted_length; i++) {\\r\\n            require(_voted[i] != msg.sender, \\\"Already voted\\\");\\r\\n        }\\r\\n        IERC20 metaunit = IERC20(_meta_unit_address);\\r\\n        require(metaunit.balanceOf(address(this)) > 0, \\\"Not enough\\\");\\r\\n        _voted.push(msg.sender);\\r\\n        if (_voted.length == 3) {\\r\\n            metaunit.transfer(_owner_of, metaunit.balanceOf(address(this)));\\r\\n            delete _voted;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Platform/MetaUnit/Tracker/IMetaUnitTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IMetaUnitTracker {\\r\\n    struct Transaction { address owner_of; uint256 value; uint256 timestamp; }\\r\\n\\r\\n    function track(address eth_address_, uint256 value_) external;\\r\\n    function getUserResalesSum(address eth_address_) external view returns(uint256);\\r\\n    function getUserTransactionQuantity(address eth_address_) external view returns(uint256);\\r\\n    function getTransactions() external view returns (Transaction[] memory);\\r\\n    function getTransactionsForPeriod(uint256 from_, uint256 to_) external view returns (address[] memory, uint256[] memory);\\r\\n}\"\r\n    },\r\n    \"/contracts/Platform/DAO/Dao/interfaces/IDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IDAO {\\r\\n    function getDaosByOwner(address owner_of)\\r\\n        external\\r\\n        returns (address[] memory);\\r\\n\\r\\n    function getDaoOwner(address dao_address)\\r\\n        external\\r\\n        returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @author MetaPlayerOne DAO\\r\\n * @title Pausable\\r\\n */\\r\\ncontract Pausable {\\r\\n    address internal _owner_of;\\r\\n    bool internal _paused = false;\\r\\n\\r\\n    /**\\r\\n     * @dev setup owner of this contract with paused off state.\\r\\n     */\\r\\n    constructor(address owner_of_) {\\r\\n        _owner_of = owner_of_;\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev modifier which can be used on child contract for checking if contract services are paused.\\r\\n     */\\r\\n    modifier notPaused() {\\r\\n        require(!_paused, \\\"Contract is paused\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function which setup paused variable.\\r\\n     * @param paused_ new boolean value of paused condition.\\r\\n     */\\r\\n    function setPaused(bool paused_) external {\\r\\n        require(_paused != paused_, \\\"Param has been asigned already\\\");\\r\\n        require(_owner_of == msg.sender, \\\"Permission address\\\");\\r\\n        _paused = paused_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function which setup owner variable.\\r\\n     * @param owner_of_ new owner of contract.\\r\\n     */\\r\\n    function setOwner(address owner_of_) external {\\r\\n        require(_owner_of == msg.sender, \\\"Permission address\\\");\\r\\n        _owner_of = owner_of_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev function returns owner of contract.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner_of;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_of_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"meta_unit_address_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dao_factory_address_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"meta_unit_tracker_address_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"committee_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao_address\",\"type\":\"address\"}],\"name\":\"getCoverageByDaoAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coeficient_\",\"type\":\"uint256\"}],\"name\":\"setCoeficient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_of_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MetaUnitDAOIncentive", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008e66691515badbaca6ee686d74c8ef29e1afe57f0000000000000000000000006e975115250b05c828ecb8ededb091975fc20a5d0000000000000000000000007146ab9f1d9b053455bc9c0c1edc45243b5036330000000000000000000000003adf09d2d5292adc2874b2c867fecbb3b0b0b17400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000050000000000000000000000000c119114f1a8240457903a1c64e4919be138f86d0000000000000000000000008e66691515badbaca6ee686d74c8ef29e1afe57f0000000000000000000000005f176d0db1c88075e6e8172934c51e6d3c7f73b80000000000000000000000008f34084f8a1882ab4d3efb374fcec1ecc8a40bc1000000000000000000000000d4ffd865d86fbea88658dc76ab85ef80ef52e683", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}