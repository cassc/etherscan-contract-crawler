{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/BitMaps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\\n * Largely inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n */\\nlibrary BitMaps {\\n    struct BitMap {\\n        mapping(uint256 => uint256) _data;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        return bitmap._data[bucket] & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(BitMap storage bitmap, uint256 index, bool value) internal {\\n        if (value) {\\n            set(bitmap, index);\\n        } else {\\n            unset(bitmap, index);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] |= mask;\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] &= ~mask;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.4;\\n\\nabstract contract EIP712 {\\n    /// -----------------------------------------------------------------------\\n    /// Structs\\n    /// -----------------------------------------------------------------------\\n\\n    /// @param v Part of the ECDSA signature\\n    /// @param r Part of the ECDSA signature\\n    /// @param s Part of the ECDSA signature\\n    struct WithdrawalPacket {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 deadline;\\n        uint256 amount;\\n        uint256 nonce;\\n        address account;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Immutable parameters\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The chain ID used by EIP-712\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    /// @notice The domain separator used by EIP-712\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor() {\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Packet verification\\n    /// -----------------------------------------------------------------------\\n\\n    function _verifySig(bytes memory data, uint8 v, bytes32 r, bytes32 s) internal virtual returns (address) {\\n        // verify signature\\n        address recoveredAddress =\\n            ecrecover(keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR(), keccak256(data))), v, r, s);\\n        return recoveredAddress;\\n    }\\n\\n    /// @notice Verifies whether a packet is valid and returns the result.\\n    /// @dev The deadline, request, and signature are verified.\\n    /// @param packet The packet provided by the offchain data provider\\n    function _verifyWithdrawal(WithdrawalPacket calldata packet) internal virtual returns (address) {\\n        // verify deadline\\n        require(block.timestamp < packet.deadline, \\\">deadline\\\");\\n\\n        // verify signature\\n        address recoveredAddress = _verifySig(\\n            abi.encode(\\n                keccak256(\\\"VerifyWithdrawal(uint256 deadline,uint256 amount,uint256 nonce,address account)\\\"),\\n                packet.deadline,\\n                packet.amount,\\n                packet.nonce,\\n                packet.account\\n            ),\\n            packet.v,\\n            packet.r,\\n            packet.s\\n        );\\n        return recoveredAddress; // Invariant: sequencer != address(0), we maintain this every time sequencer is set\\n    }\\n\\n    struct Bid {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        bytes32 auctionId;\\n        uint256 maxAmount;\\n    }\\n\\n    function _verifyBid(Bid calldata packet) internal virtual returns (address) {\\n        address recoveredAddress = _verifySig(\\n            abi.encode(keccak256(\\\"Bid(bytes32 auctionId,uint256 maxAmount)\\\"), packet.auctionId, packet.maxAmount),\\n            packet.v,\\n            packet.r,\\n            packet.s\\n        );\\n        require(recoveredAddress != address(0), \\\"sig\\\");\\n        return recoveredAddress;\\n    }\\n\\n    struct BidWinner {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        bytes32 auctionId;\\n        uint256 amount;\\n        address winner;\\n    }\\n\\n    function _verifyBidWinner(BidWinner calldata packet) internal virtual returns (address) {\\n        return _verifySig(\\n            abi.encode(\\n                keccak256(\\\"BidWinner(bytes32 auctionId,uint256 amount,address winner)\\\"),\\n                packet.auctionId,\\n                packet.amount,\\n                packet.winner\\n            ),\\n            packet.v,\\n            packet.r,\\n            packet.s\\n        );\\n    }\\n\\n    struct CancelAuction {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        bytes32 auctionId;\\n        uint256 deadline;\\n    }\\n\\n    function _verifyCancelAuction(CancelAuction calldata packet) internal virtual returns (address) {\\n        require(block.timestamp <= packet.deadline, \\\"deadline\\\");\\n        return _verifySig(\\n            abi.encode(\\n                keccak256(\\\"CancelAuction(bytes32 auctionId,uint256 deadline)\\\"), packet.auctionId, packet.deadline\\n            ),\\n            packet.v,\\n            packet.r,\\n            packet.s\\n        );\\n    }\\n\\n    struct Offer {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        address nftContract;\\n        uint256 nftId;\\n        uint256 amount;\\n        uint256 deadline;\\n        uint256 counter;\\n        uint256 nonce;\\n    }\\n\\n    function _verifyBuyOffer(Offer calldata packet) internal virtual returns (address) {\\n        return _verifySig(\\n            abi.encode(\\n                keccak256(\\n                    \\\"BuyOffer(address nftContract,uint256 nftId,uint256 amount,uint256 deadline,uint256 counter,uint256 nonce)\\\"\\n                ),\\n                packet.nftContract,\\n                packet.nftId,\\n                packet.amount,\\n                packet.deadline,\\n                packet.counter,\\n                packet.nonce\\n            ),\\n            packet.v,\\n            packet.r,\\n            packet.s\\n        );\\n    }\\n\\n    function _verifySellOffer(Offer calldata packet) internal virtual returns (address) {\\n        return _verifySig(\\n            abi.encode(\\n                keccak256(\\n                    \\\"SellOffer(address nftContract,uint256 nftId,uint256 amount,uint256 deadline,uint256 counter,uint256 nonce)\\\"\\n                ),\\n                packet.nftContract,\\n                packet.nftId,\\n                packet.amount,\\n                packet.deadline,\\n                packet.counter,\\n                packet.nonce\\n            ),\\n            packet.v,\\n            packet.r,\\n            packet.s\\n        );\\n    }\\n\\n    struct OfferAttestation {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        bytes32 auctionId;\\n        uint256 amount;\\n        address buyer;\\n        address seller;\\n        uint256 deadline;\\n    }\\n\\n    function _verifyOfferAttestation(OfferAttestation calldata packet) internal virtual returns (address) {\\n        return _verifySig(\\n            abi.encode(\\n                keccak256(\\n                    \\\"OfferAttestation(bytes32 auctionId,uint256 amount,address buyer,address seller,uint256 deadline)\\\"\\n                ),\\n                packet.auctionId,\\n                packet.amount,\\n                packet.buyer,\\n                packet.seller,\\n                packet.deadline\\n            ),\\n            packet.v,\\n            packet.r,\\n            packet.s\\n        );\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// EIP-712 compliance\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice The domain separator used by EIP-712\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : _computeDomainSeparator();\\n    }\\n\\n    /// @notice Computes the domain separator used by EIP-712\\n    function _computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(\\\"SealedArtMarket\\\"),\\n                keccak256(\\\"1\\\"),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SealedArtMarket.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.7;\\n\\nimport \\\"./EIP712.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./SealedFundingFactory.sol\\\";\\nimport {BitMaps} from \\\"@openzeppelin/contracts/utils/structs/BitMaps.sol\\\";\\n\\ninterface IERC721 {\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\\n}\\n\\ninterface RoyaltyEngine {\\n    function getRoyalty(address tokenAddress, uint256 tokenId, uint256 value)\\n        external\\n        returns (address payable[] memory recipients, uint256[] memory amounts);\\n}\\n\\ncontract SealedArtMarket is EIP712, Ownable {\\n    using BitMaps for BitMaps.BitMap;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    mapping(address => uint256) private _balances;\\n    string public constant name = \\\"Sealed ETH\\\";\\n    string public constant symbol = \\\"SETH\\\";\\n    uint8 public constant decimals = 18;\\n\\n    function totalSupply() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    // sequencer and settleSequencer are separated as an extra security measure against key leakage through side attacks\\n    // If a side channel attack is possible that requires multiple signatures to be made, settleSequencer will be more protected\\n    // against it because each signature will require an onchain action, which will make the attack extremely expensive\\n    // It also allows us to use different security systems for the two keys, since settleSequencer is much more sensitive\\n    address public sequencer; // Invariant: always different than address(0)\\n    address public settleSequencer; // Invariant: always different than address(0)\\n    address payable public treasury;\\n    SealedFundingFactory public immutable sealedFundingFactory;\\n    uint256 internal constant MAX_PROTOCOL_FEE = 0.1e18; // 10%\\n    uint256 public feeMultiplier;\\n    uint256 public forcedWithdrawDelay = 2 days;\\n    RoyaltyEngine public constant royaltyEngine = RoyaltyEngine(0xBc40d21999b4BF120d330Ee3a2DE415287f626C9);\\n\\n    enum AuctionState {\\n        NONE, // 0 -> doesnt exist, default state\\n        CREATED,\\n        CLOSED\\n    }\\n\\n    mapping(bytes32 => AuctionState) public auctionState;\\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) public pendingWithdrawals;\\n    mapping(bytes32 => uint256) public pendingAuctionCancels;\\n    mapping(address => bool) public guardians;\\n\\n    BitMaps.BitMap private usedNonces;\\n    mapping(address => BitMaps.BitMap) private usedOrderNonces;\\n    mapping(address => uint256) public accountCounter;\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    constructor(address _sequencer, address payable _treasury, address _settleSequencer) {\\n        require(_sequencer != address(0) && _settleSequencer != address(0), \\\"0x0 sequencer not allowed\\\");\\n        sequencer = _sequencer;\\n        treasury = _treasury;\\n        settleSequencer = _settleSequencer;\\n        sealedFundingFactory = new SealedFundingFactory(address(this));\\n    }\\n\\n    event SequencerChanged(address newSequencer, address newSettleSequencer);\\n\\n    function changeSequencer(address newSequencer, address newSettleSequencer) external onlyOwner {\\n        require(newSequencer != address(0) && newSettleSequencer != address(0), \\\"0x0 sequencer not allowed\\\");\\n        sequencer = newSequencer;\\n        settleSequencer = newSettleSequencer;\\n        emit SequencerChanged(newSequencer, newSettleSequencer);\\n    }\\n\\n    event ForcedWithdrawDelayChanged(uint256 newDelay);\\n\\n    function changeForcedWithdrawDelay(uint256 newDelay) external onlyOwner {\\n        require(newDelay < 10 days, \\\"<10 days\\\");\\n        forcedWithdrawDelay = newDelay;\\n        emit ForcedWithdrawDelayChanged(newDelay);\\n    }\\n\\n    event TreasuryChanged(address newTreasury);\\n\\n    function changeTreasury(address payable newTreasury) external onlyOwner {\\n        treasury = newTreasury;\\n        emit TreasuryChanged(newTreasury);\\n    }\\n\\n    event GuardianSet(address guardian, bool value);\\n\\n    function setGuardian(address guardian, bool value) external onlyOwner {\\n        guardians[guardian] = value;\\n        emit GuardianSet(guardian, value);\\n    }\\n\\n    event SequencerDisabled(address guardian);\\n\\n    function emergencyDisableSequencer() external {\\n        require(guardians[msg.sender] == true, \\\"not guardian\\\");\\n        // Maintain the invariant that sequencers are not 0x0\\n        sequencer = address(0x000000000000000000000000000000000000dEaD);\\n        settleSequencer = address(0x000000000000000000000000000000000000dEaD);\\n        emit SequencerDisabled(msg.sender);\\n    }\\n\\n    event FeeChanged(uint256 newFeeMultiplier);\\n\\n    function changeFee(uint256 newFeeMultiplier) external onlyOwner {\\n        require(newFeeMultiplier <= MAX_PROTOCOL_FEE, \\\"fee too high\\\");\\n        feeMultiplier = newFeeMultiplier;\\n        emit FeeChanged(newFeeMultiplier);\\n    }\\n\\n    function deposit(address receiver) public payable {\\n        _balances[receiver] += msg.value;\\n        emit Transfer(address(0), receiver, msg.value);\\n    }\\n\\n    function _withdraw(uint256 amount) internal {\\n        _balances[msg.sender] -= amount;\\n        (bool success,) = payable(msg.sender).call{value: amount}(\\\"\\\");\\n        require(success);\\n        emit Transfer(msg.sender, address(0), amount);\\n    }\\n\\n    event WithdrawNonceUsed(uint256 nonce);\\n\\n    function withdraw(WithdrawalPacket calldata packet) public {\\n        require(_verifyWithdrawal(packet) == sequencer, \\\"!sequencer\\\");\\n        require(nonceState(packet.nonce) == false, \\\"replayed\\\");\\n        usedNonces.set(packet.nonce);\\n        require(packet.account == msg.sender, \\\"not sender\\\");\\n        _withdraw(packet.amount);\\n        emit WithdrawNonceUsed(packet.nonce);\\n    }\\n\\n    event StartWithdrawal(address owner, uint256 timestamp, uint256 nonce, uint256 amount);\\n\\n    function startWithdrawal(uint256 amount, uint256 nonce) external {\\n        pendingWithdrawals[msg.sender][block.timestamp][nonce] = amount;\\n        emit StartWithdrawal(msg.sender, block.timestamp, nonce, amount);\\n    }\\n\\n    event CancelWithdrawal(address owner, uint256 timestamp, uint256 nonce);\\n\\n    function cancelPendingWithdrawal(uint256 timestamp, uint256 nonce) external {\\n        pendingWithdrawals[msg.sender][timestamp][nonce] = 0;\\n        emit CancelWithdrawal(msg.sender, timestamp, nonce);\\n    }\\n\\n    event ExecuteDelayedWithdrawal(address owner, uint256 timestamp, uint256 nonce);\\n\\n    function executePendingWithdrawal(uint256 timestamp, uint256 nonce) external {\\n        require(timestamp + forcedWithdrawDelay < block.timestamp, \\\"too soon\\\");\\n        uint256 amount = pendingWithdrawals[msg.sender][timestamp][nonce];\\n        pendingWithdrawals[msg.sender][timestamp][nonce] = 0;\\n        _withdraw(amount);\\n        emit ExecuteDelayedWithdrawal(msg.sender, timestamp, nonce);\\n    }\\n\\n    function calculateAuctionHash(\\n        address owner,\\n        address nftContract,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encode(owner, nftContract, auctionType, nftId, reserve));\\n    }\\n\\n    event AuctionCreated(\\n        address owner, address nftContract, uint256 auctionDuration, bytes32 auctionType, uint256 nftId, uint256 reserve\\n    );\\n\\n    function _createAuction(\\n        address nftContract,\\n        uint256 auctionDuration,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve\\n    ) internal {\\n        bytes32 auctionId = calculateAuctionHash(msg.sender, nftContract, auctionType, nftId, reserve);\\n        require(auctionState[auctionId] == AuctionState.NONE, \\\"repeated auction id\\\"); // maybe this is not needed?\\n        auctionState[auctionId] = AuctionState.CREATED;\\n        emit AuctionCreated(msg.sender, nftContract, auctionDuration, auctionType, nftId, reserve);\\n    }\\n\\n    function createAuction(\\n        address nftContract,\\n        uint256 auctionDuration,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve\\n    ) external {\\n        IERC721(nftContract).transferFrom(msg.sender, address(this), nftId);\\n        _createAuction(nftContract, auctionDuration, auctionType, nftId, reserve);\\n    }\\n\\n    event AuctionCancelled(bytes32 auctionId);\\n\\n    function _cancelAuction(\\n        address nftContract,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve,\\n        CancelAuction calldata cancelAuctionPacket\\n    ) internal {\\n        require(_verifyCancelAuction(cancelAuctionPacket) == sequencer, \\\"!sequencer\\\");\\n        bytes32 auctionId = calculateAuctionHash(msg.sender, nftContract, auctionType, nftId, reserve);\\n        require(auctionState[auctionId] == AuctionState.CREATED, \\\"bad state\\\");\\n        require(cancelAuctionPacket.auctionId == auctionId, \\\"!auctionId\\\");\\n        auctionState[auctionId] = AuctionState.CLOSED;\\n        emit AuctionCancelled(auctionId);\\n    }\\n\\n    function cancelAuction(\\n        address nftContract,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve,\\n        CancelAuction calldata cancelAuctionPacket\\n    ) external {\\n        _cancelAuction(nftContract, auctionType, nftId, reserve, cancelAuctionPacket);\\n        IERC721(nftContract).transferFrom(address(this), msg.sender, nftId);\\n    }\\n\\n    function changeAuction(\\n        address nftContract,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve,\\n        uint256 newAuctionDuration,\\n        bytes32 newAuctionType,\\n        uint256 newReserve,\\n        CancelAuction calldata cancelAuctionPacket\\n    ) external {\\n        _cancelAuction(nftContract, auctionType, nftId, reserve, cancelAuctionPacket);\\n        _createAuction(nftContract, newAuctionDuration, newAuctionType, nftId, newReserve);\\n    }\\n\\n    event StartDelayedAuctionCancel(bytes32 auctionId);\\n\\n    function startCancelAuction(\\n        address nftContract,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve\\n    ) external {\\n        bytes32 auctionId = calculateAuctionHash(msg.sender, nftContract, auctionType, nftId, reserve);\\n        require(auctionState[auctionId] == AuctionState.CREATED, \\\"bad auction state\\\");\\n        pendingAuctionCancels[auctionId] = block.timestamp;\\n        emit StartDelayedAuctionCancel(auctionId);\\n    }\\n\\n    event ExecuteDelayedAuctionCancel(bytes32 auctionId);\\n\\n    function executeCancelAuction(\\n        address nftContract,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve\\n    ) external {\\n        bytes32 auctionId = calculateAuctionHash(msg.sender, nftContract, auctionType, nftId, reserve);\\n        uint256 timestamp = pendingAuctionCancels[auctionId];\\n        require(timestamp != 0 && (timestamp + forcedWithdrawDelay) < block.timestamp, \\\"too soon\\\");\\n        require(auctionState[auctionId] == AuctionState.CREATED, \\\"not open\\\");\\n        auctionState[auctionId] = AuctionState.CLOSED;\\n        pendingAuctionCancels[auctionId] = 0;\\n        emit AuctionCancelled(auctionId);\\n        IERC721(nftContract).transferFrom(address(this), msg.sender, nftId);\\n        emit ExecuteDelayedAuctionCancel(auctionId);\\n    }\\n\\n    function _transferETH(address payable receiver, uint256 amount) internal {\\n        (bool success,) = receiver.call{value: amount, gas: 300_000}(\\\"\\\");\\n        if (success == false) {\\n            _balances[receiver] += amount;\\n            emit Transfer(address(0), receiver, amount);\\n        }\\n    }\\n\\n    function _distributeSale(address nftContract, uint256 nftId, uint256 amount, address payable seller) internal {\\n        uint256 totalRoyalty = 0;\\n        try royaltyEngine.getRoyalty{gas: 500_000}(nftContract, nftId, amount) returns (address payable[] memory recipients, uint256[] memory amounts) {\\n            uint length = 5; // Use a maximum of 5 items to avoid attacks that blow up gas limit\\n            if(recipients.length < length){\\n                length = recipients.length;\\n            }\\n            if(amounts.length < length){\\n                length = amounts.length;\\n            }\\n            for (uint256 i; i < length;) {\\n                _transferETH(recipients[i], amounts[i]);\\n                totalRoyalty += amounts[i];\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n            require(totalRoyalty <= (amount / 3), \\\"Royalty too high\\\"); // Protect against royalty hacks\\n        } catch {}\\n        uint256 feeAmount = (amount * feeMultiplier) / 1e18;\\n        _transferETH(treasury, feeAmount);\\n        _transferETH(seller, amount - (totalRoyalty + feeAmount)); // totalRoyalty+feeAmount <= amount*0.43\\n    }\\n\\n    event AuctionSettled(bytes32 auctionId);\\n\\n    function settleAuction(\\n        address payable nftOwner,\\n        address nftContract,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve,\\n        Bid calldata bid,\\n        BidWinner calldata bidWinner\\n    ) public {\\n        bytes32 auctionId = calculateAuctionHash(nftOwner, nftContract, auctionType, nftId, reserve);\\n        require(auctionState[auctionId] == AuctionState.CREATED, \\\"bad auction state\\\");\\n        auctionState[auctionId] = AuctionState.CLOSED;\\n        require(bidWinner.auctionId == auctionId && bid.auctionId == auctionId, \\\"!auctionId\\\");\\n        uint256 amount = bidWinner.amount;\\n        require(amount <= bid.maxAmount && amount >= reserve, \\\"!amount\\\");\\n        require(_verifyBid(bid) == bidWinner.winner, \\\"!winner\\\");\\n        require(_verifyBidWinner(bidWinner) == settleSequencer, \\\"!settleSequencer\\\");\\n        _balances[bidWinner.winner] -= amount;\\n        emit Transfer(bidWinner.winner, address(0), amount);\\n        IERC721(nftContract).transferFrom(address(this), bidWinner.winner, nftId);\\n        _distributeSale(nftContract, nftId, amount, nftOwner);\\n        emit AuctionSettled(auctionId);\\n    }\\n\\n    function _revealBids(bytes32[] calldata salts, address owner) internal {\\n        for (uint256 i = 0; i < salts.length;) {\\n            // We use try/catch here to prevent a griefing attack where someone could deploySealedFunding() one of the\\n            // sealed fundings of the buyer right before another user calls this function, thus making it revert\\n            // It's still possible for the buyer to perform this attack by frontrunning the call with a withdraw()\\n            // but that's trivial to solve by just revealing all the salts of the griefing user\\n            try sealedFundingFactory.deploySealedFunding{gas: 100_000}(salts[i], owner) {} // cost of deploySealedFunding() is between 55k and 82k\\n                catch {}\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function settleAuctionWithSealedBids(\\n        bytes32[] calldata salts,\\n        address payable nftOwner,\\n        address nftContract,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve,\\n        Bid calldata bid,\\n        BidWinner calldata bidWinner\\n    ) external {\\n        _revealBids(salts, bidWinner.winner);\\n        settleAuction(nftOwner, nftContract, auctionType, nftId, reserve, bid, bidWinner);\\n    }\\n\\n    function withdrawWithSealedBids(bytes32[] calldata salts, WithdrawalPacket calldata packet) external {\\n        _revealBids(salts, msg.sender);\\n        withdraw(packet);\\n    }\\n\\n    event CounterIncreased(address account, uint256 newCounter);\\n\\n    function increaseCounter(uint256 newCounter) external {\\n        require(newCounter > accountCounter[msg.sender], \\\"too low\\\");\\n        accountCounter[msg.sender] = newCounter;\\n        emit CounterIncreased(msg.sender, newCounter);\\n    }\\n\\n    event OfferCancelled(address account, uint256 nonce);\\n\\n    function cancelOffer(uint256 nonce) external {\\n        usedOrderNonces[msg.sender].set(nonce);\\n        emit OfferCancelled(msg.sender, nonce);\\n    }\\n\\n    function _verifyOffer(Offer calldata offer, address creator) private {\\n        require(offer.deadline > block.timestamp, \\\"!deadline\\\");\\n        require(orderNonces(creator, offer.nonce) == false, \\\"!orderNonce\\\");\\n        usedOrderNonces[msg.sender].set(offer.nonce);\\n        require(offer.counter > accountCounter[creator], \\\"!counter\\\");\\n    }\\n\\n    event OrdersMatched(bytes32 auctionId, address buyer, address sender, uint256 buyerNonce, uint256 sellerNonce);\\n\\n    function matchOrders(\\n        Offer calldata sellerOffer,\\n        Offer calldata buyerOffer,\\n        OfferAttestation calldata sequencerStamp,\\n        address nftContract,\\n        bytes32 auctionType,\\n        uint256 nftId,\\n        uint256 reserve\\n    ) external {\\n        // First run verifications that can fail due to a delayed tx\\n        require(sequencerStamp.deadline > block.timestamp, \\\"!deadline\\\");\\n        if (msg.sender != sequencerStamp.buyer) {\\n            _verifyOffer(buyerOffer, sequencerStamp.buyer);\\n            require(_verifyBuyOffer(buyerOffer) == sequencerStamp.buyer && sequencerStamp.buyer != address(0), \\\"!buyer\\\");\\n        }\\n        if (msg.sender != sequencerStamp.seller) {\\n            _verifyOffer(sellerOffer, sequencerStamp.seller);\\n            require(\\n                _verifySellOffer(sellerOffer) == sequencerStamp.seller && sequencerStamp.seller != address(0), \\\"!seller\\\"\\n            );\\n        }\\n        // Verify NFT is owned by seller\\n        bytes32 auctionId = calculateAuctionHash(\\n            sequencerStamp.seller,\\n            nftContract,\\n            auctionType,\\n            nftId,\\n            reserve\\n        );\\n        require(auctionState[auctionId] == AuctionState.CREATED && sequencerStamp.auctionId == auctionId, \\\"bad auction state\\\");\\n        // Execute sale\\n        _balances[sequencerStamp.buyer] -= sequencerStamp.amount;\\n        emit Transfer(sequencerStamp.buyer, address(0), sequencerStamp.amount);\\n        auctionState[auctionId] = AuctionState.CLOSED;\\n\\n        // Run verifications that can't fail due to external factors\\n        require(sequencerStamp.amount == sellerOffer.amount && sequencerStamp.amount == buyerOffer.amount, \\\"!amount\\\");\\n        require(\\n            nftContract == sellerOffer.nftContract\\n                && nftContract == buyerOffer.nftContract,\\n            \\\"!nftContract\\\"\\n        );\\n        require(nftId == sellerOffer.nftId && nftId == buyerOffer.nftId, \\\"!nftId\\\");\\n        require(_verifyOfferAttestation(sequencerStamp) == sequencer, \\\"!sequencer\\\"); // This needs sequencer approval to avoid someone rugging their bids by buying another NFT\\n\\n        // Finish executing sale\\n        IERC721(nftContract).transferFrom(address(this), sequencerStamp.buyer, nftId);\\n        _distributeSale(\\n            nftContract, nftId, sequencerStamp.amount, payable(sequencerStamp.seller)\\n        );\\n        emit OrdersMatched(auctionId, sequencerStamp.buyer, msg.sender, buyerOffer.nonce, sellerOffer.nonce);\\n    }\\n\\n    function nonceState(uint256 nonce) public view returns (bool) {\\n        return usedNonces.get(nonce);\\n    }\\n\\n    function orderNonces(address account, uint256 nonce) public view returns (bool) {\\n        return usedOrderNonces[account].get(nonce);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SealedFunding.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.7;\\n\\ninterface IExchange {\\n    function deposit(address receiver) external payable;\\n}\\n\\ncontract SealedFunding {\\n    constructor(address _owner, address _exchange) {\\n        IExchange(_exchange).deposit{value: address(this).balance}(_owner);\\n        assembly {\\n            // Ensures the runtime bytecode is a single opcode: `INVALID`. This reduces contract\\n            // deploy costs & ensures that no one can accidentally send ETH to the contract once\\n            // deployed.\\n            mstore8(0, 0xfe)\\n            return(0, 1)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SealedFundingFactory.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.7;\\n\\nimport \\\"./SealedFunding.sol\\\";\\n\\ncontract SealedFundingFactory {\\n    address public immutable exchange;\\n\\n    constructor(address _exchange) {\\n        exchange = _exchange;\\n    }\\n\\n    event SealedFundingRevealed(bytes32 salt, address owner);\\n\\n    function deploySealedFunding(bytes32 salt, address owner) public {\\n        new SealedFunding{salt: salt}(owner, exchange);\\n        emit SealedFundingRevealed(salt, owner);\\n    }\\n\\n    function computeSealedFundingAddress(bytes32 salt, address owner)\\n        external\\n        view\\n        returns (address predictedAddress, bool isDeployed)\\n    {\\n        predictedAddress = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            bytes1(0xff),\\n                            address(this),\\n                            salt,\\n                            keccak256(abi.encodePacked(type(SealedFunding).creationCode, abi.encode(owner, exchange)))\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n        isDeployed = predictedAddress.code.length != 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 4294967\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencer\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_settleSequencer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"}],\"name\":\"AuctionSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"CancelWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"}],\"name\":\"CounterIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"}],\"name\":\"ExecuteDelayedAuctionCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"ExecuteDelayedWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDelay\",\"type\":\"uint256\"}],\"name\":\"ForcedWithdrawDelayChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"GuardianSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"OfferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellerNonce\",\"type\":\"uint256\"}],\"name\":\"OrdersMatched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSequencer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSettleSequencer\",\"type\":\"address\"}],\"name\":\"SequencerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"}],\"name\":\"SequencerDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"}],\"name\":\"StartDelayedAuctionCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StartWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"TreasuryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"WithdrawNonceUsed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"auctionState\",\"outputs\":[{\"internalType\":\"enum SealedArtMarket.AuctionState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"calculateAuctionHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct EIP712.CancelAuction\",\"name\":\"cancelAuctionPacket\",\"type\":\"tuple\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"cancelPendingWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAuctionDuration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"newAuctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"newReserve\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct EIP712.CancelAuction\",\"name\":\"cancelAuctionPacket\",\"type\":\"tuple\"}],\"name\":\"changeAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDelay\",\"type\":\"uint256\"}],\"name\":\"changeForcedWithdrawDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSequencer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newSettleSequencer\",\"type\":\"address\"}],\"name\":\"changeSequencer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"changeTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionDuration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyDisableSequencer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"executeCancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"executePendingWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forcedWithdrawDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"guardians\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"}],\"name\":\"increaseCounter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct EIP712.Offer\",\"name\":\"sellerOffer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct EIP712.Offer\",\"name\":\"buyerOffer\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct EIP712.OfferAttestation\",\"name\":\"sequencerStamp\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"matchOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"nonceState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"orderNonces\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pendingAuctionCancels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyEngine\",\"outputs\":[{\"internalType\":\"contract RoyaltyEngine\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sealedFundingFactory\",\"outputs\":[{\"internalType\":\"contract SealedFundingFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guardian\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"nftOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct EIP712.Bid\",\"name\":\"bid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"internalType\":\"struct EIP712.BidWinner\",\"name\":\"bidWinner\",\"type\":\"tuple\"}],\"name\":\"settleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"salts\",\"type\":\"bytes32[]\"},{\"internalType\":\"address payable\",\"name\":\"nftOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct EIP712.Bid\",\"name\":\"bid\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"auctionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"internalType\":\"struct EIP712.BidWinner\",\"name\":\"bidWinner\",\"type\":\"tuple\"}],\"name\":\"settleAuctionWithSealedBids\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settleSequencer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"auctionType\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve\",\"type\":\"uint256\"}],\"name\":\"startCancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"startWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"internalType\":\"struct EIP712.WithdrawalPacket\",\"name\":\"packet\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"salts\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"internalType\":\"struct EIP712.WithdrawalPacket\",\"name\":\"packet\",\"type\":\"tuple\"}],\"name\":\"withdrawWithSealedBids\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SealedArtMarket", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "4294967", "ConstructorArguments": "000000000000000000000000ca2a693a03b49bbc3a25ae7ccc3c36335235eeac000000000000000000000000ca2a693a03b49bbc3a25ae7ccc3c36335235eeac000000000000000000000000ca2a693a03b49bbc3a25ae7ccc3c36335235eeac", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}