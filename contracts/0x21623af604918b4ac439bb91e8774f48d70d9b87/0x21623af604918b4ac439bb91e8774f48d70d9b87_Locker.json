{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Locker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.14;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface ERC20 {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(\\r\\n        address indexed token0,\\r\\n        address indexed token1,\\r\\n        address pair,\\r\\n        uint256\\r\\n    );\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        view\\r\\n        returns (address pair);\\r\\n\\r\\n    function allPairs(uint256) external view returns (address pair);\\r\\n\\r\\n    function allPairsLength() external view returns (uint256);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n\\r\\n    function symbol() external pure returns (string memory);\\r\\n\\r\\n    function decimals() external pure returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\r\\n    event Burn(\\r\\n        address indexed sender,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint256 amount0In,\\r\\n        uint256 amount1In,\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112 reserve0,\\r\\n            uint112 reserve1,\\r\\n            uint32 blockTimestampLast\\r\\n        );\\r\\n\\r\\n    function price0CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function price1CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function kLast() external view returns (uint256);\\r\\n\\r\\n    function mint(address to) external returns (uint256 liquidity);\\r\\n\\r\\n    function burn(address to)\\r\\n        external\\r\\n        returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function swap(\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address to,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function skim(address to) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\ncontract Locker is Ownable {\\r\\n    event Lock(uint256 amount, address from, address tokenAddress);\\r\\n    event ReleaseLock(uint256 amount, address to, address tokenAddress);\\r\\n\\r\\n    modifier onlyEOA() {\\r\\n        require(msg.sender == tx.origin, \\\"Only EOA\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    uint256 public totalLocked;\\r\\n\\r\\n    struct LockInfo {\\r\\n        address owner;\\r\\n        address tokenAddress;\\r\\n        uint256 releaseDate;\\r\\n        uint256 lockDate;\\r\\n        uint256 amount;\\r\\n        uint8 method;\\r\\n    }\\r\\n\\r\\n    struct AccountInfo {\\r\\n        uint256 lockedCount;\\r\\n        mapping(uint256 => LockInfo) lockinfo;\\r\\n    }\\r\\n\\r\\n    mapping(address => AccountInfo) public locker;\\r\\n\\r\\n    constructor() {}\\r\\n\\r\\n    //----STATEFUL\\r\\n\\r\\n    //---LOCKING---\\r\\n    function lock(\\r\\n        uint256 unlockDate,\\r\\n        address tokenAddress,\\r\\n        uint256 amount\\r\\n    ) external onlyEOA {\\r\\n        (uint256 balance, uint256 allowance, ERC20 tokens) = _tokenProxy(\\r\\n            tokenAddress,\\r\\n            msg.sender\\r\\n        );\\r\\n        require(unlockDate >= block.timestamp, \\\"Invalid date\\\");\\r\\n        require(allowance >= amount, \\\"please adjust allowances\\\");\\r\\n        require(\\r\\n            balance >= amount && balance > 0 && amount > 0,\\r\\n            \\\"invalid amount\\\"\\r\\n        );\\r\\n        AccountInfo storage AInfo = locker[msg.sender];\\r\\n        AInfo.lockedCount++;\\r\\n        AInfo.lockinfo[AInfo.lockedCount] = LockInfo({\\r\\n            owner: msg.sender,\\r\\n            tokenAddress: tokenAddress,\\r\\n            releaseDate: unlockDate,\\r\\n            lockDate: block.timestamp,\\r\\n            amount: amount,\\r\\n            method: 1\\r\\n        });\\r\\n        totalLocked++;\\r\\n        require(\\r\\n            tokens.transferFrom(msg.sender, address(this), amount),\\r\\n            \\\"tx failed\\\"\\r\\n        );\\r\\n        emit Lock(amount, msg.sender, tokenAddress);\\r\\n    }\\r\\n\\r\\n    //---RELEASE---\\r\\n    function releaseLock(uint256 lockId) external onlyEOA {\\r\\n        LockInfo storage LInfo = locker[msg.sender].lockinfo[lockId];\\r\\n        (uint256 balance, , ERC20 tokens) = _tokenProxy(\\r\\n            LInfo.tokenAddress,\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        require(block.timestamp >= LInfo.releaseDate, \\\"Not unlocked yet\\\");\\r\\n        require(msg.sender == LInfo.owner, \\\"invalid owner\\\");\\r\\n        require(balance > 0 && LInfo.amount > 0, \\\"invalid balance\\\");\\r\\n        uint256 txAmount = LInfo.amount;\\r\\n        LInfo.amount = 0;\\r\\n        totalLocked--;\\r\\n        require(\\r\\n            tokens.transfer(msg.sender, txAmount),\\r\\n            \\\"tx failed / non standard token\\\"\\r\\n        );\\r\\n        emit ReleaseLock(txAmount, msg.sender, LInfo.tokenAddress);\\r\\n    }\\r\\n\\r\\n    //----VIEW\\r\\n    function _tokenProxy(address tokenAddress, address owner)\\r\\n        private\\r\\n        view\\r\\n        returns (\\r\\n            uint256 balance,\\r\\n            uint256 allowance,\\r\\n            ERC20 token\\r\\n        )\\r\\n    {\\r\\n        ERC20 tokens = ERC20(tokenAddress);\\r\\n        uint256 balances = tokens.balanceOf(owner);\\r\\n        uint256 allowances = tokens.allowance(owner, address(this));\\r\\n        return (balances, allowances, tokens);\\r\\n    }\\r\\n\\r\\n    function viewLockCount(address addr)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256 lockedCount)\\r\\n    {\\r\\n        AccountInfo storage AInfo = locker[addr];\\r\\n        return (AInfo.lockedCount);\\r\\n    }\\r\\n\\r\\n    function viewLockByID(uint256 id, address addr)\\r\\n        public\\r\\n        view\\r\\n        returns (LockInfo memory LInfo)\\r\\n    {\\r\\n        AccountInfo storage AInfo = locker[addr];\\r\\n        LockInfo storage LInfos = AInfo.lockinfo[id];\\r\\n\\r\\n        return (LInfos);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"ReleaseLock\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"locker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockId\",\"type\":\"uint256\"}],\"name\":\"releaseLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"viewLockByID\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"releaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"method\",\"type\":\"uint8\"}],\"internalType\":\"struct Locker.LockInfo\",\"name\":\"LInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"viewLockCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockedCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Locker", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}