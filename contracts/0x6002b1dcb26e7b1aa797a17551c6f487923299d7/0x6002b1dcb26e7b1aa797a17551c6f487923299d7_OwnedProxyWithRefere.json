{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2021-05-05\r\n*/\r\n\r\n/*\r\n    .'''''''''''..     ..''''''''''''''''..       ..'''''''''''''''..\r\n    .;;;;;;;;;;;'.   .';;;;;;;;;;;;;;;;;;,.     .,;;;;;;;;;;;;;;;;;,.\r\n    .;;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;,.    .,;;;;;;;;;;;;;;;;;;,.\r\n    .;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.   .;;;;;;;;;;;;;;;;;;;;,.\r\n    ';;;;;;;;'.  .';;;;;;;;;;;;;;;;;;;;;;,. .';;;;;;;;;;;;;;;;;;;;;,.\r\n    ';;;;;,..   .';;;;;;;;;;;;;;;;;;;;;;;,..';;;;;;;;;;;;;;;;;;;;;;,.\r\n    ......     .';;;;;;;;;;;;;,'''''''''''.,;;;;;;;;;;;;;,'''''''''..\r\n              .,;;;;;;;;;;;;;.           .,;;;;;;;;;;;;;.\r\n             .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.\r\n            .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.\r\n           .,;;;;;;;;;;;;,.           .;;;;;;;;;;;;;,.     .....\r\n          .;;;;;;;;;;;;;'.         ..';;;;;;;;;;;;;'.    .',;;;;,'.\r\n        .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.   .';;;;;;;;;;.\r\n       .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.    .;;;;;;;;;;;,.\r\n      .,;;;;;;;;;;;;;'...........,;;;;;;;;;;;;;;.      .;;;;;;;;;;;,.\r\n     .,;;;;;;;;;;;;,..,;;;;;;;;;;;;;;;;;;;;;;;,.       ..;;;;;;;;;,.\r\n    .,;;;;;;;;;;;;,. .,;;;;;;;;;;;;;;;;;;;;;;,.          .',;;;,,..\r\n   .,;;;;;;;;;;;;,.  .,;;;;;;;;;;;;;;;;;;;;;,.              ....\r\n    ..',;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.\r\n       ..',;;;;'.    .,;;;;;;;;;;;;;;;;;;;'.\r\n          ...'..     .';;;;;;;;;;;;;;,,,'.\r\n                       ...............\r\n*/\r\n\r\n// https://github.com/trusttoken/smart-contracts\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private initializing;\r\n\r\n    /**\r\n     * @dev Modifier to use in the initializer function of a contract.\r\n     */\r\n    modifier initializer() {\r\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n        bool isTopLevelCall = !initializing;\r\n        if (isTopLevelCall) {\r\n            initializing = true;\r\n            initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            initializing = false;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        address self = address(this);\r\n        uint256 cs;\r\n        assembly {\r\n            cs := extcodesize(self)\r\n        }\r\n        return cs == 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Return true if and only if the contract has been initialized\r\n     * @return whether the contract has been initialized\r\n     */\r\n    function isInitialized() public view returns (bool) {\r\n        return initialized;\r\n    }\r\n\r\n    // Reserved storage space to allow for layout changes in the future.\r\n    uint256[50] private ______gap;\r\n}\r\n\r\n/**\r\n * @title UpgradeableClaimable\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. Since\r\n * this contract combines Claimable and UpgradableOwnable contracts, ownership\r\n * can be later change via 2 step method {transferOwnership} and {claimOwnership}\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract UpgradeableClaimable is Initializable, Context {\r\n    address private _owner;\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting a custom initial owner of choice.\r\n     * @param __owner Initial owner of contract to be set.\r\n     */\r\n    function initialize(address __owner) internal initializer {\r\n        _owner = __owner;\r\n        emit OwnershipTransferred(address(0), __owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier throws if called by any account other than the pendingOwner.\r\n     */\r\n    modifier onlyPendingOwner() {\r\n        require(msg.sender == _pendingOwner, \"Ownable: caller is not the pending owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to set the pendingOwner address.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _pendingOwner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner address to finalize the transfer.\r\n     */\r\n    function claimOwnership() public onlyPendingOwner {\r\n        emit OwnershipTransferred(_owner, _pendingOwner);\r\n        _owner = _pendingOwner;\r\n        _pendingOwner = address(0);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ImplementationReference\r\n * @dev This contract is made to serve a simple purpose only.\r\n * To hold the address of the implementation contract to be used by proxy.\r\n * The implementation address, is changeable anytime by the owner of this contract.\r\n */\r\ncontract ImplementationReference is UpgradeableClaimable {\r\n    address public implementation;\r\n\r\n    /**\r\n     * @dev Event to show that implementation address has been changed\r\n     * @param newImplementation New address of the implementation\r\n     */\r\n    event ImplementationChanged(address newImplementation);\r\n\r\n    /**\r\n     * @dev Set initial ownership and implementation address\r\n     * @param _implementation Initial address of the implementation\r\n     */\r\n    constructor(address _implementation) public {\r\n        UpgradeableClaimable.initialize(msg.sender);\r\n        implementation = _implementation;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to change the implementation address, which can be called only by the owner\r\n     * @param newImplementation New address of the implementation\r\n     */\r\n    function setImplementation(address newImplementation) external onlyOwner {\r\n        implementation = newImplementation;\r\n        emit ImplementationChanged(newImplementation);\r\n    }\r\n}\r\n\r\n/**\r\n * @title OwnedProxyWithReference\r\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\r\n * Its structure makes it easy for a group of contracts alike, to share an implementation and to change it easily for all of them at once\r\n */\r\ncontract OwnedProxyWithReference {\r\n    /**\r\n     * @dev Event to show ownership has been transferred\r\n     * @param previousOwner representing the address of the previous owner\r\n     * @param newOwner representing the address of the new owner\r\n     */\r\n    event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Event to show ownership transfer is pending\r\n     * @param currentOwner representing the address of the current owner\r\n     * @param pendingOwner representing the address of the pending owner\r\n     */\r\n    event NewPendingOwner(address currentOwner, address pendingOwner);\r\n\r\n    /**\r\n     * @dev Event to show implementation reference has been changed\r\n     * @param implementationReference address of the new implementation reference contract\r\n     */\r\n    event ImplementationReferenceChanged(address implementationReference);\r\n\r\n    // Storage position of the owner and pendingOwner and implementationReference of the contract\r\n    // This is made to ensure, that memory spaces do not interfere with each other\r\n    bytes32 private constant proxyOwnerPosition = 0x6279e8199720cf3557ecd8b58d667c8edc486bd1cf3ad59ea9ebdfcae0d0dfac; //keccak256(\"trueUSD.proxy.owner\");\r\n    bytes32 private constant pendingProxyOwnerPosition = 0x8ddbac328deee8d986ec3a7b933a196f96986cb4ee030d86cc56431c728b83f4; //keccak256(\"trueUSD.pending.proxy.owner\");\r\n    bytes32 private constant implementationReferencePosition = keccak256(\"trueFiPool.implementation.reference\"); //keccak256(\"trueFiPool.implementation.reference\");\r\n\r\n    /**\r\n     * @dev the constructor sets the original owner of the contract to the sender account.\r\n     * @param _owner Initial owner of the proxy\r\n     * @param _implementationReference initial ImplementationReference address\r\n     */\r\n    constructor(address _owner, address _implementationReference) public {\r\n        _setUpgradeabilityOwner(_owner);\r\n        _changeImplementationReference(_implementationReference);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner(), \"only Proxy Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the pending owner.\r\n     */\r\n    modifier onlyPendingProxyOwner() {\r\n        require(msg.sender == pendingProxyOwner(), \"only pending Proxy Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the owner\r\n     * @return owner the address of the owner\r\n     */\r\n    function proxyOwner() public view returns (address owner) {\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            owner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the owner\r\n     * @return pendingOwner the address of the pending owner\r\n     */\r\n    function pendingProxyOwner() public view returns (address pendingOwner) {\r\n        bytes32 position = pendingProxyOwnerPosition;\r\n        assembly {\r\n            pendingOwner := sload(position)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n     * @param newProxyOwner New owner to be set\r\n     */\r\n    function _setUpgradeabilityOwner(address newProxyOwner) internal {\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            sstore(position, newProxyOwner)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the address of the owner\r\n     * @param newPendingProxyOwner New pending owner address\r\n     */\r\n    function _setPendingUpgradeabilityOwner(address newPendingProxyOwner) internal {\r\n        bytes32 position = pendingProxyOwnerPosition;\r\n        assembly {\r\n            sstore(position, newPendingProxyOwner)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * changes the pending owner to newOwner. But doesn't actually transfer\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferProxyOwnership(address newOwner) external onlyProxyOwner {\r\n        require(newOwner != address(0));\r\n        _setPendingUpgradeabilityOwner(newOwner);\r\n        emit NewPendingOwner(proxyOwner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the pendingOwner to claim ownership of the proxy\r\n     */\r\n    function claimProxyOwnership() external onlyPendingProxyOwner {\r\n        emit ProxyOwnershipTransferred(proxyOwner(), pendingProxyOwner());\r\n        _setUpgradeabilityOwner(pendingProxyOwner());\r\n        _setPendingUpgradeabilityOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the proxy owner to change the contract holding address of implementation.\r\n     * @param _implementationReference representing the address contract, which holds implementation.\r\n     */\r\n    function changeImplementationReference(address _implementationReference) public virtual onlyProxyOwner {\r\n        _changeImplementationReference(_implementationReference);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the address of current implementation.\r\n     * @return Returns address of implementation contract\r\n     */\r\n    function implementation() public view returns (address) {\r\n        bytes32 position = implementationReferencePosition;\r\n        address implementationReference;\r\n        assembly {\r\n            implementationReference := sload(position)\r\n        }\r\n        return ImplementationReference(implementationReference).implementation();\r\n    }\r\n\r\n    /**\r\n     * @dev Fallback functions allowing to perform a delegatecall to the given implementation.\r\n     * This function will return whatever the implementation call returns\r\n     */\r\n    fallback() external payable {\r\n        proxyCall();\r\n    }\r\n\r\n    /**\r\n     * @dev This fallback function gets called only when this contract is called without any calldata e.g. send(), transfer()\r\n     * This would also trigger receive() function on called implementation\r\n     */\r\n    receive() external payable {\r\n        proxyCall();\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a low level call, to the contract holding all the logic, changing state on this contract at the same time\r\n     */\r\n    function proxyCall() internal {\r\n        address impl = implementation();\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\r\n            returndatacopy(ptr, 0, returndatasize())\r\n\r\n            switch result\r\n                case 0 {\r\n                    revert(ptr, returndatasize())\r\n                }\r\n                default {\r\n                    return(ptr, returndatasize())\r\n                }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function to internally change the contract holding address of implementation.\r\n     * @param _implementationReference representing the address contract, which holds implementation.\r\n     */\r\n    function _changeImplementationReference(address _implementationReference) internal virtual {\r\n        bytes32 position = implementationReferencePosition;\r\n        assembly {\r\n            sstore(position, _implementationReference)\r\n        }\r\n\r\n        emit ImplementationReferenceChanged(address(_implementationReference));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementationReference\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementationReference\",\"type\":\"address\"}],\"name\":\"ImplementationReferenceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"NewPendingOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ProxyOwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_implementationReference\",\"type\":\"address\"}],\"name\":\"changeImplementationReference\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimProxyOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingProxyOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferProxyOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OwnedProxyWithReference", "CompilerVersion": "v0.6.10+commit.00c0fcaf", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "000000000000000000000000f6e2da7d82ee49f76ce652bc0beb546cbe0ea521000000000000000000000000a47defa29a4df6a9243bdaeb4a4e5c592e17d930", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x8d35372ea3e85c49a60f0a72edeff8629da3999a", "SwarmSource": "ipfs://94e783569eec156e98e953577f0d664ef4b8dbb78a527b28d8ec46d0ac4e64be"}