{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.20;\r\n\r\n\r\nstruct TokenPair{\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint256 amountIn;\r\n        // uint24 fee;\r\n        \r\n        // uint256 amountOut;\r\n    }\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n\r\n\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n    abstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\ninterface IT2SoulSharesSwapData{\r\n     function addItemToSharesTokenList(uint256 sharesSubject, TokenPair calldata item) external returns(bool );\r\n     function getSharesTokenListByShares(uint256 sharesSubject) external view returns (TokenPair[] memory);\r\n     function removeSharesTokenByIdPair(uint256 sharesSubject, address pairTokenIn,address pairTokenOut) external  returns (bool);\r\n     function getTokenPairBalance(uint256 sharesSubject,address tokenIn,address tokenOut) external view  returns(uint256 tokenBalance);\r\n     /**\r\n     * \r\n     * @param sharesSubject subject\r\n     * @param tokenIn  token1 addr\r\n     * @param tokenOut token2 addr \r\n     * @param amount   amout unit wei\r\n     * @param plusflag true:plus,false:sub\r\n     */\r\n     function setTokenPairBlance(uint256 sharesSubject,address tokenIn,address tokenOut,uint256 amount,bool plusflag) external returns(bool );\r\n      \r\n\r\n}\r\n\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint amount) external;\r\n}\r\n\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n/// @title Callback for IUniswapV3PoolActions#swap\r\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\r\ninterface IUniswapV3SwapCallback {\r\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\r\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\r\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\r\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\r\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\r\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\r\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\r\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\r\n    function uniswapV3SwapCallback(\r\n        int256 amount0Delta,\r\n        int256 amount1Delta,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V3\r\ninterface ISwapRouter is IUniswapV3SwapCallback {\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n}\r\n\r\n\r\n\r\nlibrary TransferHelper {\r\n    /// @notice Transfers tokens from the targeted address to the given destination\r\n    /// @notice Errors with 'STF' if transfer fails\r\n    /// @param token The contract address of the token to be transferred\r\n    /// @param from The originating address from which the tokens will be transferred\r\n    /// @param to The destination address of the transfer\r\n    /// @param value The amount to be transferred\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) =\r\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\r\n    }\r\n\r\n    /// @notice Transfers tokens from msg.sender to a recipient\r\n    /// @dev Errors with ST if transfer fails\r\n    /// @param token The contract address of the token which will be transferred\r\n    /// @param to The recipient of the transfer\r\n    /// @param value The value of the transfer\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n    }\r\n\r\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\r\n    /// @dev Errors with 'SA' if transfer fails\r\n    /// @param token The contract address of the token to be approved\r\n    /// @param to The target of the approval\r\n    /// @param value The amount of the given token the target will be allowed to spend\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\r\n    }\r\n\r\n    /// @notice Transfers ETH to the recipient address\r\n    /// @dev Fails with `STE`\r\n    /// @param to The destination of the transfer\r\n    /// @param value The value to be transferred\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'STE');\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IVerifySig{\r\n   \r\n\r\n    /**\r\n     * \r\n     * @param claimer  sender\r\n     * @param questWallet  quest's wallet\r\n     * @param questId  questid\r\n     * @param _signature  sigstr\r\n     * @return signer_ wallet\r\n     * @return resMsg_ \r\n     */   \r\n    function isT2MsgValid(address claimer,address questWallet, uint256 questId,bytes memory _signature) external view returns (address signer_, string memory resMsg_); \r\n}\r\n\r\ncontract Utilities is Ownable, Pausable {\r\n\r\n mapping(address => bool) private admins;\r\n\r\n    function addAdmin(address _address) public virtual onlyOwner {\r\n        // require(_address.code.length>0,\" must be a contract's address\");\r\n        admins[_address] = true;\r\n    }\r\n\r\n    function addAdmins(address[] calldata _addresses) public virtual onlyOwner {\r\n        uint256 len = _addresses.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            // require(_addresses[i].code.length>0,\" must be a contract's address\");\r\n            admins[_addresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    // function addAdminsInternal(address[] calldata _addresses) internal {\r\n    //     uint256 len = _addresses.length;\r\n    //     for(uint256 i=0;i<len;i++)\r\n    //     {\r\n    //         // require(_addresses[i].code.length>0,\" must be a contract's address\");\r\n    //         admins[_addresses[i]]=true;\r\n    //     }\r\n    // }\r\n\r\n    function removeAdmin(address _address) external onlyOwner {\r\n        admins[_address] = false;\r\n    }\r\n\r\n    function removeAdmin(address[] calldata _addresses) external onlyOwner {\r\n        uint256 len = _addresses.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            admins[_addresses[i]] = false;\r\n        }\r\n    }\r\n\r\n    // function removeAdminInternal(\r\n    //     address[] memory _addresses\r\n    // ) internal onlyOwner {\r\n    //     uint256 len = _addresses.length;\r\n    //     for (uint256 i = 0; i < len; i++) {\r\n    //         admins[_addresses[i]] = false;\r\n    //     }\r\n    // }\r\n\r\n    function setPause(bool _shouldPause) external onlyAdminOrOwner {\r\n        if (_shouldPause) {\r\n            _pause();\r\n        } else {\r\n            _unpause();\r\n        }\r\n    }\r\n\r\n    function isAdmin(address _address) public view returns (bool) {\r\n        return admins[_address];\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(admins[msg.sender], \"Not admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdminOrOwner() {\r\n        require(admins[msg.sender] || isOwner(), \"Not admin or owner\");\r\n        _;\r\n    }\r\n    // modifier nonZeroAddress(address _address)    {\r\n    //     require(address(0) != _address, \"0 address\");\r\n    //     _;\r\n    // }\r\n    // modifier nonZeroLength(uint[] memory _array) {\r\n    //     require(_array.length > 0, \"Empty array\");\r\n    //     _;\r\n    // }\r\n    // modifier lengthsAreEqual(uint[] memory _array1, uint[] memory _array2) {\r\n    //     require(_array1.length == _array2.length, \"Unequal lengths\");\r\n    //     _;\r\n    // }\r\n    modifier onlyEOA() {\r\n        /* solhint-disable avoid-tx-origin */\r\n        require(msg.sender == tx.origin, \"No contracts\");\r\n        _;\r\n    }\r\n\r\n    modifier sharesCaller() {\r\n        /* solhint-disable avoid-tx-origin */\r\n        require(msg.sender == tx.origin||isAdmin(msg.sender), \" caller address error \");\r\n        _;\r\n    }\r\n\r\n    function isOwner() internal view returns (bool) {\r\n        return owner() == msg.sender;\r\n    }\r\n\r\n//     function isContract(address addr) internal view returns (bool) {\r\n//         uint256 size;\r\n//         assembly { size := extcodesize(addr) }\r\n//         return size > 0;\r\n//   }\r\n}\r\n\r\n\r\ncontract T2SoulSharesFinance is Utilities {\r\n    // Import SafeMath library for uint256\r\n    using SafeMath for uint256;   \r\n    address public  swapRouteV3Addr;\r\n    address public  swapRouteV2Addr;\r\n\r\n    address public protocolFeeDestination=0x2dFd4225De01DD83Da644285D07Fe2A43A5cEa62;\r\n\r\n    //k-6:official-4,10000000000000000:10000000000000000,k+o=2%\r\n    uint256 private  protocolFeePercent = 0.01 ether;\r\n    uint256 private  subjectFeePercent = 0.01 ether;\r\n    \r\n    //perUnitValue lessthan 1: 10% feed\r\n    // uint256 public lessOneBseFeePercent = 0.1 ether;\r\n    //perUnitValue lessthan 1: 2% feed send to protocol&subjectfeepercent\r\n    uint256 private  lessOneProtocolFeePercent = 0.02 ether;\r\n    //perUnitValue lessthan 1: 8% feed  send to sharespool,lessOneBseFeePercent eq sum(lessOneProtocolFeePercent,lessOneSharesPoolFeePercent)\r\n    uint256 private  lessOneSharesPoolFeePercent = 0.08 ether;\r\n\r\n    //init shares price 10000000000000000\r\n    uint256 public basePrice =0.01 ether;\r\n        \r\n\r\n    //Verify contract's addressqiang\r\n    address private verifySigAddr;\r\n    //signature's address\r\n    address private t2t2SignatureAddr;    \r\n  \r\n    address public WETHAddr;   \r\n    address public  t2swapDataAddr;  \r\n  \r\n    // SharesSubject => (Holder => Balance)\r\n    mapping(uint256 => mapping(address => uint256)) public sharesBalance;\r\n\r\n    // SharesSubject => Supply\r\n    mapping(uint256 => uint256) public sharesSupply;\r\n    mapping(address => uint256) private addr2RoomIdMap;\r\n    mapping(uint256 => address) private roomId2AddrMap;\r\n    //\u623f\u4e3b\u8d39\r\n    mapping(uint256 => uint256) public masterFeeBalance;\r\n    //subject =>amount unitValue lessOne balance reward pool\r\n    mapping(uint256=>uint256) public sharesPool;\r\n    //\u6bcf\u4e2a\u623f\u95f4\u7684eth\u4f59\u989d\r\n    mapping(uint256=>uint256) public roomEthBalance;   \r\n    //30 sec\r\n    uint24 public deadLineSec=30;\r\n\r\n   \r\n\r\n    // totoalpoolAmout:8%\u5956\u91d1\u6c60,totoalpoolAmout:8%\u5956\u91d1\u6c60\u603b\u989d\r\n    event Trade(address trader, uint256 subject,bool isBuy,uint256 shareAmount,uint256 ethAmount,uint256 protocolEthAmount,uint256 subjectEthAmount,uint256 supply,uint256 poolAmount,uint256 poolTotalAmount);    \r\n    //is_buy, totalAmount, changeAmount, tx_hash, created_at \r\n    //tradeType 0:key\u4ea4\u6613\uff0c1.token\u4ea4\u6613\r\n    event SharesETHChange(uint256 subject, uint tradeType,  bool isBuy,uint256 changeAmount);\r\n    event Deposit(address indexed from, uint256 amount);\r\n    event Withdraw(address indexed from, uint256 amount);  \r\n   \r\n    //tokenBalance:token\u4f59\u989d\uff0csharesSubjectEthBalance\uff1a\u623f\u95f4eth\u4f59\u989d\uff0cisBuy --true: \u6295\u8d44eth\u5151\u6362token\uff0cfalse:token \u5151\u6362eth\r\n    event ExcutSwapSingle(uint256 sharesSubject,address sender, bool isBuy, address tokenIn,uint256 tokenInAmout, address tokenOut,uint256 tokenOutAmout,uint24 swapfeed,address receiver);\r\n\r\n    event ExcutSwapMulti(uint256 sharesSubject, address sender,address[] tokenIns,uint24[]  fees, address tokenOut,uint256 tokenOutAmout,address receiver);\r\n\r\n\r\n    constructor()\r\n    {}\r\n\r\n\r\n    function setUniSwapAddr(address uniV2RouterAddr_,address uniV3RouterAddr_) external onlyAdminOrOwner  returns (bool)\r\n    {\r\n        require(uniV2RouterAddr_!= address(0) && uniV3RouterAddr_!= address(0),\" set uniVRouter error\");\r\n        swapRouteV2Addr = uniV2RouterAddr_;      \r\n        swapRouteV3Addr = uniV3RouterAddr_;\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n   function setContracts(address verifySigAddr_, address t2t2SigAddr_,address  t2swapDataAddr_,address weth_) external onlyAdminOrOwner  returns (bool) {\r\n        require(verifySigAddr_ != address(0) && t2t2SigAddr_ != address(0) && t2swapDataAddr_!=address(0) && weth_ != address(0) ,\"set contracts error\" ); \r\n        verifySigAddr = verifySigAddr_;\r\n        t2t2SignatureAddr = t2t2SigAddr_;   \r\n         WETHAddr = weth_;   \r\n        t2swapDataAddr = t2swapDataAddr_;              \r\n        return true;\r\n    }\r\n\r\n    function setBasePrice(uint256 _basePrice) public onlyAdminOrOwner {\r\n        basePrice = _basePrice;\r\n    }\r\n\r\n     function setDeadLine(uint24 _deadLine) public onlyAdminOrOwner {\r\n        \r\n        deadLineSec = _deadLine;\r\n    }\r\n\r\n\r\n    function setFeesInfor(uint256 _protocolFee,uint256 _subjectFee,uint256 _lessOneProtocolFee,uint256 _lessOneSharesPoolFee) public onlyAdminOrOwner {\r\n        protocolFeePercent = _protocolFee;\r\n        subjectFeePercent = _subjectFee;\r\n        lessOneProtocolFeePercent = _lessOneProtocolFee;\r\n        lessOneSharesPoolFeePercent = _lessOneSharesPoolFee;\r\n    }\r\n\r\n    function getFeesInfor() public view returns (uint256 _protocolFee,uint256 _subjectFee,uint256 _lessOneProtocolFee,uint256 _lessOneSharesPoolFee)\r\n    {\r\n        \r\n        _protocolFee= protocolFeePercent;\r\n        _subjectFee=subjectFeePercent;\r\n        _lessOneProtocolFee= lessOneProtocolFeePercent ;\r\n        _lessOneSharesPoolFee=lessOneSharesPoolFeePercent ;\r\n    }\r\n\r\n    function setFeeDestination(\r\n        address _feeDestination\r\n    ) public onlyAdminOrOwner {\r\n        require(address(0)!=_feeDestination,\" addr error\");\r\n        protocolFeeDestination = _feeDestination;\r\n    }\r\n\r\n     \r\n    function getSharesTokenListByShares(uint256 sharesSubject) public view returns (TokenPair[] memory) {\r\n        return  IT2SoulSharesSwapData(t2swapDataAddr).getSharesTokenListByShares(sharesSubject);\r\n    }\r\n\r\n    function getTokenPairBalance(uint256 sharesSubject,address tokenIn,address tokenOut) public view  returns(uint256 tokenBalance){\r\n      \r\n        return  IT2SoulSharesSwapData(t2swapDataAddr).getTokenPairBalance(sharesSubject,tokenIn,tokenOut);\r\n\r\n    }  \r\n\r\n    function getSwapAmountArry(uint amountIn, address[] memory  paths) public view  returns(uint[] memory amountOut)\r\n    {\r\n         amountOut = IUniswapV2Router02(swapRouteV2Addr).getAmountsOut(amountIn,paths);\r\n         return amountOut;\r\n    }\r\n\r\n    function getSwapAmount(uint amountIn,address  tokenIn,address  tokenOut) public view  returns(uint[] memory amountOut)\r\n    {       \r\n        address[] memory paths = new address[](2);\r\n        paths[0] = tokenIn;\r\n        paths[1] = tokenOut;              \r\n        amountOut = IUniswapV2Router02(swapRouteV2Addr).getAmountsOut(amountIn,paths);\r\n        return amountOut;\r\n    }\r\n   \r\n\r\n    function getPrice(uint256 supply,uint256 amount) public view returns (uint256) {\r\n        uint256 sum1 = supply == 0? 0: ((supply - 1) * (supply) * (2 * (supply - 1) + 1)) / 6;\r\n        uint256 sum2 = supply == 0 && amount == 1? 0: ((supply - 1 + amount) *(supply + amount) * (2 * (supply - 1 + amount) + 1)) / 6;\r\n        uint256 summation = sum2 - sum1;\r\n        uint256 basePrice_ = basePrice.mul(amount);\r\n        return basePrice_>0?basePrice_.add((summation * 1 ether) / 16000):((summation * 1 ether) / 16000);\r\n        // return  basePrice.add((summation * 1 ether) / 16000);\r\n    }\r\n\r\n    function getBuyPrice(uint256 sharesSubject,uint256 amount\r\n    ) public view returns (uint256) {\r\n        return getPrice(sharesSupply[sharesSubject], amount);\r\n    }\r\n\r\n    function getSellPrice(uint256 sharesSubject,uint256 amount) public view returns (uint256) {\r\n        return getPrice(sharesSupply[sharesSubject] - amount, amount);\r\n    }\r\n\r\n    function getBuyPriceAfterFee(uint256 sharesSubject,uint256 amount) public view returns (uint256) {\r\n        uint256 price = getBuyPrice(sharesSubject, amount);\r\n        uint256 protocolFee = (price * protocolFeePercent) / 1 ether;\r\n        uint256 subjectFee = (price * subjectFeePercent) / 1 ether;\r\n        return price + protocolFee + subjectFee;\r\n    }\r\n\r\n    function getSellPriceAfterFee(\r\n        uint256 sharesSubject,\r\n        uint256 amount\r\n    ) public view returns (uint256) {\r\n        uint256 price = getSellPrice(sharesSubject, amount);\r\n        uint256 protocolFee = (price * protocolFeePercent) / 1 ether;\r\n        uint256 subjectFee = (price * subjectFeePercent) / 1 ether;\r\n        return price - protocolFee - subjectFee;\r\n    }\r\n\r\n    //\u57fa\u91d1\u4efd\u989d\r\n  \r\n\r\n    function getSharesTotalAmount(uint256 sharesSubject) public view returns(uint256 )\r\n    {\r\n        uint256 supply = sharesSupply[sharesSubject];\r\n        if(supply==0)\r\n        {\r\n          return 0;\r\n        }\r\n        else{\r\n            uint256 sumFundShareAmount =0;\r\n            for (uint32 i = 0; i <supply; i++) {\r\n                sumFundShareAmount = sumFundShareAmount+getPrice(i,1);\r\n            }\r\n            return sumFundShareAmount;\r\n        }\r\n    }\r\n\r\n\r\n    \r\n \r\n    function buyShares(uint256 sharesSubject, uint256 amount) public payable sharesCaller {\r\n\r\n        uint256 supply = sharesSupply[sharesSubject];\r\n        // require(\r\n        //     supply > 0 || sharesSubject == msg.sender,\r\n        //     \"Only the shares' subject can buy the first share\"\r\n        // );\r\n        require(supply > 0, \"Unable to buy sharesSubject don't running\");\r\n        buyInterShares(sharesSubject, amount, supply);\r\n    }\r\n\r\n    function getETHProfit(uint256 sharesSubject, uint256 sellRatio) public view returns(bool existToken_,uint256 swapWETHTotalAmout_, TokenPair[] memory sellPairs_){\r\n        existToken_= false;\r\n        swapWETHTotalAmout_ =0;\r\n        uint256 sharesTokenBalance =0;\r\n        uint256 swapAmoutInTemp =0;       \r\n        uint256 i =0;\r\n        uint256[] memory amoutOut;\r\n\r\n         TokenPair[] memory tokenPairs = IT2SoulSharesSwapData(t2swapDataAddr).getSharesTokenListByShares(sharesSubject);\r\n         if(tokenPairs.length==0)\r\n         {\r\n            return(false,0,sellPairs_); \r\n         } \r\n        sellPairs_=  new TokenPair[](tokenPairs.length);\r\n        for (uint128 index = 0; index < tokenPairs.length; index++) {\r\n          sharesTokenBalance=  IT2SoulSharesSwapData(t2swapDataAddr).getTokenPairBalance(sharesSubject,tokenPairs[index].tokenIn,tokenPairs[index].tokenOut);\r\n          if(sharesTokenBalance>0)\r\n          {\r\n              existToken_ = true;\r\n              //sell Amount\r\n              swapAmoutInTemp = (sharesTokenBalance.mul(sellRatio))/1 ether;\r\n              TokenPair memory item = TokenPair(tokenPairs[index].tokenOut, tokenPairs[index].tokenIn,swapAmoutInTemp);\r\n              sellPairs_[i]=item;\r\n              i = i+1;\r\n              address[] memory paths = new address[](2);\r\n              paths[0] = tokenPairs[index].tokenOut;\r\n              paths[1] = tokenPairs[index].tokenIn;               \r\n              amoutOut = IUniswapV2Router02(swapRouteV2Addr).getAmountsOut(sharesTokenBalance,paths);\r\n              //weth\u6536\u76ca\u603b\u6536\u76ca\u91cf\r\n              swapWETHTotalAmout_ = swapWETHTotalAmout_.add(amoutOut[0]);\r\n          }\r\n        }\r\n\r\n        return(existToken_,swapWETHTotalAmout_,sellPairs_);\r\n\r\n    }\r\n\r\n\r\n    function emitExcutSwapSingle(uint256 sharesSubject, bool isBuy, address tokenIn,uint256 tokenInAmout, address tokenOut,uint256 tokenOutAmout,uint24 swapfeed) internal {\r\n        emit ExcutSwapSingle(sharesSubject,msg.sender,isBuy,tokenIn,tokenInAmout,tokenOut,tokenOutAmout,swapfeed,address(this));             \r\n    }\r\n\r\n    function getSellRatio(uint256 sharesSubject, uint256 price) public view returns (uint256 ratio)\r\n    {\r\n        ratio = 1;\r\n        uint256 sharesTotalAmout =   getSharesTotalAmount(sharesSubject);\r\n        if(sharesTotalAmout==0)\r\n        {\r\n            return ratio;\r\n        }else \r\n        {\r\n           //using div 1 ether\r\n            ratio = price.mul(1 ether).div(sharesTotalAmout);\r\n            return ratio;     \r\n        }\r\n        \r\n    } \r\n\r\n    \r\n    //\u6e05\u7b97\u8d44\u4ea7\r\n    function sellAssetToken(uint256 sharesSubject,uint256 price,uint24 swapFee) internal returns(uint256 price_ ) {\r\n\r\n        bool existToken_ = false;  \r\n        price_ =0;\r\n        // perUnitValue_=1;\r\n        // uint256 sharesTotalAmout =   getSharesTotalAmount(sharesSubject);\r\n        uint256 sellRatio = getSellRatio(sharesSubject,price);// price.mul(1 ether).div(sharesTotalAmout);\r\n        TokenPair[] memory sellPairs; \r\n        uint256  swapWETHTotalAmout =0; \r\n        uint256 swapAmoutInTemp =0;\r\n        (existToken_,swapWETHTotalAmout,sellPairs)=getETHProfit(sharesSubject,sellRatio);\r\n\r\n         //\u53ea\u5b58\u5728eth\r\n        if(existToken_==false)\r\n        {\r\n            // uint256 re =roomEthBalance[sharesSubject];\r\n            //\u5355\u4f4d\u51c0\u503c            \r\n            // perUnitValue_  =re.div(sharesTotalAmout)/ 1 ether;\r\n            price_ = (sellRatio.mul(roomEthBalance[sharesSubject]))/1 ether; \r\n            require(roomEthBalance[sharesSubject]>=price_,\" price balance error\");\r\n            roomEthBalance[sharesSubject] = roomEthBalance[sharesSubject].sub(price_);        \r\n            emit SharesETHChange(sharesSubject,0,false,price_);\r\n\r\n        }\r\n\r\n        if(existToken_==true)\r\n        {          \r\n           uint256 swapToken2WETH =0; \r\n        //    uint256 re =0;\r\n           for (uint128 index = 0; index < sellPairs.length; index++) {             \r\n                   IT2SoulSharesSwapData(t2swapDataAddr).setTokenPairBlance(sharesSubject,sellPairs[index].tokenOut,sellPairs[index].tokenIn,sellPairs[index].amountIn,false);                                 \r\n                   TransferHelper.safeApprove(sellPairs[index].tokenIn, swapRouteV3Addr, sellPairs[index].amountIn);  \r\n                   swapAmoutInTemp =swapSingle(sellPairs[index].tokenIn,sellPairs[index].tokenOut,sellPairs[index].amountIn,swapFee,address(this)); \r\n                   swapToken2WETH = swapToken2WETH.add(swapAmoutInTemp);          \r\n                   emitExcutSwapSingle(sharesSubject,false,sellPairs[index].tokenIn,sellPairs[index].amountIn, sellPairs[index].tokenOut,swapAmoutInTemp,swapFee);\r\n               }          \r\n            IWETH(WETHAddr).withdraw(swapToken2WETH);               \r\n           //\u53ea\u5b58\u5728token\r\n            if(roomEthBalance[sharesSubject]==0)\r\n            {   \r\n                //swapWETHTotalAmout \u603b\u51c0\u8d44\u4ea7              \r\n                // perUnitValue_  =swapWETHTotalAmout.div(sharesTotalAmout)/ 1 ether;                       \r\n                price_=swapToken2WETH;\r\n            }else if(roomEthBalance[sharesSubject]>0 )\r\n            {  //\u5b58\u5728eth\u548ctoken                \r\n                //\u6e05\u7b97\u623f\u95f4eth \r\n                swapAmoutInTemp= roomEthBalance[sharesSubject].mul(sellRatio)/1 ether;\r\n                require(roomEthBalance[sharesSubject]>=swapAmoutInTemp,\" roomEthBalance  error\");\r\n                //\u623f\u95f4\u603b\u4ef7\u503c\r\n                swapWETHTotalAmout =swapWETHTotalAmout.add(roomEthBalance[sharesSubject]);\r\n                // perUnitValue_  =swapWETHTotalAmout.div(sharesTotalAmout)/1 ether;               \r\n                roomEthBalance[sharesSubject]=roomEthBalance[sharesSubject].sub(swapAmoutInTemp); \r\n                emit SharesETHChange(sharesSubject,0,false,swapAmoutInTemp);\r\n                price_ = swapToken2WETH.add(swapAmoutInTemp);\r\n            }\r\n        }\r\n        \r\n        return price_;\r\n\r\n    }\r\n\r\n    function sellShares(uint256 sharesSubject, uint256 amount,uint24 swapFee) public payable sharesCaller {\r\n      \r\n        uint256 supply = sharesSupply[sharesSubject];\r\n        require(supply > amount, \"Cannot sell the last share\");\r\n        require(sharesBalance[sharesSubject][msg.sender] >= amount,\"Insufficient shares amount \");\r\n       \r\n\r\n        uint256 price = getPrice(supply- amount, amount);\r\n        //\u4f7f\u7528\u65f6\u5728\u9664\u4ee5 1 ether 5343750000000000\r\n        // uint256 sellRatio = price.mul(1 ether).div(sharesTotalAmout);\r\n        //\u8ba1\u7b97\u4ef7\u683c\u5360\u6bd4\r\n        //\u6e05\u7b97token 1.\u53ea\u6709ETH\uff0c2.\u53ea\u6709\u6709token token\uff0c3.\u6709eth&token      \r\n        // uint256 sharesTokenBalance =0;\r\n        uint256 perUnitValue=1;  \r\n        //\u603b\u6536\u76ca\r\n        (,perUnitValue,)=getETHProfit(sharesSubject,getSellRatio(sharesSubject,price));\r\n      \r\n        perUnitValue = perUnitValue.add(roomEthBalance[sharesSubject]); \r\n      \r\n        //\u51c0\u503c\r\n        perUnitValue = (perUnitValue.mul(1 ether)).div(getSharesTotalAmount(sharesSubject))/ 1 ether; \r\n        \r\n        price=  sellAssetToken(sharesSubject,price,swapFee);\r\n     \r\n        uint256 protocolFee=0;\r\n        uint256 subjectFee=0;\r\n        uint256 lessOneSharesFundPoolFee=0;\r\n        if(perUnitValue>=1)\r\n        {\r\n            protocolFee = (price * protocolFeePercent) / 1 ether;\r\n            subjectFee = (price * subjectFeePercent) / 1 ether;\r\n        }else if(perUnitValue<1)\r\n        {      \r\n           protocolFee=subjectFee =((price * lessOneProtocolFeePercent) / 1 ether).div(2);\r\n           lessOneSharesFundPoolFee = (price * lessOneSharesPoolFeePercent) / 1 ether;\r\n             \r\n        }\r\n   \r\n        sharesBalance[sharesSubject][msg.sender] =sharesBalance[sharesSubject][msg.sender] - amount;\r\n        sharesSupply[sharesSubject] = sharesSupply[sharesSubject] - amount;      \r\n     \r\n        // uint256 getValue = price - protocolFee - subjectFee;\r\n        if(perUnitValue>=1)\r\n        {\r\n            (bool success1, ) = msg.sender.call{value:  (price - protocolFee - subjectFee)}(\"\");\r\n            (bool success2, ) = protocolFeeDestination.call{value: protocolFee}(\"\");\r\n\r\n            // (bool success3, ) = sharesSubject.call{value: subjectFee}(\"\");\r\n            //   require(success1 && success2 && success3, \"Unable to send funds\");\r\n            masterFeeBalance[sharesSubject] = masterFeeBalance[sharesSubject].add(subjectFee);\r\n            require(success1 && success2, \"Unable to sell send funds\");\r\n        }else if(perUnitValue<1)\r\n        {\r\n            (bool success1, ) = msg.sender.call{value:  (price - protocolFee - subjectFee)}(\"\");\r\n            (bool success2, ) = protocolFeeDestination.call{value: protocolFee}(\"\");\r\n            masterFeeBalance[sharesSubject] = masterFeeBalance[sharesSubject].add(subjectFee);\r\n            sharesPool[sharesSubject] =sharesPool[sharesSubject].add(lessOneSharesFundPoolFee);\r\n            require(success1 && success2, \"Unable to sell pool send funds\");\r\n        }\r\n        // uint256 pools = sharesPool[sharesSubject];\r\n        perUnitValue = sharesPool[sharesSubject];\r\n        supply= supply- amount;\r\n        emitTrader(msg.sender,sharesSubject,false,amount,price,protocolFee,subjectFee,supply,lessOneSharesFundPoolFee, perUnitValue);\r\n\r\n\r\n    }\r\n\r\n    function buyInterShares(uint256 sharesSubject,uint256 amount,uint256 supply) internal {\r\n        // uint256 supply = sharesSupply[sharesSubject];       \r\n        uint256 price = getPrice(supply, amount);\r\n        uint256 protocolFee = (price * protocolFeePercent) / 1 ether;\r\n        uint256 subjectFee = (price * subjectFeePercent) / 1 ether;    \r\n        require(msg.value >= price + protocolFee + subjectFee,\"Insufficient payment\");\r\n        sharesBalance[sharesSubject][msg.sender] =sharesBalance[sharesSubject][msg.sender] + amount;\r\n        sharesSupply[sharesSubject] = supply + amount;        \r\n        uint256 balanceValue = msg.value.sub(protocolFee);\r\n        balanceValue = balanceValue.sub(subjectFee);\r\n\r\n        roomEthBalance[sharesSubject]=roomEthBalance[sharesSubject].add(balanceValue);\r\n        emit SharesETHChange(sharesSubject,0,true,balanceValue);\r\n        uint256 swapWETHTotalAmout =0;\r\n     \r\n        //\u4efd\u989d\r\n        uint256 sharesTotalAmout =   getSharesTotalAmount(sharesSubject);\r\n        uint256 sellRatio = getSellRatio(sharesSubject,price);// price.mul(1 ether).div(sharesTotalAmout);      \r\n        (,swapWETHTotalAmout,)=getETHProfit(sharesSubject,sellRatio);\r\n        swapWETHTotalAmout = swapWETHTotalAmout.add(roomEthBalance[sharesSubject]);           \r\n        if(supply>0)\r\n        {\r\n            //\u51c0\u503c\r\n            sharesTotalAmout  =swapWETHTotalAmout.div(sharesTotalAmout)/ 1 ether;  \r\n        }\r\n        masterFeeBalance[sharesSubject] = masterFeeBalance[sharesSubject].add(subjectFee);   \r\n        (bool success1, ) = protocolFeeDestination.call{value: protocolFee}(\"\");      \r\n        sellRatio=0;   \r\n        if (sharesTotalAmout<1)\r\n        {\r\n           if(sharesPool[sharesSubject]>0) \r\n           {\r\n                sellRatio = sharesPool[sharesSubject];\r\n                sharesPool[sharesSubject]=0;        \r\n                (bool success2, ) = msg.sender.call{value: sellRatio}(\"\"); \r\n                require(success1 && success2, \" Unable buy to send pool funds\");\r\n           }else\r\n           {\r\n             require(success1, \" protocolFee 1 error \");\r\n           }\r\n        }else \r\n        {\r\n            require(success1, \" protocolFee 2 error\");\r\n        }\r\n        // (bool success2, ) = sharesSubject.call{value: subjectFee}(\"\");\r\n        // require(success1 && success2, \"Unable to send funds\");\r\n        // sharesTotalAmout ==sellRatio\r\n        sharesTotalAmout = sharesSupply[sharesSubject];     \r\n        balanceValue   =sharesPool[sharesSubject];\r\n        //sellRatio \u4ee3\u8868\u5192\u9669\u57fa\u91d1\r\n        emitTrader(msg.sender,sharesSubject,true, amount,price,protocolFee,subjectFee,sharesTotalAmout,sellRatio, balanceValue);\r\n        \r\n        \r\n        \r\n    }\r\n   \r\n     function emitTrader(address trader, uint256 subject,bool isBuy,uint256 shareAmount,uint256 ethAmount,uint256 protocolEthAmount,uint256 subjectEthAmount,uint256 supply,uint256 poolAmount,uint256 poolTotalAmount) internal {\r\n         emit Trade(trader,subject,isBuy, shareAmount,ethAmount,protocolEthAmount,subjectEthAmount,supply,poolAmount,poolTotalAmount);\r\n     }\r\n\r\n\r\n    // function bindRoomTest(uint256 sharesSubject) payable external  returns (bool) {\r\n    \r\n    //     address addr_ = tx.origin;\r\n    //     uint256 supply = sharesSupply[sharesSubject];\r\n    //     if (supply == 0) {\r\n    //         buyInterShares(sharesSubject, 1, supply);\r\n    //     }\r\n\r\n    //     if (roomId2AddrMap[sharesSubject] != address(0)) {\r\n    //         delete addr2RoomIdMap[roomId2AddrMap[sharesSubject]];\r\n    //         delete roomId2AddrMap[sharesSubject];\r\n    //     }\r\n    //     roomId2AddrMap[sharesSubject] = addr_;\r\n    //     addr2RoomIdMap[addr_] = sharesSubject;\r\n    //     return true;\r\n    // }\r\n\r\n    function bindRoomAddr(uint256 sharesSubject,bytes memory _signature) payable external sharesCaller whenNotPaused returns (bool) {\r\n        \r\n     \r\n        require(verifySinger(sharesSubject, _signature), \" singer error\");\r\n        address addr_ = tx.origin;\r\n        uint256 supply = sharesSupply[sharesSubject];\r\n        if (supply == 0) {\r\n            buyInterShares(sharesSubject, 1, supply);\r\n        }\r\n\r\n        if (roomId2AddrMap[sharesSubject] != address(0)) {\r\n            delete addr2RoomIdMap[roomId2AddrMap[sharesSubject]];\r\n            delete roomId2AddrMap[sharesSubject];\r\n        }\r\n        roomId2AddrMap[sharesSubject] = addr_;\r\n        addr2RoomIdMap[addr_] = sharesSubject;\r\n        return true;\r\n    }\r\n\r\n    function getBindRoomAddr( uint256 roomId ) public view  returns (address addr) {\r\n        return roomId2AddrMap[roomId];\r\n    }\r\n\r\n    fallback() external payable {\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function verifySinger( uint256 roomId, bytes memory _signature ) internal view returns (bool) {\r\n        IVerifySig verifySig = IVerifySig(verifySigAddr);\r\n        string memory sigStr = \"\";\r\n        address sig_;        \r\n        (sig_, sigStr) = verifySig.isT2MsgValid(tx.origin, t2t2SignatureAddr,roomId, _signature );       \r\n        if (sig_ == t2t2SignatureAddr) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 sharesSubject) external {\r\n        address to = roomId2AddrMap[sharesSubject];\r\n        uint256 amount_ = masterFeeBalance[sharesSubject];\r\n        require(msg.sender == to,\" room's address or sender's address is error\");\r\n        require(amount_ > 0, \" shaers key amount error\");\r\n        masterFeeBalance[sharesSubject] = 0;\r\n        uint256 amount = address(this).balance;\r\n        require(amount >= amount_, \" withdraw amount error! \");\r\n        payable(to).transfer(amount_);\r\n        emit Withdraw(to, amount_);\r\n    }\r\n\r\n    //swap\r\n    function ethApproveSwap(uint256 amountIn) public {         \r\n        IWETH(WETHAddr).deposit{value: amountIn}();\r\n        IWETH(WETHAddr).approve(swapRouteV3Addr, amountIn);  \r\n    }\r\n\r\n    //token \u5151\u6362eth\r\n    function sellToken(uint256 sharesSubject,address tokenIn,address tokenOut,uint256 amountIn,uint24 swapFee) public  sharesCaller\r\n    {   \r\n        \r\n          \r\n        uint256 tokenBalance =  IT2SoulSharesSwapData(t2swapDataAddr).getTokenPairBalance(sharesSubject,tokenIn,tokenOut);  \r\n        require(tokenBalance>=amountIn && amountIn>0 ,\" amountIn error \");       \r\n        require(msg.sender ==  roomId2AddrMap[sharesSubject],\" room's address or sender's address is error\");         \r\n        require(tokenIn!=address(0) && tokenOut!=address(0) && swapFee>0,\" pairs error\");         \r\n        address receiver = address(this);\r\n        // \r\n        TransferHelper.safeApprove(tokenIn, swapRouteV3Addr, amountIn);  \r\n        IT2SoulSharesSwapData(t2swapDataAddr).setTokenPairBlance(sharesSubject,tokenIn,tokenOut,amountIn,false); \r\n        uint256 tokenAmontOut = swapSingle(tokenIn,tokenOut,amountIn,swapFee,receiver);      \r\n        IWETH(WETHAddr).withdraw(tokenAmontOut);         \r\n        roomEthBalance[sharesSubject]=roomEthBalance[sharesSubject].add(tokenAmontOut);  \r\n        emit SharesETHChange(sharesSubject,1,false,tokenAmontOut);    \r\n        emit ExcutSwapSingle(sharesSubject,msg.sender,false,tokenIn,amountIn,tokenOut,tokenAmontOut,swapFee,receiver); \r\n\r\n    }\r\n\r\n    //front call eth->token\r\n    function excuteBuySingle(uint256 sharesSubject,address tokenIn,address tokenOut,uint256 amountIn,uint24 swapFee)  public sharesCaller payable  {\r\n       \r\n        require(address(tokenIn)==address(WETHAddr) ,\" tokenIn address error\"); \r\n        require(tokenIn!=address(0) && tokenOut!=address(0),\" token address error\");\r\n        require(amountIn>0 ,\" amountIn error\");       \r\n        require(roomEthBalance[sharesSubject]>=amountIn, \" room's eth amount error\");\r\n        require(msg.sender ==  roomId2AddrMap[sharesSubject],\" room's address or sender's address is error\");         \r\n        require(tokenIn!=address(0) && tokenOut!=address(0) && swapFee>0,\" pairs error\");    \r\n\r\n        roomEthBalance[sharesSubject]=roomEthBalance[sharesSubject].sub(amountIn);  \r\n        emit SharesETHChange(sharesSubject,1,true,amountIn);          \r\n        IWETH(WETHAddr).deposit{value: amountIn}();\r\n        TransferHelper.safeApprove(tokenIn, swapRouteV3Addr, amountIn);        \r\n        address receiver =address(this);             \r\n          // pool swapFee 0.3%\r\n        // ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams(\r\n        //     { tokenIn: tokenIn,tokenOut: tokenOut,fee: swapFee,recipient: receiver,deadline: block.timestamp+deadLineSec,amountIn: amountIn,amountOutMinimum: 0,\r\n        //     // NOTE: In production, this value can be used to set the limit\r\n        //     // for the price the swap will push the pool to,\r\n        //     // which can help protect against price impact\r\n        //     sqrtPriceLimitX96: 0\r\n        // });\r\n        uint256 amountOut =swapSingle(tokenIn,tokenOut,amountIn,swapFee,receiver); \r\n        //\u6dfb\u52a0\u6bcf\u4e2a\u623f\u95f4\u7684\u6570\u91cf   addItemToSharesTokenList(uint256 sharesSubject, TokenPair calldata item) \r\n        TokenPair memory item = TokenPair(tokenIn,tokenOut,amountIn);  \r\n        IT2SoulSharesSwapData(t2swapDataAddr).addItemToSharesTokenList(sharesSubject,item);     \r\n        IT2SoulSharesSwapData(t2swapDataAddr).setTokenPairBlance(sharesSubject,tokenIn,tokenOut,amountOut,true);          \r\n        emit ExcutSwapSingle(sharesSubject,msg.sender,true,tokenIn,amountIn,tokenOut,amountOut,swapFee,receiver);       \r\n        \r\n    }\r\n\r\n     function swapSingle(address tokenIn,address tokenOut,uint256 amountIn,uint24 swapFee,address receiver)  internal returns(uint256 amountOut)   {\r\n\r\n     \r\n           // pool swapFee 0.3%\r\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams(\r\n            { tokenIn: tokenIn,tokenOut: tokenOut,fee: swapFee,recipient: receiver,deadline: block.timestamp+deadLineSec,amountIn: amountIn,amountOutMinimum: 0,\r\n            // NOTE: In production, this value can be used to set the limit\r\n            // for the price the swap will push the pool to,\r\n            // which can help protect against price impact\r\n            sqrtPriceLimitX96: 0\r\n        });\r\n        amountOut = ISwapRouter(swapRouteV3Addr).exactInputSingle(params);\r\n        return amountOut;\r\n\r\n     }\r\n\r\n\r\n     \r\n\r\n    // function excuteBuyMulti(uint256 sharesSubject,address[] calldata tokenIns,uint24[] calldata fees,address tokenOut,uint256 amountIn) external sharesCaller{\r\n       \r\n  \r\n    //     require(amountIn>0 ,\" amountIn error\");       \r\n    //     require(roomEthBalance[sharesSubject]>=amountIn, \" room's eth amount error\");\r\n    //     require(msg.sender ==  roomId2AddrMap[sharesSubject],\" room's address or sender's address is error\");                        \r\n       \r\n    //     uint256 tokenLen =tokenIns.length;\r\n    //     address receiver =address(this);\r\n    //     bytes memory paths;\r\n    //     require(tokenLen>=2 && tokenLen<=4 && tokenLen==fees.length,\" excuteMulti params numberic error\");\r\n    //     for (uint24 index = 0; index < tokenLen; index++) {\r\n    //         require(tokenIns[index]!=address(0) && fees[index]>0,\" excuteMulti pairs element error\");\r\n    //     }\r\n\r\n    //     roomEthBalance[sharesSubject]=roomEthBalance[sharesSubject].sub(amountIn);     //  \r\n    //     emit SharesETHChange(sharesSubject,1,true,amountIn,re);  \r\n    //     IWETH(WETHAddr).deposit{value: amountIn}();\r\n    //     TransferHelper.safeApprove(tokenIns[0], swapRouteV3Addr, amountIn); \r\n\r\n    //     if(tokenLen==2)\r\n    //     {\r\n    //         paths =abi.encodePacked(tokenIns[0],uint24(fees[0]),tokenIns[1],uint24(fees[1]),tokenOut);\r\n    //     }else if(tokenLen==3)\r\n    //     {\r\n    //         paths =abi.encodePacked(tokenIns[0],uint24(fees[0]),tokenIns[1],uint24(fees[1]),tokenIns[2],uint24(fees[2]),tokenOut);\r\n    //     }else if(tokenLen==4)\r\n    //     {\r\n    //         paths =abi.encodePacked(tokenIns[0],uint24(fees[0]),tokenIns[1],uint24(fees[1]),tokenIns[2],uint24(fees[2]),tokenIns[3],uint24(fees[3]),tokenOut);\r\n    //     }\r\n       \r\n    //     // ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams(\r\n    //     //     {   path:paths,recipient: receiver, deadline: block.timestamp+deadLineSec, amountIn: amountIn,amountOutMinimum: 0 });\r\n    //     // uint256 amountOut = swapRouter.exactInput(params);  \r\n    //     uint256 amountOut =swapMultil(paths,amountIn,receiver);\r\n    //       //\u6dfb\u52a0\u6bcf\u4e2a\u623f\u95f4\u7684\u6570\u91cf\r\n    //     TokenPair memory item = TokenPair(tokenIns[0],tokenOut,amountIn);  \r\n    //     IT2SoulSharesSwapData(t2swapDataAddr).addItemToSharesTokenList(sharesSubject,item);     \r\n    //     IT2SoulSharesSwapData(t2swapDataAddr).setTokenPairBlance(sharesSubject,tokenIns[0],tokenOut,amountOut,true); \r\n    \r\n    //     emit ExcutSwapMulti(sharesSubject, msg.sender,tokenIns,fees,tokenOut,amountOut,receiver);        \r\n    // }\r\n\r\n    // function swapMultil(bytes memory paths,uint256 amountIn,address receiver)  internal returns(uint256 amountOut){\r\n    //      ISwapRouter.ExactInputParams memory params = ISwapRouter.ExactInputParams(\r\n    //         {   path:paths,recipient: receiver, deadline: block.timestamp+deadLineSec, amountIn: amountIn,amountOutMinimum: 0 });\r\n    //      amountOut = ISwapRouter(swapRouteV3Addr).exactInput(params);  \r\n    //      return amountOut; \r\n\r\n    // }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokenIns\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint24[]\",\"name\":\"fees\",\"type\":\"uint24[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenOutAmout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ExcutSwapMulti\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenInAmout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenOutAmout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"swapfeed\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ExcutSwapSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"changeAmount\",\"type\":\"uint256\"}],\"name\":\"SharesETHChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBuy\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolEthAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subjectEthAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolTotalAmount\",\"type\":\"uint256\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"WETHAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"addAdmins\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"basePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"bindRoomAddr\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyShares\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadLineSec\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"ethApproveSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"swapFee\",\"type\":\"uint24\"}],\"name\":\"excuteBuySingle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roomId\",\"type\":\"uint256\"}],\"name\":\"getBindRoomAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getBuyPriceAfterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellRatio\",\"type\":\"uint256\"}],\"name\":\"getETHProfit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"existToken_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"swapWETHTotalAmout_\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenPair[]\",\"name\":\"sellPairs_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeesInfor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_subjectFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lessOneProtocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lessOneSharesPoolFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getSellPriceAfterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getSellRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"}],\"name\":\"getSharesTokenListByShares\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenPair[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"}],\"name\":\"getSharesTotalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSwapAmount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"paths\",\"type\":\"address[]\"}],\"name\":\"getSwapAmountArry\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amountOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getTokenPairBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"masterFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeDestination\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roomEthBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"swapFee\",\"type\":\"uint24\"}],\"name\":\"sellShares\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"swapFee\",\"type\":\"uint24\"}],\"name\":\"sellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_basePrice\",\"type\":\"uint256\"}],\"name\":\"setBasePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"verifySigAddr_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t2t2SigAddr_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t2swapDataAddr_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth_\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"_deadLine\",\"type\":\"uint24\"}],\"name\":\"setDeadLine\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeDestination\",\"type\":\"address\"}],\"name\":\"setFeeDestination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_subjectFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lessOneProtocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lessOneSharesPoolFee\",\"type\":\"uint256\"}],\"name\":\"setFeesInfor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_shouldPause\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniV2RouterAddr_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniV3RouterAddr_\",\"type\":\"address\"}],\"name\":\"setUniSwapAddr\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sharesBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sharesPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sharesSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouteV2Addr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouteV3Addr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"t2swapDataAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharesSubject\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "T2SoulSharesFinance", "CompilerVersion": "v0.8.22+commit.4fc1097e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://daed4072e792ed07bee613cd4e4c0fc68309d1fca3eec460e4b2ac05fc692087"}