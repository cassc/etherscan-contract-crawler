{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ChainFactory_ERC20.sol\": {\r\n      \"content\": \"/*\\n\\n  MEGAToken\\n\\n  Become a holder of MEGAToken. Official currency of the future MEGA Wallet.\\n\\n  Web: https://megatoken.tech/\\n  X: https://twitter.com/MEGATokenApp\\n\\n*/\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.23;\\n\\nimport \\\"./CF_Ownable.sol\\\";\\nimport \\\"./CF_Common.sol\\\";\\nimport \\\"./CF_ERC20.sol\\\";\\nimport \\\"./CF_Pausable.sol\\\";\\nimport \\\"./CF_Taxable.sol\\\";\\nimport \\\"./CF_DEXRouterV2.sol\\\";\\nimport \\\"./CF_HolderList.sol\\\";\\n\\ncontract ChainFactory_ERC20 is CF_Ownable, CF_Common, CF_ERC20, CF_Pausable, CF_Taxable, CF_DEXRouterV2, CF_HolderList {\\n  constructor() {\\n    _name = unicode\\\"MEGAToken\\\";\\n    _symbol = unicode\\\"MEGA\\\";\\n    _decimals = 18;\\n    _totalSupply = 55000000000000000000000000; // 55,000,000 MEGA\\n    _transferOwnership(0xFcF91DF83E05823B50c6d7549077a7e2894Fdd00);\\n    _transferInitialSupply(0xFcF91DF83E05823B50c6d7549077a7e2894Fdd00, 100000); // 100%\\n    _setDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 0xFcF91DF83E05823B50c6d7549077a7e2894Fdd00);\\n    _swapEnabled = true;\\n    _setMinSwapPercent(500); // 0.5% of totalSupply\\n    _setMinTaxDistributionPercent(500); // 0.5% of totalSupply\\n    _setTaxBeneficiary(0, 0xFcF91DF83E05823B50c6d7549077a7e2894Fdd00, [ uint24(500), uint24(1000), uint24(10000) ]);\\n    _domainSeparator = keccak256(abi.encode(keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"), keccak256(bytes(_name)), keccak256(bytes(\\\"1\\\")), block.chainid, address(this)));\\n    _initialized = true;\\n\\n    _holder[address(this)].exists = true;\\n    _holders.push(address(this));\\n  }\\n\\n  function _transfer(address from, address to, uint256 amount) internal virtual override {\\n    require(!_paused, \\\"Paused\\\");\\n\\n    if (!_distributing && !_swapping && (from != _dex.pair && from != _dex.router)) {\\n      _autoSwap(false);\\n      _autoTaxDistribute(false);\\n    }\\n\\n    if (amount > 0 && from != _owner && to != _owner && from != address(this) && to != address(this) && to != _dex.router) {\\n      require((from != _dex.pair && to != _dex.pair) || ((from == _dex.pair || to == _dex.pair) && _tradingEnabled > 0), \\\"Trading disabled\\\");\\n\\n      unchecked {\\n        if (!_suspendTaxes && !_distributing && !_swapping) {\\n          uint256 appliedTax;\\n          uint8 taxType;\\n\\n          if (from == _dex.pair || to == _dex.pair) { taxType = from == _dex.pair ? 1 : 2; }\\n\\n          for (uint8 i; i < 5; i++) {\\n            uint256 percent = uint256(taxType > 0 ? (taxType == 1 ? _taxBeneficiary[i].percent[1] : _taxBeneficiary[i].percent[2]) : _taxBeneficiary[i].percent[0]);\\n\\n            if (percent == 0) { continue; }\\n\\n            uint256 taxAmount = _percentage(amount, percent);\\n\\n            super._transfer(from, address(this), taxAmount);\\n\\n            if (_taxBeneficiary[i].account == _dex.pair) {\\n              _amountForLiquidity += taxAmount;\\n            } else {\\n              _taxBeneficiary[i].unclaimed += taxAmount;\\n              _amountForTaxDistribution += taxAmount;\\n            }\\n\\n            appliedTax += taxAmount;\\n          }\\n\\n          if (appliedTax > 0) {\\n            _totalTaxCollected += appliedTax;\\n\\n            amount -= appliedTax;\\n          }\\n        }\\n      }\\n    }\\n\\n    super._transfer(from, to, amount);\\n\\n    if (amount > 0 && !_holder[to].exists) {\\n      _holder[to].exists = true;\\n      _holders.push(to);\\n    }\\n  }\\n\\n  function _transferInitialSupply(address account, uint24 percent) private {\\n    require(!_initialized);\\n\\n    uint256 amount = _percentage(_totalSupply, uint256(percent));\\n    _balance[account] = amount;\\n    _holder[account].exists = true;\\n    _holders.push(account);\\n\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /// @notice Returns a list specifying the renounce status of each feature\\n  function renounced() external view returns (bool Pausable, bool Taxable, bool DEXRouterV2) {\\n    return (_renounced.Pausable, _renounced.Taxable, _renounced.DEXRouterV2);\\n  }\\n\\n  /// @notice Returns basic information about this Smart-Contract\\n  function info() external view returns (string memory name, string memory symbol, uint8 decimals, address owner, uint256 totalSupply, string memory version) {\\n    return (_name, _symbol, _decimals, _owner, _totalSupply, _version);\\n  }\\n\\n  receive() external payable { }\\n  fallback() external payable { }\\n}\\n\\n/*\\n   ________          _       ______           __                  \\n  / ____/ /_  ____ _(_)___  / ____/___ ______/ /_____  _______  __\\n / /   / __ \\\\/ __ `/ / __ \\\\/ /_  / __ `/ ___/ __/ __ \\\\/ ___/ / / /\\n/ /___/ / / / /_/ / / / / / __/ / /_/ / /__/ /_/ /_/ / /  / /_/ / \\n\\\\____/_/ /_/\\\\__,_/_/_/ /_/_/    \\\\__,_/\\\\___/\\\\__/\\\\____/_/   \\\\__, /  \\n                                                         /____/   \\n  Smart-Contract generated and deployed by ChainFactory\\n\\n  Web:      https://chainfactory.app/\\n  X:        https://x.com/ChainFactoryApp\\n  Telegram: https://t.me/ChainFactory\\n  Discord:  https://discord.gg/fpjxD39v3k\\n  YouTube:  https://youtube.com/@UpfrontDeFi\\n\\n  By using this Smart-Contract generated and deployed by ChainFactory,\\n  you acknowledge and agree that ChainFactory shall not be liable for any\\n  damages arising from the use of this Smart-Contract, including but not\\n  limited to any damages resulting from any malicious or illegal use of\\n  the Smart-Contract by any third party or by the owner.\\n\\n  The owner of the Smart-Contract generated by ChainFactory agrees not to\\n  misuse the Smart-Contract, including but not limited to:\\n\\n  - Using the Smart-Contract to engage in any illegal or fraudulent\\n    activity, including but not limited to scams, theft, or money\\n    laundering.\\n\\n  - Using the Smart-Contract in any manner that could cause harm to\\n    others, including but not limited to disrupting financial\\n    markets or causing financial loss to others.\\n\\n  - Using the Smart-Contract to infringe upon the intellectual\\n    property rights of others, including but not limited to\\n    copyright, trademark, or patent infringement.\\n\\n  The owner of the Smart-Contract generated by ChainFactory acknowledges\\n  that any misuse of the Smart-Contract may result in legal action,\\n  and agrees to indemnify and hold harmless ChainFactory from any and all\\n  claims, damages, or expenses arising from any such misuse.\\n\\n*/\\n\"\r\n    },\r\n    \"CF_Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.23;\\r\\n\\r\\nabstract contract CF_Ownable {\\r\\n  address internal _owner;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    require(_owner == msg.sender, \\\"Unauthorized\\\");\\r\\n\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function owner() external view returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  function renounceOwnership() external onlyOwner {\\r\\n    _transferOwnership(address(0));\\r\\n  }\\r\\n\\r\\n  function transferOwnership(address newOwner) external onlyOwner {\\r\\n    require(newOwner != address(0));\\r\\n\\r\\n    _transferOwnership(newOwner);\\r\\n  }\\r\\n\\r\\n  function _transferOwnership(address newOwner) internal {\\r\\n    address oldOwner = _owner;\\r\\n    _owner = newOwner;\\r\\n\\r\\n    emit OwnershipTransferred(oldOwner, newOwner);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_Common.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.23;\\r\\n\\r\\nimport \\\"./IDEXV2.sol\\\";\\r\\n\\r\\nabstract contract CF_Common {\\r\\n  string internal constant _version = \\\"1.0.0\\\";\\r\\n\\r\\n  mapping(address => uint256) internal _balance;\\r\\n  mapping(address => mapping(address => uint256)) internal _allowance;\\r\\n  mapping(address => holderAccount) internal _holder;\\r\\n  mapping(uint8 => taxBeneficiary) internal _taxBeneficiary;\\r\\n\\r\\n  address[] internal _holders;\\r\\n\\r\\n  bool internal _swapEnabled;\\r\\n  bool internal _swapping;\\r\\n  bool internal _paused;\\r\\n  bool internal _suspendTaxes;\\r\\n  bool internal _distributing;\\r\\n  bool internal immutable _initialized;\\r\\n\\r\\n  uint8 internal immutable _decimals;\\r\\n  uint24 internal constant _denominator = 1000;\\r\\n  uint24 internal _totalTxTax;\\r\\n  uint24 internal _totalBuyTax;\\r\\n  uint24 internal _totalSellTax;\\r\\n  uint24 internal _minTaxDistributionPercent;\\r\\n  uint24 internal _minSwapPercent;\\r\\n  uint32 internal _lastTaxDistribution;\\r\\n  uint32 internal _tradingEnabled;\\r\\n  uint32 internal _lastSwap;\\r\\n  uint256 internal _totalSupply;\\r\\n  uint256 internal _totalTaxCollected;\\r\\n  uint256 internal _minTaxDistributionAmount;\\r\\n  uint256 internal _amountForTaxDistribution;\\r\\n  uint256 internal _minSwapAmount;\\r\\n  uint256 internal _amountForLiquidity;\\r\\n\\r\\n  struct Renounced {\\r\\n    bool Pausable;\\r\\n    bool Taxable;\\r\\n    bool DEXRouterV2;\\r\\n  }\\r\\n\\r\\n  struct holderAccount {\\r\\n    bool exists;\\r\\n  }\\r\\n\\r\\n  struct taxBeneficiary {\\r\\n    bool exists;\\r\\n    address account;\\r\\n    uint24[3] percent; // 0: tx, 1: buy, 2: sell\\r\\n    uint256 unclaimed;\\r\\n  }\\r\\n\\r\\n  struct DEXRouterV2 {\\r\\n    address router;\\r\\n    address pair;\\r\\n    address WETH;\\r\\n    address receiver;\\r\\n  }\\r\\n\\r\\n  Renounced internal _renounced;\\r\\n  DEXRouterV2 internal _dex;\\r\\n\\r\\n  function _percentage(uint256 amount, uint256 bps) internal pure returns (uint256) {\\r\\n    unchecked {\\r\\n      return (amount * bps) / (100 * uint256(_denominator));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _timestamp() internal view returns (uint32) {\\r\\n    unchecked {\\r\\n      return uint32(block.timestamp % 2**32);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function denominator() external pure returns (uint24) {\\r\\n    return _denominator;\\r\\n  }\\r\\n\\r\\n  function version() external pure returns (string memory) {\\r\\n    return _version;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.23;\\r\\n\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\n\\r\\nabstract contract CF_ERC20 is CF_Common {\\r\\n  string internal _name;\\r\\n  string internal _symbol;\\r\\n  bytes32 internal _domainSeparator;\\r\\n  bytes32 private constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\r\\n  mapping(address => uint256) private _nonces;\\r\\n\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n  function name() external view returns (string memory) {\\r\\n    return _name;\\r\\n  }\\r\\n\\r\\n  function symbol() external view returns (string memory) {\\r\\n    return _symbol;\\r\\n  }\\r\\n\\r\\n  function decimals() external view returns (uint8) {\\r\\n    return _decimals;\\r\\n  }\\r\\n\\r\\n  function totalSupply() external view returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  function balanceOf(address account) external view returns (uint256) {\\r\\n    return _balance[account];\\r\\n  }\\r\\n\\r\\n  function allowance(address owner, address spender) public view returns (uint256) {\\r\\n    return _allowance[owner][spender];\\r\\n  }\\r\\n\\r\\n  function approve(address spender, uint256 amount) external returns (bool) {\\r\\n    _approve(msg.sender, spender, amount);\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\\r\\n    require(deadline >= block.timestamp, \\\"Expired signature\\\");\\r\\n\\r\\n    unchecked {\\r\\n      bytes32 digest = keccak256(abi.encodePacked(hex\\\"1901\\\", _domainSeparator, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _nonces[owner]++, deadline))));\\r\\n      address recoveredAddress = ecrecover(digest, v, r, s);\\r\\n\\r\\n      require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"Invalid signature\\\");\\r\\n    }\\r\\n\\r\\n    _approve(owner, spender, value);\\r\\n  }\\r\\n\\r\\n  function nonces(address owner) external view returns (uint256) {\\r\\n    return _nonces[owner];\\r\\n  }\\r\\n\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32) {\\r\\n    return _domainSeparator;\\r\\n  }\\r\\n\\r\\n  function transfer(address to, uint256 amount) external returns (bool) {\\r\\n    _transfer(msg.sender, to, amount);\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function transferFrom(address from, address to, uint256 amount) external returns (bool) {\\r\\n    _spendAllowance(from, msg.sender, amount);\\r\\n    _transfer(from, to, amount);\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\r\\n    unchecked {\\r\\n      _approve(msg.sender, spender, allowance(msg.sender, spender) + addedValue);\\r\\n    }\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\r\\n    uint256 currentAllowance = allowance(msg.sender, spender);\\r\\n\\r\\n    require(currentAllowance >= subtractedValue, \\\"Negative allowance\\\");\\r\\n\\r\\n    unchecked {\\r\\n      _approve(msg.sender, spender, currentAllowance - subtractedValue);\\r\\n    }\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function _approve(address owner, address spender, uint256 amount) internal {\\r\\n    _allowance[owner][spender] = amount;\\r\\n\\r\\n    emit Approval(owner, spender, amount);\\r\\n  }\\r\\n\\r\\n  function _spendAllowance(address owner, address spender, uint256 amount) internal {\\r\\n    uint256 currentAllowance = allowance(owner, spender);\\r\\n\\r\\n    require(currentAllowance >= amount, \\\"Insufficient allowance\\\");\\r\\n\\r\\n    unchecked {\\r\\n      _approve(owner, spender, currentAllowance - amount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _transfer(address from, address to, uint256 amount) internal virtual {\\r\\n    require(from != address(0) && to != address(0), \\\"Transfer from/to zero address\\\");\\r\\n    require(_balance[from] >= amount, \\\"Exceeds balance\\\");\\r\\n\\r\\n    if (amount > 0) {\\r\\n      unchecked {\\r\\n        _balance[from] -= amount;\\r\\n        _balance[to] += amount;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    emit Transfer(from, to, amount);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.23;\\r\\n\\r\\nimport \\\"./CF_Ownable.sol\\\";\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\n\\r\\nabstract contract CF_Pausable is CF_Ownable, CF_Common {\\r\\n  event Paused(bool status);\\r\\n  event RenouncedPausable();\\r\\n\\r\\n  /// @notice Permanently renounce and prevent the owner from being able to pause the Smart-Contract\\r\\n  /// @dev Existing settings will continue to be effective\\r\\n  function renouncePausable() external onlyOwner {\\r\\n    _renounced.Pausable = true;\\r\\n\\r\\n    emit RenouncedPausable();\\r\\n  }\\r\\n\\r\\n  /// @notice Check if the Smart-Contract is paused\\r\\n  function isPaused() external view returns (bool) {\\r\\n    return _paused;\\r\\n  }\\r\\n\\r\\n  function pause(bool status) external onlyOwner {\\r\\n    require(!_renounced.Pausable);\\r\\n    require(_paused != status);\\r\\n\\r\\n    _paused = status;\\r\\n\\r\\n    emit Paused(status);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_Taxable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.23;\\r\\n\\r\\nimport \\\"./CF_Ownable.sol\\\";\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\nimport \\\"./CF_ERC20.sol\\\";\\r\\n\\r\\nabstract contract CF_Taxable is CF_Ownable, CF_Common, CF_ERC20 {\\r\\n  event SetTaxBeneficiary(uint8 slot, address account, uint24[3] percent);\\r\\n  event TaxDistributed(uint256 amount);\\r\\n  event RenouncedTaxable();\\r\\n\\r\\n  struct taxBeneficiaryView {\\r\\n    address account;\\r\\n    uint24[3] percent;\\r\\n    uint256 unclaimed;\\r\\n  }\\r\\n\\r\\n  modifier lockDistributing {\\r\\n    _distributing = true;\\r\\n    _;\\r\\n    _distributing = false;\\r\\n  }\\r\\n\\r\\n  /// @notice Permanently renounce and prevent the owner from being able to update the tax features\\r\\n  /// @dev Existing settings will continue to be effective\\r\\n  function renounceTaxable() external onlyOwner {\\r\\n    _renounced.Taxable = true;\\r\\n\\r\\n    emit RenouncedTaxable();\\r\\n  }\\r\\n\\r\\n  /// @notice Total amount of taxes collected so far\\r\\n  function totalTaxCollected() external view returns (uint256) {\\r\\n    return _totalTaxCollected;\\r\\n  }\\r\\n\\r\\n  /// @notice Tax applied per transfer\\r\\n  /// @dev Taking in consideration your wallet address\\r\\n  function txTax() external view returns (uint24) {\\r\\n    return txTax(msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Tax applied per transfer\\r\\n  /// @param from Sender address\\r\\n  function txTax(address from) public view returns (uint24) {\\r\\n    unchecked {\\r\\n      return from == address(this) || from == _dex.pair ? 0 : _totalTxTax;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Tax applied for buying\\r\\n  /// @dev Taking in consideration your wallet address\\r\\n  function buyTax() external view returns (uint24) {\\r\\n    return buyTax(msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Tax applied for buying\\r\\n  /// @param from Buyer's address\\r\\n  function buyTax(address from) public view returns (uint24) {\\r\\n    if (_suspendTaxes) { return 0; }\\r\\n\\r\\n    unchecked {\\r\\n      return from == address(this) || from == _dex.pair ? 0 : _totalBuyTax;\\r\\n    }\\r\\n  }\\r\\n  /// @notice Tax applied for selling\\r\\n  /// @dev Taking in consideration your wallet address\\r\\n  function sellTax() external view returns (uint24) {\\r\\n    return sellTax(msg.sender);\\r\\n  }\\r\\n\\r\\n  /// @notice Tax applied for selling\\r\\n  /// @param to Seller's address\\r\\n  function sellTax(address to) public view returns (uint24) {\\r\\n    if (_suspendTaxes) { return 0; }\\r\\n\\r\\n    unchecked {\\r\\n      return to == address(this) || to == _owner || to == _dex.pair || to == _dex.router ? 0 : _totalSellTax;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice List of all tax beneficiaries and their assigned percentage, according to type of transfer\\r\\n  /// @custom:return `list[].account` Beneficiary address\\r\\n  /// @custom:return `list[].percent[3]` Index 0 is for tx tax, 1 is for buy tax, 2 is for sell tax, multiplied by denominator\\r\\n  function listTaxBeneficiaries() external view returns (taxBeneficiaryView[] memory list) {\\r\\n    list = new taxBeneficiaryView[](5);\\r\\n\\r\\n    unchecked {\\r\\n      for (uint8 i; i < 5; i++) { list[i] = taxBeneficiaryView(_taxBeneficiary[i].account, _taxBeneficiary[i].percent, _taxBeneficiary[i].unclaimed); }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Sets a tax beneficiary\\r\\n  /// @dev Maximum of 5 wallets can be assigned\\r\\n  /// @param slot Slot number (0 to 4)\\r\\n  /// @param account Beneficiary address\\r\\n  /// @param percent[3] Index 0 is for tx tax, 1 is for buy tax, 2 is for sell tax, multiplied by denominator\\r\\n  function setTaxBeneficiary(uint8 slot, address account, uint24[3] memory percent) external onlyOwner {\\r\\n    require(!_renounced.Taxable);\\r\\n\\r\\n    _setTaxBeneficiary(slot, account, percent);\\r\\n  }\\r\\n\\r\\n  function _setTaxBeneficiary(uint8 slot, address account, uint24[3] memory percent) internal {\\r\\n    require(slot < 5);\\r\\n    require(account != address(this) && account != address(0xdEaD) && account != address(0));\\r\\n\\r\\n    taxBeneficiary storage _taxBeneficiary = _taxBeneficiary[slot];\\r\\n\\r\\n    unchecked {\\r\\n      _totalTxTax += percent[0] - _taxBeneficiary.percent[0];\\r\\n      _totalBuyTax += percent[1] - _taxBeneficiary.percent[1];\\r\\n      _totalSellTax += percent[2] - _taxBeneficiary.percent[2];\\r\\n\\r\\n      require(_totalTxTax <= 25 * _denominator && ((_totalBuyTax <= 25 * _denominator && _totalSellTax <= 25 * _denominator) && (_totalBuyTax + _totalSellTax <= 25 * _denominator)), \\\"High Tax\\\");\\r\\n    }\\r\\n\\r\\n    _taxBeneficiary.account = account;\\r\\n    _taxBeneficiary.percent = percent;\\r\\n\\r\\n    if (!_taxBeneficiary.exists) { _taxBeneficiary.exists = true; }\\r\\n\\r\\n    emit SetTaxBeneficiary(slot, account, percent);\\r\\n  }\\r\\n\\r\\n  /// @notice Triggers the tax distribution\\r\\n  /// @dev Will only be executed if there is no ongoing tax distribution and the min. threshold has been reached unless forced\\r\\n  /// @param force Ignore the min. threshold amount\\r\\n  function autoTaxDistribute(bool force) external onlyOwner {\\r\\n    require(!_swapping && !_distributing);\\r\\n\\r\\n    _autoTaxDistribute(force);\\r\\n  }\\r\\n\\r\\n  function _autoTaxDistribute(bool force) internal lockDistributing {\\r\\n    if (!force) {\\r\\n      if (_amountForTaxDistribution == 0 || _balance[address(this)] < _amountForTaxDistribution || _amountForTaxDistribution < _minTaxDistributionAmount) { return; }\\r\\n    }\\r\\n\\r\\n    unchecked {\\r\\n      uint256 distributed;\\r\\n\\r\\n      for (uint8 i; i < 5; i++) {\\r\\n        address account = _taxBeneficiary[i].account;\\r\\n        uint256 unclaimed = _taxBeneficiary[i].unclaimed;\\r\\n\\r\\n        if (unclaimed == 0 || account == _dex.pair) { continue; }\\r\\n\\r\\n        uint256 _distributed = _distribute(account, unclaimed);\\r\\n\\r\\n        if (_distributed > 0) { _taxBeneficiary[i].unclaimed -= _distributed; }\\r\\n\\r\\n        distributed += _distributed;\\r\\n      }\\r\\n\\r\\n      _lastTaxDistribution = _timestamp();\\r\\n\\r\\n      emit TaxDistributed(distributed);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _distribute(address account, uint256 unclaimed) private returns (uint256) {\\r\\n    super._transfer(address(this), account, unclaimed);\\r\\n\\r\\n    _amountForTaxDistribution -= unclaimed;\\r\\n\\r\\n    return unclaimed;\\r\\n  }\\r\\n\\r\\n  /// @notice Suspend or reinstate tax collection\\r\\n  /// @param status True to suspend, False to reinstate existent taxes\\r\\n  function suspendTaxes(bool status) external onlyOwner {\\r\\n    require(!_renounced.Taxable);\\r\\n\\r\\n    _suspendTaxes = status;\\r\\n  }\\r\\n\\r\\n  /// @notice Checks if tax collection is currently suspended\\r\\n  function taxesSuspended() external view returns (bool) {\\r\\n    return _suspendTaxes;\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the minimum percentage of the total supply accumulated in the Smart-Contract balance to trigger tax distribution\\r\\n  function getMinTaxDistributionPercent() external view returns (uint24) {\\r\\n    return _minTaxDistributionPercent;\\r\\n  }\\r\\n\\r\\n  /// @notice Sets the minimum percentage of the total supply accumulated in the Smart-Contract balance to trigger tax distribution\\r\\n  /// @param percent Desired percentage, multiplied by denominator (0.001% to 1% of total supply)\\r\\n  function setMinTaxDistributionPercent(uint24 percent) external onlyOwner {\\r\\n    require(!_renounced.Taxable);\\r\\n    require(percent >= 1 && percent <= 1000, \\\"0.001% to 1%\\\");\\r\\n\\r\\n    _setMinTaxDistributionPercent(percent);\\r\\n  }\\r\\n\\r\\n  function _setMinTaxDistributionPercent(uint24 percent) internal {\\r\\n    _minTaxDistributionPercent = percent;\\r\\n    _minTaxDistributionAmount = _percentage(_totalSupply, uint256(percent));\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_DEXRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.23;\\r\\n\\r\\nimport \\\"./CF_Ownable.sol\\\";\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\nimport \\\"./CF_ERC20.sol\\\";\\r\\n\\r\\nabstract contract CF_DEXRouterV2 is CF_Ownable, CF_Common, CF_ERC20 {\\r\\n  event SwapAndLiquify(uint256 tokenAmount, uint256 ethAmount, uint256 liquidity);\\r\\n  event SwappedTokensForETH(uint256 tokenAmount, uint256 ethAmount);\\r\\n  event SwappedTokensForERC20(address token, uint256 token0Amount, uint256 token1Amount);\\r\\n  event SetDEXRouter(address indexed router, address indexed pair, address receiver);\\r\\n  event RenouncedDEXRouterV2();\\r\\n\\r\\n  modifier lockSwapping {\\r\\n    _swapping = true;\\r\\n    _;\\r\\n    _swapping = false;\\r\\n  }\\r\\n\\r\\n  /// @notice Permanently renounce and prevent the owner from being able to update the DEX features\\r\\n  /// @dev Existing settings will continue to be effective\\r\\n  function renounceDEXRouterV2() external onlyOwner {\\r\\n    _renounced.DEXRouterV2 = true;\\r\\n\\r\\n    emit RenouncedDEXRouterV2();\\r\\n  }\\r\\n\\r\\n  /// @notice Sets the DEX router and where to receive the LP tokens\\r\\n  /// @param router Address of the DEX router\\r\\n  /// @param receiver Address of the LP tokens receiver\\r\\n  function setDEXRouter(address router, address receiver) external onlyOwner returns (address) {\\r\\n    require(!_renounced.DEXRouterV2);\\r\\n\\r\\n    return _setDEXRouter(router, receiver);\\r\\n  }\\r\\n\\r\\n  function _setDEXRouter(address router, address receiver) internal returns (address) {\\r\\n    require(router != address(0));\\r\\n\\r\\n    if (_dex.router != router) {\\r\\n      IDEXRouterV2 _router = IDEXRouterV2(router);\\r\\n      IDEXFactoryV2 factory = IDEXFactoryV2(_router.factory());\\r\\n      address WETH = _router.WETH();\\r\\n      address pair = factory.getPair(address(this), WETH);\\r\\n\\r\\n      if (pair == address(0)) { pair = factory.createPair(address(this), WETH); }\\r\\n\\r\\n      _dex = DEXRouterV2(router, pair, WETH, receiver);\\r\\n    }\\r\\n\\r\\n    if (receiver != _dex.receiver) { _dex.receiver = receiver; }\\r\\n\\r\\n    emit SetDEXRouter(router, _dex.pair, receiver);\\r\\n\\r\\n    return _dex.pair;\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the DEX router currently in use\\r\\n  function getDEXRouter() external view returns (address) {\\r\\n    return _dex.router;\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the trading pair\\r\\n  function getDEXPair() external view returns (address) {\\r\\n    return _dex.pair;\\r\\n  }\\r\\n\\r\\n  /// @notice Returns address of the LP tokens receiver\\r\\n  function getDEXReceiver() external view returns (address) {\\r\\n    return _dex.receiver;\\r\\n  }\\r\\n\\r\\n  /// @notice Checks the status of the auto-swapping feature\\r\\n  function isSwapEnabled() external view returns (bool) {\\r\\n    return _swapEnabled;\\r\\n  }\\r\\n\\r\\n  /// @notice Checks whether the token can be traded through the assigned DEX\\r\\n  function isTradingEnabled() external view returns (bool) {\\r\\n    return _tradingEnabled > 0;\\r\\n  }\\r\\n\\r\\n  /// @notice Assign the excess token balance of the Smart-Contract to liquidity\\r\\n  function liquifyExcess() external onlyOwner {\\r\\n    require(_swapEnabled && !_swapping);\\r\\n\\r\\n    unchecked {\\r\\n      uint256 assigned = _amountForTaxDistribution + _amountForLiquidity;\\r\\n\\r\\n      require(_balance[address(this)] > assigned);\\r\\n\\r\\n      uint256 excess = _balance[address(this)] - assigned;\\r\\n\\r\\n      _amountForLiquidity += excess;\\r\\n    }\\r\\n\\r\\n    _autoSwap(false);\\r\\n  }\\r\\n\\r\\n  /// @notice Swaps the assigned amount for liquidity and taxes to the corresponding token\\r\\n  /// @dev Will only be executed if there is no ongoing swap or tax distribution and the min. threshold has been reached unless forced\\r\\n  /// @param force Ignore the min. threshold amount\\r\\n  function autoSwap(bool force) external onlyOwner {\\r\\n    require(_swapEnabled && !_swapping);\\r\\n\\r\\n    _autoSwap(force);\\r\\n  }\\r\\n\\r\\n  function _autoSwap(bool force) internal lockSwapping {\\r\\n    if (!_swapEnabled) { return; }\\r\\n\\r\\n    unchecked {\\r\\n      if (force || (_amountForLiquidity / 2 >= _minSwapAmount && _balance[address(this)] >= _amountForLiquidity)) {\\r\\n        uint256 tokenAmountForLiquidity = _amountForLiquidity / 2;\\r\\n        uint256 ethBalance = address(this).balance;\\r\\n        address[] memory pathToSwapExactTokensForETH = new address[](2);\\r\\n        pathToSwapExactTokensForETH[0] = address(this);\\r\\n        pathToSwapExactTokensForETH[1] = _dex.WETH;\\r\\n\\r\\n        _approve(address(this), _dex.router, tokenAmountForLiquidity);\\r\\n\\r\\n        try IDEXRouterV2(_dex.router).swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmountForLiquidity, 0, pathToSwapExactTokensForETH, address(this), block.timestamp + 1) {\\r\\n          _lastSwap = _timestamp();\\r\\n\\r\\n          if (_amountForLiquidity > 0) { _amountForLiquidity /= 2; }\\r\\n\\r\\n          uint256 ethAmount = address(this).balance - ethBalance;\\r\\n\\r\\n          emit SwappedTokensForETH(tokenAmountForLiquidity, ethAmount);\\r\\n\\r\\n          if (ethAmount > 0) {\\r\\n            if (tokenAmountForLiquidity > 0 && ethAmount > 0) {\\r\\n              _approve(address(this), _dex.router, tokenAmountForLiquidity);\\r\\n\\r\\n              try IDEXRouterV2(_dex.router).addLiquidityETH{ value: ethAmount }(address(this), tokenAmountForLiquidity, 0, 0, _dex.receiver, block.timestamp + 1) returns (uint256 amountToken, uint256 amountETH, uint256 liquidity) {\\r\\n                emit SwapAndLiquify(amountToken, amountETH, liquidity);\\r\\n\\r\\n                _amountForLiquidity = 0;\\r\\n              } catch {\\r\\n                _approve(address(this), _dex.router, 0);\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        } catch {\\r\\n          _approve(address(this), _dex.router, 0);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the minimum percentage of the total supply in the Smart-Contract balance to trigger auto swap\\r\\n  function getMinSwapPercent() external view returns (uint24) {\\r\\n    return _minSwapPercent;\\r\\n  }\\r\\n\\r\\n  /// @notice Sets the minimum percentage of the total supply in the Smart-Contract balance to trigger auto swap\\r\\n  /// @param percent Desired percentage, multiplied by denominator (0.001% to 1% of total supply)\\r\\n  function setMinSwapPercent(uint24 percent) external onlyOwner {\\r\\n    require(!_renounced.DEXRouterV2);\\r\\n    require(percent >= 1 && percent <= 1000, \\\"0.001% to 1%\\\");\\r\\n\\r\\n    _setMinSwapPercent(percent);\\r\\n  }\\r\\n\\r\\n  function _setMinSwapPercent(uint24 percent) internal {\\r\\n    _minSwapPercent = percent;\\r\\n    _minSwapAmount = _percentage(_totalSupply, uint256(percent));\\r\\n  }\\r\\n\\r\\n  /// @notice Enables or disables the auto swap function\\r\\n  /// @param status True to enable, False to disable\\r\\n  function setSwapStatus(bool status) external onlyOwner {\\r\\n    require(!_renounced.DEXRouterV2);\\r\\n    require(!status || _dex.router != address(0), \\\"No DEX\\\");\\r\\n\\r\\n    _swapEnabled = status;\\r\\n  }\\r\\n\\r\\n  /// @notice Enables the trading capability via the DEX set up\\r\\n  /// @dev Once enabled, it cannot be reverted unless using the pause method\\r\\n  function enableTrading() external onlyOwner {\\r\\n    require(!_renounced.DEXRouterV2);\\r\\n    require(_tradingEnabled == 0, \\\"Already enabled\\\");\\r\\n\\r\\n    _tradingEnabled = _timestamp();\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CF_HolderList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.23;\\r\\n\\r\\nimport \\\"./CF_Common.sol\\\";\\r\\n\\r\\nabstract contract CF_HolderList is CF_Common {\\r\\n  struct Holder {\\r\\n    address account;\\r\\n    uint256 balance;\\r\\n  }\\r\\n\\r\\n  /// @notice Total number of holders\\r\\n  function totalHolders() public view returns (uint256 total) {\\r\\n    unchecked {\\r\\n      uint256 cnt = _holders.length;\\r\\n\\r\\n      for (uint256 i; i < cnt; i++) {\\r\\n        address account = _holders[i];\\r\\n\\r\\n        if (account == address(0) || _balance[account] == 0) { continue; }\\r\\n\\r\\n        ++total;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Retrieves a list of wallets and their balance, paginated\\r\\n  /// @param offset How many rows to skip over\\r\\n  /// @param limit How many rows to return, at most\\r\\n  /// @return holders Rows matching your criteria\\r\\n  /// @return total Total number of holders\\r\\n  function getHolders(uint256 offset, uint256 limit) public view returns (Holder[] memory, uint256 total) {\\r\\n    total = totalHolders();\\r\\n\\r\\n    require(limit >= offset && offset <= total, \\\"Invalid range\\\");\\r\\n\\r\\n    unchecked {\\r\\n      uint256 rows = (limit - offset) + 1;\\r\\n\\r\\n      if (rows > total - offset) { rows = total - offset; }\\r\\n\\r\\n      require(rows > 0, \\\"Out of range\\\");\\r\\n\\r\\n      Holder[] memory holders = new Holder[](rows);\\r\\n\\r\\n      uint256 cnt = _holders.length;\\r\\n      uint256 s;\\r\\n      uint256 h;\\r\\n\\r\\n      for (uint256 i; i < cnt; i++) {\\r\\n        address account = _holders[i];\\r\\n\\r\\n        if (account == address(0) || _balance[account] == 0) { continue; }\\r\\n        if (s++ < offset) { continue; }\\r\\n\\r\\n        holders[h] = Holder(account, _balance[account]);\\r\\n\\r\\n        if (++h >= rows) { break; }\\r\\n      }\\r\\n\\r\\n      return (holders, total);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Retrieves the full list of wallets and their balance\\r\\n  /// @dev Use the paginated version of this function if the output exceeds the return limit\\r\\n  function getHolders() external view returns (Holder[] memory, uint256 total) {\\r\\n    total = totalHolders();\\r\\n\\r\\n    return getHolders(0, total);\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"IDEXV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.23;\\r\\n\\r\\ninterface IDEXRouterV2 {\\r\\n  function factory() external pure returns (address);\\r\\n  function WETH() external pure returns (address);\\r\\n  function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\\r\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\\r\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\\r\\n}\\r\\n\\r\\ninterface IDEXFactoryV2 {\\r\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n  function getPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"shanghai\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RenouncedDEXRouterV2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RenouncedPausable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RenouncedTaxable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"SetDEXRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24[3]\",\"name\":\"percent\",\"type\":\"uint24[3]\"}],\"name\":\"SetTaxBeneficiary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token1Amount\",\"type\":\"uint256\"}],\"name\":\"SwappedTokensForERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"SwappedTokensForETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TaxDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"autoSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"autoTaxDistribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDEXPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDEXReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDEXRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHolders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct CF_HolderList.Holder[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getHolders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct CF_HolderList.Holder[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinSwapPercent\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinTaxDistributionPercent\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"info\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquifyExcess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listTaxBeneficiaries\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint24[3]\",\"name\":\"percent\",\"type\":\"uint24[3]\"},{\"internalType\":\"uint256\",\"name\":\"unclaimed\",\"type\":\"uint256\"}],\"internalType\":\"struct CF_Taxable.taxBeneficiaryView[]\",\"name\":\"list\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceDEXRouterV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePausable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceTaxable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"Pausable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Taxable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"DEXRouterV2\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"setDEXRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"percent\",\"type\":\"uint24\"}],\"name\":\"setMinSwapPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"percent\",\"type\":\"uint24\"}],\"name\":\"setMinTaxDistributionPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setSwapStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint24[3]\",\"name\":\"percent\",\"type\":\"uint24[3]\"}],\"name\":\"setTaxBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"suspendTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxesSuspended\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTaxCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"txTax\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ChainFactory_ERC20", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "shanghai", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}