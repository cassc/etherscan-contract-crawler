{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CollateralVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport { CollateralType } from \\\"./lib/Structs.sol\\\";\\n\\nimport { InvalidCollateralType, InvalidCollateral, InvalidCollateralCriteria } from \\\"./lib/Errors.sol\\\";\\n\\nlibrary CollateralVerifier {\\n\\n    function mapCollateralType(\\n        uint8 collateralType\\n    ) external pure returns (uint8) {\\n        if (\\n            collateralType == uint8(CollateralType.ERC721) ||\\n            collateralType == uint8(CollateralType.ERC721_WITH_CRITERIA)\\n        ) {\\n            return uint8(CollateralType.ERC721);\\n        } else if (\\n            collateralType == uint8(CollateralType.ERC1155) ||\\n            collateralType == uint8(CollateralType.ERC1155_WITH_CRITERIA)\\n        ) {\\n            return uint8(CollateralType.ERC1155);\\n        } else {\\n            revert InvalidCollateralType();\\n        }\\n    }\\n\\n    function verifyCollateral(\\n        uint8 collateralType,\\n        uint256 collateralRoot,\\n        uint256 tokenId,\\n        bytes32[] calldata proof\\n    ) external pure {\\n        if (\\n            collateralType == uint8(CollateralType.ERC721) ||\\n            collateralType == uint8(CollateralType.ERC1155)\\n        ) {\\n            if (tokenId != collateralRoot) {\\n                revert InvalidCollateral();\\n            }\\n            return;\\n        }\\n\\n        bytes32 computedRoot = processProofCalldata(proof, bytes32(tokenId));\\n        if (computedRoot != bytes32(collateralRoot)) {\\n            revert InvalidCollateralCriteria();\\n        }\\n    }\\n\\n    function processProofCalldata(\\n        bytes32[] calldata proof,\\n        bytes32 leaf\\n    ) internal pure returns (bytes32) {\\n        bytes32 computedHash = keccak256(abi.encode(leaf));\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(\\n        bytes32 a,\\n        bytes32 b\\n    ) private pure returns (bytes32 value) {\\n        // solhint-disable-next-line\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// Kettle\\nerror Unauthorized();\\nerror InvalidLoan();\\nerror InvalidLien();\\nerror InvalidLoanAmount();\\nerror InsufficientOffer();\\nerror InvalidRepayment();\\nerror LienIsDefaulted();\\nerror LienNotDefaulted();\\nerror AuctionIsActive();\\nerror AuctionIsNotActive();\\nerror InvalidRefinanceRate();\\nerror InvalidRefinanceDuration();\\nerror RateTooHigh();\\nerror FeesTooHigh();\\nerror CollectionsDoNotMatch();\\nerror CurrenciesDoNotMatch();\\nerror InsufficientRefinance();\\nerror InvalidAuctionDuration();\\nerror NoEscrowImplementation();\\nerror TotalFeeTooHigh();\\n\\n// CollateralVerifier\\nerror InvalidCollateral();\\nerror InvalidCollateralCriteria();\\nerror InvalidCollateralType();\\nerror InvalidCollateralAmount();\\n\\n// OfferController\\nerror OfferExpired();\\nerror OfferUnavailable();\\n\\n// Signatures\\nerror UnauthorizedOracle();\\nerror SignatureExpired();\\nerror InvalidSignature();\\nerror InvalidVParameter();\\n\\n// Auth\\nerror AuthorizationExpired();\\nerror UnauthorizedTaker();\\nerror UnauthorizedOffer();\\nerror UnauthorizedCollateral();\\n\"\r\n    },\r\n    \"contracts/lib/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/*//////////////////////////////////////////////////\\n                COLLATERAL TYPES\\n//////////////////////////////////////////////////*/\\n\\nenum CollateralType {\\n    ERC721,\\n    ERC1155,\\n    ERC721_WITH_CRITERIA,\\n    ERC1155_WITH_CRITERIA\\n}\\n\\nstruct Collateral {\\n    uint8 collateralType;\\n    address collection;\\n    uint256 collateralId;\\n    uint256 collateralAmount;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                LIEN STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct LienPointer {\\n    Lien lien;\\n    uint256 lienId;\\n}\\n\\nstruct Lien {\\n    address lender;\\n    address borrower;\\n    uint8 collateralType;\\n    address collection;\\n    uint256 tokenId;\\n    uint256 amount;\\n    address currency;\\n    uint256 borrowAmount;\\n    uint256 duration;\\n    uint256 rate;\\n    uint256 startTime;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                LOAN OFFER STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct LoanOffer {\\n    address lender;\\n    address collection;\\n    uint8 collateralType;\\n    uint256 collateralIdentifier;\\n    uint256 collateralAmount;\\n    address currency;\\n    uint256 totalAmount;\\n    uint256 minAmount;\\n    uint256 maxAmount;\\n    uint256 duration;\\n    uint256 rate;\\n    uint256 salt;\\n    uint256 expiration;\\n    Fee[] fees;\\n}\\n\\nstruct LoanOfferInput {\\n    LoanOffer offer;\\n    bytes offerSignature;\\n}\\n\\nstruct LoanFullfillment {\\n    uint256 offerIndex;\\n    uint256 loanAmount;\\n    uint256 collateralIdentifier;\\n    OfferAuth auth;\\n    bytes authSignature;\\n    bytes32[] proof;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                BORROW OFFER STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct BorrowOffer {\\n    address borrower;\\n    address collection;\\n    uint8 collateralType;\\n    uint256 collateralIdentifier;\\n    uint256 collateralAmount;\\n    address currency;\\n    uint256 loanAmount;\\n    uint256 duration;\\n    uint256 rate;\\n    uint256 salt;\\n    uint256 expiration;\\n    Fee[] fees;\\n}\\n\\nstruct BorrowOfferInput {\\n    BorrowOffer offer;\\n    bytes offerSignature;\\n}\\n\\nstruct BorrowFullfillment {\\n    uint256 offerIndex;\\n    OfferAuth auth;\\n    bytes authSignature;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                REPAY STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct RepayFullfillment {\\n    Lien lien;\\n    uint256 lienId;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                REFINANCE STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct RefinanceFullfillment {\\n    Lien lien;\\n    uint256 lienId;\\n    uint256 offerIndex;\\n    uint256 loanAmount;\\n    bytes32[] proof;\\n    OfferAuth auth;\\n    bytes authSignature;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                FEE STRUCTS\\n//////////////////////////////////////////////////*/\\n\\nstruct Fee {\\n    uint16 rate;\\n    address recipient;\\n}\\n\\n/*//////////////////////////////////////////////////\\n                AUTH STRUCTS\\n//////////////////////////////////////////////////*/\\nstruct OfferAuth {\\n    bytes32 offerHash;\\n    address taker;\\n    uint256 expiration;\\n    bytes32 collateralHash;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000,\r\n      \"details\": {\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"u\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"InvalidCollateral\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCollateralCriteria\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCollateralType\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"collateralType\",\"type\":\"uint8\"}],\"name\":\"mapCollateralType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"collateralType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"collateralRoot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyCollateral\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "CollateralVerifier", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}