// SPDX-License-Identifier: NO LICENSE

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "../interfaces/IWoolfGen2.sol";

contract WolfGameBridge is Initializable, OwnableUpgradeable {
    using ECDSA for bytes32;

    address public signerAddress;
    IWoolfGen2 public woolfGen2;

    mapping(uint256 => uint256) public mintIds;

    /** INITIALIZE */

    /**
     * instantiates contract
     * @param initialSignerAddress         the address of the wallet that signs messages
     * @param initialWoolfGen2Address      the address of the WoolfGen2 contract
     */
    function initialize(
        address initialSignerAddress,
        address initialWoolfGen2Address
    ) external initializer {
        require(initialSignerAddress != address(0), 'Invalid signerAddress');
        require(initialWoolfGen2Address != address(0), 'Invalid woolfGen2Address');
        __Ownable_init();

        signerAddress = initialSignerAddress;
        woolfGen2 = IWoolfGen2(initialWoolfGen2Address);
    }

    /** PUBLIC */

    /**
     * @notice Mints a new woolfGen2 NFT based on a signature generated by the signer
     *
     * @param mintId        the id of the mint. Used to not duplicate a minting
     * @param signature     the off-chain signature to verify correctness of the pair (msg.signer, mintId)
     */
    function mint(uint256 mintId, bytes calldata signature) external {
        require(mintIds[mintId] == 0, "Already minted");

        bytes32 messageHash = keccak256(abi.encode(msg.sender, mintId));
        require(
            signerAddress == messageHash.toEthSignedMessageHash().recover(signature),
            "Invalid signature"
        );

        uint256 nextTokenId = woolfGen2.currentId() + 1;
        mintIds[mintId] = nextTokenId;
        woolfGen2.mint(msg.sender);
    }

    /** OWNER */

    /**
     * @notice Updates the signer address
     *
     * @param newSignerAddress      the address of the new signer
     */
    function updateSignerAddress(address newSignerAddress) external onlyOwner {
        require(newSignerAddress != address(0), 'Invalid signerAddress');
        signerAddress = newSignerAddress;
    }
}