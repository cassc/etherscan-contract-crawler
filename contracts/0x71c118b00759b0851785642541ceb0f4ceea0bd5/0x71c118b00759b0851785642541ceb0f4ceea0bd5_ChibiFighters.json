{"SourceCode": "pragma solidity ^0.4.21;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract owner and transfer functions\r\n// just in case someone wants to get my bacon\r\n// ----------------------------------------------------------------------------\r\ncontract ContractOwned {\r\n    address public contract_owner;\r\n    address public contract_newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        contract_owner = msg.sender;\r\n    }\r\n\r\n    modifier contract_onlyOwner {\r\n        require(msg.sender == contract_owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public contract_onlyOwner {\r\n        contract_newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == contract_newOwner);\r\n        emit OwnershipTransferred(contract_owner, contract_newOwner);\r\n        contract_owner = contract_newOwner;\r\n        contract_newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, returns 0 if it would go into minus range.\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b >= a) {\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/** \r\n* ERC721 compatibility from\r\n* https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC721/ERC721Token.sol\r\n* plus our magic sauce\r\n*/ \r\n\r\n/**\r\n* @title Custom CustomEvents\r\n* @dev some custom events specific to this contract\r\n*/\r\ncontract CustomEvents {\r\n    event ChibiCreated(uint tokenId, address indexed _owner, bool founder, string _name, uint16[13] dna, uint father, uint mother, uint gen, uint adult, string infoUrl);\r\n    event ChibiForFusion(uint tokenId, uint price);\r\n    event ChibiForFusionCancelled(uint tokenId);\r\n    event WarriorCreated(uint tokenId, string battleRoar);\r\n}\r\n\r\n/**\r\n* @title ERC721 interface\r\n* @dev see https://github.com/ethereum/eips/issues/721\r\n*/\r\ncontract ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    \r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function transfer(address _to, uint256 _tokenId) public;\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function takeOwnership(uint256 _tokenId) public;\r\n    function tokenMetadata(uint256 _tokenId) constant public returns (string infoUrl);\r\n    function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n// interacting with gene contract\r\ncontract GeneInterface {\r\n    // creates genes when bought directly on this contract, they will always be superb\r\n    // address, seed, founder, tokenId\r\n    function createGenes(address, uint, bool, uint, uint) external view returns (\r\n    uint16[13] genes\r\n);\r\n \r\n// transfusion chamber, no one really knows what that crazy thing does\r\n// except the scientists, but they giggle all day long\r\n// address, seed, tokenId\r\nfunction splitGenes(address, uint, uint) external view returns (\r\n    uint16[13] genes\r\n    );\r\n    function exhaustAfterFusion(uint _gen, uint _counter, uint _exhaustionTime) public pure returns (uint);\r\n    function exhaustAfterBattle(uint _gen, uint _exhaust) public pure returns (uint);\r\n        \r\n}\r\n\r\n// interacting with fcf contract\r\ncontract FcfInterface {\r\n    function balanceOf(address) public pure returns (uint) {}\r\n    function transferFrom(address, address, uint) public pure returns (bool) {}\r\n}\r\n\r\n// interacting with battle contract\r\ncontract BattleInterface {\r\n    function addWarrior(address, uint, uint8, string) pure public returns (bool) {}\r\n    function isDead(uint) public pure returns (bool) {}\r\n}\r\n \r\n\r\n/**\r\n * @title ERC721Token\r\n * Generic implementation for the required functionality of the ERC721 standard\r\n */\r\ncontract ChibiFighters is ERC721, ContractOwned, CustomEvents {\r\n    using SafeMath for uint256;\r\n\r\n    // Total amount of tokens\r\n    uint256 private totalTokens;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private tokenApprovals;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping (address => uint256[]) private ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private ownedTokensIndex;\r\n\r\n    // interfaces for other contracts, so updates are possible\r\n    GeneInterface geneContract;\r\n    FcfInterface fcfContract;\r\n    BattleInterface battleContract;\r\n    address battleContractAddress;\r\n\r\n    // default price for 1 Chibi\r\n    uint public priceChibi;\r\n    // minimum price for fusion chibis\r\n    uint priceFusionChibi;\r\n\r\n    // counter that keeps upping with each token\r\n    uint uniqueCounter;\r\n\r\n    // time to become adult\r\n    uint adultTime;\r\n\r\n    // recovery time after each fusion\r\n    uint exhaustionTime;\r\n    \r\n    // our comission\r\n    uint comission;\r\n    \r\n    // battleRemoveContractAddress to remove from array\r\n    address battleRemoveContractAddress;\r\n\r\n    struct Chibi {\r\n        // address of current chibi owner\r\n        address owner;\r\n        // belongs to og\r\n        bool founder;\r\n        // name of the chibi, chibis need names\r\n        string nameChibi;\r\n        // the dna, specifies, bodyparts, etc.\r\n        // array is easier to decode, but we are not reinventing the wheel here\r\n        uint16[13] dna;\r\n        // originates from tokenIds, gen0s will return 0\r\n        // uint size only matters in structs\r\n        uint256 father;\r\n        uint256 mother;\r\n        // generations, gen0 is created from the incubator, they are pure\r\n        // but of course the funniest combos will come from the fusion chamber\r\n        uint gen;\r\n        // fusions, the beautiful fusion Chibis that came out of this one\r\n        uint256[] fusions;\r\n        // up for fusion?\r\n        bool forFusion;\r\n        // cost to fusion with this Chibi, can be set by player at will\r\n        uint256 fusionPrice;\r\n        // exhaustion after fusion\r\n        uint256 exhausted;\r\n        // block after which chibi is an adult \r\n        uint256 adult;\r\n        // info url\r\n        string infoUrl;\r\n    }\r\n\r\n    // the link to chibis website\r\n    string _infoUrlPrefix;\r\n\r\n    Chibi[] public chibies;\r\n\r\n    string public constant name = \"Chibi Fighters\";\r\n    string public constant symbol = \"CBF\";\r\n\r\n    // pause function so fusion and minting can be paused for updates\r\n    bool paused;\r\n    bool fcfPaused;\r\n    bool fusionPaused; // needed so founder can fuse while game is paused\r\n\r\n    /**\r\n    * @dev Run only once at contract creation\r\n    */\r\n    constructor() public {\r\n        // a helping counter to keep chibis unique\r\n        uniqueCounter = 0;\r\n        // inital price in wei\r\n        priceChibi = 100000000000000000;\r\n        // default price to allow fusion\r\n        priceFusionChibi = 10000000000000000;\r\n        // time to become adult\r\n        adultTime = 2 hours;\r\n        //exhaustionTime = 3 hours;\r\n        exhaustionTime = 1 hours;\r\n        // start the contract paused\r\n        paused = true;\r\n        fcfPaused = true;\r\n        fusionPaused = true;\r\n        // set comission percentage 100-90 = 10%\r\n        comission = 90; \r\n\r\n        _infoUrlPrefix = \"https://chibigame.io/chibis.php?idj=\";\r\n    }\r\n    \r\n    /**\r\n    * @dev Set Comission rate 100-x = %\r\n    * @param _comission Rate inverted\r\n    */\r\n    function setComission(uint _comission) public contract_onlyOwner returns(bool success) {\r\n        comission = _comission;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Set minimum price for fusion Chibis in Wei\r\n    */\r\n    function setMinimumPriceFusion(uint _price) public contract_onlyOwner returns(bool success) {\r\n        priceFusionChibi = _price;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Set time until Chibi is considered adult\r\n    * @param _adultTimeSecs Set time in seconds\r\n    */\r\n    function setAdultTime(uint _adultTimeSecs) public contract_onlyOwner returns(bool success) {\r\n        adultTime = _adultTimeSecs;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Fusion Chamber Cool down\r\n    * @param _exhaustionTime Set time in seconds\r\n    */\r\n    function setExhaustionTime(uint _exhaustionTime) public contract_onlyOwner returns(bool success) {\r\n        exhaustionTime = _exhaustionTime;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Set game state paused for updates, pauses the entire creation\r\n    * @param _setPaused Boolean sets the game paused or not\r\n    */\r\n    function setGameState(bool _setPaused) public contract_onlyOwner returns(bool _paused) {\r\n        paused = _setPaused;\r\n        fcfPaused = _setPaused;\r\n        fusionPaused = _setPaused;\r\n        return paused;\r\n    }\r\n    \r\n    /**\r\n    * @dev Set game state for fcf tokens only, so Founder can get Chibis pre launch\r\n    * @param _setPaused Boolean sets the game paused or not\r\n    */\r\n    function setGameStateFCF(bool _setPaused) public contract_onlyOwner returns(bool _pausedFCF) {\r\n        fcfPaused = _setPaused;\r\n        return fcfPaused;\r\n    }\r\n    \r\n    /**\r\n    * @dev unpause Fusions so Founder can Fuse\r\n    * @param _setPaused Boolean sets the game paused or not\r\n    */\r\n    function setGameStateFusion(bool _setPaused) public contract_onlyOwner returns(bool _pausedFusions) {\r\n        fusionPaused = _setPaused;\r\n        return fusionPaused;\r\n    }\r\n\r\n    /**\r\n    * @dev Query game state. Paused (True) or not?\r\n    */\r\n    function getGameState() public constant returns(bool _paused) {\r\n        return paused;\r\n    }\r\n\r\n    /**\r\n    * @dev Set url prefix\r\n    */\r\n    function setInfoUrlPrefix(string prefix) external contract_onlyOwner returns (string infoUrlPrefix) {\r\n        _infoUrlPrefix = prefix;\r\n        return _infoUrlPrefix;\r\n    }\r\n    \r\n    /**\r\n    * @dev Set infoUrl of chibi\r\n    */\r\n    function changeInfoUrl(uint _tokenId, string _infoUrl) public returns (bool success) {\r\n        if (ownerOf(_tokenId) != msg.sender && msg.sender != contract_owner) revert();\r\n        chibies[_tokenId].infoUrl = _infoUrl;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Connect to Founder contract so user can pay in FCF\r\n    */\r\n    function setFcfContractAddress(address _address) external contract_onlyOwner returns (bool success) {\r\n        fcfContract = FcfInterface(_address);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Connect to Battle contract\r\n    */\r\n    function setBattleContractAddress(address _address) external contract_onlyOwner returns (bool success) {\r\n        battleContract = BattleInterface(_address);\r\n        battleContractAddress = _address;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Connect to Battle contract\r\n    */\r\n    function setBattleRemoveContractAddress(address _address) external contract_onlyOwner returns (bool success) {\r\n        battleRemoveContractAddress = _address;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Rename a Chibi\r\n    * @param _tokenId ID of the Chibi\r\n    * @param _name Name of the Chibi\r\n    */\r\n    function renameChibi(uint _tokenId, string _name) public returns (bool success){\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n\r\n        chibies[_tokenId].nameChibi = _name;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Has chibi necromancer trait?\r\n     * @param _tokenId ID of the chibi\r\n     */\r\n    function isNecromancer(uint _tokenId) public view returns (bool) {\r\n        for (uint i=10; i<13; i++) {\r\n            if (chibies[_tokenId].dna[i] == 1000) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev buy Chibis with Founders\r\n    */\r\n    function buyChibiWithFcf(string _name, string _battleRoar, uint8 _region, uint _seed) public returns (bool success) {\r\n        // must own at least 1 FCF, only entire FCF can be swapped for Chibis\r\n        require(fcfContract.balanceOf(msg.sender) >= 1 * 10 ** 18);\r\n        require(fcfPaused == false);\r\n        // prevent hack\r\n        uint fcfBefore = fcfContract.balanceOf(address(this));\r\n        // user must approved Founders contract to take tokens from account\r\n        // oh my, this will need a tutorial video\r\n        // always only take 1 Founder at a time\r\n        if (fcfContract.transferFrom(msg.sender, this, 1 * 10 ** 18)) {\r\n            _mint(_name, _battleRoar, _region, _seed, true, 0);\r\n        }\r\n        // prevent hacking\r\n        assert(fcfBefore == fcfContract.balanceOf(address(this)) - 1 * 10 ** 18);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Put Chibi up for fusion, this will not destroy your Chibi. Only adults can fuse.\r\n    * @param _tokenId Id of Chibi token that is for fusion\r\n    * @param _price Price for the chibi in wei\r\n    */\r\n    function setChibiForFusion(uint _tokenId, uint _price) public returns (bool success) {\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n        require(_price >= priceFusionChibi);\r\n        require(chibies[_tokenId].adult <= now);\r\n        require(chibies[_tokenId].exhausted <= now);\r\n        require(chibies[_tokenId].forFusion == false);\r\n        require(battleContract.isDead(_tokenId) == false);\r\n\r\n        chibies[_tokenId].forFusion = true;\r\n        chibies[_tokenId].fusionPrice = _price;\r\n\r\n        emit ChibiForFusion(_tokenId, _price);\r\n        return true;\r\n    }\r\n\r\n    function cancelChibiForFusion(uint _tokenId) public returns (bool success) {\r\n        if (ownerOf(_tokenId) != msg.sender && msg.sender != address(battleRemoveContractAddress)) {\r\n            revert();\r\n        }\r\n        require(chibies[_tokenId].forFusion == true);\r\n        \r\n        chibies[_tokenId].forFusion = false;\r\n        \r\n        emit ChibiForFusionCancelled(_tokenId);\r\n            \r\n    return false;\r\n    }\r\n    \r\n\r\n \r\n    /**\r\n    * @dev Connect to gene contract. That way we can update that contract and add more fighters.\r\n    */\r\n    function setGeneContractAddress(address _address) external contract_onlyOwner returns (bool success) {\r\n        geneContract = GeneInterface(_address);\r\n        return true;\r\n    }\r\n \r\n    /**\r\n    * @dev Fusions cost too much so they are here\r\n    * @return All the fusions (babies) of tokenId\r\n    */\r\n    function queryFusionData(uint _tokenId) public view returns (\r\n        uint256[] fusions,\r\n        bool forFusion,\r\n        uint256 costFusion,\r\n        uint256 adult,\r\n        uint exhausted\r\n        ) {\r\n        return (\r\n        chibies[_tokenId].fusions,\r\n        chibies[_tokenId].forFusion,\r\n        chibies[_tokenId].fusionPrice,\r\n        chibies[_tokenId].adult,\r\n        chibies[_tokenId].exhausted\r\n        );\r\n    }\r\n    \r\n    /**\r\n    * @dev Minimal query for battle contract\r\n    * @return If for fusion\r\n    */\r\n    function queryFusionData_ext(uint _tokenId) public view returns (\r\n        bool forFusion,\r\n        uint fusionPrice\r\n        ) {\r\n        return (\r\n        chibies[_tokenId].forFusion,\r\n        chibies[_tokenId].fusionPrice\r\n        );\r\n    }\r\n \r\n    /**\r\n    * @dev Triggers a Chibi event to get some data of token\r\n    * @return various\r\n    */\r\n    function queryChibi(uint _tokenId) public view returns (\r\n        string nameChibi,\r\n        string infoUrl,\r\n        uint16[13] dna,\r\n        uint256 father,\r\n        uint256 mother,\r\n        uint gen,\r\n        uint adult\r\n        ) {\r\n        return (\r\n        chibies[_tokenId].nameChibi,\r\n        chibies[_tokenId].infoUrl,\r\n        chibies[_tokenId].dna,\r\n        chibies[_tokenId].father,\r\n        chibies[_tokenId].mother,\r\n        chibies[_tokenId].gen,\r\n        chibies[_tokenId].adult\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Triggers a Chibi event getting some additional data\r\n    * @return various\r\n    */\r\n    function queryChibiAdd(uint _tokenId) public view returns (\r\n        address owner,\r\n        bool founder\r\n        ) {\r\n        return (\r\n        chibies[_tokenId].owner,\r\n        chibies[_tokenId].founder\r\n        );\r\n    }\r\n    // exhaust after battle\r\n    function exhaustBattle(uint _tokenId) internal view returns (uint) {\r\n        uint _exhaust = 0;\r\n        \r\n        for (uint i=10; i<13; i++) {\r\n            if (chibies[_tokenId].dna[i] == 1) {\r\n                _exhaust += (exhaustionTime * 3);\r\n            }\r\n            if (chibies[_tokenId].dna[i] == 3) {\r\n                _exhaust += exhaustionTime.div(2);\r\n            }\r\n        }\r\n        \r\n        _exhaust = geneContract.exhaustAfterBattle(chibies[_tokenId].gen, _exhaust);\r\n\r\n        return _exhaust;\r\n    }\r\n    // exhaust after fusion\r\n    function exhaustFusion(uint _tokenId) internal returns (uint) {\r\n        uint _exhaust = 0;\r\n        \r\n        uint counter = chibies[_tokenId].dna[9];\r\n        // set dna here, that way boni still apply but not infinite fusions possible\r\n        // max value 9999\r\n        if (chibies[_tokenId].dna[9] < 9999) chibies[_tokenId].dna[9]++;\r\n        \r\n        for (uint i=10; i<13; i++) {\r\n            if (chibies[_tokenId].dna[i] == 2) {\r\n                counter = counter.sub(1);\r\n            }\r\n            if (chibies[_tokenId].dna[i] == 4) {\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        _exhaust = geneContract.exhaustAfterFusion(chibies[_tokenId].gen, counter, exhaustionTime);\r\n        \r\n        return _exhaust;\r\n    }\r\n    /** \r\n     * @dev Exhaust Chibis after battle\r\n     */\r\n    function exhaustChibis(uint _tokenId1, uint _tokenId2) public returns (bool success) {\r\n        require(msg.sender == battleContractAddress);\r\n        \r\n        chibies[_tokenId1].exhausted = now.add(exhaustBattle(_tokenId1));\r\n        chibies[_tokenId2].exhausted = now.add(exhaustBattle(_tokenId2)); \r\n        \r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @dev Split traits between father and mother and leave the random at the _tokenId2\r\n     */\r\n    function traits(uint16[13] memory genes, uint _seed, uint _fatherId, uint _motherId) internal view returns (uint16[13] memory) {\r\n    \r\n        uint _switch = uint136(keccak256(_seed, block.coinbase, block.timestamp)) % 5;\r\n        \r\n        if (_switch == 0) {\r\n            genes[10] = chibies[_fatherId].dna[10];\r\n            genes[11] = chibies[_motherId].dna[11];\r\n        }\r\n        if (_switch == 1) {\r\n            genes[10] = chibies[_motherId].dna[10];\r\n            genes[11] = chibies[_fatherId].dna[11];\r\n        }\r\n        if (_switch == 2) {\r\n            genes[10] = chibies[_fatherId].dna[10];\r\n            genes[11] = chibies[_fatherId].dna[11];\r\n        }\r\n        if (_switch == 3) {\r\n            genes[10] = chibies[_motherId].dna[10];\r\n            genes[11] = chibies[_motherId].dna[11];\r\n        }\r\n        \r\n        return genes;\r\n        \r\n    }\r\n    \r\n    /**\r\n    * @dev The fusion chamber combines both dnas and adds a generation.\r\n    */\r\n    function fusionChibis(uint _fatherId, uint _motherId, uint _seed, string _name, string _battleRoar, uint8 _region) payable public returns (bool success) {\r\n        require(fusionPaused == false);\r\n        require(ownerOf(_fatherId) == msg.sender);\r\n        require(ownerOf(_motherId) != msg.sender);\r\n        require(chibies[_fatherId].adult <= now);\r\n        require(chibies[_fatherId].exhausted <= now);\r\n        require(chibies[_motherId].adult <= now);\r\n        require(chibies[_motherId].exhausted <= now);\r\n        require(chibies[_motherId].forFusion == true);\r\n        require(chibies[_motherId].fusionPrice == msg.value);\r\n        // exhaust father and mother\r\n        chibies[_motherId].forFusion = false;\r\n        chibies[_motherId].exhausted = now.add(exhaustFusion(_motherId));\r\n        chibies[_fatherId].exhausted = now.add(exhaustFusion(_fatherId));\r\n        \r\n        uint _gen = 0;\r\n        if (chibies[_fatherId].gen >= chibies[_motherId].gen) {\r\n            _gen = chibies[_fatherId].gen.add(1);\r\n        } else {\r\n            _gen = chibies[_motherId].gen.add(1);\r\n        }\r\n        // fusion chamber here we come\r\n        uint16[13] memory dna = traits(geneContract.splitGenes(address(this), _seed, uniqueCounter+1), _seed, _fatherId, _motherId);\r\n        \r\n        // new Chibi is born!\r\n        addToken(msg.sender, uniqueCounter);\r\n\r\n        // father and mother get the chibi in their fusion list\r\n        chibies[_fatherId].fusions.push(uniqueCounter);\r\n        // only add if mother different than father, otherwise double entry\r\n        if (_fatherId != _motherId) {\r\n            chibies[_motherId].fusions.push(uniqueCounter);\r\n        }\r\n        \r\n        // baby Chibi won't have fusions\r\n        uint[] memory _fusions;\r\n        \r\n        // baby Chibis can't be fused\r\n        chibies.push(Chibi(\r\n            msg.sender,\r\n            false,\r\n            _name, \r\n            dna,\r\n            _fatherId,\r\n            _motherId,\r\n            _gen,\r\n            _fusions,\r\n            false,\r\n            priceFusionChibi,\r\n            0,\r\n            now.add(adultTime.mul((_gen.mul(_gen)).add(1))),\r\n            strConcat(_infoUrlPrefix, uint2str(uniqueCounter))\r\n        ));\r\n        \r\n        // fires chibi created event\r\n        emit ChibiCreated(\r\n            uniqueCounter,\r\n            chibies[uniqueCounter].owner,\r\n            chibies[uniqueCounter].founder,\r\n            chibies[uniqueCounter].nameChibi,\r\n            chibies[uniqueCounter].dna, \r\n            chibies[uniqueCounter].father, \r\n            chibies[uniqueCounter].mother, \r\n            chibies[uniqueCounter].gen,\r\n            chibies[uniqueCounter].adult,\r\n            chibies[uniqueCounter].infoUrl\r\n        );\r\n\r\n        // send transfer event\r\n        emit Transfer(0x0, msg.sender, uniqueCounter);\r\n        \r\n        // create Warrior\r\n        if (battleContract.addWarrior(address(this), uniqueCounter, _region, _battleRoar) == false) revert();\r\n        \r\n        uniqueCounter ++;\r\n        // transfer money to seller minus our share, remain stays in contract\r\n        uint256 amount = msg.value / 100 * comission;\r\n        chibies[_motherId].owner.transfer(amount);\r\n        return true;\r\n }\r\n\r\n    /**\r\n    * @dev Guarantees msg.sender is owner of the given token\r\n    * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n    */\r\n    modifier onlyOwnerOf(uint256 _tokenId) {\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n        _;\r\n    }\r\n \r\n    /**\r\n    * @dev Gets the total amount of tokens stored by the contract\r\n    * @return uint256 representing the total amount of tokens\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalTokens;\r\n    }\r\n \r\n    /**\r\n    * @dev Gets the balance of the specified address\r\n    * @param _owner address to query the balance of\r\n    * @return uint256 representing the amount owned by the passed address\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return ownedTokens[_owner].length;\r\n    }\r\n \r\n    /**\r\n    * @dev Gets the list of tokens owned by a given address\r\n    * @param _owner address to query the tokens of\r\n    * @return uint256[] representing the list of tokens owned by the passed address\r\n    */\r\n    function tokensOf(address _owner) public view returns (uint256[]) {\r\n        return ownedTokens[_owner];\r\n    }\r\n \r\n    /**\r\n    * @dev Gets the owner of the specified token ID\r\n    * @param _tokenId uint256 ID of the token to query the owner of\r\n    * @return owner address currently marked as the owner of the given token ID\r\n    */\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = tokenOwner[_tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n \r\n    /**\r\n    * @dev Gets the approved address to take ownership of a given token ID\r\n    * @param _tokenId uint256 ID of the token to query the approval of\r\n    * @return address currently approved to take ownership of the given token ID\r\n    */\r\n    function approvedFor(uint256 _tokenId) public view returns (address) {\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n \r\n    /**\r\n    * @dev Transfers the ownership of a given token ID to another address\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transfer(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\r\n        clearApprovalAndTransfer(msg.sender, _to, _tokenId);\r\n    }\r\n \r\n    /**\r\n    * @dev Approves another address to claim for the ownership of the given token ID\r\n    * @param _to address to be approved for the given token ID\r\n    * @param _tokenId uint256 ID of the token to be approved\r\n    */\r\n    function approve(address _to, uint256 _tokenId) public onlyOwnerOf(_tokenId) {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_to != owner);\r\n        if (approvedFor(_tokenId) != 0 || _to != 0) {\r\n            tokenApprovals[_tokenId] = _to;\r\n            emit Approval(owner, _to, _tokenId);\r\n        }\r\n    }\r\n \r\n    /**\r\n    * @dev Claims the ownership of a given token ID\r\n    * @param _tokenId uint256 ID of the token being claimed by the msg.sender\r\n    */\r\n    function takeOwnership(uint256 _tokenId) public {\r\n        require(isApprovedFor(msg.sender, _tokenId));\r\n        clearApprovalAndTransfer(ownerOf(_tokenId), msg.sender, _tokenId);\r\n    }\r\n    \r\n    function mintSpecial(string _name, string _battleRoar, uint8 _region, uint _seed, uint _specialId) public contract_onlyOwner returns (bool success) {\r\n        // name can be empty\r\n        _mint(_name, _battleRoar, _region, _seed, false, _specialId);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * @dev Mint token function\r\n    * @param _name name of the Chibi\r\n    */\r\n    function _mint(string _name, string _battleRoar, uint8 _region, uint _seed, bool _founder, uint _specialId) internal {\r\n        require(msg.sender != address(0));\r\n        addToken(msg.sender, uniqueCounter);\r\n    \r\n        // creates a gen0 Chibi, no father, mother, gen0\r\n        uint16[13] memory dna;\r\n        \r\n        if (_specialId > 0) {\r\n            dna  = geneContract.createGenes(address(this), _seed, _founder, uniqueCounter, _specialId);\r\n        } else {\r\n            dna = geneContract.createGenes(address(this), _seed, _founder, uniqueCounter, 0);\r\n        }\r\n\r\n        uint[] memory _fusions;\r\n\r\n        chibies.push(Chibi(\r\n            msg.sender,\r\n            _founder,\r\n            _name, \r\n            dna,\r\n            0,\r\n            0,\r\n            0,\r\n            _fusions,\r\n            false,\r\n            priceFusionChibi,\r\n            0,\r\n            now.add(adultTime),\r\n            strConcat(_infoUrlPrefix, uint2str(uniqueCounter))\r\n        ));\r\n        \r\n        // send transfer event\r\n        emit Transfer(0x0, msg.sender, uniqueCounter);\r\n        \r\n        // create Warrior\r\n        if (battleContract.addWarrior(address(this), uniqueCounter, _region, _battleRoar) == false) revert();\r\n        \r\n        // fires chibi created event\r\n        emit ChibiCreated(\r\n            uniqueCounter,\r\n            chibies[uniqueCounter].owner,\r\n            chibies[uniqueCounter].founder,\r\n            chibies[uniqueCounter].nameChibi,\r\n            chibies[uniqueCounter].dna, \r\n            chibies[uniqueCounter].father, \r\n            chibies[uniqueCounter].mother, \r\n            chibies[uniqueCounter].gen,\r\n            chibies[uniqueCounter].adult,\r\n            chibies[uniqueCounter].infoUrl\r\n        );\r\n        \r\n        uniqueCounter ++;\r\n    }\r\n \r\n    /**\r\n    * @dev buy gen0 chibis\r\n    * @param _name name of the Chibi\r\n    */\r\n    function buyGEN0Chibi(string _name, string _battleRoar, uint8 _region, uint _seed) payable public returns (bool success) {\r\n        require(paused == false);\r\n        // cost at least 100 wei\r\n        require(msg.value == priceChibi);\r\n        // name can be empty\r\n        _mint(_name, _battleRoar, _region, _seed, false, 0);\r\n        return true;\r\n    }\r\n \r\n    /**\r\n    * @dev set default sale price of Chibies\r\n    * @param _priceChibi price of 1 Chibi in Wei\r\n    */\r\n    function setChibiGEN0Price(uint _priceChibi) public contract_onlyOwner returns (bool success) {\r\n        priceChibi = _priceChibi;\r\n        return true;\r\n    }\r\n \r\n    /**\r\n    * @dev Tells whether the msg.sender is approved for the given token ID or not\r\n    * This function is not private so it can be extended in further implementations like the operatable ERC721\r\n    * @param _owner address of the owner to query the approval of\r\n    * @param _tokenId uint256 ID of the token to query the approval of\r\n    * @return bool whether the msg.sender is approved for the given token ID or not\r\n    */\r\n    function isApprovedFor(address _owner, uint256 _tokenId) internal view returns (bool) {\r\n        return approvedFor(_tokenId) == _owner;\r\n    }\r\n \r\n    /**\r\n    * @dev Internal function to clear current approval and transfer the ownership of a given token ID\r\n    * @param _from address which you want to send tokens from\r\n    * @param _to address which you want to transfer the token to\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function clearApprovalAndTransfer(address _from, address _to, uint256 _tokenId) internal {\r\n        require(_to != address(0));\r\n        require(_to != ownerOf(_tokenId));\r\n        require(ownerOf(_tokenId) == _from);\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeToken(_from, _tokenId);\r\n        addToken(_to, _tokenId);\r\n        \r\n        // Chibbi code\r\n        chibies[_tokenId].owner = _to;\r\n        chibies[_tokenId].forFusion = false;\r\n        \r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n \r\n    /**\r\n    * @dev Internal function to clear current approval of a given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function clearApproval(address _owner, uint256 _tokenId) private {\r\n        require(ownerOf(_tokenId) == _owner);\r\n        tokenApprovals[_tokenId] = 0;\r\n        emit Approval(_owner, 0, _tokenId);\r\n    }\r\n \r\n    /**\r\n    * @dev Internal function to add a token ID to the list of a given address\r\n    * @param _to address representing the new owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n    */\r\n    function addToken(address _to, uint256 _tokenId) private {\r\n        require(tokenOwner[_tokenId] == address(0));\r\n        tokenOwner[_tokenId] = _to;\r\n        uint256 length = balanceOf(_to);\r\n        ownedTokens[_to].push(_tokenId);\r\n        ownedTokensIndex[_tokenId] = length;\r\n        totalTokens++;\r\n    }\r\n \r\n    /**\r\n    * @dev Internal function to remove a token ID from the list of a given address\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n    */\r\n    function removeToken(address _from, uint256 _tokenId) private {\r\n        require(ownerOf(_tokenId) == _from);\r\n        \r\n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = balanceOf(_from).sub(1);\r\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n        \r\n        tokenOwner[_tokenId] = 0;\r\n        ownedTokens[_from][tokenIndex] = lastToken;\r\n        ownedTokens[_from][lastTokenIndex] = 0;\r\n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n        \r\n        ownedTokens[_from].length--;\r\n        ownedTokensIndex[_tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = tokenIndex;\r\n        totalTokens = totalTokens.sub(1);\r\n    }\r\n\r\n    /**\r\n    * @dev Send Ether to owner\r\n    * @param _address Receiving address\r\n    * @param amount Amount in WEI to send\r\n    **/\r\n    function weiToOwner(address _address, uint amount) public contract_onlyOwner {\r\n        require(amount <= address(this).balance);\r\n        _address.transfer(amount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Return the infoUrl of Chibi\r\n    * @param _tokenId infoUrl of _tokenId\r\n    **/\r\n    function tokenMetadata(uint256 _tokenId) constant public returns (string infoUrl) {\r\n        return chibies[_tokenId].infoUrl;\r\n    }\r\n    \r\n    function tokenURI(uint256 _tokenId) public view returns (string) {\r\n        return chibies[_tokenId].infoUrl;\r\n    }\r\n\r\n    //\r\n    // some helpful functions\r\n    // https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\r\n    //\r\n    function uint2str(uint i) internal pure returns (string) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory bab = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n        return string(bab);\r\n        }\r\n    }", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId1\",\"type\":\"uint256\"},{\"name\":\"_tokenId2\",\"type\":\"uint256\"}],\"name\":\"exhaustChibis\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adultTimeSecs\",\"type\":\"uint256\"}],\"name\":\"setAdultTime\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_comission\",\"type\":\"uint256\"}],\"name\":\"setComission\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"weiToOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_setPaused\",\"type\":\"bool\"}],\"name\":\"setGameStateFCF\",\"outputs\":[{\"name\":\"_pausedFCF\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setChibiForFusion\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chibies\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"founder\",\"type\":\"bool\"},{\"name\":\"nameChibi\",\"type\":\"string\"},{\"name\":\"father\",\"type\":\"uint256\"},{\"name\":\"mother\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"forFusion\",\"type\":\"bool\"},{\"name\":\"fusionPrice\",\"type\":\"uint256\"},{\"name\":\"exhausted\",\"type\":\"uint256\"},{\"name\":\"adult\",\"type\":\"uint256\"},{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_priceChibi\",\"type\":\"uint256\"}],\"name\":\"setChibiGEN0Price\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setGeneContractAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approvedFor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setBattleRemoveContractAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"renameChibi\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_setPaused\",\"type\":\"bool\"}],\"name\":\"setGameState\",\"outputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fatherId\",\"type\":\"uint256\"},{\"name\":\"_motherId\",\"type\":\"uint256\"},{\"name\":\"_seed\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_battleRoar\",\"type\":\"string\"},{\"name\":\"_region\",\"type\":\"uint8\"}],\"name\":\"fusionChibis\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setBattleContractAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_setPaused\",\"type\":\"bool\"}],\"name\":\"setGameStateFusion\",\"outputs\":[{\"name\":\"_pausedFusions\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"queryFusionData\",\"outputs\":[{\"name\":\"fusions\",\"type\":\"uint256[]\"},{\"name\":\"forFusion\",\"type\":\"bool\"},{\"name\":\"costFusion\",\"type\":\"uint256\"},{\"name\":\"adult\",\"type\":\"uint256\"},{\"name\":\"exhausted\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"name\":\"infoUrl\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exhaustionTime\",\"type\":\"uint256\"}],\"name\":\"setExhaustionTime\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isNecromancer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelChibiForFusion\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"queryChibi\",\"outputs\":[{\"name\":\"nameChibi\",\"type\":\"string\"},{\"name\":\"infoUrl\",\"type\":\"string\"},{\"name\":\"dna\",\"type\":\"uint16[13]\"},{\"name\":\"father\",\"type\":\"uint256\"},{\"name\":\"mother\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"adult\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setFcfContractAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_battleRoar\",\"type\":\"string\"},{\"name\":\"_region\",\"type\":\"uint8\"},{\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"buyChibiWithFcf\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_battleRoar\",\"type\":\"string\"},{\"name\":\"_region\",\"type\":\"uint8\"},{\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"buyGEN0Chibi\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_battleRoar\",\"type\":\"string\"},{\"name\":\"_region\",\"type\":\"uint8\"},{\"name\":\"_seed\",\"type\":\"uint256\"},{\"name\":\"_specialId\",\"type\":\"uint256\"}],\"name\":\"mintSpecial\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contract_newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setMinimumPriceFusion\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameState\",\"outputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_infoUrl\",\"type\":\"string\"}],\"name\":\"changeInfoUrl\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"queryChibiAdd\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"founder\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceChibi\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"queryFusionData_ext\",\"outputs\":[{\"name\":\"forFusion\",\"type\":\"bool\"},{\"name\":\"fusionPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prefix\",\"type\":\"string\"}],\"name\":\"setInfoUrlPrefix\",\"outputs\":[{\"name\":\"infoUrlPrefix\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"founder\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"dna\",\"type\":\"uint16[13]\"},{\"indexed\":false,\"name\":\"father\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mother\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gen\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"adult\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"infoUrl\",\"type\":\"string\"}],\"name\":\"ChibiCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ChibiForFusion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ChibiForFusionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"battleRoar\",\"type\":\"string\"}],\"name\":\"WarriorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "ChibiFighters", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://ef67d6321542ac2083a13f0fba267b4b4b6b00f0a19bf67cecf47adfaaf932be"}