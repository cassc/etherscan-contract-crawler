{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\ninterface IGreen {\r\n    function transferOwnership(address _newOwner) external;\r\n    function acceptOwnership() external;\r\n    function totalSupply() external view returns (uint);\r\n    function distributeMinting(address[] memory to, uint256[] memory value) external;\r\n\r\n}\r\n\r\ncontract BridgeMinterTL {\r\n    address public owner;\r\n    address private notary;\r\n    address private approver;\r\n    IGreen public tokenAddress;\r\n    bool private bridging;\r\n    uint256 private chainId;\r\n    bytes32 private domainSeparator;\r\n    address public pendingOwner;\r\n    address public erc20PendingOwner;\r\n    uint public ownershipTransferInitiatedAt;\r\n    uint public erc20OwnershipTransferInitiatedAt;\r\n    uint constant TRANSFER_DELAY = 48 hours;\r\n    bool public notaryApprove;\r\n    bool public approverApprove;\r\n\r\n    mapping(bytes32 => bool) private nonces;\r\n\r\n    event Bridged(address  receiver, uint256 amount);\r\n    event TransferOwnership(address indexed owner, bool indexed confirmed);\r\n\r\n    constructor(address _owner, address _approver, address _notary, address _tokenContractAddress, uint256 _chainId){\r\n        require(_owner != address(0));       // dev: invalid owner\r\n        require(_approver != address(0));     // dev: invalid approver\r\n        require(_notary != address(0));       // dev: invalid notary\r\n        owner = _owner;\r\n        approver = _approver;\r\n        notary = _notary;\r\n        chainId = _chainId;\r\n\r\n        tokenAddress = IGreen(_tokenContractAddress);\r\n\r\n        domainSeparator = keccak256(\r\n            abi.encode(\r\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId)\"),\r\n                keccak256(\"Neptune Bridge\"), \r\n                keccak256(\"0.0.1\"), \r\n                _chainId\r\n            )\r\n        );\r\n    }\r\n\r\n    // Function to initiate ownership transfer\r\n    function initiateTransferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"New owner cannot be zero address\");\r\n        require(_newOwner != owner, \"New owner is already the current owner\");\r\n        pendingOwner = _newOwner;\r\n        ownershipTransferInitiatedAt = block.timestamp;\r\n    }\r\n\r\n    // Function to finalize ownership transfer after 48 hours\r\n    function finalizeTransferOwnership() public {\r\n        require(msg.sender == pendingOwner, \"Only pending owner can finalize ownership transfer\");\r\n        require(block.timestamp >= ownershipTransferInitiatedAt + TRANSFER_DELAY, \"Must wait 48 hours to confirm transfer.\");\r\n        owner = pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    // Function to initiate token ownership transfer\r\n    function initiateTransferTokenOwnership(address _newOwner) public onlyOwner {\r\n        erc20OwnershipTransferInitiatedAt = block.timestamp;\r\n        erc20PendingOwner = _newOwner;\r\n    }\r\n\r\n    // Function to finalize token ownership transfer after 48 hours\r\n    function completeTransferTokenOwnership() public onlyOwner {\r\n        require(block.timestamp >= erc20OwnershipTransferInitiatedAt + TRANSFER_DELAY, \"Must wait 48 hours to confirm transfer.\");\r\n        tokenAddress.transferOwnership(erc20PendingOwner);\r\n    }\r\n\r\n    function acceptTokenOwnership() public {\r\n        tokenAddress.acceptOwnership();\r\n    }\r\n    \r\n    modifier checkNonce(bytes32 nonce) {\r\n        require(nonces[nonce]==false); // dev: already processed\r\n        _;\r\n    }\r\n\r\n    function bridge(address sender, uint256 bridgedAmount, bytes32 nonce, bytes32 messageHash, bytes calldata approvedMessage, bytes calldata notarizedMessage)\r\n    external checkNonce(nonce) {\r\n        require(bridging == false, \"Re-entrancy guard triggered: bridging already in progress\"); // Re-entrancy guard\r\n        bridging = true;\r\n\r\n        bytes32 hashToVerify = keccak256(\r\n            abi.encode(keccak256(\"SignedMessage(bytes32 key,address sender,uint256 amount)\"), nonce, sender, bridgedAmount)\r\n        );\r\n\r\n        require(checkEncoding(approvedMessage, messageHash, hashToVerify, approver), \"Invalid signature from approver\"); // Check approver's signature\r\n        require(checkEncoding(notarizedMessage, messageHash, hashToVerify, notary), \"Invalid signature from notary\"); // Check notary's signature\r\n\r\n        nonces[nonce] = true;\r\n\r\n        uint256 maxSupply = 5000000000000000000; // 50 billion tokens with 8 decimals precalculated\r\n        uint256 totalSupply = tokenAddress.totalSupply();\r\n\r\n        require(totalSupply + bridgedAmount <= maxSupply, \"Minting would exceed the maximum supply of 50 billion tokens\"); // Check max mint amount\r\n\r\n        address[] memory recipients = new address[](1);\r\n        recipients[0] = sender;\r\n\r\n        uint256[] memory amounts = new uint256[](1);\r\n        amounts[0] = bridgedAmount;\r\n\r\n        tokenAddress.distributeMinting(recipients, amounts);\r\n\r\n        emit Bridged(sender, bridgedAmount);\r\n        bridging = false;\r\n    }\r\n\r\n\r\n    function checkEncoding(bytes memory signedMessage,bytes32 messageHash, bytes32 hashToVerify, address signer) \r\n    internal view returns(bool){\r\n\r\n        bytes32 domainSeparatorHash = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, hashToVerify));\r\n        require(messageHash == domainSeparatorHash); //dev: values do not match\r\n\r\n        return signer == recoverSigner(messageHash, signedMessage);\r\n    }\r\n\r\n    function splitSignature(bytes memory sig)\r\n    internal pure returns (uint8 v, bytes32 r, bytes32 s){\r\n        require(sig.length == 65); // dev: signature invalid\r\n\r\n        assembly {\r\n            // first 32 bytes, after the length prefix.\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes.\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes).\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        return (v, r, s);\r\n    }\r\n\r\n    function recoverSigner(bytes32 message, bytes memory sig)\r\n    internal pure returns (address){\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n\r\n        (v, r, s) = splitSignature(sig);\r\n\r\n        return tryRecover(message, v, r, s);\r\n    }\r\n\r\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\r\n    internal \r\n    pure \r\n    returns (address) {\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return address(0);\r\n        } else if (v != 27 && v != 28) {\r\n            return address(0);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return address(0);\r\n        }\r\n\r\n        return signer;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_approver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_notary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Bridged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptTokenOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approverApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bridgedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"messageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"approvedMessage\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"notarizedMessage\",\"type\":\"bytes\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completeTransferTokenOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20OwnershipTransferInitiatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20PendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"initiateTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"initiateTransferTokenOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notaryApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownershipTransferInitiatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"contract IGreen\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BridgeMinterTL", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000090cf5721a285e71425752b86df434aafe7b259a500000000000000000000000004c55def257624e45ace4520b00cc543ba655dbe00000000000000000000000038e21a32ee83e0d56895a08b12e597e3c656eb10000000000000000000000000b2089a7069861c8d90c8da3aacab8e9188c0c5310000000000000000000000000000000000000000000000000000000000001b1d", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e7a778497bd63e303f9287c35a9096b0eec65313ba049ac84ec03824d6c9865c"}