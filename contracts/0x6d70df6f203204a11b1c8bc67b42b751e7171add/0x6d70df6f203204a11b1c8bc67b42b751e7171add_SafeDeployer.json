{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/core/SafeDeployer.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {ReentrancyGuard} from \\\"openzeppelin-contracts/security/ReentrancyGuard.sol\\\";\\nimport {AddressProviderService} from \\\"../core/AddressProviderService.sol\\\";\\nimport {WalletRegistry} from \\\"../core/registries/WalletRegistry.sol\\\";\\nimport {PolicyRegistry} from \\\"../core/registries/PolicyRegistry.sol\\\";\\nimport {ISafeProxyFactory} from \\\"../../interfaces/external/ISafeProxyFactory.sol\\\";\\nimport {ISafeWallet} from \\\"../../interfaces/external/ISafeWallet.sol\\\";\\nimport {Types, SafeHelper} from \\\"../libraries/SafeHelper.sol\\\";\\nimport {ISafeMultiSend} from \\\"../../interfaces/external/ISafeMultiSend.sol\\\";\\n\\n/**\\n * @title SafeDeployer\\n * @author Brahma.fi\\n * @notice Deploys new brahma console accounts and sub accounts\\n */\\ncontract SafeDeployer is AddressProviderService, ReentrancyGuard {\\n    /// @notice version of safe deployer\\n    string public constant VERSION = \\\"1\\\";\\n\\n    /**\\n     * @notice hash of safe create2 failure reason\\n     * @dev keccak256(\\\"Create2 call failed\\\");\\n     */\\n    bytes32 internal constant _SAFE_CREATION_FAILURE_REASON =\\n        0xd7c71a0bdd2eb2834ad042153c811dd478e4ee2324e3003b9522e03e7b3735dc;\\n\\n    event SafeProxyCreationFailure(address indexed singleton, uint256 indexed nonce, bytes initializer);\\n    event ConsoleAccountDeployed(address indexed consoleAddress);\\n    event SubAccountDeployed(address indexed subAccountAddress, address indexed consoleAddress);\\n    event PreComputeAccount(address[] indexed owners, uint256 indexed threshold);\\n\\n    error InvalidCommitment();\\n    error NotWallet();\\n    error PreComputedAccount(address addr);\\n    error SafeProxyCreationFailed();\\n\\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\\n\\n    /// @notice owners nonce\\n    mapping(bytes32 ownersHash => uint256 count) public ownerSafeCount;\\n\\n    /**\\n     * @notice Deploys a new console account with or without policy commit and registers it\\n     * @dev _owners list should contain addresses in the same order to generate same console address on all chains\\n     * @param _owners list of safe owners\\n     * @param _threshold safe threshold\\n     * @param _policyCommit commitment\\n     * @param _salt salt to be used during creation of safe\\n     * @return _safe deployed console account address\\n     */\\n    function deployConsoleAccount(address[] calldata _owners, uint256 _threshold, bytes32 _policyCommit, bytes32 _salt)\\n        external\\n        nonReentrant\\n        returns (address _safe)\\n    {\\n        bool _policyHashValid = _policyCommit != bytes32(0);\\n\\n        _safe = _createSafe(_owners, _setupConsoleAccount(_owners, _threshold, _policyHashValid), _salt);\\n\\n        if (_policyHashValid) {\\n            PolicyRegistry(policyRegistry).updatePolicy(_safe, _policyCommit);\\n        }\\n        emit ConsoleAccountDeployed(_safe);\\n    }\\n\\n    /**\\n     * @notice Deploys a new sub-account with policy commit and registers it\\n     * @dev ConsoleAccount is enabled as module\\n     * @param _owners list of safe owners\\n     * @param _threshold safe threshold\\n     * @param _policyCommit commitment\\n     * @param _salt salt to be used during creation of safe, to generate nonce\\n     * @return _subAcc deployed sub-account address\\n     */\\n    function deploySubAccount(address[] calldata _owners, uint256 _threshold, bytes32 _policyCommit, bytes32 _salt)\\n        external\\n        nonReentrant\\n        returns (address _subAcc)\\n    {\\n        // Policy commit is required for sub account\\n        if (_policyCommit == bytes32(0)) revert InvalidCommitment();\\n\\n        // Check if msg.sender is a registered wallet\\n        if (!WalletRegistry(walletRegistry).isWallet(msg.sender)) revert NotWallet();\\n\\n        // Deploy sub account\\n        _subAcc = _createSafe(_owners, _setupSubAccount(_owners, _threshold), _salt);\\n\\n        // Register sub account to wallet\\n        WalletRegistry(walletRegistry).registerSubAccount(msg.sender, _subAcc);\\n\\n        // Update policy commit for sub account\\n        PolicyRegistry(policyRegistry).updatePolicy(_subAcc, _policyCommit);\\n        emit SubAccountDeployed(_subAcc, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Private helper function to setup Console account with setUp transactions\\n     * @param _owners list of owners addresses\\n     * @param _threshold safe threshold\\n     */\\n    function _setupConsoleAccount(address[] memory _owners, uint256 _threshold, bool _policyHashValid)\\n        private\\n        view\\n        returns (bytes memory)\\n    {\\n        address fallbackHandler;\\n        Types.Executable[] memory txns;\\n\\n        if (_policyHashValid) {\\n            txns = new Types.Executable[](2);\\n            fallbackHandler = AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH);\\n\\n            // Enable guard on console account\\n            txns[1] = Types.Executable({\\n                callType: Types.CallType.DELEGATECALL,\\n                target: AddressProviderService._getAuthorizedAddress(_SAFE_ENABLER_HASH),\\n                value: 0,\\n                data: abi.encodeCall(\\n                    ISafeWallet.setGuard, (AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_OVERRIDABLE_HASH))\\n                    )\\n            });\\n        } else {\\n            txns = new Types.Executable[](1);\\n            fallbackHandler = AddressProviderService._getAuthorizedAddress(_SAFE_FALLBACK_HANDLER_HASH);\\n        }\\n\\n        // Register Wallet\\n        /// @dev This function is being packed as a part of multisend transaction as, safe internally performs\\n        // a delegatecall during initializer to the target contract, so direct call doesnt work. Multisend is\\n        // supposed to be delegatecall\\n        txns[0] = Types.Executable({\\n            callType: Types.CallType.CALL,\\n            target: walletRegistry,\\n            value: 0,\\n            data: abi.encodeCall(WalletRegistry.registerWallet, ())\\n        });\\n\\n        return abi.encodeCall(\\n            ISafeWallet.setup,\\n            (\\n                _owners,\\n                _threshold,\\n                AddressProviderService._getAuthorizedAddress(_SAFE_MULTI_SEND_HASH),\\n                abi.encodeCall(ISafeMultiSend.multiSend, (SafeHelper._packMultisendTxns(txns))),\\n                fallbackHandler,\\n                address(0),\\n                0,\\n                address(0)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Private helper function to setup subAccount safe with setUp transactions\\n     * @param _owners list of owners addresses\\n     * @param _threshold safe threshold\\n     */\\n    function _setupSubAccount(address[] memory _owners, uint256 _threshold) private view returns (bytes memory) {\\n        address safeEnabler = AddressProviderService._getAuthorizedAddress(_SAFE_ENABLER_HASH);\\n        Types.Executable[] memory txns = new Types.Executable[](2);\\n\\n        // Enable Brhma Console account as module on sub Account\\n        txns[0] = Types.Executable({\\n            callType: Types.CallType.DELEGATECALL,\\n            target: safeEnabler,\\n            value: 0,\\n            data: abi.encodeCall(ISafeWallet.enableModule, (msg.sender))\\n        });\\n\\n        // Enable guard on subAccount\\n        txns[1] = Types.Executable({\\n            callType: Types.CallType.DELEGATECALL,\\n            target: safeEnabler,\\n            value: 0,\\n            data: abi.encodeCall(ISafeWallet.setGuard, (AddressProviderService._getAuthorizedAddress(_SAFE_MODERATOR_HASH)))\\n        });\\n\\n        return abi.encodeCall(\\n            ISafeWallet.setup,\\n            (\\n                _owners,\\n                _threshold,\\n                AddressProviderService._getAuthorizedAddress(_SAFE_MULTI_SEND_HASH),\\n                abi.encodeCall(ISafeMultiSend.multiSend, (SafeHelper._packMultisendTxns(txns))),\\n                AddressProviderService._getAuthorizedAddress(_CONSOLE_FALLBACK_HANDLER_HASH),\\n                address(0),\\n                0,\\n                address(0)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Internal function to create a new Safe Wallet.\\n     * @dev SafeDeployer calls createProxyWithNonce to deploy a new Safe Wallet. This also contains initializer bytes\\n     *  which are used during creation to setup the safe with owners and threshold. An actor can precompute the salt\\n     *  for a given set of owners and deploy the safe. We choose to not consider that safe as a valid safe and deploy a new\\n     *  safe. In case the actor chooses to deploy multiple precomputed safes with bumped nonces, the transaction will run out\\n     *  of gas and user can retry with a new random salt\\n     *  To generate deterministic addresses for a given set of owners, the order of owner addresses and threshold should be same\\n     * @param _owners list of owners addresses\\n     * @param _salt salt to be used during creation of safe, to generate nonce\\n     * @return _safe The address of the created Safe Wallet.\\n     */\\n    function _createSafe(address[] calldata _owners, bytes memory _initializer, bytes32 _salt)\\n        private\\n        returns (address _safe)\\n    {\\n        address safeProxyFactory = AddressProviderService._getAuthorizedAddress(_SAFE_PROXY_FACTORY_HASH);\\n        address safeSingleton = AddressProviderService._getAuthorizedAddress(_SAFE_SINGLETON_HASH);\\n        bytes32 ownersHash = keccak256(abi.encode(_owners));\\n\\n        // Generate nonce based on owners and user provided salt\\n        do {\\n            uint256 nonce = _genNonce(ownersHash, _salt);\\n            try ISafeProxyFactory(safeProxyFactory).createProxyWithNonce(safeSingleton, _initializer, nonce) returns (\\n                address _deployedSafe\\n            ) {\\n                _safe = _deployedSafe;\\n            } catch Error(string memory reason) {\\n                // KEK\\n                if (keccak256(bytes(reason)) != _SAFE_CREATION_FAILURE_REASON) {\\n                    // Revert if the error is not due to create2 call failure\\n                    revert SafeProxyCreationFailed();\\n                }\\n                // A safe is already deployed with the same salt, retry with bumped nonce\\n                emit SafeProxyCreationFailure(safeSingleton, nonce, _initializer);\\n            } catch {\\n                revert SafeProxyCreationFailed();\\n            }\\n        } while (_safe == address(0));\\n    }\\n\\n    /**\\n     * @notice Internal function to get the nonce of a user's safe deployment\\n     * @param _ownersHash address of owner of the safe.\\n     * @param _salt salt to be used in nonce generation\\n     * @return The nonce of the user's safe deployment.\\n     */\\n    function _genNonce(bytes32 _ownersHash, bytes32 _salt) private returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(_ownersHash, ownerSafeCount[_ownersHash]++, _salt, VERSION)));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/AddressProviderService.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {IAddressProviderService} from \\\"../../interfaces/IAddressProviderService.sol\\\";\\nimport {AddressProvider} from \\\"../core/AddressProvider.sol\\\";\\nimport {Constants} from \\\"./Constants.sol\\\";\\n\\n/**\\n * @title AddressProviderService\\n * @author Brahma.fi\\n * @notice Provides a base contract for services to resolve other services through AddressProvider\\n * @dev This contract is designed to be inheritable by other contracts\\n *  Provides quick and easy access to all contracts in Console Ecosystem\\n */\\nabstract contract AddressProviderService is IAddressProviderService, Constants {\\n    error InvalidAddressProvider();\\n    error NotGovernance(address);\\n    error InvalidAddress();\\n\\n    /// @notice address of addressProvider\\n    // solhint-disable-next-line immutable-vars-naming\\n    AddressProvider public immutable addressProvider;\\n    address public immutable walletRegistry;\\n    address public immutable policyRegistry;\\n    address public immutable executorRegistry;\\n\\n    constructor(address _addressProvider) {\\n        if (_addressProvider == address(0)) revert InvalidAddressProvider();\\n        addressProvider = AddressProvider(_addressProvider);\\n\\n        walletRegistry = addressProvider.getRegistry(_WALLET_REGISTRY_HASH);\\n        policyRegistry = addressProvider.getRegistry(_POLICY_REGISTRY_HASH);\\n        executorRegistry = addressProvider.getRegistry(_EXECUTOR_REGISTRY_HASH);\\n\\n        _notNull(walletRegistry);\\n        _notNull(policyRegistry);\\n        _notNull(executorRegistry);\\n    }\\n\\n    /**\\n     * @inheritdoc IAddressProviderService\\n     */\\n    function addressProviderTarget() external view override returns (address) {\\n        return address(addressProvider);\\n    }\\n\\n    /**\\n     * @notice Helper to get authorized address from address provider\\n     * @param _key keccak256 key corresponding to authorized address\\n     * @return authorizedAddress\\n     */\\n    function _getAuthorizedAddress(bytes32 _key) internal view returns (address authorizedAddress) {\\n        authorizedAddress = addressProvider.getAuthorizedAddress(_key);\\n        _notNull(authorizedAddress);\\n    }\\n\\n    /**\\n     * @notice Helper to revert if address is null\\n     * @param _addr address to check\\n     */\\n    function _notNull(address _addr) internal pure {\\n        if (_addr == address(0)) revert InvalidAddress();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/registries/WalletRegistry.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {AddressProviderService} from \\\"../AddressProviderService.sol\\\";\\n\\n/**\\n * @title WalletRegistry\\n * @author Brahma.fi\\n * @notice Registry for wallet and sub account addresses\\n */\\ncontract WalletRegistry is AddressProviderService {\\n    error AlreadyRegistered();\\n    error InvalidSender();\\n    error IsSubAccount();\\n\\n    event RegisterWallet(address indexed wallet);\\n    event RegisterSubAccount(address indexed wallet, address indexed subAccount);\\n\\n    /// @notice subAccount addresses mapped to owner wallet\\n    mapping(address subAccount => address wallet) public subAccountToWallet;\\n    /// @notice wallet addresses mapped to list of subAccounts\\n    mapping(address wallet => address[] subAccountList) public walletToSubAccountList;\\n    /// @notice address of wallet mapped to boolean indicating if it's a wallet\\n    mapping(address => bool) public isWallet;\\n\\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\\n\\n    /**\\n     * @notice Registers a wallet\\n     * @dev Can only be called by wallet to register itself\\n     */\\n    function registerWallet() external {\\n        if (isWallet[msg.sender]) revert AlreadyRegistered();\\n        if (subAccountToWallet[msg.sender] != address(0)) revert IsSubAccount();\\n        isWallet[msg.sender] = true;\\n        emit RegisterWallet(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Registers a sub account for a Safe\\n     * @param _wallet Console account address, owner of sub account\\n     * @param _subAccount Sub account address to register\\n     * @dev Can only be called by safe deployer\\n     */\\n\\n    function registerSubAccount(address _wallet, address _subAccount) external {\\n        if (msg.sender != AddressProviderService._getAuthorizedAddress(_SAFE_DEPLOYER_HASH)) revert InvalidSender();\\n\\n        if (subAccountToWallet[_subAccount] != address(0) || isWallet[_subAccount]) revert AlreadyRegistered();\\n\\n        subAccountToWallet[_subAccount] = _wallet;\\n        walletToSubAccountList[_wallet].push(_subAccount);\\n        emit RegisterSubAccount(_wallet, _subAccount);\\n    }\\n\\n    /**\\n     * @notice sub account list getter\\n     * @dev returns sub account list associated with _wallet\\n     * @param _wallet safe address\\n     * @return list of subAccounts for wallet\\n     */\\n    function getSubAccountsForWallet(address _wallet) external view returns (address[] memory) {\\n        return walletToSubAccountList[_wallet];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/registries/PolicyRegistry.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {AddressProviderService} from \\\"src/core/AddressProviderService.sol\\\";\\nimport {WalletRegistry} from \\\"src/core/registries/WalletRegistry.sol\\\";\\n\\n/**\\n * @title PolicyRegistry\\n * @author Brahma.fi\\n * @notice Registry for policy commits for wallets and sub accounts\\n */\\ncontract PolicyRegistry is AddressProviderService {\\n    error PolicyCommitInvalid();\\n    error UnauthorizedPolicyUpdate();\\n\\n    event UpdatedPolicyCommit(address indexed account, bytes32 policyCommit, bytes32 oldPolicyCommit);\\n\\n    /// @notice account addresses mapped to their policy commits\\n    mapping(address account => bytes32 policyCommit) public commitments;\\n\\n    constructor(address _addressProvider) AddressProviderService(_addressProvider) {}\\n\\n    /**\\n     * @notice Enables setting policy commits for accounts\\n     * @param account address of account to set policy commit for\\n     * @param policyCommit policy commit hash to set\\n     * @dev policyCommit for an account can be set by:\\n     *  1. by safe deployer, if the account is uninitialized\\n     *  2. by the registered wallet, if the account is a subAccount\\n     *  3. by the account itself, if account is a registered wallet\\n     */\\n    function updatePolicy(address account, bytes32 policyCommit) external {\\n        if (policyCommit == bytes32(0)) {\\n            revert PolicyCommitInvalid();\\n        }\\n\\n        bytes32 currentCommit = commitments[account];\\n\\n        // solhint-disable no-empty-blocks\\n        if (\\n            currentCommit == bytes32(0)\\n                && msg.sender == AddressProviderService._getAuthorizedAddress(_SAFE_DEPLOYER_HASH)\\n        ) {\\n            // In case invoker is safe  deployer\\n        } else {\\n            if (WalletRegistry(walletRegistry).subAccountToWallet(account) == msg.sender) {\\n                //In case invoker is updating on behalf of sub account\\n            } else if (msg.sender == account && WalletRegistry(walletRegistry).isWallet(msg.sender)) {\\n                // In case invoker is a registered wallet\\n            } else {\\n                revert UnauthorizedPolicyUpdate();\\n            }\\n        }\\n        // solhint-enable no-empty-blocks\\n        _updatePolicy(account, policyCommit, currentCommit);\\n    }\\n\\n    /**\\n     * @notice Internal function to update policy commit for an account\\n     * @param account address of account to set policy commit for\\n     * @param policyCommit policy commit hash to set\\n     */\\n    function _updatePolicy(address account, bytes32 policyCommit, bytes32 oldPolicyCommit) internal {\\n        emit UpdatedPolicyCommit(account, policyCommit, oldPolicyCommit);\\n        commitments[account] = policyCommit;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/external/ISafeProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface ISafeProxyFactory {\\n    event ProxyCreation(address proxy, address singleton);\\n\\n    function calculateCreateProxyWithNonceAddress(address _singleton, bytes memory initializer, uint256 saltNonce)\\n        external\\n        returns (address proxy);\\n\\n    function createProxy(address singleton, bytes memory data) external returns (address proxy);\\n\\n    function createProxyWithCallback(address _singleton, bytes memory initializer, uint256 saltNonce, address callback)\\n        external\\n        returns (address proxy);\\n\\n    function createProxyWithNonce(address _singleton, bytes memory initializer, uint256 saltNonce)\\n        external\\n        returns (address proxy);\\n\\n    function proxyCreationCode() external pure returns (bytes memory);\\n\\n    function proxyRuntimeCode() external pure returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"interfaces/external/ISafeWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.8.19;\\n\\nimport {IERC165} from \\\"openzeppelin-contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title Enum - Collection of enums\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\\ninterface ISafeWallet {\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(address to, uint256 value, bytes calldata data, Enum.Operation operation)\\n        external\\n        returns (bool success);\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModuleReturnData(address to, uint256 value, bytes memory data, Enum.Operation operation)\\n        external\\n        returns (bool success, bytes memory returnData);\\n    function getStorageAt(uint256 offset, uint256 length) external view returns (bytes memory);\\n    function isOwner(address owner) external view returns (bool);\\n    function nonce() external view returns (uint256);\\n    function getThreshold() external view returns (uint256);\\n    function isModuleEnabled(address module) external view returns (bool);\\n    function enableModule(address module) external;\\n    function disableModule(address prevModule, address module) external;\\n    function removeOwner(address prevOwner, address owner, uint256 _threshold) external;\\n    function swapOwner(address prevOwner, address oldOwner, address newOwner) external;\\n    function getOwners() external view returns (address[] memory);\\n    function approveHash(bytes32 hashToApprove) external;\\n    function signedMessages(bytes32 _dataHash) external returns (uint256 _signatures);\\n    function execTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes memory signatures\\n    ) external payable returns (bool);\\n\\n    function setup(\\n        address[] memory _owners,\\n        uint256 _threshold,\\n        address to,\\n        bytes memory data,\\n        address fallbackHandler,\\n        address paymentToken,\\n        uint256 payment,\\n        address paymentReceiver\\n    ) external;\\n\\n    function addOwnerWithThreshold(address owner, uint256 _threshold) external;\\n    function domainSeparator() external view returns (bytes32);\\n    function setFallbackHandler(address _fallbackHandler) external;\\n    function setGuard(address guard) external;\\n    function encodeTransactionData(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address refundReceiver,\\n        uint256 _nonce\\n    ) external view returns (bytes memory);\\n}\\n\\ninterface Guard is IERC165 {\\n    function checkTransaction(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes memory signatures,\\n        address msgSender\\n    ) external;\\n\\n    function checkAfterExecution(bytes32 txHash, bool success) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeHelper.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {Enum, ISafeWallet} from \\\"interfaces/external/ISafeWallet.sol\\\";\\nimport {Types} from \\\"interfaces/Types.sol\\\";\\n\\n/**\\n * @title SafeHelper\\n * @author Brahma.fi\\n * @notice Helper library containing functions to interact with safe wallet\\n */\\nlibrary SafeHelper {\\n    error InvalidMultiSendInput();\\n    error UnableToParseOperation();\\n\\n    /// @notice uint256(keccak256(\\\"guard_manager.guard.address\\\"))\\n    /// @dev This refers to the storage slot where guard is stored in Safe's layout: https://github.com/safe-global/safe-contracts/blob/ff4c6761fbfae8ab8a94f36fd26bcfb2b5414eb1/contracts/base/GuardManager.sol#L77\\n    uint256 internal constant _GUARD_STORAGE_SLOT =\\n        33528237782592280163068556224972516439282563014722366175641814928123294921928;\\n    /// @notice uint256(keccak256(\\\"fallback_manager.handler.address\\\"))\\n    /// @dev This refers to the storage slot where fallback handler is stored in Safe's layout: https://github.com/safe-global/safe-contracts/blob/ff4c6761fbfae8ab8a94f36fd26bcfb2b5414eb1/contracts/base/FallbackManager.sol#L14\\n    uint256 internal constant _FALLBACK_HANDLER_STORAGE_SLOT =\\n        49122629484629529244014240937346711770925847994644146912111677022347558721749;\\n\\n    /**\\n     * @notice Contains hash for expected overridable guard removal calldata\\n     * @dev This is the hash of the calldata for the following function call\\n     *\\n     * abi.encodeCall(ISafeWallet.setGuard, (address(0))) = 0xe19a9dd90000000000000000000000000000000000000000000000000000000000000000\\n     * keccak256(abi.encodeCall(ISafeWallet.setGuard, (address(0)))) = 0xc0e2c16ecb99419a40dd8b9c0b339b27acebd27c481a28cd606927aeb86f5079\\n     */\\n    bytes32 internal constant _GUARD_REMOVAL_CALLDATA_HASH =\\n        0xc0e2c16ecb99419a40dd8b9c0b339b27acebd27c481a28cd606927aeb86f5079;\\n\\n    /**\\n     * @notice Contains hash for expected overridable fallback handler removal calldata\\n     * @dev This is the hash of the calldata for the following function call\\n     *\\n     * abi.encodeCall(ISafeWallet.setFallbackHandler, (address(0))) = 0xf08a03230000000000000000000000000000000000000000000000000000000000000000\\n     * keccak256(abi.encodeCall(ISafeWallet.setFallbackHandler, (address(0)))) = 0x5bdf8c44c012c1347b2b15694dc5cc39b899eb99e32614676b7661001be925b7\\n     */\\n    bytes32 internal constant _FALLBACK_REMOVAL_CALLDATA_HASH =\\n        0x5bdf8c44c012c1347b2b15694dc5cc39b899eb99e32614676b7661001be925b7;\\n\\n    /**\\n     * @notice Packs multiple executables into a single bytes array compatible with Safe's MultiSend contract which can be used as argument for multicall method\\n     * @dev Reference contract at https://github.com/safe-global/safe-contracts/blob/main/contracts/libraries/MultiSend.sol\\n     * @param _txns Array of executables to pack\\n     * @return packedTxns bytes array containing packed transactions\\n     */\\n    function _packMultisendTxns(Types.Executable[] memory _txns) internal pure returns (bytes memory packedTxns) {\\n        uint256 len = _txns.length;\\n        if (len == 0) revert InvalidMultiSendInput();\\n\\n        uint256 i = 0;\\n        do {\\n            uint8 call = uint8(_parseOperationEnum(_txns[i].callType));\\n\\n            uint256 calldataLength = _txns[i].data.length;\\n\\n            bytes memory encodedTxn = abi.encodePacked(\\n                bytes1(call), bytes20(_txns[i].target), bytes32(_txns[i].value), bytes32(calldataLength), _txns[i].data\\n            );\\n\\n            if (i != 0) {\\n                // If not first transaction, append to packedTxns\\n                packedTxns = abi.encodePacked(packedTxns, encodedTxn);\\n            } else {\\n                // If first transaction, set packedTxns to encodedTxn\\n                packedTxns = encodedTxn;\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        } while (i < len);\\n    }\\n\\n    /**\\n     * @notice Gets the guard for a safe\\n     * @param safe address of safe\\n     * @return address of guard, address(0) if no guard exists\\n     */\\n    function _getGuard(address safe) internal view returns (address) {\\n        bytes memory guardAddress = ISafeWallet(safe).getStorageAt(_GUARD_STORAGE_SLOT, 1);\\n        return address(uint160(uint256(bytes32(guardAddress))));\\n    }\\n\\n    /**\\n     * @notice Gets the fallback handler for a safe\\n     * @param safe address of safe\\n     * @return address of fallback handler, address(0) if no fallback handler exists\\n     */\\n    function _getFallbackHandler(address safe) internal view returns (address) {\\n        bytes memory fallbackHandlerAddress = ISafeWallet(safe).getStorageAt(_FALLBACK_HANDLER_STORAGE_SLOT, 1);\\n        return address(uint160(uint256(bytes32(fallbackHandlerAddress))));\\n    }\\n\\n    /**\\n     * @notice Converts a CallType enum to an Operation enum.\\n     * @dev Reverts with UnableToParseOperation error if the CallType is not supported.\\n     * @param callType The CallType enum to be converted.\\n     * @return operation The converted Operation enum.\\n     */\\n    function _parseOperationEnum(Types.CallType callType) internal pure returns (Enum.Operation operation) {\\n        if (callType == Types.CallType.DELEGATECALL) {\\n            operation = Enum.Operation.DelegateCall;\\n        } else if (callType == Types.CallType.CALL) {\\n            operation = Enum.Operation.Call;\\n        } else {\\n            revert UnableToParseOperation();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/external/ISafeMultiSend.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface ISafeMultiSend {\\n    function multiSend(bytes memory transactions) external payable;\\n}\\n\"\r\n    },\r\n    \"interfaces/IAddressProviderService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\ninterface IAddressProviderService {\\n    /// @notice Returns the address of the AddressProvider\\n    function addressProviderTarget() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/core/AddressProvider.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\nimport {IAddressProviderService} from \\\"interfaces/IAddressProviderService.sol\\\";\\nimport {Constants} from \\\"src/core/Constants.sol\\\";\\n\\n/**\\n * @title AddressProvider\\n * @author Brahma.fi\\n * @notice Single source of truth for resolving addresses of core components and external contracts\\n */\\ncontract AddressProvider is Constants {\\n    error RegistryAlreadyExists();\\n    error AddressProviderUnsupported();\\n    error NotGovernance(address);\\n    error NotPendingGovernance(address);\\n    error NullAddress();\\n\\n    event RegistryInitialised(address indexed registry, bytes32 indexed key);\\n    event AuthorizedAddressInitialised(address indexed authorizedAddress, bytes32 indexed key);\\n    event GovernanceTransferRequested(address indexed previousGovernance, address indexed newGovernance);\\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    /// @notice address of governance\\n    address public governance;\\n    /// @notice address of pending governance before accepting\\n    address public pendingGovernance;\\n\\n    /**\\n     * @notice keccak256 hash of authorizedAddress keys mapped to their addresses\\n     * @dev Core & Roles are used as keys for this mapping. These addresses are mutable\\n     * @dev authorizedAddresses are updatable by governance\\n     */\\n    mapping(bytes32 => address) internal authorizedAddresses;\\n\\n    /**\\n     * @notice keccak256 hash of registry keys mapped to their addresses\\n     * @dev registries are only set once by governance and immutable\\n     */\\n    mapping(bytes32 => address) internal registries;\\n\\n    constructor(address _governance, address walletRegistry, address policyRegistry, address executorRegistry) {\\n        _notNull(_governance);\\n        governance = _governance;\\n\\n        _notNull(walletRegistry);\\n        _notNull(policyRegistry);\\n        _notNull(executorRegistry);\\n        registries[_WALLET_REGISTRY_HASH] = walletRegistry;\\n        registries[_POLICY_REGISTRY_HASH] = policyRegistry;\\n        registries[_EXECUTOR_REGISTRY_HASH] = executorRegistry;\\n    }\\n\\n    /**\\n     * @notice Governance setter\\n     * @param _newGovernance address of new governance\\n     */\\n    function setGovernance(address _newGovernance) external {\\n        _notNull(_newGovernance);\\n        _onlyGov();\\n        emit GovernanceTransferRequested(governance, _newGovernance);\\n        pendingGovernance = _newGovernance;\\n    }\\n\\n    /**\\n     * @notice Governance accepter\\n     */\\n    function acceptGovernance() external {\\n        if (msg.sender != pendingGovernance) {\\n            revert NotPendingGovernance(msg.sender);\\n        }\\n        emit GovernanceTransferred(governance, msg.sender);\\n        governance = msg.sender;\\n        delete pendingGovernance;\\n    }\\n\\n    /**\\n     * @notice Authorized address setter\\n     * @param _key key of authorizedAddress\\n     * @param _authorizedAddress address to set\\n     * @param _overrideCheck overrides check for supported address provider\\n     */\\n    function setAuthorizedAddress(bytes32 _key, address _authorizedAddress, bool _overrideCheck) external {\\n        _onlyGov();\\n        _notNull(_authorizedAddress);\\n\\n        /// @dev skips checks for supported `addressProvider()` if `_overrideCheck` is true\\n        if (!_overrideCheck) {\\n            /// @dev skips checks for supported `addressProvider()` if `_authorizedAddress` is an EOA\\n            if (_authorizedAddress.code.length != 0) _ensureAddressProvider(_authorizedAddress);\\n        }\\n\\n        authorizedAddresses[_key] = _authorizedAddress;\\n\\n        emit AuthorizedAddressInitialised(_authorizedAddress, _key);\\n    }\\n\\n    /**\\n     * @notice Registry address setter\\n     * @param _key key of registry address\\n     * @param _registry address to set\\n     */\\n    function setRegistry(bytes32 _key, address _registry) external {\\n        _onlyGov();\\n        _ensureAddressProvider(_registry);\\n\\n        if (registries[_key] != address(0)) revert RegistryAlreadyExists();\\n        registries[_key] = _registry;\\n\\n        emit RegistryInitialised(_registry, _key);\\n    }\\n\\n    /**\\n     * @notice Authorized address getter\\n     * @param _key key of authorized address\\n     * @return address of authorized address\\n     */\\n    function getAuthorizedAddress(bytes32 _key) external view returns (address) {\\n        return authorizedAddresses[_key];\\n    }\\n\\n    /**\\n     * @notice Registry address getter\\n     * @param _key key of registry address\\n     * @return address of registry address\\n     */\\n    function getRegistry(bytes32 _key) external view returns (address) {\\n        return registries[_key];\\n    }\\n\\n    /**\\n     * @notice Ensures that the new address supports the AddressProviderService interface\\n     * and is pointing to this AddressProvider\\n     * @param _newAddress address to check\\n     */\\n    function _ensureAddressProvider(address _newAddress) internal view {\\n        if (IAddressProviderService(_newAddress).addressProviderTarget() != address(this)) {\\n            revert AddressProviderUnsupported();\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if msg.sender is governance\\n     */\\n    function _onlyGov() internal view {\\n        if (msg.sender != governance) revert NotGovernance(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Checks and reverts if address is null\\n     * @param addr address to check if null\\n     */\\n    function _notNull(address addr) internal pure {\\n        if (addr == address(0)) revert NullAddress();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/core/Constants.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: BUSL-1.1\\n\\n/// Copyright (C) 2023 Brahma.fi\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @title Constants\\n * @author Brahma.fi\\n * @notice Contains constants used by multiple contracts\\n * @dev Inflates bytecode size by approximately 560 bytes on deployment, but saves gas on runtime\\n */\\nabstract contract Constants {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        REGISTRIES                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n    /// @notice Key to map address of ExecutorRegistry\\n    bytes32 internal constant _EXECUTOR_REGISTRY_HASH = bytes32(uint256(keccak256(\\\"console.core.ExecutorRegistry\\\")) - 1);\\n\\n    /// @notice Key to map address of WalletRegistry\\n    bytes32 internal constant _WALLET_REGISTRY_HASH = bytes32(uint256(keccak256(\\\"console.core.WalletRegistry\\\")) - 1);\\n\\n    /// @notice Key to map address of PolicyRegistry\\n    bytes32 internal constant _POLICY_REGISTRY_HASH = bytes32(uint256(keccak256(\\\"console.core.PolicyRegistry\\\")) - 1);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          CORE                              */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n    /// @notice Key to map address of ExecutorPlugin\\n    bytes32 internal constant _EXECUTOR_PLUGIN_HASH = bytes32(uint256(keccak256(\\\"console.core.ExecutorPlugin\\\")) - 1);\\n\\n    /// @notice Key to map address of ConsoleFallbackHandler\\n    bytes32 internal constant _CONSOLE_FALLBACK_HANDLER_HASH =\\n        bytes32(uint256(keccak256(\\\"console.core.FallbackHandler\\\")) - 1);\\n\\n    /// @notice Key to map address of Safe FallbackHandler\\n    bytes32 internal constant _SAFE_FALLBACK_HANDLER_HASH = bytes32(uint256(keccak256(\\\"safe.FallbackHandler\\\")) - 1);\\n\\n    /// @notice Key to map address of Safe MultiSend\\n    bytes32 internal constant _SAFE_MULTI_SEND_HASH = bytes32(uint256(keccak256(\\\"safe.MultiSend\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeProxyFactory\\n    bytes32 internal constant _SAFE_PROXY_FACTORY_HASH = bytes32(uint256(keccak256(\\\"safe.ProxyFactory\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeSingleton\\n    bytes32 internal constant _SAFE_SINGLETON_HASH = bytes32(uint256(keccak256(\\\"safe.Singleton\\\")) - 1);\\n\\n    /// @notice Key to map address of PolicyValidator\\n    bytes32 internal constant _POLICY_VALIDATOR_HASH = bytes32(uint256(keccak256(\\\"console.core.PolicyValidator\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeDeployer\\n    bytes32 internal constant _SAFE_DEPLOYER_HASH = bytes32(uint256(keccak256(\\\"console.core.SafeDeployer\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeEnabler\\n    bytes32 internal constant _SAFE_ENABLER_HASH = bytes32(uint256(keccak256(\\\"console.core.SafeEnabler\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeModerator\\n    bytes32 internal constant _SAFE_MODERATOR_HASH = bytes32(uint256(keccak256(\\\"console.core.SafeModerator\\\")) - 1);\\n\\n    /// @notice Key to map address of SafeModeratorOverridable\\n    bytes32 internal constant _SAFE_MODERATOR_OVERRIDABLE_HASH =\\n        bytes32(uint256(keccak256(\\\"console.core.SafeModeratorOverridable\\\")) - 1);\\n\\n    /// @notice Key to map address of TransactionValidator\\n    bytes32 internal constant _TRANSACTION_VALIDATOR_HASH =\\n        bytes32(uint256(keccak256(\\\"console.core.TransactionValidator\\\")) - 1);\\n\\n    /// @notice Key to map address of ConsoleOpBuilder\\n    bytes32 internal constant _CONSOLE_OP_BUILDER_HASH =\\n        bytes32(uint256(keccak256(\\\"console.core.ConsoleOpBuilder\\\")) - 1);\\n\\n    /// @notice Key to map address of ExecutionBlocker\\n    bytes32 internal constant _EXECUTION_BLOCKER_HASH = bytes32(uint256(keccak256(\\\"console.core.ExecutionBlocker\\\")) - 1);\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                          ROLES                             */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @notice Key to map address of Role PolicyAuthenticator\\n    bytes32 internal constant _POLICY_AUTHENTICATOR_HASH =\\n        bytes32(uint256(keccak256(\\\"console.roles.PolicyAuthenticator\\\")) - 1);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"interfaces/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\ninterface Types {\\n    enum CallType {\\n        CALL,\\n        DELEGATECALL,\\n        STATICCALL\\n    }\\n\\n    struct Executable {\\n        CallType callType;\\n        address target;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    struct TokenRequest {\\n        address token;\\n        uint256 amount;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"safe-contracts/=lib/safe-contracts/contracts/\",\r\n      \"solady/=lib/solady/src/\",\r\n      \"solmate/=lib/solady/lib/solmate/src/\",\r\n      \"solidity-bytes-utils/=lib/solidity-bytes-utils/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressProvider\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddressProvider\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCommitment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMultiSendInput\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NotGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotWallet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"PreComputedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeProxyCreationFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnableToParseOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consoleAddress\",\"type\":\"address\"}],\"name\":\"ConsoleAccountDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"PreComputeAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"singleton\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"initializer\",\"type\":\"bytes\"}],\"name\":\"SafeProxyCreationFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subAccountAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consoleAddress\",\"type\":\"address\"}],\"name\":\"SubAccountDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressProvider\",\"outputs\":[{\"internalType\":\"contract AddressProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressProviderTarget\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_policyCommit\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"deployConsoleAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_safe\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_policyCommit\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"deploySubAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_subAcc\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executorRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ownersHash\",\"type\":\"bytes32\"}],\"name\":\"ownerSafeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policyRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SafeDeployer", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "0000000000000000000000006fcf22e22f736d9ead75de8a1f12ca869287e229", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}