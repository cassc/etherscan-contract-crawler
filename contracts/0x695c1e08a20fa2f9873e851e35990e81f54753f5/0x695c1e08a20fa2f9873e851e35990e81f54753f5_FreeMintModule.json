{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/membership/modules/FreeMintModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {IERC721Mage} from \\\"mage/cores/ERC721/interface/IERC721Mage.sol\\\";\\nimport {IPermissions} from \\\"mage/access/permissions/interface/IPermissions.sol\\\";\\nimport {Operations} from \\\"mage/lib/Operations.sol\\\";\\n// module utils\\nimport {ModuleSetup} from \\\"src/lib/module/ModuleSetup.sol\\\";\\nimport {ModulePermit} from \\\"src/lib/module/ModulePermit.sol\\\";\\nimport {ModuleFee} from \\\"src/lib/module/ModuleFee.sol\\\";\\nimport {ContractMetadata} from \\\"src/lib/ContractMetadata.sol\\\";\\n\\n/// @title Station Network FreeMintModuleV3 Contract\\n/// @author symmetry (@symmtry69), frog (@0xmcg), \ud83d\udc66\ud83c\udffb\ud83d\udc66\ud83c\udffb.eth\\n/// @dev Provides a modular contract to handle collections who wish for their membership mints to be\\n/// free of charge, save for Station Network's base fee\\n\\ncontract FreeMintModule is ModuleSetup, ModulePermit, ModuleFee, ContractMetadata {\\n    /*=======================\\n        CONTRACT METADATA\\n    =======================*/\\n\\n    function _contractRoute() internal pure override returns (string memory route) {\\n        return \\\"module\\\";\\n    }\\n\\n    /*=============\\n        STORAGE\\n    =============*/\\n\\n    /// @dev collection => permits disabled, permits are enabled by default\\n    mapping(address => bool) internal _disablePermits;\\n\\n    /*============\\n        EVENTS\\n    ============*/\\n\\n    event SetUp(address indexed collection, bool indexed enablePermits);\\n\\n    /*============\\n        CONFIG\\n    ============*/\\n\\n    /// @param _newOwner The owner of the ModuleFeeV2, an address managed by Station Network\\n    /// @param _feeManager The FeeManager's address\\n    constructor(address _newOwner, address _feeManager, address metadataRouter)\\n        ModulePermit()\\n        ModuleFee(_newOwner, _feeManager)\\n        ContractMetadata(metadataRouter)\\n    {}\\n\\n    /// @dev Function to set up and configure a new collection\\n    /// @param collection The new collection to configure\\n    /// @param enablePermits A boolean to represent whether this collection will repeal or support grant functionality\\n    function setUp(address collection, bool enablePermits) public canSetUp(collection) {\\n        if (_disablePermits[collection] != !enablePermits) {\\n            _disablePermits[collection] = !enablePermits;\\n        }\\n        emit SetUp(collection, enablePermits);\\n    }\\n\\n    /// @dev convenience function for setting up when creating collections, relies on auth done in public setUp\\n    function setUp(bool enablePermits) external {\\n        setUp(msg.sender, enablePermits);\\n    }\\n\\n    /*==========\\n        MINT\\n    ==========*/\\n\\n    /// @dev Function to mint a single collection token to the caller, ie a user\\n    function mint(address collection) external payable {\\n        _batchMint(collection, msg.sender, 1);\\n    }\\n\\n    /// @dev Function to mint a single collection token to a specified recipient\\n    function mintTo(address collection, address recipient) external payable {\\n        _batchMint(collection, recipient, 1);\\n    }\\n\\n    /// @dev Function to mint collection tokens in batches to the caller, ie a user\\n    /// @notice returned tokenId range is inclusive\\n    function batchMint(address collection, uint256 amount) external payable {\\n        _batchMint(collection, msg.sender, amount);\\n    }\\n\\n    /// @dev Function to mint collection tokens in batches to a specified recipient\\n    /// @notice returned tokenId range is inclusive\\n    function batchMintTo(address collection, address recipient, uint256 amount) external payable {\\n        _batchMint(collection, recipient, amount);\\n    }\\n\\n    /*===============\\n        INTERNALS\\n    ===============*/\\n\\n    /// @dev Internal function to which all external user + client facing batchMint functions are routed.\\n    /// @param collection The token collection to mint from\\n    /// @param recipient The recipient of successfully minted tokens\\n    /// @param quantity The quantity of tokens to mint\\n    function _batchMint(address collection, address recipient, uint256 quantity)\\n        internal\\n        usePermits(_encodePermitContext(collection))\\n    {\\n        require(quantity > 0, \\\"ZERO_AMOUNT\\\");\\n\\n        // calculate fee, require fee sent to this contract, transfer collection's revenue to payoutAddress\\n        // however there is no payoutAddress, payment token is network token\\n        _collectFeeAndForwardCollectionRevenue(collection, address(0), address(0), recipient, quantity, 0);\\n\\n        // mint NFTs\\n        IERC721Mage(collection).mintTo(recipient, quantity);\\n    }\\n\\n    /*=============\\n        PERMITS\\n    =============*/\\n\\n    function _encodePermitContext(address collection) internal pure returns (bytes memory context) {\\n        return abi.encode(collection);\\n    }\\n\\n    function _decodePermitContext(bytes memory context) internal pure returns (address collection) {\\n        return abi.decode(context, (address));\\n    }\\n\\n    function signerCanPermit(address signer, bytes memory context) public view override returns (bool) {\\n        address collection = _decodePermitContext(context);\\n        return IPermissions(collection).hasPermission(Operations.MINT_PERMIT, signer);\\n    }\\n\\n    function requirePermits(bytes memory context) public view override returns (bool) {\\n        address collection = _decodePermitContext(context);\\n        return !_disablePermits[collection];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/mage/src/cores/ERC721/interface/IERC721Mage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\n/// @notice using the consistent Access layer, expose external functions for interacting with core token logic\\ninterface IERC721Mage {\\n    error CannotInitializeWhileConstructing();\\n\\n    function mintTo(address recipient, uint256 quantity) external;\\n    function burn(uint256 tokenId) external;\\n    function initialize(address owner, string calldata name, string calldata symbol, bytes calldata initData)\\n        external;\\n}\\n\"\r\n    },\r\n    \"lib/mage/src/access/permissions/interface/IPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {PermissionsStorage} from \\\"../PermissionsStorage.sol\\\";\\n\\ninterface IPermissionsInternal {\\n    struct Permission {\\n        bytes8 operation;\\n        address account;\\n        uint40 updatedAt;\\n    }\\n\\n    // events\\n    event PermissionAdded(bytes8 indexed operation, address indexed account);\\n    event PermissionRemoved(bytes8 indexed operation, address indexed account);\\n\\n    // errors\\n    error PermissionAlreadyExists(bytes8 operation, address account);\\n    error PermissionDoesNotExist(bytes8 operation, address account);\\n}\\n\\n/// @notice Since the Solidity compiler ignores inherited functions, function declarations are made\\n/// at the top level so their selectors are properly XORed into a nonzero `interfaceId`\\ninterface IPermissions is IPermissionsInternal {\\n    // IPermissionsInternal views\\n    function hashOperation(string memory name) external view returns (bytes8);\\n    function hasPermission(bytes8 operation, address account) external view returns (bool);\\n    function getAllPermissions() external view returns (Permission[] memory permissions);\\n    // external setters\\n    function addPermission(bytes8 operation, address account) external;\\n    function removePermission(bytes8 operation, address account) external;\\n}\\n\"\r\n    },\r\n    \"lib/mage/src/lib/Operations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nlibrary Operations {\\n    bytes8 constant ADMIN = 0xfd45ddde6135ec42; // hashOperation(\\\"ADMIN\\\");\\n    bytes8 constant MINT = 0x38381131ea27ecba; // hashOperation(\\\"MINT\\\");\\n    bytes8 constant BURN = 0xf951edb3fd4a16a3; // hashOperation(\\\"BURN\\\");\\n    bytes8 constant TRANSFER = 0x5cc15eb80ba37777; // hashOperation(\\\"TRANSFER\\\");\\n    bytes8 constant METADATA = 0x0e5de49ee56c0bd3; // hashOperation(\\\"METADATA\\\");\\n    bytes8 constant PERMISSIONS = 0x96bbcfa480f6f1a8; // hashOperation(\\\"PERMISSIONS\\\");\\n    bytes8 constant GUARDS = 0x53cbed5bdabf52cc; // hashOperation(\\\"GUARDS\\\");\\n    bytes8 constant EXECUTE = 0xf01aff3887dcbbc6; // hashOperation(\\\"EXECUTE\\\");\\n    bytes8 constant INTERFACE = 0x4a9bf2931aa5eae4; // hashOperation(\\\"INTERFACE\\\");\\n\\n    // TODO: deprecate and find another way versus anti-pattern\\n    // permits are enabling the permission, but only through set up modules/extension logic\\n    // e.g. someone can approve new members to mint, but cannot circumvent the module for taking payment\\n    bytes8 constant MINT_PERMIT = 0x0b6c53f325d325d3; // hashOperation(\\\"MINT_PERMIT\\\");\\n    bytes8 constant BURN_PERMIT = 0x6801400fea7cd7c7; // hashOperation(\\\"BURN_PERMIT\\\");\\n    bytes8 constant TRANSFER_PERMIT = 0xa994951607abf93b; // hashOperation(\\\"TRANSFER_PERMIT\\\");\\n    bytes8 constant EXECUTE_PERMIT = 0x6c9e9b56de5e9f1c; // hashOperation(\\\"EXECUTE_PERMIT\\\");\\n\\n    function nameOperation(bytes8 operation) public pure returns (string memory name) {\\n        if (operation == ADMIN) {\\n            return \\\"ADMIN\\\";\\n        } else if (operation == MINT) {\\n            return \\\"MINT\\\";\\n        } else if (operation == BURN) {\\n            return \\\"BURN\\\";\\n        } else if (operation == TRANSFER) {\\n            return \\\"TRANSFER\\\";\\n        } else if (operation == METADATA) {\\n            return \\\"METADATA\\\";\\n        } else if (operation == PERMISSIONS) {\\n            return \\\"PERMISSIONS\\\";\\n        } else if (operation == GUARDS) {\\n            return \\\"GUARDS\\\";\\n        } else if (operation == EXECUTE) {\\n            return \\\"EXECUTE\\\";\\n        } else if (operation == INTERFACE) {\\n            return \\\"INTERFACE\\\";\\n        } else if (operation == MINT_PERMIT) {\\n            return \\\"MINT_PERMIT\\\";\\n        } else if (operation == BURN_PERMIT) {\\n            return \\\"BURN_PERMIT\\\";\\n        } else if (operation == TRANSFER_PERMIT) {\\n            return \\\"TRANSFER_PERMIT\\\";\\n        } else if (operation == EXECUTE_PERMIT) {\\n            return \\\"EXECUTE_PERMIT\\\";\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/module/ModuleSetup.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {IPermissions} from \\\"mage/access/permissions/interface/IPermissions.sol\\\";\\nimport {Operations} from \\\"mage/lib/Operations.sol\\\";\\n\\ncontract ModuleSetup {\\n    error SetUpUnauthorized(address collection, address account);\\n\\n    modifier canSetUp(address collection) {\\n        if (collection != msg.sender && !IPermissions(collection).hasPermission(Operations.ADMIN, msg.sender)) {\\n            revert SetUpUnauthorized(collection, msg.sender);\\n        }\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/module/ModulePermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {SignatureChecker, ECDSA} from \\\"openzeppelin-contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport {Address} from \\\"openzeppelin-contracts/utils/Address.sol\\\";\\n\\nimport {NonceBitMap} from \\\"src/lib/NonceBitMap.sol\\\";\\n\\nabstract contract ModulePermit is NonceBitMap {\\n    struct Permit {\\n        address signer; // take signer as explicit argument to support smart contract signers with EIP1271\\n        address sender;\\n        uint48 expiration;\\n        uint256 nonce;\\n        bytes data;\\n        bytes signature;\\n    }\\n\\n    /*============\\n        ERRORS\\n    ============*/\\n\\n    error Reentrancy();\\n    error PermitSignerInvalid(address signer);\\n    error PermitExpired(uint48 expiration, uint48 current);\\n    error PermitSenderMismatch(address expected, address sender);\\n    error PermitInvalidSignature(address signer, bytes32 permitHash, bytes signature);\\n    error PermitCallFailed(bytes data);\\n    error PermitCallUnprotected();\\n\\n    /*=============\\n        STORAGE\\n    =============*/\\n\\n    // signatures\\n    bytes32 private constant GRANT_TYPE_HASH =\\n        keccak256(\\\"Permit(address sender,uint48 expiration,uint256 nonce,bytes data)\\\");\\n    bytes32 private constant DOMAIN_TYPE_HASH =\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n    bytes32 private constant NAME_HASH = keccak256(\\\"GroupOS\\\");\\n    bytes32 private constant VERSION_HASH = keccak256(\\\"0.0.1\\\");\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    // authentication handoff\\n    address private constant UNVERIFIED = address(1);\\n    uint256 private constant UNLOCKED = 1;\\n    uint256 private constant LOCKED = 2;\\n    address private verifiedSigner = UNVERIFIED;\\n    uint256 private lock = UNLOCKED;\\n\\n    constructor() {\\n        INITIAL_DOMAIN_SEPARATOR = _domainSeparator();\\n        INITIAL_CHAIN_ID = block.chainid;\\n    }\\n\\n    /*====================\\n        CORE UTILITIES\\n    ====================*/\\n\\n    /// @notice authenticate module functions for collections with permits and reentrancy protection\\n    modifier usePermits(bytes memory context) {\\n        address signer = verifiedSigner;\\n        // validate permits are required, signer is verified, and signer can permit\\n        if (requirePermits(context) && (signer == UNVERIFIED || !signerCanPermit(signer, context))) {\\n            revert PermitSignerInvalid(signer);\\n        }\\n        // reentrancy protection\\n        if (lock != UNLOCKED) revert Reentrancy();\\n        // lock\\n        lock = LOCKED;\\n        // function execution\\n        _;\\n        // unlock\\n        lock = UNLOCKED;\\n    }\\n\\n    /// @notice authenticate permit and make a self-call\\n    /// @dev can only be used on functions that are protected with onlyPermited\\n    function callWithPermit(Permit calldata permit) external payable {\\n        if (permit.expiration < block.timestamp) revert PermitExpired(permit.expiration, uint48(block.timestamp));\\n        if (permit.sender != address(0) && permit.sender != msg.sender) {\\n            revert PermitSenderMismatch(permit.sender, msg.sender);\\n        }\\n        // use nonce, reverts if already used\\n        _useNonce(permit.signer, permit.nonce);\\n        // verify signer, reverts if invalid\\n        _verifySigner(permit);\\n        // set signer as verified state to be used in \\\"real\\\" call\\n        verifiedSigner = permit.signer;\\n        // make authenticated call\\n        Address.functionDelegateCall(address(this), permit.data);\\n        // reset verified signer\\n        verifiedSigner = UNVERIFIED;\\n    }\\n\\n    /// @notice override to customize which signers are allowed\\n    function signerCanPermit(address, bytes memory) public view virtual returns (bool) {\\n        return false;\\n    }\\n\\n    /// @notice override to support disabling permits\\n    function requirePermits(bytes memory) public view virtual returns (bool) {\\n        return true;\\n    }\\n\\n    /*=====================\\n        PRIVATE HELPERS\\n    =====================*/\\n\\n    /// @notice Verify the signer, signature, and data align and revert otherwise\\n    function _verifySigner(Permit memory permit) private view {\\n        // hash permit values\\n        bytes32 valuesHash = keccak256(\\n            abi.encode(\\n                GRANT_TYPE_HASH,\\n                permit.sender,\\n                permit.expiration,\\n                permit.nonce,\\n                // per EIP712 spec, need to hash variable length data to 32-bytes value first\\n                keccak256(permit.data)\\n            )\\n        );\\n        // hash domain with permit values\\n        bytes32 permitHash = ECDSA.toTypedDataHash(\\n            INITIAL_CHAIN_ID == block.chainid ? INITIAL_DOMAIN_SEPARATOR : _domainSeparator(), valuesHash\\n        );\\n        // verify signer, revert if invalid\\n        if (!SignatureChecker.isValidSignatureNow(permit.signer, permitHash, permit.signature)) {\\n            revert PermitInvalidSignature(permit.signer, permitHash, permit.signature);\\n        }\\n    }\\n\\n    function _domainSeparator() private view returns (bytes32) {\\n        return keccak256(abi.encode(DOMAIN_TYPE_HASH, NAME_HASH, VERSION_HASH, block.chainid, address(this)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/module/ModuleFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {SafeERC20} from \\\"openzeppelin-contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {Ownable} from \\\"openzeppelin-contracts/access/Ownable.sol\\\";\\nimport {IERC20Metadata} from \\\"openzeppelin-contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport {FeeManager} from \\\"./FeeManager.sol\\\";\\n\\n/// @title Station Network Fee Manager Contract\\n/// @author symmetry (@symmtry69), frog (@0xmcg), \ud83d\udc66\ud83c\udffb\ud83d\udc66\ud83c\udffb.eth\\n\\n/// @dev This contract enables payment by handling funds when charging base and variable fees on each Membership's mints\\n\\n/// @notice ModuleFeeV2 differs from ModuleFee in that it is intended to be inherited by all purchase modules\\n/// The goal is to abstract all payment logic so this module can handle fees for every client's desired Membership implementation\\n\\nabstract contract ModuleFee is Ownable {\\n    // using SafeERC20 for covering USDT no-return and other transfer issues\\n    using SafeERC20 for IERC20Metadata;\\n\\n    /*============\\n        ERRORS\\n    ============*/\\n\\n    error InvalidFee(uint256 expected, uint256 received);\\n\\n    /*============\\n        EVENTS\\n    ============*/\\n\\n    event FeePaid(\\n        address indexed collection,\\n        address indexed buyer,\\n        address indexed paymentToken,\\n        uint256 unitPrice,\\n        uint256 quantity,\\n        uint256 totalFee\\n    );\\n    event FeeWithdrawn(address indexed recipient, address indexed token, uint256 amount);\\n    event FeeManagerUpdated(address indexed oldFeeManager, address indexed newFeeManager);\\n\\n    /*=============\\n        STORAGE\\n    =============*/\\n\\n    /// @dev Address of the deployed FeeManager contract which stores state for all collections' fee information\\n    /// @dev The FeeManager serves a Singleton role as central fee ledger for modules to read from\\n    address internal feeManager;\\n\\n    /*==============\\n        SETTINGS\\n    ==============*/\\n\\n    /// @param _newOwner The initialization of the contract's owner address, managed by Station\\n    /// @param _feeManager This chain's address for the FeeManager, Station's central fee management ledger\\n    constructor(address _newOwner, address _feeManager) {\\n        _transferOwnership(_newOwner);\\n        feeManager = _feeManager;\\n    }\\n\\n    /// @dev Function to set a new FeeManager\\n    /// @param newFeeManager The new FeeManager address to write to storage\\n    function setNewFeeManager(address newFeeManager) external onlyOwner {\\n        require(newFeeManager != address(0) && newFeeManager != feeManager, \\\"INVALID_FEE_MANAGER\\\");\\n        emit FeeManagerUpdated(feeManager, newFeeManager);\\n        feeManager = newFeeManager;\\n    }\\n\\n    /*==============\\n        WITHDRAW\\n    ==============*/\\n\\n    /// @dev Function to withdraw the total balances of accrued base and variable eth fees collected from mints\\n    /// @dev Sends fees to the module's owner address, which is managed by Station Network\\n    /// @dev Access control enforced for tax implications\\n    /// @param paymentTokens The token addresses to call, where address(0) represent network token\\n    function withdrawFees(address[] calldata paymentTokens) external onlyOwner {\\n        address recipient = owner();\\n        for (uint256 i; i < paymentTokens.length; i++) {\\n            uint256 amount;\\n            if (paymentTokens[i] == address(0)) {\\n                amount = address(this).balance;\\n                (bool success,) = payable(recipient).call{value: amount}(\\\"\\\");\\n                require(success);\\n            } else {\\n                amount = IERC20Metadata(paymentTokens[i]).balanceOf(address(this));\\n                IERC20Metadata(paymentTokens[i]).transfer(recipient, amount);\\n            }\\n            emit FeeWithdrawn(recipient, paymentTokens[i], amount);\\n        }\\n    }\\n\\n    /*=============\\n        COLLECT\\n    =============*/\\n\\n    /// @dev Function to collect fees for owner and collection in both network token and ERC20s\\n    /// @dev Called only by child contracts inheriting this one\\n    /// @param collection The token collection to mint from\\n    /// @param payoutAddress The address to send payment for the collection\\n    /// @param paymentToken The token address being used for payment\\n    /// @param recipient The recipient of successfully minted tokens\\n    /// @param quantity The number of items being minted, used to calculate the total fee payment required\\n    /// @param unitPrice The price per token to mint\\n    function _collectFeeAndForwardCollectionRevenue(\\n        address collection,\\n        address payoutAddress,\\n        address paymentToken,\\n        address recipient,\\n        uint256 quantity,\\n        uint256 unitPrice\\n    ) internal returns (uint256 paidFee) {\\n        // feeTotal is handled as either ETH or ERC20 stablecoin payment accordingly by FeeManager\\n        paidFee = FeeManager(feeManager).getFeeTotals(collection, paymentToken, recipient, quantity, unitPrice);\\n        uint256 total = quantity * unitPrice + paidFee;\\n\\n        // for ETH context, accept funds only if the msg.value sent matches the FeeManager's calculation\\n        if (paymentToken == address(0x0)) {\\n            // collect fees\\n            if (msg.value != total) revert InvalidFee(total, msg.value);\\n            // forward revenue to payoutAddress\\n            (bool success,) = payoutAddress.call{value: quantity * unitPrice}(\\\"\\\");\\n            require(success, \\\"PAYMENT_FAIL\\\");\\n        } else {\\n            // collect fees\\n            // transfer total to this contract first to update ERC20 approval storage once\\n            // approval must have been made prior to top-level mint call\\n            IERC20Metadata(paymentToken).safeTransferFrom(msg.sender, address(this), total);\\n            // forward revenue to payoutAddress\\n            IERC20Metadata(paymentToken).safeTransfer(payoutAddress, quantity * unitPrice);\\n        }\\n\\n        // emit event for accounting\\n        emit FeePaid(collection, recipient, paymentToken, unitPrice, quantity, paidFee);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/ContractMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {IMetadataRouter} from \\\"../metadataRouter/IMetadataRouter.sol\\\";\\n\\ncontract ContractMetadata {\\n    address public immutable metadataRouter;\\n\\n    constructor(address router) {\\n        metadataRouter = router;\\n    }\\n\\n    function contractURI() public view virtual returns (string memory uri) {\\n        return IMetadataRouter(metadataRouter).uriOf(_contractRoute(), address(this));\\n    }\\n\\n    function _contractRoute() internal pure virtual returns (string memory route) {\\n        return \\\"contract\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/mage/src/access/permissions/PermissionsStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.8;\\n\\nlibrary PermissionsStorage {\\n    bytes32 internal constant SLOT = keccak256(abi.encode(uint256(keccak256(\\\"mage.Permissions\\\")) - 1));\\n\\n    struct Layout {\\n        uint256[] _permissionKeys;\\n        mapping(uint256 => PermissionData) _permissions;\\n    }\\n\\n    struct PermissionData {\\n        uint24 index; //              [0..23]\\n        uint40 updatedAt; //          [24..63]\\n        bool exists; //              [64-71]\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function _packKey(bytes8 operation, address account) internal pure returns (uint256) {\\n        // `operation` cast to uint64 to keep it on the small Endian side, packed with account to its left; leftmost 4 bytes remain empty\\n        return (uint256(uint64(operation)) | uint256(uint160(account)) << 64);\\n    }\\n\\n    function _unpackKey(uint256 key) internal pure returns (bytes8 operation, address account) {\\n        operation = bytes8(uint64(key));\\n        account = address(uint160(key >> 64));\\n        return (operation, account);\\n    }\\n\\n    function _hashOperation(string memory name) internal pure returns (bytes8) {\\n        return bytes8(keccak256(abi.encodePacked(name)));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../Address.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\\n            return true;\\n        }\\n\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length == 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/NonceBitMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.16;\\n\\n/// @notice Utility for making address-keyed nonce bitmaps for parallelized signature replay protection\\nabstract contract NonceBitMap {\\n    /*=============\\n        STORAGE\\n    =============*/\\n\\n    // account => bitmap for tracking nonces, bitmaps used for gas efficient parallel processing\\n    mapping(address => mapping(uint256 => uint256)) internal _usedNonces;\\n\\n    /*============\\n        EVENTS\\n    ============*/\\n\\n    event NonceUsed(address indexed account, uint256 indexed nonce);\\n\\n    /*===========\\n        ERROS\\n    ===========*/\\n\\n    error NonceAlreadyUsed(address account, uint256 nonce);\\n\\n    /*==================\\n        VERIFICATION\\n    ==================*/\\n\\n    function isNonceUsed(address account, uint256 nonce) public view returns (bool) {\\n        (, uint256 word, uint256 mask) = _split(account, nonce);\\n        return word & mask != 0;\\n    }\\n\\n    function _useNonce(address account, uint256 nonce) internal {\\n        (uint256 wordId, uint256 word, uint256 mask) = _split(account, nonce);\\n        if (word & mask != 0) revert NonceAlreadyUsed(account, nonce);\\n        _usedNonces[account][wordId] = word | mask;\\n        emit NonceUsed(account, nonce);\\n    }\\n\\n    function _split(address account, uint256 nonce) private view returns (uint256 wordId, uint256 word, uint256 mask) {\\n        wordId = nonce >> 8;\\n        mask = 1 << (nonce & 0xff);\\n        word = _usedNonces[account][wordId];\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/module/FeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport {Ownable} from \\\"openzeppelin-contracts/access/Ownable.sol\\\";\\n\\n/// @title Station Network Fee Manager Contract\\n/// @author \ud83d\udc66\ud83c\udffb\ud83d\udc66\ud83c\udffb.eth\\n\\n/// @dev This contract stores state for all fees set on both a one-size fits all default basis and per-collection basis\\n/// Handles fee calculations when called by modules inquiring about the total fees involved in a mint, including ERC20 support and Station discounts\\n\\ncontract FeeManager is Ownable {\\n    /// @dev Struct of fee data, including FeeSetting enum and both base and variable fees, all packed into 1 slot\\n    /// Since `type(uint120).max` ~= 1.3e36, it suffices for fees of up to 1.3e18 ETH or ERC20 tokens, far beyond realistic scenarios.\\n    /// @param exist boolean indicating whether the fee values exist\\n    /// @param baseFee The flat fee charged by Station Network on a per item basis\\n    /// @param variableFee The variable fee (in BPS) charged by Station Network on volume basis\\n    /// Accounts for each item's cost and total amount of items\\n    struct Fees {\\n        bool exist;\\n        uint120 baseFee;\\n        uint120 variableFee;\\n    }\\n\\n    /*============\\n        ERRORS\\n    ============*/\\n\\n    error FeesNotSet();\\n\\n    /*============\\n        EVENTS\\n    ============*/\\n\\n    event DefaultFeesUpdated(Fees fees);\\n    event TokenFeesUpdated(address indexed token, Fees fees);\\n    event CollectionFeesUpdated(address indexed collection, address indexed token, Fees fees);\\n\\n    /*=============\\n        STORAGE\\n    =============*/\\n\\n    /// @dev Denominator used to calculate variable fee on a BPS basis\\n    /// @dev Not actually kept in storage as it is marked `constant`, saving gas by putting its value in contract bytecode instead\\n    uint256 private constant bpsDenominator = 10_000;\\n\\n    /// @dev Baseline fee struct that serves as a stand in for all token addresses that have been registered\\n    /// in a stablecoin purchase module but not had their default fees set\\n    Fees internal defaultFees;\\n\\n    /// @dev Mapping that stores default fees associated with a given token address\\n    mapping(address => Fees) internal tokenFees;\\n\\n    /// @dev Mapping that stores override fees associated with specific collections, i.e. for discounts\\n    mapping(address => mapping(address => Fees)) internal collectionFees;\\n\\n    /*================\\n        FEEMANAGER\\n    ================*/\\n\\n    /// @notice Constructor will be deprecated in favor of an initialize() UUPS proxy call once logic is finalized & approved\\n    /// @param _newOwner The initialization of the contract's owner address, managed by Station\\n    /// @param _defaultBaseFee The initialization of default baseFees for all token addresses that have not (yet) been given defaults\\n    /// @param _defaultVariableFee The initialization of default variableFees for all token addresses that have not (yet) been given defaults\\n    /// @param _networkTokenBaseFee The initialization of default baseFees for the network's token\\n    /// @param _networkTokenVariableFee The initialization of default variableFees for the network's token\\n    constructor(\\n        address _newOwner,\\n        uint120 _defaultBaseFee,\\n        uint120 _defaultVariableFee,\\n        uint120 _networkTokenBaseFee,\\n        uint120 _networkTokenVariableFee\\n    ) {\\n        Fees memory _defaultFees = Fees(true, _defaultBaseFee, _defaultVariableFee);\\n        defaultFees = _defaultFees;\\n        emit DefaultFeesUpdated(_defaultFees);\\n\\n        Fees memory _networkTokenFees = Fees(true, _networkTokenBaseFee, _networkTokenVariableFee);\\n        tokenFees[address(0x0)] = _networkTokenFees;\\n        emit TokenFeesUpdated(address(0x0), _networkTokenFees);\\n\\n        _transferOwnership(_newOwner);\\n    }\\n\\n    /// @dev Function to set baseline base and variable fees across all collections without specified defaults\\n    /// @dev Only callable by contract owner, an address managed by Station\\n    /// @param baseFee The new baseFee to apply as default\\n    /// @param variableFee The new variableFee to apply as default\\n    function setDefaultFees(uint120 baseFee, uint120 variableFee) external onlyOwner {\\n        Fees memory fees = Fees(true, baseFee, variableFee);\\n        defaultFees = fees;\\n        emit DefaultFeesUpdated(fees);\\n    }\\n\\n    /// @dev Function to set base and variable fees for a specific token\\n    /// @dev Only callable by contract owner, an address managed by Station\\n    /// @param token The token for which to set new base and variable fees\\n    /// @param baseFee The new baseFee to apply to the token\\n    /// @param variableFee The new variableFee to apply to the token\\n    function setTokenFees(address token, uint120 baseFee, uint120 variableFee) external onlyOwner {\\n        Fees memory fees = Fees(true, baseFee, variableFee);\\n        tokenFees[token] = fees;\\n        emit TokenFeesUpdated(token, fees);\\n    }\\n\\n    /// @dev Function to remove base and variable fees for a specific token\\n    /// @dev Only callable by contract owner, an address managed by Station\\n    /// @param token The token for which to remove fees\\n    function removeTokenFees(address token) external onlyOwner {\\n        Fees memory fees = Fees(false, 0, 0);\\n        tokenFees[token] = fees;\\n        emit TokenFeesUpdated(token, fees);\\n    }\\n\\n    /// @dev Function to set override base and variable fees on a per-collection basis\\n    /// @param collection The collection for which to set override fees\\n    /// @param token The token for which to set new base and variable fees\\n    /// @param baseFee The new baseFee to apply to the collection and token\\n    /// @param variableFee The new variableFee to apply to the collection and token\\n    function setCollectionFees(address collection, address token, uint120 baseFee, uint120 variableFee)\\n        external\\n        onlyOwner\\n    {\\n        Fees memory fees = Fees(true, baseFee, variableFee);\\n        collectionFees[collection][token] = fees;\\n        emit CollectionFeesUpdated(collection, token, fees);\\n    }\\n\\n    /// @dev Function to remove base and variable fees for a specific token\\n    /// @dev Only callable by contract owner, an address managed by Station\\n    /// @param collection The collection for which to remove fees\\n    /// @param token The token for which to remove fees\\n    function removeCollectionFees(address collection, address token) external onlyOwner {\\n        Fees memory fees = Fees(false, 0, 0);\\n        tokenFees[token] = fees;\\n        emit CollectionFeesUpdated(collection, token, fees);\\n    }\\n\\n    /*============\\n        VIEWS\\n    ============*/\\n\\n    /// @dev Function to get collection fees\\n    /// @param collection The collection whose fees will be read, including checks for client-specific fee discounts\\n    /// @param paymentToken The ERC20 token address used to pay fees. Will use base currency (ETH, MATIC, etc) when == address(0)\\n    /// @param recipient The address to mint to. Checked to apply discounts per user for Station Network incentives\\n    /// @param quantity The amount of tokens for which to compute total baseFee\\n    /// @param unitPrice The price of each token, used to compute subtotal on which to apply variableFee\\n    /// @param feeTotal The returned total incl fees for the given collection.\\n    function getFeeTotals(\\n        address collection,\\n        address paymentToken,\\n        address recipient,\\n        uint256 quantity,\\n        uint256 unitPrice\\n    ) external view returns (uint256 feeTotal) {\\n        // todo support recipient discounts for individual users holding a collection NFT\\n\\n        // get existing fees, first checking for override fees or discounts if they have already been set\\n        Fees memory fees = getFees(collection, paymentToken);\\n\\n        // if being called in free mint context results in only base fee\\n        (uint256 baseFeeTotal, uint256 variableFeeTotal) =\\n            calculateFees(fees.baseFee, fees.variableFee, quantity, unitPrice);\\n        return baseFeeTotal + variableFeeTotal;\\n    }\\n\\n    /// @dev Function to get baseline fees for all tokens\\n    function getDefaultFees() public view returns (Fees memory fees) {\\n        fees = defaultFees;\\n    }\\n\\n    /// @dev Function to get default fees for a token if they have been set\\n    /// @param token The token address to query against tokenFees mapping\\n    function getTokenFees(address token) public view returns (Fees memory fees) {\\n        fees = tokenFees[token];\\n        if (!fees.exist) revert FeesNotSet();\\n    }\\n\\n    /// @dev Function to get override fees for a collection and token if they have been set\\n    /// @param collection The collection address to query against collectionFees mapping\\n    /// @param token The token address to query against collectionFees mapping\\n    function getCollectionFees(address collection, address token) public view returns (Fees memory fees) {\\n        fees = collectionFees[collection][token];\\n        if (!fees.exist) revert FeesNotSet();\\n    }\\n\\n    /// @dev Function to evaluate whether override fees have been set for a specific collection\\n    /// and whether default fees have been set for the given token\\n    function getFees(address _collection, address _token) public view returns (Fees memory fees) {\\n        // if collectionFees exist, return overrides\\n        Fees memory collectionOverrides = collectionFees[_collection][_token];\\n        if (collectionOverrides.exist) {\\n            return collectionOverrides;\\n        }\\n        // if tokenFees exist, return overrides\\n        Fees memory tokenOverrides = tokenFees[_token];\\n        if (tokenOverrides.exist) {\\n            return tokenOverrides;\\n        }\\n        // no overrides set, return defaults\\n        return defaultFees;\\n    }\\n\\n    /// @dev Function to calculate fees using base and variable fee structures, agnostic to ETH or ERC20 values\\n    /// @param baseFee The base fee denominated either in ETH or ERC20 tokens\\n    /// @param variableFee The variable fee denominated either in ETH or ERC20 tokens\\n    /// @param quantity The number of tokens being minted\\n    /// @param unitPrice The price per unit of tokens being minted\\n    function calculateFees(uint256 baseFee, uint256 variableFee, uint256 quantity, uint256 unitPrice)\\n        public\\n        pure\\n        returns (uint256 baseFeeTotal, uint256 variableFeeTotal)\\n    {\\n        // calculate baseFee total (quantity * unitPrice), set to baseFee\\n        baseFeeTotal = quantity * baseFee;\\n        // apply variable fee on baseFee total, set to variableFee\\n        variableFeeTotal = unitPrice * quantity * variableFee / bpsDenominator;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/metadataRouter/IMetadataRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\ninterface IMetadataRouter {\\n    // events\\n    event DefaultURIUpdated(string uri);\\n    event RouteURIUpdated(string route, string uri);\\n    event ContractRouteURIUpdated(string route, string uri, address indexed contractAddress);\\n\\n    // views\\n    function baseURI(string memory route, address contractAddress) external view returns (string memory);\\n    function defaultURI() external view returns (string memory);\\n    function routeURI(string memory route) external view returns (string memory);\\n    function contractRouteURI(string memory route, address contractAddress) external view returns (string memory);\\n    function uriOf(string memory route, address contractAddress) external view returns (string memory);\\n    function uriOf(string memory route, address contractAddress, string memory appendData)\\n        external\\n        view\\n        returns (string memory);\\n    // specific routes\\n    function tokenURI(address collection, uint256 tokenId) external view returns (string memory);\\n\\n    // setters\\n    function setDefaultURI(string memory uri) external;\\n    function setRouteURI(string memory uri, string memory route) external;\\n    function setContractRouteURI(string memory uri, string memory route, address contractAddress) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"solmate/=lib/solmate/\",\r\n      \"tokenbound/=lib/contracts/\",\r\n      \"test/=test/\",\r\n      \"mage/=lib/mage/src/\",\r\n      \"ERC721A/=lib/mage/lib/ERC721A/contracts/\",\r\n      \"contracts/=lib/contracts/src/\",\r\n      \"erc4626-tests/=lib/mage/lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin/=lib/mage/lib/openzeppelin-contracts/contracts/\",\r\n      \"sstore2/=lib/contracts/lib/sstore2/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"metadataRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"InvalidFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"NonceAlreadyUsed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"PermitCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitCallUnprotected\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"current\",\"type\":\"uint48\"}],\"name\":\"PermitExpired\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"permitHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"PermitInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"expected\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"PermitSenderMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"PermitSignerInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SetUpUnauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldFeeManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newFeeManager\",\"type\":\"address\"}],\"name\":\"FeeManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalFee\",\"type\":\"uint256\"}],\"name\":\"FeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"NonceUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"enablePermits\",\"type\":\"bool\"}],\"name\":\"SetUp\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"batchMintTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct ModulePermit.Permit\",\"name\":\"permit\",\"type\":\"tuple\"}],\"name\":\"callWithPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"isNonceUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"requirePermits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeManager\",\"type\":\"address\"}],\"name\":\"setNewFeeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enablePermits\",\"type\":\"bool\"}],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enablePermits\",\"type\":\"bool\"}],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"context\",\"type\":\"bytes\"}],\"name\":\"signerCanPermit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"paymentTokens\",\"type\":\"address[]\"}],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FreeMintModule", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007ff6363cd3a4e7f9ece98d78dd3c862bace2163d0000000000000000000000004b5f9b012842d449f84c93b1b9c85a730ea7cd7a000000000000000000000000eb9359fb4154e4ef9b3ba153aa86555f69cd2e3e", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}