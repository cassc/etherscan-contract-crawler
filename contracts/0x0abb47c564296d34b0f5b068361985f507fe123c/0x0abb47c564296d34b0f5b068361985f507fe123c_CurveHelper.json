{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/util/CurveHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\nimport \\\"src/util/OffchainAbstractHelper.sol\\\";\\n\\ninterface ICurvePool {\\n    function coins(uint index) external view returns(address);\\n    function get_dy(uint i, uint j, uint dx) external view returns(uint);\\n    function exchange(uint i, uint j, uint dx, uint min_dy, bool use_eth) external payable returns(uint);\\n    function exchange(uint i, uint j, uint dx, uint min_dy, bool use_eth, address receiver) external payable returns(uint);\\n}\\n\\ncontract CurveHelper is OffchainAbstractHelper{\\n\\n    ICurvePool public immutable curvePool;\\n    uint dbrIndex;\\n    uint dolaIndex;\\n\\n    constructor(address _pool, uint tokens) {\\n        curvePool = ICurvePool(_pool);\\n        DOLA.approve(_pool, type(uint).max);\\n        DBR.approve(_pool, type(uint).max);\\n        for(uint i; i < tokens; ++i){\\n            if(ICurvePool(_pool).coins(i) == address(DOLA)){\\n                dolaIndex = i;\\n            }\\n            else if(ICurvePool(_pool).coins(i) == address(DBR)){\\n                dbrIndex = i;\\n            }\\n        }\\n    }\\n\\n    /**\\n    @notice Sells an exact amount of DBR for DOLA in a curve pool\\n    @param amount Amount of DBR to sell\\n    @param minOut minimum amount of DOLA to receive\\n    */\\n    function _sellDbr(uint amount, uint minOut) internal override {\\n        if(amount > 0){\\n            curvePool.exchange(dbrIndex, dolaIndex, amount, minOut, false);\\n        }\\n    }\\n\\n    /**\\n    @notice Buys an exact amount of DBR for DOLA in a curve pool\\n    @param amount Amount of DOLA to sell\\n    @param minOut minimum amount of DBR out\\n    */\\n    function _buyDbr(uint amount, uint minOut, address receiver) internal override {\\n        if(amount > 0) {\\n            curvePool.exchange(dolaIndex, dbrIndex, amount, minOut, false, receiver);\\n        }\\n    }\\n    \\n    /**\\n    @notice Approximates the total amount of dola and dbr needed to borrow a dolaBorrowAmount while also borrowing enough to buy the DBR needed to cover for the borrowing period\\n    @dev Uses a binary search to approximate the amounts needed. Should only be called as part of generating transaction parameters.\\n    @param dolaBorrowAmount Amount of dola the user wishes to end up with\\n    @param period Amount of time in seconds the loan will last\\n    @param iterations Number of approximation iterations. The higher the more precise the result\\n    */\\n    function approximateDolaAndDbrNeeded(uint dolaBorrowAmount, uint period, uint iterations) public view override returns(uint dolaForDbr, uint dbrNeeded){\\n        uint amountIn = dolaBorrowAmount;\\n        uint stepSize = amountIn / 2;\\n        uint dbrReceived = curvePool.get_dy(dolaIndex, dbrIndex, amountIn);\\n        uint dbrToBuy = (amountIn + dolaBorrowAmount) * period / 365 days;\\n        uint dist = dbrReceived > dbrToBuy ? dbrReceived - dbrToBuy : dbrToBuy - dbrReceived;\\n        for(uint i; i < iterations; ++i){\\n            uint newAmountIn = amountIn;\\n            if(dbrReceived > dbrToBuy){\\n                newAmountIn -= stepSize;\\n            } else {\\n                newAmountIn += stepSize;\\n            }\\n            uint newDbrReceived = curvePool.get_dy(dolaIndex, dbrIndex, newAmountIn);\\n            uint newDbrToBuy = (newAmountIn + dolaBorrowAmount) * period / 365 days;\\n            uint newDist = newDbrReceived > newDbrToBuy ? newDbrReceived - newDbrToBuy : newDbrToBuy - newDbrReceived;\\n            if(newDist < dist){\\n                dbrReceived = newDbrReceived;\\n                dbrToBuy = newDbrToBuy;\\n                dist = newDist;\\n                amountIn = newAmountIn;\\n            }\\n            stepSize /= 2;\\n        }\\n        return (amountIn, (dolaBorrowAmount + amountIn) * period / 365 days);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/util/OffchainAbstractHelper.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\nimport \\\"../interfaces/IMarket.sol\\\";\\ninterface IERC20 {\\n    function transfer(address to, uint amount) external;\\n    function transferFrom(address from, address to, uint amount) external;\\n    function approve(address to, uint amount) external;\\n    function balanceOf(address user) external view returns(uint);\\n}\\n\\ninterface IWETH is IERC20 {\\n    function withdraw(uint wad) external;\\n    function deposit() external payable;\\n}\\n\\nabstract contract OffchainAbstractHelper {\\n\\n    IERC20 constant DOLA = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\\n    IERC20 constant DBR = IERC20(0xAD038Eb671c44b853887A7E32528FaB35dC5D710);\\n    IWETH constant WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n    \\n    /**\\n    Virtual functions implemented by the AMM interfacing part of the Helper contract\\n    */\\n\\n    /**\\n    @notice Buys DBR for an amount of Dola\\n    @param amount Amount of Dola to spend on DBR\\n    @param minOut minimum amount of DBR to receive\\n    */\\n    function _buyDbr(uint amount, uint minOut, address receiver) internal virtual;\\n\\n    /**\\n    @notice Sells an exact amount of DBR for DOLA\\n    @param amount Amount of DBR to sell\\n    @param minOut minimum amount of DOLA to receive\\n    */\\n    function _sellDbr(uint amount, uint minOut) internal virtual;\\n\\n    /**\\n    @notice Approximates the amount of additional DOLA and DBR needed to sustain dolaBorrowAmount over the period\\n    @dev Larger number of iterations increases both accuracy of the approximation and gas cost. This method should not be called in smart contract code.\\n    @param dolaBorrowAmount The amount of DOLA the user wishes to borrow before covering DBR expenses\\n    @param minDbr The amount of seconds the user wish to borrow the DOLA for\\n    @param iterations The amount of approximation iterations.\\n    @return Tuple of (dolaNeeded, dbrNeeded) representing the total dola needed to pay for the DBR and pay out dolaBorrowAmount and the dbrNeeded to sustain the loan over the period\\n    */\\n    function approximateDolaAndDbrNeeded(uint dolaBorrowAmount, uint minDbr, uint iterations) public view virtual returns(uint, uint);\\n\\n    /**\\n    @notice Borrows on behalf of the caller, buying the necessary DBR to pay for the loan over the period, by borrowing aditional funds to pay for the necessary DBR\\n    @dev Has to borrow the dolaForDbr amount due to how the market's borrowOnBehalf functions, and repay the excess at the end of the call resulting in a weird repay event\\n    @param market Market the caller wishes to borrow from\\n    @param dolaAmount Amount the caller wants to end up with at their disposal\\n    @param dolaForDbr The max amount of debt the caller is willing to end up with\\n     This is a sensitive parameter and should be reasonably low to prevent sandwhiching.\\n     A good estimate can be calculated given the approximateDolaAndDbrNeeded function, though should be set slightly higher.\\n    @param minDbr The minDbr the caller wish to borrow for\\n    @param deadline Deadline of the signature\\n    @param v V parameter of the signature\\n    @param r R parameter of the signature\\n    @param s S parameter of the signature\\n    */\\n    function buyDbrAndBorrowOnBehalf(\\n        IMarket market, \\n        uint dolaAmount,\\n        uint dolaForDbr,\\n        uint minDbr,\\n        uint deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s) \\n        public \\n    {\\n        //Borrow Dola\\n        uint totalBorrow = dolaAmount + dolaForDbr;\\n        market.borrowOnBehalf(msg.sender, totalBorrow, deadline, v, r, s);\\n        \\n        //Buy DBR\\n        _buyDbr(dolaForDbr, minDbr, msg.sender);\\n\\n        //Transfer remaining DOLA amount to user\\n        DOLA.transfer(msg.sender, dolaAmount);\\n    }\\n\\n    /**\\n    @notice Deposits collateral and borrows on behalf of the caller, buying the necessary DBR to pay for the loan over the period, by borrowing aditional funds to pay for the necessary DBR\\n    @dev Has to borrow the dolaForDbr amount due to how the market's borrowOnBehalf functions, and repay the excess at the end of the call resulting in a weird repay event\\n    @param market Market the caller wish to deposit to and borrow from\\n    @param dolaAmount Amount the caller wants to end up with at their disposal\\n    @param dolaForDbr The max amount of debt the caller is willing to take on to buy dbr\\n     This is a sensitive parameter and should be reasonably low to prevent sandwhiching.\\n     A good estimate can be calculated given the approximateDolaAndDbrNeeded function, though should be set slightly higher.\\n    @param minDbr The minDbr the caller wish to borrow for\\n    @param deadline Deadline of the signature\\n    @param v V parameter of the signature\\n    @param r R parameter of the signature\\n    @param s S parameter of the signature\\n    */\\n    function depositBuyDbrAndBorrowOnBehalf(\\n        IMarket market, \\n        uint collateralAmount, \\n        uint dolaAmount,\\n        uint dolaForDbr,\\n        uint minDbr,\\n        uint deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s) \\n        public \\n    {\\n        IERC20 collateral = IERC20(market.collateral());\\n\\n        //Deposit collateral\\n        collateral.transferFrom(msg.sender, address(this), collateralAmount);\\n        collateral.approve(address(market), collateralAmount);\\n        market.deposit(msg.sender, collateralAmount);\\n\\n        //Borrow dola and buy dbr\\n        buyDbrAndBorrowOnBehalf(market, dolaAmount, dolaForDbr, minDbr, deadline, v, r , s);\\n    }\\n\\n    /**\\n    @notice Deposits native eth as collateral and borrows on behalf of the caller,\\n    buying the necessary DBR to pay for the loan over the period, by borrowing aditional funds to pay for the necessary DBR\\n    @dev Has to borrow the dolaForDbr amount due to how the market's borrowOnBehalf functions, and repay the excess at the end of the call resulting in a weird repay event\\n    @param market Market the caller wish to deposit to and borrow from\\n    @param dolaAmount Amount the caller wants to end up with at their disposal\\n    @param dolaForDbr The max amount of debt the caller is willing to end up with\\n     This is a sensitive parameter and should be reasonably low to prevent sandwhiching.\\n     A good estimate can be calculated given the approximateDolaAndDbrNeeded function, though should be set slightly higher.\\n    @param minDbr The minDbr the caller wish to borrow for\\n    @param deadline Deadline of the signature\\n    @param v V parameter of the signature\\n    @param r R parameter of the signature\\n    @param s S parameter of the signature\\n    */\\n    function depositNativeEthBuyDbrAndBorrowOnBehalf(\\n        IMarket market, \\n        uint dolaAmount,\\n        uint dolaForDbr,\\n        uint minDbr,\\n        uint deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s) \\n        public payable\\n    {\\n        IERC20 collateral = IERC20(market.collateral());\\n        require(address(collateral) == address(WETH), \\\"Market is not an ETH market\\\");\\n        WETH.deposit{value:msg.value}();\\n\\n        //Deposit collateral\\n        collateral.approve(address(market), msg.value);\\n        market.deposit(msg.sender, msg.value);\\n\\n        //Borrow dola and buy dbr\\n        buyDbrAndBorrowOnBehalf(market, dolaAmount, dolaForDbr, minDbr, deadline, v, r , s);\\n    }\\n\\n    /**\\n    @notice Sells DBR on behalf of the caller and uses the proceeds along with DOLA from the caller to repay debt.\\n    @dev The caller is unlikely to spend all of the DOLA they make available for the function call\\n    @param market The market the user wishes to repay debt in\\n    @param dolaAmount The maximum amount of dola debt the user is willing to repay\\n    @param minDolaFromDbr The minimum amount of DOLA the caller expects to get in return for selling their DBR.\\n     This is a sensitive parameter and should be provided with reasonably low slippage to prevent sandwhiching.\\n    @param dbrAmountToSell The amount of DBR the caller wishes to sell\\n    */\\n    function sellDbrAndRepayOnBehalf(IMarket market, uint dolaAmount, uint minDolaFromDbr, uint dbrAmountToSell) public {\\n        uint dbrBal = DBR.balanceOf(msg.sender);\\n\\n        //If user has less DBR than ordered, sell what's available\\n        if(dbrAmountToSell > dbrBal){\\n            DBR.transferFrom(msg.sender, address(this), dbrBal);\\n            _sellDbr(dbrBal, minDolaFromDbr);\\n        } else {\\n            DBR.transferFrom(msg.sender, address(this), dbrAmountToSell);\\n            _sellDbr(dbrAmountToSell, minDolaFromDbr);\\n        }\\n\\n        uint debt = market.debts(msg.sender);\\n        uint dolaBal = DOLA.balanceOf(address(this));\\n        \\n        //If the debt is lower than the dolaAmount, repay debt else repay dolaAmount\\n        uint repayAmount = debt < dolaAmount ? debt : dolaAmount;\\n\\n        //If dolaBal is less than repayAmount, transfer remaining DOLA from user, otherwise transfer excess dola to user\\n        if(dolaBal < repayAmount){\\n            DOLA.transferFrom(msg.sender, address(this), repayAmount - dolaBal);\\n        } else {\\n            DOLA.transfer(msg.sender, dolaBal - repayAmount);\\n        }\\n\\n        //Repay repayAmount\\n        DOLA.approve(address(market), repayAmount);\\n        market.repay(msg.sender, repayAmount);\\n    }\\n\\n    /**\\n    @notice Sells DBR on behalf of the caller and uses the proceeds along with DOLA from the caller to repay debt, and then withdraws collateral\\n    @dev The caller is unlikely to spend all of the DOLA they make available for the function call\\n    @param market Market the user wishes to repay debt in\\n    @param dolaAmount Maximum amount of dola debt the user is willing to repay\\n    @param minDolaFromDbr Minimum amount of DOLA the caller expects to get in return for selling their DBR\\n     This is a sensitive parameter and should be provided with reasonably low slippage to prevent sandwhiching.\\n    @param dbrAmountToSell Amount of DBR the caller wishes to sell\\n    @param collateralAmount Amount of collateral to withdraw\\n    @param deadline Deadline of the signature\\n    @param v V parameter of the signature\\n    @param r R parameter of the signature\\n    @param s S parameter of the signature\\n    */\\n    function sellDbrRepayAndWithdrawOnBehalf(\\n        IMarket market, \\n        uint dolaAmount, \\n        uint minDolaFromDbr,\\n        uint dbrAmountToSell, \\n        uint collateralAmount, \\n        uint deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s) \\n        external \\n    {\\n        //Repay\\n        sellDbrAndRepayOnBehalf(market, dolaAmount, minDolaFromDbr, dbrAmountToSell);\\n\\n        //Withdraw\\n        market.withdrawOnBehalf(msg.sender, collateralAmount, deadline, v, r, s);\\n\\n        //Transfer collateral to msg.sender\\n        IERC20(market.collateral()).transfer(msg.sender, collateralAmount);\\n    }\\n\\n    /**\\n    @notice Sells DBR on behalf of the caller and uses the proceeds along with DOLA from the caller to repay debt, and then withdraws collateral\\n    @dev The caller is unlikely to spend all of the DOLA they make available for the function call\\n    @param market Market the user wishes to repay debt in\\n    @param dolaAmount Maximum amount of dola debt the user is willing to repay\\n    @param minDolaFromDbr Minimum amount of DOLA the caller expects to get in return for selling their DBR\\n     This is a sensitive parameter and should be provided with reasonably low slippage to prevent sandwhiching.\\n    @param dbrAmountToSell Amount of DBR the caller wishes to sell\\n    @param collateralAmount Amount of collateral to withdraw\\n    @param deadline Deadline of the signature\\n    @param v V parameter of the signature\\n    @param r R parameter of the signature\\n    @param s S parameter of the signature\\n    */\\n    function sellDbrRepayAndWithdrawNativeEthOnBehalf(\\n        IMarket market, \\n        uint dolaAmount, \\n        uint minDolaFromDbr,\\n        uint dbrAmountToSell, \\n        uint collateralAmount, \\n        uint deadline, \\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s) \\n        external \\n    {\\n        //Repay\\n        sellDbrAndRepayOnBehalf(market, dolaAmount, minDolaFromDbr, dbrAmountToSell);\\n\\n        //Withdraw\\n        withdrawNativeEthOnBehalf(market, collateralAmount, deadline, v, r, s);\\n    }\\n\\n    /**\\n    @notice Repays debt, and then withdraws native ETH\\n    @dev The caller is unlikely to spend all of the DOLA they make available for the function call\\n    @param market Market the user wishes to repay debt in\\n    @param dolaAmount Amount of dola debt the user is willing to repay    \\n    @param collateralAmount Amount of collateral to withdraw\\n    @param deadline Deadline of the signature\\n    @param v V parameter of the signature\\n    @param r R parameter of the signature\\n    @param s S parameter of the signature\\n    */\\n    function repayAndWithdrawNativeEthOnBehalf(\\n        IMarket market, \\n        uint dolaAmount,                 \\n        uint collateralAmount, \\n        uint deadline,\\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s) \\n        external \\n    {        \\n        // Repay\\n        DOLA.transferFrom(msg.sender, address(this), dolaAmount);        \\n        DOLA.approve(address(market), dolaAmount);\\n        market.repay(msg.sender, dolaAmount);\\n\\n        // Withdraw\\n        withdrawNativeEthOnBehalf(market, collateralAmount, deadline, v, r, s);\\n    }\\n\\n    /**\\n    @notice Helper function for depositing native eth to WETH markets\\n    @param market The WETH market to deposit to\\n    */\\n    function depositNativeEthOnBehalf(IMarket market) public payable {\\n        require(address(market.collateral()) == address(WETH), \\\"Not an ETH market\\\");\\n        WETH.deposit{value:msg.value}();\\n        WETH.approve(address(market), msg.value);\\n        market.deposit(msg.sender, msg.value);\\n    }\\n\\n    /**\\n    @notice Helper function for depositing native eth to WETH markets before borrowing on behalf of the depositor\\n    @param market The WETH market to deposit to\\n    @param borrowAmount The amount to borrow on behalf of the depositor\\n    @param deadline Deadline of the signature\\n    @param v V parameter of the signature\\n    @param r R parameter of the signature\\n    @param s S parameter of the signature\\n    */\\n    function depositNativeEthAndBorrowOnBehalf(IMarket market, uint borrowAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) public payable {\\n        require(address(market.collateral()) == address(WETH), \\\"Not an ETH market\\\");\\n\\n        //Deposit native eth\\n        WETH.deposit{value:msg.value}();\\n        WETH.approve(address(market), msg.value);\\n        market.deposit(msg.sender, msg.value);\\n\\n        //Borrow Dola\\n        market.borrowOnBehalf(msg.sender, borrowAmount, deadline, v, r, s);\\n        DOLA.transfer(msg.sender, borrowAmount);\\n    }\\n\\n    /**\\n    @notice Helper function for withdrawing to native eth\\n    @param market WETH market to withdraw collateral from\\n    @param collateralAmount Amount of collateral to withdraw\\n    @param deadline Deadline of the signature\\n    @param v V parameter of the signature\\n    @param r R parameter of the signature\\n    @param s S parameter of the signature\\n    */\\n    function withdrawNativeEthOnBehalf(\\n        IMarket market,\\n        uint collateralAmount,\\n        uint deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s)\\n        public\\n    {\\n        market.withdrawOnBehalf(msg.sender, collateralAmount, deadline, v, r, s);\\n\\n        IERC20 collateral = IERC20(market.collateral());\\n        require(address(collateral) == address(WETH), \\\"Not an ETH market\\\");\\n        WETH.withdraw(collateralAmount);\\n\\n        (bool success,) = payable(msg.sender).call{value:collateralAmount}(\\\"\\\");\\n        require(success, \\\"Failed to transfer ETH\\\");\\n    }\\n    \\n    //Empty receive function for receiving the native eth sent by the WETH contract\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMarket.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\ninterface IMarket {\\n    function borrowOnBehalf(address msgSender, uint dolaAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function withdrawOnBehalf(address msgSender, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function deposit(address msgSender, uint collateralAmount) external;\\n    function repay(address msgSender, uint amount) external;\\n    function collateral() external returns(address);\\n    function debts(address user) external returns(uint);\\n    function recall(uint amount) external;\\n    function totalDebt() external view returns (uint);\\n    function borrowPaused() external view returns (bool);\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dolaBorrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"}],\"name\":\"approximateDolaAndDbrNeeded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dolaForDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbrNeeded\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dolaAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dolaForDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyDbrAndBorrowOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePool\",\"outputs\":[{\"internalType\":\"contract ICurvePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dolaAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dolaForDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositBuyDbrAndBorrowOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositNativeEthAndBorrowOnBehalf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dolaAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dolaForDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositNativeEthBuyDbrAndBorrowOnBehalf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"depositNativeEthOnBehalf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dolaAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"repayAndWithdrawNativeEthOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dolaAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDolaFromDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbrAmountToSell\",\"type\":\"uint256\"}],\"name\":\"sellDbrAndRepayOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dolaAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDolaFromDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbrAmountToSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"sellDbrRepayAndWithdrawNativeEthOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dolaAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDolaFromDbr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbrAmountToSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"sellDbrRepayAndWithdrawOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"withdrawNativeEthOnBehalf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CurveHelper", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c7de47b9ca2fc753d6a2f167d8b3e19c6d18b19a0000000000000000000000000000000000000000000000000000000000000003", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}