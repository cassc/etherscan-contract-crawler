{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/WatRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {Auth} from \\\"chronicle-std/auth/Auth.sol\\\";\\n\\nimport {IWatRegistry} from \\\"./IWatRegistry.sol\\\";\\n\\n/**\\n * @title WatRegistry\\n *\\n * @notice Single source of truth for all of Chronicle Protocol's wat\\n *         configurations\\n *\\n * @dev Note that this registry is built on the assumption that a wat has the\\n *      same configuration on each chain it is deployed to with the exception\\n *      of wats being deployed on Ethereum which can have less lifted feeds due\\n *      to ScribeOptimistic's auto-kicking functionality.\\n *\\n * @dev Storage use is O(n + m) where n = #wats, m = #deployments\\n */\\ncontract WatRegistry is IWatRegistry, Auth {\\n    struct Config {\\n        uint8 bar;\\n        uint feedsBloom;\\n    }\\n\\n    /// @dev Ethereum's chain id.\\n    ///\\n    ///      Note that this contract is only deployed on Ethereum and respective\\n    ///      testnets.\\n    uint internal immutable _CHAINID_ETH;\\n\\n    /// @dev List of all wats.\\n    ///\\n    /// @dev Note that stable ordering is not guaranteed.\\n    ///\\n    /// @custom:invariant Does not contain duplicates.\\n    /// @custom:invariant Does not contain bytes32(0).\\n    bytes32[] internal _wats;\\n\\n    /// @dev Mapping of wats to their configurations.\\n    ///\\n    /// @custom:invariant If config exists its bar is not zero.\\n    mapping(bytes32 => Config) internal _configs;\\n\\n    /// @dev Mapping of wats to the list of chains with a deployment.\\n    mapping(bytes32 => uint[]) internal _chains;\\n\\n    /// @dev Mapping of (wats, chain id) to the respective deployment.\\n    mapping(bytes32 => mapping(uint => address)) internal _deployment;\\n\\n    // -- Constructor --\\n\\n    constructor(address initialAuthed) Auth(initialAuthed) {\\n        _CHAINID_ETH = block.chainid;\\n    }\\n\\n    // -- Public Read Functions --\\n\\n    /// @inheritdoc IWatRegistry\\n    function wats() external view returns (bytes32[] memory) {\\n        return _wats;\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function exists(bytes32 wat) public view returns (bool) {\\n        return _configs[wat].bar != 0\\n            || _deployment[wat][_CHAINID_ETH] != address(0);\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function config(bytes32 wat) public view returns (uint8, uint) {\\n        // Revert if wat unknown.\\n        if (!exists(wat)) {\\n            revert WatUnknown(wat);\\n        }\\n\\n        // Use Ethereum deployment as config's source if possible, otherwise use\\n        // config stored in _configs storage.\\n        address src = _deployment[wat][_CHAINID_ETH];\\n        if (src != address(0)) {\\n            return (_readBar(src), _readFeedsBloom(src));\\n        } else {\\n            Config memory cfg = _configs[wat];\\n\\n            return (cfg.bar, cfg.feedsBloom);\\n        }\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function chains(bytes32 wat) public view returns (uint[] memory) {\\n        // Revert if wat unknown.\\n        if (!exists(wat)) {\\n            revert WatUnknown(wat);\\n        }\\n\\n        return _chains[wat];\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function deployment(bytes32 wat, uint chainId)\\n        public\\n        view\\n        returns (address)\\n    {\\n        // Revert if wat unknown.\\n        if (!exists(wat)) {\\n            revert WatUnknown(wat);\\n        }\\n\\n        return _deployment[wat][chainId];\\n    }\\n\\n    // -- Auth'ed Functionality --\\n\\n    /// @inheritdoc IWatRegistry\\n    function embrace(bytes32 wat, address ethDeployment) external auth {\\n        // Revert if wat invalid.\\n        require(wat != bytes32(0));\\n\\n        // Revert if wat exists and ethDeployment does not match.\\n        if (exists(wat)) {\\n            require(_deployment[wat][_CHAINID_ETH] == ethDeployment);\\n            return;\\n        }\\n\\n        // Add wat to _wats storage.\\n        _wats.push(wat);\\n        emit Embraced(msg.sender, wat);\\n\\n        // Store Ethereum deployment.\\n        _chains[wat].push(_CHAINID_ETH);\\n        _deployment[wat][_CHAINID_ETH] = ethDeployment;\\n        emit DeploymentUpdated(\\n            msg.sender, wat, _CHAINID_ETH, address(0), ethDeployment\\n        );\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function embrace(bytes32 wat, uint8 bar, uint feedsBloom) external auth {\\n        // Revert if wat invalid.\\n        require(wat != bytes32(0));\\n\\n        // Revert if wat exists and configs due not match.\\n        if (exists(wat)) {\\n            Config memory cfg = _configs[wat];\\n            require(cfg.bar == bar);\\n            require(cfg.feedsBloom == feedsBloom);\\n            return;\\n        }\\n\\n        // Revert if bar is zero.\\n        require(bar != 0);\\n\\n        // Add wat to _wats storage.\\n        _wats.push(wat);\\n        emit Embraced(msg.sender, wat);\\n\\n        // Store config.\\n        _configs[wat] = Config(bar, feedsBloom);\\n        emit ConfigUpdated(msg.sender, wat, uint8(0), bar, 0, feedsBloom);\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function abandon(bytes32 wat) external auth {\\n        // Note to be idempotent.\\n        if (!exists(wat)) {\\n            return;\\n        }\\n\\n        // Delete config.\\n        delete _configs[wat];\\n\\n        // Cache chains in memory and delete afterwards.\\n        uint[] memory chains_ = _chains[wat];\\n        delete _chains[wat];\\n\\n        // Delete every deployment.\\n        for (uint i; i < chains_.length; i++) {\\n            delete _deployment[wat][chains_[i]];\\n        }\\n\\n        // Delete wat.\\n        uint len = _wats.length;\\n        for (uint i; i < len; i++) {\\n            if (_wats[i] == wat) {\\n                _wats[i] = _wats[len - 1];\\n                _wats.pop();\\n                break;\\n            }\\n        }\\n\\n        emit Abandoned(msg.sender, wat);\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function setConfig(bytes32 wat, uint8 bar, uint feedsBloom) external auth {\\n        require(exists(wat));\\n\\n        // Revert if bar is zero and no Ethereum deployment exists.\\n        require(_deployment[wat][_CHAINID_ETH] != address(0) || bar != 0);\\n\\n        // Load current config from storage.\\n        Config memory cfg = _configs[wat];\\n        uint8 oldBar = cfg.bar;\\n        uint oldFeedsBloom = cfg.feedsBloom;\\n\\n        if (oldBar != bar || oldFeedsBloom != feedsBloom) {\\n            _configs[wat] = Config(bar, feedsBloom);\\n\\n            emit ConfigUpdated(\\n                msg.sender, wat, oldBar, bar, oldFeedsBloom, feedsBloom\\n            );\\n        }\\n    }\\n\\n    /// @inheritdoc IWatRegistry\\n    function setDeployment(bytes32 wat, uint chainId, address deployment_)\\n        external\\n        auth\\n    {\\n        require(exists(wat));\\n        require(chainId != 0);\\n\\n        address oldDeployment = _deployment[wat][chainId];\\n        if (oldDeployment != deployment_) {\\n            if (chainId == _CHAINID_ETH) {\\n                // Revert if Ethereum deployment is being removed while config\\n                // has bar of zero.\\n                if (deployment_ == address(0)) {\\n                    require(_configs[wat].bar != 0);\\n                }\\n            }\\n\\n            // If chain does not exist yet, add it to _chains.\\n            if (oldDeployment == address(0)) {\\n                _chains[wat].push(chainId);\\n            }\\n\\n            // If deployment is being removed, remove chain from _chains.\\n            if (deployment_ == address(0)) {\\n                uint len = _chains[wat].length;\\n                for (uint i; i < len; i++) {\\n                    if (_chains[wat][i] == chainId) {\\n                        _chains[wat][i] = _chains[wat][len - 1];\\n                        _chains[wat].pop();\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            _deployment[wat][chainId] = deployment_;\\n\\n            emit DeploymentUpdated(\\n                msg.sender, wat, chainId, oldDeployment, deployment_\\n            );\\n        }\\n    }\\n\\n    // -- Internal Helpers --\\n\\n    function _readBar(address src) internal view returns (uint8) {\\n        return IWatLike(src).bar();\\n    }\\n\\n    function _readFeedsBloom(address src) internal view returns (uint) {\\n        address[] memory feeds = IWatLike(src).feeds();\\n\\n        uint feedsBloom;\\n        for (uint i; i < feeds.length; i++) {\\n            uint8 feedId = uint8(uint(uint160(feeds[i]) >> 152));\\n            feedsBloom |= (1 << feedId);\\n        }\\n\\n        return feedsBloom;\\n    }\\n}\\n\\ninterface IWatLike {\\n    function bar() external view returns (uint8);\\n    function feeds() external view returns (address[] memory);\\n}\\n\\n/**\\n * @dev Contract overwrite to deploy contract instances with specific naming.\\n *\\n *      For more info, see docs/Deployment.md.\\n */\\ncontract WatRegistry_2 is WatRegistry {\\n    constructor(address initialAuthed) WatRegistry(initialAuthed) {}\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {IAuth} from \\\"./IAuth.sol\\\";\\n\\n/**\\n * @title Auth Module\\n *\\n * @dev The `Auth` contract module provides a basic access control mechanism,\\n *      where a set of addresses are granted access to protected functions.\\n *      These addresses are said to be _auth'ed_.\\n *\\n *      Initially, the address given as constructor argument is the only address\\n *      auth'ed. Through the `rely(address)` and `deny(address)` functions,\\n *      auth'ed callers are able to grant/renounce auth to/from addresses.\\n *\\n *      This module is used through inheritance. It will make available the\\n *      modifier `auth`, which can be applied to functions to restrict their\\n *      use to only auth'ed callers.\\n */\\nabstract contract Auth is IAuth {\\n    /// @dev Mapping storing whether address is auth'ed.\\n    /// @custom:invariant Image of mapping is {0, 1}.\\n    ///                     \u2200x \u220a Address: _wards[x] \u220a {0, 1}\\n    /// @custom:invariant Only address given as constructor argument is authenticated after deployment.\\n    ///                     deploy(initialAuthed) \u2192 (\u2200x \u220a Address: _wards[x] == 1 \u2192 x == initialAuthed)\\n    /// @custom:invariant Only functions `rely` and `deny` may mutate the mapping's state.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x])\\n    ///                                     \u2192 (msg.sig == \\\"rely\\\" \u2228 msg.sig == \\\"deny\\\")\\n    /// @custom:invariant Mapping's state may only be mutated by authenticated caller.\\n    ///                     \u2200x \u220a Address: preTx(_wards[x]) != postTx(_wards[x]) \u2192 _wards[msg.sender] = 1\\n    mapping(address => uint) private _wards;\\n\\n    /// @dev List of addresses possibly being auth'ed.\\n    /// @dev May contain duplicates.\\n    /// @dev May contain addresses not being auth'ed anymore.\\n    /// @custom:invariant Every address being auth'ed once is element of the list.\\n    ///                     \u2200x \u220a Address: authed(x) -> x \u220a _wardsTouched\\n    address[] private _wardsTouched;\\n\\n    /// @dev Ensures caller is auth'ed.\\n    modifier auth() {\\n        assembly (\\\"memory-safe\\\") {\\n            // Compute slot of _wards[msg.sender].\\n            mstore(0x00, caller())\\n            mstore(0x20, _wards.slot)\\n            let slot := keccak256(0x00, 0x40)\\n\\n            // Revert if caller not auth'ed.\\n            let isAuthed := sload(slot)\\n            if iszero(isAuthed) {\\n                // Store selector of `NotAuthorized(address)`.\\n                mstore(0x00, 0x4a0bfec1)\\n                // Store msg.sender.\\n                mstore(0x20, caller())\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x24)\\n            }\\n        }\\n        _;\\n    }\\n\\n    constructor(address initialAuthed) {\\n        _wards[initialAuthed] = 1;\\n        _wardsTouched.push(initialAuthed);\\n\\n        // Note to use address(0) as caller to indicate address was auth'ed\\n        // during deployment.\\n        emit AuthGranted(address(0), initialAuthed);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function rely(address who) external auth {\\n        if (_wards[who] == 1) return;\\n\\n        _wards[who] = 1;\\n        _wardsTouched.push(who);\\n        emit AuthGranted(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function deny(address who) external auth {\\n        if (_wards[who] == 0) return;\\n\\n        _wards[who] = 0;\\n        emit AuthRenounced(msg.sender, who);\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function authed(address who) public view returns (bool) {\\n        return _wards[who] == 1;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    /// @custom:invariant Only contains auth'ed addresses.\\n    ///                     \u2200x \u220a authed(): _wards[x] == 1\\n    /// @custom:invariant Contains all auth'ed addresses.\\n    ///                     \u2200x \u220a Address: _wards[x] == 1 \u2192 x \u220a authed()\\n    function authed() public view returns (address[] memory) {\\n        // Initiate array with upper limit length.\\n        address[] memory wardsList = new address[](_wardsTouched.length);\\n\\n        // Iterate through all possible auth'ed addresses.\\n        uint ctr;\\n        for (uint i; i < wardsList.length; i++) {\\n            // Add address only if still auth'ed.\\n            if (_wards[_wardsTouched[i]] == 1) {\\n                wardsList[ctr++] = _wardsTouched[i];\\n            }\\n        }\\n\\n        // Set length of array to number of auth'ed addresses actually included.\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(wardsList, ctr)\\n        }\\n\\n        return wardsList;\\n    }\\n\\n    /// @inheritdoc IAuth\\n    function wards(address who) public view returns (uint) {\\n        return _wards[who];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IWatRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IWatRegistry {\\n    /// @notice Thrown if wat `wat` unknown.\\n    error WatUnknown(bytes32 wat);\\n\\n    /// @notice Emitted when wat added to registry.\\n    /// @param caller The caller's address.\\n    /// @param wat The wat added.\\n    event Embraced(address indexed caller, bytes32 indexed wat);\\n\\n    /// @notice Emitted when wat removed from registry.\\n    /// @param caller The caller's address.\\n    /// @param wat The wat removed.\\n    event Abandoned(address indexed caller, bytes32 indexed wat);\\n\\n    /// @notice Emitted when a wat's config updated.\\n    /// @param caller The caller's address.\\n    /// @param wat The wat updated.\\n    /// @param oldBar The old bar security parameter.\\n    /// @param newBar The new bar security parameter.\\n    /// @param oldFeedsBloom The old feeds encoded via bloom mechanism.\\n    /// @param newFeedsBloom The new feeds encoded via bloom mechanism.\\n    event ConfigUpdated(\\n        address indexed caller,\\n        bytes32 indexed wat,\\n        uint8 oldBar,\\n        uint8 newBar,\\n        uint oldFeedsBloom,\\n        uint newFeedsBloom\\n    );\\n\\n    /// @notice Emitted when a wat's deployment updated.\\n    /// @param caller The caller's address.\\n    /// @param wat The wat updated.\\n    /// @param chainId The chain id of the deployment.\\n    /// @param oldDeployment The old deployment address.\\n    /// @param newDeployment The new deployment address.\\n    event DeploymentUpdated(\\n        address indexed caller,\\n        bytes32 indexed wat,\\n        uint chainId,\\n        address oldDeployment,\\n        address newDeployment\\n    );\\n\\n    // -- Public Read Functions --\\n\\n    /// @notice Returns all of Chronicle Protocol's wat identifiers.\\n    ///\\n    /// @return Chronicle Protocol's wat identifiers.\\n    function wats() external view returns (bytes32[] memory);\\n\\n    /// @notice Returns whether wat `wat` exists in registry.\\n    ///\\n    /// @param wat The wat identifier.\\n    /// @return Whether wat exists in registry.\\n    function exists(bytes32 wat) external view returns (bool);\\n\\n    /// @notice Returns wat `wat`'s configuration.\\n    ///\\n    /// @dev Reverts if:\\n    ///      - Wat unknown\\n    ///\\n    /// @dev Config is sourced from the Ethereum deployment if it exists,\\n    ///      otherwise static config is returned.\\n    ///\\n    /// @param wat The wat identifier.\\n    /// @return The wat's bar security parameter.\\n    /// @return The wat's lifted feeds encoded via bloom mechanism.\\n    function config(bytes32 wat) external view returns (uint8, uint);\\n\\n    /// @notice Returns wat `wat`'s list of chain ids its deployed to.\\n    ///\\n    /// @dev Reverts if:\\n    ///      - Wat unknown\\n    ///\\n    /// @param wat The wat identifier.\\n    /// @return The list of chain ids the wat is deployed to.\\n    function chains(bytes32 wat) external view returns (uint[] memory);\\n\\n    /// @notice Returns wat `wat`'s deployment address for chain `chainId`.\\n    ///\\n    /// @dev Reverts if:\\n    ///      - Wat unknown\\n    ///\\n    /// @param wat The wat identifier.\\n    /// @param chainId The chain id.\\n    /// @return Address of wat's deployment on given chain if it exists, zero\\n    ///         address otherwise.\\n    function deployment(bytes32 wat, uint chainId)\\n        external\\n        view\\n        returns (address);\\n\\n    // -- Auth'ed Functions --\\n\\n    /// @notice Adds wat `wat` with Ethereum deployment `ethDeployment` to the\\n    ///         registry.\\n    ///\\n    /// @dev Only callable by auth'ed addresses.\\n    ///\\n    /// @dev Reverts if:\\n    ///      - Wat invalid\\n    ///      - Wat exists already\\n    ///\\n    /// @param wat The wat identifier.\\n    /// @param ethDeployment The wat's deployment on Ethereum.\\n    function embrace(bytes32 wat, address ethDeployment) external;\\n\\n    /// @notice Adds wat `wat` with config bar `bar` and feeds encoded via bloom\\n    ///         mechanism `feedsBloom` to the registry.\\n    ///\\n    /// @dev Only callable by auth'ed addresses.\\n    ///\\n    /// @dev Reverts if:\\n    ///      - Wat invalid\\n    ///      - Wat exists already\\n    ///      - Bar zero\\n    ///\\n    /// @param wat The wat identifier.\\n    /// @param bar The bar security parameter.\\n    /// @param feedsBloom The feeds encoded via bloom mechanism.\\n    function embrace(bytes32 wat, uint8 bar, uint feedsBloom) external;\\n\\n    /// @notice Removes wat `wat` from the registry.\\n    ///\\n    /// @dev Only callable by auth'ed addresses.\\n    function abandon(bytes32 wat) external;\\n\\n    /// @notice Updates wat `wat`'s config.\\n    ///\\n    /// @dev Only callable by auth'ed addresses.\\n    ///\\n    /// @dev Reverts if:\\n    ///      - Wat unknown\\n    ///      - Bar zero while no Ethereum deployment exists\\n    ///\\n    /// @param wat The wat identifier.\\n    /// @param bar The bar security parameter.\\n    /// @param feedsBloom The feeds encoded via bloom mechanism.\\n    function setConfig(bytes32 wat, uint8 bar, uint feedsBloom) external;\\n\\n    /// @notice Updates wat `wat`'s deployment for chain `chainId`.\\n    ///\\n    /// @dev Only callable by auth'ed addresses.\\n    ///\\n    /// @dev Reverts if:\\n    ///      - Wat unknown\\n    ///      - Chain id zero\\n    ///      - Ethereum deployment is set to zero while bar config is zero\\n    ///\\n    /// @param wat The wat identifier.\\n    /// @param chainId The chain id of the deployment.\\n    /// @param deployment The deployment.\\n    function setDeployment(bytes32 wat, uint chainId, address deployment)\\n        external;\\n}\\n\"\r\n    },\r\n    \"lib/chronicle-std/src/auth/IAuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\ninterface IAuth {\\n    /// @notice Thrown by protected function if caller not auth'ed.\\n    /// @param caller The caller's address.\\n    error NotAuthorized(address caller);\\n\\n    /// @notice Emitted when auth granted to address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got granted to.\\n    event AuthGranted(address indexed caller, address indexed who);\\n\\n    /// @notice Emitted when auth renounced from address.\\n    /// @param caller The caller's address.\\n    /// @param who The address auth got renounced from.\\n    event AuthRenounced(address indexed caller, address indexed who);\\n\\n    /// @notice Grants address `who` auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to grant auth.\\n    function rely(address who) external;\\n\\n    /// @notice Renounces address `who`'s auth.\\n    /// @dev Only callable by auth'ed address.\\n    /// @param who The address to renounce auth.\\n    function deny(address who) external;\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @param who The address to check.\\n    /// @return True if `who` is auth'ed, false otherwise.\\n    function authed(address who) external view returns (bool);\\n\\n    /// @notice Returns full list of addresses granted auth.\\n    /// @dev May contain duplicates.\\n    /// @return List of addresses granted auth.\\n    function authed() external view returns (address[] memory);\\n\\n    /// @notice Returns whether address `who` is auth'ed.\\n    /// @custom:deprecated Use `authed(address)(bool)` instead.\\n    /// @param who The address to check.\\n    /// @return 1 if `who` is auth'ed, 0 otherwise.\\n    function wards(address who) external view returns (uint);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"chronicle-std/=lib/chronicle-std/src/\",\r\n      \"@script/chronicle-std/=lib/chronicle-std/script/\",\r\n      \"greenhouse/=lib/greenhouse/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialAuthed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"NotAuthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"}],\"name\":\"WatUnknown\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"}],\"name\":\"Abandoned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AuthRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldBar\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newBar\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFeedsBloom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeedsBloom\",\"type\":\"uint256\"}],\"name\":\"ConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDeployment\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDeployment\",\"type\":\"address\"}],\"name\":\"DeploymentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"}],\"name\":\"Embraced\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"}],\"name\":\"abandon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authed\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"}],\"name\":\"chains\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"}],\"name\":\"config\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"deployment\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"ethDeployment\",\"type\":\"address\"}],\"name\":\"embrace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"bar\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"feedsBloom\",\"type\":\"uint256\"}],\"name\":\"embrace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"bar\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"feedsBloom\",\"type\":\"uint256\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"wat\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"deployment_\",\"type\":\"address\"}],\"name\":\"setDeployment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wats\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WatRegistry_2", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000c50dfedb7e93ef7a3daccad7987d0960c4e2cd4b", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}