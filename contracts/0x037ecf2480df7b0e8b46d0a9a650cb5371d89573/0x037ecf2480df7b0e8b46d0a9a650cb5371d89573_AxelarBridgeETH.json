{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/bridge/AxelarBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.2;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { AxelarExecutable } from \\\"@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol\\\";\\nimport { IAxelarGateway } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol';\\nimport { IAxelarGasService } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol';\\nimport { AddressToString } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/libs/AddressString.sol';\\n\\n\\ninterface riotNftEth {\\n  function ownerOf(uint256 _tokenId) external returns (address);\\n  function tokenURI(uint256 _tokenId) external returns (string memory);\\n  function transferFrom(address from, address to, uint256 tokenId) external;\\n}\\n\\ncontract AxelarBridgeETH is Ownable, AxelarExecutable {\\n\\n  IAxelarGasService public immutable gasService;\\n  riotNftEth public riotNftEthAddress;\\n  string public riotNftPolyAddress;\\n  bool public enableUnlock = true;\\n  mapping(uint => address) public tokenIdAddress;\\n\\n  constructor(address gateway_, address gasService_) AxelarExecutable(gateway_) {\\n    gasService = IAxelarGasService(gasService_);\\n  }\\n\\n  function bridgeNft(uint256 _tokenId) external payable {\\n    riotNftEthAddress.transferFrom(msg.sender, address(this), _tokenId);\\n    address getRiotNftEthAddress = riotNftEthAddress.ownerOf(_tokenId);\\n    require(getRiotNftEthAddress == address(this), \\\"Not the Owner\\\");\\n    string memory tokenURI_ = riotNftEthAddress.tokenURI(_tokenId);\\n    tokenIdAddress[_tokenId] = msg.sender;\\n    bytes memory payload = abi.encode(_tokenId, tokenURI_, msg.sender);\\n    gasService.payNativeGasForContractCall{value: msg.value} (address(this), \\\"Polygon\\\", riotNftPolyAddress, payload, msg.sender);\\n    gateway.callContract(\\\"Polygon\\\", riotNftPolyAddress, payload);\\n  }\\n\\n  function setRiotEth(riotNftEth _riotNftEthAddress) public onlyOwner {\\n    riotNftEthAddress = _riotNftEthAddress;\\n  }\\n\\n  function setRiotPolygon(string memory _riotNftPolyAddress) public onlyOwner {\\n    riotNftPolyAddress = _riotNftPolyAddress;\\n  }\\n\\n  function setDisableUnlock() public onlyOwner {\\n    enableUnlock = false;\\n  }\\n\\n  function unlockRiotNft(uint256 _tokenId) public onlyOwner {\\n      require(enableUnlock, \\\"Unlock function was disabled\\\");\\n      riotNftEthAddress.transferFrom(address(this), tokenIdAddress[_tokenId], _tokenId);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\\n\\ncontract AxelarExecutable is IAxelarExecutable {\\n    IAxelarGateway public immutable override gateway;\\n\\n    constructor(address gateway_) {\\n        if (gateway_ == address(0)) revert InvalidAddress();\\n\\n        gateway = IAxelarGateway(gateway_);\\n    }\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external override {\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\\n            revert NotApprovedByGateway();\\n\\n        _execute(sourceChain, sourceAddress, payload);\\n    }\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external override {\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        if (\\n            !gateway.validateContractCallAndMint(\\n                commandId,\\n                sourceChain,\\n                sourceAddress,\\n                payloadHash,\\n                tokenSymbol,\\n                amount\\n            )\\n        ) revert NotApprovedByGateway();\\n\\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\\n    }\\n\\n    function _execute(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) internal virtual {}\\n\\n    function _executeWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IGovernable } from './IGovernable.sol';\\nimport { IImplementation } from './IImplementation.sol';\\n\\ninterface IAxelarGateway is IImplementation, IGovernable {\\n    /**********\\\\\\n    |* Errors *|\\n    \\\\**********/\\n\\n    error NotSelf();\\n    error InvalidCodeHash();\\n    error SetupFailed();\\n    error InvalidAuthModule();\\n    error InvalidTokenDeployer();\\n    error InvalidAmount();\\n    error InvalidChainId();\\n    error InvalidCommands();\\n    error TokenDoesNotExist(string symbol);\\n    error TokenAlreadyExists(string symbol);\\n    error TokenDeployFailed(string symbol);\\n    error TokenContractDoesNotExist(address token);\\n    error BurnFailed(string symbol);\\n    error MintFailed(string symbol);\\n    error InvalidSetMintLimitsParams();\\n    error ExceedMintLimit(string symbol);\\n\\n    /**********\\\\\\n    |* Events *|\\n    \\\\**********/\\n\\n    event TokenSent(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationAddress,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event ContractCall(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload\\n    );\\n\\n    event ContractCallWithToken(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event Executed(bytes32 indexed commandId);\\n\\n    event TokenDeployed(string symbol, address tokenAddresses);\\n\\n    event ContractCallApproved(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallApprovedWithMint(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallExecuted(bytes32 indexed commandId);\\n\\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\\n\\n    event OperatorshipTransferred(bytes newOperatorsData);\\n\\n    event Upgraded(address indexed implementation);\\n\\n    /********************\\\\\\n    |* Public Functions *|\\n    \\\\********************/\\n\\n    function sendToken(\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function callContract(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function callContractWithToken(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function isContractCallApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash\\n    ) external view returns (bool);\\n\\n    function isContractCallAndMintApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function validateContractCall(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) external returns (bool);\\n\\n    function validateContractCallAndMint(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /***********\\\\\\n    |* Getters *|\\n    \\\\***********/\\n\\n    function authModule() external view returns (address);\\n\\n    function tokenDeployer() external view returns (address);\\n\\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\\n\\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\\n\\n    function allTokensFrozen() external view returns (bool);\\n\\n    function implementation() external view returns (address);\\n\\n    function tokenAddresses(string memory symbol) external view returns (address);\\n\\n    function tokenFrozen(string memory symbol) external view returns (bool);\\n\\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\\n\\n    /************************\\\\\\n    |* Governance Functions *|\\n    \\\\************************/\\n\\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata setupParams\\n    ) external;\\n\\n    /**********************\\\\\\n    |* External Functions *|\\n    \\\\**********************/\\n\\n    function execute(bytes calldata input) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGasService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IUpgradable } from '../interfaces/IUpgradable.sol';\\n\\n/**\\n * @title IAxelarGasService Interface\\n * @notice This is an interface for the AxelarGasService contract which manages gas payments\\n * and refunds for cross-chain communication on the Axelar network.\\n * @dev This interface inherits IUpgradable\\n */\\ninterface IAxelarGasService is IUpgradable {\\n    error NothingReceived();\\n    error InvalidAddress();\\n    error NotCollector();\\n    error InvalidAmounts();\\n\\n    event GasPaidForContractCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForContractCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForContractCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForContractCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForExpressCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasPaidForExpressCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForExpressCall(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasPaidForExpressCallWithToken(\\n        address indexed sourceAddress,\\n        string destinationChain,\\n        string destinationAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event GasAdded(\\n        bytes32 indexed txHash,\\n        uint256 indexed logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeGasAdded(bytes32 indexed txHash, uint256 indexed logIndex, uint256 gasFeeAmount, address refundAddress);\\n\\n    event ExpressGasAdded(\\n        bytes32 indexed txHash,\\n        uint256 indexed logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event NativeExpressGasAdded(\\n        bytes32 indexed txHash,\\n        uint256 indexed logIndex,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    );\\n\\n    event Refunded(\\n        bytes32 indexed txHash,\\n        uint256 indexed logIndex,\\n        address payable receiver,\\n        address token,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for a contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForContractCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for a contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForContractCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using native currency for a contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForContractCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Pay for gas using native currency for a contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForContractCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for an express contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForExpressCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using ERC20 tokens for an express contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param gasToken The address of the ERC20 token used to pay for gas\\n     * @param gasFeeAmount The amount of tokens to pay for gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payGasForExpressCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Pay for gas using native currency for an express contract call on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForExpressCall(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Pay for gas using native currency for an express contract call with tokens on a destination chain.\\n     * @dev This function is called on the source chain before calling the gateway to express execute a remote contract.\\n     * @param sender The address making the payment\\n     * @param destinationChain The target chain where the contract call with tokens will be made\\n     * @param destinationAddress The target address on the destination chain\\n     * @param payload Data payload for the contract call with tokens\\n     * @param symbol The symbol of the token to be sent with the call\\n     * @param amount The amount of tokens to be sent with the call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function payNativeGasForExpressCallWithToken(\\n        address sender,\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Add additional gas payment using ERC20 tokens after initiating a cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param gasToken The ERC20 token address used to add gas\\n     * @param gasFeeAmount The amount of tokens to add as gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Add additional gas payment using native currency after initiating a cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addNativeGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Add additional gas payment using ERC20 tokens after initiating an express cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param gasToken The ERC20 token address used to add gas\\n     * @param gasFeeAmount The amount of tokens to add as gas\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addExpressGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address gasToken,\\n        uint256 gasFeeAmount,\\n        address refundAddress\\n    ) external;\\n\\n    /**\\n     * @notice Add additional gas payment using native currency after initiating an express cross-chain call.\\n     * @dev This function can be called on the source chain after calling the gateway to express execute a remote contract.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param refundAddress The address where refunds, if any, should be sent\\n     */\\n    function addNativeExpressGas(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address refundAddress\\n    ) external payable;\\n\\n    /**\\n     * @notice Allows the gasCollector to collect accumulated fees from the contract.\\n     * @dev Use address(0) as the token address for native currency.\\n     * @param receiver The address to receive the collected fees\\n     * @param tokens Array of token addresses to be collected\\n     * @param amounts Array of amounts to be collected for each respective token address\\n     */\\n    function collectFees(\\n        address payable receiver,\\n        address[] calldata tokens,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice Refunds gas payment to the receiver in relation to a specific cross-chain transaction.\\n     * @dev Only callable by the gasCollector.\\n     * @dev Use address(0) as the token address to refund native currency.\\n     * @param txHash The transaction hash of the cross-chain call\\n     * @param logIndex The log index for the cross-chain call\\n     * @param receiver The address to receive the refund\\n     * @param token The token address to be refunded\\n     * @param amount The amount to refund\\n     */\\n    function refund(\\n        bytes32 txHash,\\n        uint256 logIndex,\\n        address payable receiver,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @notice Returns the address of the designated gas collector.\\n     * @return address of the gas collector\\n     */\\n    function gasCollector() external returns (address);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/libs/AddressString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary StringToAddress {\\n    error InvalidAddressString();\\n\\n    function toAddress(string memory addressString) internal pure returns (address) {\\n        bytes memory stringBytes = bytes(addressString);\\n        uint160 addressNumber = 0;\\n        uint8 stringByte;\\n\\n        if (stringBytes.length != 42 || stringBytes[0] != '0' || stringBytes[1] != 'x') revert InvalidAddressString();\\n\\n        for (uint256 i = 2; i < 42; ++i) {\\n            stringByte = uint8(stringBytes[i]);\\n\\n            if ((stringByte >= 97) && (stringByte <= 102)) stringByte -= 87;\\n            else if ((stringByte >= 65) && (stringByte <= 70)) stringByte -= 55;\\n            else if ((stringByte >= 48) && (stringByte <= 57)) stringByte -= 48;\\n            else revert InvalidAddressString();\\n\\n            addressNumber |= uint160(uint256(stringByte) << ((41 - i) << 2));\\n        }\\n\\n        return address(addressNumber);\\n    }\\n}\\n\\nlibrary AddressToString {\\n    function toString(address address_) internal pure returns (string memory) {\\n        bytes memory addressBytes = abi.encodePacked(address_);\\n        bytes memory characters = '0123456789abcdef';\\n        bytes memory stringBytes = new bytes(42);\\n\\n        stringBytes[0] = '0';\\n        stringBytes[1] = 'x';\\n\\n        for (uint256 i; i < 20; ++i) {\\n            stringBytes[2 + i * 2] = characters[uint8(addressBytes[i] >> 4)];\\n            stringBytes[3 + i * 2] = characters[uint8(addressBytes[i] & 0x0f)];\\n        }\\n\\n        return string(stringBytes);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from './IAxelarGateway.sol';\\n\\ninterface IAxelarExecutable {\\n    error InvalidAddress();\\n    error NotApprovedByGateway();\\n\\n    function gateway() external view returns (IAxelarGateway);\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IGovernable Interface\\n * @notice This is an interface used by the AxelarGateway contract to manage governance and mint limiter roles.\\n */\\ninterface IGovernable {\\n    error NotGovernance();\\n    error NotMintLimiter();\\n    error InvalidGovernance();\\n    error InvalidMintLimiter();\\n\\n    event GovernanceTransferred(address indexed previousGovernance, address indexed newGovernance);\\n    event MintLimiterTransferred(address indexed previousGovernance, address indexed newGovernance);\\n\\n    /**\\n     * @notice Returns the governance address.\\n     * @return address of the governance\\n     */\\n    function governance() external view returns (address);\\n\\n    /**\\n     * @notice Returns the mint limiter address.\\n     * @return address of the mint limiter\\n     */\\n    function mintLimiter() external view returns (address);\\n\\n    /**\\n     * @notice Transfer the governance role to another address.\\n     * @param newGovernance The new governance address\\n     */\\n    function transferGovernance(address newGovernance) external;\\n\\n    /**\\n     * @notice Transfer the mint limiter role to another address.\\n     * @param newGovernance The new mint limiter address\\n     */\\n    function transferMintLimiter(address newGovernance) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IContractIdentifier } from './IContractIdentifier.sol';\\n\\ninterface IImplementation is IContractIdentifier {\\n    error NotProxy();\\n\\n    function setup(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IContractIdentifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// General interface for upgradable contracts\\ninterface IContractIdentifier {\\n    /**\\n     * @notice Returns the contract ID. It can be used as a check during upgrades.\\n     * @dev Meant to be overridden in derived contracts.\\n     * @return bytes32 The contract ID\\n     */\\n    function contractId() external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IUpgradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable } from './IOwnable.sol';\\nimport { IImplementation } from './IImplementation.sol';\\n\\n// General interface for upgradable contracts\\ninterface IUpgradable is IOwnable, IImplementation {\\n    error InvalidCodeHash();\\n    error InvalidImplementation();\\n    error SetupFailed();\\n\\n    event Upgraded(address indexed newImplementation);\\n\\n    function implementation() external view returns (address);\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata params\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IOwnable Interface\\n * @notice IOwnable is an interface that abstracts the implementation of a\\n * contract with ownership control features. It's commonly used in upgradable\\n * contracts and includes the functionality to get current owner, transfer\\n * ownership, and propose and accept ownership.\\n */\\ninterface IOwnable {\\n    error NotOwner();\\n    error InvalidOwner();\\n    error InvalidOwnerAddress();\\n\\n    event OwnershipTransferStarted(address indexed newOwner);\\n    event OwnershipTransferred(address indexed newOwner);\\n\\n    /**\\n     * @notice Returns the current owner of the contract.\\n     * @return address The address of the current owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Returns the address of the pending owner of the contract.\\n     * @return address The address of the pending owner\\n     */\\n    function pendingOwner() external view returns (address);\\n\\n    /**\\n     * @notice Transfers ownership of the contract to a new address\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function transferOwnership(address newOwner) external;\\n\\n    /**\\n     * @notice Proposes to transfer the contract's ownership to a new address.\\n     * The new owner needs to accept the ownership explicitly.\\n     * @param newOwner The address to transfer ownership to\\n     */\\n    function proposeOwnership(address newOwner) external;\\n\\n    /**\\n     * @notice Transfers ownership to the pending owner.\\n     * @dev Can only be called by the pending owner\\n     */\\n    function acceptOwnership() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gateway_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gasService_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedByGateway\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bridgeNft\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableUnlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasService\",\"outputs\":[{\"internalType\":\"contract IAxelarGasService\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"contract IAxelarGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riotNftEthAddress\",\"outputs\":[{\"internalType\":\"contract riotNftEth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riotNftPolyAddress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setDisableUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract riotNftEth\",\"name\":\"_riotNftEthAddress\",\"type\":\"address\"}],\"name\":\"setRiotEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_riotNftPolyAddress\",\"type\":\"string\"}],\"name\":\"setRiotPolygon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unlockRiotNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AxelarBridgeETH", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000004f4495243837681061c4743b74b3eedf548d56a50000000000000000000000002d5d7d31f671f86c782533cc367f14109a082712", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}