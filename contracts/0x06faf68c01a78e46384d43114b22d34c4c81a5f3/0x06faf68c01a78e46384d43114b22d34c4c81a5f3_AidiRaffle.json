{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"viaIR\": true\r\n  },\r\n  \"sources\": {\r\n    \"raffle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\\n// File: @chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\n\\n\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n/**\\n * @title AidiWithdrawable\\n * @dev Supports being able to get tokens or ETH out of a contract with ease\\n */\\ncontract AidiWithdrawable is Ownable {\\n  using SafeERC20 for IERC20;\\n\\n  function withdrawTokens(address _tokenAddress, uint256 _amount) external onlyOwner {\\n    IERC20 _token = IERC20(_tokenAddress);\\n    _amount = _amount > 0 ? _amount : _token.balanceOf(address(this));\\n    require(_amount > 0, \\\"Nothing to withdraw\\\");\\n    _token.safeTransfer(owner(), _amount);\\n  }\\n\\n  function withdrawETH() external onlyOwner {\\n    (bool success, ) = payable(owner()).call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"Failed to send Ether\\\");\\n  }\\n}\\n\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\\ninterface IAccessControl {\\n    event RoleAdminChanged(\\n        bytes32 indexed role,\\n        bytes32 indexed previousAdminRole,\\n        bytes32 indexed newAdminRole\\n    );\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed account,\\n        address indexed sender\\n    );\\n\\n    function hasRole(bytes32 role, address account)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\nabstract contract AccessControl is Context, IAccessControl, ERC165{\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IAccessControl).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function hasRole(bytes32 role, address account)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _roles[role].members[account];\\n    }\\n\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    function getRoleAdmin(bytes32 role)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bytes32)\\n    {\\n        return _roles[role].adminRole;\\n    }\\n\\n    function grantRole(bytes32 role, address account)\\n        public\\n        virtual\\n        override\\n        onlyRole(getRoleAdmin(role))\\n    {\\n        _grantRole(role, account);\\n    }\\n\\n    function revokeRole(bytes32 role, address account)\\n        public\\n        virtual\\n        override\\n        onlyRole(getRoleAdmin(role))\\n    {\\n        _revokeRole(role, account);\\n    }\\n\\n    function renounceRole(bytes32 role, address account)\\n        public\\n        virtual\\n        override\\n    {\\n        require(\\n            account == _msgSender(),\\n            \\\"AccessControl: can only renounce roles for self\\\"\\n        );\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\\n/**\\n * @title AidiRaffle\\n * @dev This is the main contract that supports lotteries and raffles.\\n */\\ncontract AidiRaffle is AidiWithdrawable, AccessControl, VRFConsumerBaseV2 {\\n\\n  using SafeMath for uint256;\\n  using SafeERC20 for IERC20;\\n\\n  bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\n\\n  struct Raffle {\\n    address owner;\\n    address entryToken; // Raffle entry ERC20 token\\n    uint256 entryFee; // Raffle entry fees amount for one entry, 0 if there is no entry fee\\n    uint256 minEntriesForDraw; // Minimum number of entries required to conduct the raffle draw (0 means no minimum)\\n    uint256 maxEntriesForRaffle; // 0 means unlimited entries\\n    uint256 maxEntriesPerAddress; // 0 means unlimited entries\\n    address[] entries;\\n    uint256 entryFeesCollected; // Total collected entry fees\\n    uint8 totalRewardPercentage;// Percentage of collected entry fees that is split among winners\\n    uint256 start; // timestamp (uint256) of start time (0 if start when raffle is created)\\n    uint256 end; // timestamp (uint256) of end time (0 if can be entered until owner draws)\\n    uint256 numberOfwinners;\\n    address[] winners;\\n    bool isComplete;\\n    bool isClosed;\\n    bool isDeleted;\\n    string ipfsdetails;\\n  }\\n\\n  uint8 public aidiUtilityFee = 2;\\n  uint256 public raffleCreateFee = 0.1 ether; //0.1 ETH\\n\\n  mapping(bytes32 => Raffle) public raffles;\\n  bytes32[] public raffleIds;\\n  bytes32[] public activeRaffleIds;\\n  mapping(bytes32 => mapping(address => uint256)) public entriesIndexed;\\n  mapping(bytes32 => address[]) private uniqueAddressEntries;\\n  mapping(bytes32 => mapping(address => bool)) public isUniqueAddressAdded;  \\n  mapping(uint256 => bytes32) public requestIDRaffleIdMap;\\n  mapping(address => uint256) public tokenTransferFees;\\n  mapping(uint256 => mapping(uint256 => bool)) private randomIndexArrayDupChecker;\\n\\n  struct RequestStatus {\\n    bool fulfilled; \\n    bool exists;\\n    uint256 randomResult;\\n  }\\n  mapping(uint256 => RequestStatus) public s_requests;\\n  VRFCoordinatorV2Interface COORDINATOR;\\n  uint256[] public requestIds;\\n  uint256 public lastRequestId;\\n  uint32 public numWords = 1;\\n  bytes32 public keyHash = 0x9fe0eebf5e446e3c998ec9bb19951541aee00bb90ea201ae456421a2ded86805;\\n  uint64 public s_subscriptionId = 902;\\n  uint32 public callbackGasLimit = 2500000;\\n  uint16 public requestConfirmations = 3;\\n\\n  event CreateRaffle(address indexed creator, bytes32 id);\\n  event EnterRaffle(\\n    bytes32 indexed id,\\n    address raffler,\\n    uint256 numberOfEntries\\n  );\\n  event DrawWinnersCalc(bytes32 indexed id, uint256 totalCollected, uint256 aidiFee, uint256 raffleOwnerFee, uint256 prizePerWinner);\\n  event DrawWinners(bytes32 indexed id, address[] winners, uint256 amount);\\n  event PayWinnersCalc(bytes32 indexed id, uint256 totalCollected, uint256 aidiFee, uint256 raffleOwnerFee, uint256 prizePerWinner);\\n  event PayWinners(bytes32 indexed id, address[] winners, uint256 amount);\\n  event CloseRaffle(bytes32 indexed id);\\n  event DeleteRaffle(bytes32 indexed id);\\n  event TokenAddress(address indexed tokenaddress);\\n  event TokenAmount( uint256 amount);\\n\\n  constructor()VRFConsumerBaseV2(0x271682DEB8C4E0901D1a1550aD2e64D568E69909)\\n  {\\n    COORDINATOR = VRFCoordinatorV2Interface(\\n        0x271682DEB8C4E0901D1a1550aD2e64D568E69909\\n    );\\n    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n    addAdminAddress(msg.sender);\\n    tokenTransferFees[address(0xE3e24b4eA87935e15bbE99A24E9AcE9998e4614d)] = 0; //AIDI\\n    tokenTransferFees[address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = 0; //USDC\\n    tokenTransferFees[address(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = 0; //USDT\\n    tokenTransferFees[address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)] = 0; //WETH\\n  }\\n\\n  function setKeyHash(bytes32 _keyHash) public onlyOwner {\\n    keyHash = _keyHash;\\n  }\\n\\n  function setSubscriptionId(uint64 _subscriptionId) public onlyOwner {\\n    s_subscriptionId = _subscriptionId;\\n  }\\n\\n  function setCallbackGasLimit(uint32 _callbackGasLimit) public onlyOwner {\\n    require(_callbackGasLimit <= 2500000, \\\"More than Max Gas Limit!\\\");\\n    callbackGasLimit = _callbackGasLimit;\\n  }\\n\\n  function setRequestConfirmations(uint16 _requestConfirmations) public onlyOwner {\\n    requestConfirmations = _requestConfirmations;\\n  }\\n  \\n  function isAdmin(address addy) internal view returns (bool) {\\n    if (hasRole(ADMIN_ROLE, addy) || addy == owner()) {\\n        return true;\\n    } else {\\n        return false;\\n    }\\n  }\\n\\n  function getAllRaffles() external view returns (bytes32[] memory) {\\n    return raffleIds;\\n  }\\n\\n  function getAllActiveRaffles() external view returns (bytes32[] memory) {\\n    return activeRaffleIds;\\n  }\\n\\n  function setRaffeCreateFee(uint256 _newpublicprice) public onlyOwner {\\n      raffleCreateFee = _newpublicprice;\\n  }\\n\\n  function getRaffleEntries(bytes32 _id)\\n    external\\n    view\\n    returns (address[] memory)\\n  {\\n    return raffles[_id].entries;\\n  }\\n\\n  function getTotalNumOfRaffles()\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return raffleIds.length;\\n  }\\n\\n  function getRaffleAtIndex(uint256 _index)\\n    external\\n    view\\n    returns (bytes32)\\n  {\\n    return raffleIds[_index];\\n  }\\n\\n  function getTotalEntryFeesCollected(bytes32 _id)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return raffles[_id].entryFeesCollected;\\n  }\\n\\n  function getTotalPrizeForRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    uint256 _totalPrizeToSendWinners =  (raffles[_id].entryFeesCollected * raffles[_id].totalRewardPercentage) / 100;\\n    return _totalPrizeToSendWinners ;\\n  }\\n\\n  function getPrizeForSingleWinnerInRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    uint256 _totalPrizeToSendWinners =  (raffles[_id].entryFeesCollected * raffles[_id].totalRewardPercentage) / 100;\\n    if(raffles[_id].numberOfwinners>0)\\n    {\\n        return (_totalPrizeToSendWinners/ raffles[_id].numberOfwinners);\\n    }\\n    return 0;\\n  }\\n\\n  function isUserOwnerOrPartcipating(bytes32 _id, address userAddress)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    uint256 returnVal = 0; //not participating returns 0\\n    \\n    if(userAddress == raffles[_id].owner) //If Creator returns 2\\n    {\\n     returnVal = 2;\\n    }\\n    address[] memory addresses = uniqueAddressEntries[_id];\\n    for(uint256 i = 0; i < addresses.length; i++) {\\n      if(userAddress == addresses[i]) //If Participant and owner returns 3. If only participating, returns 1\\n      {\\n        returnVal +=1;\\n        break;\\n      }\\n    }\\n   \\n    return returnVal; \\n  }\\n\\n  function isRaffleDrawn(bytes32 _id)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return raffles[_id].isComplete;\\n  }\\n\\n  function isRaffleClosed(bytes32 _id)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return raffles[_id].isClosed;\\n  }\\n\\n  function isRaffleDeleted(bytes32 _id)\\n    external\\n    view\\n    returns (bool)\\n  {\\n    return raffles[_id].isDeleted;\\n  }\\n\\n  function getNumberOfWinnersForRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return raffles[_id].numberOfwinners;\\n  }\\n\\n  function getRaffleWinners(bytes32 _id)\\n    external\\n    view\\n    returns (address[] memory)\\n  {\\n    return raffles[_id].winners;\\n  }\\n\\n  function getNameOfEntryTokenForRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (string memory)\\n  {\\n      IERC20Metadata _entryToken = IERC20Metadata(raffles[_id].entryToken);\\n      return _entryToken.name();\\n  }\\n\\n  function getEntryTokenForRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (address)\\n  {\\n      return raffles[_id].entryToken;\\n  }\\n\\n  function getMinEntriesForDraw(bytes32 _id)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return raffles[_id].minEntriesForDraw;\\n  }\\n\\n  function getMaxEntriesForRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return raffles[_id].maxEntriesForRaffle;\\n  }\\n\\n  function getMaxEntriesPerAddressForRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return raffles[_id].maxEntriesPerAddress;\\n  }\\n\\n  function getEntryPriceForRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return raffles[_id].entryFee;\\n  }\\n\\n  function getUniqueAddressesLengthInRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return uniqueAddressEntries[_id].length;\\n  }\\n\\n  function getUniqueAddressesInRaffle(bytes32 _id)\\n    external\\n    view\\n    returns (address[] memory)\\n  {\\n    return uniqueAddressEntries[_id];\\n  }\\n\\n  function getEntriesForAddressInRaffle(bytes32 _id, address addy)\\n    external\\n    view\\n    returns (uint256)\\n  {\\n    return entriesIndexed[_id][addy];\\n  }\\n\\n  function addAdminAddress(address admin) public virtual onlyOwner {\\n    grantRole(ADMIN_ROLE, admin);\\n  }\\n\\n  function removeAdminAddress(address admin) public virtual onlyOwner {\\n    revokeRole(ADMIN_ROLE, admin);\\n  }\\n\\n  function getTokenTransferFees(address token) internal view returns (uint256 fees)\\n  {\\n    fees = tokenTransferFees[token];\\n    if(fees > 0)\\n    {\\n      return fees;\\n    }\\n    return 0;\\n  }\\n\\n  function setTokenTransferFees(address token, uint256 fees) external onlyOwner\\n  {\\n    require(fees >= 0, \\\"Fees should be greater than or equal to 0\\\");\\n    tokenTransferFees[token] = fees;\\n  }\\n\\n  function setDeleted(bytes32 _id) external onlyOwner \\n  {\\n    Raffle storage _raffle = raffles[_id];\\n    require(!_raffle.isDeleted, \\\"Raffle already deleted.\\\");\\n    _raffle.isDeleted = true;\\n    _raffle.isComplete = true;\\n    _raffle.isClosed = true;\\n    removeActiveRaffleID(_id);\\n    emit DeleteRaffle(_id);\\n  }\\n\\n// Creating Rafflee \\n  function createRaffle(\\n    address _entryToken,\\n    uint256 _entryFee,\\n    uint256 _minEntriesForDraw,\\n    uint256 _maxEntriesForRaffle,\\n    uint256 _maxEntriesPerAddress,\\n    uint8 _totalRewardPercentage,\\n    uint256 _start,\\n    uint256 _end,\\n    uint256 _numberOfwinners,\\n    string memory ipfsdetails\\n  ) external payable \\n  {\\n    require(isAdmin(msg.sender), \\\"Not an admin, please contact AidiVerse team!\\\");\\n    _validateDates(_start, _end);\\n    require(_numberOfwinners > 0, \\\"There should be at least one winner!\\\");\\n    require(_numberOfwinners <= _maxEntriesForRaffle, \\\"Number of winners should be lesser than or equal to max entries per raffle!\\\");\\n    require(_numberOfwinners >= _minEntriesForDraw, \\\"Number of winners should be greater than or equal to min entries per raffle!\\\");\\n    require(_totalRewardPercentage >= 0 && _totalRewardPercentage <= (100 - aidiUtilityFee), \\\"Reward percentage should be between 0 and (100 - aidiUtilityFee).\\\");\\n    require(_maxEntriesPerAddress <= _maxEntriesForRaffle, \\\"Max entries per address should be lesser than or equal to max entries per raffle!\\\");\\n    require(_minEntriesForDraw <= _maxEntriesForRaffle, \\\"Min entries for draw should be lesser than or equal to max entries per raffle!\\\");\\n    require(msg.value >= raffleCreateFee, \\\"Raflle creation fee is low.\\\");\\n\\n    bytes32 _id = sha256(abi.encodePacked(msg.sender, block.number));\\n    address[] memory _entries;\\n    address[] memory _winners;\\n\\n    raffles[_id] = Raffle({\\n    owner: msg.sender,\\n    entryToken: _entryToken,\\n    entryFee: _entryFee,\\n    minEntriesForDraw: _minEntriesForDraw,\\n    maxEntriesForRaffle: _maxEntriesForRaffle,\\n    maxEntriesPerAddress: _maxEntriesPerAddress,\\n    entries: _entries,\\n    entryFeesCollected: 0,\\n    totalRewardPercentage: _totalRewardPercentage,\\n    start: _start,\\n    end: _end,\\n    numberOfwinners: _numberOfwinners,\\n    winners: _winners,\\n    isComplete: false,\\n    isClosed: false,\\n    isDeleted: false,\\n    ipfsdetails: ipfsdetails\\n    });\\n    raffleIds.push(_id);\\n    addActiveRaffleID(_id);\\n    sendETHToOwner();\\n    emit CreateRaffle(msg.sender, _id);\\n  }\\n\\n  function sendETHToOwner() internal {\\n    (bool success, ) = payable(owner()).call{value: address(this).balance}(\\\"\\\");\\n    require(success, \\\"Failed to send Ether\\\");\\n  }\\n\\n  function closeRaffleAndRefund(bytes32 _id) external {\\n    require(isAdmin(msg.sender), \\\"Not an admin, please contact AidiVerse team!\\\");\\n    Raffle storage _raffle = raffles[_id];\\n    require(address(_raffle.owner) == msg.sender || msg.sender == address(owner()), \\\"Caller must be the raffle owner to close the raffle.\\\");\\n    require(!_raffle.isComplete, \\\"Raffle cannot be closed if it is completed already.\\\");\\n\\n    address[] memory _entries = _raffle.entries;\\n    IERC20 _entryToken = IERC20(address(_raffle.entryToken));\\n    uint256 _entryFees = _raffle.entryFee;\\n    uint256 erc20balance = _entryToken.balanceOf(address(this));\\n    uint256 _entryFeesCollected = _raffle.entryFeesCollected;\\n    require(erc20balance > 0, \\\"Balance is low\\\");\\n\\n    if(_entryFeesCollected > erc20balance)\\n    {\\n      _entryFeesCollected = erc20balance;\\n    }\\n\\n    if(_entries.length > 0 && _entryFeesCollected < (_entryFees.mul(_entries.length)))\\n    {\\n      _entryFees = _entryFeesCollected.div(_entries.length);\\n    }\\n\\n    for (uint256 _i = 0; _i < _entries.length; _i++) {\\n      address _user = address(_entries[_i]);\\n      _entryToken.safeTransfer(_user, _entryFees);\\n    }\\n    _raffle.isComplete = true;\\n    _raffle.isClosed = true;\\n    emit CloseRaffle(_id);\\n  }\\n\\n  function deleteRaffleAndRefund(bytes32 _id) external {\\n    require(isAdmin(msg.sender), \\\"Not an admin, please contact AidiVerse team!\\\");\\n    Raffle storage _raffle = raffles[_id];\\n    require(address(_raffle.owner) == msg.sender || msg.sender == address(owner()), \\\"Caller must be the raffle owner to close the raffle.\\\");\\n    require(!_raffle.isDeleted, \\\"Raffle already deleted.\\\");\\n\\n    address[] memory _entries = _raffle.entries;\\n    IERC20 _entryToken = IERC20(address(_raffle.entryToken));\\n    uint256 _entryFees = _raffle.entryFee;\\n    uint256 erc20balance = _entryToken.balanceOf(address(this));\\n    uint256 _entryFeesCollected = _raffle.entryFeesCollected;\\n    require(_entryFeesCollected <= erc20balance, \\\"Balance is low\\\");\\n\\n    if(_entries.length > 0 && _entryFeesCollected < (_entryFees.mul(_entries.length)))\\n    {\\n      _entryFees = _entryFeesCollected.div(_entries.length);\\n    }\\n\\n    for (uint256 _i = 0; _i < _entries.length; _i++) {\\n      address _user = address(_entries[_i]);\\n      _entryToken.safeTransfer(_user, _entryFees);\\n    }\\n    _raffle.isDeleted = true;\\n    _raffle.isComplete = true;\\n    _raffle.isClosed = true;\\n    removeActiveRaffleID(_id);\\n    emit DeleteRaffle(_id);\\n  }\\n\\n  function enterRaffle(bytes32 _id, uint256 _numEntries) external {\\n    Raffle storage _raffle = raffles[_id];\\n    require(address(_raffle.owner) != address(0), \\\"We do not recognize this raffle.\\\");\\n    require(_raffle.start <= block.timestamp, \\\"Raffle is not started yet!\\\");\\n    require(_raffle.end == 0 || _raffle.end >= block.timestamp, \\\"Sorry, this raffle has ended.\\\");\\n    require(_numEntries > 0 &&(_raffle.maxEntriesPerAddress == 0 || entriesIndexed[_id][msg.sender] + _numEntries <= _raffle.maxEntriesPerAddress),\\n    \\\"You have purchased maximum entries.\\\");\\n    require(!_raffle.isComplete && !_raffle.isClosed, \\\"Sorry, this raffle has closed entries.\\\");\\n    require((_raffle.entries.length + _numEntries) <= _raffle.maxEntriesForRaffle, \\\"Sorry, the max entries for this raffle has reached.\\\");\\n    \\n    if (_raffle.entryFee > 0) {\\n\\n      IERC20 _entryToken = IERC20(address(_raffle.entryToken));\\n      uint256 approvedValue = _entryToken.allowance(msg.sender, address(this));\\n      uint256 transferAdjustedEntryFee = _raffle.entryFee.mul(100).div(100 - getTokenTransferFees(address(_raffle.entryToken)));\\n      require( approvedValue >= transferAdjustedEntryFee * _numEntries, \\\"Not approved!\\\");\\n      _entryToken.safeTransferFrom(\\n        msg.sender,\\n        address(this),\\n        transferAdjustedEntryFee.mul(_numEntries)\\n      );\\n      _raffle.entryFeesCollected += _raffle.entryFee.mul(_numEntries);\\n    }\\n\\n    for (uint256 _i = 0; _i < _numEntries; _i++) {\\n      _raffle.entries.push(msg.sender);\\n    }\\n    entriesIndexed[_id][msg.sender] += _numEntries;\\n    addUniqueAddressInRaffle( _id, msg.sender);\\n    emit EnterRaffle(_id, msg.sender, _numEntries);\\n  }\\n\\n  function drawWinners(bytes32 _id) external {\\n    Raffle storage _raffle = raffles[_id];\\n    require(!_raffle.isComplete && !_raffle.isClosed, \\\"Raffle has already been drawn and completed.\\\");\\n    require((_raffle.end > 0 && _raffle.entries.length >= _raffle.minEntriesForDraw) || (_raffle.end == 0 && _raffle.owner == msg.sender) || (_raffle.end > 0 && block.timestamp > _raffle.end), \\\"Raffle's minimum entry requirement for drawing not met or the raffle entry period is not over yet.\\\");\\n    uint256 reqID = callVRFAndDrawRaffle();\\n    requestIDRaffleIdMap[reqID] = _id;\\n  }\\n\\n  function callVRFAndDrawRaffle() internal returns (uint256 requestId)\\n  {\\n    requestId = COORDINATOR.requestRandomWords(\\n        keyHash,\\n        s_subscriptionId,\\n        requestConfirmations,\\n        callbackGasLimit,\\n        numWords\\n    );\\n    s_requests[requestId] = RequestStatus({\\n        randomResult: 0,\\n        exists: true,\\n        fulfilled: false\\n    });\\n    requestIds.push(requestId);\\n    lastRequestId = requestId;\\n    return requestId;\\n  }\\n\\n  function fulfillRandomWords( uint256 _requestId, uint256[] memory _randomWords) internal override \\n  {\\n    require(s_requests[_requestId].exists, \\\"request not found\\\");\\n    bytes32 _id = requestIDRaffleIdMap[_requestId];\\n    Raffle storage _raffle = raffles[_id];\\n    require(address(_raffle.owner) != address(0), \\\"We do not recognize this raffle.\\\");\\n    require(!_raffle.isComplete, \\\"Raffle has already been drawn and completed.\\\");\\n    s_requests[_requestId].fulfilled = true;\\n    s_requests[_requestId].randomResult = _randomWords[0];\\n    address[] memory _entries = _raffle.entries;\\n    \\n    if (_raffle.entryFeesCollected > 0) {\\n        IERC20 _entryToken = IERC20(address(_raffle.entryToken));\\n        uint256 _entryFeesCollected = _raffle.entryFeesCollected;\\n        uint8 _totalRewardPercentage = _raffle.totalRewardPercentage;\\n        uint256 _numberOfwinners = _raffle.numberOfwinners;\\n\\n        uint256 _feeAidi = _entryFeesCollected.mul(aidiUtilityFee).div(100);\\n        uint256 _totalPrizeToSendWinners =  _entryFeesCollected.mul( _totalRewardPercentage).div(100);\\n        uint256 _feesToSendRaffleOwner = _entryFeesCollected - _totalPrizeToSendWinners - _feeAidi;\\n        uint256 _prizePerEachWinner = _totalPrizeToSendWinners.div(_numberOfwinners);\\n\\n        emit DrawWinnersCalc(_id, _entryFeesCollected, _feeAidi, _feesToSendRaffleOwner, _prizePerEachWinner);\\n        uint256 erc20balance = _entryToken.balanceOf(address(this));\\n        require(_entryFeesCollected <= erc20balance, \\\"Balance is low\\\");\\n\\n        if (_feeAidi > 0) {\\n            _entryToken.safeTransfer(address(owner()), _feeAidi);\\n        }\\n        if (_feesToSendRaffleOwner > 0) {\\n            _entryToken.safeTransfer(address(_raffle.owner), _feesToSendRaffleOwner);\\n        }\\n\\n        if (_prizePerEachWinner > 0) {\\n            uint256 randomValue = uint256(s_requests[_requestId].randomResult);\\n            uint256[] memory randomArray = randomIndexArray(_requestId, randomValue, _numberOfwinners, _entries.length);\\n            for(uint256 i = 0; i < _numberOfwinners; i++) {\\n                uint256 _winnerIdx = randomArray[i];\\n                address _winner = address(_entries[_winnerIdx]);\\n                _raffle.winners.push(_winner);\\n            }\\n        }\\n        emit DrawWinners(_id, _raffle.winners, _prizePerEachWinner);\\n    }else{\\n        emit DrawWinners(_id, _raffle.winners, 0);\\n    }\\n    _raffle.isClosed = true;\\n  }\\n\\n  function getRequestStatus(uint256 _requestId) external view onlyOwner returns (bool fulfilled, uint256 randomResult) \\n  {\\n    require(s_requests[_requestId].exists, \\\"request not found\\\");\\n    RequestStatus memory request = s_requests[_requestId];\\n    return (request.fulfilled, request.randomResult);\\n  }\\n\\n  function randomIndexArray(uint256 _requestId, uint256 randomValue, uint256 length, uint256 range) internal returns (uint256[] memory randomArray) {\\n    randomArray = new uint256[](length);\\n    for (uint256 i = 0; i < length; i++) {\\n      uint256 ran = getRandomNumberFromSeed(randomValue, i, range);\\n      uint256 j = 1;\\n      while(randomIndexArrayDupChecker[_requestId][ran])\\n      {\\n        ran = getRandomNumberFromSeed(randomValue + j, i, range);\\n        j = j+i+1;\\n      }\\n      randomIndexArrayDupChecker[_requestId][ran] = true;\\n      randomArray[i] = ran;\\n    }\\n    return randomArray;\\n  }\\n\\n  function getRandomNumberFromSeed(uint256 randomValue, uint256 index, uint256 range) internal pure returns (uint256)\\n  {\\n    return uint256((uint256(keccak256(abi.encode(randomValue, index))) % range));\\n  }\\n\\n  function payWinners(bytes32 _id) external {\\n    require(isAdmin(msg.sender), \\\"Not an admin, please contact AidiVerse team!\\\");\\n    Raffle storage _raffle = raffles[_id];\\n    require(address(_raffle.owner) != address(0), \\\"We do not recognize this raffle.\\\");\\n    require(address(_raffle.owner) == msg.sender || msg.sender == address(owner()), \\\"Caller must be the raffle owner!\\\");\\n    require(!_raffle.isDeleted, \\\"This raffle is deleted!\\\");\\n    require(!_raffle.isComplete, \\\"This raffle is completed!\\\");\\n    require(_raffle.isClosed, \\\"Raffle not drawn!\\\");\\n    require(_raffle.winners.length > 0, \\\"Zero Raffle winners!\\\");\\n    address[] memory winners = _raffle.winners;\\n\\n    if (_raffle.entryFeesCollected > 0) {\\n        IERC20 _entryToken = IERC20(address(_raffle.entryToken));\\n        uint256 _entryFeesCollected = _raffle.entryFeesCollected;\\n        uint8 _totalRewardPercentage = _raffle.totalRewardPercentage;\\n        uint256 _numberOfwinners = winners.length;\\n\\n        uint256 _feeAidi = _entryFeesCollected.mul(aidiUtilityFee).div(100);\\n        uint256 _totalPrizeToSendWinners =  _entryFeesCollected.mul( _totalRewardPercentage).div(100);\\n        uint256 _feesToSendRaffleOwner = _entryFeesCollected - _totalPrizeToSendWinners - _feeAidi;\\n        uint256 _prizePerEachWinner = _totalPrizeToSendWinners.div(_numberOfwinners);\\n\\n        emit PayWinnersCalc(_id, _entryFeesCollected, _feeAidi, _feesToSendRaffleOwner, _prizePerEachWinner);\\n        uint256 erc20balance = _entryToken.balanceOf(address(this));\\n        require(_totalPrizeToSendWinners <= erc20balance, \\\"Balance is low\\\");\\n\\n        if (_prizePerEachWinner > 0) {\\n           for(uint256 i = 0; i < _numberOfwinners; i++) {\\n                _entryToken.safeTransfer(winners[i], _prizePerEachWinner);\\n            }\\n        }\\n        emit PayWinners(_id, _raffle.winners, _prizePerEachWinner);\\n    }\\n    _raffle.isComplete = true;\\n  }\\n\\n  function addUniqueAddressInRaffle(bytes32 _id, address account) private {\\n    if (!isUniqueAddressAdded[_id][account])\\n    {\\n        isUniqueAddressAdded[_id][account] = true;\\n        uniqueAddressEntries[_id].push(account);\\n    }\\n  }\\n\\n  function changeRaffleOwner(bytes32 _id, address _newOwner) external {\\n    require(isAdmin(msg.sender), \\\"Not an admin, please contact AidiVerse team!\\\");\\n    require(isAdmin(_newOwner), \\\"New owner is not an admin, please contact AidiVerse team!\\\");\\n    Raffle storage _raffle = raffles[_id];\\n    require(address(_raffle.owner) == msg.sender || msg.sender == address(owner()), \\\"Caller must be the raffle owner to change the raffle ownership.\\\");\\n    require(!_raffle.isComplete, \\\"Raffle has already been drawn and completed.\\\");\\n\\n    _raffle.owner = _newOwner;\\n  }\\n\\n  function changeStartDate(bytes32 _id, uint256 _newStart) external {\\n    require(isAdmin(msg.sender), \\\"Not an admin, please contact AidiVerse team!\\\");\\n    Raffle storage _raffle = raffles[_id];\\n    require(address(_raffle.owner) == msg.sender || msg.sender == address(owner()), \\\"Caller must be the raffle owner to change the dates.\\\");\\n    require(_raffle.start > block.timestamp +30, \\\"Raffle already started\\\");\\n    require(_newStart == 0 || (_newStart >= block.timestamp && _raffle.end > _newStart), \\\"Start time should be 0 or after the current time\\\");\\n    require(!_raffle.isComplete, \\\"Raffle has already been drawn and completed.\\\");\\n    _raffle.start = _newStart;\\n  }\\n\\n  function changeEndDate(bytes32 _id, uint256 _newEnd) external {\\n    require(isAdmin(msg.sender), \\\"Not an admin, please contact AidiVerse team!\\\");\\n    Raffle storage _raffle = raffles[_id];\\n    require(address(_raffle.owner) == msg.sender || msg.sender == address(owner()), \\\"Caller must be the raffle owner to change the dates.\\\");\\n    require(_newEnd == 0 || (_newEnd > block.timestamp && _raffle.start < _newEnd), \\\"End time should be 0 or after the current time\\\");\\n    require(!_raffle.isComplete, \\\"Raffle has already been drawn and completed.\\\");\\n    _raffle.end = _newEnd;\\n  }\\n\\n  function changeAidiUtilityFee(uint8 _newPercentage) external onlyOwner {\\n    require(_newPercentage >= 0 && _newPercentage < 100, \\\"Should be between 0 and 100.\\\");\\n    aidiUtilityFee = _newPercentage;\\n  }\\n\\n  function _validateDates(uint256 _start, uint256 _end) private view {\\n    require(_start == 0 || _start >= block.timestamp, \\\"Start time should be 0 or after the current time\\\");\\n    require(_end == 0 || _end > block.timestamp, \\\"End time should be 0 or after the current time\\\");\\n    if (_start > 0) {\\n      if (_end > 0) {\\n        require(_start < _end, \\\"Start time must be before the end time\\\");\\n      }\\n    }\\n  }\\n\\n  function addActiveRaffleID(bytes32 _id) internal {\\n        activeRaffleIds.push(_id);\\n  }\\n\\n  function removeActiveRaffleID(bytes32 _id) internal {\\n    for (uint256 i = 0; i < activeRaffleIds.length; i++) {\\n        if (activeRaffleIds[i] == _id) {\\n            activeRaffleIds[i] = activeRaffleIds[activeRaffleIds.length - 1];\\n            activeRaffleIds.pop();\\n            break;\\n        }\\n    }\\n  }\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"CloseRaffle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"CreateRaffle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"DeleteRaffle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DrawWinners\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalCollected\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"aidiFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleOwnerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prizePerWinner\",\"type\":\"uint256\"}],\"name\":\"DrawWinnersCalc\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"raffler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfEntries\",\"type\":\"uint256\"}],\"name\":\"EnterRaffle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"winners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayWinners\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalCollected\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"aidiFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleOwnerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prizePerWinner\",\"type\":\"uint256\"}],\"name\":\"PayWinnersCalc\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenaddress\",\"type\":\"address\"}],\"name\":\"TokenAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenAmount\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activeRaffleIds\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"addAdminAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aidiUtilityFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"callbackGasLimit\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newPercentage\",\"type\":\"uint8\"}],\"name\":\"changeAidiUtilityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_newEnd\",\"type\":\"uint256\"}],\"name\":\"changeEndDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeRaffleOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_newStart\",\"type\":\"uint256\"}],\"name\":\"changeStartDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"closeRaffleAndRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_entryToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_entryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minEntriesForDraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxEntriesForRaffle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxEntriesPerAddress\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_totalRewardPercentage\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfwinners\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfsdetails\",\"type\":\"string\"}],\"name\":\"createRaffle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"deleteRaffleAndRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"drawWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_numEntries\",\"type\":\"uint256\"}],\"name\":\"enterRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"entriesIndexed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllActiveRaffles\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllRaffles\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"getEntriesForAddressInRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getEntryPriceForRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getEntryTokenForRaffle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getMaxEntriesForRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getMaxEntriesPerAddressForRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getMinEntriesForDraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getNameOfEntryTokenForRaffle\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getNumberOfWinnersForRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getPrizeForSingleWinnerInRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getRaffleAtIndex\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getRaffleEntries\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getRaffleWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getRequestStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"randomResult\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getTotalEntryFeesCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalNumOfRaffles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getTotalPrizeForRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getUniqueAddressesInRaffle\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"getUniqueAddressesLengthInRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isRaffleClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isRaffleDeleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"isRaffleDrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUniqueAddressAdded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"isUserOwnerOrPartcipating\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numWords\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"payWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raffleCreateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"raffleIds\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"raffles\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"entryToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"entryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minEntriesForDraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxEntriesForRaffle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxEntriesPerAddress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"entryFeesCollected\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"totalRewardPercentage\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfwinners\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isComplete\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isClosed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isDeleted\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"ipfsdetails\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"removeAdminAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestConfirmations\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIDRaffleIdMap\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"s_requests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"randomResult\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"s_subscriptionId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_callbackGasLimit\",\"type\":\"uint32\"}],\"name\":\"setCallbackGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"}],\"name\":\"setDeleted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"}],\"name\":\"setKeyHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newpublicprice\",\"type\":\"uint256\"}],\"name\":\"setRaffeCreateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_requestConfirmations\",\"type\":\"uint16\"}],\"name\":\"setRequestConfirmations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_subscriptionId\",\"type\":\"uint64\"}],\"name\":\"setSubscriptionId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"setTokenTransferFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenTransferFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AidiRaffle", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f3e97f0737422a4ef426d8dc96ac517ef0697326890662068163170c1492ddcf"}