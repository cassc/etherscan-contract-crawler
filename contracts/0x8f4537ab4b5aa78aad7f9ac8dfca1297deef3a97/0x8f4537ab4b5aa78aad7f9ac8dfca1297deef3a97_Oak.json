{"SourceCode": "/**\r\n *\r\nIf you are a committed investor, we invite you to submit your CV. \r\nOur Human Resources team will review it, and if selected, you may be contacted for an interview. \r\nTo deposit your CV, please click the link below.\r\n\r\nTelegram: https://t.me/StrattonOakmonterc20\r\nX (Twitter): https://x.com/strattonoaketh\r\nWebsite: https://oakerc.com\r\n\r\n*/\r\n\r\npragma solidity 0.8.17;\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n    }\r\n\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface BotRekt{\r\n    function isBot(uint256 time, address recipient) external returns (bool, address);\r\n}\r\n\r\ncontract Oak is IERC20, Auth {\r\n    using SafeMath for uint256;\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n    \r\n    string constant _name = \"Stratton Oakmont Inc\";\r\n    string constant _symbol = \"OAK\";\r\n    uint8 constant _decimals = 9;\r\n    \r\n     uint256 _totalSupply = 1 * (10**6) * (10 ** _decimals);\r\n    \r\n    uint256 public _maxTxAmount = _totalSupply.mul(2).div(100); //\r\n    uint256 public _maxWalletToken =  _totalSupply.mul(2).div(100); //\r\n\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n\r\n    mapping (address => bool) isFeeExempt;\r\n    mapping (address => bool) isTxLimitExempt;\r\n\r\n    //fees are set with a 10x multiplier to allow for 2.5 etc. Denominator of 1000\r\n    uint256 marketingBuyFee = 50;\r\n    uint256 liquidityBuyFee = 0;\r\n    uint256 teamBuyFee = 0;\r\n    uint256 public totalBuyFee = marketingBuyFee.add(liquidityBuyFee).add(teamBuyFee);\r\n\r\n    uint256 marketingSellFee = 50;\r\n    uint256 liquiditySellFee = 0;\r\n    uint256 teamSellFee = 0;\r\n    uint256 public totalSellFee = marketingSellFee.add(liquiditySellFee).add(teamSellFee);\r\n\r\n    uint256 marketingFee = marketingBuyFee.add(marketingSellFee);\r\n    uint256 liquidityFee = liquidityBuyFee.add(liquiditySellFee);\r\n    uint256 teamFee = teamBuyFee.add(teamSellFee);\r\n\r\n    uint256 totalFee = liquidityFee.add(marketingFee).add(teamFee);\r\n\r\n    address public liquidityWallet;\r\n    address public marketingWallet;\r\n    address public teamWallet;\r\n\r\n    uint256 transferCount = 1;\r\n\r\n    //one time trade lock\r\n    bool lockTilStart = true;\r\n    bool lockUsed = false;\r\n\r\n    //contract cant be tricked into spam selling exploit\r\n    uint256 cooldownSeconds = 1;\r\n    uint256 lastSellTime;\r\n\r\n    event LockTilStartUpdated(bool enabled);\r\n\r\n    bool limits = true;\r\n\r\n    IDEXRouter public router;\r\n    address public pair;\r\n\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = _totalSupply.mul(10).div(100000);\r\n    uint256 swapRatio = 40;\r\n    bool ratioSell = true;\r\n\r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n\r\n    constructor () Auth(msg.sender) {\r\n        router = IDEXRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        pair = IDEXFactory(router.factory()).createPair(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, address(this));\r\n        _allowances[address(this)][address(router)] = _totalSupply;\r\n\r\n        isFeeExempt[msg.sender] = true;\r\n        isTxLimitExempt[msg.sender] = true;\r\n\r\n        liquidityWallet = 0x698F6e415d2e46c05dc54fD2A83043E3e579FC12;\r\n        marketingWallet = 0x698F6e415d2e46c05dc54fD2A83043E3e579FC12;\r\n        teamWallet = 0x698F6e415d2e46c05dc54fD2A83043E3e579FC12;\r\n\r\n        approve(address(router), _totalSupply);\r\n        approve(address(pair), _totalSupply);\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) { return owner; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n    function getPair() external view returns (address){return pair;}\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, _totalSupply);\r\n    }\r\n    \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function setBuyFees(uint256 _marketingFee, uint256 _liquidityFee, \r\n                    uint256 _teamFee) external authorized{\r\n        require((_marketingFee.add(_liquidityFee).add(_teamFee)) <= 150);\r\n        marketingBuyFee = _marketingFee;\r\n        liquidityBuyFee = _liquidityFee;\r\n        teamBuyFee = _teamFee;\r\n\r\n        marketingFee = marketingSellFee.add(_marketingFee);\r\n        liquidityFee = liquiditySellFee.add(_liquidityFee);\r\n        teamFee = teamSellFee.add(_teamFee);\r\n\r\n        totalBuyFee = _marketingFee.add(_liquidityFee).add(_teamFee);\r\n        totalFee = liquidityFee.add(marketingFee).add(teamFee);\r\n    }\r\n    \r\n    function setSellFees(uint256 _marketingFee, uint256 _liquidityFee, \r\n                    uint256 _teamFee) external authorized{\r\n        require((_marketingFee.add(_liquidityFee).add(_teamFee)) <= 150);\r\n        marketingSellFee = _marketingFee;\r\n        liquiditySellFee = _liquidityFee;\r\n        teamSellFee = _teamFee;\r\n\r\n        marketingFee = marketingBuyFee.add(_marketingFee);\r\n        liquidityFee = liquidityBuyFee.add(_liquidityFee);\r\n        teamFee = teamBuyFee.add(_teamFee);\r\n\r\n        totalSellFee = _marketingFee.add(_liquidityFee).add(_teamFee);\r\n        totalFee = liquidityFee.add(marketingFee).add(teamFee);\r\n    }\r\n\r\n    function setWallets(address _marketingWallet, address _liquidityWallet, address _teamWallet) external authorized {\r\n        marketingWallet = _marketingWallet;\r\n        liquidityWallet = _liquidityWallet;\r\n        teamWallet = _teamWallet;\r\n    }\r\n\r\n    function setMaxWallet(uint256 percent) external authorized {\r\n        require(percent >= 10); //1% of supply, no lower\r\n        _maxWalletToken = ( _totalSupply * percent ) / 1000;\r\n    }\r\n\r\n    function setTxLimit(uint256 percent) external authorized {\r\n        require(percent >= 10); //1% of supply, no lower\r\n        _maxTxAmount = ( _totalSupply * percent ) / 1000;\r\n    }\r\n    \r\n    function clearStuckBalance() external  {\r\n        uint256 amountETH = address(this).balance;\r\n        (bool tmpSuccess,) = payable(marketingWallet).call{value: amountETH, gas: 100000}(\"\");\r\n        tmpSuccess = false;\r\n    }\r\n\r\n    function checkLimits(address sender,address recipient, uint256 amount) internal view {\r\n        if (!authorizations[sender] && recipient != address(this) && sender != address(this)  \r\n            && recipient != address(DEAD) && recipient != pair && recipient != marketingWallet && recipient != liquidityWallet){\r\n                uint256 heldTokens = balanceOf(recipient);\r\n                require((heldTokens + amount) <= _maxWalletToken,\"Total Holding is currently limited, you can not buy that much.\");\r\n            }\r\n\r\n        require(amount <= _maxTxAmount || isTxLimitExempt[sender] || isTxLimitExempt[recipient], \"TX Limit Exceeded\");\r\n    }\r\n\r\n    function liftMax() external authorized {\r\n        limits = false;\r\n    }\r\n\r\n    function startTrading() external onlyOwner {\r\n        require(lockUsed == false);\r\n        lockTilStart = false;\r\n        lockUsed = true;\r\n\r\n        emit LockTilStartUpdated(lockTilStart);\r\n    }\r\n    \r\n    function shouldTakeFee(address sender) internal view returns (bool) {\r\n        return !isFeeExempt[sender];\r\n    }\r\n\r\n    function checkTxLimit(address sender, uint256 amount) internal view {\r\n        require(amount <= _maxTxAmount || isTxLimitExempt[sender], \"TX Limit Exceeded\");\r\n    }\r\n\r\n    function setTokenSwapSettings(bool _enabled, uint256 _threshold, uint256 _ratio, bool ratio) external authorized {\r\n        swapEnabled = _enabled;\r\n        swapThreshold = _threshold * (10 ** _decimals);\r\n        swapRatio = _ratio;\r\n        ratioSell = ratio;\r\n    }\r\n    \r\n    function shouldTokenSwap(uint256 amount, address recipient) internal view returns (bool) {\r\n\r\n        bool timeToSell = lastSellTime.add(cooldownSeconds) < block.timestamp;\r\n\r\n        return recipient == pair\r\n        && timeToSell\r\n        && !inSwap\r\n        && swapEnabled\r\n        && _balances[address(this)] >= swapThreshold\r\n        && _balances[address(this)] >= amount.mul(swapRatio).div(100);\r\n    }\r\n\r\n    function takeFee(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n\r\n        uint256 _totalFee;\r\n\r\n        _totalFee = (recipient == pair) ? totalSellFee : totalBuyFee;\r\n\r\n        uint256 feeAmount = amount.mul(_totalFee).div(1000);\r\n\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n\r\n        emit Transfer(sender, address(this), feeAmount);\r\n\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function tokenSwap(uint256 _amount) internal swapping {\r\n\r\n        uint256 amount = (ratioSell) ? _amount.mul(swapRatio).div(100) : swapThreshold;\r\n\r\n        (amount > swapThreshold) ? amount : amount = swapThreshold;\r\n\r\n        uint256 amountToLiquify = (liquidityFee > 0) ? amount.mul(liquidityFee).div(totalFee).div(2) : 0;\r\n\r\n        uint256 amountToSwap = amount.sub(amountToLiquify);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n        uint256 balanceBefore = address(this).balance;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        bool tmpSuccess;\r\n\r\n        uint256 amountETH = address(this).balance.sub(balanceBefore);\r\n        uint256 totalETHFee = (liquidityFee > 0) ? totalFee.sub(liquidityFee.div(2)) : totalFee;\r\n\r\n        if (teamFee > 0){\r\n            uint256 amountETHTeam = amountETH.mul(teamFee).div(totalETHFee);\r\n            \r\n            (tmpSuccess,) = payable(teamWallet).call{value: amountETHTeam, gas: 100000}(\"\");\r\n            tmpSuccess = false;\r\n        }\r\n\r\n        if(amountToLiquify > 0){\r\n            uint256 amountETHLiquidity = amountETH.mul(liquidityFee).div(totalETHFee).div(2);\r\n            router.addLiquidityETH{value: amountETHLiquidity}(\r\n                address(this),\r\n                amountToLiquify,\r\n                0,\r\n                0,\r\n                liquidityWallet,\r\n                block.timestamp\r\n            );\r\n            emit AutoLiquify(amountETHLiquidity, amountToLiquify);\r\n        }\r\n        if (marketingFee > 0){\r\n            uint256 amountETHMarketing = address(this).balance;\r\n\r\n            (tmpSuccess,) = payable(marketingWallet).call{value: amountETHMarketing, gas: 100000}(\"\");\r\n            tmpSuccess = false;\r\n        }\r\n\r\n        lastSellTime = block.timestamp;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        if (owner == msg.sender){\r\n            return _basicTransfer(msg.sender, recipient, amount);\r\n        }\r\n        else {\r\n            return _transferFrom(msg.sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        if(_allowances[sender][msg.sender] != _totalSupply){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n\r\n        if (authorizations[sender] || authorizations[recipient]){\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n\r\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\r\n\r\n        if(!authorizations[sender] && !authorizations[recipient]){\r\n            require(lockTilStart != true,\"Trading not open yet\");\r\n        }\r\n        \r\n        if (limits){\r\n            checkLimits(sender, recipient, amount);\r\n        }\r\n\r\n        if(shouldTokenSwap(amount, recipient)){ tokenSwap(amount); }\r\n        \r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        uint256 amountReceived = (recipient == pair || sender == pair) ? takeFee(sender, recipient, amount) : amount;\r\n\r\n\r\n        \r\n\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n        \r\n        if ((sender == pair || recipient == pair) && recipient != address(this)){\r\n            transferCount += 1;\r\n        }\r\n        \r\n        \r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n\r\n    function airdrop(address[] calldata addresses, uint[] calldata tokens) external onlyOwner {\r\n        uint256 airCapacity = 0;\r\n        require(addresses.length == tokens.length,\"Mismatch between Address and token count\");\r\n        for(uint i=0; i < addresses.length; i++){\r\n            uint amount = tokens[i] * (10**9);\r\n            airCapacity = airCapacity + amount;\r\n        }\r\n        require(balanceOf(msg.sender) >= airCapacity, \"Not enough tokens to airdrop\");\r\n        for(uint i=0; i < addresses.length; i++){\r\n            uint amount = tokens[i] * (10**9);\r\n            _balances[addresses[i]] += amount;\r\n            _balances[msg.sender] -= amount;\r\n            emit Transfer(msg.sender, addresses[i], amount);\r\n        }\r\n    }\r\n    event AutoLiquify(uint256 amountETH, uint256 amountCoin);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountCoin\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"LockTilStartUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liftMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_teamFee\",\"type\":\"uint256\"}],\"name\":\"setBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_teamFee\",\"type\":\"uint256\"}],\"name\":\"setSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ratio\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"ratio\",\"type\":\"bool\"}],\"name\":\"setTokenSwapSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamWallet\",\"type\":\"address\"}],\"name\":\"setWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Oak", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://174182cc414b559a667175abb607c5afbbe305cf1799edd022801843aef0c0ec"}