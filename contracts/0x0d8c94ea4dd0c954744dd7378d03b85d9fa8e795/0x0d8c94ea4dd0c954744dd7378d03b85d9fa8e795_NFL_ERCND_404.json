{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2024-02-12\r\n*/\r\n\r\n/*\r\nWe are not actually the real DN404 protocol; we waited all day for DN404 to launch, but it never happened. Now I am bored, watching the Super Bowl, so I launched this token. Let's watch it together.\r\n*/\r\n\r\n//Inspired by all the great work out there from ERC20, 404, 721, 721a, 721Psi, 1155, 1155Delta\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.24;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * The initial owner is set to the address provided by the deployer. This can\r\n * later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        if (initialOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != _msgSender()) {\r\n            revert OwnableUnauthorizedAccount(_msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface IERC20Errors {\r\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\r\n    error ERC20InvalidSender(address sender);\r\n    error ERC20InvalidReceiver(address receiver);\r\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\r\n    error ERC20InvalidApprover(address approver);\r\n    error ERC20InvalidSpender(address spender);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\ninterface IERCX {\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error ApprovalCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * Cannot query the balance for the zero address.\r\n     */\r\n    error BalanceQueryForZeroAddress();\r\n\r\n    /**\r\n     * Cannot mint to the zero address.\r\n     */\r\n    error MintToZeroAddress();\r\n\r\n    /**\r\n     * The quantity of tokens minted must be more than zero.\r\n     */\r\n    error MintZeroQuantity();\r\n\r\n    /**\r\n     * Cannot burn from the zero address.\r\n     */\r\n    error BurnFromZeroAddress();\r\n\r\n    /**\r\n     * Cannot burn from the address that doesn't owne the token.\r\n     */\r\n    error BurnFromNonOnwerAddress();\r\n\r\n    /**\r\n     * The caller must own the token or be an approved operator.\r\n     */\r\n    error TransferCallerNotOwnerNorApproved();\r\n\r\n    /**\r\n     * The token must be owned by `from` or the `amount` is not 1.\r\n     */\r\n    error TransferFromIncorrectOwnerOrInvalidAmount();\r\n\r\n    /**\r\n     * Cannot safely transfer to a contract that does not implement the\r\n     * ERC1155Receiver interface.\r\n     */\r\n    error TransferToNonERC1155ReceiverImplementer();\r\n    error TransferToNonERC721ReceiverImplementer();\r\n\r\n    /**\r\n     * Cannot transfer to the zero address.\r\n     */\r\n    error TransferToZeroAddress();\r\n\r\n    /**\r\n     * The length of input arraies is not matching.\r\n     */\r\n    error InputLengthMistmatch();\r\n\r\n    function isOwnerOf(address account, uint256 id) external view returns(bool);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Interface that must be implemented by smart contracts in order to receive\r\n * ERC-1155 token transfers.\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\nabstract contract ERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external virtual returns (bytes4) {\r\n        return ERC721Receiver.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n    /**\r\n     * @dev Returns the URI for token type `id`.\r\n     *\r\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n     * clients with the actual token type ID.\r\n     */\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n/// @notice Library for bit twiddling and boolean operations.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\r\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\r\nlibrary LibBit {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  BIT TWIDDLING OPERATIONS                  */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Find last set.\r\n    /// Returns the index of the most significant bit of `x`,\r\n    /// counting from the least significant bit position.\r\n    /// If `x` is zero, returns 256.\r\n    function fls(uint256 x) internal pure returns (uint256 r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\r\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\r\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\r\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\r\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\r\n            // forgefmt: disable-next-item\r\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\r\n                0x0706060506020504060203020504030106050205030304010505030400000000))\r\n        }\r\n    }\r\n\r\n    /// @dev Count leading zeros.\r\n    /// Returns the number of zeros preceding the most significant one bit.\r\n    /// If `x` is zero, returns 256.\r\n    function clz(uint256 x) internal pure returns (uint256 r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\r\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\r\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\r\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\r\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\r\n            // forgefmt: disable-next-item\r\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\r\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\r\n        }\r\n    }\r\n\r\n    /// @dev Find first set.\r\n    /// Returns the index of the least significant bit of `x`,\r\n    /// counting from the least significant bit position.\r\n    /// If `x` is zero, returns 256.\r\n    /// Equivalent to `ctz` (count trailing zeros), which gives\r\n    /// the number of zeros following the least significant one bit.\r\n    function ffs(uint256 x) internal pure returns (uint256 r) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Isolate the least significant bit.\r\n            let b := and(x, add(not(x), 1))\r\n\r\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, b)))\r\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, b))))\r\n            r := or(r, shl(5, lt(0xffffffff, shr(r, b))))\r\n\r\n            // For the remaining 32 bits, use a De Bruijn lookup.\r\n            // forgefmt: disable-next-item\r\n            r := or(r, byte(and(div(0xd76453e0, shr(r, b)), 0x1f),\r\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the number of set bits in `x`.\r\n    function popCount(uint256 x) internal pure returns (uint256 c) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let max := not(0)\r\n            let isMax := eq(x, max)\r\n            x := sub(x, and(shr(1, x), div(max, 3)))\r\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\r\n            x := and(add(x, shr(4, x)), div(max, 17))\r\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns whether `x` is a power of 2.\r\n    function isPo2(uint256 x) internal pure returns (bool result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Equivalent to `x && !(x & (x - 1))`.\r\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x` reversed at the bit level.\r\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\r\n        uint256 m0 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\r\n        uint256 m1 = m0 ^ (m0 << 2);\r\n        uint256 m2 = m1 ^ (m1 << 1);\r\n        r = reverseBytes(x);\r\n        r = (m2 & (r >> 1)) | ((m2 & r) << 1);\r\n        r = (m1 & (r >> 2)) | ((m1 & r) << 2);\r\n        r = (m0 & (r >> 4)) | ((m0 & r) << 4);\r\n    }\r\n\r\n    /// @dev Returns `x` reversed at the byte level.\r\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\r\n        unchecked {\r\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\r\n            uint256 m0 = 0x100000000000000000000000000000001 * (~toUint(x == 0) >> 192);\r\n            uint256 m1 = m0 ^ (m0 << 32);\r\n            uint256 m2 = m1 ^ (m1 << 16);\r\n            uint256 m3 = m2 ^ (m2 << 8);\r\n            r = (m3 & (x >> 8)) | ((m3 & x) << 8);\r\n            r = (m2 & (r >> 16)) | ((m2 & r) << 16);\r\n            r = (m1 & (r >> 32)) | ((m1 & r) << 32);\r\n            r = (m0 & (r >> 64)) | ((m0 & r) << 64);\r\n            r = (r >> 128) | (r << 128);\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     BOOLEAN OPERATIONS                     */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\r\n    // Non-zero values are true, zero is false.\r\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\r\n    // Usually, if not always, the bool result of a regular Solidity expression,\r\n    // or the argument of a public/external function will be a clean bool.\r\n    // You can usually use the raw variants for more performance.\r\n    // If uncertain, test (best with exact compiler settings).\r\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\r\n\r\n    /// @dev Returns `x & y`. Inputs must be clean.\r\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := and(x, y)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x & y`.\r\n    function and(bool x, bool y) internal pure returns (bool z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x | y`. Inputs must be clean.\r\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := or(x, y)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns `x | y`.\r\n    function or(bool x, bool y) internal pure returns (bool z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\r\n    function rawToUint(bool b) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := b\r\n        }\r\n    }\r\n\r\n    /// @dev Returns 1 if `b` is true, else 0.\r\n    function toUint(bool b) internal pure returns (uint256 z) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            z := iszero(iszero(b))\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Library for storage of packed unsigned booleans.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBitmap.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibBitmap.sol)\r\n/// @author Modified from Solidity-Bits (https://github.com/estarriolvetch/solidity-bits/blob/main/contracts/BitMaps.sol)\r\nlibrary LibBitmap {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The constant returned when a bitmap scan does not find a result.\r\n    uint256 internal constant NOT_FOUND = type(uint256).max;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STRUCTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev A bitmap in storage.\r\n    struct Bitmap {\r\n        mapping(uint256 => uint256) map;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         OPERATIONS                         */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the boolean value of the bit at `index` in `bitmap`.\r\n    function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\r\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\r\n        // Both cost the same amount of gas, but the former allows the returned value\r\n        // to be reused without cleaning the upper bits.\r\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            isSet := b\r\n        }\r\n    }\r\n\r\n    /// @dev Updates the bit at `index` in `bitmap` to true.\r\n    function set(Bitmap storage bitmap, uint256 index) internal {\r\n        bitmap.map[index >> 8] |= (1 << (index & 0xff));\r\n    }\r\n\r\n    /// @dev Updates the bit at `index` in `bitmap` to false.\r\n    function unset(Bitmap storage bitmap, uint256 index) internal {\r\n        bitmap.map[index >> 8] &= ~(1 << (index & 0xff));\r\n    }\r\n\r\n    /// @dev Flips the bit at `index` in `bitmap`.\r\n    /// Returns the boolean result of the flipped bit.\r\n    function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, bitmap.slot)\r\n            mstore(0x00, shr(8, index))\r\n            let storageSlot := keccak256(0x00, 0x40)\r\n            let shift := and(index, 0xff)\r\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\r\n            // It makes sense to return the `newIsSet`,\r\n            // as it allow us to skip an additional warm `sload`,\r\n            // and it costs minimal gas (about 15),\r\n            // which may be optimized away if the returned value is unused.\r\n            newIsSet := and(1, shr(shift, storageValue))\r\n            sstore(storageSlot, storageValue)\r\n        }\r\n    }\r\n\r\n    /// @dev Updates the bit at `index` in `bitmap` to `shouldSet`.\r\n    function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, bitmap.slot)\r\n            mstore(0x00, shr(8, index))\r\n            let storageSlot := keccak256(0x00, 0x40)\r\n            let storageValue := sload(storageSlot)\r\n            let shift := and(index, 0xff)\r\n            sstore(\r\n                storageSlot,\r\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\r\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Consecutively sets `amount` of bits starting from the bit at `start`.\r\n    function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let max := not(0)\r\n            let shift := and(start, 0xff)\r\n            mstore(0x20, bitmap.slot)\r\n            mstore(0x00, shr(8, start))\r\n            if iszero(lt(add(shift, amount), 257)) {\r\n                let storageSlot := keccak256(0x00, 0x40)\r\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\r\n                let bucket := add(mload(0x00), 1)\r\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\r\n                amount := and(add(amount, shift), 0xff)\r\n                shift := 0\r\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\r\n                    mstore(0x00, bucket)\r\n                    sstore(keccak256(0x00, 0x40), max)\r\n                }\r\n                mstore(0x00, bucket)\r\n            }\r\n            let storageSlot := keccak256(0x00, 0x40)\r\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\r\n        }\r\n    }\r\n\r\n    /// @dev Consecutively unsets `amount` of bits starting from the bit at `start`.\r\n    function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let shift := and(start, 0xff)\r\n            mstore(0x20, bitmap.slot)\r\n            mstore(0x00, shr(8, start))\r\n            if iszero(lt(add(shift, amount), 257)) {\r\n                let storageSlot := keccak256(0x00, 0x40)\r\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\r\n                let bucket := add(mload(0x00), 1)\r\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\r\n                amount := and(add(amount, shift), 0xff)\r\n                shift := 0\r\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\r\n                    mstore(0x00, bucket)\r\n                    sstore(keccak256(0x00, 0x40), 0)\r\n                }\r\n                mstore(0x00, bucket)\r\n            }\r\n            let storageSlot := keccak256(0x00, 0x40)\r\n            sstore(\r\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @dev Returns number of set bits within a range by\r\n    /// scanning `amount` of bits starting from the bit at `start`.\r\n    function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\r\n        internal\r\n        view\r\n        returns (uint256 count)\r\n    {\r\n        unchecked {\r\n            uint256 bucket = start >> 8;\r\n            uint256 shift = start & 0xff;\r\n            if (!(amount + shift < 257)) {\r\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\r\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\r\n                amount = (amount + shift) & 0xff;\r\n                shift = 0;\r\n                for (++bucket; bucket != bucketEnd; ++bucket) {\r\n                    count += LibBit.popCount(bitmap.map[bucket]);\r\n                }\r\n            }\r\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the index of the most significant set bit before the bit at `before`.\r\n    /// If no set bit is found, returns `NOT_FOUND`.\r\n    function findLastSet(Bitmap storage bitmap, uint256 before)\r\n        internal\r\n        view\r\n        returns (uint256 setBitIndex)\r\n    {\r\n        uint256 bucket;\r\n        uint256 bucketBits;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            setBitIndex := not(0)\r\n            bucket := shr(8, before)\r\n            mstore(0x00, bucket)\r\n            mstore(0x20, bitmap.slot)\r\n            let offset := and(0xff, not(before)) // `256 - (255 & before) - 1`.\r\n            bucketBits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\r\n            if iszero(or(bucketBits, iszero(bucket))) {\r\n                for {} 1 {} {\r\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\r\n                    mstore(0x00, bucket)\r\n                    bucketBits := sload(keccak256(0x00, 0x40))\r\n                    if or(bucketBits, iszero(bucket)) { break }\r\n                }\r\n            }\r\n        }\r\n        if (bucketBits != 0) {\r\n            setBitIndex = (bucket << 8) | LibBit.fls(bucketBits);\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, before)))\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERCX is Context, ERC165, IERC1155, IERC1155MetadataURI, IERCX, IERC20Metadata, IERC20Errors, Ownable {\r\n\r\n    using Address for address;\r\n    using LibBitmap for LibBitmap.Bitmap;\r\n\r\n    error InvalidQueryRange();\r\n\r\n    // The mask of the lower 160 bits for addresses.\r\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\r\n    // The `Transfer` event signature is given by:\r\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE = 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    // Mapping from accout to owned tokens\r\n    mapping(address => LibBitmap.Bitmap) internal _owned;\r\n    \r\n    // Mapping from account to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string private _uri;\r\n\r\n    // The next token ID to be minted.\r\n    uint256 private _currentIndex;\r\n\r\n    // NFT Approval\r\n    mapping(uint256 => address) public getApproved;\r\n\r\n    //Token balances\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    //Token allowances\r\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\r\n    \r\n    // Token name\r\n    string public name;\r\n\r\n    // Token symbol\r\n    string public symbol;\r\n\r\n    // Decimals for supply\r\n    uint8 public immutable decimals;\r\n\r\n    // Total ERC20 supply\r\n    uint256 public immutable totalSupply;\r\n\r\n    // Tokens Per NFT\r\n    uint256 public immutable decimalFactor;\r\n    uint256 public immutable tokensPerNFT;\r\n\r\n    // Don't mint for these wallets\r\n    mapping(address => bool) public whitelist;\r\n\r\n    // Easy Launch - auto-whitelist first transfer which is probably the LP\r\n    uint256 public easyLaunch = 1;\r\n\r\n    /**\r\n     * @dev See {_setURI}.\r\n     */\r\n    constructor(string memory uri_, string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalNativeSupply, uint256 _tokensPerNFT) Ownable(msg.sender) {\r\n        _setURI(uri_);\r\n        _currentIndex = _startTokenId();\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        decimalFactor = 10 ** decimals;\r\n        tokensPerNFT = _tokensPerNFT * decimalFactor;\r\n        totalSupply = _totalNativeSupply * decimalFactor;\r\n        whitelist[msg.sender] = true;\r\n        _balances[msg.sender] = totalSupply;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    /** @notice Initialization function to set pairs / etc\r\n     *  saving gas by avoiding mint / burn on unnecessary targets\r\n     */\r\n    function setWhitelist(address target, bool state) public virtual onlyOwner {\r\n        whitelist[target] = state;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the starting token ID.\r\n     * To change the starting token ID, please override this function.\r\n     */\r\n    function _startTokenId() internal pure virtual returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the next token ID to be minted.\r\n     */\r\n    function _nextTokenId() internal view returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens minted in the contract.\r\n     */\r\n    function _totalMinted() internal view returns (uint256) {\r\n        return _nextTokenId() - _startTokenId();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the account owns the `id` token.\r\n     */\r\n    function isOwnerOf(address account, uint256 id) public view virtual override returns(bool) {\r\n        return _owned[account].get(id);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            interfaceId == type(IERCX).interfaceId ||\r\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\r\n            interfaceId == 0x5b5e139f || // ERC165 interface ID for ERC721Metadata.\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155MetadataURI-uri}.\r\n     *\r\n     * This implementation returns the same URI for *all* token types. It relies\r\n     * on the token type ID substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * Clients calling this function must replace the `\\{id\\}` substring with the\r\n     * actual token type ID.\r\n     */\r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of tokens owned by `owner`.\r\n     */\r\n    function balanceOf(address owner) public view virtual returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of nfts owned by `owner`,\r\n     * in the range [`start`, `stop`)\r\n     * (i.e. `start <= tokenId < stop`).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `start < stop`\r\n     */\r\n    function balanceOf(address owner, uint256 start, uint256 stop) public view virtual returns (uint256) {\r\n        return _owned[owner].popCount(start, stop - start);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        if(account == address(0)) {\r\n            revert BalanceQueryForZeroAddress();\r\n        }\r\n        if(_owned[account].get(id)) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }   \r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOfBatch}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        if(accounts.length != ids.length) {\r\n            revert InputLengthMistmatch();\r\n        }\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        if(from == _msgSender() || isApprovedForAll(from, _msgSender())){\r\n            _safeTransferFrom(from, to, id, amount, data, true);\r\n        } else {\r\n            revert TransferCallerNotOwnerNorApproved();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        if(!(from == _msgSender() || isApprovedForAll(from, _msgSender()))) {\r\n            revert TransferCallerNotOwnerNorApproved();\r\n        }\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `amount` cannot be zero.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bool check\r\n    ) internal virtual {\r\n        if(to == address(0)) {\r\n            revert TransferToZeroAddress();\r\n        }\r\n\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids);\r\n\r\n        if(amount == 1 && _owned[from].get(id)) {\r\n            _owned[from].unset(id);\r\n            _owned[to].set(id);\r\n            _transfer(from, to, tokensPerNFT, false);\r\n        } else {\r\n            revert TransferFromIncorrectOwnerOrInvalidAmount();\r\n        }\r\n\r\n        uint256 toMasked;\r\n        uint256 fromMasked;\r\n        assembly {\r\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            toMasked := and(to, _BITMASK_ADDRESS)\r\n            fromMasked := and(from, _BITMASK_ADDRESS)\r\n            // Emit the `Transfer` event.\r\n            log4(\r\n                0, // Start of data (0, since no data).\r\n                0, // End of data (0, since no data).\r\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\r\n                fromMasked, // `from`.\r\n                toMasked, // `to`.\r\n                amount // `tokenId`.\r\n            )\r\n        }\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _afterTokenTransfer(operator, from, to, ids);\r\n\r\n        if(check)\r\n            _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        if(ids.length != amounts.length) {\r\n            revert InputLengthMistmatch();\r\n        }\r\n\r\n        if(to == address(0)) {\r\n            revert TransferToZeroAddress();\r\n        }\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            if(amount == 1 && _owned[from].get(id)) {\r\n                _owned[from].unset(id);\r\n                _owned[to].set(id);\r\n            } else {\r\n                revert TransferFromIncorrectOwnerOrInvalidAmount();\r\n            }\r\n        }\r\n        _transfer(from, to, tokensPerNFT * ids.length, false);\r\n\r\n        uint256 toMasked;\r\n        uint256 fromMasked;\r\n        uint256 end = ids.length + 1;\r\n\r\n        // Use assembly to loop and emit the `Transfer` event for gas savings.\r\n        // The duplicated `log4` removes an extra check and reduces stack juggling.\r\n        // The assembly, together with the surrounding Solidity code, have been\r\n        // delicately arranged to nudge the compiler into producing optimized opcodes.\r\n        assembly {\r\n            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\r\n            fromMasked := and(from, _BITMASK_ADDRESS)\r\n            toMasked := and(to, _BITMASK_ADDRESS)\r\n            // Emit the `Transfer` event.\r\n            log4(\r\n                0, // Start of data (0, since no data).\r\n                0, // End of data (0, since no data).\r\n                _TRANSFER_EVENT_SIGNATURE, // Signature.\r\n                fromMasked, // `from`.\r\n                toMasked, // `to`.\r\n                mload(add(ids, 0x20)) // `tokenId`.\r\n            )\r\n\r\n            // The `iszero(eq(,))` check ensures that large values of `quantity`\r\n            // that overflows uint256 will make the loop run out of gas.\r\n            // The compiler will optimize the `iszero` away for performance.\r\n            for {\r\n                let arrayId := 2\r\n            } iszero(eq(arrayId, end)) {\r\n                arrayId := add(arrayId, 1)\r\n            } {\r\n                // Emit the `Transfer` event. Similar to above.\r\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, fromMasked, toMasked, mload(add(ids, mul(0x20, arrayId))))\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _afterTokenTransfer(operator, from, to, ids);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new URI for all token types, by relying on the token type ID\r\n     * substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\r\n     * clients with the token type ID.\r\n     *\r\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n     * interpreted by clients as\r\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n     * for token type ID 0x4cce0.\r\n     *\r\n     * See {uri}.\r\n     *\r\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n     * this function emits no events.\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        _mint(to, amount, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens, and assigns them to `to`.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `amount` cannot be zero.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mint(\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n       (uint256[] memory ids, uint256[] memory amounts) =  _mintWithoutCheck(to, amount);\r\n\r\n        uint256 end = _currentIndex;\r\n        _doSafeBatchTransferAcceptanceCheck(_msgSender(), address(0), to, ids, amounts, data);\r\n        if (_currentIndex != end) revert();\r\n    }\r\n\r\n    function _mintWithoutCheck(\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual returns(uint256[] memory ids, uint256[] memory amounts) {\r\n\r\n        if(to == address(0)) {\r\n            revert MintToZeroAddress();\r\n        }\r\n        if(amount == 0) {\r\n            revert MintZeroQuantity();\r\n        }\r\n\r\n        address operator = _msgSender();\r\n\r\n        ids = new uint256[](amount);\r\n        amounts = new uint256[](amount);\r\n        uint256 startTokenId = _nextTokenId();\r\n\r\n        unchecked {\r\n            require(type(uint256).max - amount >= startTokenId);\r\n            for(uint256 i = 0; i < amount; i++) {\r\n                ids[i] = startTokenId + i;\r\n                amounts[i] = 1;\r\n            }\r\n        }\r\n        \r\n        _beforeTokenTransfer(operator, address(0), to, ids);\r\n\r\n        _owned[to].setBatch(startTokenId, amount);\r\n        _currentIndex += amount;\r\n\r\n        uint256 toMasked;\r\n        uint256 end = startTokenId + amount;\r\n\r\n        assembly {\r\n            toMasked := and(to, _BITMASK_ADDRESS)\r\n            log4(\r\n                0,\r\n                0,\r\n                _TRANSFER_EVENT_SIGNATURE,\r\n                0,\r\n                toMasked,\r\n                startTokenId\r\n            )\r\n\r\n            for {\r\n                let tokenId := add(startTokenId, 1)\r\n            } iszero(eq(tokenId, end)) {\r\n                tokenId := add(tokenId, 1)\r\n            } {\r\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _afterTokenTransfer(operator, address(0), to, ids);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys token of token type `id` from `from`\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `from` must have the token of token type `id`.\r\n     */\r\n    function _burn(\r\n        address from,\r\n        uint256 id\r\n    ) internal virtual {\r\n        if(from == address(0)){\r\n            revert BurnFromZeroAddress();\r\n        }\r\n\r\n        address operator = _msgSender();\r\n        uint256[] memory ids = _asSingletonArray(id);\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids);\r\n\r\n        if(!_owned[from].get(id)) {\r\n            revert BurnFromNonOnwerAddress();\r\n        }\r\n\r\n        _owned[from].unset(id);\r\n\r\n        uint256 fromMasked;\r\n        assembly {\r\n            fromMasked := and(from, _BITMASK_ADDRESS)\r\n            log4(\r\n                0,\r\n                0,\r\n                _TRANSFER_EVENT_SIGNATURE,\r\n                fromMasked,\r\n                0,\r\n                id\r\n            )\r\n        }\r\n\r\n        emit TransferSingle(operator, from, address(0), id, 1);\r\n\r\n        _afterTokenTransfer(operator, from, address(0), ids);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys tokens of token types in `ids` from `from`\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `from` must have the token of token types in `ids`.\r\n     */\r\n    function _burnBatch(\r\n        address from,\r\n        uint256[] memory ids\r\n    ) internal virtual {\r\n        if(from == address(0)){\r\n            revert BurnFromZeroAddress();\r\n        }\r\n\r\n        address operator = _msgSender();\r\n\r\n        uint256[] memory amounts = new uint256[](ids.length);\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), ids);\r\n\r\n        unchecked {\r\n            for(uint256 i = 0; i < ids.length; i++) {\r\n                amounts[i] = 1;\r\n                uint256 id = ids[i];\r\n                if(!_owned[from].get(id)) {\r\n                    revert BurnFromNonOnwerAddress();\r\n                }\r\n                _owned[from].unset(id);\r\n            }\r\n        }\r\n\r\n        uint256 fromMasked;\r\n        uint256 end = ids.length + 1;\r\n\r\n        assembly {\r\n            fromMasked := and(from, _BITMASK_ADDRESS)\r\n            log4(\r\n                0,\r\n                0,\r\n                _TRANSFER_EVENT_SIGNATURE,\r\n                fromMasked,\r\n                0,\r\n                mload(add(ids, 0x20))\r\n            )\r\n\r\n            for {\r\n                let arrayId := 2\r\n            } iszero(eq(arrayId, end)) {\r\n                arrayId := add(arrayId, 1)\r\n            } {\r\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, fromMasked, 0, mload(add(ids, mul(0x20, arrayId))))\r\n            }\r\n        }\r\n        \r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n\r\n        _afterTokenTransfer(operator, from, address(0), ids);\r\n\r\n    }\r\n\r\n    function _burnBatch(\r\n        address from,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        if(from == address(0)){\r\n            revert BurnFromZeroAddress();\r\n        }\r\n\r\n        address operator = _msgSender();\r\n\r\n        uint256 searchFrom = _nextTokenId();\r\n\r\n        uint256[] memory amounts = new uint256[](amount);\r\n        uint256[] memory ids = new uint256[](amount);\r\n\r\n        unchecked {\r\n            for(uint256 i = 0; i < amount; i++) {\r\n                amounts[i] = 1;\r\n                uint256 id = _owned[from].findLastSet(searchFrom);\r\n                ids[i] = id;\r\n                _owned[from].unset(id);\r\n                searchFrom = id;\r\n            }\r\n        }\r\n\r\n        //technically after, but we didn't have the IDs then\r\n        _beforeTokenTransfer(operator, from, address(0), ids);\r\n\r\n        uint256 fromMasked;\r\n        uint256 end = amount + 1;\r\n\r\n        assembly {\r\n            fromMasked := and(from, _BITMASK_ADDRESS)\r\n            log4(\r\n                0,\r\n                0,\r\n                _TRANSFER_EVENT_SIGNATURE,\r\n                fromMasked,\r\n                0,\r\n                mload(add(ids, 0x20))\r\n            )\r\n\r\n            for {\r\n                let arrayId := 2\r\n            } iszero(eq(arrayId, end)) {\r\n                arrayId := add(arrayId, 1)\r\n            } {\r\n                log4(0, 0, _TRANSFER_EVENT_SIGNATURE, fromMasked, 0, mload(add(ids, mul(0x20, arrayId))))\r\n            }\r\n        }\r\n\r\n        if(amount == 1)\r\n            emit TransferSingle(operator, from, address(0), ids[0], 1);\r\n        else\r\n            emit TransferBatch(operator, from, address(0), ids, amounts);\r\n        \r\n\r\n        _afterTokenTransfer(operator, from, address(0), ids);\r\n\r\n    }\r\n\r\n\r\n     /**\r\n     * @dev Approve `operator` to operate on all of `owner` tokens\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) internal virtual {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `id` and `amount` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids\r\n    ) internal virtual {}\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            if (IERC165(to).supportsInterface(type(IERC1155).interfaceId)) {\r\n                try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                    if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                        revert TransferToNonERC1155ReceiverImplementer();\r\n                    }\r\n                } catch Error(string memory reason) {\r\n                    revert(reason);\r\n                } catch {\r\n                    revert TransferToNonERC1155ReceiverImplementer();\r\n                }\r\n            }\r\n            else {\r\n                try ERC721Receiver(to).onERC721Received(operator, from, id, data) returns (bytes4 response) {\r\n                    if (response != ERC721Receiver.onERC721Received.selector) {\r\n                        revert TransferToNonERC721ReceiverImplementer();\r\n                    }\r\n                } catch Error(string memory reason) {\r\n                    revert(reason);\r\n                } catch {\r\n                    revert TransferToNonERC721ReceiverImplementer();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert TransferToNonERC1155ReceiverImplementer();\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert TransferToNonERC1155ReceiverImplementer();\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory array) {\r\n        array = new uint256[](1);\r\n        array[0] = element;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public virtual returns (bool) {\r\n        address owner = msg.sender;\r\n        _transfer(owner, to, value, true);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public virtual returns (bool) {\r\n        address owner = msg.sender;\r\n        if (value < _nextTokenId() && value > 0) {\r\n\r\n            if(!isOwnerOf(owner, value)) {\r\n                revert ERC20InvalidSender(owner);\r\n            }\r\n\r\n            getApproved[value] = spender;\r\n\r\n            emit Approval(owner, spender, value);\r\n        } else {\r\n            _approve(owner, spender, value);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @notice Function for mixed transfers\r\n    /// @dev This function assumes id / native if amount less than or equal to current max id\r\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\r\n        if (value < _nextTokenId()) {\r\n            if(!_owned[from].get(value)) {\r\n                revert ERC20InvalidSpender(from);\r\n            }    \r\n\r\n            if (\r\n                msg.sender != from &&\r\n                !isApprovedForAll(from, msg.sender) &&\r\n                msg.sender != getApproved[value]\r\n            ) {\r\n                revert ERC20InvalidSpender(msg.sender);\r\n            }\r\n\r\n            _transfer(from, to, tokensPerNFT, false);\r\n\r\n            delete getApproved[value];\r\n\r\n            _safeTransferFrom(from, to, value, 1, \"\", false);\r\n\r\n        } else {\r\n            _spendAllowance(from, msg.sender, value);\r\n            _transfer(from, to, value, true);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 value, bool mint) internal {\r\n        if (from == address(0)) {\r\n            revert ERC20InvalidSender(address(0));\r\n        }\r\n        if (to == address(0)) {\r\n            revert ERC20InvalidReceiver(address(0));\r\n        }\r\n        _update(from, to, value, mint);\r\n    }\r\n\r\n    function _update(address from, address to, uint256 value, bool mint) internal virtual {\r\n        uint256 fromBalance = _balances[from];\r\n        uint256 toBalance = _balances[to];\r\n        if (fromBalance < value) {\r\n            revert ERC20InsufficientBalance(from, fromBalance, value);\r\n        }\r\n\r\n        unchecked {\r\n            // Overflow not possible: value <= fromBalance <= totalSupply.\r\n            _balances[from] = fromBalance - value;\r\n\r\n            // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\r\n            _balances[to] = toBalance + value;\r\n        }\r\n\r\n        emit Transfer(from, to, value);\r\n\r\n        if(mint) {\r\n            // Skip burn for certain addresses to save gas\r\n            bool wlf = whitelist[from];\r\n            if (!wlf) {\r\n                uint256 tokens_to_burn = (fromBalance / tokensPerNFT) - ((fromBalance - value) / tokensPerNFT);\r\n                if(tokens_to_burn > 0)\r\n                    _burnBatch(from, tokens_to_burn);\r\n            }\r\n\r\n            // Skip minting for certain addresses to save gas\r\n            if (!whitelist[to]) {\r\n                if(easyLaunch == 1 && wlf && from == owner()) {\r\n                    //auto-initialize first (assumed) LP\r\n                    whitelist[to] = true;\r\n                    easyLaunch = 2;\r\n                } else {\r\n                    uint256 tokens_to_mint = ((toBalance + value) / tokensPerNFT) - (toBalance / tokensPerNFT);\r\n                    if(tokens_to_mint > 0)\r\n                        _mintWithoutCheck(to, tokens_to_mint);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        _approve(owner, spender, value, true);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\r\n        if (owner == address(0)) {\r\n            revert ERC20InvalidApprover(address(0));\r\n        }\r\n        if (spender == address(0)) {\r\n            revert ERC20InvalidSpender(address(0));\r\n        }\r\n        _allowances[owner][spender] = value;\r\n        if (emitEvent) {\r\n            emit Approval(owner, spender, value);\r\n        }\r\n    }\r\n\r\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            if (currentAllowance < value) {\r\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\r\n            }\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - value, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array of token IDs owned by `owner`,\r\n     * in the range [`start`, `stop`)\r\n     * (i.e. `start <= tokenId < stop`).\r\n     *\r\n     * This function allows for tokens to be queried if the collection\r\n     * grows too big for a single call of {ERC1155DelataQueryable-tokensOfOwner}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `start < stop`\r\n     */\r\n    function tokensOfOwnerIn(\r\n        address owner,\r\n        uint256 start,\r\n        uint256 stop\r\n    ) public view virtual returns (uint256[] memory) {\r\n        unchecked {\r\n            if (start >= stop) revert InvalidQueryRange();\r\n            \r\n            \r\n            // Set `start = max(start, _startTokenId())`.\r\n            if (start < _startTokenId()) {\r\n                start = _startTokenId();\r\n            }\r\n            \r\n            // Set `stop = min(stop, stopLimit)`.\r\n            uint256 stopLimit = _nextTokenId();\r\n            if (stop > stopLimit) {\r\n                stop = stopLimit;\r\n            }\r\n\r\n            uint256 tokenIdsLength;\r\n            if(start < stop) {\r\n                tokenIdsLength = balanceOf(owner, start, stop);\r\n            } else {\r\n                tokenIdsLength = 0;\r\n            }\r\n            \r\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\r\n\r\n            LibBitmap.Bitmap storage bmap = _owned[owner];\r\n            \r\n            for ((uint256 i, uint256 tokenIdsIdx) = (start, 0); tokenIdsIdx != tokenIdsLength; ++i) {\r\n                if(bmap.get(i) ) {\r\n                    tokenIds[tokenIdsIdx++] = i;\r\n                }\r\n            }\r\n            return tokenIds;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an array of token IDs owned by `owner`.\r\n     *\r\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\r\n     * It is meant to be called off-chain.\r\n     *\r\n     * See {ERC1155DeltaQueryable-tokensOfOwnerIn} for splitting the scan into\r\n     * multiple smaller scans if the collection is large enough to cause\r\n     * an out-of-gas error (10K collections should be fine).\r\n     */\r\n    function tokensOfOwner(address owner) public view virtual returns (uint256[] memory) {\r\n        if(_totalMinted() == 0) {\r\n            return new uint256[](0);\r\n        }\r\n        return tokensOfOwnerIn(owner, _startTokenId(), _nextTokenId());\r\n    }\r\n}\r\n\r\ncontract NFL_ERCND_404 is ERCX {\r\n    using Strings for uint256;\r\n    string public dataURI;\r\n    string public baseTokenURI;\r\n    \r\n    uint8 private constant _decimals = 18;\r\n    uint256 private constant _totalTokens = 10000;\r\n    uint256 private constant _tokensPerNFT = 1;\r\n    string private constant _name = \"NFL-ERCND-404\";\r\n    string private constant _ticker = \"NFL\";\r\n\r\n    // Snipe reduction tools\r\n    uint256 public maxWallet;\r\n    bool public transferDelay = true;\r\n    mapping (address => uint256) private delayTimer;\r\n\r\n    constructor() ERCX(\"\", _name, _ticker, _decimals, _totalTokens, _tokensPerNFT) {\r\n        dataURI = \"https://i.ibb.co/\";\r\n        maxWallet = (_totalTokens * 10 ** _decimals) * 2 / 100;\r\n    }\r\n\r\n    function _afterTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids\r\n    ) internal override {\r\n        if(!whitelist[to]) {\r\n            require(_balances[to] <= maxWallet, \"Transfer exceeds maximum wallet\");\r\n            if (transferDelay) {\r\n                require(delayTimer[tx.origin] < block.number,\"Only one transfer per block allowed.\");\r\n                delayTimer[tx.origin] = block.number;\r\n\r\n                require(address(to).code.length == 0 && address(tx.origin).code.length == 0, \"Contract trading restricted at launch\");\r\n            }\r\n        }\r\n        \r\n        \r\n        super._afterTokenTransfer(operator, from, to, ids);\r\n    }\r\n\r\n    function toggleDelay() external onlyOwner {\r\n        transferDelay = !transferDelay;\r\n    }\r\n\r\n    function setMaxWallet(uint256 percent) external onlyOwner {\r\n        maxWallet = totalSupply * percent / 100;\r\n    }\r\n\r\n    function setDataURI(string memory _dataURI) public onlyOwner {\r\n        dataURI = _dataURI;\r\n    }\r\n\r\n    function setTokenURI(string memory _tokenURI) public onlyOwner {\r\n        baseTokenURI = _tokenURI;\r\n    }\r\n\r\n    function setURI(string memory newuri) external onlyOwner {\r\n        _setURI(newuri);\r\n    }\r\n\r\n    function tokenURI(uint256 id) public view returns (string memory) {\r\n        if(id >= _nextTokenId()) revert InputLengthMistmatch();\r\n\r\n        if (bytes(super.uri(id)).length > 0)\r\n            return super.uri(id);\r\n        if (bytes(baseTokenURI).length > 0)\r\n            return string(abi.encodePacked(baseTokenURI, id.toString()));\r\n        else {\r\n            uint8 seed = uint8(bytes1(keccak256(abi.encodePacked(id))));\r\n\r\n            string memory image;\r\n            string memory color;\r\n            string memory description;\r\n\r\n            if (seed <= 63) {\r\n                image = \"GQRhWyF/Diamond.jpg\";\r\n                color = \"Diamond\";\r\n                description = \"Legendary NFTs powered by ERC1155. The Diamond NFTs are meticulously mined by industry elites and crafted with unparalleled precision, representing the zenith of luxury and digital artistry.\";\r\n            } else if (seed <= 127) {\r\n                image = \"gwdLf3f/Gold.jpg\";\r\n                color = \"Gold\";\r\n                description = \"Prestigious NFTs powered by ERC1155. The gold NFTs are carefully mined by expert collectors and meticulously crafted with golden excellence, symbolizing the pinnacle of digital rarity and exclusivity.\";\r\n            } else if (seed <= 191) {\r\n                image = \"FJmdrdm/Silver.jpg\";\r\n                color = \"Silver\";\r\n                description = \"Refined NFTs powered by ERC1155. The silver NFTs are mined by seasoned enthusiasts, adding an extra layer of sophistication to your portfolio.\";\r\n            } else if (seed <= 255) {\r\n                image = \"YLG3Jvc/Bronze.jpg\";\r\n                color = \"Bronze\";\r\n                description = \"Entry level NFTs powered by ERC1155. The silver NFTs are mined by aspiring collectors and meticulously crafted for accessibility.\";\r\n            }\r\n\r\n            string memory jsonPreImage = string(abi.encodePacked('{\"name\": \"WINER #', id.toString(), '\",\"description\":\"', description, '\",\"external_url\":\"https://miner.build\",\"image\":\"', dataURI, image));\r\n            return string(abi.encodePacked(\"data:application/json;utf8,\", jsonPreImage, '\",\"attributes\":[{\"trait_type\":\"Color\",\"value\":\"', color, '\"}]}'));\r\n        }\r\n    }\r\n\r\n    function uri(uint256 id) public view override returns (string memory) {\r\n        return tokenURI(id);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnFromNonOnwerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BurnFromZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"ERC20InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ERC20InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSender\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"ERC20InvalidSpender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InputLengthMistmatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidQueryRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwnerOrInvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC1155ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimalFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"easyLaunch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"isOwnerOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_dataURI\",\"type\":\"string\"}],\"name\":\"setDataURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newuri\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stop\",\"type\":\"uint256\"}],\"name\":\"tokensOfOwnerIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NFL_ERCND_404", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9e3afb3651f1ccb66377c91c3dc84aba09bd01d49d37899c5da2eec423755b37"}