{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CometMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Compound's Comet Math Contract\\n * @dev Pure math functions\\n * @author Compound\\n */\\ncontract CometMath {\\n    /** Custom errors **/\\n\\n    error InvalidUInt64();\\n    error InvalidUInt104();\\n    error InvalidUInt128();\\n    error InvalidInt104();\\n    error InvalidInt256();\\n    error NegativeNumber();\\n\\n    function safe64(uint n) internal pure returns (uint64) {\\n        if (n > type(uint64).max) revert InvalidUInt64();\\n        return uint64(n);\\n    }\\n\\n    function safe104(uint n) internal pure returns (uint104) {\\n        if (n > type(uint104).max) revert InvalidUInt104();\\n        return uint104(n);\\n    }\\n\\n    function safe128(uint n) internal pure returns (uint128) {\\n        if (n > type(uint128).max) revert InvalidUInt128();\\n        return uint128(n);\\n    }\\n\\n    function signed104(uint104 n) internal pure returns (int104) {\\n        if (n > uint104(type(int104).max)) revert InvalidInt104();\\n        return int104(n);\\n    }\\n\\n    function signed256(uint256 n) internal pure returns (int256) {\\n        if (n > uint256(type(int256).max)) revert InvalidInt256();\\n        return int256(n);\\n    }\\n\\n    function unsigned104(int104 n) internal pure returns (uint104) {\\n        if (n < 0) revert NegativeNumber();\\n        return uint104(n);\\n    }\\n\\n    function unsigned256(int256 n) internal pure returns (uint256) {\\n        if (n < 0) revert NegativeNumber();\\n        return uint256(n);\\n    }\\n\\n    function toUInt8(bool x) internal pure returns (uint8) {\\n        return x ? 1 : 0;\\n    }\\n\\n    function toBool(uint8 x) internal pure returns (bool) {\\n        return x != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CometStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Compound's Comet Storage Interface\\n * @dev Versions can enforce append-only storage slots via inheritance.\\n * @author Compound\\n */\\ncontract CometStorage {\\n    // 512 bits total = 2 slots\\n    struct TotalsBasic {\\n        // 1st slot\\n        uint64 baseSupplyIndex;\\n        uint64 baseBorrowIndex;\\n        uint64 trackingSupplyIndex;\\n        uint64 trackingBorrowIndex;\\n        // 2nd slot\\n        uint104 totalSupplyBase;\\n        uint104 totalBorrowBase;\\n        uint40 lastAccrualTime;\\n        uint8 pauseFlags;\\n    }\\n\\n    struct TotalsCollateral {\\n        uint128 totalSupplyAsset;\\n        uint128 _reserved;\\n    }\\n\\n    struct UserBasic {\\n        int104 principal;\\n        uint64 baseTrackingIndex;\\n        uint64 baseTrackingAccrued;\\n        uint16 assetsIn;\\n        uint8 _reserved;\\n    }\\n\\n    struct UserCollateral {\\n        uint128 balance;\\n        uint128 _reserved;\\n    }\\n\\n    struct LiquidatorPoints {\\n        uint32 numAbsorbs;\\n        uint64 numAbsorbed;\\n        uint128 approxSpend;\\n        uint32 _reserved;\\n    }\\n\\n    /// @dev Aggregate variables tracked for the entire market\\n    uint64 internal baseSupplyIndex;\\n    uint64 internal baseBorrowIndex;\\n    uint64 internal trackingSupplyIndex;\\n    uint64 internal trackingBorrowIndex;\\n    uint104 internal totalSupplyBase;\\n    uint104 internal totalBorrowBase;\\n    uint40 internal lastAccrualTime;\\n    uint8 internal pauseFlags;\\n\\n    /// @notice Aggregate variables tracked for each collateral asset\\n    mapping(address => TotalsCollateral) public totalsCollateral;\\n\\n    /// @notice Mapping of users to accounts which may be permitted to manage the user account\\n    mapping(address => mapping(address => bool)) public isAllowed;\\n\\n    /// @notice The next expected nonce for an address, for validating authorizations via signature\\n    mapping(address => uint) public userNonce;\\n\\n    /// @notice Mapping of users to base principal and other basic data\\n    mapping(address => UserBasic) public userBasic;\\n\\n    /// @notice Mapping of users to collateral data per collateral asset\\n    mapping(address => mapping(address => UserCollateral)) public userCollateral;\\n\\n    /// @notice Mapping of magic liquidator points\\n    mapping(address => LiquidatorPoints) public liquidatorPoints;\\n}\\n\"\r\n    },\r\n    \"contracts/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @title ERC 20 Token Standard Interface\\n *  https://eips.ethereum.org/EIPS/eip-20\\n */\\ninterface ERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n      * @notice Get the total number of tokens in circulation\\n      * @return The supply of tokens\\n      */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the balance of the specified address\\n     * @param owner The address from which the balance will be retrieved\\n     * @return The balance\\n     */\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    /**\\n      * @notice Transfer `amount` tokens from `src` to `dst`\\n      * @param src The address of the source account\\n      * @param dst The address of the destination account\\n      * @param amount The number of tokens to transfer\\n      * @return Whether or not the transfer succeeded\\n      */\\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool);\\n\\n    /**\\n      * @notice Approve `spender` to transfer up to `amount` from `src`\\n      * @dev This will overwrite the approval amount for `spender`\\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\n      * @param spender The address of the account which may transfer tokens\\n      * @param amount The number of tokens that are approved (-1 means infinite)\\n      * @return Whether or not the approval succeeded\\n      */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n      * @notice Get the current allowance from `owner` for `spender`\\n      * @param owner The address of the account which owns the tokens to be spent\\n      * @param spender The address of the account which may transfer tokens\\n      * @return The number of tokens allowed to be spent (-1 means infinite)\\n      */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @dev Interface for price feeds used by Comet\\n * Note This is Chainlink's AggregatorV3Interface, but without the `getRoundData` function.\\n */\\ninterface IPriceFeed {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\"\r\n    },\r\n    \"contracts/Kompu.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"./KompuMainInterface.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./IPriceFeed.sol\\\";\\n\\n/**\\n * @title Compound's Comet Contract\\n * @notice An efficient monolithic money market protocol\\n * @author Compound\\n */\\ncontract Kompu is KompuMainInterface {\\n    /** General configuration constants **/\\n\\n    /// @notice The admin of the protocol\\n    address public immutable override governor;\\n\\n    /// @notice The account which may trigger pauses\\n    address public immutable override pauseGuardian;\\n\\n    /// @notice The address of the base token contract\\n    address public immutable override baseToken;\\n\\n    /// @notice The address of the price feed for the base token\\n    address public immutable override baseTokenPriceFeed;\\n\\n    /// @notice The address of the extension contract delegate\\n    address public immutable override extensionDelegate;\\n\\n    /// @notice The point in the supply rates separating the low interest rate slope and the high interest rate slope (factor)\\n    /// @dev uint64\\n    uint public immutable override supplyKink;\\n\\n    /// @notice Per second supply interest rate slope applied when utilization is below kink (factor)\\n    /// @dev uint64\\n    uint public immutable override supplyPerSecondInterestRateSlopeLow;\\n\\n    /// @notice Per second supply interest rate slope applied when utilization is above kink (factor)\\n    /// @dev uint64\\n    uint public immutable override supplyPerSecondInterestRateSlopeHigh;\\n\\n    /// @notice Per second supply base interest rate (factor)\\n    /// @dev uint64\\n    uint public immutable override supplyPerSecondInterestRateBase;\\n\\n    /// @notice The point in the borrow rate separating the low interest rate slope and the high interest rate slope (factor)\\n    /// @dev uint64\\n    uint public immutable override borrowKink;\\n\\n    /// @notice Per second borrow interest rate slope applied when utilization is below kink (factor)\\n    /// @dev uint64\\n    uint public immutable override borrowPerSecondInterestRateSlopeLow;\\n\\n    /// @notice Per second borrow interest rate slope applied when utilization is above kink (factor)\\n    /// @dev uint64\\n    uint public immutable override borrowPerSecondInterestRateSlopeHigh;\\n\\n    /// @notice Per second borrow base interest rate (factor)\\n    /// @dev uint64\\n    uint public immutable override borrowPerSecondInterestRateBase;\\n\\n    /// @notice The fraction of the liquidation penalty that goes to buyers of collateral instead of the protocol\\n    /// @dev uint64\\n    uint public immutable override storeFrontPriceFactor;\\n\\n    /// @notice The scale for base token (must be less than 18 decimals)\\n    /// @dev uint64\\n    uint public immutable override baseScale;\\n\\n    /// @notice The scale for reward tracking\\n    /// @dev uint64\\n    uint public immutable override trackingIndexScale;\\n\\n    /// @notice The point at which it begins to give rewards to supplyers.\\n    /// @dev uint64\\n    uint public immutable override rewardKink;\\n\\n    /// @notice The speed at which rewards are tracked (in trackingIndexScale)\\n    /// @dev uint64\\n    uint public immutable override baseTrackingRewardSpeed;\\n\\n    /// @notice The minimum amount of base principal wei for rewards to accrue\\n    /// @dev This must be large enough so as to prevent division by base wei from overflowing the 64 bit indices\\n    /// @dev uint104\\n    uint public immutable override baseMinForRewards;\\n\\n    /// @notice The minimum base amount required to initiate a borrow\\n    uint public immutable override baseBorrowMin;\\n\\n    /// @notice The minimum base token reserves which must be held before collateral is hodled\\n    uint public immutable override targetReserves;\\n\\n    /// @notice The number of decimals for wrapped base token\\n    uint8 public immutable override decimals;\\n\\n    /// @notice The number of assets this contract actually supports\\n    uint8 public immutable override numAssets;\\n\\n    /// @notice Factor to divide by when accruing rewards in order to preserve 6 decimals (i.e. baseScale / 1e6)\\n    uint internal immutable accrualDescaleFactor;\\n\\n    /** Collateral asset configuration (packed) **/\\n\\n    uint256 internal immutable asset00_a;\\n    uint256 internal immutable asset00_b;\\n    uint256 internal immutable asset01_a;\\n    uint256 internal immutable asset01_b;\\n    uint256 internal immutable asset02_a;\\n    uint256 internal immutable asset02_b;\\n    uint256 internal immutable asset03_a;\\n    uint256 internal immutable asset03_b;\\n    uint256 internal immutable asset04_a;\\n    uint256 internal immutable asset04_b;\\n    uint256 internal immutable asset05_a;\\n    uint256 internal immutable asset05_b;\\n    uint256 internal immutable asset06_a;\\n    uint256 internal immutable asset06_b;\\n    uint256 internal immutable asset07_a;\\n    uint256 internal immutable asset07_b;\\n    uint256 internal immutable asset08_a;\\n    uint256 internal immutable asset08_b;\\n    uint256 internal immutable asset09_a;\\n    uint256 internal immutable asset09_b;\\n    uint256 internal immutable asset10_a;\\n    uint256 internal immutable asset10_b;\\n    uint256 internal immutable asset11_a;\\n    uint256 internal immutable asset11_b;\\n    uint256 internal immutable asset12_a;\\n    uint256 internal immutable asset12_b;\\n    uint256 internal immutable asset13_a;\\n    uint256 internal immutable asset13_b;\\n    uint256 internal immutable asset14_a;\\n    uint256 internal immutable asset14_b;\\n\\n    /**\\n     * @notice Construct a new protocol instance\\n     * @param config The mapping of initial/constant parameters\\n     **/\\n    constructor(Configuration memory config) {\\n        // Sanity checks\\n        uint8 decimals_ = ERC20(config.baseToken).decimals();\\n        if (decimals_ > MAX_BASE_DECIMALS) revert BadDecimals();\\n        if (config.storeFrontPriceFactor > FACTOR_SCALE) revert BadDiscount();\\n        if (config.assetConfigs.length > MAX_ASSETS) revert TooManyAssets();\\n        if (config.baseMinForRewards == 0) revert BadMinimum();\\n        if (\\n            IPriceFeed(config.baseTokenPriceFeed).decimals() !=\\n            PRICE_FEED_DECIMALS\\n        ) revert BadDecimals();\\n\\n        // Copy configuration\\n        unchecked {\\n            governor = config.governor;\\n            pauseGuardian = config.pauseGuardian;\\n            baseToken = config.baseToken;\\n            baseTokenPriceFeed = config.baseTokenPriceFeed;\\n            extensionDelegate = config.extensionDelegate;\\n            storeFrontPriceFactor = config.storeFrontPriceFactor;\\n\\n            decimals = decimals_;\\n            baseScale = uint64(10 ** decimals_);\\n            trackingIndexScale = config.trackingIndexScale;\\n            if (baseScale < BASE_ACCRUAL_SCALE) revert BadDecimals();\\n            accrualDescaleFactor = baseScale / BASE_ACCRUAL_SCALE;\\n\\n            baseMinForRewards = config.baseMinForRewards;\\n            rewardKink = config.rewardKink;\\n            baseTrackingRewardSpeed = config.baseTrackingRewardSpeed;\\n\\n            baseBorrowMin = config.baseBorrowMin;\\n            targetReserves = config.targetReserves;\\n        }\\n\\n        // Set interest rate model configs\\n        unchecked {\\n            supplyKink = config.supplyKink;\\n            supplyPerSecondInterestRateSlopeLow =\\n                config.supplyPerYearInterestRateSlopeLow /\\n                SECONDS_PER_YEAR;\\n            supplyPerSecondInterestRateSlopeHigh =\\n                config.supplyPerYearInterestRateSlopeHigh /\\n                SECONDS_PER_YEAR;\\n            supplyPerSecondInterestRateBase =\\n                config.supplyPerYearInterestRateBase /\\n                SECONDS_PER_YEAR;\\n            borrowKink = config.borrowKink;\\n            borrowPerSecondInterestRateSlopeLow =\\n                config.borrowPerYearInterestRateSlopeLow /\\n                SECONDS_PER_YEAR;\\n            borrowPerSecondInterestRateSlopeHigh =\\n                config.borrowPerYearInterestRateSlopeHigh /\\n                SECONDS_PER_YEAR;\\n            borrowPerSecondInterestRateBase =\\n                config.borrowPerYearInterestRateBase /\\n                SECONDS_PER_YEAR;\\n        }\\n\\n        // Set asset info\\n        numAssets = uint8(config.assetConfigs.length);\\n\\n        (asset00_a, asset00_b) = getPackedAssetInternal(config.assetConfigs, 0);\\n        (asset01_a, asset01_b) = getPackedAssetInternal(config.assetConfigs, 1);\\n        (asset02_a, asset02_b) = getPackedAssetInternal(config.assetConfigs, 2);\\n        (asset03_a, asset03_b) = getPackedAssetInternal(config.assetConfigs, 3);\\n        (asset04_a, asset04_b) = getPackedAssetInternal(config.assetConfigs, 4);\\n        (asset05_a, asset05_b) = getPackedAssetInternal(config.assetConfigs, 5);\\n        (asset06_a, asset06_b) = getPackedAssetInternal(config.assetConfigs, 6);\\n        (asset07_a, asset07_b) = getPackedAssetInternal(config.assetConfigs, 7);\\n        (asset08_a, asset08_b) = getPackedAssetInternal(config.assetConfigs, 8);\\n        (asset09_a, asset09_b) = getPackedAssetInternal(config.assetConfigs, 9);\\n        (asset10_a, asset10_b) = getPackedAssetInternal(\\n            config.assetConfigs,\\n            10\\n        );\\n        (asset11_a, asset11_b) = getPackedAssetInternal(\\n            config.assetConfigs,\\n            11\\n        );\\n        (asset12_a, asset12_b) = getPackedAssetInternal(\\n            config.assetConfigs,\\n            12\\n        );\\n        (asset13_a, asset13_b) = getPackedAssetInternal(\\n            config.assetConfigs,\\n            13\\n        );\\n        (asset14_a, asset14_b) = getPackedAssetInternal(\\n            config.assetConfigs,\\n            14\\n        );\\n    }\\n\\n    /**\\n     * @notice Initialize storage for the contract\\n     * @dev Can be used from constructor or proxy\\n     */\\n    function initializeStorage() external override {\\n        if (lastAccrualTime != 0) revert AlreadyInitialized();\\n\\n        // Initialize aggregates\\n        lastAccrualTime = getNowInternal();\\n        baseSupplyIndex = BASE_INDEX_SCALE;\\n        baseBorrowIndex = BASE_INDEX_SCALE;\\n\\n        // Implicit initialization (not worth increasing contract size)\\n        // trackingSupplyIndex = 0;\\n        // trackingBorrowIndex = 0;\\n    }\\n\\n    /**\\n     * @dev Checks and gets the packed asset info for storage\\n     */\\n    function getPackedAssetInternal(\\n        AssetConfig[] memory assetConfigs,\\n        uint i\\n    ) internal view returns (uint256, uint256) {\\n        AssetConfig memory assetConfig;\\n        if (i < assetConfigs.length) {\\n            assembly {\\n                assetConfig := mload(add(add(assetConfigs, 0x20), mul(i, 0x20)))\\n            }\\n        } else {\\n            return (0, 0);\\n        }\\n        address asset = assetConfig.asset;\\n        address priceFeed = assetConfig.priceFeed;\\n        uint8 decimals_ = assetConfig.decimals;\\n\\n        // Short-circuit if asset is nil\\n        if (asset == address(0)) {\\n            return (0, 0);\\n        }\\n\\n        // Sanity check price feed and asset decimals\\n        if (IPriceFeed(priceFeed).decimals() != PRICE_FEED_DECIMALS)\\n            revert BadDecimals();\\n        if (ERC20(asset).decimals() != decimals_) revert BadDecimals();\\n\\n        // Ensure collateral factors are within range\\n        if (\\n            assetConfig.borrowCollateralFactor >=\\n            assetConfig.liquidateCollateralFactor\\n        ) revert BorrowCFTooLarge();\\n        if (assetConfig.liquidateCollateralFactor > MAX_COLLATERAL_FACTOR)\\n            revert LiquidateCFTooLarge();\\n\\n        unchecked {\\n            // Keep 4 decimals for each factor\\n            uint64 descale = FACTOR_SCALE / 1e4;\\n            uint16 borrowCollateralFactor = uint16(\\n                assetConfig.borrowCollateralFactor / descale\\n            );\\n            uint16 liquidateCollateralFactor = uint16(\\n                assetConfig.liquidateCollateralFactor / descale\\n            );\\n            uint16 liquidationFactor = uint16(\\n                assetConfig.liquidationFactor / descale\\n            );\\n\\n            // Be nice and check descaled values are still within range\\n            if (borrowCollateralFactor >= liquidateCollateralFactor)\\n                revert BorrowCFTooLarge();\\n\\n            // Keep whole units of asset for supply cap\\n            uint64 supplyCap = uint64(\\n                assetConfig.supplyCap / (10 ** decimals_)\\n            );\\n\\n            uint256 word_a = ((uint160(asset) << 0) |\\n                (uint256(borrowCollateralFactor) << 160) |\\n                (uint256(liquidateCollateralFactor) << 176) |\\n                (uint256(liquidationFactor) << 192));\\n            uint256 word_b = ((uint160(priceFeed) << 0) |\\n                (uint256(decimals_) << 160) |\\n                (uint256(supplyCap) << 168));\\n\\n            return (word_a, word_b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the i-th asset info, according to the order they were passed in originally\\n     * @param i The index of the asset info to get\\n     * @return The asset info object\\n     */\\n    function getAssetInfo(\\n        uint8 i\\n    ) public view override returns (AssetInfo memory) {\\n        if (i >= numAssets) revert BadAsset();\\n\\n        uint256 word_a;\\n        uint256 word_b;\\n\\n        if (i == 0) {\\n            word_a = asset00_a;\\n            word_b = asset00_b;\\n        } else if (i == 1) {\\n            word_a = asset01_a;\\n            word_b = asset01_b;\\n        } else if (i == 2) {\\n            word_a = asset02_a;\\n            word_b = asset02_b;\\n        } else if (i == 3) {\\n            word_a = asset03_a;\\n            word_b = asset03_b;\\n        } else if (i == 4) {\\n            word_a = asset04_a;\\n            word_b = asset04_b;\\n        } else if (i == 5) {\\n            word_a = asset05_a;\\n            word_b = asset05_b;\\n        } else if (i == 6) {\\n            word_a = asset06_a;\\n            word_b = asset06_b;\\n        } else if (i == 7) {\\n            word_a = asset07_a;\\n            word_b = asset07_b;\\n        } else if (i == 8) {\\n            word_a = asset08_a;\\n            word_b = asset08_b;\\n        } else if (i == 9) {\\n            word_a = asset09_a;\\n            word_b = asset09_b;\\n        } else if (i == 10) {\\n            word_a = asset10_a;\\n            word_b = asset10_b;\\n        } else if (i == 11) {\\n            word_a = asset11_a;\\n            word_b = asset11_b;\\n        } else if (i == 12) {\\n            word_a = asset12_a;\\n            word_b = asset12_b;\\n        } else if (i == 13) {\\n            word_a = asset13_a;\\n            word_b = asset13_b;\\n        } else if (i == 14) {\\n            word_a = asset14_a;\\n            word_b = asset14_b;\\n        } else {\\n            revert Absurd();\\n        }\\n\\n        address asset = address(uint160(word_a & type(uint160).max));\\n        uint64 rescale = FACTOR_SCALE / 1e4;\\n        uint64 borrowCollateralFactor = uint64(\\n            ((word_a >> 160) & type(uint16).max) * rescale\\n        );\\n        uint64 liquidateCollateralFactor = uint64(\\n            ((word_a >> 176) & type(uint16).max) * rescale\\n        );\\n        uint64 liquidationFactor = uint64(\\n            ((word_a >> 192) & type(uint16).max) * rescale\\n        );\\n\\n        address priceFeed = address(uint160(word_b & type(uint160).max));\\n        uint8 decimals_ = uint8(((word_b >> 160) & type(uint8).max));\\n        uint64 scale = uint64(10 ** decimals_);\\n        uint128 supplyCap = uint128(\\n            ((word_b >> 168) & type(uint64).max) * scale\\n        );\\n\\n        return\\n            AssetInfo({\\n                offset: i,\\n                asset: asset,\\n                priceFeed: priceFeed,\\n                scale: scale,\\n                borrowCollateralFactor: borrowCollateralFactor,\\n                liquidateCollateralFactor: liquidateCollateralFactor,\\n                liquidationFactor: liquidationFactor,\\n                supplyCap: supplyCap\\n            });\\n    }\\n\\n    /**\\n     * @dev Determine index of asset that matches given address\\n     */\\n    function getAssetInfoByAddress(\\n        address asset\\n    ) public view override returns (AssetInfo memory) {\\n        for (uint8 i = 0; i < numAssets; ) {\\n            AssetInfo memory assetInfo = getAssetInfo(i);\\n            if (assetInfo.asset == asset) {\\n                return assetInfo;\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        revert BadAsset();\\n    }\\n\\n    /**\\n     * @return The current timestamp\\n     **/\\n    function getNowInternal() internal view virtual returns (uint40) {\\n        if (block.timestamp >= 2 ** 40) revert TimestampTooLarge();\\n        return uint40(block.timestamp);\\n    }\\n\\n    /**\\n     * @dev Calculate accrued interest indices for base token supply and borrows\\n     **/\\n    function accruedInterestIndices(\\n        uint timeElapsed\\n    ) internal view returns (uint64, uint64) {\\n        uint64 baseSupplyIndex_ = baseSupplyIndex;\\n        uint64 baseBorrowIndex_ = baseBorrowIndex;\\n        if (timeElapsed > 0) {\\n            uint utilization = getUtilization();\\n            uint supplyRate = getSupplyRate(utilization);\\n            uint borrowRate = getBorrowRate(utilization);\\n            baseSupplyIndex_ += safe64(\\n                mulFactor(baseSupplyIndex_, supplyRate * timeElapsed)\\n            );\\n            baseBorrowIndex_ += safe64(\\n                mulFactor(baseBorrowIndex_, borrowRate * timeElapsed)\\n            );\\n        }\\n        return (baseSupplyIndex_, baseBorrowIndex_);\\n    }\\n\\n    /**\\n     * @dev Accrue interest (and rewards) in base token supply and borrows\\n     **/\\n    function accrueInternal() internal {\\n        uint40 now_ = getNowInternal();\\n        uint timeElapsed = uint256(now_ - lastAccrualTime);\\n        if (timeElapsed > 0) {\\n            (baseSupplyIndex, baseBorrowIndex) = accruedInterestIndices(\\n                timeElapsed\\n            );\\n            uint utilization = getUtilization();\\n            if (totalSupplyBase >= baseMinForRewards) {\\n                trackingSupplyIndex += safe64(\\n                    divBaseWei(\\n                        getBaseTrackingSupplySpeed(utilization) * timeElapsed,\\n                        totalSupplyBase\\n                    )\\n                );\\n            }\\n            if (totalBorrowBase >= baseMinForRewards) {\\n                trackingBorrowIndex += safe64(\\n                    divBaseWei(\\n                        getBaseTrackingBorrowSpeed(utilization) * timeElapsed,\\n                        totalBorrowBase\\n                    )\\n                );\\n            }\\n            lastAccrualTime = now_;\\n        }\\n    }\\n\\n    /**\\n     * @notice Accrue interest and rewards for an account\\n     **/\\n    function accrueAccount(address account) external override {\\n        accrueInternal();\\n\\n        UserBasic memory basic = userBasic[account];\\n        updateBasePrincipal(account, basic, basic.principal);\\n    }\\n\\n    /**\\n     * @dev Note: Does not accrue interest first\\n     * @param utilization The utilization to check the supply rate for\\n     * @return The per second supply rate at `utilization`\\n     */\\n    function getSupplyRate(\\n        uint utilization\\n    ) public view override returns (uint64) {\\n        if (utilization <= supplyKink) {\\n            // interestRateBase + interestRateSlopeLow * utilization\\n            return\\n                safe64(\\n                    supplyPerSecondInterestRateBase +\\n                        mulFactor(\\n                            supplyPerSecondInterestRateSlopeLow,\\n                            utilization\\n                        )\\n                );\\n        } else {\\n            // interestRateBase + interestRateSlopeLow * kink + interestRateSlopeHigh * (utilization - kink)\\n            return\\n                safe64(\\n                    supplyPerSecondInterestRateBase +\\n                        mulFactor(\\n                            supplyPerSecondInterestRateSlopeLow,\\n                            supplyKink\\n                        ) +\\n                        mulFactor(\\n                            supplyPerSecondInterestRateSlopeHigh,\\n                            (utilization - supplyKink)\\n                        )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev Note: Does not accrue interest first\\n     * @param utilization The utilization to check the borrow rate for\\n     * @return The per second borrow rate at `utilization`\\n     */\\n    function getBorrowRate(\\n        uint utilization\\n    ) public view override returns (uint64) {\\n        if (utilization <= borrowKink) {\\n            // interestRateBase + interestRateSlopeLow * utilization\\n            return\\n                safe64(\\n                    borrowPerSecondInterestRateBase +\\n                        mulFactor(\\n                            borrowPerSecondInterestRateSlopeLow,\\n                            utilization\\n                        )\\n                );\\n        } else {\\n            // interestRateBase + interestRateSlopeLow * kink + interestRateSlopeHigh * (utilization - kink)\\n            return\\n                safe64(\\n                    borrowPerSecondInterestRateBase +\\n                        mulFactor(\\n                            borrowPerSecondInterestRateSlopeLow,\\n                            borrowKink\\n                        ) +\\n                        mulFactor(\\n                            borrowPerSecondInterestRateSlopeHigh,\\n                            (utilization - borrowKink)\\n                        )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev Note: Does not accrue interest first\\n     * @return The utilization rate of the base asset\\n     */\\n    function getUtilization() public view override returns (uint) {\\n        uint totalSupply_ = presentValueSupply(\\n            baseSupplyIndex,\\n            totalSupplyBase\\n        );\\n        uint totalBorrow_ = presentValueBorrow(\\n            baseBorrowIndex,\\n            totalBorrowBase\\n        );\\n        if (totalSupply_ == 0) {\\n            return 0;\\n        } else {\\n            return (totalBorrow_ * FACTOR_SCALE) / totalSupply_;\\n        }\\n    }\\n\\n    function baseTrackingSupplySpeed() public view override returns (uint) {\\n        uint utilization = getUtilization();\\n        if (utilization <= rewardKink) {\\n            return 0;\\n        } else if (utilization <= FACTOR_SCALE) {\\n            return\\n                (baseTrackingRewardSpeed * (utilization - rewardKink)) /\\n                (FACTOR_SCALE - rewardKink);\\n        } else {\\n            return baseTrackingRewardSpeed;\\n        }\\n    }\\n\\n    function baseTrackingBorrowSpeed() public view override returns (uint) {\\n        uint utilization = getUtilization();\\n        if (utilization <= rewardKink) {\\n            return baseTrackingRewardSpeed;\\n        } else if (utilization <= FACTOR_SCALE) {\\n            return\\n                (baseTrackingRewardSpeed * (FACTOR_SCALE - utilization)) /\\n                (FACTOR_SCALE - rewardKink);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function getBaseTrackingSupplySpeed(\\n        uint utilization\\n    ) public view returns (uint) {\\n        if (utilization <= rewardKink) {\\n            return 0;\\n        } else if (utilization <= FACTOR_SCALE) {\\n            return\\n                (baseTrackingRewardSpeed * (utilization - rewardKink)) /\\n                (FACTOR_SCALE - rewardKink);\\n        } else {\\n            return baseTrackingRewardSpeed;\\n        }\\n    }\\n\\n    function getBaseTrackingBorrowSpeed(\\n        uint utilization\\n    ) public view returns (uint) {\\n        if (utilization <= rewardKink) {\\n            return baseTrackingRewardSpeed;\\n        } else if (utilization <= FACTOR_SCALE) {\\n            return\\n                (baseTrackingRewardSpeed * (FACTOR_SCALE - utilization)) /\\n                (FACTOR_SCALE - rewardKink);\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the current price from a feed\\n     * @param priceFeed The address of a price feed\\n     * @return The price, scaled by `PRICE_SCALE`\\n     */\\n    function getPrice(\\n        address priceFeed\\n    ) public view override returns (uint256) {\\n        (, int price, , , ) = IPriceFeed(priceFeed).latestRoundData();\\n        if (price <= 0) revert BadPrice();\\n        return uint256(price);\\n    }\\n\\n    /**\\n     * @notice Gets the total balance of protocol collateral reserves for an asset\\n     * @dev Note: Reverts if collateral reserves are somehow negative, which should not be possible\\n     * @param asset The collateral asset\\n     */\\n    function getCollateralReserves(\\n        address asset\\n    ) public view override returns (uint) {\\n        return\\n            ERC20(asset).balanceOf(address(this)) -\\n            totalsCollateral[asset].totalSupplyAsset;\\n    }\\n\\n    /**\\n     * @notice Gets the total amount of protocol reserves of the base asset\\n     */\\n    function getReserves() public view override returns (int) {\\n        (\\n            uint64 baseSupplyIndex_,\\n            uint64 baseBorrowIndex_\\n        ) = accruedInterestIndices(getNowInternal() - lastAccrualTime);\\n        uint balance = ERC20(baseToken).balanceOf(address(this));\\n        uint totalSupply_ = presentValueSupply(\\n            baseSupplyIndex_,\\n            totalSupplyBase\\n        );\\n        uint totalBorrow_ = presentValueBorrow(\\n            baseBorrowIndex_,\\n            totalBorrowBase\\n        );\\n        return\\n            signed256(balance) -\\n            signed256(totalSupply_) +\\n            signed256(totalBorrow_);\\n    }\\n\\n    /**\\n     * @notice Check whether an account has enough collateral to borrow\\n     * @param account The address to check\\n     * @return Whether the account is minimally collateralized enough to borrow\\n     */\\n    function isBorrowCollateralized(\\n        address account\\n    ) public view override returns (bool) {\\n        int104 principal = userBasic[account].principal;\\n\\n        if (principal >= 0) {\\n            return true;\\n        }\\n\\n        uint16 assetsIn = userBasic[account].assetsIn;\\n        int liquidity = signedMulPrice(\\n            presentValue(principal),\\n            getPrice(baseTokenPriceFeed),\\n            uint64(baseScale)\\n        );\\n\\n        for (uint8 i = 0; i < numAssets; ) {\\n            if (isInAsset(assetsIn, i)) {\\n                if (liquidity >= 0) {\\n                    return true;\\n                }\\n\\n                AssetInfo memory asset = getAssetInfo(i);\\n                uint newAmount = mulPrice(\\n                    userCollateral[account][asset.asset].balance,\\n                    getPrice(asset.priceFeed),\\n                    asset.scale\\n                );\\n                liquidity += signed256(\\n                    mulFactor(newAmount, asset.borrowCollateralFactor)\\n                );\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        return liquidity >= 0;\\n    }\\n\\n    /**\\n     * @notice Check whether an account has enough collateral to not be liquidated\\n     * @param account The address to check\\n     * @return Whether the account is minimally collateralized enough to not be liquidated\\n     */\\n    function isLiquidatable(\\n        address account\\n    ) public view override returns (bool) {\\n        int104 principal = userBasic[account].principal;\\n\\n        if (principal >= 0) {\\n            return false;\\n        }\\n\\n        uint16 assetsIn = userBasic[account].assetsIn;\\n        int liquidity = signedMulPrice(\\n            presentValue(principal),\\n            getPrice(baseTokenPriceFeed),\\n            uint64(baseScale)\\n        );\\n\\n        for (uint8 i = 0; i < numAssets; ) {\\n            if (isInAsset(assetsIn, i)) {\\n                if (liquidity >= 0) {\\n                    return false;\\n                }\\n\\n                AssetInfo memory asset = getAssetInfo(i);\\n                uint newAmount = mulPrice(\\n                    userCollateral[account][asset.asset].balance,\\n                    getPrice(asset.priceFeed),\\n                    asset.scale\\n                );\\n                liquidity += signed256(\\n                    mulFactor(newAmount, asset.liquidateCollateralFactor)\\n                );\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        return liquidity < 0;\\n    }\\n\\n    /**\\n     * @dev The change in principal broken into repay and supply amounts\\n     */\\n    function repayAndSupplyAmount(\\n        int104 oldPrincipal,\\n        int104 newPrincipal\\n    ) internal pure returns (uint104, uint104) {\\n        // If the new principal is less than the old principal, then no amount has been repaid or supplied\\n        if (newPrincipal < oldPrincipal) return (0, 0);\\n\\n        if (newPrincipal <= 0) {\\n            return (uint104(newPrincipal - oldPrincipal), 0);\\n        } else if (oldPrincipal >= 0) {\\n            return (0, uint104(newPrincipal - oldPrincipal));\\n        } else {\\n            return (uint104(-oldPrincipal), uint104(newPrincipal));\\n        }\\n    }\\n\\n    /**\\n     * @dev The change in principal broken into withdraw and borrow amounts\\n     */\\n    function withdrawAndBorrowAmount(\\n        int104 oldPrincipal,\\n        int104 newPrincipal\\n    ) internal pure returns (uint104, uint104) {\\n        // If the new principal is greater than the old principal, then no amount has been withdrawn or borrowed\\n        if (newPrincipal > oldPrincipal) return (0, 0);\\n\\n        if (newPrincipal >= 0) {\\n            return (uint104(oldPrincipal - newPrincipal), 0);\\n        } else if (oldPrincipal <= 0) {\\n            return (0, uint104(oldPrincipal - newPrincipal));\\n        } else {\\n            return (uint104(oldPrincipal), uint104(-newPrincipal));\\n        }\\n    }\\n\\n    /**\\n     * @notice Pauses different actions within Comet\\n     * @param supplyPaused Boolean for pausing supply actions\\n     * @param transferPaused Boolean for pausing transfer actions\\n     * @param withdrawPaused Boolean for pausing withdraw actions\\n     * @param absorbPaused Boolean for pausing absorb actions\\n     * @param buyPaused Boolean for pausing buy actions\\n     */\\n    function pause(\\n        bool supplyPaused,\\n        bool transferPaused,\\n        bool withdrawPaused,\\n        bool absorbPaused,\\n        bool buyPaused\\n    ) external override {\\n        if (msg.sender != governor && msg.sender != pauseGuardian)\\n            revert Unauthorized();\\n\\n        pauseFlags =\\n            uint8(0) |\\n            (toUInt8(supplyPaused) << PAUSE_SUPPLY_OFFSET) |\\n            (toUInt8(transferPaused) << PAUSE_TRANSFER_OFFSET) |\\n            (toUInt8(withdrawPaused) << PAUSE_WITHDRAW_OFFSET) |\\n            (toUInt8(absorbPaused) << PAUSE_ABSORB_OFFSET) |\\n            (toUInt8(buyPaused) << PAUSE_BUY_OFFSET);\\n\\n        emit PauseAction(\\n            supplyPaused,\\n            transferPaused,\\n            withdrawPaused,\\n            absorbPaused,\\n            buyPaused\\n        );\\n    }\\n\\n    /**\\n     * @return Whether or not supply actions are paused\\n     */\\n    function isSupplyPaused() public view override returns (bool) {\\n        return toBool(pauseFlags & (uint8(1) << PAUSE_SUPPLY_OFFSET));\\n    }\\n\\n    /**\\n     * @return Whether or not transfer actions are paused\\n     */\\n    function isTransferPaused() public view override returns (bool) {\\n        return toBool(pauseFlags & (uint8(1) << PAUSE_TRANSFER_OFFSET));\\n    }\\n\\n    /**\\n     * @return Whether or not withdraw actions are paused\\n     */\\n    function isWithdrawPaused() public view override returns (bool) {\\n        return toBool(pauseFlags & (uint8(1) << PAUSE_WITHDRAW_OFFSET));\\n    }\\n\\n    /**\\n     * @return Whether or not absorb actions are paused\\n     */\\n    function isAbsorbPaused() public view override returns (bool) {\\n        return toBool(pauseFlags & (uint8(1) << PAUSE_ABSORB_OFFSET));\\n    }\\n\\n    /**\\n     * @return Whether or not buy actions are paused\\n     */\\n    function isBuyPaused() public view override returns (bool) {\\n        return toBool(pauseFlags & (uint8(1) << PAUSE_BUY_OFFSET));\\n    }\\n\\n    /**\\n     * @dev Multiply a number by a factor\\n     */\\n    function mulFactor(uint n, uint factor) internal pure returns (uint) {\\n        return (n * factor) / FACTOR_SCALE;\\n    }\\n\\n    /**\\n     * @dev Divide a number by an amount of base\\n     */\\n    function divBaseWei(uint n, uint baseWei) internal view returns (uint) {\\n        return (n * baseScale) / baseWei;\\n    }\\n\\n    /**\\n     * @dev Multiply a `fromScale` quantity by a price, returning a common price quantity\\n     */\\n    function mulPrice(\\n        uint n,\\n        uint price,\\n        uint64 fromScale\\n    ) internal pure returns (uint) {\\n        return (n * price) / fromScale;\\n    }\\n\\n    /**\\n     * @dev Multiply a signed `fromScale` quantity by a price, returning a common price quantity\\n     */\\n    function signedMulPrice(\\n        int n,\\n        uint price,\\n        uint64 fromScale\\n    ) internal pure returns (int) {\\n        return (n * signed256(price)) / int256(uint256(fromScale));\\n    }\\n\\n    /**\\n     * @dev Divide a common price quantity by a price, returning a `toScale` quantity\\n     */\\n    function divPrice(\\n        uint n,\\n        uint price,\\n        uint64 toScale\\n    ) internal pure returns (uint) {\\n        return (n * toScale) / price;\\n    }\\n\\n    /**\\n     * @dev Whether user has a non-zero balance of an asset, given assetsIn flags\\n     */\\n    function isInAsset(\\n        uint16 assetsIn,\\n        uint8 assetOffset\\n    ) internal pure returns (bool) {\\n        return (assetsIn & (uint16(1) << assetOffset) != 0);\\n    }\\n\\n    /**\\n     * @dev Update assetsIn bit vector if user has entered or exited an asset\\n     */\\n    function updateAssetsIn(\\n        address account,\\n        AssetInfo memory assetInfo,\\n        uint128 initialUserBalance,\\n        uint128 finalUserBalance\\n    ) internal {\\n        if (initialUserBalance == 0 && finalUserBalance != 0) {\\n            // set bit for asset\\n            userBasic[account].assetsIn |= (uint16(1) << assetInfo.offset);\\n        } else if (initialUserBalance != 0 && finalUserBalance == 0) {\\n            // clear bit for asset\\n            userBasic[account].assetsIn &= ~(uint16(1) << assetInfo.offset);\\n        }\\n    }\\n\\n    /**\\n     * @dev Write updated principal to store and tracking participation\\n     */\\n    function updateBasePrincipal(\\n        address account,\\n        UserBasic memory basic,\\n        int104 principalNew\\n    ) internal {\\n        int104 principal = basic.principal;\\n        basic.principal = principalNew;\\n\\n        if (principal >= 0) {\\n            uint indexDelta = uint256(\\n                trackingSupplyIndex - basic.baseTrackingIndex\\n            );\\n            basic.baseTrackingAccrued += safe64(\\n                (uint104(principal) * indexDelta) /\\n                    trackingIndexScale /\\n                    accrualDescaleFactor\\n            );\\n        } else {\\n            uint indexDelta = uint256(\\n                trackingBorrowIndex - basic.baseTrackingIndex\\n            );\\n            basic.baseTrackingAccrued += safe64(\\n                (uint104(-principal) * indexDelta) /\\n                    trackingIndexScale /\\n                    accrualDescaleFactor\\n            );\\n        }\\n\\n        if (principalNew >= 0) {\\n            basic.baseTrackingIndex = trackingSupplyIndex;\\n        } else {\\n            basic.baseTrackingIndex = trackingBorrowIndex;\\n        }\\n\\n        userBasic[account] = basic;\\n    }\\n\\n    /**\\n     * @dev Safe ERC20 transfer in, assumes no fee is charged and amount is transferred\\n     */\\n    function doTransferIn(address asset, address from, uint amount) internal {\\n        bool success = ERC20(asset).transferFrom(from, address(this), amount);\\n        if (!success) revert TransferInFailed();\\n    }\\n\\n    /**\\n     * @dev Safe ERC20 transfer out\\n     */\\n    function doTransferOut(address asset, address to, uint amount) internal {\\n        bool success = ERC20(asset).transfer(to, amount);\\n        if (!success) revert TransferOutFailed();\\n    }\\n\\n    /**\\n     * @notice Supply an amount of asset to the protocol\\n     * @param asset The asset to supply\\n     * @param amount The quantity to supply\\n     */\\n    function supply(address asset, uint amount) external override {\\n        return\\n            supplyInternal(msg.sender, msg.sender, msg.sender, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Supply an amount of asset to dst\\n     * @param dst The address which will hold the balance\\n     * @param asset The asset to supply\\n     * @param amount The quantity to supply\\n     */\\n    function supplyTo(\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external override {\\n        return supplyInternal(msg.sender, msg.sender, dst, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Supply an amount of asset from `from` to dst, if allowed\\n     * @param from The supplier address\\n     * @param dst The address which will hold the balance\\n     * @param asset The asset to supply\\n     * @param amount The quantity to supply\\n     */\\n    function supplyFrom(\\n        address from,\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external override {\\n        return supplyInternal(msg.sender, from, dst, asset, amount);\\n    }\\n\\n    /**\\n     * @dev Supply either collateral or base asset, depending on the asset, if operator is allowed\\n     * @dev Note: Specifying an `amount` of uint256.max will repay all of `dst`'s accrued base borrow balance\\n     */\\n    function supplyInternal(\\n        address operator,\\n        address from,\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) internal {\\n        if (isSupplyPaused()) revert Paused();\\n        if (!hasPermission(from, operator)) revert Unauthorized();\\n\\n        if (asset == baseToken) {\\n            if (amount == type(uint256).max) {\\n                amount = borrowBalanceOf(dst);\\n            }\\n            return supplyBase(from, dst, amount);\\n        } else {\\n            return supplyCollateral(from, dst, asset, safe128(amount));\\n        }\\n    }\\n\\n    /**\\n     * @dev Supply an amount of base asset from `from` to dst\\n     */\\n    function supplyBase(address from, address dst, uint256 amount) internal {\\n        doTransferIn(baseToken, from, amount);\\n\\n        accrueInternal();\\n\\n        UserBasic memory dstUser = userBasic[dst];\\n        int104 dstPrincipal = dstUser.principal;\\n        int256 dstBalance = presentValue(dstPrincipal) + signed256(amount);\\n        int104 dstPrincipalNew = principalValue(dstBalance);\\n\\n        (uint104 repayAmount, uint104 supplyAmount) = repayAndSupplyAmount(\\n            dstPrincipal,\\n            dstPrincipalNew\\n        );\\n\\n        totalSupplyBase += supplyAmount;\\n        totalBorrowBase -= repayAmount;\\n\\n        updateBasePrincipal(dst, dstUser, dstPrincipalNew);\\n\\n        emit Supply(from, dst, amount);\\n\\n        if (supplyAmount > 0) {\\n            emit Transfer(\\n                address(0),\\n                dst,\\n                presentValueSupply(baseSupplyIndex, supplyAmount)\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Supply an amount of collateral asset from `from` to dst\\n     */\\n    function supplyCollateral(\\n        address from,\\n        address dst,\\n        address asset,\\n        uint128 amount\\n    ) internal {\\n        doTransferIn(asset, from, amount);\\n\\n        AssetInfo memory assetInfo = getAssetInfoByAddress(asset);\\n        TotalsCollateral memory totals = totalsCollateral[asset];\\n        totals.totalSupplyAsset += amount;\\n        if (totals.totalSupplyAsset > assetInfo.supplyCap)\\n            revert SupplyCapExceeded();\\n\\n        uint128 dstCollateral = userCollateral[dst][asset].balance;\\n        uint128 dstCollateralNew = dstCollateral + amount;\\n\\n        totalsCollateral[asset] = totals;\\n        userCollateral[dst][asset].balance = dstCollateralNew;\\n\\n        updateAssetsIn(dst, assetInfo, dstCollateral, dstCollateralNew);\\n\\n        emit SupplyCollateral(from, dst, asset, amount);\\n    }\\n\\n    /**\\n     * @notice ERC20 transfer an amount of base token to dst\\n     * @param dst The recipient address\\n     * @param amount The quantity to transfer\\n     * @return true\\n     */\\n    function transfer(\\n        address dst,\\n        uint amount\\n    ) external override returns (bool) {\\n        transferInternal(msg.sender, msg.sender, dst, baseToken, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice ERC20 transfer an amount of base token from src to dst, if allowed\\n     * @param src The sender address\\n     * @param dst The recipient address\\n     * @param amount The quantity to transfer\\n     * @return true\\n     */\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint amount\\n    ) external override returns (bool) {\\n        transferInternal(msg.sender, src, dst, baseToken, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer an amount of asset to dst\\n     * @param dst The recipient address\\n     * @param asset The asset to transfer\\n     * @param amount The quantity to transfer\\n     */\\n    function transferAsset(\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external override {\\n        return transferInternal(msg.sender, msg.sender, dst, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Transfer an amount of asset from src to dst, if allowed\\n     * @param src The sender address\\n     * @param dst The recipient address\\n     * @param asset The asset to transfer\\n     * @param amount The quantity to transfer\\n     */\\n    function transferAssetFrom(\\n        address src,\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external override {\\n        return transferInternal(msg.sender, src, dst, asset, amount);\\n    }\\n\\n    /**\\n     * @dev Transfer either collateral or base asset, depending on the asset, if operator is allowed\\n     * @dev Note: Specifying an `amount` of uint256.max will transfer all of `src`'s accrued base balance\\n     */\\n    function transferInternal(\\n        address operator,\\n        address src,\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) internal {\\n        if (isTransferPaused()) revert Paused();\\n        if (!hasPermission(src, operator)) revert Unauthorized();\\n        if (src == dst) revert NoSelfTransfer();\\n\\n        if (asset == baseToken) {\\n            if (amount == type(uint256).max) {\\n                amount = balanceOf(src);\\n            }\\n            return transferBase(src, dst, amount);\\n        } else {\\n            return transferCollateral(src, dst, asset, safe128(amount));\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfer an amount of base asset from src to dst, borrowing if possible/necessary\\n     */\\n    function transferBase(address src, address dst, uint256 amount) internal {\\n        accrueInternal();\\n\\n        UserBasic memory srcUser = userBasic[src];\\n        UserBasic memory dstUser = userBasic[dst];\\n\\n        int104 srcPrincipal = srcUser.principal;\\n        int104 dstPrincipal = dstUser.principal;\\n        int256 srcBalance = presentValue(srcPrincipal) - signed256(amount);\\n        int256 dstBalance = presentValue(dstPrincipal) + signed256(amount);\\n        int104 srcPrincipalNew = principalValue(srcBalance);\\n        int104 dstPrincipalNew = principalValue(dstBalance);\\n\\n        (\\n            uint104 withdrawAmount,\\n            uint104 borrowAmount\\n        ) = withdrawAndBorrowAmount(srcPrincipal, srcPrincipalNew);\\n        (uint104 repayAmount, uint104 supplyAmount) = repayAndSupplyAmount(\\n            dstPrincipal,\\n            dstPrincipalNew\\n        );\\n\\n        // Note: Instead of `total += addAmount - subAmount` to avoid underflow errors.\\n        totalSupplyBase = totalSupplyBase + supplyAmount - withdrawAmount;\\n        totalBorrowBase = totalBorrowBase + borrowAmount - repayAmount;\\n\\n        updateBasePrincipal(src, srcUser, srcPrincipalNew);\\n        updateBasePrincipal(dst, dstUser, dstPrincipalNew);\\n\\n        if (srcBalance < 0) {\\n            if (uint256(-srcBalance) < baseBorrowMin) revert BorrowTooSmall();\\n            if (!isBorrowCollateralized(src)) revert NotCollateralized();\\n        }\\n\\n        if (withdrawAmount > 0) {\\n            emit Transfer(\\n                src,\\n                address(0),\\n                presentValueSupply(baseSupplyIndex, withdrawAmount)\\n            );\\n        }\\n\\n        if (supplyAmount > 0) {\\n            emit Transfer(\\n                address(0),\\n                dst,\\n                presentValueSupply(baseSupplyIndex, supplyAmount)\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfer an amount of collateral asset from src to dst\\n     */\\n    function transferCollateral(\\n        address src,\\n        address dst,\\n        address asset,\\n        uint128 amount\\n    ) internal {\\n        uint128 srcCollateral = userCollateral[src][asset].balance;\\n        uint128 dstCollateral = userCollateral[dst][asset].balance;\\n        uint128 srcCollateralNew = srcCollateral - amount;\\n        uint128 dstCollateralNew = dstCollateral + amount;\\n\\n        userCollateral[src][asset].balance = srcCollateralNew;\\n        userCollateral[dst][asset].balance = dstCollateralNew;\\n\\n        AssetInfo memory assetInfo = getAssetInfoByAddress(asset);\\n        updateAssetsIn(src, assetInfo, srcCollateral, srcCollateralNew);\\n        updateAssetsIn(dst, assetInfo, dstCollateral, dstCollateralNew);\\n\\n        // Note: no accrue interest, BorrowCF < LiquidationCF covers small changes\\n        if (!isBorrowCollateralized(src)) revert NotCollateralized();\\n\\n        emit TransferCollateral(src, dst, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw an amount of asset from the protocol\\n     * @param asset The asset to withdraw\\n     * @param amount The quantity to withdraw\\n     */\\n    function withdraw(address asset, uint amount) external override {\\n        return\\n            withdrawInternal(msg.sender, msg.sender, msg.sender, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw an amount of asset to `to`\\n     * @param to The recipient address\\n     * @param asset The asset to withdraw\\n     * @param amount The quantity to withdraw\\n     */\\n    function withdrawTo(\\n        address to,\\n        address asset,\\n        uint amount\\n    ) external override {\\n        return withdrawInternal(msg.sender, msg.sender, to, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Withdraw an amount of asset from src to `to`, if allowed\\n     * @param src The sender address\\n     * @param to The recipient address\\n     * @param asset The asset to withdraw\\n     * @param amount The quantity to withdraw\\n     */\\n    function withdrawFrom(\\n        address src,\\n        address to,\\n        address asset,\\n        uint amount\\n    ) external override {\\n        return withdrawInternal(msg.sender, src, to, asset, amount);\\n    }\\n\\n    /**\\n     * @dev Withdraw either collateral or base asset, depending on the asset, if operator is allowed\\n     * @dev Note: Specifying an `amount` of uint256.max will withdraw all of `src`'s accrued base balance\\n     */\\n    function withdrawInternal(\\n        address operator,\\n        address src,\\n        address to,\\n        address asset,\\n        uint amount\\n    ) internal {\\n        if (isWithdrawPaused()) revert Paused();\\n        if (!hasPermission(src, operator)) revert Unauthorized();\\n\\n        if (asset == baseToken) {\\n            if (amount == type(uint256).max) {\\n                amount = balanceOf(src);\\n            }\\n            return withdrawBase(src, to, amount);\\n        } else {\\n            return withdrawCollateral(src, to, asset, safe128(amount));\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraw an amount of base asset from src to `to`, borrowing if possible/necessary\\n     */\\n    function withdrawBase(address src, address to, uint256 amount) internal {\\n        accrueInternal();\\n\\n        UserBasic memory srcUser = userBasic[src];\\n        int104 srcPrincipal = srcUser.principal;\\n        int256 srcBalance = presentValue(srcPrincipal) - signed256(amount);\\n        int104 srcPrincipalNew = principalValue(srcBalance);\\n\\n        (\\n            uint104 withdrawAmount,\\n            uint104 borrowAmount\\n        ) = withdrawAndBorrowAmount(srcPrincipal, srcPrincipalNew);\\n\\n        totalSupplyBase -= withdrawAmount;\\n        totalBorrowBase += borrowAmount;\\n\\n        updateBasePrincipal(src, srcUser, srcPrincipalNew);\\n\\n        if (srcBalance < 0) {\\n            if (uint256(-srcBalance) < baseBorrowMin) revert BorrowTooSmall();\\n            if (!isBorrowCollateralized(src)) revert NotCollateralized();\\n        }\\n\\n        doTransferOut(baseToken, to, amount);\\n\\n        emit Withdraw(src, to, amount);\\n\\n        if (withdrawAmount > 0) {\\n            emit Transfer(\\n                src,\\n                address(0),\\n                presentValueSupply(baseSupplyIndex, withdrawAmount)\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraw an amount of collateral asset from src to `to`\\n     */\\n    function withdrawCollateral(\\n        address src,\\n        address to,\\n        address asset,\\n        uint128 amount\\n    ) internal {\\n        uint128 srcCollateral = userCollateral[src][asset].balance;\\n        uint128 srcCollateralNew = srcCollateral - amount;\\n\\n        totalsCollateral[asset].totalSupplyAsset -= amount;\\n        userCollateral[src][asset].balance = srcCollateralNew;\\n\\n        AssetInfo memory assetInfo = getAssetInfoByAddress(asset);\\n        updateAssetsIn(src, assetInfo, srcCollateral, srcCollateralNew);\\n\\n        // Note: no accrue interest, BorrowCF < LiquidationCF covers small changes\\n        if (!isBorrowCollateralized(src)) revert NotCollateralized();\\n\\n        doTransferOut(asset, to, amount);\\n\\n        emit WithdrawCollateral(src, to, asset, amount);\\n    }\\n\\n    /**\\n     * @notice Absorb a list of underwater accounts onto the protocol balance sheet\\n     * @param absorber The recipient of the incentive paid to the caller of absorb\\n     * @param accounts The list of underwater accounts to absorb\\n     */\\n    function absorb(\\n        address absorber,\\n        address[] calldata accounts\\n    ) external override {\\n        if (isAbsorbPaused()) revert Paused();\\n\\n        uint startGas = gasleft();\\n        accrueInternal();\\n        for (uint i = 0; i < accounts.length; ) {\\n            absorbInternal(absorber, accounts[i]);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        uint gasUsed = startGas - gasleft();\\n\\n        // Note: liquidator points are an imperfect tool for governance,\\n        //  to be used while evaluating strategies for incentivizing absorption.\\n        // Using gas price instead of base fee would more accurately reflect spend,\\n        //  but is also subject to abuse if refunds were to be given automatically.\\n        LiquidatorPoints memory points = liquidatorPoints[absorber];\\n        points.numAbsorbs++;\\n        points.numAbsorbed += safe64(accounts.length);\\n        points.approxSpend += safe128(gasUsed * block.basefee);\\n        liquidatorPoints[absorber] = points;\\n    }\\n\\n    /**\\n     * @dev Transfer user's collateral and debt to the protocol itself.\\n     */\\n    function absorbInternal(address absorber, address account) internal {\\n        if (!isLiquidatable(account)) revert NotLiquidatable();\\n\\n        UserBasic memory accountUser = userBasic[account];\\n        int104 oldPrincipal = accountUser.principal;\\n        int256 oldBalance = presentValue(oldPrincipal);\\n        uint16 assetsIn = accountUser.assetsIn;\\n\\n        uint256 basePrice = getPrice(baseTokenPriceFeed);\\n        uint256 deltaValue = 0;\\n\\n        for (uint8 i = 0; i < numAssets; ) {\\n            if (isInAsset(assetsIn, i)) {\\n                AssetInfo memory assetInfo = getAssetInfo(i);\\n                address asset = assetInfo.asset;\\n                uint128 seizeAmount = userCollateral[account][asset].balance;\\n                userCollateral[account][asset].balance = 0;\\n                totalsCollateral[asset].totalSupplyAsset -= seizeAmount;\\n\\n                uint256 value = mulPrice(\\n                    seizeAmount,\\n                    getPrice(assetInfo.priceFeed),\\n                    assetInfo.scale\\n                );\\n                deltaValue += mulFactor(value, assetInfo.liquidationFactor);\\n\\n                emit AbsorbCollateral(\\n                    absorber,\\n                    account,\\n                    asset,\\n                    seizeAmount,\\n                    value\\n                );\\n            }\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        uint256 deltaBalance = divPrice(\\n            deltaValue,\\n            basePrice,\\n            uint64(baseScale)\\n        );\\n        int256 newBalance = oldBalance + signed256(deltaBalance);\\n        // New balance will not be negative, all excess debt absorbed by reserves\\n        if (newBalance < 0) {\\n            newBalance = 0;\\n        }\\n\\n        int104 newPrincipal = principalValue(newBalance);\\n        updateBasePrincipal(account, accountUser, newPrincipal);\\n\\n        // reset assetsIn\\n        userBasic[account].assetsIn = 0;\\n\\n        (uint104 repayAmount, uint104 supplyAmount) = repayAndSupplyAmount(\\n            oldPrincipal,\\n            newPrincipal\\n        );\\n\\n        // Reserves are decreased by increasing total supply and decreasing borrows\\n        //  the amount of debt repaid by reserves is `newBalance - oldBalance`\\n        totalSupplyBase += supplyAmount;\\n        totalBorrowBase -= repayAmount;\\n\\n        uint256 basePaidOut = unsigned256(newBalance - oldBalance);\\n        uint256 valueOfBasePaidOut = mulPrice(\\n            basePaidOut,\\n            basePrice,\\n            uint64(baseScale)\\n        );\\n        emit AbsorbDebt(absorber, account, basePaidOut, valueOfBasePaidOut);\\n\\n        if (newPrincipal > 0) {\\n            emit Transfer(\\n                address(0),\\n                account,\\n                presentValueSupply(baseSupplyIndex, unsigned104(newPrincipal))\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Buy collateral from the protocol using base tokens, increasing protocol reserves\\n       A minimum collateral amount should be specified to indicate the maximum slippage acceptable for the buyer.\\n     * @param asset The asset to buy\\n     * @param minAmount The minimum amount of collateral tokens that should be received by the buyer\\n     * @param baseAmount The amount of base tokens used to buy the collateral\\n     * @param recipient The recipient address\\n     */\\n    function buyCollateral(\\n        address asset,\\n        uint minAmount,\\n        uint baseAmount,\\n        address recipient\\n    ) external override {\\n        if (isBuyPaused()) revert Paused();\\n\\n        int reserves = getReserves();\\n        if (reserves >= 0 && uint(reserves) >= targetReserves)\\n            revert NotForSale();\\n\\n        // Note: Re-entrancy can skip the reserves check above on a second buyCollateral call.\\n        doTransferIn(baseToken, msg.sender, baseAmount);\\n\\n        uint collateralAmount = quoteCollateral(asset, baseAmount);\\n        if (collateralAmount < minAmount) revert TooMuchSlippage();\\n        if (collateralAmount > getCollateralReserves(asset))\\n            revert InsufficientReserves();\\n\\n        // Note: Pre-transfer hook can re-enter buyCollateral with a stale collateral ERC20 balance.\\n        //  Assets should not be listed which allow re-entry from pre-transfer now, as too much collateral could be bought.\\n        //  This is also a problem if quoteCollateral derives its discount from the collateral ERC20 balance.\\n        doTransferOut(asset, recipient, safe128(collateralAmount));\\n\\n        emit BuyCollateral(msg.sender, asset, baseAmount, collateralAmount);\\n    }\\n\\n    /**\\n     * @notice Gets the quote for a collateral asset in exchange for an amount of base asset\\n     * @param asset The collateral asset to get the quote for\\n     * @param baseAmount The amount of the base asset to get the quote for\\n     * @return The quote in terms of the collateral asset\\n     */\\n    function quoteCollateral(\\n        address asset,\\n        uint baseAmount\\n    ) public view override returns (uint) {\\n        AssetInfo memory assetInfo = getAssetInfoByAddress(asset);\\n        uint256 assetPrice = getPrice(assetInfo.priceFeed);\\n        // Store front discount is derived from the collateral asset's liquidationFactor and storeFrontPriceFactor\\n        // discount = storeFrontPriceFactor * (1e18 - liquidationFactor)\\n        uint256 discountFactor = mulFactor(\\n            storeFrontPriceFactor,\\n            FACTOR_SCALE - assetInfo.liquidationFactor\\n        );\\n        uint256 assetPriceDiscounted = mulFactor(\\n            assetPrice,\\n            FACTOR_SCALE - discountFactor\\n        );\\n        uint256 basePrice = getPrice(baseTokenPriceFeed);\\n        // # of collateral assets\\n        // = (TotalValueOfBaseAmount / DiscountedPriceOfCollateralAsset) * assetScale\\n        // = ((basePrice * baseAmount / baseScale) / assetPriceDiscounted) * assetScale\\n        return\\n            (basePrice * baseAmount * assetInfo.scale) /\\n            assetPriceDiscounted /\\n            baseScale;\\n    }\\n\\n    /**\\n     * @notice Withdraws base token reserves if called by the governor\\n     * @param to An address of the receiver of withdrawn reserves\\n     * @param amount The amount of reserves to be withdrawn from the protocol\\n     */\\n    function withdrawReserves(address to, uint amount) external override {\\n        if (msg.sender != governor) revert Unauthorized();\\n\\n        int reserves = getReserves();\\n        if (reserves < 0 || amount > unsigned256(reserves))\\n            revert InsufficientReserves();\\n\\n        doTransferOut(baseToken, to, amount);\\n\\n        emit WithdrawReserves(to, amount);\\n    }\\n\\n    /**\\n     * @notice Sets Comet's ERC20 allowance of an asset for a manager\\n     * @dev Only callable by governor\\n     * @dev Note: Setting the `asset` as Comet's address will allow the manager\\n     * to withdraw from Comet's Comet balance\\n     * @param asset The asset that the manager will gain approval of\\n     * @param manager The account which will be allowed or disallowed\\n     * @param amount The amount of an asset to approve\\n     */\\n    function approveThis(\\n        address manager,\\n        address asset,\\n        uint amount\\n    ) external override {\\n        if (msg.sender != governor) revert Unauthorized();\\n\\n        ERC20(asset).approve(manager, amount);\\n    }\\n\\n    /**\\n     * @notice Get the total number of tokens in circulation\\n     * @dev Note: uses updated interest indices to calculate\\n     * @return The supply of tokens\\n     **/\\n    function totalSupply() external view override returns (uint256) {\\n        (uint64 baseSupplyIndex_, ) = accruedInterestIndices(\\n            getNowInternal() - lastAccrualTime\\n        );\\n        return presentValueSupply(baseSupplyIndex_, totalSupplyBase);\\n    }\\n\\n    /**\\n     * @notice Get the total amount of debt\\n     * @dev Note: uses updated interest indices to calculate\\n     * @return The amount of debt\\n     **/\\n    function totalBorrow() external view override returns (uint256) {\\n        (, uint64 baseBorrowIndex_) = accruedInterestIndices(\\n            getNowInternal() - lastAccrualTime\\n        );\\n        return presentValueBorrow(baseBorrowIndex_, totalBorrowBase);\\n    }\\n\\n    /**\\n     * @notice Query the current positive base balance of an account or zero\\n     * @dev Note: uses updated interest indices to calculate\\n     * @param account The account whose balance to query\\n     * @return The present day base balance magnitude of the account, if positive\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        (uint64 baseSupplyIndex_, ) = accruedInterestIndices(\\n            getNowInternal() - lastAccrualTime\\n        );\\n        int104 principal = userBasic[account].principal;\\n        return\\n            principal > 0\\n                ? presentValueSupply(baseSupplyIndex_, unsigned104(principal))\\n                : 0;\\n    }\\n\\n    /**\\n     * @notice Query the current negative base balance of an account or zero\\n     * @dev Note: uses updated interest indices to calculate\\n     * @param account The account whose balance to query\\n     * @return The present day base balance magnitude of the account, if negative\\n     */\\n    function borrowBalanceOf(\\n        address account\\n    ) public view override returns (uint256) {\\n        (, uint64 baseBorrowIndex_) = accruedInterestIndices(\\n            getNowInternal() - lastAccrualTime\\n        );\\n        int104 principal = userBasic[account].principal;\\n        return\\n            principal < 0\\n                ? presentValueBorrow(baseBorrowIndex_, unsigned104(-principal))\\n                : 0;\\n    }\\n\\n    /**\\n     * @notice Fallback to calling the extension delegate for everything else\\n     */\\n    fallback() external payable {\\n        address delegate = extensionDelegate;\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), delegate, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/KompuConfiguration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @title Compound's Comet Configuration Interface\\n * @author Compound\\n */\\ncontract KompuConfiguration {\\n    struct ExtConfiguration {\\n        bytes32 name32;\\n        bytes32 symbol32;\\n    }\\n\\n    struct Configuration {\\n        address governor;\\n        address pauseGuardian;\\n        address baseToken;\\n        address baseTokenPriceFeed;\\n        address extensionDelegate;\\n        uint64 supplyKink;\\n        uint64 supplyPerYearInterestRateSlopeLow;\\n        uint64 supplyPerYearInterestRateSlopeHigh;\\n        uint64 supplyPerYearInterestRateBase;\\n        uint64 borrowKink;\\n        uint64 borrowPerYearInterestRateSlopeLow;\\n        uint64 borrowPerYearInterestRateSlopeHigh;\\n        uint64 borrowPerYearInterestRateBase;\\n        uint64 storeFrontPriceFactor;\\n        uint64 trackingIndexScale;\\n        uint64 rewardKink;\\n        uint64 baseTrackingRewardSpeed;\\n        uint104 baseMinForRewards;\\n        uint104 baseBorrowMin;\\n        uint104 targetReserves;\\n        AssetConfig[] assetConfigs;\\n    }\\n\\n    struct AssetConfig {\\n        address asset;\\n        address priceFeed;\\n        uint8 decimals;\\n        uint64 borrowCollateralFactor;\\n        uint64 liquidateCollateralFactor;\\n        uint64 liquidationFactor;\\n        uint128 supplyCap;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/KompuCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"./KompuConfiguration.sol\\\";\\nimport \\\"./CometStorage.sol\\\";\\nimport \\\"./CometMath.sol\\\";\\n\\nabstract contract KompuCore is KompuConfiguration, CometStorage, CometMath {\\n    struct AssetInfo {\\n        uint8 offset;\\n        address asset;\\n        address priceFeed;\\n        uint64 scale;\\n        uint64 borrowCollateralFactor;\\n        uint64 liquidateCollateralFactor;\\n        uint64 liquidationFactor;\\n        uint128 supplyCap;\\n    }\\n\\n    /** Internal constants **/\\n\\n    /// @dev The max number of assets this contract is hardcoded to support\\n    ///  Do not change this variable without updating all the fields throughout the contract,\\n    //    including the size of UserBasic.assetsIn and corresponding integer conversions.\\n    uint8 internal constant MAX_ASSETS = 15;\\n\\n    /// @dev The max number of decimals base token can have\\n    ///  Note this cannot just be increased arbitrarily.\\n    uint8 internal constant MAX_BASE_DECIMALS = 18;\\n\\n    /// @dev The max value for a collateral factor (1)\\n    uint64 internal constant MAX_COLLATERAL_FACTOR = FACTOR_SCALE;\\n\\n    /// @dev Offsets for specific actions in the pause flag bit array\\n    uint8 internal constant PAUSE_SUPPLY_OFFSET = 0;\\n    uint8 internal constant PAUSE_TRANSFER_OFFSET = 1;\\n    uint8 internal constant PAUSE_WITHDRAW_OFFSET = 2;\\n    uint8 internal constant PAUSE_ABSORB_OFFSET = 3;\\n    uint8 internal constant PAUSE_BUY_OFFSET = 4;\\n\\n    /// @dev The decimals required for a price feed\\n    uint8 internal constant PRICE_FEED_DECIMALS = 8;\\n\\n    /// @dev 365 days * 24 hours * 60 minutes * 60 seconds\\n    uint64 internal constant SECONDS_PER_YEAR = 31_536_000;\\n\\n    /// @dev The scale for base tracking accrual\\n    uint64 internal constant BASE_ACCRUAL_SCALE = 1e6;\\n\\n    /// @dev The scale for base index (depends on time/rate scales, not base token)\\n    uint64 internal constant BASE_INDEX_SCALE = 1e15;\\n\\n    /// @dev The scale for prices (in USD)\\n    uint64 internal constant PRICE_SCALE = uint64(10 ** PRICE_FEED_DECIMALS);\\n\\n    /// @dev The scale for factors\\n    uint64 internal constant FACTOR_SCALE = 1e18;\\n\\n    /**\\n     * @notice Determine if the manager has permission to act on behalf of the owner\\n     * @param owner The owner account\\n     * @param manager The manager account\\n     * @return Whether or not the manager has permission\\n     */\\n    function hasPermission(\\n        address owner,\\n        address manager\\n    ) public view returns (bool) {\\n        return owner == manager || isAllowed[owner][manager];\\n    }\\n\\n    /**\\n     * @dev The positive present supply balance if positive or the negative borrow balance if negative\\n     */\\n    function presentValue(\\n        int104 principalValue_\\n    ) internal view returns (int256) {\\n        if (principalValue_ >= 0) {\\n            return\\n                signed256(\\n                    presentValueSupply(\\n                        baseSupplyIndex,\\n                        uint104(principalValue_)\\n                    )\\n                );\\n        } else {\\n            return\\n                -signed256(\\n                    presentValueBorrow(\\n                        baseBorrowIndex,\\n                        uint104(-principalValue_)\\n                    )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev The principal amount projected forward by the supply index\\n     */\\n    function presentValueSupply(\\n        uint64 baseSupplyIndex_,\\n        uint104 principalValue_\\n    ) internal pure returns (uint256) {\\n        return (uint256(principalValue_) * baseSupplyIndex_) / BASE_INDEX_SCALE;\\n    }\\n\\n    /**\\n     * @dev The principal amount projected forward by the borrow index\\n     */\\n    function presentValueBorrow(\\n        uint64 baseBorrowIndex_,\\n        uint104 principalValue_\\n    ) internal pure returns (uint256) {\\n        return (uint256(principalValue_) * baseBorrowIndex_) / BASE_INDEX_SCALE;\\n    }\\n\\n    /**\\n     * @dev The positive principal if positive or the negative principal if negative\\n     */\\n    function principalValue(\\n        int256 presentValue_\\n    ) internal view returns (int104) {\\n        if (presentValue_ >= 0) {\\n            return\\n                signed104(\\n                    principalValueSupply(\\n                        baseSupplyIndex,\\n                        uint256(presentValue_)\\n                    )\\n                );\\n        } else {\\n            return\\n                -signed104(\\n                    principalValueBorrow(\\n                        baseBorrowIndex,\\n                        uint256(-presentValue_)\\n                    )\\n                );\\n        }\\n    }\\n\\n    /**\\n     * @dev The present value projected backward by the supply index (rounded down)\\n     *  Note: This will overflow (revert) at 2^104/1e18=~20 trillion principal for assets with 18 decimals.\\n     */\\n    function principalValueSupply(\\n        uint64 baseSupplyIndex_,\\n        uint256 presentValue_\\n    ) internal pure returns (uint104) {\\n        return safe104((presentValue_ * BASE_INDEX_SCALE) / baseSupplyIndex_);\\n    }\\n\\n    /**\\n     * @dev The present value projected backward by the borrow index (rounded up)\\n     *  Note: This will overflow (revert) at 2^104/1e18=~20 trillion principal for assets with 18 decimals.\\n     */\\n    function principalValueBorrow(\\n        uint64 baseBorrowIndex_,\\n        uint256 presentValue_\\n    ) internal pure returns (uint104) {\\n        return\\n            safe104(\\n                (presentValue_ * BASE_INDEX_SCALE + baseBorrowIndex_ - 1) /\\n                    baseBorrowIndex_\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/KompuMainInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"./KompuCore.sol\\\";\\n\\n/**\\n * @title Compound's Comet Main Interface (without Ext)\\n * @notice An efficient monolithic money market protocol\\n * @author Compound\\n */\\nabstract contract KompuMainInterface is KompuCore {\\n    error Absurd();\\n    error AlreadyInitialized();\\n    error BadAsset();\\n    error BadDecimals();\\n    error BadDiscount();\\n    error BadMinimum();\\n    error BadPrice();\\n    error BorrowTooSmall();\\n    error BorrowCFTooLarge();\\n    error InsufficientReserves();\\n    error LiquidateCFTooLarge();\\n    error NoSelfTransfer();\\n    error NotCollateralized();\\n    error NotForSale();\\n    error NotLiquidatable();\\n    error Paused();\\n    error SupplyCapExceeded();\\n    error TimestampTooLarge();\\n    error TooManyAssets();\\n    error TooMuchSlippage();\\n    error TransferInFailed();\\n    error TransferOutFailed();\\n    error Unauthorized();\\n\\n    event Supply(address indexed from, address indexed dst, uint amount);\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Withdraw(address indexed src, address indexed to, uint amount);\\n\\n    event SupplyCollateral(\\n        address indexed from,\\n        address indexed dst,\\n        address indexed asset,\\n        uint amount\\n    );\\n    event TransferCollateral(\\n        address indexed from,\\n        address indexed to,\\n        address indexed asset,\\n        uint amount\\n    );\\n    event WithdrawCollateral(\\n        address indexed src,\\n        address indexed to,\\n        address indexed asset,\\n        uint amount\\n    );\\n\\n    /// @notice Event emitted when a borrow position is absorbed by the protocol\\n    event AbsorbDebt(\\n        address indexed absorber,\\n        address indexed borrower,\\n        uint basePaidOut,\\n        uint usdValue\\n    );\\n\\n    /// @notice Event emitted when a user's collateral is absorbed by the protocol\\n    event AbsorbCollateral(\\n        address indexed absorber,\\n        address indexed borrower,\\n        address indexed asset,\\n        uint collateralAbsorbed,\\n        uint usdValue\\n    );\\n\\n    /// @notice Event emitted when a collateral asset is purchased from the protocol\\n    event BuyCollateral(\\n        address indexed buyer,\\n        address indexed asset,\\n        uint baseAmount,\\n        uint collateralAmount\\n    );\\n\\n    /// @notice Event emitted when an action is paused/unpaused\\n    event PauseAction(\\n        bool supplyPaused,\\n        bool transferPaused,\\n        bool withdrawPaused,\\n        bool absorbPaused,\\n        bool buyPaused\\n    );\\n\\n    /// @notice Event emitted when reserves are withdrawn by the governor\\n    event WithdrawReserves(address indexed to, uint amount);\\n\\n    function supply(address asset, uint amount) external virtual;\\n\\n    function supplyTo(address dst, address asset, uint amount) external virtual;\\n\\n    function supplyFrom(\\n        address from,\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function transfer(address dst, uint amount) external virtual returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint amount\\n    ) external virtual returns (bool);\\n\\n    function transferAsset(\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function transferAssetFrom(\\n        address src,\\n        address dst,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function withdraw(address asset, uint amount) external virtual;\\n\\n    function withdrawTo(\\n        address to,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function withdrawFrom(\\n        address src,\\n        address to,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function approveThis(\\n        address manager,\\n        address asset,\\n        uint amount\\n    ) external virtual;\\n\\n    function withdrawReserves(address to, uint amount) external virtual;\\n\\n    function absorb(\\n        address absorber,\\n        address[] calldata accounts\\n    ) external virtual;\\n\\n    function buyCollateral(\\n        address asset,\\n        uint minAmount,\\n        uint baseAmount,\\n        address recipient\\n    ) external virtual;\\n\\n    function quoteCollateral(\\n        address asset,\\n        uint baseAmount\\n    ) public view virtual returns (uint);\\n\\n    function getAssetInfo(\\n        uint8 i\\n    ) public view virtual returns (AssetInfo memory);\\n\\n    function getAssetInfoByAddress(\\n        address asset\\n    ) public view virtual returns (AssetInfo memory);\\n\\n    function getCollateralReserves(\\n        address asset\\n    ) public view virtual returns (uint);\\n\\n    function getReserves() public view virtual returns (int);\\n\\n    function getPrice(address priceFeed) public view virtual returns (uint);\\n\\n    function isBorrowCollateralized(\\n        address account\\n    ) public view virtual returns (bool);\\n\\n    function isLiquidatable(address account) public view virtual returns (bool);\\n\\n    function totalSupply() external view virtual returns (uint256);\\n\\n    function totalBorrow() external view virtual returns (uint256);\\n\\n    function balanceOf(address owner) public view virtual returns (uint256);\\n\\n    function borrowBalanceOf(\\n        address account\\n    ) public view virtual returns (uint256);\\n\\n    function pause(\\n        bool supplyPaused,\\n        bool transferPaused,\\n        bool withdrawPaused,\\n        bool absorbPaused,\\n        bool buyPaused\\n    ) external virtual;\\n\\n    function isSupplyPaused() public view virtual returns (bool);\\n\\n    function isTransferPaused() public view virtual returns (bool);\\n\\n    function isWithdrawPaused() public view virtual returns (bool);\\n\\n    function isAbsorbPaused() public view virtual returns (bool);\\n\\n    function isBuyPaused() public view virtual returns (bool);\\n\\n    function accrueAccount(address account) external virtual;\\n\\n    function getSupplyRate(\\n        uint utilization\\n    ) public view virtual returns (uint64);\\n\\n    function getBorrowRate(\\n        uint utilization\\n    ) public view virtual returns (uint64);\\n\\n    function getUtilization() public view virtual returns (uint);\\n\\n    function governor() external view virtual returns (address);\\n\\n    function pauseGuardian() external view virtual returns (address);\\n\\n    function baseToken() external view virtual returns (address);\\n\\n    function baseTokenPriceFeed() external view virtual returns (address);\\n\\n    function extensionDelegate() external view virtual returns (address);\\n\\n    /// @dev uint64\\n    function supplyKink() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateSlopeLow()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateSlopeHigh()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function supplyPerSecondInterestRateBase()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function borrowKink() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateSlopeLow()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateSlopeHigh()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function borrowPerSecondInterestRateBase()\\n        external\\n        view\\n        virtual\\n        returns (uint);\\n\\n    /// @dev uint64\\n    function storeFrontPriceFactor() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function baseScale() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function trackingIndexScale() external view virtual returns (uint);\\n\\n    function rewardKink() external view virtual returns (uint);\\n\\n    function baseTrackingRewardSpeed() external view virtual returns (uint);\\n\\n    /// @dev uint104\\n    function baseTrackingSupplySpeed() external view virtual returns (uint);\\n\\n    /// @dev uint64\\n    function baseTrackingBorrowSpeed() external view virtual returns (uint);\\n\\n    /// @dev uint104\\n    function baseMinForRewards() external view virtual returns (uint);\\n\\n    /// @dev uint104\\n    function baseBorrowMin() external view virtual returns (uint);\\n\\n    /// @dev uint104\\n    function targetReserves() external view virtual returns (uint);\\n\\n    function numAssets() external view virtual returns (uint8);\\n\\n    function decimals() external view virtual returns (uint8);\\n\\n    function initializeStorage() external virtual;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1,\r\n      \"details\": {\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf [xa[r]scLM cCTUtTOntnfDIul Lcul Vcul [j] Tpeul xa[rul] xa[r]cL gvif CTUca[r]LsTOtfDnca[r]Iulc] jmul[jul] VcTOcul jmul\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pauseGuardian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"baseTokenPriceFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"extensionDelegate\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"supplyKink\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"supplyPerYearInterestRateSlopeLow\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"supplyPerYearInterestRateSlopeHigh\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"supplyPerYearInterestRateBase\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"borrowKink\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"borrowPerYearInterestRateSlopeLow\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"borrowPerYearInterestRateSlopeHigh\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"borrowPerYearInterestRateBase\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"storeFrontPriceFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"trackingIndexScale\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rewardKink\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"baseTrackingRewardSpeed\",\"type\":\"uint64\"},{\"internalType\":\"uint104\",\"name\":\"baseMinForRewards\",\"type\":\"uint104\"},{\"internalType\":\"uint104\",\"name\":\"baseBorrowMin\",\"type\":\"uint104\"},{\"internalType\":\"uint104\",\"name\":\"targetReserves\",\"type\":\"uint104\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"borrowCollateralFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidateCollateralFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidationFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"supplyCap\",\"type\":\"uint128\"}],\"internalType\":\"struct KompuConfiguration.AssetConfig[]\",\"name\":\"assetConfigs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct KompuConfiguration.Configuration\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Absurd\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadAsset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadDecimals\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadDiscount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadMinimum\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowCFTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BorrowTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientReserves\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInt104\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInt256\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUInt104\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUInt128\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUInt64\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidateCFTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NegativeNumber\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSelfTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCollateralized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotForSale\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotLiquidatable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplyCapExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimestampTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooManyAssets\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooMuchSlippage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferInFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferOutFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"absorber\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAbsorbed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"name\":\"AbsorbCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"absorber\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basePaidOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdValue\",\"type\":\"uint256\"}],\"name\":\"AbsorbDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"name\":\"BuyCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"supplyPaused\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"transferPaused\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"withdrawPaused\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"absorbPaused\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"buyPaused\",\"type\":\"bool\"}],\"name\":\"PauseAction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Supply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SupplyCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawReserves\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"absorber\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"absorb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"accrueAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveThis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseBorrowMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseMinForRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenPriceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTrackingBorrowSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTrackingRewardSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTrackingSupplySpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"borrowBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowKink\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowPerSecondInterestRateBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowPerSecondInterestRateSlopeHigh\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"borrowPerSecondInterestRateSlopeLow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"buyCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extensionDelegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"i\",\"type\":\"uint8\"}],\"name\":\"getAssetInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"offset\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"scale\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"borrowCollateralFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidateCollateralFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidationFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"supplyCap\",\"type\":\"uint128\"}],\"internalType\":\"struct KompuCore.AssetInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getAssetInfoByAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"offset\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"scale\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"borrowCollateralFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidateCollateralFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"liquidationFactor\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"supplyCap\",\"type\":\"uint128\"}],\"internalType\":\"struct KompuCore.AssetInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"}],\"name\":\"getBaseTrackingBorrowSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"}],\"name\":\"getBaseTrackingSupplySpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"}],\"name\":\"getBorrowRate\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getCollateralReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"priceFeed\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"}],\"name\":\"getSupplyRate\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUtilization\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"hasPermission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAbsorbPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBorrowCollateralized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBuyPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isLiquidatable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSupplyPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTransferPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWithdrawPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidatorPoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"numAbsorbs\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"numAbsorbed\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"approxSpend\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_reserved\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numAssets\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"supplyPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"transferPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withdrawPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"absorbPaused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"buyPaused\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseGuardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"}],\"name\":\"quoteCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardKink\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storeFrontPriceFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supplyFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyKink\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyPerSecondInterestRateBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyPerSecondInterestRateSlopeHigh\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyPerSecondInterestRateSlopeLow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supplyTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalsCollateral\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"totalSupplyAsset\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_reserved\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trackingIndexScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferAssetFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBasic\",\"outputs\":[{\"internalType\":\"int104\",\"name\":\"principal\",\"type\":\"int104\"},{\"internalType\":\"uint64\",\"name\":\"baseTrackingIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"baseTrackingAccrued\",\"type\":\"uint64\"},{\"internalType\":\"uint16\",\"name\":\"assetsIn\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_reserved\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userCollateral\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"balance\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_reserved\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Kompu", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000b0a167a0b6800207c89544d2ebdc98dcdd33bec000000000000000000000000153d9dd730083e53615610a0d2f6f95ab5a0bc010000000000000000000000001cfa5641c01406ab8ac350ded7d735ec41298372000000000000000000000000bce206cae7f0ec07b545edde332a47c2f75bbeb3000000000000000000000000d0e5a7cf47128d5779e6d9c92011db9a888442fc0000000000000000000000000000000000000000000000000c7d713b49da0000000000000000000000000000000000000000000000000000008e1bc9bf0400000000000000000000000000000000000000000000000000000dbd2fc137a3000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c7d713b49da00000000000000000000000000000000000000000000000000000058d15e176280000000000000000000000000000000000000000000000000000dbd2fc137a300000000000000000000000000000000000000000000000000000061b31ab352c00000000000000000000000000000000000000000000000000006f05b59d3b2000000000000000000000000000000000000000000000000000000038d7ea4c680000000000000000000000000000000000000000000000000000bcbce7f1b1500000000000000000000000000000000000000000000000000000000000e0ea163c0000000000000000000000000000000000000000000084595161401484a00000000000000000000000000000000000000000000000000003635c9adc5dea000000000000000000000000000000000000000000000000422ca8b0a00a42500000000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000004000000000000000000000000961dd84059505d59f82ce4fb87d3c09bec65301d0000000000000000000000007354fbf446fff15db6c7c2b8a4a84bfc092b648500000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000b1a2bc2ec5000000000000000000000000000000000000000000000000000000c7d713b49da00000000000000000000000000000000000000000000000000000c7d713b49da0000000000000000000000000000000000000000000000000000000009184e72a0000000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca000000000000000000000000096cf272b16d3aec1933b593b25e3c60f173390ee00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000bcbce7f1b1500000000000000000000000000000000000000000000000000000d2f13f7789f00000000000000000000000000000000000000000000000000000d2f13f7789f0000000000000000000000000000000000000000000000000a968163f0a57b400000000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000008fffffd4afb6115b954bd326cbe7b4ba576818f600000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000d2f13f7789f00000000000000000000000000000000000000000000000000000d99a8cec7e200000000000000000000000000000000000000000000000000000d2f13f7789f000000000000000000000000000000000000000000000000000000005af3107a4000000000000000000000000000f939e0a03fb07f59a73314e73794be0e57ac1b4e000000000000000000000000eef0c605546958c1f899b6fb336c20671f9cd49f00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000d2f13f7789f00000000000000000000000000000000000000000000000000000d99a8cec7e200000000000000000000000000000000000000000000000000000d2f13f7789f000000000000000000000000000000000000000000000052b7d2dcc80cd2e4000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}