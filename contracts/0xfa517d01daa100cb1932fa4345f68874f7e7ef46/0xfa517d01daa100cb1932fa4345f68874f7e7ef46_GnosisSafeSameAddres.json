{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/multisigs/GnosisSafeSameAddressMultisig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.21;\\n\\n// Gnosis Safe Master Copy interface extracted from the mainnet: https://etherscan.io/address/0xd9db270c1b5e3bd161e8c8503c55ceabee709552#code#F6#L126\\ninterface IGnosisSafe {\\n    /// @dev Gets set of owners.\\n    /// @return Set of Safe owners.\\n    function getOwners() external view returns (address[] memory);\\n\\n    /// @dev Gets threshold.\\n    /// @return Threshold\\n    function getThreshold() external view returns (uint256);\\n}\\n\\n/// @dev Zero value when it has to be different from zero.\\nerror ZeroValue();\\n\\n/// @dev Provided zero address.\\nerror ZeroAddress();\\n\\n/// @dev Multisig proxy bytecode is not whitelisted.\\n/// @param multisig Address of a multisig proxy.\\nerror UnauthorizedMultisig(address multisig);\\n\\n/// @dev Provided incorrect data length.\\n/// @param expected Expected minimum data length.\\n/// @param provided Provided data length.\\nerror IncorrectDataLength(uint256 expected, uint256 provided);\\n\\n/// @dev Provided incorrect multisig threshold.\\n/// @param expected Expected threshold.\\n/// @param provided Provided threshold.\\nerror WrongThreshold(uint256 expected, uint256 provided);\\n\\n/// @dev Provided incorrect number of owners.\\n/// @param expected Expected number of owners.\\n/// @param provided Provided number of owners.\\nerror WrongNumOwners(uint256 expected, uint256 provided);\\n\\n/// @dev Provided incorrect multisig owner.\\n/// @param provided Provided owner address.\\nerror WrongOwner(address provided);\\n\\n/// @dev Multisig transaction resulted in a failure.\\n/// @param provided Provided multisig address.\\nerror MultisigExecFailed(address provided);\\n\\n/// @title Gnosis Safe Same Address - Smart contract for Gnosis Safe verification of an already existent multisig address.\\n/// @author Aleksandr Kuperman - <aleksandr.kuperman@valory.xyz>\\ncontract GnosisSafeSameAddressMultisig {\\n    // Default data size to be parsed as an address of a Gnosis Safe multisig proxy address\\n    // This exact size suggests that all the changes to the multisig have been performed and only validation is needed\\n    uint256 public constant DEFAULT_DATA_LENGTH = 20;\\n\\n    // Approved multisig proxy hash\\n    bytes32 public immutable proxyHash;\\n\\n    /// @dev GnosisSafeSameAddressMultisig constructor.\\n    /// @param _proxyHash Approved multisig proxy hash.\\n    constructor(bytes32 _proxyHash) {\\n        if (_proxyHash == bytes32(0)) {\\n            revert ZeroValue();\\n        }\\n\\n        // Record provided multisig proxy bytecode hash\\n        proxyHash = _proxyHash;\\n    }\\n\\n    /// @dev Updates and/or verifies the existent gnosis safe multisig for changed owners and threshold.\\n    /// @notice This function operates with existent multisig proxy that is requested to be updated in terms of\\n    ///         the set of owners' addresses and the threshold. There are two scenarios possible:\\n    ///         1. The multisig proxy is already updated before reaching this function. Then the multisig address\\n    ///            must be passed as a payload such that its owners and threshold are verified against those specified\\n    ///            in the argument list.\\n    ///         2. The multisig proxy is not yet updated. Then the multisig address must be passed in a packed bytes of\\n    ///            data along with the Gnosis Safe `execTransaction()` function arguments packed payload. That payload\\n    ///            is going to modify the mulsisig proxy as per its signed transaction. At the end, the updated multisig\\n    ///            proxy is going to be verified with the provided set of owners' addresses and the threshold.\\n    ///         Note that owners' addresses in the multisig are stored in reverse order compared to how they were added:\\n    ///         https://etherscan.io/address/0xd9db270c1b5e3bd161e8c8503c55ceabee709552#code#F6#L56\\n    /// @param owners Set of updated multisig owners to verify against.\\n    /// @param threshold Updated number for multisig transaction confirmations.\\n    /// @param data Packed data containing address of an existent gnosis safe multisig and a payload to call the multisig with.\\n    /// @return multisig Address of a multisig (proxy).\\n    function create(\\n        address[] memory owners,\\n        uint256 threshold,\\n        bytes memory data\\n    ) external returns (address multisig)\\n    {\\n        // Check for the correct data length\\n        uint256 dataLength = data.length;\\n        if (dataLength < DEFAULT_DATA_LENGTH) {\\n            revert IncorrectDataLength(DEFAULT_DATA_LENGTH, data.length);\\n        }\\n\\n        // Read the proxy multisig address (20 bytes) and the multisig-related data\\n        assembly {\\n            multisig := mload(add(data, DEFAULT_DATA_LENGTH))\\n        }\\n\\n        // Check that the multisig address corresponds to the authorized multisig proxy bytecode hash\\n        bytes32 multisigProxyHash = keccak256(multisig.code);\\n        if (proxyHash != multisigProxyHash) {\\n            revert UnauthorizedMultisig(multisig);\\n        }\\n\\n        // If provided, read the payload that is going to change the multisig ownership and threshold\\n        // The payload is expected to be the `execTransaction()` function call with all its arguments and signature(s)\\n        if (dataLength > DEFAULT_DATA_LENGTH) {\\n            uint256 payloadLength = dataLength - DEFAULT_DATA_LENGTH;\\n            bytes memory payload = new bytes(payloadLength);\\n            for (uint256 i = 0; i < payloadLength; ++i) {\\n                payload[i] = data[i + DEFAULT_DATA_LENGTH];\\n            }\\n\\n            // Call the multisig with the provided payload\\n            (bool success, ) = multisig.call(payload);\\n            if (!success) {\\n                revert MultisigExecFailed(multisig);\\n            }\\n        }\\n\\n        // Get the provided proxy multisig owners and threshold\\n        address[] memory checkOwners = IGnosisSafe(multisig).getOwners();\\n        uint256 checkThreshold = IGnosisSafe(multisig).getThreshold();\\n\\n        // Verify updated multisig proxy for provided owners and threshold\\n        if (threshold != checkThreshold) {\\n            revert WrongThreshold(checkThreshold, threshold);\\n        }\\n        uint256 numOwners = owners.length;\\n        if (numOwners != checkOwners.length) {\\n            revert WrongNumOwners(checkOwners.length, numOwners);\\n        }\\n        // The owners' addresses in the multisig itself are stored in reverse order compared to how they were added:\\n        // https://etherscan.io/address/0xd9db270c1b5e3bd161e8c8503c55ceabee709552#code#F6#L56\\n        // Thus, the check must be carried out accordingly.\\n        for (uint256 i = 0; i < numOwners; ++i) {\\n            if (owners[i] != checkOwners[numOwners - i - 1]) {\\n                revert WrongOwner(owners[i]);\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 750\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proxyHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"}],\"name\":\"IncorrectDataLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provided\",\"type\":\"address\"}],\"name\":\"MultisigExecFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"multisig\",\"type\":\"address\"}],\"name\":\"UnauthorizedMultisig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"}],\"name\":\"WrongNumOwners\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"provided\",\"type\":\"address\"}],\"name\":\"WrongOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"}],\"name\":\"WrongThreshold\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DEFAULT_DATA_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"multisig\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GnosisSafeSameAddressMultisig", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "750", "ConstructorArguments": "b89c1b3bdf2cf8827818646bce9a8f6e372885f8c55e5c07acbd307cb133b000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}