{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Multisig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Tells the Solidity compiler to compile only from v0.8.13 to v0.9.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AccessControl.sol\\\";\\n\\ncontract Multisig {\\n\\n    address[] public owners;\\n    mapping (address => bool) public isOwner;\\n    uint256 public requiredSignatures;\\n    uint public timelock;\\n    uint public maxTimeLock;\\n    AccessControl accessControl;\\n\\n    event Approved(uint transactionId, uint8 operation);\\n    event Executed(uint transactionId, uint8 operation);\\n    event NewTransaction(uint transactionId, uint8 operation, bool add);\\n\\n    struct Custodian {\\n        address[] newCustodianAddress;\\n        uint8[] custodianCategories;\\n        uint256 unlockTimestamp;\\n        bool executed;\\n        bool add; // true to add false to remove\\n    }\\n\\n    struct Token {\\n        address newTokenAddress;\\n        uint256 unlockTimestamp;\\n        bool executed;\\n        bool add; // true to add false to remove\\n    }\\n\\n    Custodian[] public CustodianTransactions;    \\n    Token[] public TokenTransactions;    \\n\\n    mapping(uint => mapping(uint => mapping(address => bool))) public approved;\\n\\n    modifier onlyOwner(){\\n        require(isOwner[msg.sender], \\\"not owner\\\");\\n        _;\\n    }\\n\\n    modifier txValid(uint _transactionId, uint8 _operation){\\n        if (_operation == 1){\\n            require (_transactionId < CustodianTransactions.length, \\\"invalid tx id\\\");\\n            }\\n        if (_operation == 2){\\n            require (_transactionId < TokenTransactions.length, \\\"invalid tx id\\\");\\n         }\\n         _;\\n    }\\n\\n    modifier txNotExecuted(uint _transactionId, uint8 _operation){\\n        if (_operation == 1){\\n            require (CustodianTransactions[_transactionId].executed == false, \\\"tx already executed\\\");\\n        }\\n        if (_operation == 2){\\n            require (TokenTransactions[_transactionId].executed == false, \\\"tx already executed\\\");\\n        }\\n        _;\\n    }\\n\\n    function _getTimestamp() private view returns (uint timestamp){\\n        bool overflow= false;\\n        (overflow, timestamp) = _tryAdd(block.number, timelock);\\n        require (overflow, \\\"timelock overflow\\\");\\n    }\\n\\n    function _checkTimelocks(uint proposedUnlockTime) private view { \\n        require (proposedUnlockTime < block.number, \\\"timelock not met\\\");\\n        (bool overflow, uint staleTime) = _tryAdd(proposedUnlockTime, maxTimeLock);\\n        require (overflow, \\\"timelock overflow\\\");\\n        require (staleTime > block.number, \\\"transaction staled\\\");\\n    }\\n\\n    constructor(address[] memory _owners, uint _requiredSignatures, address _accessControlAddress, uint _timelockInDays)\\n    {\\n        require(_owners.length > 0, \\\"not valid owners\\\");\\n        require(_requiredSignatures > 0 && _requiredSignatures <= _owners.length, \\\"invalid data\\\");\\n        require(_timelockInDays > 0, \\\"invalid timelock\\\");\\n        _checkZeroAddress(_accessControlAddress);\\n        accessControl = AccessControl(_accessControlAddress);\\n\\n        for (uint i=0; i< _owners.length; i++){\\n            _checkZeroAddress(_owners[i]);\\n            require(!isOwner[_owners[i]], \\\"owner not unique\\\");\\n            isOwner[_owners[i]] = true;\\n            owners.push(_owners[i]);\\n        }\\n\\n        bool overflow = false;\\n        bool overflow2 = false;\\n\\n        (overflow, timelock) = _tryMul(7200, _timelockInDays);\\n        require (overflow, \\\"timelock overflow\\\");\\n        (overflow2, maxTimeLock) = _tryMul(timelock, 2); //transaction goes stale after 3* timelock (1+2)\\n        require (overflow2, \\\"maxTimelock overflow\\\");\\n        requiredSignatures = _requiredSignatures;\\n    }\\n\\n    function submitCustodiansAllowable(address[] memory _newCustodianAddresses, uint8[] memory _custodianCategories) public onlyOwner {\\n        CustodianTransactions.push(Custodian({\\n            newCustodianAddress: _newCustodianAddresses,\\n            custodianCategories: _custodianCategories,\\n            unlockTimestamp: _getTimestamp(),\\n            executed: false,\\n            add: true\\n        }));\\n        emit NewTransaction(CustodianTransactions.length -1, 1, true);\\n    }\\n\\n    function submitCustodiansRemoved(address[] memory _newCustodianAddresses) public onlyOwner {\\n        uint8[] memory emptyArray;\\n        CustodianTransactions.push(Custodian({\\n            newCustodianAddress: _newCustodianAddresses,\\n            custodianCategories: emptyArray,\\n            unlockTimestamp: _getTimestamp(),\\n            executed: false,\\n            add: false\\n        }));\\n        emit NewTransaction(CustodianTransactions.length -1, 1, false);\\n    }\\n\\n    function submitTokenAllowed(address _newTokenAddress) public onlyOwner {\\n        TokenTransactions.push(Token({\\n            newTokenAddress: _newTokenAddress,\\n            unlockTimestamp: _getTimestamp(),\\n            executed: false,\\n            add: true\\n        }));\\n        emit NewTransaction(TokenTransactions.length -1, 2, true);\\n    }\\n\\n    function submitTokenRemoved(address _newTokenAddress) public onlyOwner {\\n        TokenTransactions.push(Token({\\n            newTokenAddress: _newTokenAddress,\\n            unlockTimestamp: _getTimestamp(),\\n            executed: false,\\n            add: false\\n        }));\\n        emit NewTransaction(TokenTransactions.length -1, 2, false);\\n    }\\n\\n    function approveTransaction(uint _transactionId, uint8 _operationType) public \\n        onlyOwner() \\n        txValid(_transactionId, _operationType)\\n        txNotExecuted(_transactionId, _operationType) { // 1 for custodian 2 for token\\n        require (!approved[_transactionId][_operationType][msg.sender], \\\"tx already approved\\\");\\n        approved[_transactionId][_operationType][msg.sender] = true;\\n        emit Approved(_transactionId, _operationType); \\n    }\\n\\n    function executeTransaction(uint _transactionId, uint8 _operationType) external\\n    onlyOwner()\\n    txValid(_transactionId, _operationType)\\n    txNotExecuted(_transactionId, _operationType) {\\n        require(_getApprovalCount(_transactionId, _operationType) >= requiredSignatures, \\\"not enough approvals\\\");\\n        if (_operationType == 1){\\n            Custodian storage custodian = CustodianTransactions[_transactionId];\\n            _checkTimelocks(custodian.unlockTimestamp);\\n            custodian.executed = true;\\n            if (custodian.add){\\n                accessControl.setMultipleCustodiansAllowable(custodian.newCustodianAddress, custodian.custodianCategories);\\n            } else {\\n                for (uint i = 0; i< custodian.newCustodianAddress.length; i++){\\n                    accessControl.removeCustodianAllowable(custodian.newCustodianAddress[i]);\\n                }\\n            }\\n        }\\n        if (_operationType == 2){\\n            Token storage token = TokenTransactions[_transactionId];\\n            _checkTimelocks(token.unlockTimestamp);\\n            token.executed = true;\\n            if (token.add) {\\n                accessControl.setTokenAllowable(token.newTokenAddress);\\n            } else {\\n                accessControl.removeTokenAllowable(token.newTokenAddress);\\n            }\\n        }\\n        emit Executed(_transactionId, _operationType);\\n    }\\n\\n    function _getApprovalCount(uint _transactionId, uint8 _operation) private view returns (uint count){\\n        for (uint i = 0; i < owners.length; i++) {\\n            if (approved[_transactionId][_operation][owners[i]]){\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    function getCustodianData(uint _transactionId) public view returns (address[] memory _custodians, uint8[] memory _category, \\n        uint256 _unlockBlock, bool _executed, bool _add){\\n        Custodian memory data = CustodianTransactions[_transactionId];\\n        _custodians = data.newCustodianAddress;\\n        _category = data.custodianCategories;\\n        _unlockBlock = data.unlockTimestamp;\\n        _executed = data.executed;\\n        _add = data.add;    \\n    }\\n\\n\\n    function _checkZeroAddress(address _address) internal pure {\\n        require (_address != address(0), \\\"Invalid address\\\");\\n    }\\n\\n    //OPPENZEPPELIN functions\\n    function _tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n    function _tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/contracts/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Tells the Solidity compiler to compile only from v0.8.13 to v0.9.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ncontract AccessControl {    \\n\\n    address public owner;\\n    address public auditor;\\n    address public settlementContract;\\n\\n    bool public definedContract = false;\\n\\n    mapping(address => bool) private custodianAddresses; \\n    mapping(address => uint8) private custodianCategory; // 1 - Big custodians  2 - Individuals 10 - Marked as releasable\\n    mapping(address => bool) private allowableTokens;\\n\\n    event CustodianAdded(address custodianAddress, uint8 custodianCategory);\\n\\n\\n    constructor(address auditorAddress){\\n        checkZeroAddress(auditorAddress);\\n        auditor = auditorAddress;\\n        owner = msg.sender;\\n    }\\n\\n    function onlyOwner (address sentAddress) private view {\\n        require(sentAddress == owner, \\\"Not contract owner\\\");\\n        return;\\n    }\\n\\n    function checkZeroAddress(address _address) internal pure {\\n        require (_address != address(0), \\\"Invalid address\\\");\\n    }\\n\\n    function onlySettlementAndAuditor(address settlementContractOrAuditorAddress) private view {\\n        require((settlementContractOrAuditorAddress == auditor) || (settlementContractOrAuditorAddress == settlementContract), \\\"No permission to release\\\");\\n        return;\\n    }\\n\\n     function onlySettlement(address settlementContractOrAuditorAddress) private view {\\n        require((settlementContractOrAuditorAddress == settlementContract), \\\"No permission to lock\\\");\\n        return;\\n    }\\n\\n    function onlyAllowed (address sentAddress) external view {\\n        require(custodianAddresses[sentAddress] == true || sentAddress == auditor, \\\"Address not allowed\\\");\\n        return;\\n    }\\n\\n    function onlyAllowedToken(address tokenAddress) external view {\\n        require(allowableTokens[tokenAddress] == true, \\\"Token not allowed\\\");\\n        return;\\n    }\\n\\n    function isAuditor(address auditorAddress) external view returns (bool) {\\n        require(auditor == auditorAddress, \\\"Address is not the auditor\\\");\\n        return true;\\n    }\\n\\n    function markAsRelease(address custodianAddress) public {\\n        onlySettlementAndAuditor(msg.sender);\\n        require (custodianCategory[custodianAddress] == 2, \\\"Wrong custodian category\\\");\\n        custodianCategory[custodianAddress] = 10;\\n    }\\n\\n    function setMultipleCustodiansAllowable(address[] calldata newCustodianAddresses, uint8[] calldata custodianCategories) external {\\n        require(newCustodianAddresses.length == custodianCategories.length);\\n        onlyOwner(msg.sender);\\n        for (uint8 i = 0; i< newCustodianAddresses.length; i++){\\n            setCustodianAllowable(newCustodianAddresses[i], custodianCategories[i]);\\n        }\\n    }\\n\\n    function setCustodianAllowable(address custodianAddress, uint8 custodianCategoryValue) public {\\n        onlyOwner(msg.sender);\\n        checkZeroAddress(custodianAddress);\\n        custodianAddresses[custodianAddress] = true;\\n        custodianCategory[custodianAddress] = custodianCategoryValue;\\n        emit CustodianAdded(custodianAddress, custodianCategoryValue);\\n    }\\n\\n    function getCustodianAllowable(address custodianAddress) external view returns (bool, uint8) {\\n        return (custodianAddresses[custodianAddress], custodianCategory[custodianAddress]);\\n    }\\n\\n    function isVirtualCustodian(address custodianAddress) external view returns (bool) {\\n        return 2 == custodianCategory[custodianAddress];\\n    }\\n    function isBrickAndMortar(address custodianAddress) external view returns (bool){\\n        return 1 == custodianCategory[custodianAddress];\\n    }\\n\\n    function isReleased(address custodianAddress) external view returns (bool) {\\n        return 10 == custodianCategory[custodianAddress];\\n    }\\n\\n    function relockForVC(address custodianAddress) external {\\n        onlySettlement(msg.sender);\\n        if(custodianCategory[custodianAddress] == 10) custodianCategory[custodianAddress] = 2; //relocks custodian after marked for release\\n        require(custodianCategory[custodianAddress] == 2, \\\"Custodian category cannot lock funds\\\");\\n        return;\\n    }\\n\\n    function validateSettlement(address creditor, address debtor, bool releaseCreditor, bool releaseDebtor, address[] calldata tokenAddresses) external view{\\n        require ((custodianAddresses[creditor] && custodianAddresses[debtor]), \\\"Invalid creditor/debtor\\\");\\n        bool inconsistent = false;\\n        if (releaseCreditor && custodianCategory[creditor]!= 2){\\n            inconsistent = true;\\n        }\\n        if (releaseDebtor && custodianCategory[debtor]!= 2){\\n            inconsistent = true;\\n        }\\n        require(!inconsistent, \\\"Creditor/debtor is not a VC to be released\\\");\\n        for(uint index = 0; index < tokenAddresses.length; index++) {\\n            require(allowableTokens[tokenAddresses[index]], \\\"Invalid token used\\\");\\n        }        \\n    }\\n\\n    function removeCustodianAllowable(address custodianAddress) external {\\n        onlyOwner(msg.sender);\\n        custodianAddresses[custodianAddress] = false;\\n    }    \\n\\n    function setTokenAllowable(address tokenAddress) external {\\n        onlyOwner(msg.sender);\\n        allowableTokens[tokenAddress] = true;\\n    }\\n\\n    function removeTokenAllowable(address tokenAddress) external {\\n        onlyOwner(msg.sender);\\n        allowableTokens[tokenAddress] = false;\\n    }\\n\\n    function getTokenAllowable(address tokenAddress) public view returns (bool) {\\n        return allowableTokens[tokenAddress];\\n    }\\n\\n    function changeOwnership(address ownerAddress) external {\\n        onlyOwner(msg.sender);\\n        checkZeroAddress(ownerAddress);\\n        owner = ownerAddress;\\n    }\\n\\n    function addSettlementContractAddress(address settlementAddress) public {\\n        onlyOwner(msg.sender);\\n        require (definedContract == false, \\\"Cannot redefine linked settlement contract\\\");\\n        checkZeroAddress(settlementAddress);\\n        settlementContract = settlementAddress;\\n        definedContract = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_requiredSignatures\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_accessControlAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timelockInDays\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"Approved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"operation\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"NewTransaction\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CustodianTransactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TokenTransactions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transactionId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_operationType\",\"type\":\"uint8\"}],\"name\":\"approveTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transactionId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_operationType\",\"type\":\"uint8\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transactionId\",\"type\":\"uint256\"}],\"name\":\"getCustodianData\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_custodians\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_category\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256\",\"name\":\"_unlockBlock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_add\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTimeLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requiredSignatures\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newCustodianAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_custodianCategories\",\"type\":\"uint8[]\"}],\"name\":\"submitCustodiansAllowable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newCustodianAddresses\",\"type\":\"address[]\"}],\"name\":\"submitCustodiansRemoved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenAddress\",\"type\":\"address\"}],\"name\":\"submitTokenAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenAddress\",\"type\":\"address\"}],\"name\":\"submitTokenRemoved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Multisig", "CompilerVersion": "v0.8.23+commit.f704f362", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000020000000000000000000000002ea29c47ba9ce3f3695abd9091bbecc2265c1b09000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000020000000000000000000000005c75ecbd8065f325a49386910df190aa6d5a377f000000000000000000000000f05008de8c85caa7cb8f561d5cb3d6b03908e0e4", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}