{"SourceCode": "pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract UserManager {\r\n\r\n    struct User {\r\n        string username;\r\n        bytes32 hashToProfilePicture;\r\n        bool exists;\r\n    }\r\n\r\n    uint public numberOfUsers;\r\n\r\n    mapping(string => bool) internal usernameExists;\r\n    mapping(address => User) public addressToUser;\r\n\r\n    mapping(bytes32 => bool) public profilePictureExists;\r\n    mapping(string => address) internal usernameToAddress;\r\n\r\n    event NewUser(address indexed user, string username, bytes32 profilePicture);\r\n\r\n    function register(string _username, bytes32 _hashToProfilePicture) public {\r\n        require(usernameExists[_username] == false || \r\n                keccak256(abi.encodePacked(getUsername(msg.sender))) == keccak256(abi.encodePacked(_username))\r\n        );\r\n\r\n        if (usernameExists[getUsername(msg.sender)]) {\r\n            // if he already had username, that username is free now\r\n            usernameExists[getUsername(msg.sender)] = false;\r\n        } else {\r\n            numberOfUsers++;\r\n            emit NewUser(msg.sender, _username, _hashToProfilePicture);\r\n        }\r\n\r\n        addressToUser[msg.sender] = User({\r\n            username: _username,\r\n            hashToProfilePicture: _hashToProfilePicture,\r\n            exists: true\r\n        });\r\n\r\n        usernameExists[_username] = true;\r\n        profilePictureExists[_hashToProfilePicture] = true;\r\n        usernameToAddress[_username] = msg.sender;\r\n    }\r\n\r\n    function changeProfilePicture(bytes32 _hashToProfilePicture) public {\r\n        require(addressToUser[msg.sender].exists, \"User doesn't exists\");\r\n\r\n        addressToUser[msg.sender].hashToProfilePicture = _hashToProfilePicture;\r\n    }\r\n\r\n    function getUserInfo(address _address) public view returns(string, bytes32) {\r\n        User memory user = addressToUser[_address];\r\n        return (user.username, user.hashToProfilePicture);\r\n    }\r\n\r\n    function getUsername(address _address) public view returns(string) {\r\n        return addressToUser[_address].username;\r\n    } \r\n\r\n    function getProfilePicture(address _address) public view returns(bytes32) {\r\n        return addressToUser[_address].hashToProfilePicture;\r\n    }\r\n\r\n    function isUsernameExists(string _username) public view returns(bool) {\r\n        return usernameExists[_username];\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract AssetManager is Ownable {\r\n\r\n    struct Asset {\r\n        uint id;\r\n        uint packId;\r\n        /// atributes field is going to be 3 digit uint where every digit can be \"1\" or \"2\"\r\n        /// 1st digit will tell us if asset is background 1 - true / 2 - false\r\n        /// 2nd digit will tell us if rotation is enabled 1 - true / 2 - false\r\n        /// 3rd digit will tell us if scaling  is enabled 1 - true / 2 - false\r\n        uint attributes;\r\n        bytes32 ipfsHash; // image\r\n    }\r\n\r\n    struct AssetPack {\r\n        bytes32 packCover;\r\n        uint[] assetIds;\r\n        address creator;\r\n        uint price;\r\n        string ipfsHash; // containing title and description\r\n    }\r\n\r\n    uint public numberOfAssets;\r\n    uint public numberOfAssetPacks;\r\n\r\n    Asset[] public assets;\r\n    AssetPack[] public assetPacks;\r\n\r\n    UserManager public userManager;\r\n\r\n    mapping(address => uint) public artistBalance;\r\n    mapping(bytes32 => bool) public hashExists;\r\n\r\n    mapping(address => uint[]) public createdAssetPacks;\r\n    mapping(address => uint[]) public boughtAssetPacks;\r\n    mapping(address => mapping(uint => bool)) public hasPermission;\r\n    mapping(uint => address) public approvedTakeover;\r\n\r\n    event AssetPackCreated(uint indexed id, address indexed owner);\r\n    event AssetPackBought(uint indexed id, address indexed buyer);\r\n\r\n    function addUserManager(address _userManager) public onlyOwner {\r\n        require(userManager == address(0));\r\n\r\n        userManager = UserManager(_userManager);\r\n    }\r\n\r\n    /// @notice Function to create assetpack\r\n    /// @param _packCover is cover image for asset pack\r\n    /// @param _attributes is array of attributes\r\n    /// @param _ipfsHashes is array containing all ipfsHashes for assets we'd like to put in pack\r\n    /// @param _packPrice is price for total assetPack (every asset will have average price)\r\n    /// @param _ipfsHash ipfs hash containing title and description in json format\r\n    function createAssetPack(\r\n        bytes32 _packCover, \r\n        uint[] _attributes, \r\n        bytes32[] _ipfsHashes, \r\n        uint _packPrice,\r\n        string _ipfsHash) public {\r\n        \r\n        require(_ipfsHashes.length > 0);\r\n        require(_ipfsHashes.length < 50);\r\n        require(_attributes.length == _ipfsHashes.length);\r\n\r\n        uint[] memory ids = new uint[](_ipfsHashes.length);\r\n\r\n        for (uint i = 0; i < _ipfsHashes.length; i++) {\r\n            ids[i] = createAsset(_attributes[i], _ipfsHashes[i], numberOfAssetPacks);\r\n        }\r\n\r\n        assetPacks.push(AssetPack({\r\n            packCover: _packCover,\r\n            assetIds: ids,\r\n            creator: msg.sender,\r\n            price: _packPrice,\r\n            ipfsHash: _ipfsHash\r\n        }));\r\n\r\n        createdAssetPacks[msg.sender].push(numberOfAssetPacks);\r\n        numberOfAssetPacks++;\r\n\r\n        emit AssetPackCreated(numberOfAssetPacks-1, msg.sender);\r\n    }\r\n\r\n    /// @notice Function which creates an asset\r\n    /// @param _attributes is meta info for asset\r\n    /// @param _ipfsHash is ipfsHash to image of asset\r\n    function createAsset(uint _attributes, bytes32 _ipfsHash, uint _packId) internal returns(uint) {\r\n        uint id = numberOfAssets;\r\n\r\n        require(isAttributesValid(_attributes), \"Attributes are not valid.\");\r\n\r\n        assets.push(Asset({\r\n            id : id,\r\n            packId: _packId,\r\n            attributes: _attributes,\r\n            ipfsHash : _ipfsHash\r\n        }));\r\n\r\n        numberOfAssets++;\r\n\r\n        return id;\r\n    }\r\n\r\n    /// @notice Method to buy right to use specific asset pack\r\n    /// @param _to is address of user who will get right on that asset pack\r\n    /// @param _assetPackId is id of asset pack user is buying\r\n    function buyAssetPack(address _to, uint _assetPackId) public payable {\r\n        require(!checkHasPermissionForPack(_to, _assetPackId));\r\n\r\n        AssetPack memory assetPack = assetPacks[_assetPackId];\r\n        require(msg.value >= assetPack.price);\r\n        // if someone wants to pay more money for asset pack, we will give all of it to creator\r\n        artistBalance[assetPack.creator] += msg.value * 95 / 100;\r\n        artistBalance[owner] += msg.value * 5 / 100;\r\n        boughtAssetPacks[_to].push(_assetPackId);\r\n        hasPermission[_to][_assetPackId] = true;\r\n\r\n        emit AssetPackBought(_assetPackId, _to);\r\n    }\r\n\r\n    /// @notice Change price of asset pack\r\n    /// @param _assetPackId is id of asset pack for changing price\r\n    /// @param _newPrice is new price for that asset pack\r\n    function changeAssetPackPrice(uint _assetPackId, uint _newPrice) public {\r\n        require(assetPacks[_assetPackId].creator == msg.sender);\r\n\r\n        assetPacks[_assetPackId].price = _newPrice;\r\n    }\r\n\r\n    /// @notice Approve address to become creator of that pack\r\n    /// @param _assetPackId id of asset pack for other address to claim\r\n    /// @param _newCreator address that will be able to claim that asset pack\r\n    function approveTakeover(uint _assetPackId, address _newCreator) public {\r\n        require(assetPacks[_assetPackId].creator == msg.sender);\r\n\r\n        approvedTakeover[_assetPackId] = _newCreator;\r\n    }\r\n\r\n    /// @notice claim asset pack that is previously approved by creator\r\n    /// @param _assetPackId id of asset pack that is changing creator\r\n    function claimAssetPack(uint _assetPackId) public {\r\n        require(approvedTakeover[_assetPackId] == msg.sender);\r\n        \r\n        approvedTakeover[_assetPackId] = address(0);\r\n        assetPacks[_assetPackId].creator = msg.sender;\r\n    }\r\n\r\n    ///@notice Function where all artists can withdraw their funds\r\n    function withdraw() public {\r\n        uint amount = artistBalance[msg.sender];\r\n        artistBalance[msg.sender] = 0;\r\n\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    /// @notice Function to fetch total number of assets\r\n    /// @return numberOfAssets\r\n    function getNumberOfAssets() public view returns (uint) {\r\n        return numberOfAssets;\r\n    }\r\n\r\n    /// @notice Function to fetch total number of assetpacks\r\n    /// @return uint numberOfAssetPacks\r\n    function getNumberOfAssetPacks() public view returns(uint) {\r\n        return numberOfAssetPacks;\r\n    }\r\n\r\n    /// @notice Function to check if user have permission (owner / bought) for pack\r\n    /// @param _address is address of user\r\n    /// @param _packId is id of pack\r\n    function checkHasPermissionForPack(address _address, uint _packId) public view returns (bool) {\r\n\r\n        return (assetPacks[_packId].creator == _address) || hasPermission[_address][_packId];\r\n    }\r\n\r\n    /// @notice Function to check does hash exist in mapping\r\n    /// @param _ipfsHash is bytes32 representation of hash\r\n    function checkHashExists(bytes32 _ipfsHash) public view returns (bool) {\r\n        return hashExists[_ipfsHash];\r\n    }\r\n\r\n    /// @notice method that gets all unique packs from array of assets\r\n    function pickUniquePacks(uint[] assetIds) public view returns (uint[]) {\r\n        require(assetIds.length > 0);\r\n\r\n        uint[] memory packs = new uint[](assetIds.length);\r\n        uint packsCount = 0;\r\n        \r\n        for (uint i = 0; i < assetIds.length; i++) {\r\n            Asset memory asset = assets[assetIds[i]];\r\n            bool exists = false;\r\n\r\n            for (uint j = 0; j < packsCount; j++) {\r\n                if (asset.packId == packs[j]) {\r\n                    exists = true;\r\n                }\r\n            }\r\n\r\n            if (!exists) {\r\n                packs[packsCount] = asset.packId;\r\n                packsCount++;\r\n            }\r\n        }\r\n\r\n        uint[] memory finalPacks = new uint[](packsCount);\r\n        for (i = 0; i < packsCount; i++) {\r\n            finalPacks[i] = packs[i];\r\n        }\r\n\r\n        return finalPacks;\r\n    }\r\n\r\n    /// @notice Method to get all info for an asset\r\n    /// @param id is id of asset\r\n    /// @return All data for an asset\r\n    function getAssetInfo(uint id) public view returns (uint, uint, uint, bytes32) {\r\n        require(id >= 0);\r\n        require(id < numberOfAssets);\r\n        Asset memory asset = assets[id];\r\n\r\n        return (asset.id, asset.packId, asset.attributes, asset.ipfsHash);\r\n    }\r\n\r\n    /// @notice method returns all asset packs created by _address\r\n    /// @param _address is creator address\r\n    function getAssetPacksUserCreated(address _address) public view returns(uint[]) {\r\n        return createdAssetPacks[_address];\r\n    }\r\n\r\n    /// @notice Function to get ipfsHash for selected asset\r\n    /// @param _id is id of asset we'd like to get ipfs hash\r\n    /// @return string representation of ipfs hash of that asset\r\n    function getAssetIpfs(uint _id) public view returns (bytes32) {\r\n        require(_id < numberOfAssets);\r\n        \r\n        return assets[_id].ipfsHash;\r\n    }\r\n\r\n    /// @notice Function to get attributes for selected asset\r\n    /// @param _id is id of asset we'd like to get ipfs hash\r\n    /// @return uint representation of attributes of that asset\r\n    function getAssetAttributes(uint _id) public view returns (uint) {\r\n        require(_id < numberOfAssets);\r\n        \r\n        return assets[_id].attributes;\r\n    }\r\n\r\n    /// @notice Function to get array of ipfsHashes for specific assets\r\n    /// @dev need for data parsing on frontend efficiently\r\n    /// @param _ids is array of ids\r\n    /// @return bytes32 array of hashes\r\n    function getIpfsForAssets(uint[] _ids) public view returns (bytes32[]) {\r\n        bytes32[] memory hashes = new bytes32[](_ids.length);\r\n        for (uint i = 0; i < _ids.length; i++) {\r\n            Asset memory asset = assets[_ids[i]];\r\n            hashes[i] = asset.ipfsHash;\r\n        }\r\n\r\n        return hashes;\r\n    }\r\n\r\n    /// @notice method that returns attributes for many assets\r\n    function getAttributesForAssets(uint[] _ids) public view returns(uint[]) {\r\n        uint[] memory attributes = new uint[](_ids.length);\r\n        \r\n        for (uint i = 0; i < _ids.length; i++) {\r\n            Asset memory asset = assets[_ids[i]];\r\n            attributes[i] = asset.attributes;\r\n        }\r\n        return attributes;\r\n    }\r\n\r\n    /// @notice Function to get ipfs hash and id for all assets in one asset pack\r\n    /// @param _assetPackId is id of asset pack\r\n    /// @return two arrays with data\r\n    function getAssetPackData(uint _assetPackId) public view \r\n    returns(bytes32, address, uint, uint[], uint[], bytes32[], string, string, bytes32) {\r\n        require(_assetPackId < numberOfAssetPacks);\r\n\r\n        AssetPack memory assetPack = assetPacks[_assetPackId];\r\n        bytes32[] memory hashes = new bytes32[](assetPack.assetIds.length);\r\n\r\n        for (uint i = 0; i < assetPack.assetIds.length; i++) {\r\n            hashes[i] = getAssetIpfs(assetPack.assetIds[i]);\r\n        }\r\n\r\n        uint[] memory attributes = getAttributesForAssets(assetPack.assetIds);\r\n\r\n        return(\r\n            assetPack.packCover, \r\n            assetPack.creator, \r\n            assetPack.price, \r\n            assetPack.assetIds, \r\n            attributes, \r\n            hashes,\r\n            assetPack.ipfsHash,\r\n            userManager.getUsername(assetPack.creator),\r\n            userManager.getProfilePicture(assetPack.creator)\r\n        );\r\n    }\r\n\r\n    function getAssetPackPrice(uint _assetPackId) public view returns (uint) {\r\n        require(_assetPackId < numberOfAssetPacks);\r\n\r\n        return assetPacks[_assetPackId].price;\r\n    }\r\n\r\n    function getBoughtAssetPacks(address _address) public view returns (uint[]) {\r\n        return boughtAssetPacks[_address];\r\n    }\r\n\r\n    /// @notice Function to get cover image for every assetpack\r\n    /// @param _packIds is array of asset pack ids\r\n    /// @return bytes32[] array of hashes\r\n    function getCoversForPacks(uint[] _packIds) public view returns (bytes32[]) {\r\n        require(_packIds.length > 0);\r\n        bytes32[] memory covers = new bytes32[](_packIds.length);\r\n        for (uint i = 0; i < _packIds.length; i++) {\r\n            AssetPack memory assetPack = assetPacks[_packIds[i]];\r\n            covers[i] = assetPack.packCover;\r\n        }\r\n        return covers;\r\n    }\r\n\r\n    function isAttributesValid(uint attributes) private pure returns(bool) {\r\n        if (attributes < 100 || attributes > 999) {\r\n            return false;\r\n        }\r\n\r\n        uint num = attributes;\r\n\r\n        while (num > 0) {\r\n            if (num % 10 != 1 && num % 10 != 2) {\r\n                return false;\r\n            } \r\n            num = num / 10;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_assetPackId\",\"type\":\"uint256\"},{\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"changeAssetPackPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAssetPacksUserCreated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_packIds\",\"type\":\"uint256[]\"}],\"name\":\"getCoversForPacks\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"getIpfsForAssets\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetPackId\",\"type\":\"uint256\"}],\"name\":\"getAssetPackData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"bytes32[]\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetPackId\",\"type\":\"uint256\"}],\"name\":\"claimAssetPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"boughtAssetPacks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedTakeover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_assetPackId\",\"type\":\"uint256\"}],\"name\":\"buyAssetPack\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"artistBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfAssetPacks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetPackId\",\"type\":\"uint256\"}],\"name\":\"getAssetPackPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfAssetPacks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hasPermission\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetIds\",\"type\":\"uint256[]\"}],\"name\":\"pickUniquePacks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetPacks\",\"outputs\":[{\"name\":\"packCover\",\"type\":\"bytes32\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"ipfsHash\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getBoughtAssetPacks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetPackId\",\"type\":\"uint256\"},{\"name\":\"_newCreator\",\"type\":\"address\"}],\"name\":\"approveTakeover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"createdAssetPacks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAssetIpfs\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAssetAttributes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_packId\",\"type\":\"uint256\"}],\"name\":\"checkHasPermissionForPack\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assets\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"packId\",\"type\":\"uint256\"},{\"name\":\"attributes\",\"type\":\"uint256\"},{\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_packCover\",\"type\":\"bytes32\"},{\"name\":\"_attributes\",\"type\":\"uint256[]\"},{\"name\":\"_ipfsHashes\",\"type\":\"bytes32[]\"},{\"name\":\"_packPrice\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"string\"}],\"name\":\"createAssetPack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_userManager\",\"type\":\"address\"}],\"name\":\"addUserManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumberOfAssets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfAssets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"getAttributesForAssets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ipfsHash\",\"type\":\"bytes32\"}],\"name\":\"checkHashExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAssetInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AssetPackCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"AssetPackBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "AssetManager", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://20eb13bde8c62e2757259205a9859437c8f7d109b86a11546c70a5e074db9ac3"}