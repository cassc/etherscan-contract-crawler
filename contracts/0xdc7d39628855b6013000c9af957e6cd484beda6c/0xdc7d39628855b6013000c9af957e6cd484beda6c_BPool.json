{"SourceCode": "{\"BColor.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\ncontract BColor {\\n    function getColor()\\n        external view\\n        returns (bytes32);\\n}\\n\\ncontract BBronze is BColor {\\n    function getColor()\\n        external view\\n        returns (bytes32) {\\n            return bytes32(\\\"BRONZE\\\");\\n        }\\n}\\n\"},\"BConst.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BColor.sol\\\";\\n\\ncontract BConst is BBronze {\\n    uint public constant BONE              = 10**18;\\n\\n    uint public constant MIN_BOUND_TOKENS  = 2;\\n    uint public constant MAX_BOUND_TOKENS  = 8;\\n\\n    uint public constant MIN_FEE           = BONE / 10**6;\\n    uint public constant MAX_FEE           = BONE / 10;\\n    uint public constant EXIT_FEE          = 0;\\n\\n    uint public constant MIN_WEIGHT        = BONE;\\n    uint public constant MAX_WEIGHT        = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;\\n    uint public constant MIN_BALANCE       = BONE / 10**12;\\n\\n    uint public constant INIT_POOL_SUPPLY  = BONE * 100;\\n\\n    uint public constant MIN_BPOW_BASE     = 1 wei;\\n    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;\\n    uint public constant BPOW_PRECISION    = BONE / 10**10;\\n\\n    uint public constant MAX_IN_RATIO      = BONE / 2;\\n    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;\\n}\\n\"},\"BMath.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BNum.sol\\\";\\n\\ncontract BMath is BBronze, BConst, BNum {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint spotPrice)\\n    {\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\\n        return  (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n        uint adjustedIn = bsub(BONE, swapFee);\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\\n        uint y = bdiv(tokenBalanceOut, diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        tokenAmountIn = bsub(BONE, swapFee);\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint poolAmountOut)\\n    {\\n        // Charge the trading fee for the proportion of tokenAi\\n        ///  which is implicitly traded to the other pool tokens.\\n        // That proportion is (1- weightTokenIn)\\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\n        return poolAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n      \\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n        uint boo = bdiv(BONE, normalizedWeight); \\n        uint tokenInRatio = bpow(poolRatio, boo);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountIn,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        // charge exit fee on the pool token side\\n        // pAiAfterExitFee = pAi*(1-exitFee)\\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n     \\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n        // charge swap fee on the output token side \\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        public pure\\n        returns (uint poolAmountIn)\\n    {\\n\\n        // charge swap fee on the output token side \\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n        uint zoo = bsub(BONE, normalizedWeight);\\n        uint zar = bmul(zoo, swapFee); \\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n        // charge exit fee on the pool token side\\n        // pAi = pAiAfterExitFee/(1-exitFee)\\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n        return poolAmountIn;\\n    }\\n\\n\\n}\\n\"},\"BNum.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BConst.sol\\\";\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure \\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c \\u003e= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a \\u003e= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 \\u003e= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 \\u003e= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base \\u003e= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base \\u003c= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = bfloor(exp);   \\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom \\n        //         = (product(a - i - 1, i=1--\\u003ek) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term \\u003e= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n}\\n\"},\"BPool.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\n\\ncontract BPool is BBronze, BToken, BMath {\\n\\n    struct Record {\\n        bool bound;   // is token bound to pool\\n        uint index;   // private\\n        uint denorm;  // denormalized weight\\n        uint balance;\\n    }\\n\\n    event LOG_SWAP(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256         tokenAmountIn,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_JOIN(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256         tokenAmountIn\\n    );\\n\\n    event LOG_EXIT(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LOG_CALL(\\n        bytes4  indexed sig,\\n        address indexed caller,\\n        bytes           data\\n    ) anonymous;\\n\\n    modifier _logs_() {\\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n        _;\\n    }\\n\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _;\\n    }\\n\\n    bool private _mutex;\\n\\n    address private _factory;    // BFactory address to push token exitFee to\\n    address private _controller; // has CONTROL role\\n    bool private _publicSwap; // true if PUBLIC can call SWAP functions\\n\\n    // `setSwapFee` and `finalize` require CONTROL\\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\\n    uint private _swapFee;\\n    bool private _finalized;\\n\\n    address[] private _tokens;\\n    mapping(address=\\u003eRecord) private  _records;\\n    uint private _totalWeight;\\n\\n    constructor() public {\\n        _controller = msg.sender;\\n        _factory = msg.sender;\\n        _swapFee = MIN_FEE;\\n        _publicSwap = false;\\n        _finalized = false;\\n    }\\n\\n    function isPublicSwap()\\n        external view\\n        returns (bool)\\n    {\\n        return _publicSwap;\\n    }\\n\\n    function isFinalized()\\n        external view\\n        returns (bool)\\n    {\\n        return _finalized;\\n    }\\n\\n    function isBound(address t)\\n        external view\\n        returns (bool)\\n    {\\n        return _records[t].bound;\\n    }\\n\\n    function getNumTokens()\\n        external view\\n        returns (uint) \\n    {\\n        return _tokens.length;\\n    }\\n\\n    function getCurrentTokens()\\n        external view _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    function getFinalTokens()\\n        external view\\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        return _tokens;\\n    }\\n\\n    function getDenormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].denorm;\\n    }\\n\\n    function getTotalDenormalizedWeight()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _totalWeight;\\n    }\\n\\n    function getNormalizedWeight(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        uint denorm = _records[token].denorm;\\n        return bdiv(denorm, _totalWeight);\\n    }\\n\\n    function getBalance(address token)\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].balance;\\n    }\\n\\n    function getSwapFee()\\n        external view\\n        _viewlock_\\n        returns (uint)\\n    {\\n        return _swapFee;\\n    }\\n\\n    function getController()\\n        external view\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _controller;\\n    }\\n\\n    function setSwapFee(uint swapFee)\\n        external\\n        _logs_\\n        _lock_\\n    { \\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(swapFee \\u003e= MIN_FEE, \\\"ERR_MIN_FEE\\\");\\n        require(swapFee \\u003c= MAX_FEE, \\\"ERR_MAX_FEE\\\");\\n        _swapFee = swapFee;\\n    }\\n\\n    function setController(address manager)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _controller = manager;\\n    }\\n\\n    function setPublicSwap(bool public_)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _publicSwap = public_;\\n    }\\n\\n    function finalize()\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n        require(_tokens.length \\u003e= MIN_BOUND_TOKENS, \\\"ERR_MIN_TOKENS\\\");\\n\\n        _finalized = true;\\n        _publicSwap = true;\\n\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);\\n    }\\n\\n\\n    function bind(address token, uint balance, uint denorm)\\n        external\\n        _logs_\\n        // _lock_  Bind does not lock because it jumps to `rebind`, which does\\n    {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(_tokens.length \\u003c MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            index: _tokens.length,\\n            denorm: 0,    // balance and denorm will be validated\\n            balance: 0   // and set by `rebind`\\n        });\\n        _tokens.push(token);\\n        rebind(token, balance, denorm);\\n    }\\n\\n    function rebind(address token, uint balance, uint denorm)\\n        public\\n        _logs_\\n        _lock_\\n    {\\n\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        require(denorm \\u003e= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n        require(denorm \\u003c= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n        require(balance \\u003e= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n        // Adjust the denorm and totalWeight\\n        uint oldWeight = _records[token].denorm;\\n        if (denorm \\u003e oldWeight) {\\n            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));\\n            require(_totalWeight \\u003c= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        } else if (denorm \\u003c oldWeight) {\\n            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));\\n        }        \\n        _records[token].denorm = denorm;\\n\\n        // Adjust the balance record and actual token balance\\n        uint oldBalance = _records[token].balance;\\n        _records[token].balance = balance;\\n        if (balance \\u003e oldBalance) {\\n            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\\n        } else if (balance \\u003c oldBalance) {\\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\\n            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\\n            uint tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\\n            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\\n            _pushUnderlying(token, _factory, tokenExitFee);\\n        }\\n    }\\n\\n    function unbind(address token)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(!_finalized, \\\"ERR_IS_FINALIZED\\\");\\n\\n        uint tokenBalance = _records[token].balance;\\n        uint tokenExitFee = bmul(tokenBalance, EXIT_FEE);\\n\\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint index = _records[token].index;\\n        uint last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = index;\\n        _tokens.pop();\\n        _records[token] = Record({\\n            bound: false,\\n            index: 0,\\n            denorm: 0,\\n            balance: 0\\n        });\\n\\n        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));\\n        _pushUnderlying(token, _factory, tokenExitFee);\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        _records[token].balance = IERC20(token).balanceOf(address(this));\\n    }\\n\\n    function getSpotPrice(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\\n    }\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\\n        external view\\n        _viewlock_\\n        returns (uint spotPrice)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\\n    }\\n\\n    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint poolTotal = totalSupply();\\n        uint ratio = bdiv(poolAmountOut, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountIn = bmul(ratio, bal);\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountIn \\u003c= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n            _records[t].balance = badd(_records[t].balance, tokenAmountIn);\\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n    }\\n\\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\\n        external\\n        _logs_\\n        _lock_\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n\\n        uint poolTotal = totalSupply();\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n        uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n        uint ratio = bdiv(pAiAfterExitFee, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _pushPoolShare(_factory, exitFee);\\n        _burnPoolShare(pAiAfterExitFee);\\n\\n        for (uint i = 0; i \\u003c _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint bal = _records[t].balance;\\n            uint tokenAmountOut = bmul(ratio, bal);\\n            require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountOut \\u003e= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);\\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\\n        }\\n\\n    }\\n\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint tokenAmountIn,\\n        address tokenOut,\\n        uint minAmountOut,\\n        uint maxPrice\\n    )\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut, uint spotPriceAfter)\\n    {\\n\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountIn \\u003c= bmul(inRecord.balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore \\u003c= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountOut = calcOutGivenIn(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountIn,\\n                            _swapFee\\n                        );\\n        require(tokenAmountOut \\u003e= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter \\u003e= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");     \\n        require(spotPriceAfter \\u003c= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore \\u003c= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountOut, spotPriceAfter);\\n    }\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint maxAmountIn,\\n        address tokenOut,\\n        uint tokenAmountOut,\\n        uint maxPrice\\n    )\\n        external\\n        _logs_\\n        _lock_ \\n        returns (uint tokenAmountIn, uint spotPriceAfter)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(_publicSwap, \\\"ERR_SWAP_NOT_PUBLIC\\\");\\n\\n        Record storage inRecord = _records[address(tokenIn)];\\n        Record storage outRecord = _records[address(tokenOut)];\\n\\n        require(tokenAmountOut \\u003c= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        uint spotPriceBefore = calcSpotPrice(\\n                                    inRecord.balance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore \\u003c= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountIn = calcInGivenOut(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n        require(tokenAmountIn \\u003c= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                inRecord.balance,\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter \\u003e= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter \\u003c= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore \\u003c= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n\\n    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountOut)\\n\\n    {        \\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountIn \\u003c= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        poolAmountOut = calcPoolOutGivenSingleIn(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            tokenAmountIn,\\n                            _swapFee\\n                        );\\n\\n        require(poolAmountOut \\u003e= minPoolAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        return poolAmountOut;\\n    }\\n\\n    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountIn)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n\\n        tokenAmountIn = calcSingleInGivenPoolOut(\\n                            inRecord.balance,\\n                            inRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            poolAmountOut,\\n                            _swapFee\\n                        );\\n\\n        require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(tokenAmountIn \\u003c= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n        \\n        require(tokenAmountIn \\u003c= bmul(_records[tokenIn].balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        inRecord.balance = badd(inRecord.balance, tokenAmountIn);\\n\\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\\n\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n\\n        return tokenAmountIn;\\n    }\\n\\n    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint tokenAmountOut)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        tokenAmountOut = calcSingleOutGivenPoolIn(\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            poolAmountIn,\\n                            _swapFee\\n                        );\\n\\n        require(tokenAmountOut \\u003e= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n        \\n        require(tokenAmountOut \\u003c= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        return tokenAmountOut;\\n    }\\n\\n    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)\\n        external\\n        _logs_\\n        _lock_\\n        returns (uint poolAmountIn)\\n    {\\n        require(_finalized, \\\"ERR_NOT_FINALIZED\\\");\\n        require(_records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(tokenAmountOut \\u003c= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        Record storage outRecord = _records[tokenOut];\\n\\n        poolAmountIn = calcPoolInGivenSingleOut(\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            _totalSupply,\\n                            _totalWeight,\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n\\n        require(poolAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(poolAmountIn \\u003c= maxPoolAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);\\n\\n        uint exitFee = bmul(poolAmountIn, EXIT_FEE);\\n\\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _burnPoolShare(bsub(poolAmountIn, exitFee));\\n        _pushPoolShare(_factory, exitFee);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);        \\n\\n        return poolAmountIn;\\n    }\\n\\n\\n    // ==\\n    // \\u0027Underlying\\u0027 token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n\\n    function _pullUnderlying(address erc20, address from, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pushUnderlying(address erc20, address to, uint amount)\\n        internal\\n    {\\n        bool xfer = IERC20(erc20).transfer(to, amount);\\n        require(xfer, \\\"ERR_ERC20_FALSE\\\");\\n    }\\n\\n    function _pullPoolShare(address from, uint amount)\\n        internal\\n    {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint amount)\\n        internal\\n    {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint amount)\\n        internal\\n    {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint amount)\\n        internal\\n    {\\n        _burn(amount);\\n    }\\n\\n}\\n\"},\"BToken.sol\":{\"content\":\"// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see \\u003chttp://www.gnu.org/licenses/\\u003e.\\n\\npragma solidity 0.5.12;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n// Highly opinionated token implementation\\n\\ninterface IERC20 {\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address whom) external view returns (uint);\\n    function allowance(address src, address dst) external view returns (uint);\\n\\n    function approve(address dst, uint amt) external returns (bool);\\n    function transfer(address dst, uint amt) external returns (bool);\\n    function transferFrom(\\n        address src, address dst, uint amt\\n    ) external returns (bool);\\n}\\n\\ncontract BTokenBase is BNum {\\n\\n    mapping(address =\\u003e uint)                   internal _balance;\\n    mapping(address =\\u003e mapping(address=\\u003euint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] \\u003e= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] \\u003e= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract BToken is BTokenBase, IERC20 {\\n\\n    string  private _name     = \\\"Balancer Pool Token\\\";\\n    string  private _symbol   = \\\"BPT\\\";\\n    uint8   private _decimals = 18;\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view returns(uint8) {\\n        return _decimals;\\n    }\\n\\n    function allowance(address src, address dst) external view returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external view returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt \\u003e oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external returns (bool) {\\n        require(msg.sender == src || amt \\u003c= _allowance[src][msg.sender], \\\"ERR_BTOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src \\u0026\\u0026 _allowance[src][msg.sender] != uint256(-1)) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BPOW_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INIT_POOL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_IN_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OUT_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TOTAL_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BOUND_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BPOW_BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"bind\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcInGivenOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcOutGivenIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolInGivenSingleOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcPoolOutGivenSingleIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleInGivenPoolOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSingleOutGivenPoolIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalanceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalanceOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWeightOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"calcSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPoolAmountIn\",\"type\":\"uint256\"}],\"name\":\"exitswapExternAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getColor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFinalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPriceSansFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPublicSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"}],\"name\":\"joinswapPoolAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denorm\",\"type\":\"uint256\"}],\"name\":\"rebind\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"public_\",\"type\":\"bool\"}],\"name\":\"setPublicSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unbind\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BPool", "CompilerVersion": "v0.5.12+commit.7709ece9", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://08be3d1ae8df326becfb0d7fa15f3da56c3488a4813f666aa4154f7433e2a31e"}