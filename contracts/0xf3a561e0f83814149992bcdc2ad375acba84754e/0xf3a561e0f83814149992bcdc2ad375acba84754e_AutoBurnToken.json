{"SourceCode": "/*\r\nABN = AutoBurn token\r\nDeflationary. Low gas. Made simple.\r\n\r\nThis token has decreasing supply and increasing price achieved by 3% burn and 3% added \r\nto liquidity on each transaction except wallet to wallet transactions (non-contract).\r\nThis is done by direct balance adjustments which are much cheaper than calling external \r\nmethods for sell, add liquidity and mint LP tokens functions on each trade. The pool \r\nis verified to stay in sync despite no additional LP tokens are minted or burned, \r\nproportionally rewarding any additional liquidity providers.\r\n\r\nPrice is driven up every day by burning 3% of ABN from liquidity pool while keeping WETH there\r\nintact. Wallet and other pool balances are not daily burn, only WETH-ABN pool is affected.\r\n\r\nNet size of a single transaction is limited to 1% of available supply, no limit on balances\r\nand no limit for wallet to wallet transactions (non-contract).\r\n\r\nIf you get \"error:undefined\" on swap or \"confirm\" button is dead:\r\nCheck slippage, increase to 7%.\r\nSet exact amount for ABN, not for the counterparty.\r\nCheck token available supply, 1% bought at once may be later sold in 2 or more transactions if\r\nsome supply was burn in meantime.\r\n\r\nTip to remove liquidity: Save one transaction fee by removing liquidity to WETH instead of ETH.\r\n\r\nDisclaimer: This is an experimental project. DYOR and read contract code thoroughly before trading.\r\nCheck liquidity distribution and lock duration.\r\nDeployer has no liability, direct or indirectly implied, of any loss or damage caused by bugs in\r\ncode or EVM, Solidity vulnerabilities, bot activity or malicious behavior of token holders.\r\n\r\n*/\r\n\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\n// License: Parts different from open-zeppelin implementations are copyrighted. Any clones should send a 0.3% of tx value to deployer of this contract provided the tx is not considered feeless here.\r\npragma solidity =0.7.6;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function burn(uint256 amount) external returns (bool);\r\n    function burnFrom(address account, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface UNIV2Sync {\r\n    function sync() external;\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function balanceOf(address _owner) external returns (uint256);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function withdraw(uint256 _amount) external;\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/*\r\n * An {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract DeflationaryERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    address private _deployer;\r\n    uint256 public lastPoolBurnTime;\r\n    uint256 public epoch;\r\n\r\n    // Transaction Fees:\r\n    uint8 public txFee = 6; // total in %, half will burn and half adds to liquidity\r\n    address public feeDistributor; // fees are sent to fee distributor = uniswap pool\r\n    address public wethContract; // wrap ethers sent to contract to increase liquidity\r\n\r\n    constructor (string memory __name, string memory __symbol)  {\r\n        _name = __name;\r\n        _symbol = __symbol;\r\n        _decimals = 6;\r\n        _deployer = tx.origin;\r\n        epoch = 86400;\r\n        wethContract=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n        lastPoolBurnTime = block.timestamp.div(epoch).mul(epoch); //set time part to midnight UTC\r\n    }\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        _transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n    function countdownPoolBurnDue() public view returns (uint256) {\r\n          return ((lastPoolBurnTime.add(epoch))>block.timestamp?(lastPoolBurnTime.add(epoch).sub(block.timestamp)):0);\r\n    }\r\n\r\n    //Important: Due to checks made during swap process avoid calling this method inside a swap transaction.\r\n    function PoolBurnAndSync() public virtual returns (bool) {\r\n        // Burns any token balance donated to the contract (always)\r\n        if (_balances[address(this)] > 0) {\r\n            _burn(address(this),_balances[address(this)]);\r\n        }\r\n        //Convert any ETH to WETH (always).\r\n        uint256 amountETH = address(this).balance;\r\n        if (amountETH > 0) {\r\n            IWETH(wethContract).deposit{value : amountETH}();\r\n        }\r\n        //Checks pool address and time since last pool burn\r\n        if (countdownPoolBurnDue() == 0 && feeDistributor != address(0)) {\r\n            lastPoolBurnTime = lastPoolBurnTime.add(epoch);\r\n            //Burns 3% from pool address\r\n            if (_balances[feeDistributor] > 100) {\r\n                _burn(feeDistributor,_balances[feeDistributor].mul(3).div(100));\r\n            }\r\n        }\r\n        //Calls sync anytime it's not a swap. Swaps sync at the end automatically.\r\n        if(feeDistributor != address(0)) {\r\n            //Gets weth balance\r\n            uint256 amountWETH =  IWETH(wethContract).balanceOf(address(this));\r\n            //Sends weth to pool\r\n            if (amountWETH > 0) {\r\n                IWETH(wethContract).transfer(feeDistributor, amountWETH);\r\n            }\r\n            UNIV2Sync(feeDistributor).sync(); //important to reflect updated price\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // assign a new pool address, enforce deflationary features and renounce ownership\r\n    function setFeeDistributor(address _distributor) public {\r\n        require(tx.origin == _deployer, \"Not from deployer\");\r\n        require(feeDistributor == address(0), \"Pool: Address immutable once set\");\r\n        feeDistributor = _distributor;\r\n    }\r\n\r\n    // to caclulate the amounts for recipient and distributer after fees have been applied\r\n    function calculateAmountsAfterFee(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public view returns (uint256 transferToAmount, uint256 transferToFeeDistributorAmount, uint256 burnAmount) {\r\n        // check if fees should apply to this transaction\r\n        if (sender.isContract() || recipient.isContract()) {\r\n            // calculate fees and amounts if any address is an active contract\r\n            uint256 fee = amount.mul(txFee).div(100);\r\n            uint256 burnFee = fee.div(2);\r\n            return (amount.sub(fee), fee.sub(burnFee),burnFee);\r\n        }\r\n        return (amount, 0, 0);\r\n    }\r\n\r\n    function burnFrom(address account,uint256 amount) public virtual override returns (bool) {\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\r\n        _burn(account, amount);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 amount) public virtual override returns (bool) {\r\n        _burn(_msgSender(), amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount >= 100, \"amount below 100 base units, avoiding underflows\");\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        // calculate fee:\r\n        (uint256 transferToAmount, uint256 transferToFeeDistributorAmount,uint256 burnAmount) = calculateAmountsAfterFee(sender, recipient, amount);\r\n        // subtract net amount, keep amount for fees to be subtracted later\r\n        _balances[sender] = _balances[sender].sub(transferToAmount, \"ERC20: transfer amount exceeds balance\");\r\n        // update recipients balance:\r\n        _balances[recipient] = _balances[recipient].add(transferToAmount);\r\n        emit Transfer(sender, recipient, transferToAmount);\r\n        // update pool balance, limit max tx once pool contract is known and funded\r\n        if(transferToFeeDistributorAmount > 0 && feeDistributor != address(0)){\r\n            require(_totalSupply.div(transferToAmount) >= 99, \"max single trade 1% of current total supply\");\r\n            _burn(sender,burnAmount);\r\n            _balances[sender] = _balances[sender].sub(transferToFeeDistributorAmount, \"ERC20: fee transfer amount exceeds remaining balance\");\r\n            _balances[feeDistributor] = _balances[feeDistributor].add(transferToFeeDistributorAmount);\r\n            emit Transfer(sender, feeDistributor, transferToFeeDistributorAmount);\r\n            //Sync is made automatically at the end of swap transaction,  doing it earlier reverts the swap\r\n        } else {\r\n            //Since there may be relayers like 1inch allow sync on feeless txs only\r\n            PoolBurnAndSync();\r\n        }\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(_totalSupply == 0, \"Mint: Not an initial supply mint\");\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n        if(amount != 0) {\r\n            _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n            _totalSupply = _totalSupply.sub(amount);\r\n            emit Transfer(account, address(0), amount);\r\n        }\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * Hook that is called before any transfer of tokens. This includes minting and burning.\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n    //Before sennding ether to this contract ensure gas cost is estimated properly\r\n    receive() external payable {\r\n       PoolBurnAndSync();\r\n    }\r\n}\r\n\r\n/**\r\n * ABN is a token designed to implement pool inflation and supply deflation using simplified way of transferring or burning \r\n * fees manually and then forcing Uniswap pool to resync balances instead of costly sell, add liquidity and mint LP tokens.\r\n * The ABN Token itself is just a standard ERC20, with:\r\n * No minting.\r\n * Public burning.\r\n * Transfer fee applied. Fixed to 3% into pool + 3% burn.\r\n */\r\ncontract AutoBurnToken is DeflationaryERC20 {\r\n    constructor()  DeflationaryERC20(\"AutoBurn\", \"ABN\") {\r\n        // maximum supply   = 100000 whole units with decimals = 6\r\n        _mint(msg.sender, 100000e6);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PoolBurnAndSync\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateAmountsAfterFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transferToAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferToFeeDistributorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countdownPoolBurnDue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPoolBurnTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_distributor\",\"type\":\"address\"}],\"name\":\"setFeeDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txFee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AutoBurnToken", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cb6bfc5a9da24d07fbfb547d02eec0ca32b7e46a454db41f5aaca6fdbe801d85"}