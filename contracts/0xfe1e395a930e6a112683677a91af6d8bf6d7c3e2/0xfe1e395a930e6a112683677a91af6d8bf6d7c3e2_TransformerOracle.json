{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@mean-finance/oracles/solidity/contracts/TransformerOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@openzeppelin/contracts/access/AccessControl.sol';\\nimport './libraries/TokenSorting.sol';\\nimport './base/BaseOracle.sol';\\nimport '../interfaces/ITransformerOracle.sol';\\n\\n/**\\n * @notice This implementation of `ITransformerOracle` assumes that all tokens being transformed only have one underlying token.\\n *         This is true when this implementation was written, but it may not be true in the future. If that happens, then another\\n *         implementation will be needed\\n */\\ncontract TransformerOracle is BaseOracle, AccessControl, ITransformerOracle {\\n  bytes32 public constant SUPER_ADMIN_ROLE = keccak256('SUPER_ADMIN_ROLE');\\n  bytes32 public constant ADMIN_ROLE = keccak256('ADMIN_ROLE');\\n\\n  /// @inheritdoc ITransformerOracle\\n  ITransformerRegistry public immutable REGISTRY;\\n\\n  /// @inheritdoc ITransformerOracle\\n  ITokenPriceOracle public immutable UNDERLYING_ORACLE;\\n\\n  /// @inheritdoc ITransformerOracle\\n  mapping(address => bool) public willAvoidMappingToUnderlying;\\n  mapping(bytes32 => PairSpecificMappingConfig) internal _pairSpecificMappingConfig;\\n\\n  constructor(\\n    ITransformerRegistry _registry,\\n    ITokenPriceOracle _underlyingOracle,\\n    address _superAdmin,\\n    address[] memory _initialAdmins\\n  ) {\\n    if (address(_registry) == address(0) || address(_underlyingOracle) == address(0) || _superAdmin == address(0)) revert ZeroAddress();\\n    REGISTRY = _registry;\\n    UNDERLYING_ORACLE = _underlyingOracle;\\n    // We are setting the super admin role as its own admin so we can transfer it\\n    _setRoleAdmin(SUPER_ADMIN_ROLE, SUPER_ADMIN_ROLE);\\n    _setRoleAdmin(ADMIN_ROLE, SUPER_ADMIN_ROLE);\\n    _setupRole(SUPER_ADMIN_ROLE, _superAdmin);\\n    for (uint256 i; i < _initialAdmins.length; i++) {\\n      _setupRole(ADMIN_ROLE, _initialAdmins[i]);\\n    }\\n  }\\n\\n  /// @inheritdoc ITransformerOracle\\n  function getMappingForPair(address _tokenA, address _tokenB) public view virtual returns (address _mappedTokenA, address _mappedTokenB) {\\n    (ITransformer _transformerTokenA, ITransformer _transformerTokenB) = _getTransformers(_tokenA, _tokenB, true, true);\\n    _mappedTokenA = _mapToUnderlyingIfExists(_tokenA, _transformerTokenA);\\n    _mappedTokenB = _mapToUnderlyingIfExists(_tokenB, _transformerTokenB);\\n  }\\n\\n  /// @inheritdoc ITransformerOracle\\n  function getRecursiveMappingForPair(address _tokenA, address _tokenB)\\n    public\\n    view\\n    virtual\\n    returns (address _mappedTokenA, address _mappedTokenB)\\n  {\\n    return _getRecursiveMappingForPair(_tokenA, _tokenB, true, true);\\n  }\\n\\n  /// @inheritdoc ITransformerOracle\\n  function pairSpecificMappingConfig(address _tokenA, address _tokenB) public view virtual returns (PairSpecificMappingConfig memory) {\\n    return _pairSpecificMappingConfig[_keyForPair(_tokenA, _tokenB)];\\n  }\\n\\n  /// @inheritdoc ITransformerOracle\\n  function shouldMapToUnderlying(address[] calldata _dependents) external onlyRole(ADMIN_ROLE) {\\n    for (uint256 i; i < _dependents.length; i++) {\\n      willAvoidMappingToUnderlying[_dependents[i]] = false;\\n    }\\n    emit DependentsWillMapToUnderlying(_dependents);\\n  }\\n\\n  /// @inheritdoc ITransformerOracle\\n  function avoidMappingToUnderlying(address[] calldata _dependents) external onlyRole(ADMIN_ROLE) {\\n    for (uint256 i; i < _dependents.length; i++) {\\n      willAvoidMappingToUnderlying[_dependents[i]] = true;\\n    }\\n    emit DependentsWillAvoidMappingToUnderlying(_dependents);\\n  }\\n\\n  /// @inheritdoc ITransformerOracle\\n  function setPairSpecificMappingConfig(PairSpecificMappingConfigToSet[] calldata _config) external onlyRole(ADMIN_ROLE) {\\n    for (uint256 i = 0; i < _config.length; ) {\\n      PairSpecificMappingConfigToSet memory _pairConfigToSet = _config[i];\\n      // We make sure that the tokens are sorted correctly, or we reverse the config so that it ends up sorted\\n      (bytes32 _key, bool _mapTokenAToUnderlying, bool _mapTokenBToUnderlying) = _pairConfigToSet.tokenA < _pairConfigToSet.tokenB\\n        ? (\\n          _keyForSortedPair(_pairConfigToSet.tokenA, _pairConfigToSet.tokenB),\\n          _pairConfigToSet.mapTokenAToUnderlying,\\n          _pairConfigToSet.mapTokenBToUnderlying\\n        )\\n        : (\\n          _keyForSortedPair(_pairConfigToSet.tokenB, _pairConfigToSet.tokenA),\\n          _pairConfigToSet.mapTokenBToUnderlying,\\n          _pairConfigToSet.mapTokenAToUnderlying\\n        );\\n      _pairSpecificMappingConfig[_key] = PairSpecificMappingConfig(_mapTokenAToUnderlying, _mapTokenBToUnderlying, true);\\n      unchecked {\\n        i++;\\n      }\\n    }\\n    emit PairSpecificConfigSet(_config);\\n  }\\n\\n  /// @inheritdoc ITransformerOracle\\n  function clearPairSpecificMappingConfig(Pair[] calldata _pairs) external onlyRole(ADMIN_ROLE) {\\n    for (uint256 i = 0; i < _pairs.length; ) {\\n      delete _pairSpecificMappingConfig[_keyForPair(_pairs[i].tokenA, _pairs[i].tokenB)];\\n      unchecked {\\n        i++;\\n      }\\n    }\\n    emit PairSpecificConfigCleared(_pairs);\\n  }\\n\\n  /// @inheritdoc ITokenPriceOracle\\n  function canSupportPair(address _tokenA, address _tokenB) external view returns (bool) {\\n    (address _mappedTokenA, address _mappedTokenB) = getRecursiveMappingForPair(_tokenA, _tokenB);\\n    return UNDERLYING_ORACLE.canSupportPair(_mappedTokenA, _mappedTokenB);\\n  }\\n\\n  /// @inheritdoc ITokenPriceOracle\\n  function isPairAlreadySupported(address _tokenA, address _tokenB) external view returns (bool) {\\n    (address _mappedTokenA, address _mappedTokenB) = getRecursiveMappingForPair(_tokenA, _tokenB);\\n    return UNDERLYING_ORACLE.isPairAlreadySupported(_mappedTokenA, _mappedTokenB);\\n  }\\n\\n  /// @inheritdoc ITokenPriceOracle\\n  function quote(\\n    address _tokenIn,\\n    uint256 _amountIn,\\n    address _tokenOut,\\n    bytes calldata _data\\n  ) external view returns (uint256 _amountOut) {\\n    return _getRecursiveQuote(_tokenIn, _amountIn, _tokenOut, _data, true, true);\\n  }\\n\\n  function _getRecursiveQuote(\\n    address _tokenIn,\\n    uint256 _amountIn,\\n    address _tokenOut,\\n    bytes calldata _data,\\n    bool _shouldCheckIn,\\n    bool _shouldCheckOut\\n  ) internal view returns (uint256 _amountOut) {\\n    (ITransformer _transformerTokenIn, ITransformer _transformerTokenOut) = _getTransformers(\\n      _tokenIn,\\n      _tokenOut,\\n      _shouldCheckIn,\\n      _shouldCheckOut\\n    );\\n\\n    bool _tokenInHasUnderlying = address(_transformerTokenIn) != address(0);\\n    bool _tokenOutHasUnderlying = address(_transformerTokenOut) != address(0);\\n\\n    if (!_tokenInHasUnderlying && !_tokenOutHasUnderlying) {\\n      return UNDERLYING_ORACLE.quote(_tokenIn, _amountIn, _tokenOut, _data);\\n    }\\n\\n    if (_tokenInHasUnderlying) {\\n      // If token in has a transformer, then calculate how much amount it would be in underlying, and calculate the quote for that\\n      ITransformer.UnderlyingAmount[] memory _transformedIn = _transformerTokenIn.calculateTransformToUnderlying(_tokenIn, _amountIn);\\n      _tokenIn = _transformedIn[0].underlying;\\n      _amountIn = _transformedIn[0].amount;\\n    }\\n\\n    if (_tokenOutHasUnderlying) {\\n      // If token out has a transformer, then calculate the quote for the underlying and then transform the result\\n      address[] memory _underlyingOut = _transformerTokenOut.getUnderlying(_tokenOut);\\n      uint256 _amountOutUnderlying = _getRecursiveQuote(_tokenIn, _amountIn, _underlyingOut[0], _data, _tokenInHasUnderlying, true);\\n      return _transformerTokenOut.calculateTransformToDependent(_tokenOut, _toUnderlyingAmount(_underlyingOut[0], _amountOutUnderlying));\\n    }\\n\\n    return _getRecursiveQuote(_tokenIn, _amountIn, _tokenOut, _data, _tokenInHasUnderlying, false);\\n  }\\n\\n  /// @inheritdoc ITokenPriceOracle\\n  function addOrModifySupportForPair(\\n    address _tokenA,\\n    address _tokenB,\\n    bytes calldata _data\\n  ) external {\\n    (address _mappedTokenA, address _mappedTokenB) = getRecursiveMappingForPair(_tokenA, _tokenB);\\n    UNDERLYING_ORACLE.addOrModifySupportForPair(_mappedTokenA, _mappedTokenB, _data);\\n  }\\n\\n  /// @inheritdoc ITokenPriceOracle\\n  function addSupportForPairIfNeeded(\\n    address _tokenA,\\n    address _tokenB,\\n    bytes calldata _data\\n  ) external {\\n    (address _mappedTokenA, address _mappedTokenB) = getRecursiveMappingForPair(_tokenA, _tokenB);\\n    UNDERLYING_ORACLE.addSupportForPairIfNeeded(_mappedTokenA, _mappedTokenB, _data);\\n  }\\n\\n  /// @inheritdoc IERC165\\n  function supportsInterface(bytes4 _interfaceId) public view override(AccessControl, BaseOracle) returns (bool) {\\n    return\\n      _interfaceId == type(ITransformerOracle).interfaceId ||\\n      AccessControl.supportsInterface(_interfaceId) ||\\n      BaseOracle.supportsInterface(_interfaceId);\\n  }\\n\\n  /**\\n   * @notice Takes a token and a associated transformer (could not exist). If the transformer exists, this\\n   *         function will return the underlying token. If it doesn't exist, then it will return the given token\\n   */\\n  function _mapToUnderlyingIfExists(address _token, ITransformer _transformer) internal view returns (address) {\\n    if (address(_transformer) == address(0)) {\\n      return _token;\\n    }\\n    address[] memory _underlying = _transformer.getUnderlying(_token);\\n    return _underlying[0];\\n  }\\n\\n  function _getRecursiveMappingForPair(\\n    address _tokenA,\\n    address _tokenB,\\n    bool _shouldCheckA,\\n    bool _shouldCheckB\\n  ) internal view returns (address _mappedTokenA, address _mappedTokenB) {\\n    (ITransformer _transformerTokenA, ITransformer _transformerTokenB) = _getTransformers(_tokenA, _tokenB, _shouldCheckA, _shouldCheckB);\\n    if (address(_transformerTokenA) == address(0) && address(_transformerTokenB) == address(0)) {\\n      return (_tokenA, _tokenB);\\n    }\\n    return\\n      _getRecursiveMappingForPair(\\n        _mapToUnderlyingIfExists(_tokenA, _transformerTokenA),\\n        _mapToUnderlyingIfExists(_tokenB, _transformerTokenB),\\n        address(_transformerTokenA) != address(0),\\n        address(_transformerTokenB) != address(0)\\n      );\\n  }\\n\\n  function _getTransformers(\\n    address _tokenA,\\n    address _tokenB,\\n    bool _shouldCheckA,\\n    bool _shouldCheckB\\n  ) internal view virtual returns (ITransformer _transformerTokenA, ITransformer _transformerTokenB) {\\n    (ITransformer _fetchedTransformerA, ITransformer _fetchedTransformerB) = _fetchTransformers(_tokenA, _tokenB, _shouldCheckA, _shouldCheckB);\\n    return _hideTransformersBasedOnConfig(_tokenA, _tokenB, _fetchedTransformerA, _fetchedTransformerB);\\n  }\\n\\n  function _fetchTransformers(\\n    address _tokenA,\\n    address _tokenB,\\n    bool _shouldCheckA,\\n    bool _shouldCheckB\\n  ) internal view returns (ITransformer _transformerTokenA, ITransformer _transformerTokenB) {\\n    if (_shouldCheckA && _shouldCheckB) {\\n      address[] memory _tokens = new address[](2);\\n      _tokens[0] = _tokenA;\\n      _tokens[1] = _tokenB;\\n      ITransformer[] memory _transformers = REGISTRY.transformers(_tokens);\\n      return (_transformers[0], _transformers[1]);\\n    } else if (_shouldCheckA) {\\n      address[] memory _tokens = new address[](1);\\n      _tokens[0] = _tokenA;\\n      ITransformer[] memory _transformers = REGISTRY.transformers(_tokens);\\n      return (_transformers[0], ITransformer(address(0)));\\n    } else if (_shouldCheckB) {\\n      address[] memory _tokens = new address[](1);\\n      _tokens[0] = _tokenB;\\n      ITransformer[] memory _transformers = REGISTRY.transformers(_tokens);\\n      return (ITransformer(address(0)), _transformers[0]);\\n    } else {\\n      return (ITransformer(address(0)), ITransformer(address(0)));\\n    }\\n  }\\n\\n  /**\\n   * @dev We have the transformers for tokenA and tokenB, but maybe, based on the config, we don't want to map these tokens to their underlying.\\n   *      For example, this is normally the case for WETH and ETH. So this function will take the transformers and, based on the config, return\\n   *      the fetched transformers or the zero address\\n   */\\n  function _hideTransformersBasedOnConfig(\\n    address _tokenA,\\n    address _tokenB,\\n    ITransformer _transformerTokenA,\\n    ITransformer _transformerTokenB\\n  ) internal view returns (ITransformer _mappedTransformerTokenA, ITransformer _mappedTransformerTokenB) {\\n    bool _tokenAHasTransformer = address(_transformerTokenA) != address(0);\\n    bool _tokenBHasTransformer = address(_transformerTokenB) != address(0);\\n\\n    if (_tokenAHasTransformer || _tokenBHasTransformer) {\\n      bool _avoidMappingTokenA = false;\\n      bool _avoidMappingTokenB = false;\\n\\n      PairSpecificMappingConfig memory _config = pairSpecificMappingConfig(_tokenA, _tokenB);\\n      if (_config.isSet) {\\n        _avoidMappingTokenA = _tokenAHasTransformer && (_tokenA < _tokenB ? !_config.mapTokenAToUnderlying : !_config.mapTokenBToUnderlying);\\n        _avoidMappingTokenB = _tokenBHasTransformer && (_tokenA < _tokenB ? !_config.mapTokenBToUnderlying : !_config.mapTokenAToUnderlying);\\n      } else {\\n        _avoidMappingTokenA = _tokenAHasTransformer && willAvoidMappingToUnderlying[_tokenA];\\n        _avoidMappingTokenB = _tokenBHasTransformer && willAvoidMappingToUnderlying[_tokenB];\\n      }\\n\\n      if (!_avoidMappingTokenA) {\\n        _mappedTransformerTokenA = _transformerTokenA;\\n      }\\n\\n      if (!_avoidMappingTokenB) {\\n        _mappedTransformerTokenB = _transformerTokenB;\\n      }\\n    }\\n  }\\n\\n  function _toUnderlyingAmount(address _underlying, uint256 _amount)\\n    internal\\n    pure\\n    returns (ITransformer.UnderlyingAmount[] memory _underlyingAmount)\\n  {\\n    _underlyingAmount = new ITransformer.UnderlyingAmount[](1);\\n    _underlyingAmount[0].underlying = _underlying;\\n    _underlyingAmount[0].amount = _amount;\\n  }\\n\\n  function _keyForPair(address _tokenA, address _tokenB) internal pure returns (bytes32) {\\n    (address __tokenA, address __tokenB) = TokenSorting.sortTokens(_tokenA, _tokenB);\\n    return _keyForSortedPair(__tokenA, __tokenB);\\n  }\\n\\n  function _keyForSortedPair(address _tokenA, address _tokenB) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_tokenA, _tokenB));\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/oracles/solidity/contracts/libraries/TokenSorting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >0.6;\\n\\n/**\\n * @title TokenSorting library\\n * @notice Provides functions to sort tokens easily\\n */\\nlibrary TokenSorting {\\n  /**\\n   * @notice Takes two tokens, and returns them sorted\\n   * @param _tokenA One of the tokens\\n   * @param _tokenB The other token\\n   * @return __tokenA The first of the tokens\\n   * @return __tokenB The second of the tokens\\n   */\\n  function sortTokens(address _tokenA, address _tokenB) internal pure returns (address __tokenA, address __tokenB) {\\n    (__tokenA, __tokenB) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\\n  }\\n}\\n\"\r\n    },\r\n    \"@mean-finance/oracles/solidity/interfaces/ITransformerOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport '@mean-finance/transformers/solidity/interfaces/ITransformerRegistry.sol';\\nimport './ITokenPriceOracle.sol';\\n\\n/**\\n * @title An implementation of `ITokenPriceOracle` that handles transformations between tokens\\n * @notice This oracle takes the transformer registry, and will transform some dependent tokens into their underlying\\n *         tokens before quoting. We do this because it's hard to quote `yield-bearing(USDC) => yield-bearing(ETH)`.\\n *         But we can easily do something like `yield-bearing(USDC) => USDC => ETH => yield-bearing(ETH)`. So the\\n *         idea is to use the transformer registry to transform between dependent and their underlying, and then\\n *         quote the underlyings.\\n */\\ninterface ITransformerOracle is ITokenPriceOracle {\\n  /// @notice How a specific pair will be mapped to their underlying tokens\\n  struct PairSpecificMappingConfig {\\n    // Whether tokenA will be mapped to its underlying (tokenA < tokenB)\\n    bool mapTokenAToUnderlying;\\n    // Whether tokenB will be mapped to its underlying (tokenA < tokenB)\\n    bool mapTokenBToUnderlying;\\n    // Whether the config is set\\n    bool isSet;\\n  }\\n\\n  /// @notice Pair-specifig mapping configuration to set\\n  struct PairSpecificMappingConfigToSet {\\n    // One of the pair's tokens\\n    address tokenA;\\n    // The other of the pair's tokens\\n    address tokenB;\\n    // Whether to map tokenA to its underlying\\n    bool mapTokenAToUnderlying;\\n    // Whether to map tokenB to its underlying\\n    bool mapTokenBToUnderlying;\\n  }\\n\\n  /// @notice A pair of tokens\\n  struct Pair {\\n    // One of the pair's tokens\\n    address tokenA;\\n    // The other of the pair's tokens\\n    address tokenB;\\n  }\\n\\n  /// @notice Thrown when a parameter is the zero address\\n  error ZeroAddress();\\n\\n  /**\\n   * @notice Emitted when new dependents are set to avoid mapping to their underlying counterparts\\n   * @param dependents The tokens that will avoid mapping\\n   */\\n  event DependentsWillAvoidMappingToUnderlying(address[] dependents);\\n\\n  /**\\n   * @notice Emitted when dependents are set to map to their underlying counterparts\\n   * @param dependents The tokens that will map to underlying\\n   */\\n  event DependentsWillMapToUnderlying(address[] dependents);\\n\\n  /**\\n   * @notice Emitted when dependents pair-specific mapping config is set\\n   * @param config The config that was set\\n   */\\n  event PairSpecificConfigSet(PairSpecificMappingConfigToSet[] config);\\n\\n  /**\\n   * @notice Emitted when dependents pair-specific mapping config is cleared\\n   * @param pairs The pairs that had their config cleared\\n   */\\n  event PairSpecificConfigCleared(Pair[] pairs);\\n\\n  /**\\n   * @notice Returns the address of the transformer registry\\n   * @dev Cannot be modified\\n   * @return The address of the transformer registry\\n   */\\n  function REGISTRY() external view returns (ITransformerRegistry);\\n\\n  /**\\n   * @notice Returns the address of the underlying oracle\\n   * @dev Cannot be modified\\n   * @return The address of the underlying oracle\\n   */\\n  function UNDERLYING_ORACLE() external view returns (ITokenPriceOracle);\\n\\n  /**\\n   * @notice Returns whether the given dependent will avoid mapping to their underlying counterparts\\n   * @param dependent The dependent token to check\\n   * @return Whether the given dependent will avoid mapping to their underlying counterparts\\n   */\\n  function willAvoidMappingToUnderlying(address dependent) external view returns (bool);\\n\\n  /**\\n   * @notice Takes a pair of tokens, and maps them to their underlying counterparts if they exist, and if they\\n   *         haven't been configured to avoid mapping. Pair-specific config will be prioritized, but if it isn't\\n   *         set, then global config will be used.\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @return mappedTokenA tokenA's underlying token, if exists and isn't configured to avoid mapping.\\n   *                      Otherwise tokenA\\n   * @return mappedTokenB tokenB's underlying token, if exists and isn't configured to avoid mapping.\\n   *                      Otherwise tokenB\\n   */\\n  function getMappingForPair(address tokenA, address tokenB) external view returns (address mappedTokenA, address mappedTokenB);\\n\\n  /**\\n   * @notice Very similar to `getMappingForPair`, but recursive. Since an underlying could have an underlying, we might need to map\\n   *         the given pair recursively\\n   */\\n  function getRecursiveMappingForPair(address tokenA, address tokenB) external view returns (address mappedTokenA, address mappedTokenB);\\n\\n  /**\\n   * @notice Returns any pair-specific mapping configuration for the given tokens\\n   * @dev tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   */\\n  function pairSpecificMappingConfig(address tokenA, address tokenB) external view returns (PairSpecificMappingConfig memory);\\n\\n  /**\\n   * @notice Determines that the given dependents will avoid mapping to their underlying counterparts, and\\n   *         instead perform quotes with their own addreses. This comes in handy with situations such as\\n   *         ETH/WETH, where some oracles use WETH instead of ETH\\n   * @param dependents The dependent tokens that should avoid mapping to underlying\\n   */\\n  function avoidMappingToUnderlying(address[] calldata dependents) external;\\n\\n  /**\\n   * @notice Determines that the given dependents go back to mapping to their underlying counterparts (the\\n   *         default behaviour)\\n   * @param dependents The dependent tokens that should go back to mapping to underlying\\n   */\\n  function shouldMapToUnderlying(address[] calldata dependents) external;\\n\\n  /**\\n   * @notice Determines how the given pairs should be mapped to their underlying tokens\\n   * @param config A list of pairs to configure\\n   */\\n  function setPairSpecificMappingConfig(PairSpecificMappingConfigToSet[] calldata config) external;\\n\\n  /**\\n   * @notice Cleares any pair-specific mapping config for the given list of pairs\\n   * @param pairs The pairs that will have their config cleared\\n   */\\n  function clearPairSpecificMappingConfig(Pair[] calldata pairs) external;\\n}\\n\"\r\n    },\r\n    \"@mean-finance/oracles/solidity/contracts/base/BaseOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.7 <0.9.0;\\n\\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\nimport '@openzeppelin/contracts/utils/Multicall.sol';\\nimport '../../interfaces/ITokenPriceOracle.sol';\\n\\n/// @title A base implementation of `ITokenPriceOracle` that implements `ERC165` and `Multicall`\\nabstract contract BaseOracle is Multicall, ERC165, ITokenPriceOracle {\\n  /// @inheritdoc IERC165\\n  function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\n    return\\n      _interfaceId == type(ITokenPriceOracle).interfaceId ||\\n      _interfaceId == type(Multicall).interfaceId ||\\n      super.supportsInterface(_interfaceId);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@mean-finance/transformers/solidity/interfaces/ITransformerRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport './ITransformer.sol';\\n\\n/**\\n * @title A registry for all existing transformers\\n * @notice This contract will contain all registered transformers and act as proxy. When called\\n *         the registry will find the corresponding transformer and delegate the call to it. If no\\n *         transformer is found, then it will fail\\n */\\ninterface ITransformerRegistry is ITransformer {\\n  /// @notice An association between a transformer, and some of its dependentes\\n  struct TransformerRegistration {\\n    address transformer;\\n    address[] dependents;\\n  }\\n\\n  /**\\n   * @notice Thrown when trying to register a dependent to an address that is not a transformer\\n   * @param account The account that was not a transformer\\n   */\\n  error AddressIsNotTransformer(address account);\\n\\n  /**\\n   * @notice Thrown when trying to execute an action with a dependent that has no transformer\\n   *          associated\\n   * @param dependent The dependent that didn't have a transformer\\n   */\\n  error NoTransformerRegistered(address dependent);\\n\\n  /**\\n   * @notice Emitted when new dependents are registered\\n   * @param registrations The dependents that were registered\\n   */\\n  event TransformersRegistered(TransformerRegistration[] registrations);\\n\\n  /**\\n   * @notice Emitted when dependents are removed from the registry\\n   * @param dependents The dependents that were removed\\n   */\\n  event TransformersRemoved(address[] dependents);\\n\\n  /**\\n   * @notice Returns the registered transformer for the given dependents\\n   * @param dependents The dependents to get the transformer for\\n   * @return The registered transformers, or the zero address if there isn't any\\n   */\\n  function transformers(address[] calldata dependents) external view returns (ITransformer[] memory);\\n\\n  /**\\n   * @notice Sets a new registration for the given dependents\\n   * @dev Can only be called by admin\\n   * @param registrations The associations to register\\n   */\\n  function registerTransformers(TransformerRegistration[] calldata registrations) external;\\n\\n  /**\\n   * @notice Removes registration for the given dependents\\n   * @dev Can only be called by admin\\n   * @param dependents The associations to remove\\n   */\\n  function removeTransformers(address[] calldata dependents) external;\\n\\n  /**\\n   * @notice Executes a transformation to the underlying tokens, by taking the caller's entire\\n   *         dependent balance. This is meant to be used as part of a multi-hop swap\\n   * @dev This function was made payable, so that it could be multicalled when msg.value > 0\\n   * @param dependent The address of the dependent token\\n   * @param recipient The address that would receive the underlying tokens\\n   * @param minAmountOut The minimum amount of underlying that the caller expects to get. Will fail\\n   *                     if less is received. As a general rule, the underlying tokens should\\n   *                     be provided in the same order as `getUnderlying` returns them\\n   * @param deadline A deadline when the transaction becomes invalid\\n   * @return The transformed amount in each of the underlying tokens\\n   */\\n  function transformAllToUnderlying(\\n    address dependent,\\n    address recipient,\\n    UnderlyingAmount[] calldata minAmountOut,\\n    uint256 deadline\\n  ) external payable returns (UnderlyingAmount[] memory);\\n\\n  /**\\n   * @notice Executes a transformation to the dependent token, by taking the caller's entire\\n   *         underlying balance. This is meant to be used as part of a multi-hop swap\\n   * @dev This function will not work when the underlying token is ETH/MATIC/BNB, since it can't be taken from the caller\\n   *      This function was made payable, so that it could be multicalled when msg.value > 0\\n   * @param dependent The address of the dependent token\\n   * @param recipient The address that would receive the dependent tokens\\n   * @param minAmountOut The minimum amount of dependent that the caller expects to get. Will fail\\n   *                     if less is received\\n   * @param deadline A deadline when the transaction becomes invalid\\n   * @return amountDependent The transformed amount in the dependent token\\n   */\\n  function transformAllToDependent(\\n    address dependent,\\n    address recipient,\\n    uint256 minAmountOut,\\n    uint256 deadline\\n  ) external payable returns (uint256 amountDependent);\\n}\\n\"\r\n    },\r\n    \"@mean-finance/oracles/solidity/interfaces/ITokenPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title The interface for an oracle that provides price quotes\\n * @notice These methods allow users to add support for pairs, and then ask for quotes\\n */\\ninterface ITokenPriceOracle {\\n  /// @notice Thrown when trying to add support for a pair that cannot be supported\\n  error PairCannotBeSupported(address tokenA, address tokenB);\\n\\n  /// @notice Thrown when trying to execute a quote with a pair that isn't supported yet\\n  error PairNotSupportedYet(address tokenA, address tokenB);\\n\\n  /**\\n   * @notice Returns whether this oracle can support the given pair of tokens\\n   * @dev tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @return Whether the given pair of tokens can be supported by the oracle\\n   */\\n  function canSupportPair(address tokenA, address tokenB) external view returns (bool);\\n\\n  /**\\n   * @notice Returns whether this oracle is already supporting the given pair of tokens\\n   * @dev tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @return Whether the given pair of tokens is already being supported by the oracle\\n   */\\n  function isPairAlreadySupported(address tokenA, address tokenB) external view returns (bool);\\n\\n  /**\\n   * @notice Returns a quote, based on the given tokens and amount\\n   * @dev Will revert if pair isn't supported\\n   * @param tokenIn The token that will be provided\\n   * @param amountIn The amount that will be provided\\n   * @param tokenOut The token we would like to quote\\n   * @param data Custom data that the oracle might need to operate\\n   * @return amountOut How much `tokenOut` will be returned in exchange for `amountIn` amount of `tokenIn`\\n   */\\n  function quote(\\n    address tokenIn,\\n    uint256 amountIn,\\n    address tokenOut,\\n    bytes calldata data\\n  ) external view returns (uint256 amountOut);\\n\\n  /**\\n   * @notice Add or reconfigures the support for a given pair. This function will let the oracle take some actions\\n   *         to configure the pair, in preparation for future quotes. Can be called many times in order to let the oracle\\n   *         re-configure for a new context\\n   * @dev Will revert if pair cannot be supported. tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @param data Custom data that the oracle might need to operate\\n   */\\n  function addOrModifySupportForPair(\\n    address tokenA,\\n    address tokenB,\\n    bytes calldata data\\n  ) external;\\n\\n  /**\\n   * @notice Adds support for a given pair if the oracle didn't support it already. If called for a pair that is already supported,\\n   *         then nothing will happen. This function will let the oracle take some actions to configure the pair, in preparation\\n   *         for future quotes\\n   * @dev Will revert if pair cannot be supported. tokenA and tokenB may be passed in either tokenA/tokenB or tokenB/tokenA order\\n   * @param tokenA One of the pair's tokens\\n   * @param tokenB The other of the pair's tokens\\n   * @param data Custom data that the oracle might need to operate\\n   */\\n  function addSupportForPairIfNeeded(\\n    address tokenA,\\n    address tokenB,\\n    bytes calldata data\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@mean-finance/transformers/solidity/interfaces/ITransformer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title A contract that can map between one token and their underlying counterparts, and vice-versa\\n * @notice This contract defines the concept of dependent tokens. These are tokens that depend on one or more underlying tokens,\\n *         they can't exist on their own. This concept can apply to some known types of tokens, such as:\\n *           - Wrappers (WETH/WMATIC/WBNB)\\n *           - ERC-4626 tokens\\n *           - LP tokens\\n *         Now, transformers are smart contract that knows how to map dependent tokens into their underlying counterparts,\\n *         and vice-versa. We are doing this so that we can abstract the way tokens can be transformed between each other\\n * @dev All non-view functions were made payable, so that they could be multicalled when msg.value > 0\\n */\\ninterface ITransformer {\\n  /// @notice An amount of an underlying token\\n  struct UnderlyingAmount {\\n    address underlying;\\n    uint256 amount;\\n  }\\n\\n  /// @notice Thrown when the underlying input is not valid for the used transformer\\n  error InvalidUnderlyingInput();\\n\\n  /// @notice Thrown when the transformation provides less output than expected\\n  error ReceivedLessThanExpected(uint256 received);\\n\\n  /// @notice Thrown when the transformation needs more input than expected\\n  error NeededMoreThanExpected(uint256 needed);\\n\\n  /// @notice Thrown when a transaction is executed after the deadline has passed\\n  error TransactionExpired();\\n\\n  /**\\n   * @notice Returns the addresses of all the underlying tokens, for the given dependent\\n   * @dev This function must be unaware of context. The returned values must be the same,\\n   *      regardless of who the caller is\\n   * @param dependent The address of the dependent token\\n   * @return The addresses of all the underlying tokens\\n   */\\n  function getUnderlying(address dependent) external view returns (address[] memory);\\n\\n  /**\\n   * @notice Calculates how much would the transformation to the underlying tokens return\\n   * @dev This function must be unaware of context. The returned values must be the same,\\n   *      regardless of who the caller is\\n   * @param dependent The address of the dependent token\\n   * @param amountDependent The amount to transform\\n   * @return The transformed amount in each of the underlying tokens\\n   */\\n  function calculateTransformToUnderlying(address dependent, uint256 amountDependent) external view returns (UnderlyingAmount[] memory);\\n\\n  /**\\n   * @notice Calculates how much would the transformation to the dependent token return\\n   * @dev This function must be unaware of context. The returned values must be the same,\\n   *      regardless of who the caller is\\n   * @param dependent The address of the dependent token\\n   * @param underlying The amounts of underlying tokens to transform\\n   * @return amountDependent The transformed amount in the dependent token\\n   */\\n  function calculateTransformToDependent(address dependent, UnderlyingAmount[] calldata underlying)\\n    external\\n    view\\n    returns (uint256 amountDependent);\\n\\n  /**\\n   * @notice Calculates how many dependent tokens are needed to transform to the expected\\n   *         amount of underlying\\n   * @dev This function must be unaware of context. The returned values must be the same,\\n   *      regardless of who the caller is\\n   * @param dependent The address of the dependent token\\n   * @param expectedUnderlying The expected amounts of underlying tokens\\n   * @return neededDependent The amount of dependent needed\\n   */\\n  function calculateNeededToTransformToUnderlying(address dependent, UnderlyingAmount[] calldata expectedUnderlying)\\n    external\\n    view\\n    returns (uint256 neededDependent);\\n\\n  /**\\n   * @notice Calculates how many underlying tokens are needed to transform to the expected\\n   *         amount of dependent\\n   * @dev This function must be unaware of context. The returned values must be the same,\\n   *      regardless of who the caller is\\n   * @param dependent The address of the dependent token\\n   * @param expectedDependent The expected amount of dependent tokens\\n   * @return neededUnderlying The amount of underlying tokens needed\\n   */\\n  function calculateNeededToTransformToDependent(address dependent, uint256 expectedDependent)\\n    external\\n    view\\n    returns (UnderlyingAmount[] memory neededUnderlying);\\n\\n  /**\\n   * @notice Executes the transformation to the underlying tokens\\n   * @param dependent The address of the dependent token\\n   * @param amountDependent The amount to transform\\n   * @param recipient The address that would receive the underlying tokens\\n   * @param minAmountOut The minimum amount of underlying that the caller expects to get. Will fail\\n   *                     if less is received. As a general rule, the underlying tokens should\\n   *                     be provided in the same order as `getUnderlying` returns them\\n   * @param deadline A deadline when the transaction becomes invalid\\n   * @return The transformed amount in each of the underlying tokens\\n   */\\n  function transformToUnderlying(\\n    address dependent,\\n    uint256 amountDependent,\\n    address recipient,\\n    UnderlyingAmount[] calldata minAmountOut,\\n    uint256 deadline\\n  ) external payable returns (UnderlyingAmount[] memory);\\n\\n  /**\\n   * @notice Executes the transformation to the dependent token\\n   * @param dependent The address of the dependent token\\n   * @param underlying The amounts of underlying tokens to transform\\n   * @param recipient The address that would receive the dependent tokens\\n   * @param minAmountOut The minimum amount of dependent that the caller expects to get. Will fail\\n   *                     if less is received\\n   * @param deadline A deadline when the transaction becomes invalid\\n   * @return amountDependent The transformed amount in the dependent token\\n   */\\n  function transformToDependent(\\n    address dependent,\\n    UnderlyingAmount[] calldata underlying,\\n    address recipient,\\n    uint256 minAmountOut,\\n    uint256 deadline\\n  ) external payable returns (uint256 amountDependent);\\n\\n  /**\\n   * @notice Transforms dependent tokens to an expected amount of underlying tokens\\n   * @param dependent The address of the dependent token\\n   * @param expectedUnderlying The expected amounts of underlying tokens\\n   * @param recipient The address that would receive the underlying tokens\\n   * @param maxAmountIn The maximum amount of dependent that the caller is willing to spend.\\n   *                    Will fail more is needed\\n   * @param deadline A deadline when the transaction becomes invalid\\n   * @return spentDependent The amount of spent dependent tokens\\n   */\\n  function transformToExpectedUnderlying(\\n    address dependent,\\n    UnderlyingAmount[] calldata expectedUnderlying,\\n    address recipient,\\n    uint256 maxAmountIn,\\n    uint256 deadline\\n  ) external payable returns (uint256 spentDependent);\\n\\n  /**\\n   * @notice Transforms underlying tokens to an expected amount of dependent tokens\\n   * @param dependent The address of the dependent token\\n   * @param expectedDependent The expected amounts of dependent tokens\\n   * @param recipient The address that would receive the underlying tokens\\n   * @param maxAmountIn The maximum amount of underlying that the caller is willing to spend.\\n   *                    Will fail more is needed. As a general rule, the underlying tokens should\\n   *                    be provided in the same order as `getUnderlying` returns them\\n   * @param deadline A deadline when the transaction becomes invalid\\n   * @return spentUnderlying The amount of spent underlying tokens\\n   */\\n  function transformToExpectedDependent(\\n    address dependent,\\n    uint256 expectedDependent,\\n    address recipient,\\n    UnderlyingAmount[] calldata maxAmountIn,\\n    uint256 deadline\\n  ) external payable returns (UnderlyingAmount[] memory spentUnderlying);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract Multicall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ITransformerRegistry\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"contract ITokenPriceOracle\",\"name\":\"_underlyingOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_superAdmin\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_initialAdmins\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"PairCannotBeSupported\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"PairNotSupportedYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"dependents\",\"type\":\"address[]\"}],\"name\":\"DependentsWillAvoidMappingToUnderlying\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"dependents\",\"type\":\"address[]\"}],\"name\":\"DependentsWillMapToUnderlying\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct ITransformerOracle.Pair[]\",\"name\":\"pairs\",\"type\":\"tuple[]\"}],\"name\":\"PairSpecificConfigCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"mapTokenAToUnderlying\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"mapTokenBToUnderlying\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct ITransformerOracle.PairSpecificMappingConfigToSet[]\",\"name\":\"config\",\"type\":\"tuple[]\"}],\"name\":\"PairSpecificConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REGISTRY\",\"outputs\":[{\"internalType\":\"contract ITransformerRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPER_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNDERLYING_ORACLE\",\"outputs\":[{\"internalType\":\"contract ITokenPriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"addOrModifySupportForPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"addSupportForPairIfNeeded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_dependents\",\"type\":\"address[]\"}],\"name\":\"avoidMappingToUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"name\":\"canSupportPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"internalType\":\"struct ITransformerOracle.Pair[]\",\"name\":\"_pairs\",\"type\":\"tuple[]\"}],\"name\":\"clearPairSpecificMappingConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"name\":\"getMappingForPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_mappedTokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mappedTokenB\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"name\":\"getRecursiveMappingForPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_mappedTokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mappedTokenB\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"name\":\"isPairAlreadySupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"}],\"name\":\"pairSpecificMappingConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"mapTokenAToUnderlying\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"mapTokenBToUnderlying\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSet\",\"type\":\"bool\"}],\"internalType\":\"struct ITransformerOracle.PairSpecificMappingConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"mapTokenAToUnderlying\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"mapTokenBToUnderlying\",\"type\":\"bool\"}],\"internalType\":\"struct ITransformerOracle.PairSpecificMappingConfigToSet[]\",\"name\":\"_config\",\"type\":\"tuple[]\"}],\"name\":\"setPairSpecificMappingConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_dependents\",\"type\":\"address[]\"}],\"name\":\"shouldMapToUnderlying\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"willAvoidMappingToUnderlying\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TransformerOracle", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "000000000000000000000000c0136591df365611b1452b5f8823def69ff3a6850000000000000000000000009e1ca4cd00ed059c5d34204dce622549583545d9000000000000000000000000ec864be26084ba3bbf3caacf8f6961a9263319c400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000ec864be26084ba3bbf3caacf8f6961a9263319c4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}