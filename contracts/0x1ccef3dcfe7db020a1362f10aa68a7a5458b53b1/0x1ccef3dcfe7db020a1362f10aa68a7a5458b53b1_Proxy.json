{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport \\\"./Mixer.sol\\\";\\r\\nimport \\\"./Wallet.sol\\\";\\r\\n\\r\\ncontract Proxy {\\r\\n    event Created(address newMixer, address recipient, uint divRate, uint delayTime, uint srcChainId, uint dscChainId);\\r\\n\\r\\n    function createMixer(\\r\\n        address _recipient,\\r\\n        uint _divRate,\\r\\n        uint _delayTime,\\r\\n        uint _srcChainId,\\r\\n        uint _dscChainId\\r\\n    ) public {\\r\\n        address walletA = address(new Wallet(_recipient, _dscChainId));\\r\\n        address walletB = address(new Wallet(_recipient, _dscChainId));\\r\\n        address newMixer = address(new Mixer(walletA, walletB, _divRate, _delayTime));\\r\\n\\r\\n        emit Created(newMixer, _recipient, _divRate, _delayTime, _srcChainId, _dscChainId);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Mixer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./interfaces/IWallet.sol\\\";\\n\\ncontract Mixer {\\n    using SafeMath for uint;\\n\\n    address public walletA;\\n    address public walletB;\\n    uint public divRate;\\n    uint public delayTime;\\n    uint public startTime;\\n    bool public isSplited = false;\\n    bool public isDelayed = false;\\n\\n    constructor(\\n        address _walletA, \\n        address _walletB, \\n        uint _divRate,\\n        uint _delayTime\\n    ) {\\n        walletA = _walletA;\\n        walletB = _walletB;\\n        divRate = _divRate;\\n        delayTime = _delayTime;\\n\\n        startTime = block.timestamp;\\n    }\\n\\n    function split() external {\\n        require(isSplited == false, \\\"Already called\\\");\\n        uint amount = address(this).balance;\\n        require(amount > 0, \\\"Token amount must be not zero\\\");\\n        \\n        // uint amountA = amount.mul(divRate).div(1000);\\n        // uint amountB = amount.sub(amountA);\\n        isSplited = true;\\n\\n        payable(walletA).transfer(amount);\\n        // payable(walletB).transfer(amountB);\\n        IWallet(walletA).transfer();\\n    }\\n\\n    function delay() external {\\n        require(block.timestamp > startTime + delayTime, \\\"Already did\\\");\\n        require(isDelayed == false, \\\"Already called\\\");\\n        isDelayed = true;\\n\\n        IWallet(walletB).transfer();\\n    }\\n\\n    receive() external payable {}\\n    // // Fallback function is called when msg.data is not empty\\n    fallback() external payable {}\\n\\n    function getBalance() public view returns (uint) {\\n        return address(this).balance;\\n    }\\n\\n    function withdraw(address _user) external {\\n        uint amount = address(this).balance;\\n        payable(_user).transfer(amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Wallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n// import {IConnext} from \\\"@connext/interfaces/core/IConnext.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/ISwap.sol\\\";\\r\\nimport \\\"./interfaces/IWeth.sol\\\";\\r\\n\\r\\ncontract Wallet {\\r\\n\\r\\n    address private recipient;\\r\\n    uint private dscChainId;\\r\\n    address public constant XSwapperAddress = 0x4315f344a905dC21a08189A117eFd6E1fcA37D57; // need to change each chains.\\r\\n    // address public constant ContextAddress = 0x8898B472C54c31894e3B9bb83cEA802a5d0e63C6; // need to change each chains.\\r\\n    address public constant ETHER_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\r\\n    // address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    // IConnext public immutable connext = IConnext(ContextAddress);\\r\\n    ISwap immutable public XSwapper = ISwap(XSwapperAddress);\\r\\n\\r\\n    constructor(address _recipient, uint _dscChainId) {\\r\\n        recipient = _recipient;\\r\\n        dscChainId = _dscChainId;\\r\\n    } \\r\\n\\r\\n    function transfer() external {\\r\\n        uint amount = address(this).balance;\\r\\n        // uint relayerFee = 1000000;\\r\\n        // payable(recipient).transfer(amount);\\r\\n        SwapDescription memory swapData;\\r\\n        swapData.fromToken = IERC20(ETHER_ADDRESS);\\r\\n        swapData.toToken = IERC20(ETHER_ADDRESS);\\r\\n        swapData.receiver = recipient;\\r\\n        swapData.amount = amount;\\r\\n        swapData.minReturnAmount = amount;\\r\\n\\r\\n        ToChainDescription memory chainData;\\r\\n        chainData.toChainId = uint32(dscChainId);\\r\\n        chainData.toChainToken = IERC20(ETHER_ADDRESS);\\r\\n        chainData.expectedToChainTokenAmount = amount;\\r\\n        chainData.slippage = uint32(100);\\r\\n        XSwapper.swap{value: amount}(\\r\\n            address(0),\\r\\n            swapData, // swapDesc\\r\\n            \\\"\\\",\\r\\n            chainData // chainDesc\\r\\n        );\\r\\n            // Wrap ETH into WETH to send with the xcall\\r\\n        // IWeth(WETH).deposit{value: amount - relayerFee}();\\r\\n\\r\\n        // // This contract approves transfer to Connext\\r\\n        // IWeth(WETH).approve(address(connext), amount - relayerFee);\\r\\n\\r\\n        // // Encode the recipient address for calldata\\r\\n        // bytes memory callData = abi.encode(recipient);\\r\\n        // // xcall the Unwrapper contract to unwrap WETH into ETH on destination\\r\\n        // connext.xcall{value: relayerFee}(\\r\\n        //     1634886255,    // _destination: Domain ID of the destination chain\\r\\n        //     0x429b9eb01362b2799131EfCC44319689b662999D, // _to: Unwrapper contract\\r\\n        //     WETH,                 // _asset: address of the WETH contract\\r\\n        //     msg.sender,           // _delegate: address that can revert or forceLocal on destination\\r\\n        //     amount - relayerFee,               // _amount: amount of tokens to transfer\\r\\n        //     30,                   // _slippage: the maximum amount of slippage the user will accept in BPS (e.g. 30 = 0.3%)\\r\\n        //     callData              // _callData: calldata with encoded recipient address\\r\\n        // );\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n    // Fallback function is called when msg.data is not empty\\r\\n    fallback() external payable {}\\r\\n\\r\\n    function getBalance() public view returns (uint) {\\r\\n        return address(this).balance;\\r\\n    }\\r\\n\\r\\n    function withdraw(address _user) external {\\r\\n        uint amount = address(this).balance;\\r\\n        payable(_user).transfer(amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\n// interface for Wallet\\ninterface IWallet {\\n    function transfer() external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nstruct SwapDescription {\\r\\n    IERC20 fromToken;\\r\\n    IERC20 toToken;\\r\\n    address receiver;\\r\\n    uint256 amount;\\r\\n    uint256 minReturnAmount;\\r\\n}\\r\\n\\r\\nstruct ToChainDescription {\\r\\n    uint32 toChainId;\\r\\n    IERC20 toChainToken;\\r\\n    uint256 expectedToChainTokenAmount;\\r\\n    uint32 slippage;\\r\\n}\\r\\n\\r\\n// interface for xy.finance swap\\r\\ninterface ISwap {\\r\\n    function swap(\\r\\n        address aggregatorAdaptor,\\r\\n        SwapDescription memory swapDesc,\\r\\n        bytes memory aggregatorData,\\r\\n        ToChainDescription calldata toChainDesc\\r\\n    ) external payable;\\r\\n\\r\\n    function getTokenBalance(IERC20 _token, address _account) external returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWeth.sol\": {\r\n      \"content\": \"\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.18;\\r\\n\\r\\ninterface IWeth {\\r\\n  function deposit() external payable;\\r\\n  function approve(address guy, uint wad) external returns (bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMixer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"divRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delayTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dscChainId\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_divRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_delayTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dscChainId\",\"type\":\"uint256\"}],\"name\":\"createMixer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}