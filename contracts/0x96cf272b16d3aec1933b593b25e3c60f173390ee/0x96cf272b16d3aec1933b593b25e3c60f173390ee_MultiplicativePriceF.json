{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\n/**\\n * @dev Interface for price feeds used by Comet\\n * Note This is Chainlink's AggregatorV3Interface, but without the `getRoundData` function.\\n */\\ninterface IPriceFeed {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\"\r\n    },\r\n    \"contracts/pricefeeds/MultiplicativePriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"../vendor/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../IPriceFeed.sol\\\";\\n\\n/**\\n * @title Multiplicative price feed\\n * @notice A custom price feed that multiplies the prices from two price feeds and returns the result\\n * @author Compound\\n */\\ncontract MultiplicativePriceFeed is IPriceFeed {\\n    /** Custom errors **/\\n    error BadDecimals();\\n    error InvalidInt256();\\n\\n    /// @notice Version of the price feed\\n    uint public constant VERSION = 1;\\n\\n    /// @notice Description of the price feed\\n    string public override description;\\n\\n    /// @notice Number of decimals for returned prices\\n    uint8 public immutable override decimals;\\n\\n    /// @notice Chainlink price feed A\\n    address public immutable priceFeedA;\\n\\n    /// @notice Chainlink price feed B\\n    address public immutable priceFeedB;\\n\\n    /// @notice Combined scale of the two underlying Chainlink price feeds\\n    int public immutable combinedScale;\\n\\n    /// @notice Scale of this price feed\\n    int public immutable priceFeedScale;\\n\\n    /**\\n     * @notice Construct a new multiplicative price feed\\n     * @param priceFeedA_ The address of the first price feed to fetch prices from\\n     * @param priceFeedB_ The address of the second price feed to fetch prices from\\n     * @param decimals_ The number of decimals for the returned prices\\n     * @param description_ The description of the price feed\\n     **/\\n    constructor(address priceFeedA_, address priceFeedB_, uint8 decimals_, string memory description_) {\\n        priceFeedA = priceFeedA_;\\n        priceFeedB = priceFeedB_;\\n        uint8 priceFeedADecimals = AggregatorV3Interface(priceFeedA_).decimals();\\n        uint8 priceFeedBDecimals = AggregatorV3Interface(priceFeedB_).decimals();\\n        combinedScale = signed256(10 ** (priceFeedADecimals + priceFeedBDecimals));\\n\\n        if (decimals_ > 18) revert BadDecimals();\\n        decimals = decimals_;\\n        description = description_;\\n        priceFeedScale = int256(10 ** decimals);\\n    }\\n\\n    /**\\n     * @notice Calculates the latest round data using data from the two price feeds\\n     * @return roundId Round id from price feed B\\n     * @return answer Latest price\\n     * @return startedAt Timestamp when the round was started; passed on from price feed B\\n     * @return updatedAt Timestamp when the round was last updated; passed on from price feed B\\n     * @return answeredInRound Round id in which the answer was computed; passed on from price feed B\\n     * @dev Note: Only the `answer` really matters for downstream contracts that use this price feed (e.g. Comet)\\n     **/\\n    function latestRoundData() override external view returns (uint80, int256, uint256, uint256, uint80) {\\n        (, int256 priceA, , , ) = AggregatorV3Interface(priceFeedA).latestRoundData();\\n        (uint80 roundId_, int256 priceB, uint256 startedAt_, uint256 updatedAt_, uint80 answeredInRound_) = AggregatorV3Interface(priceFeedB).latestRoundData();\\n\\n        if (priceA <= 0 || priceB <= 0) return (roundId_, 0, startedAt_, updatedAt_, answeredInRound_);\\n\\n        int256 price = priceA * priceB * priceFeedScale / combinedScale;\\n        return (roundId_, price, startedAt_, updatedAt_, answeredInRound_);\\n    }\\n\\n    function signed256(uint256 n) internal pure returns (int256) {\\n        if (n > uint256(type(int256).max)) revert InvalidInt256();\\n        return int256(n);\\n    }\\n\\n    /**\\n     * @notice Price for the latest round\\n     * @return The version of the price feed contract\\n     **/\\n    function version() external pure returns (uint256) {\\n        return VERSION;\\n    }\\n}\"\r\n    },\r\n    \"contracts/vendor/@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1,\r\n      \"details\": {\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf [xa[r]scLM cCTUtTOntnfDIul Lcul Vcul [j] Tpeul xa[rul] xa[r]cL gvif CTUca[r]LsTOtfDnca[r]Iulc] jmul[jul] VcTOcul jmul\"\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"priceFeedA_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"priceFeedB_\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"description_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadDecimals\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInt256\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"combinedScale\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedScale\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "MultiplicativePriceFeed", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000004f67e4d9bd67efa28236013288737d39aef48e790000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000147773744554482f55534420707269636546656564000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}