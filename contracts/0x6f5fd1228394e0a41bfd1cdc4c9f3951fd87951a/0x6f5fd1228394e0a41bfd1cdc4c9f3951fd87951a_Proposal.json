{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/RelayerRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface IRelayerRegistry {\\n    function unregisterRelayer(address relayer) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/RelayerRegistryProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\ninterface IRelayerRegistryProxy {\\n    function upgradeTo(address newImplementation) external;\\n}\"\r\n    },\r\n    \"contracts/libraries/EnsNamehash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\n/*\\n * @dev Solidity implementation of the ENS namehash algorithm.\\n *\\n * Warning! Does not normalize or validate names before hashing.\\n * Original version can be found here https://github.com/JonahGroendal/ens-namehash/\\n */\\nlibrary ENSNamehash {\\n    function namehash(bytes memory domain) internal pure returns (bytes32) {\\n        return namehash(domain, 0);\\n    }\\n\\n    function namehash(bytes memory domain, uint256 i) internal pure returns (bytes32) {\\n        if (domain.length <= i) return 0x0000000000000000000000000000000000000000000000000000000000000000;\\n\\n        uint256 len = labelLength(domain, i);\\n\\n        return keccak256(abi.encodePacked(namehash(domain, i + len + 1), keccak(domain, i, len)));\\n    }\\n\\n    function labelLength(bytes memory domain, uint256 i) private pure returns (uint256) {\\n        uint256 len;\\n        while (i + len != domain.length && domain[i + len] != 0x2e) {\\n            len++;\\n        }\\n        return len;\\n    }\\n\\n    function keccak(bytes memory data, uint256 offset, uint256 len) private pure returns (bytes32 ret) {\\n        require(offset + len <= data.length);\\n        assembly {\\n            ret := keccak256(add(add(data, 32), offset), len)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/RegistryUpgradeProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport { IRelayerRegistryProxy } from \\\"./interfaces/RelayerRegistryProxy.sol\\\";\\nimport { IRelayerRegistry } from \\\"./interfaces/RelayerRegistry.sol\\\";\\nimport { ENSNamehash } from \\\"./libraries/EnsNamehash.sol\\\";\\nimport { EnsResolve } from \\\"torn-token/contracts/ENS.sol\\\";\\n\\ncontract Proposal is EnsResolve {\\n    using ENSNamehash for bytes;\\n\\n    address immutable newRelayerRegistry;\\n    address constant relayerRegistryProxyAddr = 0x58E8dCC13BE9780fC42E8723D8EaD4CF46943dF2;\\n\\n    constructor(address _newRelayerRegistry) public {\\n        newRelayerRegistry = _newRelayerRegistry;\\n    }\\n\\n    function executeProposal() public {\\n        IRelayerRegistryProxy relayerRegistryProxy = IRelayerRegistryProxy(relayerRegistryProxyAddr);\\n        relayerRegistryProxy.upgradeTo(newRelayerRegistry);\\n\\n        string[5] memory cheatingRelayers = [\\n            \\\"available-reliable-relayer.eth\\\",\\n            \\\"0xtornadocash.eth\\\",\\n            \\\"0xtorn365.eth\\\",\\n            \\\"tornrelayers.eth\\\",\\n            \\\"moon-relayer.eth\\\"\\n        ];\\n        for (uint i = 0; i < cheatingRelayers.length; i++) {\\n            address cheatingRelayer = resolve(bytes(cheatingRelayers[i]).namehash());\\n            IRelayerRegistry(relayerRegistryProxyAddr).unregisterRelayer(cheatingRelayer);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"torn-token/contracts/ENS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\ninterface ENS {\\n  function resolver(bytes32 node) external view returns (Resolver);\\n}\\n\\ninterface Resolver {\\n  function addr(bytes32 node) external view returns (address);\\n}\\n\\ncontract EnsResolve {\\n  function resolve(bytes32 node) public view virtual returns (address) {\\n    ENS Registry = ENS(\\n      getChainId() == 1 ? 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e : 0x8595bFb0D940DfEDC98943FA8a907091203f25EE\\n    );\\n    return Registry.resolver(node).addr(node);\\n  }\\n\\n  function bulkResolve(bytes32[] memory domains) public view returns (address[] memory result) {\\n    result = new address[](domains.length);\\n    for (uint256 i = 0; i < domains.length; i++) {\\n      result[i] = resolve(domains[i]);\\n    }\\n  }\\n\\n  function getChainId() internal pure returns (uint256) {\\n    uint256 chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    return chainId;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRelayerRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"domains\",\"type\":\"bytes32[]\"}],\"name\":\"bulkResolve\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"result\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Proposal", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a3b821a2c6c9a52533178a1f2b9ff4aedba880e6", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}