{"SourceCode": " // SPDX-License-Identifier: MIT\r\npragma solidity =0.8.24;\r\n\r\n/// @title Used to store exchange data in a transaction\r\n/// @dev Always set and read data in the same tx, and keep in mind it can be accessed by anyone\r\ncontract BytesTransientStorage {\r\n    /*\r\n        Example:\r\n        0x1cff79cd000004e4b26a5e2e6dad30c5d95f5ce78a8310f04c200000000009d4e4b26a5e2e6dad30c5d95f5ce78a8310f04c200000000002e6dad30c5d95f5ce78a8310f04c23030\r\n        This data has length of 72\r\n        Slot 0 will be 0x0000000000000000000000000000000000000000000000000000000000000048 \r\n        Slot 1 will be 0x1cff79cd000004e4b26a5e2e6dad30c5d95f5ce78a8310f04c200000000009d4 _data[0:32]\r\n        Slot 2 will be 0xe4b26a5e2e6dad30c5d95f5ce78a8310f04c200000000002e6dad30c5d95f5ce _data[32:64]\r\n        lastPart will be 0xc5d95f5ce78a8310f04c200000000002e6dad30c5d95f5ce78a8310f04c23030 _data[40:72] will be shifted to the left 24*8 times\r\n        Slot 3 will be 0x78a8310f04c23030000000000000000000000000000000000000000000000000\r\n    */\r\n    function setBytesTransiently(bytes calldata _data) public {\r\n        require(_data.length >= 32);\r\n        // write length of _data to first slot\r\n        assembly {\r\n            tstore(0, _data.length)\r\n        }\r\n        // calculate how many slots at full size are we going to use\r\n        uint256 chunks = _data.length / 32;\r\n        uint256 i = 1;\r\n        // write _data split into bytes32 from slot 1 to slot 1+chunks\r\n        for (i; i <= chunks; ++i) {\r\n            bytes32 chunk = bytes32(_data[32 * (i-1) : 32 * i]); // chunks are bytes32: _data[0:32] -> _data[32:64] -> etc\r\n            assembly {\r\n                tstore(i, chunk)\r\n            }\r\n        }\r\n        // if there's any leftover write it in the next slot by writing last 32 bytes and then shifting left to delete what's already stored\r\n        uint256 leftover = _data.length % 32;\r\n        if (leftover > 0) {\r\n            bytes32 lastPart = bytes32(_data[_data.length - 32 : _data.length]);\r\n            lastPart = lastPart << ((32 - leftover) * 8);\r\n            assembly {\r\n                tstore(i, lastPart)\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBytesTransiently() public view returns (bytes memory result){\r\n        uint256 dataLength;\r\n        // fetch data length from first slot\r\n        assembly{\r\n            dataLength := tload(0)\r\n        }\r\n        // find out how many full size chunks there are\r\n        uint256 chunks = dataLength / 32;\r\n        uint256 i = 1;\r\n        // concat each full size chunk to the result\r\n        for (i; i <= chunks; ++i) {\r\n            bytes32 chunk;\r\n            assembly {\r\n                chunk := tload(i)\r\n            }\r\n            result = bytes.concat(result, chunk);\r\n        }\r\n        uint256 leftover = dataLength % 32;\r\n        // create a bytes consisting only of the leftover information\r\n        if (leftover > 0) {\r\n            bytes32 lastChunk;\r\n            assembly {\r\n                lastChunk := tload(i)\r\n            }\r\n            bytes memory cutChunk = new bytes(leftover);\r\n            for (uint256 j = 0; j < leftover; j++) {\r\n                cutChunk[j] = bytes1(bytes32(lastChunk << (j * 8))); // Shift the bytes32 by 8 bits each time\r\n            }\r\n            \r\n            result = bytes.concat(result, cutChunk);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"getBytesTransiently\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"setBytesTransiently\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BytesTransientStorage", "CompilerVersion": "v0.8.24+commit.e11b9ed9", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "cancun", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}