{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IBasePolygonZkEVMGlobalExitRoot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.20;\\n\\ninterface IBasePolygonZkEVMGlobalExitRoot {\\n    /**\\n     * @dev Thrown when the caller is not the allowed contracts\\n     */\\n    error OnlyAllowedContracts();\\n\\n    function updateExitRoot(bytes32 newRollupExitRoot) external;\\n\\n    function globalExitRootMap(\\n        bytes32 globalExitRootNum\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPolygonZkEVMGlobalExitRoot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.20;\\nimport \\\"./IBasePolygonZkEVMGlobalExitRoot.sol\\\";\\n\\ninterface IPolygonZkEVMGlobalExitRoot is IBasePolygonZkEVMGlobalExitRoot {\\n    function getLastGlobalExitRoot() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GlobalExitRootLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.20;\\n\\n/**\\n * @dev A library that provides the necessary calculations to calculate the global exit root\\n */\\nlibrary GlobalExitRootLib {\\n    function calculateGlobalExitRoot(\\n        bytes32 mainnetExitRoot,\\n        bytes32 rollupExitRoot\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(mainnetExitRoot, rollupExitRoot));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PolygonZkEVMGlobalExitRoot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"./interfaces/IPolygonZkEVMGlobalExitRoot.sol\\\";\\nimport \\\"./lib/GlobalExitRootLib.sol\\\";\\n\\n/**\\n * Contract responsible for managing the exit roots across multiple networks\\n */\\ncontract PolygonZkEVMGlobalExitRoot is IPolygonZkEVMGlobalExitRoot {\\n    // PolygonZkEVMBridge address\\n    address public immutable bridgeAddress;\\n\\n    // Rollup contract address\\n    address public immutable rollupAddress;\\n\\n    // Rollup exit root, this will be updated every time a batch is verified\\n    bytes32 public lastRollupExitRoot;\\n\\n    // Mainnet exit root, this will be updated every time a deposit is made in mainnet\\n    bytes32 public lastMainnetExitRoot;\\n\\n    // Store every global exit root: Root --> timestamp\\n    mapping(bytes32 => uint256) public globalExitRootMap;\\n\\n    /**\\n     * @dev Emitted when the global exit root is updated\\n     */\\n    event UpdateGlobalExitRoot(\\n        bytes32 indexed mainnetExitRoot,\\n        bytes32 indexed rollupExitRoot\\n    );\\n\\n    /**\\n     * @param _rollupAddress Rollup contract address\\n     * @param _bridgeAddress PolygonZkEVMBridge contract address\\n     */\\n    constructor(address _rollupAddress, address _bridgeAddress) {\\n        rollupAddress = _rollupAddress;\\n        bridgeAddress = _bridgeAddress;\\n    }\\n\\n    /**\\n     * @notice Update the exit root of one of the networks and the global exit root\\n     * @param newRoot new exit tree root\\n     */\\n    function updateExitRoot(bytes32 newRoot) external {\\n        // Store storage variables into temporal variables since will be used multiple times\\n        bytes32 cacheLastRollupExitRoot = lastRollupExitRoot;\\n        bytes32 cacheLastMainnetExitRoot = lastMainnetExitRoot;\\n\\n        if (msg.sender == bridgeAddress) {\\n            lastMainnetExitRoot = newRoot;\\n            cacheLastMainnetExitRoot = newRoot;\\n        } else if (msg.sender == rollupAddress) {\\n            lastRollupExitRoot = newRoot;\\n            cacheLastRollupExitRoot = newRoot;\\n        } else {\\n            revert OnlyAllowedContracts();\\n        }\\n\\n        bytes32 newGlobalExitRoot = GlobalExitRootLib.calculateGlobalExitRoot(\\n            cacheLastMainnetExitRoot,\\n            cacheLastRollupExitRoot\\n        );\\n\\n        // If it already exists, do not modify the timestamp\\n        if (globalExitRootMap[newGlobalExitRoot] == 0) {\\n            globalExitRootMap[newGlobalExitRoot] = block.timestamp;\\n            emit UpdateGlobalExitRoot(\\n                cacheLastMainnetExitRoot,\\n                cacheLastRollupExitRoot\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Return last global exit root\\n     */\\n    function getLastGlobalExitRoot() public view returns (bytes32) {\\n        return\\n            GlobalExitRootLib.calculateGlobalExitRoot(\\n                lastMainnetExitRoot,\\n                lastRollupExitRoot\\n            );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rollupAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bridgeAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OnlyAllowedContracts\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"mainnetExitRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"rollupExitRoot\",\"type\":\"bytes32\"}],\"name\":\"UpdateGlobalExitRoot\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bridgeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastGlobalExitRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"globalExitRootMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastMainnetExitRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRollupExitRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"}],\"name\":\"updateExitRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PolygonZkEVMGlobalExitRoot", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000001cbc08bf0d48b18f9f97796c61352b192d1850a50000000000000000000000009cb4706e20a18e59a48ffa7616d700a3891e1861", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}