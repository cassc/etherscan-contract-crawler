{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/nft/ZoraCreator1155Impl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ERC1155Upgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/ERC1155Upgradeable.sol\\\";\\nimport {ReentrancyGuardUpgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {UUPSUpgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport {IERC1155MetadataURIUpgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport {IERC165Upgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC165Upgradeable.sol\\\";\\nimport {IProtocolRewards} from \\\"@zoralabs/protocol-rewards/dist/contracts/interfaces/IProtocolRewards.sol\\\";\\nimport {ERC1155Rewards} from \\\"@zoralabs/protocol-rewards/dist/contracts/abstract/ERC1155/ERC1155Rewards.sol\\\";\\nimport {ERC1155RewardsStorageV1} from \\\"@zoralabs/protocol-rewards/dist/contracts/abstract/ERC1155/ERC1155RewardsStorageV1.sol\\\";\\nimport {IZoraCreator1155} from \\\"../interfaces/IZoraCreator1155.sol\\\";\\nimport {IZoraCreator1155Initializer} from \\\"../interfaces/IZoraCreator1155Initializer.sol\\\";\\nimport {ReentrancyGuardUpgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {UUPSUpgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport {MathUpgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol\\\";\\n\\nimport {ContractVersionBase} from \\\"../version/ContractVersionBase.sol\\\";\\nimport {CreatorPermissionControl} from \\\"../permissions/CreatorPermissionControl.sol\\\";\\nimport {CreatorRendererControl} from \\\"../renderer/CreatorRendererControl.sol\\\";\\nimport {CreatorRoyaltiesControl} from \\\"../royalties/CreatorRoyaltiesControl.sol\\\";\\nimport {ICreatorCommands} from \\\"../interfaces/ICreatorCommands.sol\\\";\\nimport {IMinter1155} from \\\"../interfaces/IMinter1155.sol\\\";\\nimport {IRenderer1155} from \\\"../interfaces/IRenderer1155.sol\\\";\\nimport {ITransferHookReceiver} from \\\"../interfaces/ITransferHookReceiver.sol\\\";\\nimport {IFactoryManagedUpgradeGate} from \\\"../interfaces/IFactoryManagedUpgradeGate.sol\\\";\\nimport {IZoraCreator1155} from \\\"../interfaces/IZoraCreator1155.sol\\\";\\nimport {LegacyNamingControl} from \\\"../legacy-naming/LegacyNamingControl.sol\\\";\\nimport {MintFeeManager} from \\\"../fee/MintFeeManager.sol\\\";\\nimport {PublicMulticall} from \\\"../utils/PublicMulticall.sol\\\";\\nimport {SharedBaseConstants} from \\\"../shared/SharedBaseConstants.sol\\\";\\nimport {TransferHelperUtils} from \\\"../utils/TransferHelperUtils.sol\\\";\\nimport {ZoraCreator1155StorageV1} from \\\"./ZoraCreator1155StorageV1.sol\\\";\\n\\n/// Imagine. Mint. Enjoy.\\n/// @title ZoraCreator1155Impl\\n/// @notice The core implementation contract for a creator's 1155 token\\n/// @author @iainnash / @tbtstl\\ncontract ZoraCreator1155Impl is\\n    IZoraCreator1155,\\n    IZoraCreator1155Initializer,\\n    ContractVersionBase,\\n    ReentrancyGuardUpgradeable,\\n    PublicMulticall,\\n    ERC1155Upgradeable,\\n    MintFeeManager,\\n    UUPSUpgradeable,\\n    CreatorRendererControl,\\n    LegacyNamingControl,\\n    ZoraCreator1155StorageV1,\\n    CreatorPermissionControl,\\n    CreatorRoyaltiesControl,\\n    ERC1155Rewards,\\n    ERC1155RewardsStorageV1\\n{\\n    /// @notice This user role allows for any action to be performed\\n    uint256 public constant PERMISSION_BIT_ADMIN = 2 ** 1;\\n    /// @notice This user role allows for only mint actions to be performed\\n    uint256 public constant PERMISSION_BIT_MINTER = 2 ** 2;\\n\\n    /// @notice This user role allows for only managing sales configurations\\n    uint256 public constant PERMISSION_BIT_SALES = 2 ** 3;\\n    /// @notice This user role allows for only managing metadata configuration\\n    uint256 public constant PERMISSION_BIT_METADATA = 2 ** 4;\\n    /// @notice This user role allows for only withdrawing funds and setting funds withdraw address\\n    uint256 public constant PERMISSION_BIT_FUNDS_MANAGER = 2 ** 5;\\n    /// @notice Factory contract\\n    IFactoryManagedUpgradeGate internal immutable factory;\\n\\n    constructor(\\n        uint256 _mintFeeAmount,\\n        address _mintFeeRecipient,\\n        address _factory,\\n        address _protocolRewards\\n    ) MintFeeManager(_mintFeeAmount, _mintFeeRecipient) ERC1155Rewards(_protocolRewards, _mintFeeRecipient) initializer {\\n        factory = IFactoryManagedUpgradeGate(_factory);\\n    }\\n\\n    /// @notice Initializes the contract\\n    /// @param contractName the legacy on-chain contract name\\n    /// @param newContractURI The contract URI\\n    /// @param defaultRoyaltyConfiguration The default royalty configuration\\n    /// @param defaultAdmin The default admin to manage the token\\n    /// @param setupActions The setup actions to run, if any\\n    function initialize(\\n        string memory contractName,\\n        string memory newContractURI,\\n        RoyaltyConfiguration memory defaultRoyaltyConfiguration,\\n        address payable defaultAdmin,\\n        bytes[] calldata setupActions\\n    ) external nonReentrant initializer {\\n        // We are not initalizing the OZ 1155 implementation\\n        // to save contract storage space and runtime\\n        // since the only thing affected here is the uri.\\n        // __ERC1155_init(\\\"\\\");\\n\\n        // Setup uups\\n        __UUPSUpgradeable_init();\\n\\n        // Setup re-entracy guard\\n        __ReentrancyGuard_init();\\n\\n        // Setup contract-default token ID\\n        _setupDefaultToken(defaultAdmin, newContractURI, defaultRoyaltyConfiguration);\\n\\n        // Set owner to default admin\\n        _setOwner(defaultAdmin);\\n\\n        _setFundsRecipient(defaultAdmin);\\n\\n        _setName(contractName);\\n\\n        // Run Setup actions\\n        if (setupActions.length > 0) {\\n            // Temporarily make sender admin\\n            _addPermission(CONTRACT_BASE_ID, msg.sender, PERMISSION_BIT_ADMIN);\\n\\n            // Make calls\\n            multicall(setupActions);\\n\\n            // Remove admin\\n            _removePermission(CONTRACT_BASE_ID, msg.sender, PERMISSION_BIT_ADMIN);\\n        }\\n    }\\n\\n    /// @notice sets up the global configuration for the 1155 contract\\n    /// @param newContractURI The contract URI\\n    /// @param defaultRoyaltyConfiguration The default royalty configuration\\n    function _setupDefaultToken(address defaultAdmin, string memory newContractURI, RoyaltyConfiguration memory defaultRoyaltyConfiguration) internal {\\n        // Add admin permission to default admin to manage contract\\n        _addPermission(CONTRACT_BASE_ID, defaultAdmin, PERMISSION_BIT_ADMIN);\\n\\n        // Mint token ID 0 / don't allow any user mints\\n        _setupNewToken(newContractURI, 0);\\n\\n        // Update default royalties\\n        _updateRoyalties(CONTRACT_BASE_ID, defaultRoyaltyConfiguration);\\n    }\\n\\n    /// @notice Updates the royalty configuration for a token\\n    /// @param tokenId The token ID to update\\n    /// @param newConfiguration The new royalty configuration\\n    function updateRoyaltiesForToken(\\n        uint256 tokenId,\\n        RoyaltyConfiguration memory newConfiguration\\n    ) external onlyAdminOrRole(tokenId, PERMISSION_BIT_FUNDS_MANAGER) {\\n        _updateRoyalties(tokenId, newConfiguration);\\n    }\\n\\n    /// @notice remove this function from openzeppelin impl\\n    /// @dev This makes this internal function a no-op\\n    function _setURI(string memory newuri) internal virtual override {}\\n\\n    /// @notice This gets the next token in line to be minted when minting linearly (default behavior) and updates the counter\\n    function _getAndUpdateNextTokenId() internal returns (uint256) {\\n        unchecked {\\n            return nextTokenId++;\\n        }\\n    }\\n\\n    /// @notice Ensure that the next token ID is correct\\n    /// @dev This reverts if the invariant doesn't match. This is used for multicall token id assumptions\\n    /// @param lastTokenId The last token ID\\n    function assumeLastTokenIdMatches(uint256 lastTokenId) external view {\\n        unchecked {\\n            if (nextTokenId - 1 != lastTokenId) {\\n                revert TokenIdMismatch(lastTokenId, nextTokenId - 1);\\n            }\\n        }\\n    }\\n\\n    /// @notice Checks if a user either has a role for a token or if they are the admin\\n    /// @dev This is an internal function that is called by the external getter and internal functions\\n    /// @param user The user to check\\n    /// @param tokenId The token ID to check\\n    /// @param role The role to check\\n    /// @return true or false if the permission exists for the user given the token id\\n    function _isAdminOrRole(address user, uint256 tokenId, uint256 role) internal view returns (bool) {\\n        return _hasAnyPermission(tokenId, user, PERMISSION_BIT_ADMIN | role);\\n    }\\n\\n    /// @notice Checks if a user either has a role for a token or if they are the admin\\n    /// @param user The user to check\\n    /// @param tokenId The token ID to check\\n    /// @param role The role to check\\n    /// @return true or false if the permission exists for the user given the token id\\n    function isAdminOrRole(address user, uint256 tokenId, uint256 role) external view returns (bool) {\\n        return _isAdminOrRole(user, tokenId, role);\\n    }\\n\\n    /// @notice Checks if the user is an admin for the given tokenId\\n    /// @dev This function reverts if the permission does not exist for the given user and tokenId\\n    /// @param user user to check\\n    /// @param tokenId tokenId to check\\n    /// @param role role to check for admin\\n    function _requireAdminOrRole(address user, uint256 tokenId, uint256 role) internal view {\\n        if (!(_hasAnyPermission(tokenId, user, PERMISSION_BIT_ADMIN | role) || _hasAnyPermission(CONTRACT_BASE_ID, user, PERMISSION_BIT_ADMIN | role))) {\\n            revert UserMissingRoleForToken(user, tokenId, role);\\n        }\\n    }\\n\\n    /// @notice Checks if the user is an admin\\n    /// @dev This reverts if the user is not an admin for the given token id or contract\\n    /// @param user user to check\\n    /// @param tokenId tokenId to check\\n    function _requireAdmin(address user, uint256 tokenId) internal view {\\n        if (!(_hasAnyPermission(tokenId, user, PERMISSION_BIT_ADMIN) || _hasAnyPermission(CONTRACT_BASE_ID, user, PERMISSION_BIT_ADMIN))) {\\n            revert UserMissingRoleForToken(user, tokenId, PERMISSION_BIT_ADMIN);\\n        }\\n    }\\n\\n    /// @notice Modifier checking if the user is an admin or has a role\\n    /// @dev This reverts if the msg.sender is not an admin for the given token id or contract\\n    /// @param tokenId tokenId to check\\n    /// @param role role to check\\n    modifier onlyAdminOrRole(uint256 tokenId, uint256 role) {\\n        _requireAdminOrRole(msg.sender, tokenId, role);\\n        _;\\n    }\\n\\n    /// @notice Modifier checking if the user is an admin\\n    /// @dev This reverts if the msg.sender is not an admin for the given token id or contract\\n    /// @param tokenId tokenId to check\\n    modifier onlyAdmin(uint256 tokenId) {\\n        _requireAdmin(msg.sender, tokenId);\\n        _;\\n    }\\n\\n    /// @notice Modifier checking if the requested quantity of tokens can be minted for the tokenId\\n    /// @dev This reverts if the number that can be minted is exceeded\\n    /// @param tokenId token id to check available allowed quantity\\n    /// @param quantity requested to be minted\\n    modifier canMintQuantity(uint256 tokenId, uint256 quantity) {\\n        _requireCanMintQuantity(tokenId, quantity);\\n        _;\\n    }\\n\\n    /// @notice Only from approved address for burn\\n    /// @param from address that the tokens will be burned from, validate that this is msg.sender or that msg.sender is approved\\n    modifier onlyFromApprovedForBurn(address from) {\\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender)) {\\n            revert Burn_NotOwnerOrApproved(msg.sender, from);\\n        }\\n\\n        _;\\n    }\\n\\n    /// @notice Checks if a user can mint a quantity of a token\\n    /// @dev Reverts if the mint exceeds the allowed quantity (or if the token does not exist)\\n    /// @param tokenId The token ID to check\\n    /// @param quantity The quantity of tokens to mint to check\\n    function _requireCanMintQuantity(uint256 tokenId, uint256 quantity) internal view {\\n        TokenData storage tokenInformation = tokens[tokenId];\\n        if (tokenInformation.totalMinted + quantity > tokenInformation.maxSupply) {\\n            revert CannotMintMoreTokens(tokenId, quantity, tokenInformation.totalMinted, tokenInformation.maxSupply);\\n        }\\n    }\\n\\n    /// @notice Set up a new token\\n    /// @param newURI The URI for the token\\n    /// @param maxSupply The maximum supply of the token\\n    function setupNewToken(\\n        string calldata newURI,\\n        uint256 maxSupply\\n    ) public onlyAdminOrRole(CONTRACT_BASE_ID, PERMISSION_BIT_MINTER) nonReentrant returns (uint256) {\\n        uint256 tokenId = _setupNewTokenAndPermission(newURI, maxSupply, msg.sender, PERMISSION_BIT_ADMIN);\\n\\n        return tokenId;\\n    }\\n\\n    /// @notice Set up a new token with a create referral\\n    /// @param newURI The URI for the token\\n    /// @param maxSupply The maximum supply of the token\\n    /// @param createReferral The address of the create referral\\n    function setupNewTokenWithCreateReferral(\\n        string calldata newURI,\\n        uint256 maxSupply,\\n        address createReferral\\n    ) public onlyAdminOrRole(CONTRACT_BASE_ID, PERMISSION_BIT_MINTER) nonReentrant returns (uint256) {\\n        uint256 tokenId = _setupNewTokenAndPermission(newURI, maxSupply, msg.sender, PERMISSION_BIT_ADMIN);\\n\\n        _setCreateReferral(tokenId, createReferral);\\n\\n        return tokenId;\\n    }\\n\\n    function _setupNewTokenAndPermission(string calldata newURI, uint256 maxSupply, address user, uint256 permission) internal returns (uint256) {\\n        uint256 tokenId = _setupNewToken(newURI, maxSupply);\\n\\n        _addPermission(tokenId, user, permission);\\n\\n        if (bytes(newURI).length > 0) {\\n            emit URI(newURI, tokenId);\\n        }\\n\\n        emit SetupNewToken(tokenId, user, newURI, maxSupply);\\n\\n        return tokenId;\\n    }\\n\\n    /// @notice Update the token URI for a token\\n    /// @param tokenId The token ID to update the URI for\\n    /// @param _newURI The new URI\\n    function updateTokenURI(uint256 tokenId, string memory _newURI) external onlyAdminOrRole(tokenId, PERMISSION_BIT_METADATA) {\\n        if (tokenId == CONTRACT_BASE_ID) {\\n            revert();\\n        }\\n        emit URI(_newURI, tokenId);\\n        tokens[tokenId].uri = _newURI;\\n    }\\n\\n    /// @notice Update the global contract metadata\\n    /// @param _newURI The new contract URI\\n    /// @param _newName The new contract name\\n    function updateContractMetadata(string memory _newURI, string memory _newName) external onlyAdminOrRole(0, PERMISSION_BIT_METADATA) {\\n        tokens[CONTRACT_BASE_ID].uri = _newURI;\\n        _setName(_newName);\\n        emit ContractMetadataUpdated(msg.sender, _newURI, _newName);\\n    }\\n\\n    function _setupNewToken(string memory newURI, uint256 maxSupply) internal returns (uint256 tokenId) {\\n        tokenId = _getAndUpdateNextTokenId();\\n        TokenData memory tokenData = TokenData({uri: newURI, maxSupply: maxSupply, totalMinted: 0});\\n        tokens[tokenId] = tokenData;\\n        emit UpdatedToken(msg.sender, tokenId, tokenData);\\n    }\\n\\n    /// @notice Add a role to a user for a token\\n    /// @param tokenId The token ID to add the role to\\n    /// @param user The user to add the role to\\n    /// @param permissionBits The permission bit to add\\n    function addPermission(uint256 tokenId, address user, uint256 permissionBits) external onlyAdmin(tokenId) {\\n        _addPermission(tokenId, user, permissionBits);\\n    }\\n\\n    /// @notice Remove a role from a user for a token\\n    /// @param tokenId The token ID to remove the role from\\n    /// @param user The user to remove the role from\\n    /// @param permissionBits The permission bit to remove\\n    function removePermission(uint256 tokenId, address user, uint256 permissionBits) external onlyAdmin(tokenId) {\\n        _removePermission(tokenId, user, permissionBits);\\n\\n        // Clear owner field\\n        if (tokenId == CONTRACT_BASE_ID && user == config.owner && !_hasAnyPermission(CONTRACT_BASE_ID, user, PERMISSION_BIT_ADMIN)) {\\n            _setOwner(address(0));\\n        }\\n    }\\n\\n    /// @notice Set the owner of the contract\\n    /// @param newOwner The new owner of the contract\\n    function setOwner(address newOwner) external onlyAdmin(CONTRACT_BASE_ID) {\\n        if (!_hasAnyPermission(CONTRACT_BASE_ID, newOwner, PERMISSION_BIT_ADMIN)) {\\n            revert NewOwnerNeedsToBeAdmin();\\n        }\\n\\n        // Update owner field\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @notice Getter for the owner singleton of the contract for outside interfaces\\n    /// @return the owner of the contract singleton for compat.\\n    function owner() external view returns (address) {\\n        return config.owner;\\n    }\\n\\n    /// @notice AdminMint that only checks if the requested quantity can be minted and has a re-entrant guard\\n    /// @param recipient recipient for admin minted tokens\\n    /// @param tokenId token id to mint\\n    /// @param quantity quantity to mint\\n    /// @param data callback data as specified by the 1155 spec\\n    function _adminMint(address recipient, uint256 tokenId, uint256 quantity, bytes memory data) internal {\\n        _mint(recipient, tokenId, quantity, data);\\n    }\\n\\n    /// @notice Mint a token to a user as the admin or minter\\n    /// @param recipient The recipient of the token\\n    /// @param tokenId The token ID to mint\\n    /// @param quantity The quantity of tokens to mint\\n    /// @param data The data to pass to the onERC1155Received function\\n    function adminMint(\\n        address recipient,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        bytes memory data\\n    ) external nonReentrant onlyAdminOrRole(tokenId, PERMISSION_BIT_MINTER) {\\n        // Call internal admin mint\\n        _adminMint(recipient, tokenId, quantity, data);\\n    }\\n\\n    /// @notice Batch mint tokens to a user as the admin or minter\\n    /// @param recipient The recipient of the tokens\\n    /// @param tokenIds The token IDs to mint\\n    /// @param quantities The quantities of tokens to mint\\n    /// @param data The data to pass to the onERC1155BatchReceived function\\n    function adminMintBatch(address recipient, uint256[] memory tokenIds, uint256[] memory quantities, bytes memory data) external nonReentrant {\\n        bool isGlobalAdminOrMinter = _isAdminOrRole(msg.sender, CONTRACT_BASE_ID, PERMISSION_BIT_MINTER);\\n\\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\\n            if (!isGlobalAdminOrMinter) {\\n                _requireAdminOrRole(msg.sender, tokenIds[i], PERMISSION_BIT_MINTER);\\n            }\\n        }\\n        _mintBatch(recipient, tokenIds, quantities, data);\\n    }\\n\\n    /// @notice Mint tokens given a minter contract and minter arguments\\n    /// @param minter The minter contract to use\\n    /// @param tokenId The token ID to mint\\n    /// @param quantity The quantity of tokens to mint\\n    /// @param minterArguments The arguments to pass to the minter\\n    function mint(IMinter1155 minter, uint256 tokenId, uint256 quantity, bytes calldata minterArguments) external payable nonReentrant {\\n        // Require admin from the minter to mint\\n        _requireAdminOrRole(address(minter), tokenId, PERMISSION_BIT_MINTER);\\n\\n        // Get value sent and handle mint fee\\n        uint256 ethValueSent = _handleFeeAndGetValueSent(quantity);\\n\\n        // Execute commands returned from minter\\n        _executeCommands(minter.requestMint(msg.sender, tokenId, quantity, ethValueSent, minterArguments).commands, ethValueSent, tokenId);\\n\\n        emit Purchased(msg.sender, address(minter), tokenId, quantity, msg.value);\\n    }\\n\\n    /// @notice Get the creator reward recipient address\\n    /// @dev The creator is not enforced to set a funds recipient address, so in that case the reward would be claimable by creator's contract\\n    function getCreatorRewardRecipient() public view returns (address payable) {\\n        return config.fundsRecipient != address(0) ? config.fundsRecipient : payable(address(this));\\n    }\\n\\n    /// @notice Mint tokens and payout rewards given a minter contract, minter arguments, a finder, and a origin\\n    /// @param minter The minter contract to use\\n    /// @param tokenId The token ID to mint\\n    /// @param quantity The quantity of tokens to mint\\n    /// @param minterArguments The arguments to pass to the minter\\n    /// @param mintReferral The referrer of the mint\\n    function mintWithRewards(\\n        IMinter1155 minter,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        bytes calldata minterArguments,\\n        address mintReferral\\n    ) external payable nonReentrant {\\n        // Require admin from the minter to mint\\n        _requireAdminOrRole(address(minter), tokenId, PERMISSION_BIT_MINTER);\\n\\n        // Get value sent and handle mint rewards\\n        uint256 ethValueSent = _handleRewardsAndGetValueSent(msg.value, quantity, getCreatorRewardRecipient(), createReferrals[tokenId], mintReferral);\\n\\n        // Execute commands returned from minter\\n        _executeCommands(minter.requestMint(msg.sender, tokenId, quantity, ethValueSent, minterArguments).commands, ethValueSent, tokenId);\\n\\n        emit Purchased(msg.sender, address(minter), tokenId, quantity, msg.value);\\n    }\\n\\n    /// @notice Set a metadata renderer for a token\\n    /// @param tokenId The token ID to set the renderer for\\n    /// @param renderer The renderer to set\\n    function setTokenMetadataRenderer(uint256 tokenId, IRenderer1155 renderer) external nonReentrant onlyAdminOrRole(tokenId, PERMISSION_BIT_METADATA) {\\n        _setRenderer(tokenId, renderer);\\n\\n        if (tokenId == 0) {\\n            emit ContractRendererUpdated(renderer);\\n        } else {\\n            // We don't know the uri from the renderer but can emit a notification to the indexer here\\n            emit URI(\\\"\\\", tokenId);\\n        }\\n    }\\n\\n    /// Execute Minter Commands ///\\n\\n    /// @notice Internal functions to execute commands returned by the minter\\n    /// @param commands list of command structs\\n    /// @param ethValueSent the ethereum value sent in the mint transaction into the contract\\n    /// @param tokenId the token id the user requested to mint (0 if the token id is set by the minter itself across the whole contract)\\n    function _executeCommands(ICreatorCommands.Command[] memory commands, uint256 ethValueSent, uint256 tokenId) internal {\\n        for (uint256 i = 0; i < commands.length; ++i) {\\n            ICreatorCommands.CreatorActions method = commands[i].method;\\n            if (method == ICreatorCommands.CreatorActions.SEND_ETH) {\\n                (address recipient, uint256 amount) = abi.decode(commands[i].args, (address, uint256));\\n                if (ethValueSent > amount) {\\n                    revert Mint_InsolventSaleTransfer();\\n                }\\n                if (!TransferHelperUtils.safeSendETH(recipient, amount, TransferHelperUtils.FUNDS_SEND_NORMAL_GAS_LIMIT)) {\\n                    revert Mint_ValueTransferFail();\\n                }\\n            } else if (method == ICreatorCommands.CreatorActions.MINT) {\\n                (address recipient, uint256 mintTokenId, uint256 quantity) = abi.decode(commands[i].args, (address, uint256, uint256));\\n                if (tokenId != 0 && mintTokenId != tokenId) {\\n                    revert Mint_TokenIDMintNotAllowed();\\n                }\\n                _mint(recipient, tokenId, quantity, \\\"\\\");\\n            } else {\\n                // no-op\\n            }\\n        }\\n    }\\n\\n    /// @notice Token info getter\\n    /// @param tokenId token id to get info for\\n    /// @return TokenData struct returned\\n    function getTokenInfo(uint256 tokenId) external view returns (TokenData memory) {\\n        return tokens[tokenId];\\n    }\\n\\n    /// @notice Proxy setter for sale contracts (only callable by SALES permission or admin)\\n    /// @param tokenId The token ID to call the sale contract with\\n    /// @param salesConfig The sales config contract to call\\n    /// @param data The data to pass to the sales config contract\\n    function callSale(uint256 tokenId, IMinter1155 salesConfig, bytes memory data) external onlyAdminOrRole(tokenId, PERMISSION_BIT_SALES) {\\n        _requireAdminOrRole(address(salesConfig), tokenId, PERMISSION_BIT_MINTER);\\n        if (!salesConfig.supportsInterface(type(IMinter1155).interfaceId)) {\\n            revert Sale_CannotCallNonSalesContract(address(salesConfig));\\n        }\\n        (bool success, bytes memory why) = address(salesConfig).call(data);\\n        if (!success) {\\n            revert CallFailed(why);\\n        }\\n    }\\n\\n    /// @notice Proxy setter for renderer contracts (only callable by METADATA permission or admin)\\n    /// @param tokenId The token ID to call the renderer contract with\\n    /// @param data The data to pass to the renderer contract\\n    function callRenderer(uint256 tokenId, bytes memory data) external onlyAdminOrRole(tokenId, PERMISSION_BIT_METADATA) {\\n        // We assume any renderers set are checked for EIP165 signature during write stage.\\n        (bool success, bytes memory why) = address(getCustomRenderer(tokenId)).call(data);\\n        if (!success) {\\n            revert CallFailed(why);\\n        }\\n    }\\n\\n    /// @notice Returns true if the contract implements the interface defined by interfaceId\\n    /// @param interfaceId The interface to check for\\n    /// @return if the interfaceId is marked as supported\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual override(CreatorRoyaltiesControl, ERC1155Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return super.supportsInterface(interfaceId) || interfaceId == type(IZoraCreator1155).interfaceId || ERC1155Upgradeable.supportsInterface(interfaceId);\\n    }\\n\\n    function _handleSupplyRoyalty(uint256 tokenId, uint256 mintAmount, bytes memory data) internal returns (uint256 totalRoyaltyMints) {\\n        uint256 royaltyMintSchedule = royalties[tokenId].royaltyMintSchedule;\\n        if (royaltyMintSchedule == 0) {\\n            royaltyMintSchedule = royalties[CONTRACT_BASE_ID].royaltyMintSchedule;\\n        }\\n        if (royaltyMintSchedule == 0) {\\n            // If we still have no schedule, return 0 supply royalty.\\n            return 0;\\n        }\\n        uint256 maxSupply = tokens[tokenId].maxSupply;\\n        uint256 totalMinted = tokens[tokenId].totalMinted;\\n\\n        totalRoyaltyMints = (mintAmount + (totalMinted % royaltyMintSchedule)) / (royaltyMintSchedule - 1);\\n        totalRoyaltyMints = MathUpgradeable.min(totalRoyaltyMints, maxSupply - (mintAmount + totalMinted));\\n        if (totalRoyaltyMints > 0) {\\n            address royaltyRecipient = royalties[tokenId].royaltyRecipient;\\n            if (royaltyRecipient == address(0)) {\\n                royaltyRecipient = royalties[CONTRACT_BASE_ID].royaltyRecipient;\\n            }\\n            // If we have no recipient set, return 0 supply royalty.\\n            if (royaltyRecipient == address(0)) {\\n                return 0;\\n            }\\n            super._mint(royaltyRecipient, tokenId, totalRoyaltyMints, data);\\n        }\\n    }\\n\\n    /// Generic 1155 function overrides ///\\n\\n    /// @notice Mint function that 1) checks quantity and 2) handles supply royalty 3) keeps track of allowed tokens\\n    /// @param to to mint to\\n    /// @param id token id to mint\\n    /// @param amount of tokens to mint\\n    /// @param data as specified by 1155 standard\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual override {\\n        uint256 supplyRoyaltyMints = _handleSupplyRoyalty(id, amount, data);\\n        _requireCanMintQuantity(id, amount + supplyRoyaltyMints);\\n\\n        super._mint(to, id, amount, data);\\n        tokens[id].totalMinted += amount + supplyRoyaltyMints;\\n    }\\n\\n    /// @notice Mint batch function that 1) checks quantity and 2) handles supply royalty 3) keeps track of allowed tokens\\n    /// @param to to mint to\\n    /// @param ids token ids to mint\\n    /// @param amounts of tokens to mint\\n    /// @param data as specified by 1155 standard\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual override {\\n        super._mintBatch(to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 supplyRoyaltyMints = _handleSupplyRoyalty(ids[i], amounts[i], data);\\n            _requireCanMintQuantity(ids[i], amounts[i] + supplyRoyaltyMints);\\n            tokens[ids[i]].totalMinted += amounts[i] + supplyRoyaltyMints;\\n        }\\n    }\\n\\n    /// @notice Burns a batch of tokens\\n    /// @dev Only the current owner is allowed to burn\\n    /// @param from the user to burn from\\n    /// @param tokenIds The token ID to burn\\n    /// @param amounts The amount of tokens to burn\\n    function burnBatch(address from, uint256[] calldata tokenIds, uint256[] calldata amounts) external {\\n        if (from != msg.sender && !isApprovedForAll(from, msg.sender)) {\\n            revert Burn_NotOwnerOrApproved(msg.sender, from);\\n        }\\n\\n        _burnBatch(from, tokenIds, amounts);\\n    }\\n\\n    function setTransferHook(ITransferHookReceiver transferHook) external onlyAdmin(CONTRACT_BASE_ID) {\\n        if (address(transferHook) != address(0)) {\\n            if (!transferHook.supportsInterface(type(ITransferHookReceiver).interfaceId)) {\\n                revert Config_TransferHookNotSupported(address(transferHook));\\n            }\\n        }\\n\\n        config.transferHook = transferHook;\\n        emit ConfigUpdated(msg.sender, ConfigUpdate.TRANSFER_HOOK, config);\\n    }\\n\\n    /// @notice Hook before token transfer that checks for a transfer hook integration\\n    /// @param operator operator moving the tokens\\n    /// @param from from address\\n    /// @param to to address\\n    /// @param ids token ids to move\\n    /// @param amounts amounts of tokens\\n    /// @param data data of tokens\\n    function _beforeBatchTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal override {\\n        super._beforeBatchTokenTransfer(operator, from, to, ids, amounts, data);\\n        if (address(config.transferHook) != address(0)) {\\n            config.transferHook.onTokenTransferBatch({target: address(this), operator: operator, from: from, to: to, ids: ids, amounts: amounts, data: data});\\n        }\\n    }\\n\\n    /// @notice Returns the URI for the contract\\n    function contractURI() external view returns (string memory) {\\n        IRenderer1155 customRenderer = getCustomRenderer(CONTRACT_BASE_ID);\\n        if (address(customRenderer) != address(0)) {\\n            return customRenderer.contractURI();\\n        }\\n        return uri(0);\\n    }\\n\\n    /// @notice Returns the URI for a token\\n    /// @param tokenId The token ID to return the URI for\\n    function uri(uint256 tokenId) public view override(ERC1155Upgradeable, IERC1155MetadataURIUpgradeable) returns (string memory) {\\n        if (bytes(tokens[tokenId].uri).length > 0) {\\n            return tokens[tokenId].uri;\\n        }\\n        return _render(tokenId);\\n    }\\n\\n    /// @notice Internal setter for contract admin with no access checks\\n    /// @param newOwner new owner address\\n    function _setOwner(address newOwner) internal {\\n        address lastOwner = config.owner;\\n        config.owner = newOwner;\\n\\n        emit OwnershipTransferred(lastOwner, newOwner);\\n        emit ConfigUpdated(msg.sender, ConfigUpdate.OWNER, config);\\n    }\\n\\n    /// @notice Set funds recipient address\\n    /// @param fundsRecipient new funds recipient address\\n    function setFundsRecipient(address payable fundsRecipient) external onlyAdminOrRole(CONTRACT_BASE_ID, PERMISSION_BIT_FUNDS_MANAGER) {\\n        _setFundsRecipient(fundsRecipient);\\n    }\\n\\n    /// @notice Internal no-checks set funds recipient address\\n    /// @param fundsRecipient new funds recipient address\\n    function _setFundsRecipient(address payable fundsRecipient) internal {\\n        config.fundsRecipient = fundsRecipient;\\n        emit ConfigUpdated(msg.sender, ConfigUpdate.FUNDS_RECIPIENT, config);\\n    }\\n\\n    /// @notice Allows the create referral to update the address that can claim their rewards\\n    function updateCreateReferral(uint256 tokenId, address recipient) external {\\n        if (msg.sender != createReferrals[tokenId]) revert ONLY_CREATE_REFERRAL();\\n\\n        _setCreateReferral(tokenId, recipient);\\n    }\\n\\n    function _setCreateReferral(uint256 tokenId, address recipient) internal {\\n        createReferrals[tokenId] = recipient;\\n    }\\n\\n    /// @notice Withdraws all ETH from the contract to the funds recipient address\\n    function withdraw() public onlyAdminOrRole(CONTRACT_BASE_ID, PERMISSION_BIT_FUNDS_MANAGER) {\\n        uint256 contractValue = address(this).balance;\\n        if (!TransferHelperUtils.safeSendETH(config.fundsRecipient, contractValue, TransferHelperUtils.FUNDS_SEND_NORMAL_GAS_LIMIT)) {\\n            revert ETHWithdrawFailed(config.fundsRecipient, contractValue);\\n        }\\n    }\\n\\n    /// @notice Withdraws ETH from the Zora Rewards contract\\n    function withdrawRewards(address to, uint256 amount) public onlyAdminOrRole(CONTRACT_BASE_ID, PERMISSION_BIT_FUNDS_MANAGER) {\\n        bytes memory data = abi.encodeWithSelector(IProtocolRewards.withdraw.selector, to, amount);\\n\\n        (bool success, ) = address(protocolRewards).call(data);\\n\\n        if (!success) {\\n            revert ProtocolRewardsWithdrawFailed(msg.sender, to, amount);\\n        }\\n    }\\n\\n    ///                                                          ///\\n    ///                         MANAGER UPGRADE                  ///\\n    ///                                                          ///\\n\\n    /// @notice Ensures the caller is authorized to upgrade the contract\\n    /// @dev This function is called in `upgradeTo` & `upgradeToAndCall`\\n    /// @param _newImpl The new implementation address\\n    function _authorizeUpgrade(address _newImpl) internal view override onlyAdmin(CONTRACT_BASE_ID) {\\n        if (!factory.isRegisteredUpgradePath(_getImplementation(), _newImpl)) {\\n            revert();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/ERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Modifications from OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol):\\n// - Revert strings replaced with custom errors\\n// - Decoupled hooks \\n//   - `_beforeTokenTransfer` --> `_beforeTokenTransfer` & `_beforeBatchTokenTransfer`\\n//   - `_afterTokenTransfer` --> `_afterTokenTransfer` & `_afterBatchTokenTransfer`\\n// - Minor gas optimizations (eg. array length caching, unchecked loop iteration)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC1155Upgradeable.sol\\\";\\nimport \\\"./IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"./extensions/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\nerror ERC1155_ADDRESS_ZERO_IS_NOT_A_VALID_OWNER();\\nerror ERC1155_ACCOUNTS_AND_IDS_LENGTH_MISMATCH();\\nerror ERC1155_IDS_AND_AMOUNTS_LENGTH_MISMATCH();\\nerror ERC1155_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED();\\nerror ERC1155_TRANSFER_TO_ZERO_ADDRESS();\\nerror ERC1155_INSUFFICIENT_BALANCE_FOR_TRANSFER();\\nerror ERC1155_MINT_TO_ZERO_ADDRESS();\\nerror ERC1155_BURN_FROM_ZERO_ADDRESS();\\nerror ERC1155_BURN_AMOUNT_EXCEEDS_BALANCE();\\nerror ERC1155_SETTING_APPROVAL_FOR_SELF();\\nerror ERC1155_ERC1155RECEIVER_REJECTED_TOKENS();\\nerror ERC1155_TRANSFER_TO_NON_ERC1155RECEIVER_IMPLEMENTER();\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\\n    using AddressUpgradeable for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\\n        __ERC1155_init_unchained(uri_);\\n    }\\n\\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        if (account == address(0)) {\\n            revert ERC1155_ADDRESS_ZERO_IS_NOT_A_VALID_OWNER();\\n        }\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) public view virtual override returns (uint256[] memory batchBalances) {\\n        uint256 numAccounts = accounts.length;\\n\\n        if (numAccounts != ids.length) {\\n            revert ERC1155_ACCOUNTS_AND_IDS_LENGTH_MISMATCH();\\n        }\\n\\n        batchBalances = new uint256[](numAccounts);\\n\\n        unchecked {\\n            for (uint256 i; i < numAccounts; ++i) {\\n                batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        if (from != _msgSender() && !isApprovedForAll(from, _msgSender())) {\\n            revert ERC1155_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED();\\n        }\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        if (from != _msgSender() && !isApprovedForAll(from, _msgSender())) {\\n            revert ERC1155_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED();\\n        }\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        if (to == address(0)) {\\n            revert ERC1155_TRANSFER_TO_ZERO_ADDRESS();\\n        }\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, id, amount, data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        if (fromBalance < amount) {\\n            revert ERC1155_INSUFFICIENT_BALANCE_FOR_TRANSFER();\\n        }\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _afterTokenTransfer(operator, from, to, id, amount, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 numIds = ids.length;\\n\\n        if (numIds != amounts.length) {\\n            revert ERC1155_ACCOUNTS_AND_IDS_LENGTH_MISMATCH();\\n        }\\n        if (to == address(0)) {\\n            revert ERC1155_TRANSFER_TO_ZERO_ADDRESS();\\n        }\\n\\n        address operator = _msgSender();\\n\\n        _beforeBatchTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        uint256 id;\\n        uint256 amount;\\n        uint256 fromBalance;\\n\\n        for (uint256 i; i < numIds; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n            fromBalance = _balances[id][from];\\n\\n            if (fromBalance < amount) {\\n                revert ERC1155_INSUFFICIENT_BALANCE_FOR_TRANSFER();\\n            }\\n\\n            _balances[id][to] += amount;\\n\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n\\n                ++i;\\n            }\\n\\n\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _afterBatchTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        if (to == address(0)) {\\n            revert ERC1155_MINT_TO_ZERO_ADDRESS();\\n        }\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, id, amount, data);\\n\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _afterTokenTransfer(operator, address(0), to, id, amount, data);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        if (to == address(0)) {\\n            revert ERC1155_MINT_TO_ZERO_ADDRESS();\\n        }\\n\\n        uint256 numIds = ids.length;\\n\\n        if (numIds != amounts.length) {\\n            revert ERC1155_IDS_AND_AMOUNTS_LENGTH_MISMATCH();\\n        }\\n\\n        address operator = _msgSender();\\n\\n        _beforeBatchTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i; i < numIds; ) {\\n            _balances[ids[i]][to] += amounts[i];\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _afterBatchTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        if (from == address(0)) {\\n            revert ERC1155_BURN_FROM_ZERO_ADDRESS();\\n        }\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, address(0), id, amount, \\\"\\\");\\n\\n        uint256 fromBalance = _balances[id][from];\\n\\n        if (fromBalance < amount) {\\n            revert ERC1155_BURN_AMOUNT_EXCEEDS_BALANCE();\\n        }\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n\\n        _afterTokenTransfer(operator, from, address(0), id, amount, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        if (from == address(0)) {\\n            revert ERC1155_BURN_FROM_ZERO_ADDRESS();\\n        }\\n\\n        uint256 numIds = ids.length;\\n\\n        if (numIds != amounts.length) {\\n            revert ERC1155_IDS_AND_AMOUNTS_LENGTH_MISMATCH();\\n        }\\n\\n        address operator = _msgSender();\\n\\n        _beforeBatchTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        uint256 id;\\n        uint256 amount;\\n        uint256 fromBalance;\\n        for (uint256 i; i < numIds; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            fromBalance = _balances[id][from];\\n\\n            if (fromBalance < amount) {\\n                revert ERC1155_BURN_AMOUNT_EXCEEDS_BALANCE();\\n            }\\n\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n\\n        _afterBatchTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\\n        if (owner == operator) {\\n            revert ERC1155_SETTING_APPROVAL_FOR_SELF();\\n        }\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before a single token transfer.\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual { }\\n\\n\\n    /**\\n     * @dev Hook that is called before a batch token transfer.\\n     */\\n    function _beforeBatchTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a single token transfer.\\n     */\\n    function _afterTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after a batch token transfer.\\n     */\\n    function _afterBatchTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\\n                    revert ERC1155_ERC1155RECEIVER_REJECTED_TOKENS();\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert ERC1155_TRANSFER_TO_NON_ERC1155RECEIVER_IMPLEMENTER();\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\\n                    revert ERC1155_ERC1155RECEIVER_REJECTED_TOKENS();\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert ERC1155_TRANSFER_TO_NON_ERC1155RECEIVER_IMPLEMENTER();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[47] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\nerror FUNCTION_MUST_BE_CALLED_THROUGH_DELEGATECALL();\\nerror FUNCTION_MUST_BE_CALLED_THROUGH_ACTIVE_PROXY();\\nerror UUPS_UPGRADEABLE_MUST_NOT_BE_CALLED_THROUGH_DELEGATECALL();\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        if (address(this) == __self) {\\n            revert FUNCTION_MUST_BE_CALLED_THROUGH_DELEGATECALL();\\n        }\\n        if (_getImplementation() != __self) {\\n            revert FUNCTION_MUST_BE_CALLED_THROUGH_ACTIVE_PROXY();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        if (address(this) != __self) {\\n            revert UUPS_UPGRADEABLE_MUST_NOT_BE_CALLED_THROUGH_DELEGATECALL();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1155MetadataURIUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\\\";\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165Upgradeable.sol\\\";\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/protocol-rewards/dist/contracts/interfaces/IProtocolRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @title IProtocolRewards\\n/// @notice The interface for deposits & withdrawals of protocol rewards\\ninterface IProtocolRewards {\\n    event RewardsDeposit(\\n        address indexed creator,\\n        address indexed createReferral,\\n        address indexed mintReferral,\\n        address firstMinter,\\n        address zora,\\n        address from,\\n        uint256 creatorReward,\\n        uint256 createReferralReward,\\n        uint256 mintReferralReward,\\n        uint256 firstMinterReward,\\n        uint256 zoraReward\\n    );\\n    event Deposit(address indexed from, address indexed to, uint256 amount, string comment);\\n    event Withdraw(address indexed from, address indexed to, uint256 amount);\\n\\n    error ADDRESS_ZERO();\\n    error ARRAY_LENGTH_MISMATCH();\\n    error INVALID_DEPOSIT();\\n    error INVALID_SIGNATURE();\\n    error INVALID_WITHDRAW();\\n    error SIGNATURE_DEADLINE_EXPIRED();\\n    error TRANSFER_FAILED();\\n\\n    function deposit(address to, string calldata comment) external payable;\\n\\n    function depositBatch(address[] calldata recipients, uint256[] calldata amounts, string calldata comment) external payable;\\n\\n    function depositRewards(\\n        address creator,\\n        uint256 creatorReward,\\n        address createReferral,\\n        uint256 createReferralReward,\\n        address mintReferral,\\n        uint256 mintReferralReward,\\n        address firstMinter,\\n        uint256 firstMinterReward,\\n        address zora,\\n        uint256 zoraReward\\n    ) external payable;\\n\\n    function withdraw(address to, uint256 amount) external;\\n\\n    function withdrawWithSig(address from, address to, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/protocol-rewards/dist/contracts/abstract/ERC1155/ERC1155Rewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {RewardSplits} from \\\"../RewardSplits.sol\\\";\\n\\n/// @notice The base logic for handling Zora ERC-1155 protocol rewards\\n/// @dev Used in https://github.com/ourzora/zora-1155-contracts/blob/main/src/nft/ZoraCreator1155Impl.sol\\nabstract contract ERC1155Rewards is RewardSplits {\\n    constructor(address _protocolRewards, address _zoraRewardRecipient) payable RewardSplits(_protocolRewards, _zoraRewardRecipient) {}\\n\\n    function _handleRewardsAndGetValueSent(\\n        uint256 msgValue,\\n        uint256 numTokens,\\n        address creator,\\n        address createReferral,\\n        address mintReferral\\n    ) internal returns (uint256) {\\n        uint256 totalReward = computeTotalReward(numTokens);\\n\\n        if (msgValue < totalReward) {\\n            revert INVALID_ETH_AMOUNT();\\n        } else if (msgValue == totalReward) {\\n            _depositFreeMintRewards(totalReward, numTokens, creator, createReferral, mintReferral);\\n\\n            return 0;\\n        } else {\\n            _depositPaidMintRewards(totalReward, numTokens, creator, createReferral, mintReferral);\\n\\n            unchecked {\\n                return msgValue - totalReward;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/protocol-rewards/dist/contracts/abstract/ERC1155/ERC1155RewardsStorageV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ncontract ERC1155RewardsStorageV1 {\\n    mapping(uint256 => address) public createReferrals;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IZoraCreator1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IERC165Upgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC165Upgradeable.sol\\\";\\nimport {IERC1155MetadataURIUpgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC1155MetadataURIUpgradeable.sol\\\";\\nimport {IZoraCreator1155TypesV1} from \\\"../nft/IZoraCreator1155TypesV1.sol\\\";\\nimport {IRenderer1155} from \\\"../interfaces/IRenderer1155.sol\\\";\\nimport {IMinter1155} from \\\"../interfaces/IMinter1155.sol\\\";\\nimport {IOwnable} from \\\"../interfaces/IOwnable.sol\\\";\\nimport {IVersionedContract} from \\\"./IVersionedContract.sol\\\";\\nimport {ICreatorRoyaltiesControl} from \\\"../interfaces/ICreatorRoyaltiesControl.sol\\\";\\n\\n/*\\n\\n\\n             \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591              \\n        \u2591\u2591\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591        \\n      \u2591\u2591\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591      \\n    \u2591\u2591\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \\n   \u2591\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591        \u2591\u2591\u2591\u2591\u2591\u2591\u2591    \\n  \u2591\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591        \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n  \u2591\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n  \u2591\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n  \u2591\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n   \u2591\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n    \u2591\u2591\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \\n    \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u2592\u2591\u2591    \\n      \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591      \\n          \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2591\u2591\u2591          \\n\\n               OURS TRULY,\\n\\n */\\n\\n/// @notice Main interface for the ZoraCreator1155 contract\\n/// @author @iainnash / @tbtstl\\ninterface IZoraCreator1155 is IZoraCreator1155TypesV1, IVersionedContract, IOwnable, IERC1155MetadataURIUpgradeable {\\n    function PERMISSION_BIT_ADMIN() external returns (uint256);\\n\\n    function PERMISSION_BIT_MINTER() external returns (uint256);\\n\\n    function PERMISSION_BIT_SALES() external returns (uint256);\\n\\n    function PERMISSION_BIT_METADATA() external returns (uint256);\\n\\n    /// @notice Used to label the configuration update type\\n    enum ConfigUpdate {\\n        OWNER,\\n        FUNDS_RECIPIENT,\\n        TRANSFER_HOOK\\n    }\\n    event ConfigUpdated(address indexed updater, ConfigUpdate indexed updateType, ContractConfig newConfig);\\n\\n    event UpdatedToken(address indexed from, uint256 indexed tokenId, TokenData tokenData);\\n    event SetupNewToken(uint256 indexed tokenId, address indexed sender, string newURI, uint256 maxSupply);\\n\\n    function setOwner(address newOwner) external;\\n\\n    event ContractRendererUpdated(IRenderer1155 renderer);\\n    event ContractMetadataUpdated(address indexed updater, string uri, string name);\\n    event Purchased(address indexed sender, address indexed minter, uint256 indexed tokenId, uint256 quantity, uint256 value);\\n\\n    error TokenIdMismatch(uint256 expected, uint256 actual);\\n    error UserMissingRoleForToken(address user, uint256 tokenId, uint256 role);\\n\\n    error Config_TransferHookNotSupported(address proposedAddress);\\n\\n    error Mint_InsolventSaleTransfer();\\n    error Mint_ValueTransferFail();\\n    error Mint_TokenIDMintNotAllowed();\\n    error Mint_UnknownCommand();\\n\\n    error Burn_NotOwnerOrApproved(address operator, address user);\\n\\n    error NewOwnerNeedsToBeAdmin();\\n\\n    error Sale_CannotCallNonSalesContract(address targetContract);\\n\\n    error CallFailed(bytes reason);\\n    error Renderer_NotValidRendererContract();\\n\\n    error ETHWithdrawFailed(address recipient, uint256 amount);\\n    error FundsWithdrawInsolvent(uint256 amount, uint256 contractValue);\\n    error ProtocolRewardsWithdrawFailed(address caller, address recipient, uint256 amount);\\n\\n    error CannotMintMoreTokens(uint256 tokenId, uint256 quantity, uint256 totalMinted, uint256 maxSupply);\\n\\n    /// @notice Only allow minting one token id at time\\n    /// @dev Mint contract function that calls the underlying sales function for commands\\n    /// @param minter Address for the minter\\n    /// @param tokenId tokenId to mint, set to 0 for new tokenId\\n    /// @param quantity to mint\\n    /// @param minterArguments calldata for the minter contracts\\n    function mint(IMinter1155 minter, uint256 tokenId, uint256 quantity, bytes calldata minterArguments) external payable;\\n\\n    function adminMint(address recipient, uint256 tokenId, uint256 quantity, bytes memory data) external;\\n\\n    function adminMintBatch(address recipient, uint256[] memory tokenIds, uint256[] memory quantities, bytes memory data) external;\\n\\n    function burnBatch(address user, uint256[] calldata tokenIds, uint256[] calldata amounts) external;\\n\\n    /// @notice Contract call to setupNewToken\\n    /// @param tokenURI URI for the token\\n    /// @param maxSupply maxSupply for the token, set to 0 for open edition\\n    function setupNewToken(string memory tokenURI, uint256 maxSupply) external returns (uint256 tokenId);\\n\\n    function updateTokenURI(uint256 tokenId, string memory _newURI) external;\\n\\n    function updateContractMetadata(string memory _newURI, string memory _newName) external;\\n\\n    // Public interface for `setTokenMetadataRenderer(uint256, address) has been deprecated.\\n\\n    function contractURI() external view returns (string memory);\\n\\n    function assumeLastTokenIdMatches(uint256 tokenId) external;\\n\\n    function updateRoyaltiesForToken(uint256 tokenId, ICreatorRoyaltiesControl.RoyaltyConfiguration memory royaltyConfiguration) external;\\n\\n    function addPermission(uint256 tokenId, address user, uint256 permissionBits) external;\\n\\n    function removePermission(uint256 tokenId, address user, uint256 permissionBits) external;\\n\\n    function isAdminOrRole(address user, uint256 tokenId, uint256 role) external view returns (bool);\\n\\n    function getTokenInfo(uint256 tokenId) external view returns (TokenData memory);\\n\\n    function callRenderer(uint256 tokenId, bytes memory data) external;\\n\\n    function callSale(uint256 tokenId, IMinter1155 salesConfig, bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IZoraCreator1155Initializer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ICreatorRoyaltiesControl} from \\\"../interfaces/ICreatorRoyaltiesControl.sol\\\";\\n\\ninterface IZoraCreator1155Initializer {\\n    function initialize(\\n        string memory contractName,\\n        string memory newContractURI,\\n        ICreatorRoyaltiesControl.RoyaltyConfiguration memory defaultRoyaltyConfiguration,\\n        address payable defaultAdmin,\\n        bytes[] calldata setupActions\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/version/ContractVersionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IVersionedContract} from \\\"../interfaces/IVersionedContract.sol\\\";\\n\\n/// @title ContractVersionBase\\n/// @notice Base contract for versioning contracts\\ncontract ContractVersionBase is IVersionedContract {\\n    /// @notice The version of the contract\\n    function contractVersion() external pure override returns (string memory) {\\n        return \\\"1.4.0\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"src/permissions/CreatorPermissionControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {CreatorPermissionStorageV1} from \\\"./CreatorPermissionStorageV1.sol\\\";\\nimport {ICreatorPermissionControl} from \\\"../interfaces/ICreatorPermissionControl.sol\\\";\\n\\n/// Imagine. Mint. Enjoy.\\n/// @author @iainnash / @tbtstl\\ncontract CreatorPermissionControl is CreatorPermissionStorageV1, ICreatorPermissionControl {\\n    /// @notice Check if the user has the given permissions\\n    /// @dev if multiple permissions are passed in this checks for all the permissions requested\\n    /// @return true or false if all of the passed in permissions apply\\n    function _hasPermissions(uint256 tokenId, address user, uint256 permissionBits) internal view returns (bool) {\\n        // Does a bitwise and and checks if any of those permissions match\\n        return permissions[tokenId][user] & permissionBits == permissionBits;\\n    }\\n\\n    /// @notice Check if the user has any of the given permissions\\n    /// @dev if multiple permissions are passed in this checks for any one of those permissions\\n    /// @return true or false if any of the passed in permissions apply\\n    function _hasAnyPermission(uint256 tokenId, address user, uint256 permissionBits) internal view returns (bool) {\\n        // Does a bitwise and and checks if any of those permissions match\\n        return permissions[tokenId][user] & permissionBits > 0;\\n    }\\n\\n    /// @return raw permission bits for the given user\\n    function getPermissions(uint256 tokenId, address user) external view returns (uint256) {\\n        return permissions[tokenId][user];\\n    }\\n\\n    /// @notice addPermission \u2013\u00a0internal function to add a set of permission bits to a user\\n    /// @param tokenId token id to add the permission to (0 indicates contract-wide add)\\n    /// @param user user to update permissions for\\n    /// @param permissionBits bits to add permissions to\\n    function _addPermission(uint256 tokenId, address user, uint256 permissionBits) internal {\\n        uint256 tokenPermissions = permissions[tokenId][user];\\n        tokenPermissions |= permissionBits;\\n        permissions[tokenId][user] = tokenPermissions;\\n        emit UpdatedPermissions(tokenId, user, tokenPermissions);\\n    }\\n\\n    /// @notice _clearPermission clear permissions for user\\n    /// @param tokenId token id to clear permission from (0 indicates contract-wide action)\\n    function _clearPermissions(uint256 tokenId, address user) internal {\\n        permissions[tokenId][user] = 0;\\n        emit UpdatedPermissions(tokenId, user, 0);\\n    }\\n\\n    /// @notice _removePermission removes permissions for user\\n    /// @param tokenId token id to clear permission from (0 indicates contract-wide action)\\n    /// @param user user to manage permissions for\\n    /// @param permissionBits set of permission bits to remove\\n    function _removePermission(uint256 tokenId, address user, uint256 permissionBits) internal {\\n        uint256 tokenPermissions = permissions[tokenId][user];\\n        tokenPermissions &= ~permissionBits;\\n        permissions[tokenId][user] = tokenPermissions;\\n        emit UpdatedPermissions(tokenId, user, tokenPermissions);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/renderer/CreatorRendererControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {CreatorRendererStorageV1} from \\\"./CreatorRendererStorageV1.sol\\\";\\nimport {IRenderer1155} from \\\"../interfaces/IRenderer1155.sol\\\";\\nimport {ITransferHookReceiver} from \\\"../interfaces/ITransferHookReceiver.sol\\\";\\nimport {SharedBaseConstants} from \\\"../shared/SharedBaseConstants.sol\\\";\\n\\n/// @title CreatorRendererControl\\n/// @notice Contract for managing the renderer of an 1155 contract\\nabstract contract CreatorRendererControl is CreatorRendererStorageV1, SharedBaseConstants {\\n    function _setRenderer(uint256 tokenId, IRenderer1155 renderer) internal {\\n        customRenderers[tokenId] = renderer;\\n        if (address(renderer) != address(0)) {\\n            if (!renderer.supportsInterface(type(IRenderer1155).interfaceId)) {\\n                revert RendererNotValid(address(renderer));\\n            }\\n        }\\n\\n        emit RendererUpdated({tokenId: tokenId, renderer: address(renderer), user: msg.sender});\\n    }\\n\\n    /// @notice Return the renderer for a given token\\n    /// @dev Returns address 0 for no results\\n    /// @param tokenId The token to get the renderer for\\n    function getCustomRenderer(uint256 tokenId) public view returns (IRenderer1155 customRenderer) {\\n        customRenderer = customRenderers[tokenId];\\n        if (address(customRenderer) == address(0)) {\\n            customRenderer = customRenderers[CONTRACT_BASE_ID];\\n        }\\n    }\\n\\n    /// @notice Function called to render when an empty tokenURI exists on the contract\\n    function _render(uint256 tokenId) internal view returns (string memory) {\\n        return getCustomRenderer(tokenId).uri(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/royalties/CreatorRoyaltiesControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {CreatorRoyaltiesStorageV1} from \\\"./CreatorRoyaltiesStorageV1.sol\\\";\\nimport {ICreatorRoyaltiesControl} from \\\"../interfaces/ICreatorRoyaltiesControl.sol\\\";\\nimport {SharedBaseConstants} from \\\"../shared/SharedBaseConstants.sol\\\";\\nimport {IERC2981} from \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\n\\n/// Imagine. Mint. Enjoy.\\n/// @title CreatorRoyaltiesControl\\n/// @author ZORA @iainnash / @tbtstl\\n/// @notice Contract for managing the royalties of an 1155 contract\\nabstract contract CreatorRoyaltiesControl is CreatorRoyaltiesStorageV1, SharedBaseConstants {\\n    uint256 immutable ROYALTY_BPS_TO_PERCENT = 10_000;\\n\\n    /// @notice The royalty information for a given token.\\n    /// @param tokenId The token ID to get the royalty information for.\\n    function getRoyalties(uint256 tokenId) public view returns (RoyaltyConfiguration memory) {\\n        if (royalties[tokenId].royaltyRecipient != address(0)) {\\n            return royalties[tokenId];\\n        }\\n        // Otherwise, return default.\\n        return royalties[CONTRACT_BASE_ID];\\n    }\\n\\n    /// @notice Returns the royalty information for a given token.\\n    /// @param tokenId The token ID to get the royalty information for.\\n    /// @param salePrice The sale price of the NFT asset specified by tokenId\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice) public view returns (address receiver, uint256 royaltyAmount) {\\n        RoyaltyConfiguration memory config = getRoyalties(tokenId);\\n        royaltyAmount = (config.royaltyBPS * salePrice) / ROYALTY_BPS_TO_PERCENT;\\n        receiver = config.royaltyRecipient;\\n    }\\n\\n    /// @notice Returns the supply royalty information for a given token.\\n    /// @param tokenId The token ID to get the royalty information for.\\n    /// @param mintAmount The amount of tokens being minted.\\n    /// @param totalSupply The total supply of the token,\\n    function supplyRoyaltyInfo(uint256 tokenId, uint256 totalSupply, uint256 mintAmount) public view returns (address receiver, uint256 royaltyAmount) {\\n        RoyaltyConfiguration memory config = getRoyalties(tokenId);\\n        if (config.royaltyMintSchedule == 0) {\\n            return (config.royaltyRecipient, 0);\\n        }\\n        uint256 totalRoyaltyMints = (mintAmount + (totalSupply % config.royaltyMintSchedule)) / (config.royaltyMintSchedule - 1);\\n        return (config.royaltyRecipient, totalRoyaltyMints);\\n    }\\n\\n    function _updateRoyalties(uint256 tokenId, RoyaltyConfiguration memory configuration) internal {\\n        // Don't allow 100% supply royalties\\n        if (configuration.royaltyMintSchedule == 1) {\\n            revert InvalidMintSchedule();\\n        }\\n        // Don't allow setting royalties to burn address\\n        if (configuration.royaltyRecipient == address(0) && (configuration.royaltyMintSchedule > 0 || configuration.royaltyBPS > 0)) {\\n            revert InvalidMintSchedule();\\n        }\\n        royalties[tokenId] = configuration;\\n\\n        emit UpdatedRoyalties(tokenId, msg.sender, configuration);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC2981).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICreatorCommands.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice Creator Commands used by minter modules passed back to the main modules\\ninterface ICreatorCommands {\\n    /// @notice This enum is used to define supported creator action types.\\n    /// This can change in the future\\n    enum CreatorActions {\\n        // No operation - also the default for mintings that may not return a command\\n        NO_OP,\\n        // Send ether\\n        SEND_ETH,\\n        // Mint operation\\n        MINT\\n    }\\n\\n    /// @notice This command is for\\n    struct Command {\\n        // Method for operation\\n        CreatorActions method;\\n        // Arguments used for this operation\\n        bytes args;\\n    }\\n\\n    /// @notice This command set is returned from the minter back to the user\\n    struct CommandSet {\\n        Command[] commands;\\n        uint256 at;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMinter1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IERC165Upgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC165Upgradeable.sol\\\";\\nimport {ICreatorCommands} from \\\"./ICreatorCommands.sol\\\";\\n\\n/// @notice Minter standard interface\\n/// @dev Minters need to confirm to the ERC165 selector of type(IMinter1155).interfaceId\\ninterface IMinter1155 is IERC165Upgradeable {\\n    function requestMint(\\n        address sender,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        uint256 ethValueSent,\\n        bytes calldata minterArguments\\n    ) external returns (ICreatorCommands.CommandSet memory commands);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IRenderer1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IERC165Upgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC165Upgradeable.sol\\\";\\n\\n/// @dev IERC165 type required\\ninterface IRenderer1155 is IERC165Upgradeable {\\n    /// @notice Called for assigned tokenId, or when token id is globally set to a renderer\\n    /// @dev contract target is assumed to be msg.sender\\n    /// @param tokenId token id to get uri for\\n    function uri(uint256 tokenId) external view returns (string memory);\\n\\n    /// @notice Only called for tokenId == 0\\n    /// @dev contract target is assumed to be msg.sender\\n    function contractURI() external view returns (string memory);\\n\\n    /// @notice Sets up renderer from contract\\n    /// @param initData data to setup renderer with\\n    /// @dev contract target is assumed to be msg.sender\\n    function setup(bytes memory initData) external;\\n\\n    // IERC165 type required \u2013\u00a0set in base helper\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITransferHookReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IERC165Upgradeable} from \\\"@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC165Upgradeable.sol\\\";\\n\\ninterface ITransferHookReceiver is IERC165Upgradeable {\\n    /// @notice Token transfer batch callback\\n    /// @param target target contract for transfer\\n    /// @param operator operator address for transfer\\n    /// @param from user address for amount transferred\\n    /// @param to user address for amount transferred\\n    /// @param ids list of token ids transferred\\n    /// @param amounts list of values transferred\\n    /// @param data data as perscribed by 1155 standard\\n    function onTokenTransferBatch(\\n        address target,\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n\\n    // IERC165 type required\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IFactoryManagedUpgradeGate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice Factory Upgrade Gate Admin Factory Implementation \u2013 Allows specific contract upgrades as a safety measure\\ninterface IFactoryManagedUpgradeGate {\\n    /// @notice If an implementation is registered by the Builder DAO as an optional upgrade\\n    /// @param baseImpl The base implementation address\\n    /// @param upgradeImpl The upgrade implementation address\\n    function isRegisteredUpgradePath(address baseImpl, address upgradeImpl) external view returns (bool);\\n\\n    /// @notice Called by the Builder DAO to offer implementation upgrades for created DAOs\\n    /// @param baseImpls The base implementation addresses\\n    /// @param upgradeImpl The upgrade implementation address\\n    function registerUpgradePath(address[] memory baseImpls, address upgradeImpl) external;\\n\\n    /// @notice Called by the Builder DAO to remove an upgrade\\n    /// @param baseImpl The base implementation address\\n    /// @param upgradeImpl The upgrade implementation address\\n    function removeUpgradePath(address baseImpl, address upgradeImpl) external;\\n\\n    event UpgradeRegistered(address indexed baseImpl, address indexed upgradeImpl);\\n    event UpgradeRemoved(address indexed baseImpl, address indexed upgradeImpl);\\n}\\n\"\r\n    },\r\n    \"src/legacy-naming/LegacyNamingControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ILegacyNaming} from \\\"../interfaces/ILegacyNaming.sol\\\";\\nimport {LegacyNamingStorageV1} from \\\"./LegacyNamingStorageV1.sol\\\";\\n\\n/// @title LegacyNamingControl\\n/// @notice Contract for managing the name and symbol of an 1155 contract in the legacy naming scheme\\ncontract LegacyNamingControl is LegacyNamingStorageV1, ILegacyNaming {\\n    /// @notice The name of the contract\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /// @notice The token symbol of the contract\\n    function symbol() external pure returns (string memory) {}\\n\\n    function _setName(string memory _newName) internal {\\n        _name = _newName;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/fee/MintFeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {TransferHelperUtils} from \\\"../utils/TransferHelperUtils.sol\\\";\\nimport {IMintFeeManager} from \\\"../interfaces/IMintFeeManager.sol\\\";\\n\\n/// @title MintFeeManager\\n/// @notice Manages mint fees for an 1155 contract\\ncontract MintFeeManager is IMintFeeManager {\\n    uint256 public immutable mintFee;\\n    address public immutable mintFeeRecipient;\\n\\n    constructor(uint256 _mintFee, address _mintFeeRecipient) {\\n        // Set fixed finders fee\\n        if (_mintFee >= 0.1 ether) {\\n            revert MintFeeCannotBeMoreThanZeroPointOneETH(_mintFee);\\n        }\\n        if (_mintFeeRecipient == address(0) && _mintFee > 0) {\\n            revert CannotSetMintFeeToZeroAddress();\\n        }\\n        mintFeeRecipient = _mintFeeRecipient;\\n        mintFee = _mintFee;\\n    }\\n\\n    /// @notice Sends the mint fee to the mint fee recipient and returns the amount of ETH remaining that can be used in this transaction\\n    /// @param _quantity The amount of toknens being minted\\n    function _handleFeeAndGetValueSent(uint256 _quantity) internal returns (uint256 ethValueSent) {\\n        ethValueSent = msg.value;\\n\\n        // Handle mint fee\\n        if (mintFeeRecipient != address(0)) {\\n            uint256 totalFee = mintFee * _quantity;\\n            ethValueSent -= totalFee;\\n            if (!TransferHelperUtils.safeSendETH(mintFeeRecipient, totalFee, TransferHelperUtils.FUNDS_SEND_LOW_GAS_LIMIT)) {\\n                revert CannotSendMintFee(mintFeeRecipient, totalFee);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/PublicMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/// @title PublicMulticall\\n/// @notice Contract for executing a batch of function calls on this contract\\nabstract contract PublicMulticall {\\n    /**\\n     * @notice Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) public virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/shared/SharedBaseConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ncontract SharedBaseConstants {\\n    uint256 public constant CONTRACT_BASE_ID = 0;\\n}\\n\"\r\n    },\r\n    \"src/utils/TransferHelperUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @title TransferHelperUtils\\n/// @notice Helper functions for sending ETH\\nlibrary TransferHelperUtils {\\n    /// @dev Gas limit to send funds\\n    uint256 internal constant FUNDS_SEND_LOW_GAS_LIMIT = 110_000;\\n\\n    // @dev Gas limit to send funds \u2013 usable for splits, can use with withdraws\\n    uint256 internal constant FUNDS_SEND_NORMAL_GAS_LIMIT = 310_000;\\n\\n    /// @notice Sends ETH to a recipient, making conservative estimates to not run out of gas\\n    /// @param recipient The address to send ETH to\\n    /// @param value The amount of ETH to send\\n    function safeSendETH(address recipient, uint256 value, uint256 gasLimit) internal returns (bool success) {\\n        (success, ) = recipient.call{value: value, gas: gasLimit}(\\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/nft/ZoraCreator1155StorageV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IZoraCreator1155TypesV1} from \\\"./IZoraCreator1155TypesV1.sol\\\";\\n\\n/*\\n\\n\\n             \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591              \\n        \u2591\u2591\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591        \\n      \u2591\u2591\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591      \\n    \u2591\u2591\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \\n   \u2591\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591        \u2591\u2591\u2591\u2591\u2591\u2591\u2591    \\n  \u2591\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591        \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n  \u2591\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n  \u2591\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n  \u2591\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n   \u2591\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n    \u2591\u2591\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \\n    \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u2592\u2591\u2591    \\n      \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591      \\n          \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2591\u2591\u2591          \\n\\n               OURS TRULY,\\n\\n\\n    github.com/ourzora/zora-1155-contracts\\n\\n */\\n\\n/// Imagine. Mint. Enjoy.\\n/// @notice Storage for 1155 contract\\n/// @author @iainnash / @tbtstl\\ncontract ZoraCreator1155StorageV1 is IZoraCreator1155TypesV1 {\\n    /// @notice token data stored for each token\\n    mapping(uint256 => TokenData) internal tokens;\\n\\n    /// @notice metadata renderer contract for each token\\n    mapping(uint256 => address) public metadataRendererContract;\\n\\n    /// @notice next token id available when using a linear mint style (default for launch)\\n    uint256 public nextTokenId;\\n\\n    /// @notice Global contract configuration\\n    ContractConfig public config;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/IERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n\\nerror ADDRESS_INSUFFICIENT_BALANCE();\\nerror ADDRESS_UNABLE_TO_SEND_VALUE();\\nerror ADDRESS_LOW_LEVEL_CALL_FAILED();\\nerror ADDRESS_LOW_LEVEL_CALL_WITH_VALUE_FAILED();\\nerror ADDRESS_INSUFFICIENT_BALANCE_FOR_CALL();\\nerror ADDRESS_LOW_LEVEL_STATIC_CALL_FAILED();\\nerror ADDRESS_CALL_TO_NON_CONTRACT();\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance > amount) {\\n            revert ADDRESS_INSUFFICIENT_BALANCE();\\n        }\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert ADDRESS_UNABLE_TO_SEND_VALUE();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert ADDRESS_INSUFFICIENT_BALANCE();\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                if (!isContract(target)) {\\n                    revert ADDRESS_CALL_TO_NON_CONTRACT();\\n                }\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert ADDRESS_LOW_LEVEL_CALL_FAILED();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\nerror INITIALIZABLE_CONTRACT_ALREADY_INITIALIZED();\\nerror INITIALIZABLE_CONTRACT_IS_NOT_INITIALIZING();\\nerror INITIALIZABLE_CONTRACT_IS_INITIALIZING();\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        if ((!isTopLevelCall || _initialized != 0) && (AddressUpgradeable.isContract(address(this)) || _initialized != 1)) {\\n            revert INITIALIZABLE_CONTRACT_ALREADY_INITIALIZED();\\n        }\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        if (_initializing || _initialized >= version) {\\n            revert INITIALIZABLE_CONTRACT_ALREADY_INITIALIZED();\\n        }\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        if (!_initializing) {\\n            revert INITIALIZABLE_CONTRACT_IS_NOT_INITIALIZING();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        if (_initializing) {\\n            revert INITIALIZABLE_CONTRACT_IS_INITIALIZING();\\n        }\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\nerror ERC1967_NEW_IMPL_NOT_CONTRACT();\\nerror ERC1967_UNSUPPORTED_PROXIABLEUUID();\\nerror ERC1967_NEW_IMPL_NOT_UUPS();\\nerror ERC1967_NEW_ADMIN_IS_ZERO_ADDRESS();\\nerror ERC1967_NEW_BEACON_IS_NOT_CONTRACT();\\nerror ERC1967_BEACON_IMPL_IS_NOT_CONTRACT();\\nerror ADDRESS_DELEGATECALL_TO_NON_CONTRACT();\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (!AddressUpgradeable.isContract(newImplementation)) {\\n            revert ERC1967_NEW_IMPL_NOT_CONTRACT();\\n        } \\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                if (slot != _IMPLEMENTATION_SLOT) {\\n                    revert ERC1967_UNSUPPORTED_PROXIABLEUUID();\\n                }\\n            } catch {\\n                revert ERC1967_NEW_IMPL_NOT_UUPS();\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967_NEW_ADMIN_IS_ZERO_ADDRESS();\\n        }\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (!AddressUpgradeable.isContract(newBeacon)) {\\n            revert ERC1967_NEW_BEACON_IS_NOT_CONTRACT();\\n        }\\n        if (!AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation())) {\\n            revert ERC1967_BEACON_IMPL_IS_NOT_CONTRACT();\\n        }\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        if (!AddressUpgradeable.isContract(target)) {\\n            revert ADDRESS_DELEGATECALL_TO_NON_CONTRACT();\\n        }\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/protocol-rewards/dist/contracts/abstract/RewardSplits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IProtocolRewards} from \\\"../interfaces/IProtocolRewards.sol\\\";\\n\\nstruct RewardsSettings {\\n    uint256 creatorReward;\\n    uint256 createReferralReward;\\n    uint256 mintReferralReward;\\n    uint256 firstMinterReward;\\n    uint256 zoraReward;\\n}\\n\\n/// @notice Common logic for between Zora ERC-721 & ERC-1155 contracts for protocol reward splits & deposits\\nabstract contract RewardSplits {\\n    error CREATOR_FUNDS_RECIPIENT_NOT_SET();\\n    error INVALID_ADDRESS_ZERO();\\n    error INVALID_ETH_AMOUNT();\\n    error ONLY_CREATE_REFERRAL();\\n\\n    uint256 internal constant TOTAL_REWARD_PER_MINT = 0.000777 ether;\\n\\n    uint256 internal constant CREATOR_REWARD = 0.000333 ether;\\n    uint256 internal constant FIRST_MINTER_REWARD = 0.000111 ether;\\n\\n    uint256 internal constant CREATE_REFERRAL_FREE_MINT_REWARD = 0.000111 ether;\\n    uint256 internal constant MINT_REFERRAL_FREE_MINT_REWARD = 0.000111 ether;\\n    uint256 internal constant ZORA_FREE_MINT_REWARD = 0.000111 ether;\\n\\n    uint256 internal constant MINT_REFERRAL_PAID_MINT_REWARD = 0.000222 ether;\\n    uint256 internal constant CREATE_REFERRAL_PAID_MINT_REWARD = 0.000222 ether;\\n    uint256 internal constant ZORA_PAID_MINT_REWARD = 0.000222 ether;\\n\\n    address internal immutable zoraRewardRecipient;\\n    IProtocolRewards internal immutable protocolRewards;\\n\\n    constructor(address _protocolRewards, address _zoraRewardRecipient) payable {\\n        if (_protocolRewards == address(0) || _zoraRewardRecipient == address(0)) {\\n            revert INVALID_ADDRESS_ZERO();\\n        }\\n\\n        protocolRewards = IProtocolRewards(_protocolRewards);\\n        zoraRewardRecipient = _zoraRewardRecipient;\\n    }\\n\\n    function computeTotalReward(uint256 numTokens) public pure returns (uint256) {\\n        return numTokens * TOTAL_REWARD_PER_MINT;\\n    }\\n\\n    function computeFreeMintRewards(uint256 numTokens) public pure returns (RewardsSettings memory) {\\n        return\\n            RewardsSettings({\\n                creatorReward: numTokens * CREATOR_REWARD,\\n                createReferralReward: numTokens * CREATE_REFERRAL_FREE_MINT_REWARD,\\n                mintReferralReward: numTokens * MINT_REFERRAL_FREE_MINT_REWARD,\\n                firstMinterReward: numTokens * FIRST_MINTER_REWARD,\\n                zoraReward: numTokens * ZORA_FREE_MINT_REWARD\\n            });\\n    }\\n\\n    function computePaidMintRewards(uint256 numTokens) public pure returns (RewardsSettings memory) {\\n        return\\n            RewardsSettings({\\n                creatorReward: 0,\\n                createReferralReward: numTokens * CREATE_REFERRAL_PAID_MINT_REWARD,\\n                mintReferralReward: numTokens * MINT_REFERRAL_PAID_MINT_REWARD,\\n                firstMinterReward: numTokens * FIRST_MINTER_REWARD,\\n                zoraReward: numTokens * ZORA_PAID_MINT_REWARD\\n            });\\n    }\\n\\n    function _depositFreeMintRewards(uint256 totalReward, uint256 numTokens, address creator, address createReferral, address mintReferral) internal {\\n        RewardsSettings memory settings = computeFreeMintRewards(numTokens);\\n\\n        if (createReferral == address(0)) {\\n            createReferral = zoraRewardRecipient;\\n        }\\n\\n        if (mintReferral == address(0)) {\\n            mintReferral = zoraRewardRecipient;\\n        }\\n\\n        protocolRewards.depositRewards{value: totalReward}(\\n            creator,\\n            settings.creatorReward,\\n            createReferral,\\n            settings.createReferralReward,\\n            mintReferral,\\n            settings.mintReferralReward,\\n            creator,\\n            settings.firstMinterReward,\\n            zoraRewardRecipient,\\n            settings.zoraReward\\n        );\\n    }\\n\\n    function _depositPaidMintRewards(uint256 totalReward, uint256 numTokens, address creator, address createReferral, address mintReferral) internal {\\n        RewardsSettings memory settings = computePaidMintRewards(numTokens);\\n\\n        if (createReferral == address(0)) {\\n            createReferral = zoraRewardRecipient;\\n        }\\n\\n        if (mintReferral == address(0)) {\\n            mintReferral = zoraRewardRecipient;\\n        }\\n\\n        protocolRewards.depositRewards{value: totalReward}(\\n            address(0),\\n            0,\\n            createReferral,\\n            settings.createReferralReward,\\n            mintReferral,\\n            settings.mintReferralReward,\\n            creator,\\n            settings.firstMinterReward,\\n            zoraRewardRecipient,\\n            settings.zoraReward\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/nft/IZoraCreator1155TypesV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ITransferHookReceiver} from \\\"../interfaces/ITransferHookReceiver.sol\\\";\\n\\n/*\\n\\n\\n             \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591              \\n        \u2591\u2591\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591        \\n      \u2591\u2591\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591      \\n    \u2591\u2591\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \\n   \u2591\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591        \u2591\u2591\u2591\u2591\u2591\u2591\u2591    \\n  \u2591\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591        \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n  \u2591\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n  \u2591\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n  \u2591\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n   \u2591\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591  \\n    \u2591\u2591\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \\n    \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2592\u2592\u2592\u2592\u2592\u2591\u2591    \\n      \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2592\u2591\u2591      \\n          \u2591\u2591\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2592\u2592\u2591\u2591\u2591          \\n\\n               OURS TRULY,\\n\\n */\\n\\n/// Imagine. Mint. Enjoy.\\n/// @notice Interface for types used across the ZoraCreator1155 contract\\n/// @author @iainnash / @tbtstl\\ninterface IZoraCreator1155TypesV1 {\\n    /// @notice Used to store individual token data\\n    struct TokenData {\\n        string uri;\\n        uint256 maxSupply;\\n        uint256 totalMinted;\\n    }\\n\\n    /// @notice Used to store contract-level configuration\\n    struct ContractConfig {\\n        address owner;\\n        uint96 __gap1;\\n        address payable fundsRecipient;\\n        uint96 __gap2;\\n        ITransferHookReceiver transferHook;\\n        uint96 __gap3;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IOwnable {\\n    function owner() external returns (address);\\n\\n    event OwnershipTransferred(address lastOwner, address newOwner);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IVersionedContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IVersionedContract {\\n    function contractVersion() external returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICreatorRoyaltiesControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IERC2981} from \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\n\\ninterface ICreatorRoyaltiesControl is IERC2981 {\\n    /// @notice The RoyaltyConfiguration struct is used to store the royalty configuration for a given token.\\n    /// @param royaltyMintSchedule Every nth token will go to the royalty recipient.\\n    /// @param royaltyBPS The royalty amount in basis points for secondary sales.\\n    /// @param royaltyRecipient The address that will receive the royalty payments.\\n    struct RoyaltyConfiguration {\\n        uint32 royaltyMintSchedule;\\n        uint32 royaltyBPS;\\n        address royaltyRecipient;\\n    }\\n\\n    /// @notice Thrown when a user tries to have 100% supply royalties\\n    error InvalidMintSchedule();\\n\\n    /// @notice Event emitted when royalties are updated\\n    event UpdatedRoyalties(uint256 indexed tokenId, address indexed user, RoyaltyConfiguration configuration);\\n\\n    /// @notice External data getter to get royalties for a token\\n    /// @param tokenId tokenId to get royalties configuration for\\n    function getRoyalties(uint256 tokenId) external view returns (RoyaltyConfiguration memory);\\n}\\n\"\r\n    },\r\n    \"src/permissions/CreatorPermissionStorageV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// Imagine. Mint. Enjoy.\\n/// @author @iainnash / @tbtstl\\ncontract CreatorPermissionStorageV1 {\\n    mapping(uint256 => mapping(address => uint256)) public permissions;\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICreatorPermissionControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice Generic control interface for bit-based permissions-control\\ninterface ICreatorPermissionControl {\\n    /// @notice Emitted when permissions are updated\\n    event UpdatedPermissions(uint256 indexed tokenId, address indexed user, uint256 indexed permissions);\\n\\n    /// @notice Public interface to get permissions given a token id and a user address\\n    /// @return Returns raw permission bits\\n    function getPermissions(uint256 tokenId, address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/renderer/CreatorRendererStorageV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ICreatorRendererControl} from \\\"../interfaces/ICreatorRendererControl.sol\\\";\\nimport {IRenderer1155} from \\\"../interfaces/IRenderer1155.sol\\\";\\n\\n/// @notice Creator Renderer Storage Configuration Contract V1\\nabstract contract CreatorRendererStorageV1 is ICreatorRendererControl {\\n    /// @notice Mapping for custom renderers\\n    mapping(uint256 => IRenderer1155) public customRenderers;\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/royalties/CreatorRoyaltiesStorageV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {ICreatorRoyaltiesControl} from \\\"../interfaces/ICreatorRoyaltiesControl.sol\\\";\\n\\n/// Imagine. Mint. Enjoy.\\n/// @title CreatorRoyaltiesControl\\n/// @author ZORA @iainnash / @tbtstl\\n/// @notice Royalty storage contract pattern\\nabstract contract CreatorRoyaltiesStorageV1 is ICreatorRoyaltiesControl {\\n    mapping(uint256 => RoyaltyConfiguration) public royalties;\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILegacyNaming.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ILegacyNaming {\\n    function name() external returns (string memory);\\n\\n    function symbol() external returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/legacy-naming/LegacyNamingStorageV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ncontract LegacyNamingStorageV1 {\\n    string internal _name;\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMintFeeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IMintFeeManager {\\n    error MintFeeCannotBeMoreThanZeroPointOneETH(uint256 mintFeeBPS);\\n    error CannotSendMintFee(address mintFeeRecipient, uint256 mintFee);\\n    error CannotSetMintFeeToZeroAddress();\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function mintFeeRecipient() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"node_modules/@zoralabs/openzeppelin-contracts-upgradeable/contracts/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICreatorRendererControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IRenderer1155} from \\\"./IRenderer1155.sol\\\";\\n\\n/// @notice Interface for creator renderer controls\\ninterface ICreatorRendererControl {\\n    /// @notice Get the custom renderer contract (if any) for the given token id\\n    /// @dev Reverts if not custom renderer is set for this token\\n    function getCustomRenderer(uint256 tokenId) external view returns (IRenderer1155 renderer);\\n\\n    error NoRendererForToken(uint256 tokenId);\\n    error RendererNotValid(address renderer);\\n    event RendererUpdated(uint256 indexed tokenId, address indexed renderer, address indexed user);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/\",\r\n      \"@zoralabs/=node_modules/@zoralabs/\",\r\n      \"@zoralabs/openzeppelin-contracts-upgradeable/=node_modules/@zoralabs/openzeppelin-contracts-upgradeable/\",\r\n      \"@zoralabs/protocol-rewards/=node_modules/@zoralabs/protocol-rewards/\",\r\n      \"_imagine/=_imagine/\",\r\n      \"ds-test/=node_modules/ds-test/src/\",\r\n      \"forge-std/=node_modules/forge-std/src/\",\r\n      \"mint/=_imagine/mint/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 3000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mintFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolRewards\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ADDRESS_DELEGATECALL_TO_NON_CONTRACT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ADDRESS_LOW_LEVEL_CALL_FAILED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Burn_NotOwnerOrApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CREATOR_FUNDS_RECIPIENT_NOT_SET\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"CallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMinted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"CannotMintMoreTokens\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mintFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"mintFee\",\"type\":\"uint256\"}],\"name\":\"CannotSendMintFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetMintFeeToZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proposedAddress\",\"type\":\"address\"}],\"name\":\"Config_TransferHookNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_ACCOUNTS_AND_IDS_LENGTH_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_ADDRESS_ZERO_IS_NOT_A_VALID_OWNER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_BURN_AMOUNT_EXCEEDS_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_BURN_FROM_ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_ERC1155RECEIVER_REJECTED_TOKENS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_IDS_AND_AMOUNTS_LENGTH_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_INSUFFICIENT_BALANCE_FOR_TRANSFER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_MINT_TO_ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_SETTING_APPROVAL_FOR_SELF\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_TRANSFER_TO_NON_ERC1155RECEIVER_IMPLEMENTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1155_TRANSFER_TO_ZERO_ADDRESS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967_NEW_IMPL_NOT_CONTRACT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967_NEW_IMPL_NOT_UUPS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC1967_UNSUPPORTED_PROXIABLEUUID\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ETHWithdrawFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FUNCTION_MUST_BE_CALLED_THROUGH_ACTIVE_PROXY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FUNCTION_MUST_BE_CALLED_THROUGH_DELEGATECALL\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractValue\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawInsolvent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INITIALIZABLE_CONTRACT_ALREADY_INITIALIZED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INITIALIZABLE_CONTRACT_IS_NOT_INITIALIZING\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ADDRESS_ZERO\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"INVALID_ETH_AMOUNT\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMintSchedule\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintFeeBPS\",\"type\":\"uint256\"}],\"name\":\"MintFeeCannotBeMoreThanZeroPointOneETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Mint_InsolventSaleTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Mint_TokenIDMintNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Mint_UnknownCommand\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Mint_ValueTransferFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerNeedsToBeAdmin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NoRendererForToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ONLY_CREATE_REFERRAL\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ProtocolRewardsWithdrawFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"renderer\",\"type\":\"address\"}],\"name\":\"RendererNotValid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Renderer_NotValidRendererContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"}],\"name\":\"Sale_CannotCallNonSalesContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"TokenIdMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UUPS_UPGRADEABLE_MUST_NOT_BE_CALLED_THROUGH_DELEGATECALL\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"UserMissingRoleForToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enum IZoraCreator1155.ConfigUpdate\",\"name\":\"updateType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"__gap1\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"fundsRecipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"__gap2\",\"type\":\"uint96\"},{\"internalType\":\"contract ITransferHookReceiver\",\"name\":\"transferHook\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"__gap3\",\"type\":\"uint96\"}],\"indexed\":false,\"internalType\":\"struct IZoraCreator1155TypesV1.ContractConfig\",\"name\":\"newConfig\",\"type\":\"tuple\"}],\"name\":\"ConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"ContractMetadataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IRenderer1155\",\"name\":\"renderer\",\"type\":\"address\"}],\"name\":\"ContractRendererUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lastOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"renderer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RendererUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"SetupNewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"permissions\",\"type\":\"uint256\"}],\"name\":\"UpdatedPermissions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"royaltyMintSchedule\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"royaltyBPS\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct ICreatorRoyaltiesControl.RoyaltyConfiguration\",\"name\":\"configuration\",\"type\":\"tuple\"}],\"name\":\"UpdatedRoyalties\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMinted\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct IZoraCreator1155TypesV1.TokenData\",\"name\":\"tokenData\",\"type\":\"tuple\"}],\"name\":\"UpdatedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTRACT_BASE_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMISSION_BIT_ADMIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMISSION_BIT_FUNDS_MANAGER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMISSION_BIT_METADATA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMISSION_BIT_MINTER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMISSION_BIT_SALES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"permissionBits\",\"type\":\"uint256\"}],\"name\":\"addPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"adminMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"quantities\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"adminMintBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastTokenId\",\"type\":\"uint256\"}],\"name\":\"assumeLastTokenIdMatches\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"batchBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"contract IMinter1155\",\"name\":\"salesConfig\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"computeFreeMintRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"creatorReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createReferralReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintReferralReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstMinterReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zoraReward\",\"type\":\"uint256\"}],\"internalType\":\"struct RewardsSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"computePaidMintRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"creatorReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createReferralReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintReferralReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstMinterReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zoraReward\",\"type\":\"uint256\"}],\"internalType\":\"struct RewardsSettings\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"computeTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"__gap1\",\"type\":\"uint96\"},{\"internalType\":\"address payable\",\"name\":\"fundsRecipient\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"__gap2\",\"type\":\"uint96\"},{\"internalType\":\"contract ITransferHookReceiver\",\"name\":\"transferHook\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"__gap3\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"createReferrals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"customRenderers\",\"outputs\":[{\"internalType\":\"contract IRenderer1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreatorRewardRecipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCustomRenderer\",\"outputs\":[{\"internalType\":\"contract IRenderer1155\",\"name\":\"customRenderer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPermissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyalties\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"royaltyMintSchedule\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"royaltyBPS\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"}],\"internalType\":\"struct ICreatorRoyaltiesControl.RoyaltyConfiguration\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalMinted\",\"type\":\"uint256\"}],\"internalType\":\"struct IZoraCreator1155TypesV1.TokenData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newContractURI\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"royaltyMintSchedule\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"royaltyBPS\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"}],\"internalType\":\"struct ICreatorRoyaltiesControl.RoyaltyConfiguration\",\"name\":\"defaultRoyaltyConfiguration\",\"type\":\"tuple\"},{\"internalType\":\"address payable\",\"name\":\"defaultAdmin\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"setupActions\",\"type\":\"bytes[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"isAdminOrRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"metadataRendererContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMinter1155\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"minterArguments\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMinter1155\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"minterArguments\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"mintReferral\",\"type\":\"address\"}],\"name\":\"mintWithRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"permissionBits\",\"type\":\"uint256\"}],\"name\":\"removePermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royalties\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"royaltyMintSchedule\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"royaltyBPS\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"fundsRecipient\",\"type\":\"address\"}],\"name\":\"setFundsRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"contract IRenderer1155\",\"name\":\"renderer\",\"type\":\"address\"}],\"name\":\"setTokenMetadataRenderer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITransferHookReceiver\",\"name\":\"transferHook\",\"type\":\"address\"}],\"name\":\"setTransferHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"setupNewToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"createReferral\",\"type\":\"address\"}],\"name\":\"setupNewTokenWithCreateReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"}],\"name\":\"supplyRoyaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_newName\",\"type\":\"string\"}],\"name\":\"updateContractMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"updateCreateReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"royaltyMintSchedule\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"royaltyBPS\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"royaltyRecipient\",\"type\":\"address\"}],\"internalType\":\"struct ICreatorRoyaltiesControl.RoyaltyConfiguration\",\"name\":\"newConfiguration\",\"type\":\"tuple\"}],\"name\":\"updateRoyaltiesForToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_newURI\",\"type\":\"string\"}],\"name\":\"updateTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ZoraCreator1155Impl", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "3000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000002c2ad68fd9000000000000000000000000000d1d1d4e36117ab794ec5d4c78cbd3a8904e691d0000000000000000000000000a6c5f2de915240270dac655152c3f6a91748cb850000000000000000000000007777777a456ff23d9b6851184472c08fbda73e32", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}