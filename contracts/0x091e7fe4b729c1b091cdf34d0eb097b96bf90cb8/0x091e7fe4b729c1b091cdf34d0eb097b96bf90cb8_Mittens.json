{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: prb-math/contracts/PRBMath.sol\r\n\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Emitted when the result overflows uint256.\r\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\r\n\r\n/// @notice Emitted when the result overflows uint256.\r\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\r\n\r\n/// @notice Emitted when one of the inputs is type(int256).min.\r\nerror PRBMath__MulDivSignedInputTooSmall();\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows int256.\r\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is MIN_SD59x18.\r\nerror PRBMathSD59x18__AbsInputTooSmall();\r\n\r\n/// @notice Emitted when ceiling a number overflows SD59x18.\r\nerror PRBMathSD59x18__CeilOverflow(int256 x);\r\n\r\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\r\nerror PRBMathSD59x18__DivInputTooSmall();\r\n\r\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\r\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is greater than 133.084258667509499441.\r\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\r\n\r\n/// @notice Emitted when the input is greater than 192.\r\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\r\n\r\n/// @notice Emitted when flooring a number underflows SD59x18.\r\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\r\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\r\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\r\n\r\n/// @notice Emitted when the product of the inputs is negative.\r\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\r\n\r\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\r\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\r\n\r\n/// @notice Emitted when the input is less than or equal to zero.\r\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\r\n\r\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\r\nerror PRBMathSD59x18__MulInputTooSmall();\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\r\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\r\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is negative.\r\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\r\n\r\n/// @notice Emitted when the calculating the square root overflows SD59x18.\r\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\r\n\r\n/// @notice Emitted when addition overflows UD60x18.\r\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\r\n\r\n/// @notice Emitted when ceiling a number overflows UD60x18.\r\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\r\n\r\n/// @notice Emitted when the input is greater than 133.084258667509499441.\r\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\r\n\r\n/// @notice Emitted when the input is greater than 192.\r\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\r\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\r\n\r\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\r\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\r\n\r\n/// @notice Emitted when the input is less than 1.\r\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\r\n\r\n/// @notice Emitted when the calculating the square root overflows UD60x18.\r\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\r\n\r\n/// @notice Emitted when subtraction underflows UD60x18.\r\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\r\n\r\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\r\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\r\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\r\nlibrary PRBMath {\r\n    /// STRUCTS ///\r\n\r\n    struct SD59x18 {\r\n        int256 value;\r\n    }\r\n\r\n    struct UD60x18 {\r\n        uint256 value;\r\n    }\r\n\r\n    /// STORAGE ///\r\n\r\n    /// @dev How many trailing decimals can be represented.\r\n    uint256 internal constant SCALE = 1e18;\r\n\r\n    /// @dev Largest power of two divisor of SCALE.\r\n    uint256 internal constant SCALE_LPOTD = 262144;\r\n\r\n    /// @dev SCALE inverted mod 2^256.\r\n    uint256 internal constant SCALE_INVERSE =\r\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\r\n\r\n    /// FUNCTIONS ///\r\n\r\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\r\n    /// @dev Has to use 192.64-bit fixed-point numbers.\r\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\r\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp2(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // Start from 0.5 in the 192.64-bit fixed-point format.\r\n            result = 0x800000000000000000000000000000000000000000000000;\r\n\r\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\r\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\r\n            if (x & 0x8000000000000000 > 0) {\r\n                result = (result * 0x16A09E667F3BCC909) >> 64;\r\n            }\r\n            if (x & 0x4000000000000000 > 0) {\r\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\r\n            }\r\n            if (x & 0x2000000000000000 > 0) {\r\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\r\n            }\r\n            if (x & 0x1000000000000000 > 0) {\r\n                result = (result * 0x10B5586CF9890F62A) >> 64;\r\n            }\r\n            if (x & 0x800000000000000 > 0) {\r\n                result = (result * 0x1059B0D31585743AE) >> 64;\r\n            }\r\n            if (x & 0x400000000000000 > 0) {\r\n                result = (result * 0x102C9A3E778060EE7) >> 64;\r\n            }\r\n            if (x & 0x200000000000000 > 0) {\r\n                result = (result * 0x10163DA9FB33356D8) >> 64;\r\n            }\r\n            if (x & 0x100000000000000 > 0) {\r\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\r\n            }\r\n            if (x & 0x80000000000000 > 0) {\r\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\r\n            }\r\n            if (x & 0x40000000000000 > 0) {\r\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\r\n            }\r\n            if (x & 0x20000000000000 > 0) {\r\n                result = (result * 0x100162F3904051FA1) >> 64;\r\n            }\r\n            if (x & 0x10000000000000 > 0) {\r\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\r\n            }\r\n            if (x & 0x8000000000000 > 0) {\r\n                result = (result * 0x100058BA01FB9F96D) >> 64;\r\n            }\r\n            if (x & 0x4000000000000 > 0) {\r\n                result = (result * 0x10002C5CC37DA9492) >> 64;\r\n            }\r\n            if (x & 0x2000000000000 > 0) {\r\n                result = (result * 0x1000162E525EE0547) >> 64;\r\n            }\r\n            if (x & 0x1000000000000 > 0) {\r\n                result = (result * 0x10000B17255775C04) >> 64;\r\n            }\r\n            if (x & 0x800000000000 > 0) {\r\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\r\n            }\r\n            if (x & 0x400000000000 > 0) {\r\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\r\n            }\r\n            if (x & 0x200000000000 > 0) {\r\n                result = (result * 0x10000162E43F4F831) >> 64;\r\n            }\r\n            if (x & 0x100000000000 > 0) {\r\n                result = (result * 0x100000B1721BCFC9A) >> 64;\r\n            }\r\n            if (x & 0x80000000000 > 0) {\r\n                result = (result * 0x10000058B90CF1E6E) >> 64;\r\n            }\r\n            if (x & 0x40000000000 > 0) {\r\n                result = (result * 0x1000002C5C863B73F) >> 64;\r\n            }\r\n            if (x & 0x20000000000 > 0) {\r\n                result = (result * 0x100000162E430E5A2) >> 64;\r\n            }\r\n            if (x & 0x10000000000 > 0) {\r\n                result = (result * 0x1000000B172183551) >> 64;\r\n            }\r\n            if (x & 0x8000000000 > 0) {\r\n                result = (result * 0x100000058B90C0B49) >> 64;\r\n            }\r\n            if (x & 0x4000000000 > 0) {\r\n                result = (result * 0x10000002C5C8601CC) >> 64;\r\n            }\r\n            if (x & 0x2000000000 > 0) {\r\n                result = (result * 0x1000000162E42FFF0) >> 64;\r\n            }\r\n            if (x & 0x1000000000 > 0) {\r\n                result = (result * 0x10000000B17217FBB) >> 64;\r\n            }\r\n            if (x & 0x800000000 > 0) {\r\n                result = (result * 0x1000000058B90BFCE) >> 64;\r\n            }\r\n            if (x & 0x400000000 > 0) {\r\n                result = (result * 0x100000002C5C85FE3) >> 64;\r\n            }\r\n            if (x & 0x200000000 > 0) {\r\n                result = (result * 0x10000000162E42FF1) >> 64;\r\n            }\r\n            if (x & 0x100000000 > 0) {\r\n                result = (result * 0x100000000B17217F8) >> 64;\r\n            }\r\n            if (x & 0x80000000 > 0) {\r\n                result = (result * 0x10000000058B90BFC) >> 64;\r\n            }\r\n            if (x & 0x40000000 > 0) {\r\n                result = (result * 0x1000000002C5C85FE) >> 64;\r\n            }\r\n            if (x & 0x20000000 > 0) {\r\n                result = (result * 0x100000000162E42FF) >> 64;\r\n            }\r\n            if (x & 0x10000000 > 0) {\r\n                result = (result * 0x1000000000B17217F) >> 64;\r\n            }\r\n            if (x & 0x8000000 > 0) {\r\n                result = (result * 0x100000000058B90C0) >> 64;\r\n            }\r\n            if (x & 0x4000000 > 0) {\r\n                result = (result * 0x10000000002C5C860) >> 64;\r\n            }\r\n            if (x & 0x2000000 > 0) {\r\n                result = (result * 0x1000000000162E430) >> 64;\r\n            }\r\n            if (x & 0x1000000 > 0) {\r\n                result = (result * 0x10000000000B17218) >> 64;\r\n            }\r\n            if (x & 0x800000 > 0) {\r\n                result = (result * 0x1000000000058B90C) >> 64;\r\n            }\r\n            if (x & 0x400000 > 0) {\r\n                result = (result * 0x100000000002C5C86) >> 64;\r\n            }\r\n            if (x & 0x200000 > 0) {\r\n                result = (result * 0x10000000000162E43) >> 64;\r\n            }\r\n            if (x & 0x100000 > 0) {\r\n                result = (result * 0x100000000000B1721) >> 64;\r\n            }\r\n            if (x & 0x80000 > 0) {\r\n                result = (result * 0x10000000000058B91) >> 64;\r\n            }\r\n            if (x & 0x40000 > 0) {\r\n                result = (result * 0x1000000000002C5C8) >> 64;\r\n            }\r\n            if (x & 0x20000 > 0) {\r\n                result = (result * 0x100000000000162E4) >> 64;\r\n            }\r\n            if (x & 0x10000 > 0) {\r\n                result = (result * 0x1000000000000B172) >> 64;\r\n            }\r\n            if (x & 0x8000 > 0) {\r\n                result = (result * 0x100000000000058B9) >> 64;\r\n            }\r\n            if (x & 0x4000 > 0) {\r\n                result = (result * 0x10000000000002C5D) >> 64;\r\n            }\r\n            if (x & 0x2000 > 0) {\r\n                result = (result * 0x1000000000000162E) >> 64;\r\n            }\r\n            if (x & 0x1000 > 0) {\r\n                result = (result * 0x10000000000000B17) >> 64;\r\n            }\r\n            if (x & 0x800 > 0) {\r\n                result = (result * 0x1000000000000058C) >> 64;\r\n            }\r\n            if (x & 0x400 > 0) {\r\n                result = (result * 0x100000000000002C6) >> 64;\r\n            }\r\n            if (x & 0x200 > 0) {\r\n                result = (result * 0x10000000000000163) >> 64;\r\n            }\r\n            if (x & 0x100 > 0) {\r\n                result = (result * 0x100000000000000B1) >> 64;\r\n            }\r\n            if (x & 0x80 > 0) {\r\n                result = (result * 0x10000000000000059) >> 64;\r\n            }\r\n            if (x & 0x40 > 0) {\r\n                result = (result * 0x1000000000000002C) >> 64;\r\n            }\r\n            if (x & 0x20 > 0) {\r\n                result = (result * 0x10000000000000016) >> 64;\r\n            }\r\n            if (x & 0x10 > 0) {\r\n                result = (result * 0x1000000000000000B) >> 64;\r\n            }\r\n            if (x & 0x8 > 0) {\r\n                result = (result * 0x10000000000000006) >> 64;\r\n            }\r\n            if (x & 0x4 > 0) {\r\n                result = (result * 0x10000000000000003) >> 64;\r\n            }\r\n            if (x & 0x2 > 0) {\r\n                result = (result * 0x10000000000000001) >> 64;\r\n            }\r\n            if (x & 0x1 > 0) {\r\n                result = (result * 0x10000000000000001) >> 64;\r\n            }\r\n\r\n            // We're doing two things at the same time:\r\n            //\r\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\r\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\r\n            //      rather than 192.\r\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\r\n            //\r\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\r\n            result *= SCALE;\r\n            result >>= (191 - (x >> 64));\r\n        }\r\n    }\r\n\r\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\r\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\r\n    /// @param x The uint256 number for which to find the index of the most significant bit.\r\n    /// @return msb The index of the most significant bit as an uint256.\r\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\r\n        if (x >= 2**128) {\r\n            x >>= 128;\r\n            msb += 128;\r\n        }\r\n        if (x >= 2**64) {\r\n            x >>= 64;\r\n            msb += 64;\r\n        }\r\n        if (x >= 2**32) {\r\n            x >>= 32;\r\n            msb += 32;\r\n        }\r\n        if (x >= 2**16) {\r\n            x >>= 16;\r\n            msb += 16;\r\n        }\r\n        if (x >= 2**8) {\r\n            x >>= 8;\r\n            msb += 8;\r\n        }\r\n        if (x >= 2**4) {\r\n            x >>= 4;\r\n            msb += 4;\r\n        }\r\n        if (x >= 2**2) {\r\n            x >>= 2;\r\n            msb += 2;\r\n        }\r\n        if (x >= 2**1) {\r\n            // No need to shift x any more.\r\n            msb += 1;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\r\n    ///\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\r\n    ///\r\n    /// Requirements:\r\n    /// - The denominator cannot be zero.\r\n    /// - The result must fit within uint256.\r\n    ///\r\n    /// Caveats:\r\n    /// - This function does not work with fixed-point numbers.\r\n    ///\r\n    /// @param x The multiplicand as an uint256.\r\n    /// @param y The multiplier as an uint256.\r\n    /// @param denominator The divisor as an uint256.\r\n    /// @return result The result as an uint256.\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2^256 + prod0.\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(x, y, not(0))\r\n            prod0 := mul(x, y)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division.\r\n        if (prod1 == 0) {\r\n            unchecked {\r\n                result = prod0 / denominator;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n        if (prod1 >= denominator) {\r\n            revert PRBMath__MulDivOverflow(prod1, denominator);\r\n        }\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0].\r\n        uint256 remainder;\r\n        assembly {\r\n            // Compute remainder using mulmod.\r\n            remainder := mulmod(x, y, denominator)\r\n\r\n            // Subtract 256 bit number from 512 bit number.\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n        // See https://cs.stackexchange.com/q/138556/92363.\r\n        unchecked {\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 lpotdod = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by lpotdod.\r\n                denominator := div(denominator, lpotdod)\r\n\r\n                // Divide [prod1 prod0] by lpotdod.\r\n                prod0 := div(prod0, lpotdod)\r\n\r\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\r\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * lpotdod;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y\u00f71e18) with full precision.\r\n    ///\r\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\r\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\r\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\r\n    ///\r\n    /// Requirements:\r\n    /// - The result must fit within uint256.\r\n    ///\r\n    /// Caveats:\r\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\r\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\r\n    ///     1. x * y = type(uint256).max * SCALE\r\n    ///     2. (x * y) % SCALE >= SCALE / 2\r\n    ///\r\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        uint256 prod0;\r\n        uint256 prod1;\r\n        assembly {\r\n            let mm := mulmod(x, y, not(0))\r\n            prod0 := mul(x, y)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        if (prod1 >= SCALE) {\r\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\r\n        }\r\n\r\n        uint256 remainder;\r\n        uint256 roundUpUnit;\r\n        assembly {\r\n            remainder := mulmod(x, y, SCALE)\r\n            roundUpUnit := gt(remainder, 499999999999999999)\r\n        }\r\n\r\n        if (prod1 == 0) {\r\n            unchecked {\r\n                result = (prod0 / SCALE) + roundUpUnit;\r\n                return result;\r\n            }\r\n        }\r\n\r\n        assembly {\r\n            result := add(\r\n                mul(\r\n                    or(\r\n                        div(sub(prod0, remainder), SCALE_LPOTD),\r\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\r\n                    ),\r\n                    SCALE_INVERSE\r\n                ),\r\n                roundUpUnit\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\r\n    ///\r\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\r\n    ///\r\n    /// Requirements:\r\n    /// - None of the inputs can be type(int256).min.\r\n    /// - The result must fit within int256.\r\n    ///\r\n    /// @param x The multiplicand as an int256.\r\n    /// @param y The multiplier as an int256.\r\n    /// @param denominator The divisor as an int256.\r\n    /// @return result The result as an int256.\r\n    function mulDivSigned(\r\n        int256 x,\r\n        int256 y,\r\n        int256 denominator\r\n    ) internal pure returns (int256 result) {\r\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\r\n            revert PRBMath__MulDivSignedInputTooSmall();\r\n        }\r\n\r\n        // Get hold of the absolute values of x, y and the denominator.\r\n        uint256 ax;\r\n        uint256 ay;\r\n        uint256 ad;\r\n        unchecked {\r\n            ax = x < 0 ? uint256(-x) : uint256(x);\r\n            ay = y < 0 ? uint256(-y) : uint256(y);\r\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\r\n        }\r\n\r\n        // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\r\n        uint256 rAbs = mulDiv(ax, ay, ad);\r\n        if (rAbs > uint256(type(int256).max)) {\r\n            revert PRBMath__MulDivSignedOverflow(rAbs);\r\n        }\r\n\r\n        // Get the signs of x, y and the denominator.\r\n        uint256 sx;\r\n        uint256 sy;\r\n        uint256 sd;\r\n        assembly {\r\n            sx := sgt(x, sub(0, 1))\r\n            sy := sgt(y, sub(0, 1))\r\n            sd := sgt(denominator, sub(0, 1))\r\n        }\r\n\r\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\r\n        // If yes, the result should be negative.\r\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\r\n    }\r\n\r\n    /// @notice Calculates the square root of x, rounding down.\r\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n    ///\r\n    /// Caveats:\r\n    /// - This function does not work with fixed-point numbers.\r\n    ///\r\n    /// @param x The uint256 number for which to calculate the square root.\r\n    /// @return result The result as an uint256.\r\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Set the initial guess to the closest power of two that is higher than x.\r\n        uint256 xAux = uint256(x);\r\n        result = 1;\r\n        if (xAux >= 0x100000000000000000000000000000000) {\r\n            xAux >>= 128;\r\n            result <<= 64;\r\n        }\r\n        if (xAux >= 0x10000000000000000) {\r\n            xAux >>= 64;\r\n            result <<= 32;\r\n        }\r\n        if (xAux >= 0x100000000) {\r\n            xAux >>= 32;\r\n            result <<= 16;\r\n        }\r\n        if (xAux >= 0x10000) {\r\n            xAux >>= 16;\r\n            result <<= 8;\r\n        }\r\n        if (xAux >= 0x100) {\r\n            xAux >>= 8;\r\n            result <<= 4;\r\n        }\r\n        if (xAux >= 0x10) {\r\n            xAux >>= 4;\r\n            result <<= 2;\r\n        }\r\n        if (xAux >= 0x8) {\r\n            result <<= 1;\r\n        }\r\n\r\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\r\n        unchecked {\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1; // Seven iterations should be enough\r\n            uint256 roundedDownResult = x / result;\r\n            return result >= roundedDownResult ? roundedDownResult : result;\r\n        }\r\n    }\r\n}\r\n\r\n// File: prb-math/contracts/PRBMathUD60x18.sol\r\n\r\n\r\npragma solidity >=0.8.4;\r\n\r\n\r\n/// @title PRBMathUD60x18\r\n/// @author Paul Razvan Berg\r\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\r\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\r\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\r\n/// maximum values permitted by the Solidity type uint256.\r\nlibrary PRBMathUD60x18 {\r\n    /// @dev Half the SCALE number.\r\n    uint256 internal constant HALF_SCALE = 5e17;\r\n\r\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\r\n    uint256 internal constant LOG2_E = 1_442695040888963407;\r\n\r\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\r\n    uint256 internal constant MAX_UD60x18 =\r\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\r\n\r\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\r\n    uint256 internal constant MAX_WHOLE_UD60x18 =\r\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\r\n\r\n    /// @dev How many trailing decimals can be represented.\r\n    uint256 internal constant SCALE = 1e18;\r\n\r\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\r\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\r\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        // The operations can never overflow.\r\n        unchecked {\r\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\r\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\r\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\r\n    ///\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\r\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\r\n    function ceil(uint256 x) internal pure returns (uint256 result) {\r\n        if (x > MAX_WHOLE_UD60x18) {\r\n            revert PRBMathUD60x18__CeilOverflow(x);\r\n        }\r\n        assembly {\r\n            // Equivalent to \"x % SCALE\" but faster.\r\n            let remainder := mod(x, SCALE)\r\n\r\n            // Equivalent to \"SCALE - remainder\" but faster.\r\n            let delta := sub(SCALE, remainder)\r\n\r\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\r\n            result := add(x, mul(delta, gt(remainder, 0)))\r\n        }\r\n    }\r\n\r\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\r\n    ///\r\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\r\n    ///\r\n    /// Requirements:\r\n    /// - The denominator cannot be zero.\r\n    ///\r\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = PRBMath.mulDiv(x, SCALE, y);\r\n    }\r\n\r\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\r\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\r\n    function e() internal pure returns (uint256 result) {\r\n        result = 2_718281828459045235;\r\n    }\r\n\r\n    /// @notice Calculates the natural exponent of x.\r\n    ///\r\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    /// - x must be less than 133.084258667509499441.\r\n    ///\r\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp(uint256 x) internal pure returns (uint256 result) {\r\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\r\n        if (x >= 133_084258667509499441) {\r\n            revert PRBMathUD60x18__ExpInputTooBig(x);\r\n        }\r\n\r\n        // Do the fixed-point multiplication inline to save gas.\r\n        unchecked {\r\n            uint256 doubleScaleProduct = x * LOG2_E;\r\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\r\n    ///\r\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be 192 or less.\r\n    /// - The result must fit within MAX_UD60x18.\r\n    ///\r\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp2(uint256 x) internal pure returns (uint256 result) {\r\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\r\n        if (x >= 192e18) {\r\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\r\n        }\r\n\r\n        unchecked {\r\n            // Convert x to the 192.64-bit fixed-point format.\r\n            uint256 x192x64 = (x << 64) / SCALE;\r\n\r\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\r\n            result = PRBMath.exp2(x192x64);\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\r\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\r\n    function floor(uint256 x) internal pure returns (uint256 result) {\r\n        assembly {\r\n            // Equivalent to \"x % SCALE\" but faster.\r\n            let remainder := mod(x, SCALE)\r\n\r\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\r\n            result := sub(x, mul(remainder, gt(remainder, 0)))\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the excess beyond the floor of x.\r\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\r\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\r\n    function frac(uint256 x) internal pure returns (uint256 result) {\r\n        assembly {\r\n            result := mod(x, SCALE)\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\r\n    ///\r\n    /// @param x The basic integer to convert.\r\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\r\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            if (x > MAX_UD60x18 / SCALE) {\r\n                revert PRBMathUD60x18__FromUintOverflow(x);\r\n            }\r\n            result = x * SCALE;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\r\n    ///\r\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        unchecked {\r\n            // Checking for overflow this way is faster than letting Solidity do it.\r\n            uint256 xy = x * y;\r\n            if (xy / x != y) {\r\n                revert PRBMathUD60x18__GmOverflow(x, y);\r\n            }\r\n\r\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\r\n            // during multiplication. See the comments within the \"sqrt\" function.\r\n            result = PRBMath.sqrt(xy);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates 1 / x, rounding toward zero.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x cannot be zero.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\r\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\r\n    function inv(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 1e36 is SCALE * SCALE.\r\n            result = 1e36 / x;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the natural logarithm of x.\r\n    ///\r\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\r\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\r\n    function ln(uint256 x) internal pure returns (uint256 result) {\r\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\r\n        // can return is 196205294292027477728.\r\n        unchecked {\r\n            result = (log2(x) * SCALE) / LOG2_E;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the common logarithm of x.\r\n    ///\r\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\r\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\r\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\r\n    function log10(uint256 x) internal pure returns (uint256 result) {\r\n        if (x < SCALE) {\r\n            revert PRBMathUD60x18__LogInputTooSmall(x);\r\n        }\r\n\r\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\r\n        // in this contract.\r\n        // prettier-ignore\r\n        assembly {\r\n            switch x\r\n            case 1 { result := mul(SCALE, sub(0, 18)) }\r\n            case 10 { result := mul(SCALE, sub(1, 18)) }\r\n            case 100 { result := mul(SCALE, sub(2, 18)) }\r\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\r\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\r\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\r\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\r\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\r\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\r\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\r\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\r\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\r\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\r\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\r\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\r\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\r\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\r\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\r\n            case 1000000000000000000 { result := 0 }\r\n            case 10000000000000000000 { result := SCALE }\r\n            case 100000000000000000000 { result := mul(SCALE, 2) }\r\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\r\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\r\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\r\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\r\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\r\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\r\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\r\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\r\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\r\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\r\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\r\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\r\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\r\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\r\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\r\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\r\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\r\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\r\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\r\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\r\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\r\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\r\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\r\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\r\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\r\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\r\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\r\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\r\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\r\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\r\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\r\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\r\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\r\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\r\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\r\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\r\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\r\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\r\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\r\n            default {\r\n                result := MAX_UD60x18\r\n            }\r\n        }\r\n\r\n        if (result == MAX_UD60x18) {\r\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\r\n            unchecked {\r\n                result = (log2(x) * SCALE) / 3_321928094887362347;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary logarithm of x.\r\n    ///\r\n    /// @dev Based on the iterative approximation algorithm.\r\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\r\n    ///\r\n    /// Caveats:\r\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\r\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\r\n    function log2(uint256 x) internal pure returns (uint256 result) {\r\n        if (x < SCALE) {\r\n            revert PRBMathUD60x18__LogInputTooSmall(x);\r\n        }\r\n        unchecked {\r\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\r\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\r\n\r\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\r\n            // because n is maximum 255 and SCALE is 1e18.\r\n            result = n * SCALE;\r\n\r\n            // This is y = x * 2^(-n).\r\n            uint256 y = x >> n;\r\n\r\n            // If y = 1, the fractional part is zero.\r\n            if (y == SCALE) {\r\n                return result;\r\n            }\r\n\r\n            // Calculate the fractional part via the iterative approximation.\r\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\r\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\r\n                y = (y * y) / SCALE;\r\n\r\n                // Is y^2 > 2 and so in the range [2,4)?\r\n                if (y >= 2 * SCALE) {\r\n                    // Add the 2^(-m) factor to the logarithm.\r\n                    result += delta;\r\n\r\n                    // Corresponds to z/2 on Wikipedia.\r\n                    y >>= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\r\n    /// fixed-point number.\r\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\r\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = PRBMath.mulDivFixedPoint(x, y);\r\n    }\r\n\r\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\r\n    function pi() internal pure returns (uint256 result) {\r\n        result = 3_141592653589793238;\r\n    }\r\n\r\n    /// @notice Raises x to the power of y.\r\n    ///\r\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\r\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            result = y == 0 ? SCALE : uint256(0);\r\n        } else {\r\n            result = exp2(mul(log2(x), y));\r\n        }\r\n    }\r\n\r\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\r\n    /// famous algorithm \"exponentiation by squaring\".\r\n    ///\r\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\r\n    ///\r\n    /// Requirements:\r\n    /// - The result must fit within MAX_UD60x18.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"mul\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The exponent as an uint256.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        // Calculate the first iteration of the loop in advance.\r\n        result = y & 1 > 0 ? x : SCALE;\r\n\r\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\r\n        for (y >>= 1; y > 0; y >>= 1) {\r\n            x = PRBMath.mulDivFixedPoint(x, x);\r\n\r\n            // Equivalent to \"y % 2 == 1\" but faster.\r\n            if (y & 1 > 0) {\r\n                result = PRBMath.mulDivFixedPoint(result, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\r\n    function scale() internal pure returns (uint256 result) {\r\n        result = SCALE;\r\n    }\r\n\r\n    /// @notice Calculates the square root of x, rounding down.\r\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be less than MAX_UD60x18 / SCALE.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\r\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            if (x > MAX_UD60x18 / SCALE) {\r\n                revert PRBMathUD60x18__SqrtOverflow(x);\r\n            }\r\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\r\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\r\n            result = PRBMath.sqrt(x * SCALE);\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\r\n    /// @return result The same number in basic integer form.\r\n    function toUint(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            result = x / SCALE;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Mittens.sol\r\n\r\npragma solidity >=0.8.3;\r\n\r\n\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n}\r\n\r\ncontract Mittens is ERC20, Ownable {\r\n    using PRBMathUD60x18 for uint256;\r\n\r\n    uint256 private constant _initialTotalEmission = 1e12;\r\n    address private _devAddress =\r\n        address(0x6Ea2075a5144A10923F240E7b4d405Bf7A92E1e9);\r\n    address private _marketingAddress =\r\n        address(0x3831F5A0076AA624c6d16Ce72F66c3A83595A1EE);\r\n    uint256 constant devPercent = 4e16;\r\n    uint256 constant marketingPercent = 5e16;\r\n    uint256 constant burnPercent = 1e16;\r\n    uint256 public minTxSecondsInterval = 60; // if 0 than not enabled\r\n    mapping(address => bool) private _bots;\r\n    mapping(address => bool) private _isExcludedFromFee;\r\n    mapping(address => uint256) _lastBuyTimes;\r\n    IUniswapV2Router02 constant _uniswapRouter =\r\n        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n    address public uniswapPair;\r\n    uint256 public maxBuy;\r\n    bool public noTaxMode;\r\n\r\n    constructor() ERC20(\"MITTENS Token\", \"MITTENS\") {\r\n        _mint(address(this), _initialTotalEmission * 10**decimals());\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[_devAddress] = true;\r\n        _isExcludedFromFee[_marketingAddress] = true;\r\n        _isExcludedFromFee[address(_uniswapRouter)] = true;\r\n        setMaxBuy(15e9);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        if (to != address(0)) require(!_bots[from] && !_bots[to]);\r\n        QuickSaleLimit(from, to);\r\n    }\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        // take tax on transfer\r\n        if (from != address(0) && to != address(0)) {\r\n            GetFees(to, amount);\r\n        }\r\n\r\n        if (maxBuy > 0 && !_isExcludedFromFee[to])\r\n            require(balanceOf(to) <= maxBuy, \"max buy limit\");\r\n    }\r\n\r\n    function QuickSaleLimit(address from, address to) internal {\r\n        // \u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0438\u0442\u0435\u043b\u0438\r\n        if (\r\n            minTxSecondsInterval == 0 ||\r\n            from == address(0) ||\r\n            to == address(0) ||\r\n            from == to\r\n        ) return;\r\n        // \u0435\u0441\u043b\u0438 \u0431\u044b\u043b\u0430 \u043f\u043e\u043a\u0443\u043f\u043a\u0430 \u0441 \u043e\u0431\u043c\u0435\u043d\u043d\u0438\u043a\u0430 \u0442\u043e \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c \u043a\u043e\u0433\u0434\u0430 \u043e\u043d\u0430 \u0431\u044b\u043b\u0430 \u0438 \u0434\u0430\u043b\u0435\u0435 \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435 \u0434\u0435\u043b\u0430\u0435\u043c\r\n        if (from == uniswapPair) {\r\n            _lastBuyTimes[to] = block.timestamp; // \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c \u043a\u043e\u0433\u0434\u0430 \u0431\u044b\u043b\u0430 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u044f\u044f \u043f\u043e\u043a\u0443\u043f\u043a\u0430\r\n            return;\r\n        }\r\n        // \u0435\u0441\u043b\u0438 \u0438\u0434\u0435\u0442 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0430 \u043d\u0430 \u043e\u0431\u043c\u0435\u043d\u043d\u0438\u043a (\u043f\u0440\u043e\u0434\u0430\u0436\u0430 \u0442\u043e\u043a\u0435\u043d\u0430)\r\n        if (to == uniswapPair) {\r\n            uint256 timeInterval = block.timestamp - _lastBuyTimes[from];\r\n            require(\r\n                timeInterval >= minTxSecondsInterval * 1 seconds,\r\n                \"quick sale\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function GetFees(address acc, uint256 amount) private {\r\n        if (noTaxMode || uniswapPair == address(0) || _isExcludedFromFee[acc])\r\n            return;\r\n        GetBurnFee(acc, amount);\r\n        GetDevFee(acc, amount);\r\n        GetMarketingFee(acc, amount);\r\n    }\r\n\r\n    function GetDevFee(address acc, uint256 amount) private {\r\n        // calculating the tax\r\n        uint256 tax = PRBMathUD60x18.mul(amount, devPercent);\r\n        uint256 balance = balanceOf(acc);\r\n        if (tax > balance) tax = balance;\r\n        // burn tax\r\n        _burn(acc, tax);\r\n        // send to dev addr\r\n        _mint(_devAddress, tax);\r\n    }\r\n\r\n    function GetMarketingFee(address acc, uint256 amount) private {\r\n        // calculating the tax\r\n        uint256 tax = PRBMathUD60x18.mul(amount, marketingPercent);\r\n        uint256 balance = balanceOf(acc);\r\n        if (tax > balance) tax = balance;\r\n        // burn tax\r\n        _burn(acc, tax);\r\n        // send to marketing addr\r\n        _mint(_marketingAddress, tax);\r\n    }\r\n\r\n    function GetBurnFee(address acc, uint256 amount) private {\r\n        // calculating the tax\r\n        uint256 tax = PRBMathUD60x18.mul(amount, burnPercent);\r\n        uint256 balance = balanceOf(acc);\r\n        if (tax > balance) tax = balance;\r\n        // burn tax\r\n        _burn(acc, tax);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function openTrading() external onlyOwner {\r\n        require(uniswapPair == address(0), \"trading is already open\");\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        _approve(address(this), address(_uniswapRouter), contractBalance);\r\n        uniswapPair = IUniswapV2Factory(_uniswapRouter.factory()).createPair(\r\n            address(this),\r\n            _uniswapRouter.WETH()\r\n        );\r\n        _isExcludedFromFee[uniswapPair] = true;\r\n        _uniswapRouter.addLiquidityETH{value: address(this).balance}(\r\n            address(this),\r\n            contractBalance,\r\n            0,\r\n            0,\r\n            owner(),\r\n            block.timestamp\r\n        );\r\n        IERC20(uniswapPair).approve(address(_uniswapRouter), type(uint256).max);\r\n    }\r\n\r\n    function setMaxBuy(uint256 newMaxBuy) public onlyOwner {\r\n        maxBuy = newMaxBuy * 10**decimals();\r\n    }\r\n\r\n    function setMarketingWallet(address marketingWalletAddress) external {\r\n        require(_msgSender() == _marketingAddress);\r\n        _isExcludedFromFee[_marketingAddress] = false;\r\n        _marketingAddress = marketingWalletAddress;\r\n        _isExcludedFromFee[_marketingAddress] = true;\r\n    }\r\n\r\n    function setDevWallet(address devWalletAddress) external {\r\n        require(_msgSender() == _devAddress);\r\n        _isExcludedFromFee[_devAddress] = false;\r\n        _devAddress = devWalletAddress;\r\n        _isExcludedFromFee[_devAddress] = true;\r\n    }\r\n\r\n    function excludeFromFee(address ad) external {\r\n        require(_msgSender() == _devAddress);\r\n        _isExcludedFromFee[ad] = true;\r\n    }\r\n\r\n    function includeToFee(address ad) external {\r\n        require(_msgSender() == _devAddress);\r\n        _isExcludedFromFee[ad] = false;\r\n    }\r\n\r\n    function setNoTaxMode(bool onoff) external {\r\n        require(_msgSender() == _devAddress);\r\n        noTaxMode = onoff;\r\n    }\r\n\r\n    function setBots(address[] memory bots_) public onlyOwner {\r\n        for (uint256 i = 0; i < bots_.length; i++) {\r\n            if (\r\n                bots_[i] != uniswapPair && bots_[i] != address(_uniswapRouter)\r\n            ) {\r\n                _bots[bots_[i]] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function delBot(address notbot) public onlyOwner {\r\n        _bots[notbot] = false;\r\n    }\r\n\r\n    function burnBot(address bot) public onlyOwner {\r\n        require(_bots[bot], \"is not bot\");\r\n        _burn(bot, balanceOf(bot));\r\n    }\r\n\r\n    function isBot(address ad) public view returns (bool) {\r\n        return _bots[ad];\r\n    }\r\n\r\n    function setminTxSecondsInterval(uint256 newMinTxSecondsInterval)\r\n        public\r\n        onlyOwner\r\n    {\r\n        minTxSecondsInterval = newMinTxSecondsInterval * 1 seconds;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivFixedPointOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bot\",\"type\":\"address\"}],\"name\":\"burnBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"notbot\",\"type\":\"address\"}],\"name\":\"delBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ad\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ad\",\"type\":\"address\"}],\"name\":\"includeToFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ad\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTxSecondsInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noTaxMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"bots_\",\"type\":\"address[]\"}],\"name\":\"setBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"devWalletAddress\",\"type\":\"address\"}],\"name\":\"setDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketingWalletAddress\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxBuy\",\"type\":\"uint256\"}],\"name\":\"setMaxBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"onoff\",\"type\":\"bool\"}],\"name\":\"setNoTaxMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinTxSecondsInterval\",\"type\":\"uint256\"}],\"name\":\"setminTxSecondsInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Mittens", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8f7aa7b5adb12bbe558060d7741c83c3a35d53aa7f19640fa736294ce667b77e"}