{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Banana_Repo_Project.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.21;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\\\";\\r\\nimport \\\"./RepoErrors.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\"; // interface\\r\\n\\r\\n/// @title Banana Repo Project\\r\\n/// @author Boonana\\r\\n/// @notice A smart contract that allows one to sell repos of whitelisted tokens. Liquidity (repo buyers) is provided by users. If a repo seller does not repurchase their asset, it defaults to liquidity providers\\r\\ncontract BananaRepoProject is Ownable {\\r\\n\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                  Structs                                //\\r\\n    /////////////////////////////////////////////////////////////////////////////\\r\\n\\tstruct repo {\\r\\n\\t\\tuint256 expirationTime;\\r\\n\\t\\tuint256 repoTokenAmount;\\r\\n\\t}\\r\\n\\r\\n\\tstruct pendingDeposit {\\r\\n\\t\\tuint256 activationTime;\\r\\n\\t\\tuint256 amount;\\r\\n\\t}\\r\\n\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                  Constants                              //\\r\\n    /////////////////////////////////////////////////////////////////////////////\\r\\n\\t\\r\\n\\taddress public immutable currencyToken;\\r\\n\\taddress public immutable repoToken;\\r\\n\\tuint256 public constant PRECISION = 1e18;\\r\\n\\t\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                  Storage                                //\\r\\n    /////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n\\tmapping (address => uint256) public userCurrencyBalances; // how much each address is owed in Currency Token\\r\\n\\taddress[] public clearedDepositorsList;\\r\\n\\tuint256 public totalClearedBalance; // sum of the balances in userCurrencyBalances\\r\\n\\tuint256 public totalEligibleBalance; // sum of the balances in userCurrencyBalances, minus any that are \\\"reserved\\\" in other repos. i.e. the amount that can be used for another repo at the moment\\r\\n\\tmapping (address => uint256) public userDefaultBalances;  // how much each address is owed in repoToken\\r\\n\\t\\r\\n\\t//  Implementation notes:\\r\\n\\t// 1. When you deposit, your deposit will go in as a pending deposit with an activation time set pendingTime seconds in the future. In other words, your deposit will only be able to participate after the activation time.\\r\\n\\t// 2. If you deposit and you have previous pending deposits whose pending time has not yet passed, your deposited amount will be added to the pending balance and the activation time will reset. \\r\\n\\t// THEY WILL NOT BE CONSIDERED TWO DIFFERENT DEPOSITS WITH TWO DIFFERENT PENDING TIMES.\\r\\n\\t// 3. However, every time you deposit, the code will first clear any pending deposits of yours whose activationTime have passed automatically, so rest assured cleared pending deposits will not be reset. \\r\\n\\t// 4. Whenever a repo is initiated, all pending deposits whose activation time have passed will be cleared.\\r\\n\\t// 5. You can withdraw before activationTime has passed on a pending deposit; the activation time only applies to if the money can be used in repos.\\r\\n\\t// 6. If you have both pending and active balances, and withdraw, the balance will first be taken out of your pending balance - LIFO.\\r\\n\\r\\n\\tmapping (address => pendingDeposit) public pendingBalances; // deposits that are not eligible to participate in repo transactions yet. If you deposit again before these activate, your time will restart. \\r\\n\\taddress[] public pendingAddressList; // list of addresses currently with pending balances\\r\\n\\r\\n\\tmapping (address => repo) public activeRepos; // stores all active repos at the moment\\r\\n\\taddress[] public reposUsersList;\\r\\n\\tuint256 public repoSellPrice;\\r\\n\\tuint256 public repoBuybackPrice;\\r\\n\\tuint256 public repoTimeLength;\\r\\n\\tuint256 public pendingTime; // a pending time can be set to prevent users from only depositing when repos have been bought and not depositing otherwise. Would make sense to be set equal to repoTimeLength\\r\\n\\tuint256 public withdrawActivationTime; // after a default, all individuals must wait defaultWithdrawBuffer time to withdraw. Default set to 0.\\r\\n\\tuint256 public defaultWithdrawBuffer; // buffer to add after a withdraw to guard against any attacks via the default code. Default is set to 0\\r\\n\\tbool public reposPaused; // default set to false;\\r\\n\\t\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                  Events                                 //\\r\\n    /////////////////////////////////////////////////////////////////////////////\\r\\n    event Deposit(address indexed user, uint256 amount);\\r\\n\\tevent Withdraw(address indexed user, address indexed token, uint256 amount);\\r\\n\\tevent repoSold(address indexed seller, uint256 repoTokenAmount, uint256 currencyTokenAmount);\\r\\n\\tevent repoBoughtBack(address indexed buyer, uint256 repoTokenAmount, uint256 currencyTokenAmount);\\r\\n\\tevent repoDefault(address indexed defaulter, uint256 repoTokenAmount, uint256 currencyTokenAmount);\\r\\n\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                  CONSTRUCTOR                            //\\r\\n    /////////////////////////////////////////////////////////////////////////////\\r\\n\\t// @notice constructor\\r\\n\\t// @param _currencyToken Address of the currency token.\\r\\n    // @param _repoToken Address of the repo token - the token the contract has open repo bids for.\\r\\n    // @param _repoSellPrice Sell price for 1e18 units of repoToken. Necessary since you can't store fractions :(.\\r\\n    // @param _repoBuybackPrice Buyback price for 1e18 shares of repoToken. Necessary to do price fo 1e18 since you can't store fractions :(.\\r\\n    // @param _repoTimeLength Amount of time in seconds before a buyback option for a repo expires.\\r\\n\\t// @param _pendingTime Amount of time in seconds before deposited funds can participate in repo transactions\\r\\n\\tconstructor(address _currencyToken, address _repoToken,  uint256 _repoSellPrice, uint256 _repoBuybackPrice, uint256 _repoTimeLength, uint256 _pendingTime) Ownable(_msgSender()) {\\r\\n\\t\\tcurrencyToken = _currencyToken;\\r\\n\\t\\trepoToken = _repoToken;\\r\\n\\t\\trepoSellPrice = _repoSellPrice;\\r\\n\\t\\trepoBuybackPrice = _repoBuybackPrice;\\r\\n\\t\\trepoTimeLength = _repoTimeLength;\\r\\n\\t\\tpendingTime = _pendingTime;\\r\\n\\t}\\r\\n\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                   VIEWS                                 //\\r\\n    /////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n\\t// @notice shows how much _address is owed in both tokens (currencyToken and repoToken). Note this may not be withdrawable at the moment if some funds were used to buy repos.\\r\\n\\t// @param _address the address to check owed balance for\\r\\n\\tfunction getOwedBalance(address _address) external view returns (uint256, uint256) {\\r\\n\\t\\treturn (pendingBalances[_address].amount + userCurrencyBalances[_address], userDefaultBalances[_address]);\\r\\n\\t}\\r\\n\\r\\n\\t// @notice shows how much _address can currently withdraw in both tokens (currencyToken and repoToken). Note they may be owed more, but some is not withdrawable because it is currently used to buy repos. Both pending and cleared balances are withdrawable.\\r\\n\\t// @param _address the address to check withdrawable balance for\\r\\n\\tfunction getWithdrawableBalance(address _address) external view returns (uint256, uint256) {\\r\\n\\t\\tuint256 withdrawableCurrencyBalance = (totalEligibleBalance > userCurrencyBalances[_address]) ? (userCurrencyBalances[_address] + pendingBalances[_address].amount) : (totalEligibleBalance + pendingBalances[_address].amount);\\r\\n\\t\\treturn (withdrawableCurrencyBalance, userDefaultBalances[_address]);\\r\\n\\t}\\r\\n\\r\\n\\t// @notice returns true if the repo for a given address is expired, returns false if not or if the user does not have an active repo\\r\\n\\t// @param the user whose repos to check\\r\\n\\tfunction checkRepoExpiration(address _address) external view returns (bool) {\\r\\n\\r\\n\\t\\tuint256 expirationTime = activeRepos[_address].expirationTime;\\r\\n\\t\\tif (expirationTime == 0) {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t} else if (block.timestamp > expirationTime) {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn false;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// @notice protocol earns money off rounding errors (i.e. if 10 tokens are split 1/3 1/3 1/3, then those are all roudned down and the remainder is protocol profit) or when there are no cleared balances when a repo is bought back (rare)\\r\\n\\t// protocol profit as a result should be very small, but is always borrowable as it is included in totalEligibleBalance\\r\\n\\tfunction getProtocolProfits() public view returns (uint256, uint256) {\\r\\n\\t\\t\\r\\n\\t\\tuint256 contractCurrencyBalance = IERC20(currencyToken).balanceOf(address(this));\\r\\n\\t\\t\\r\\n\\t\\tuint256 pendingListLength = pendingAddressList.length;\\r\\n\\t\\tuint256 pendingBalanceSum;\\r\\n\\t\\tfor (uint256 i=0; i<pendingListLength; ++i) {\\r\\n\\t\\t\\tpendingBalanceSum += pendingBalances[pendingAddressList[i]].amount;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuint256 currencyTokenProfit = contractCurrencyBalance - totalEligibleBalance - pendingBalanceSum;\\r\\n\\r\\n\\t\\tuint256 repoListLength = reposUsersList.length;\\r\\n\\t\\tuint256 repoTokenAmountSum;\\r\\n\\t\\tfor (uint256 i = 0; i<repoListLength; ++i) {\\r\\n\\t\\t\\trepoTokenAmountSum += activeRepos[reposUsersList[i]].repoTokenAmount;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuint256 clearedDepositorLength = clearedDepositorsList.length;\\r\\n\\t\\tuint256 defaultBalanceSum;\\r\\n\\t\\tfor (uint256 i = 0; i<clearedDepositorLength; ++i) {\\r\\n\\t\\t\\tdefaultBalanceSum += userDefaultBalances[clearedDepositorsList[i]];\\r\\n\\t\\t}\\r\\n\\t\\t\\r\\n\\t\\treturn (currencyTokenProfit, IERC20(repoToken).balanceOf(address(this)) - repoTokenAmountSum - defaultBalanceSum);\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Checks the maximum amount of currencyToken available to buy a repo with at the moment in the protocol\\r\\n\\tfunction getTotalCurrencyAvailableForRepo() external view returns (uint256) {\\r\\n\\r\\n\\t\\tuint256 pendingListLength = pendingAddressList.length;\\r\\n\\t\\tuint256 pendingBalanceSum;\\r\\n\\t\\tuint256 curTimestamp = block.timestamp;\\r\\n\\t\\tfor (uint256 i=0; i<pendingListLength; ++i) {\\r\\n\\t\\t\\tif (curTimestamp > pendingBalances[pendingAddressList[i]].activationTime) {\\r\\n\\t\\t\\t\\tpendingBalanceSum += pendingBalances[pendingAddressList[i]].amount;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn (pendingBalanceSum + totalEligibleBalance);\\r\\n\\t}\\r\\n\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                  CORE - DEPOSITORS                      //\\r\\n    /////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n\\t/// @notice Deposit funds into the user's balance.\\r\\n\\t/// @param _amount The amount to deposit.\\r\\n\\tfunction depositFunds(uint256 _amount) external {\\r\\n\\r\\n\\t\\tIERC20(currencyToken).transferFrom(msg.sender, address(this), _amount);\\r\\n\\r\\n\\t\\t_clearPendingBalanceUser(msg.sender); // if there are any pending balances by this user, first clear them\\r\\n\\t\\tuint256 currentTime = block.timestamp;\\r\\n\\t\\tif (_amount == 0) return; // nothing to do\\r\\n\\t\\tif (pendingBalances[msg.sender].amount == 0) {\\r\\n\\r\\n\\t\\t\\t// if it doesn't exist yet, add to pendingAddressList\\r\\n\\t\\t\\tpendingAddressList.push(msg.sender);\\r\\n\\t\\t} \\r\\n\\r\\n\\t\\tpendingBalances[msg.sender].amount += _amount; // \\r\\n\\t\\tpendingBalances[msg.sender].activationTime = currentTime + pendingTime; // activation time reset\\r\\n\\t\\t\\r\\n\\t\\temit Deposit(msg.sender, _amount);\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice \\r\\n\\t/// @param _token is the token to withdraw\\r\\n\\t/// @param _amount is the amount to withdraw\\r\\n\\tfunction withdrawFunds(address _token, uint256 _amount) external {\\r\\n\\r\\n\\t\\tif (block.timestamp < withdrawActivationTime) revert RepoErrors.CannotWithdrawUntilWithdrawActivationTime();\\r\\n\\r\\n\\t\\tif (_token == currencyToken) {\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tuint256 currentBalance = userCurrencyBalances[msg.sender];\\r\\n\\t\\t\\tuint256 pendingBalance = pendingBalances[msg.sender].amount;\\r\\n\\t\\t\\tif (currentBalance + pendingBalance < _amount) revert RepoErrors.InsufficientBalance();\\r\\n\\r\\n\\t\\t\\tif (_amount >= pendingBalance) {\\r\\n\\r\\n\\t\\t\\t\\t// we subtract from pending balance first to benefit depositor the most; LIFO\\r\\n\\t\\t\\t\\tuint256 remainingBalance = (_amount- pendingBalance);\\r\\n\\t\\t\\t\\t// see RepoErros.sol for explanation\\r\\n\\t\\t\\t\\tif (totalEligibleBalance < remainingBalance) revert RepoErrors.WithdrawingMoreThanEligible();\\r\\n\\r\\n\\t\\t\\t\\tuserCurrencyBalances[msg.sender] -= remainingBalance;\\r\\n\\t\\t\\t\\tif (currentBalance == remainingBalance) {\\r\\n\\r\\n\\t\\t\\t\\t\\t_removeClearedDepositorsListUser(msg.sender); // the user has no cleared balance left\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\ttotalClearedBalance -= remainingBalance;\\r\\n\\t\\t\\t\\ttotalEligibleBalance -= remainingBalance;\\r\\n\\r\\n\\t\\t\\t\\tdelete pendingBalances[msg.sender];\\r\\n\\t\\t\\t\\t_removePendingAddressListUser(msg.sender);\\r\\n\\t\\t\\t} else {\\r\\n\\r\\n\\t\\t\\t\\tpendingBalances[msg.sender].amount -= _amount; // we subtract from pending balance first to benefit depositor the most; LIFO\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tIERC20(currencyToken).transfer(msg.sender, _amount);\\r\\n\\t\\t\\t\\r\\n\\t\\t} else if (_token == repoToken) {\\r\\n\\r\\n\\t\\t\\t// amount of tokens user currently is owed\\r\\n\\t\\t\\tif (userDefaultBalances[msg.sender] < _amount) revert RepoErrors.InsufficientBalance();\\r\\n\\r\\n\\t\\t\\tuserDefaultBalances[msg.sender] -= _amount;\\r\\n\\t\\t\\tIERC20(repoToken).transfer(msg.sender, _amount);\\r\\n\\t\\t} else {\\r\\n\\r\\n\\t\\t\\trevert RepoErrors.InvalidToken();\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\temit Withdraw(msg.sender, _token, _amount);\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Allows users to withdraw their total owed balance. Note: may fail if some owed balance is currently part of a sold repo\\r\\n \\t/// @dev External function that allows users to withdraw their available balances for currency and repo tokens.\\r\\n\\tfunction withdrawAll() external {\\r\\n\\r\\n\\t\\tif (block.timestamp < withdrawActivationTime) revert RepoErrors.CannotWithdrawUntilWithdrawActivationTime();\\r\\n\\r\\n\\t\\tuint256 userClearedBalance = userCurrencyBalances[msg.sender];\\r\\n\\t\\tuint256 userPendingBalance = pendingBalances[msg.sender].amount;\\r\\n\\t\\tuint256 userCurrencyBalance = userClearedBalance + userPendingBalance;\\r\\n\\t\\tuint256 userDefaultBalance = userDefaultBalances[msg.sender];\\r\\n\\r\\n\\t\\tif (userCurrencyBalance == 0 && userDefaultBalance == 0) revert RepoErrors.NothingToWithdraw();\\r\\n\\t\\tif (userClearedBalance > totalEligibleBalance) revert RepoErrors.WithdrawingMoreThanEligible();\\r\\n\\r\\n\\t\\tif (userCurrencyBalance > 0) {\\r\\n\\r\\n\\t\\t\\tif (userPendingBalance > 0) {\\r\\n\\t\\t\\t\\tdelete pendingBalances[msg.sender];\\r\\n\\t\\t\\t\\t_removePendingAddressListUser(msg.sender);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\ttotalClearedBalance -= userClearedBalance;\\r\\n\\t\\t\\ttotalEligibleBalance -= userClearedBalance;\\r\\n\\t\\t\\tdelete userCurrencyBalances[msg.sender];\\t\\t\\t\\r\\n\\r\\n\\t\\t\\tIERC20(currencyToken).transfer(msg.sender, userCurrencyBalance);\\r\\n\\t\\t\\temit Withdraw(msg.sender, currencyToken, userCurrencyBalance);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (userDefaultBalance > 0) {\\r\\n\\r\\n\\t\\t\\tdelete userDefaultBalances[msg.sender];\\r\\n\\t\\t\\tIERC20(repoToken).transfer(msg.sender, userDefaultBalance);\\r\\n\\t\\t\\temit Withdraw(msg.sender, repoToken, userDefaultBalance);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_removeClearedDepositorsListUser(msg.sender);\\r\\n\\t}\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                  CORE - REPO SELLERS                    //\\r\\n    /////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n\\t/// @notice Allows the selling of repo tokens.\\r\\n\\t/// @param _repoTokenAmount The amount of repo tokens to sell.\\r\\n\\tfunction sellRepo(uint256 _repoTokenAmount) external {\\r\\n\\r\\n\\t\\tif (reposPaused) revert RepoErrors.RepoPaused();\\r\\n\\t\\tif (activeRepos[msg.sender].repoTokenAmount > 0) revert RepoErrors.RepoAlreadyExistsForUser();\\r\\n\\r\\n\\t\\tclearPendingBalances(); // any pending balances, clear, to maximize totalEligibleBalance\\r\\n\\t\\tuint256 currencyTokenAmount = _repoTokenAmount*repoSellPrice/PRECISION;\\r\\n\\r\\n\\t\\tif (currencyTokenAmount > totalEligibleBalance) revert RepoErrors.InsufficientEligibleCurrencyAmount();\\r\\n\\r\\n\\t\\tIERC20(repoToken).transferFrom(msg.sender, address(this), _repoTokenAmount);\\r\\n\\t\\tIERC20(currencyToken).transfer(msg.sender, currencyTokenAmount);\\r\\n\\r\\n\\t\\tuint256 expirationTime = block.timestamp + repoTimeLength;\\r\\n\\t\\tactiveRepos[msg.sender].expirationTime = expirationTime;\\r\\n\\t\\tactiveRepos[msg.sender].repoTokenAmount = _repoTokenAmount;\\r\\n\\t\\treposUsersList.push(msg.sender);\\r\\n\\r\\n\\t\\ttotalEligibleBalance -= currencyTokenAmount;\\r\\n\\t\\temit repoSold(msg.sender, _repoTokenAmount, currencyTokenAmount);\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Allows the buyback of repo tokens.\\r\\n\\tfunction buybackRepo() external {\\r\\n\\t\\t\\r\\n\\t\\trepo memory userRepo = activeRepos[msg.sender];\\r\\n\\t\\tif (userRepo.expirationTime == 0) revert RepoErrors.NoActiveRepoForUser();\\r\\n\\t\\t// if (block.timestamp > userRepo.expirationTime) revert RepoErrors.RepoExpired();\\r\\n\\r\\n\\t\\tuint256 currencyTokenAmount = userRepo.repoTokenAmount*repoBuybackPrice/PRECISION;\\r\\n\\r\\n\\t\\tIERC20(currencyToken).transferFrom(msg.sender, address(this), currencyTokenAmount);\\r\\n\\t\\tIERC20(repoToken).transfer(msg.sender, userRepo.repoTokenAmount);\\r\\n\\r\\n\\t\\tclearPendingBalances(); // a bit of a tough design decision. But basically if your balance is cleared before the repo is bought back, then you benefit, even if you weren't cleared at time of deposit\\r\\n\\t\\t// the alternative is to only _clearPendingBalances() before the repo is sold. But then deposit also clears pending repos, so say, if pendingTime and repoTimeLength are 24 hours:\\r\\n\\t\\t// first deposit is T-23 hours.\\r\\n\\t\\t// repo is sold at T+0 hours\\r\\n\\t\\t// if repo isn't repaid at T+1 hour, someone could deposit again $1 and cause their balance to clear\\r\\n\\t\\t// so the criteria then becomes \\\"to guarantee eligibility without extra work deposit 24 hours before repo is sold, otherwise, with extra work you can guarantee eligibility if you deposit 24 hours before repo is repaid\\\" \\r\\n\\t\\tuint256 newBalanceAdded = currencyTokenAmount - userRepo.repoTokenAmount*repoSellPrice/PRECISION;\\r\\n\\t\\tuint256 totalClearedBalanceCopy = totalClearedBalance; // don't call this each time from storage, just save a copy in memory to save gas\\r\\n\\r\\n\\t\\tuint256 listLength = clearedDepositorsList.length;\\r\\n\\t\\tfor (uint256 i=0; i < listLength; ++i) {\\r\\n\\t\\t\\tuint256 balanceToAdd = userCurrencyBalances[clearedDepositorsList[i]] * newBalanceAdded / totalClearedBalanceCopy;\\r\\n\\t\\t\\tuserCurrencyBalances[clearedDepositorsList[i]] += balanceToAdd; // everyone's balance increases yay\\r\\n\\t\\t\\ttotalClearedBalance += balanceToAdd;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\ttotalEligibleBalance += (userRepo.repoTokenAmount*repoSellPrice/PRECISION + totalClearedBalance - totalClearedBalanceCopy);\\r\\n\\r\\n\\t\\tdelete activeRepos[msg.sender];\\r\\n\\t\\t_removeReposUsersListUser(msg.sender);\\r\\n\\r\\n\\t\\temit repoBoughtBack(msg.sender, userRepo.repoTokenAmount, currencyTokenAmount);\\r\\n\\t}\\r\\n\\r\\n\\tfunction defaultRepo(address _address) external {\\r\\n\\r\\n\\t\\trepo memory userRepo = activeRepos[_address];\\r\\n\\t\\tif (userRepo.expirationTime == 0) revert RepoErrors.NoActiveRepo(); // nothing to do\\r\\n\\t\\tif (block.timestamp <= userRepo.expirationTime) revert RepoErrors.RepoStillActive();\\r\\n\\t\\tif (block.timestamp > userRepo.expirationTime) { // repo has indeed expired\\r\\n\\r\\n\\t\\t\\tclearPendingBalances();\\r\\n\\t\\t\\tuint256 lostCurrencyBalance = userRepo.repoTokenAmount*repoSellPrice/PRECISION;\\r\\n\\t\\t\\tuint256 totalClearedBalanceCopy = totalClearedBalance; // don't call this each time from storage, just save a copy in memory to save gas\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t// see error explanation in RepoErrors.sols. This *shouldn't* be possible at the moment because withdrawals greater than totalEligibleBalance are not permitted, but having this check just in case\\r\\n\\t\\t\\tif (totalClearedBalanceCopy < lostCurrencyBalance) revert RepoErrors.InsufficientClearedDeposits(); \\r\\n\\r\\n\\t\\t\\t// high level this is what we want to do:\\r\\n\\t\\t\\t// We want to remove lostCurrencyBalance across the cleared balances, and distribute userRepo.repoTokenAmount across those\\r\\n\\t\\t\\t// Solidity division rounds towards zero. So we must be careful and err towards removing AT LEAST lostCurrencyBalance, and distributing AT MOST userRepo.repoTokenAmount, with excess going to protocol\\r\\n\\t\\t\\t// 1. we can do this for currency balances by adjusting each to be the same percentage as [totalClearedBalance - lostCurrencyBalance] as they are now of totalClearedBalance\\r\\n\\t\\t\\t// NOTE: we CANNOT subtract the amount to be subtracted multiplied proportionately across the balances, as rounding in that case may result in removing LESS than lostCurrencyBalance in total\\r\\n\\t\\t\\t// 2. we can do this for repo balances by assigning the same current percentage to the repo tokens being distributed\\r\\n\\t\\t\\tuint256 tempNewTotalClearedBalance = totalClearedBalance - lostCurrencyBalance; \\r\\n\\t\\t\\tuint256 listLength = clearedDepositorsList.length;\\r\\n\\t\\t\\tfor (uint256 i=0; i < listLength; ++i) {\\r\\n\\r\\n\\t\\t\\t\\taddress userAddress = clearedDepositorsList[i];\\r\\n\\t\\t\\t\\tuserDefaultBalances[userAddress] += userCurrencyBalances[userAddress]*userRepo.repoTokenAmount /totalClearedBalanceCopy; // as noted in 2)\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tuint256 currencyBalanceOld = userCurrencyBalances[userAddress];\\r\\n\\t\\t\\t\\tuserCurrencyBalances[userAddress] = currencyBalanceOld * tempNewTotalClearedBalance / totalClearedBalanceCopy; // as noted in 1)\\r\\n\\t\\t\\t\\tuint256 currencyBalanceSubtracted = currencyBalanceOld - userCurrencyBalances[userAddress];\\r\\n\\t\\t\\t\\ttotalClearedBalance -= currencyBalanceSubtracted;\\r\\n\\r\\n\\t\\t\\t\\tif ((userCurrencyBalances[userAddress] == 0) && (userDefaultBalances[userAddress] ==0)) _removeClearedDepositorsListUser(userAddress);\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// if removed MORE than lostCurrencyBalance, subtract excess from totalEligibleBalance\\r\\n\\t\\t\\ttotalEligibleBalance -= (tempNewTotalClearedBalance - totalClearedBalance);\\r\\n\\r\\n\\t\\t\\tdelete activeRepos[_address];\\r\\n\\t\\t\\t_removeReposUsersListUser(_address);\\r\\n\\r\\n\\t\\t\\twithdrawActivationTime = block.timestamp + defaultWithdrawBuffer;\\r\\n\\t\\t\\t\\r\\n\\t\\t\\temit repoDefault(_address, userRepo.repoTokenAmount, lostCurrencyBalance);\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Allows the owner to modify the repo sell price.\\r\\n\\tfunction editRepoSellPrice(uint256 _price) external onlyOwner {\\r\\n\\t\\trepoSellPrice = _price;\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Allows the owner to modify the repo buyback price.\\r\\n\\tfunction editRepoBuybackPrice(uint256 _price) external onlyOwner {\\r\\n\\t\\trepoBuybackPrice = _price;\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Allows the owner to modify the repo time length.\\r\\n\\tfunction editRepoTimeLength(uint256 _seconds) external onlyOwner {\\r\\n\\t\\trepoTimeLength = _seconds;\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Allows the owner to modify the pending time.\\r\\n\\tfunction editPendingTime(uint256 _seconds) external onlyOwner {\\r\\n\\t\\tpendingTime = _seconds;\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Allows the owner to pause repos.\\r\\n\\tfunction pauseRepos() external onlyOwner {\\r\\n\\t\\treposPaused = true;\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Allows the owner to unpause repos.\\r\\n\\tfunction unpauseRepos() external onlyOwner {\\r\\n\\t\\treposPaused = false;\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Allows the owner edit the withdrawActivationTime\\r\\n\\tfunction editWithdrawActivationTime(uint256 _timestamp) external onlyOwner {\\r\\n\\t\\twithdrawActivationTime = _timestamp;\\r\\n\\t}\\r\\n\\r\\n\\t// @notice Allows the owner to edit the default withdraw buffer.\\r\\n\\tfunction editDefaultWithdrawBuffer(uint256 _seconds) external onlyOwner {\\r\\n\\t\\tdefaultWithdrawBuffer = _seconds;\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                  CORE - HELPERS                         //\\r\\n    /////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n\\t/// @notice Clears pending balances by checking their activation time and moving the amounts to the users' currency balances if the activation time has passed.\\r\\n\\tfunction clearPendingBalances() public {\\r\\n\\r\\n\\t\\tuint256 i = 0;\\r\\n\\t\\tuint256 currentTimestamp = block.timestamp;\\r\\n\\r\\n\\t\\tuint256 totalAmountCleared;\\r\\n\\t\\tuint256 pendingAddressListLength = pendingAddressList.length; // saves gas to store in memory vs read each time from storage\\r\\n    \\twhile (i < pendingAddressListLength) {\\r\\n\\t\\t\\t\\r\\n\\t\\t\\taddress userAddress = pendingAddressList[i];\\r\\n\\t\\t\\tpendingDeposit memory pendingDepositUser = pendingBalances[userAddress];\\r\\n\\r\\n\\t\\t\\tif (currentTimestamp >= pendingDepositUser.activationTime) {\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\t// add to list if first time depositor\\r\\n\\t\\t\\t\\tif (userCurrencyBalances[userAddress] == 0) {\\r\\n\\t\\t\\t\\t\\tclearedDepositorsList.push(userAddress);\\r\\n\\t\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t\\tuserCurrencyBalances[userAddress] += pendingDepositUser.amount;\\r\\n\\t\\t\\t\\ttotalAmountCleared += pendingDepositUser.amount;\\r\\n\\r\\n\\t\\t\\t\\tdelete pendingBalances[userAddress];\\r\\n\\t\\t\\t\\t_removePendingAddressList(i);\\r\\n\\t\\t\\t\\tpendingAddressListLength -= 1; //reassign now that length is different\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// Increment 'i' only when not removing the element to stay at the same index\\r\\n\\t\\t\\t\\t++i;\\r\\n\\t\\t\\t}\\r\\n    \\t}\\r\\n\\r\\n\\t\\t// write to storage just once at the end to save gas\\r\\n\\t\\ttotalClearedBalance += totalAmountCleared;\\r\\n\\t\\ttotalEligibleBalance += totalAmountCleared;\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Clears pending balances for a specified user address based on the activation time; if current timestamp is past activation time, the user's pending balance is added to their userCurrencyBalance.\\r\\n\\t/// @param _address The address for which pending balances need to be cleared.\\r\\n\\tfunction _clearPendingBalanceUser(address _address) internal {\\r\\n\\r\\n\\t\\tpendingDeposit memory pendingDepositUser = pendingBalances[_address]; // saves gas to cache in memory\\r\\n\\t\\tif (pendingDepositUser.amount == 0) return; // user does not have pending Balance\\r\\n\\t\\t\\r\\n\\t\\tuint256 currentTimestamp = block.timestamp;\\r\\n\\t\\tif (currentTimestamp >= pendingDepositUser.activationTime) {\\r\\n\\r\\n\\t\\t\\t// add to list if first time depositor\\r\\n\\t\\t\\tif (userCurrencyBalances[_address] == 0) clearedDepositorsList.push(_address);\\r\\n\\r\\n\\t\\t\\tuserCurrencyBalances[_address] += pendingDepositUser.amount;\\r\\n\\t\\t\\ttotalClearedBalance += pendingDepositUser.amount;\\r\\n\\t\\t\\ttotalEligibleBalance += pendingDepositUser.amount;\\r\\n\\r\\n\\t\\t\\tdelete pendingBalances[_address];\\r\\n\\t\\t\\t_removePendingAddressListUser(_address);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Removes a specific user address from pending balance list.\\r\\n\\t/// @param _address The address to remove from pending balance list.\\r\\n\\tfunction _removePendingAddressListUser(address _address) internal {\\r\\n\\r\\n\\t\\tuint256 listLength = pendingAddressList.length;\\r\\n\\t\\tfor (uint256 i = 0; i < listLength; ++i) {\\r\\n\\t\\t\\tif (pendingAddressList[i] == _address) {\\r\\n\\t\\t\\t\\t_removePendingAddressList(i);\\r\\n\\t\\t\\t\\tbreak; // end the function after we find the user, as they should only appear once\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Remove a user from the pending balance list at the specified index in the array.\\r\\n\\t/// @param _index The index of the address in pendingAddressList to remove\\r\\n\\tfunction _removePendingAddressList(uint256 _index) internal {\\r\\n\\r\\n\\t\\tuint256 listLength = pendingAddressList.length;\\r\\n        if (_index > listLength) revert RepoErrors.InvalidIndex();\\r\\n\\r\\n\\t\\t// remove from pending address list\\r\\n\\t\\tpendingAddressList[_index] = pendingAddressList[listLength - 1];\\r\\n\\t\\tpendingAddressList.pop();\\r\\n\\r\\n\\t} \\r\\n\\r\\n\\t/// @notice Removes a specific user address from cleared deposit list.\\r\\n\\t/// @param _address The address to remove from cleared deposit list.\\r\\n\\tfunction _removeClearedDepositorsListUser(address _address) internal {\\r\\n\\r\\n\\t\\tuint256 listLength = clearedDepositorsList.length;\\r\\n\\t\\tfor (uint256 i = 0; i < listLength; ++i) {\\r\\n\\t\\t\\tif (clearedDepositorsList[i] == _address) {\\r\\n\\t\\t\\t\\t_removeClearedDepositorsList(i);\\r\\n\\t\\t\\t\\tbreak; // end the function after we find the user, as they should only appear once\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Remove a user from the cleared Deposit list at the specified index in the array.\\r\\n\\t/// @param _index The index of the address in clearedDepositList to remove\\r\\n\\tfunction _removeClearedDepositorsList(uint256 _index) internal {\\r\\n\\t\\t\\r\\n\\t\\tuint256 listLength = clearedDepositorsList.length;\\r\\n        if (_index > listLength) revert RepoErrors.InvalidIndex();\\r\\n\\r\\n\\t\\t// remove from pending address list\\r\\n\\t\\tclearedDepositorsList[_index] = clearedDepositorsList[listLength - 1];\\r\\n\\t\\tclearedDepositorsList.pop();\\r\\n\\r\\n\\t} \\r\\n\\r\\n\\t/// @notice Removes a specific user address from repos users list.\\r\\n\\t/// @param _address The address to remove from repos users list.\\r\\n\\tfunction _removeReposUsersListUser(address _address) internal {\\r\\n\\r\\n\\t\\tuint256 listLength = reposUsersList.length;\\r\\n\\t\\tfor (uint256 i = 0; i < listLength; ++i) {\\r\\n\\t\\t\\tif (reposUsersList[i] == _address) {\\r\\n\\t\\t\\t\\t_removeReposUsersList(i);\\r\\n\\t\\t\\t\\tbreak; // end the function after we find the user, as they should only appear once\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/// @notice Remove a user from the repos users list at the specified index in the array.\\r\\n\\t/// @param _index The index of the address in reposUsersList to remove\\r\\n\\tfunction _removeReposUsersList(uint256 _index) internal {\\r\\n\\t\\t\\r\\n\\t\\tuint256 listLength = reposUsersList.length;\\r\\n        if (_index > listLength) revert RepoErrors.InvalidIndex();\\r\\n\\r\\n\\t\\t// remove from pending address list\\r\\n\\t\\treposUsersList[_index] = reposUsersList[listLength - 1];\\r\\n\\t\\treposUsersList.pop();\\r\\n\\r\\n\\t}\\r\\n\\r\\n\\t/////////////////////////////////////////////////////////////////////////////\\r\\n    //                                  CORE - ADMIN                           //\\r\\n    ///////////////////////////////////////////////////////////////////////////// \\r\\n\\r\\n\\t/// @notice for emergency use if the owner needs to withdraw all tokens. If withdrawing protocol profits, should use protocolProfitWithdraw\\r\\n\\t/// @param _tokenAddress the address of the token to withdraw\\r\\n\\t/// @param _amount the amount of the token to withdraw\\r\\n\\tfunction adminWithdraw(address _tokenAddress, uint256 _amount) external onlyOwner {\\r\\n\\r\\n\\t\\tIERC20(_tokenAddress).transfer(msg.sender, _amount);\\r\\n\\t\\t\\r\\n\\t}\\r\\n\\r\\n\\t/// For withdrawing protocol profits\\r\\n\\tfunction protocolProfitWithdraw() external onlyOwner {\\r\\n\\r\\n\\t\\t(uint256 protocolCurrencyProfits, uint256 protocolRepoProfits) = getProtocolProfits();\\r\\n\\t\\tIERC20(currencyToken).transfer(msg.sender, protocolCurrencyProfits);\\r\\n\\t\\tIERC20(repoToken).transfer(msg.sender, protocolRepoProfits);\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/RepoErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.21;\\r\\n\\r\\nlibrary RepoErrors {\\r\\n    error InsufficientBalance();\\r\\n    error NothingToWithdraw();\\r\\n    error InvalidToken();\\r\\n    error InvalidIndex(); // issue with code\\r\\n    error RepoPaused();\\r\\n    error RepoAlreadyExistsForUser();\\r\\n    error InsufficientEligibleCurrencyAmount();\\r\\n    error RepoExpired();\\r\\n    error NoActiveRepo();\\r\\n    error NoActiveRepoForUser();\\r\\n    error RepoStillActive();\\r\\n\\r\\n    // so basically there is a possible case where there are no cleared Depositors.\\r\\n    //\\r\\n    // Example: \\r\\n    // 1. At the time of sellRepo, there is one cleared Depositor for 1000 currencyToken.\\r\\n    // 2. sellRepo is called, and repoToken is sold for all 1000 currencyToken.\\r\\n    // 3. The repo expires.\\r\\n    // 4. A new depositor deposits 1000 more currencyToken. At this point this is 1000 currencyToken in the contract, and 1 address each in clearedDepositorsList and pendingAddressList\\r\\n    // 5. Before the new depositor's deposit clears, the cleared depositor withdraws all 1000 currency tokens.\\r\\n    // 6. Now, there are 0 cleared depositors, and an expired repo!\\r\\n    //\\r\\n    // If defaultRepo is called in this case, the pending depositor would still be owed 1000 currency tokens, and no one would have ownership of all the defaulted repo tokens.\\r\\n    // Therefore we need at least one cleared depositor to be present before defaultRepo() can be called; furthermore, we need the total number of cleared Deposits to be greater than or equal to 1000 currencyTokens.\\r\\n    // Note this is guaranteed to happen within pendingTime as all pendingDeposits will be cleared then, and no one else can withdraw since there are no more tokens left in the contract.\\r\\n    // Note it is fine if there are no cleared depositors present when buybackRepo() is called, as the extra currencyToken accrued would just sit in the contract for the owner presumably.\\r\\n    error InsufficientClearedDeposits();\\r\\n\\r\\n    // this occurs when the amount of currencyToken you are trying to withdraw exceeds totalEligibleBalance, which is the unborrowed cleared balance at the moment\\r\\n    // if you receive this error, this likely means the contract has enough currencyToken to pay you out, but some of that belongs to pending balances which do not belong to you. Your funds are locked in a repo at the moment, while the \\r\\n    // pending funds belonging to someone else are not\\r\\n    error WithdrawingMoreThanEligible(); \\r\\n    error CannotWithdrawUntilWithdrawActivationTime();\\r\\n}\"\r\n    },\r\n    \"https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currencyToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_repoToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_repoSellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_repoBuybackPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_repoTimeLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pendingTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CannotWithdrawUntilWithdrawActivationTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientClearedDeposits\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientEligibleCurrencyAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoActiveRepo\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoActiveRepoForUser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NothingToWithdraw\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RepoAlreadyExistsForUser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RepoPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RepoStillActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawingMoreThanEligible\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repoTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyTokenAmount\",\"type\":\"uint256\"}],\"name\":\"repoBoughtBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"defaulter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repoTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyTokenAmount\",\"type\":\"uint256\"}],\"name\":\"repoDefault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repoTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyTokenAmount\",\"type\":\"uint256\"}],\"name\":\"repoSold\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"activeRepos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"repoTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackRepo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"checkRepoExpiration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearPendingBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"clearedDepositorsList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"defaultRepo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultWithdrawBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"editDefaultWithdrawBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"editPendingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"editRepoBuybackPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"editRepoSellPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"editRepoTimeLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"editWithdrawActivationTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getOwedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProtocolProfits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalCurrencyAvailableForRepo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getWithdrawableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseRepos\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingAddressList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"activationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolProfitWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repoBuybackPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repoSellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repoTimeLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repoToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reposPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reposUsersList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_repoTokenAmount\",\"type\":\"uint256\"}],\"name\":\"sellRepo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClearedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEligibleBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseRepos\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userCurrencyBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDefaultBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawActivationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BananaRepoProject", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000ab87046fbb341d058f17cbc4c1133f25a20a52f000000000000000000000000000000000000000000000001158e460913d000000000000000000000000000000000000000000000000000013f306a2409fc000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}