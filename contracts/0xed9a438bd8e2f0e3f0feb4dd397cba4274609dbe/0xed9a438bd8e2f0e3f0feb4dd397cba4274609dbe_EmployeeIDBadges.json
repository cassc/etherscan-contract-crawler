{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n// Author: tycoon.eth\r\n// Project: Cigarette Token\r\n// About: ERC721 for Employee ID badges\r\n// \ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\ud83d\udeac\r\n\r\npragma solidity ^0.8.19; // compile contract with 10 optimization runs\r\n\r\n//import \"hardhat/console.sol\";\r\n/*\r\n  _____                 _                         ___ ____\r\n | ____|_ __ ___  _ __ | | ___  _   _  ___  ___  |_ _|  _ \\\r\n |  _| | '_ ` _ \\| '_ \\| |/ _ \\| | | |/ _ \\/ _ \\  | || | | |\r\n | |___| | | | | | |_) | | (_) | |_| |  __/  __/  | || |_| |\r\n |_____|_| |_| |_| .__/|_|\\___/ \\__, |\\___|\\___| |___|____/\r\n  ____           |_|            |___/\r\n | __ )  __ _  __| | __ _  ___  ___\r\n |  _ \\ / _` |/ _` |/ _` |/ _ \\/ __|\r\n | |_) | (_| | (_| | (_| |  __/\\__ \\\r\n |____/ \\__,_|\\__,_|\\__, |\\___||___/\r\n                    |___/\r\n\r\nEmployee ID badges are NFTs that are issued for those who have deposited\r\nStogies into the Cigarette Factory. Each NFT has a unique Employee ID that\r\nyou can put on to your Twitter / Discord profile.\r\n\r\nBadges are 100% onchain, and combine the following contracts to generate and\r\nrender their metadata:\r\n\r\n- 0xe91eb909203c8c8cad61f86fc44edee9023bda4d \"Punk Blocks\". A contract for\r\nstoring PNG files of individual punk traits onchain. Categorized in layers,\r\nand rendering the layers according to a configuration. \r\n\r\n- 0xc55C7913BE9E9748FF10a4A7af86A5Af25C46047  \"Punk Identicons\". A contract\r\nthat contains a \"punk picking function\". it picks the traits from  a pool of\r\n\"Punk Blocks\" based on an Ethereum address, and configurable probabilities.\r\n\r\n- 0x4872BC4a6B29E8141868C3Fe0d4aeE70E9eA6735 \"Barcode in Solidity\". A contract\r\nthat can generate Code-128C barcodes from a number and output as SVG.\r\n\r\nThe \"Punk Blocks\" and \"Punk Identicons\" contracts are used to draw a custom\r\npunk picture based on an Ethereum address. The \"Barcode in Solidity\" contract\r\nis used to draw a barcode at the bottom of the picture, and this is a real\r\nbarcode that stores the Employee ID. The badge artwork was designed and drawn\r\npiv.eth. Additional \"Factory Employee\" punk attributes were drawn by\r\nMr.1/Employee 20, a community member of the Cig Token project.\r\n\r\nIn all, there are 51 new attributes, which includes 34 new types. The\r\nprobabilities of the new types are fairly evenly distributed, which ensures that\r\npunks will be picked with a higher count of traits on average. Therefore, there\r\nmight be be some very weird punk pictures generated, and it was impossible to\r\ncheck all the possible combinations before deploying this contract.\r\n\r\nTERMINOLOGY\r\n\r\nStogies: An ERC20 token that wraps the CIG/ETH SushiSwap Liquidity Pool (SLP)\r\ntoken, for meme-ability and ease of use. Each Stogie represents a share of the\r\nETH & CIG reserves stored at 0x22b15c7ee1186a7c7cffb2d942e20fc228f6e4ed. To work\r\nout how much is a Stogie worth, add the values of ETH and CIG in the pool,\r\nand divide them by the total supply of the SLP token.\r\nFor example, if there are $100 worth of CIG and $100 worth of ETH in the pool,\r\nand the total supply of the SLP token is 1000, then each token would be worth\r\n(100+100)/1000 = 0.2, or 20 cents. Note that the SLP tokens do not have a capped\r\nsupply and new tokens can be minted by anyone, by adding more CIG & ETH to the\r\npool. This means that Stogies are not capped, only limited by the amount of ETH\r\nand CIG that can practically be added to the pool.\r\n\r\nMinimum Stogie Deposit: The minimum amount of Stogies required to be deposited\r\nin the Cig Factory to mint a badge. This value can be changed by the CEO of\r\nCryptoPunks, and is recorded for each badge. The recorded value is used to\r\ncalculate the \"Total Minimum Stogie Deposit\" for an account.\r\n\r\nTotal Minimum Stogie Deposit: The amount of Stogies the account is required to\r\ndeposit in the Cigarette Factory, depending on the badges they own.\r\nFor all badges owned by an account, a sum is calculated using the\r\nMinimum Stogie Deposit value of each badge. This sum is the Total Minimum Stogie\r\n Deposit.\r\n\r\nPrimary Badge: In case the address holds multiple badges, a primary badge can be\r\nchosen. The primary badge will be the one that the holder chooses to be always\r\nassociated with their account. If the address has no primary badge set, then the\r\nfirst badge held by the address will be chosen as the primary.\r\n\r\nRULES\r\n\r\n1. Each account can mint a badge once. With the exceptions: (a) if their badge\r\n   expired, once their expired badge gets reclaimed, then they can mint again.\r\n   (b) The badge gets transferred to a fresh account and the \"snapshot\" function\r\n   is executed from the fresh account to change the picture.\r\n\r\n2. To mint a badge, a minimum amount of stogie deposit in the Cigarette Factory\r\n   is required.\r\n\r\n3. Badges can expire! If you have not deposited a minimum amount of Stogies\r\n   into the Cigarette Factory, then anybody can call the `expire` function. So,\r\n   you will need to make sure to always keep a \"Total Minimum Stogie Deposit\"\r\n   in the Cigarette Factory, or else badges owned by your account can be expired\r\n   one-by-one, until the deposit amount is satisfied.\r\n\r\n4. Expiration can be initiated by anyone at any time, if the expiration rule (4)\r\n   is met. If an expiry initiation transaction is successful, the token will be\r\n   placed in the `PendingExpiry` state, and moved to the \"Expired\" account.\r\n   Your \"Total Minimum Stogie Deposit\" will also decrease by the \"Minimum\r\n   Stogie Deposit\" value of that badge.\r\n\r\n5. Expiration grace period: After transferring a badge, it cannot be expired for\r\n   72 hours. The new owner will have 72 hours to put up a Minimum Stogie\r\n   Deposit onto the account holding the badges.\r\n\r\n6. Reactivating: Badges that are in `PendingExpiry` state for less than 90 days\r\n   can still be reactivated. Their owner would need to place a minimum\r\n   amount of stogies to the Cigarette Factory, and then call the reactivate\r\n   method. Only the owner can reactivate.\r\n\r\n7. Reclaiming: If the NFT has been expired in `PendingExpiry` for more than 90\r\n    days, then it can be reclaimed by a fresh account, by calling the\r\n    `reclaim` function. The caller must hold a minimum amount of Stogies to\r\n    reclaim. \"Fresh account\" here means that the address reclaiming must not\r\n    have minted a badge before. Note that the picture on the badge will change,\r\n    but the ID won't change.\r\n\r\n8. The supply of the NFT is unlimited. However, since Stogies are required\r\n   for minting and holding the NFT, there is an economic scarcity to the NFT.\r\n   This means it cannot be minted forever, since CIG and ETH is needed to\r\n   create Stogies, and both may have limited availability, if demand for any of\r\n   these is high.\r\n\r\n9. Each unique address can only mint a maximum of 1 badge. However, they can\r\n   hold an unlimited number of badges, minted by other accounts, as long as they\r\n   have deposited the minimum Stogies into the Cigarette Factory.\r\n\r\n10. CEO can change the Global Minimum Value. %2.5 up or down, every 30 days.\r\n    With the limit that the result of the change must be not higher than 0.01%\r\n    of Stogies staked supply, and never less than 1 Stogie. The change will not\r\n    affect existing badges, only new mints or reactivations.\r\n\r\n11. The punk picture is chosen randomly based on the address that minted it.\r\n    There is also a special feature:\r\n    Addresses starting with 5 or more zeros get a rare type. The more 0's, the\r\n    rarer the type!\r\n\r\n    The list is like this:\r\n\r\n                zeros = name\r\n                5 = Alien 3\r\n                6 = Alienette 3\r\n                7 = Killer Bot\r\n                8 = Killer Botina\r\n                9 = Green Alien\r\n                10 = Green Alienette\r\n                11 = Alien 4\r\n                12 = Alienette 4\r\n                13 = Alien 5\r\n                14 = Alienette 5\r\n                15 = Alien 6\r\n                16 = Blue Ape\r\n                17 = Alienette 6\r\n\r\n     The more zeros, the harder it is to get. It should be very difficult to\r\n     get the last few, but maybe impossible to get 16 and 17.\r\n\r\n     Some \"back of the napkin\" estimations if you have a GPU:\r\n\r\n                17 = 26,722 years\r\n                16 = 1,670 years\r\n                15 = 104 years\r\n                14 = 6.5 years\r\n                13 = 0.4 years\r\n                12 = 1.3 weeks\r\n                11 = 14 hours\r\n                10 = 0.9 hours\r\n\r\n12. Changing the punk picture: It is possible to change the punk picture by\r\n    transferring the punk to a fresh address that has never minted an ID before,\r\n    and then calling the `snapshot` method. This method can only be called once\r\n    per address.\r\n\r\n\r\nEND \ud83d\udeac\r\n\r\n\r\n*/\r\n\r\ncontract EmployeeIDBadges {\r\n\r\n    using DynamicBufferLib for DynamicBufferLib.DynamicBuffer;\r\n\r\n    enum State {\r\n        Uninitialized,\r\n        Active,\r\n        PendingExpiry,\r\n        Expired\r\n    }\r\n\r\n    struct Badge {\r\n        address identiconSeed;   // address of identicon (the minter)\r\n        address owner;           // address of current owner\r\n        uint256 minStog;         // minimum stogies deposit needed\r\n        address approval;        // address approved for\r\n        uint64 transferAt;       // block id of when was the last transfer\r\n        uint64 index;            // sequential index in the wallet\r\n        State state;             // NFT's state\r\n    }\r\n\r\n    struct Attribute {\r\n        bool isType;\r\n        bytes value;\r\n    }\r\n\r\n    IStogie public stogie;\r\n    ICigToken private immutable cig;                // 0xCB56b52316041A62B6b5D0583DcE4A8AE7a3C629\r\n    IPunkIdenticons private immutable identicons;   // 0xc55C7913BE9E9748FF10a4A7af86A5Af25C46047;\r\n    IPunkBlocks private immutable pblocks;          // 0xe91eb909203c8c8cad61f86fc44edee9023bda4d;\r\n    IBarcode private immutable barcode;             // 0x4872BC4a6B29E8141868C3Fe0d4aeE70E9eA6735\r\n    uint32 private immutable orderConfigId;\r\n    mapping(bytes32 => Attribute) internal atts;    // punk-block to attribute name lookup table\r\n    mapping(address => uint256) private balances;   // counts of ownership\r\n    mapping(address => mapping(uint256 => uint256)) private ownedBadges;// track enumeration\r\n    mapping(address => uint256) public minStogSum;                      // sum of min Stogies required per account\r\n    mapping(uint256 => address) public expiredOwners;                   // keep track of last owner of expired token\r\n    mapping(uint256 => Badge) public badges;                            // all of the badges\r\n    uint256 public employeeHeight;                                      // the next available employee id\r\n    mapping(address => mapping(address => bool)) private approvalAll;   // operator approvals\r\n    bytes4 private constant RECEIVED = 0x150b7a02;  // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\r\n    mapping(address => uint64) public minters;      // ensures each badge has a unique identiconSeed value, address => timestamp\r\n    mapping(address => uint256) private pID;        // store the primary id for the address\r\n    address private curator;\r\n    uint256 public minSTOG = 20 ether;              // minimum STOG required to mint\r\n    uint64 public minSTOGUpdatedAt;                 // block number of last change\r\n    uint32 private immutable DURATION_MIN_CHANGE;   // 30 days, or 216000 blocks (7200 * 30)\r\n    uint32 private immutable DURATION_STATE_CHANGE; // 90 days, or 648000 blocks (7200 * 90)\r\n    uint16 private immutable GRACE_PERIOD;          // Number of blocks to wait after transfer before it can be cancelled (21600)\r\n    uint64 private constant SCALE = 1e10;\r\n    address private constant EXPIRED = 0x0000000000000000000000000000000000000E0F; // expired NFTs go here\r\n    event StateChanged(uint256 indexed id, address indexed caller, State s0, State s1);\r\n    event MinSTOGChanged(uint256 minSTOG, uint256 amt);\r\n    event Snapshot(uint256 indexed id, address indexed caller);\r\n    event MetadataUpdate(uint256);    // ERC-4906\r\n    constructor(\r\n        address _cig,                 // 0xCB56b52316041A62B6b5D0583DcE4A8AE7a3C629\r\n        uint32 _duration_min_change,  // 216000\r\n        uint32 _duration_state_change,// 648000\r\n        uint16 _gracePeriod,          // 21600\r\n        address _identicons,          // 0xc55C7913BE9E9748FF10a4A7af86A5Af25C46047\r\n        address _pblocks,             // 0xe91eb909203c8c8cad61f86fc44edee9023bda4d\r\n        address _barcode,             // 0x4872BC4a6B29E8141868C3Fe0d4aeE70E9eA6735\r\n        uint32 _configId\r\n    ) {\r\n        _transferOwnership(msg.sender);\r\n        cig = ICigToken(_cig);\r\n        DURATION_MIN_CHANGE = _duration_min_change;\r\n        DURATION_STATE_CHANGE = _duration_state_change;\r\n        GRACE_PERIOD = _gracePeriod;\r\n        identicons = IPunkIdenticons(_identicons);  // punk picking function for the punk picture\r\n        pblocks = IPunkBlocks(_pblocks);            // stores the images of the punk traits\r\n        barcode = IBarcode(_barcode);               // onchain barcode generator\r\n        orderConfigId = _configId;\r\n        atts[0x9039da071f773e85254cbd0f99efa70230c4c11d63fce84323db9eca8e8ef283] = Attribute(true, \"Male 1\"); // 0\r\n        atts[0xdfcbad4edd134a08c17026fc7af40e146af242a3412600cee7c0719d0ac42d53] = Attribute(true, \"Male 2\"); // 0\r\n        atts[0xed94d667f893279240c415151388f335b32027819fa6a4661afaacce342f4c54] = Attribute(true, \"Male 3\"); // 0\r\n        atts[0x1323f587f8837b162082b8d221e381c5e015d390305ce6be8ade3ff70e70446e] = Attribute(true, \"Male 4\"); // 0\r\n        atts[0x1bb61a688fea4953cb586baa1eadb220020829a1e284be38d2ea8fb996dd7286] = Attribute(true, \"Female 1\"); // 0\r\n        atts[0x47cc6a8e17679da04a479e5d29625d737670c27b21f8ccfb334e6af61bf6885a] = Attribute(true, \"Female 2\"); // 0\r\n        atts[0x80547b534287b04dc7e9afb751db65a7515fde92b8c2394ae341e3ae0955d519] = Attribute(true, \"Female 3\"); // 0\r\n        atts[0xc0c9e42e9d271c94b57d055fc963197e4c62d5933e371a7449ef5d59f26be00a] = Attribute(true, \"Female 4\"); // 0\r\n        atts[0xf41cb73ce9ba5c1f594bcdfd56e2d14e42d2ecc23f0a4863835bdd4baacd8b72] = Attribute(true, \"Zombie\"); // 0\r\n        atts[0xb1ea1507d58429e4dfa3f444cd2e584ba8909c931969bbfb5f1e21e2ac8b758d] = Attribute(true, \"Ape\"); // 0\r\n        atts[0x62223f0b03d25507f52a69efbbdbcfdc7579756a7a08a95a2f0e72ada31e32b8] = Attribute(true, \"Alien\"); // 0\r\n        atts[0x047228ad95cec16eb926f7cd21ac9cc9a3288d911a6c2917a24555eac7a2c0e2] = Attribute(false, \"Rosy Cheeks\"); // 2\r\n        atts[0xce1f93a7afe9aad7ebb13c0add89c79d42b5e9b1272fdd1573aac99fe5d860d0] = Attribute(false, \"Luxurious Beard\"); // 6\r\n        atts[0xbfac272e71cad64427175cd77d774a7884f98c7901ebc4909ada29d464c8981e] = Attribute(false, \"Clown Hair Green\"); // 8\r\n        atts[0xa71068a671b554f75b7cc31ce4f8d63c377f276333d11989e77bc4a9205b5e42] = Attribute(false, \"Mohawk Dark\"); // 8\r\n        atts[0x9a132de8409f80845eaec43154ff43d7bd61df75e52d96b4ded0b64626e4c88a] = Attribute(false, \"Cowboy Hat\"); // 8\r\n        atts[0xfca4c5f86ef326916536dfdae74031d6960e41e10d38c624294334c3833974e2] = Attribute(false, \"Mustache\"); // 6\r\n        atts[0x4483a654781ca58fa6ba3590c74c005bce612263e17c70445d6cd167e55e900b] = Attribute(false, \"Clown Nose\"); // 12\r\n        atts[0x1885fe71e225eade934ab7040d533bd49efc5d66e8f2d4b5aa42477ae9892ec9] = Attribute(false, \"Cigarette\"); // 11\r\n        atts[0x7411db1fe7a50d41767858710dc8b8432ac0c4fd26503ba78d2ed17789ce4f72] = Attribute(false, \"Nerd Glasses\"); // 10\r\n        atts[0xdd7231e98344a83b64e1ac7a07b39d2ecc2b21128681123a9030e17a12422527] = Attribute(false, \"Regular Shades\"); // 10\r\n        atts[0x24dd0364c2b2d0e6540c7deb5a0acf9177d47737a2bf41ca29b553eb69558ef9] = Attribute(false, \"Knitted Cap\"); // 8\r\n        atts[0xea5efa009543229e434689349c866e4d254811928ae8a1320abb82a36d3be53f] = Attribute(false, \"Shadow Beard\"); // 6\r\n        atts[0x2df03e79022dc10f7539f01da354ffe10da3ef91f1e18bc7fd096db00c381de8] = Attribute(false, \"Frown\"); // 1\r\n        atts[0xf0ac7cf8c022008e16b983f22d22dae3a15b9b5abcc635bc5c20beb4d7c91800] = Attribute(false, \"Cap Forward\"); // 8\r\n        atts[0x8580e735d58252637afd6fef159c826c5e7e6a5dcf1fe2d8398b3bf92c376d42] = Attribute(false, \"Goat\"); // 6\r\n        atts[0x041bf83549434251cc54c0632896c8d3176b48d06150048c1bce6b6102c4e90c] = Attribute(false, \"Mole\"); // 3\r\n        atts[0x591f84c8a41edd0013624b89d5e6b96cd3b0c6f1e214d4ea13a35639412f07e6] = Attribute(false, \"Purple Hair\"); // 8\r\n        atts[0x54917cb8cff2411930ac1b1d36a674f855c6b16c8662806266734b5f718a9890] = Attribute(false, \"Small Shades\"); // 10\r\n        atts[0x274ae610f9d7dec1e425c54ad990e7d265ba95c4f84683be4333542088ecb8e7] = Attribute(false, \"Shaved Head\"); // 8\r\n        atts[0x6a400b1508bfd84ab2f4cb067d6d74dc46f74cdae7efd8b2a2d990c9f037e426] = Attribute(false, \"Classic Shades\"); // 10\r\n        atts[0x3e6bc8fc06a569840c9490f8122e6b7f08a7598486649b64477b548602362516] = Attribute(false, \"Vape\"); // 11\r\n        atts[0x2c382a7f1f32a6a2d0e9b0d378cb95e3dad70fe6909ff13888fe2a250bd10bb0] = Attribute(false, \"Silver Chain\"); // 5\r\n        atts[0x8968ce85cb55abb5d9f6f678baeeb565638b6bad5d9be0ea2e703a34f4593566] = Attribute(false, \"Smile\"); // 1\r\n        atts[0xc3075202748482832362d1b854d8274a38bf56c5ad38d418e590f46113ff10b1] = Attribute(false, \"Big Shades\"); // 10\r\n        atts[0x971f7c3d5d14436a3b5ef2d658445ea527464a6409bd5f9a44f3d72e30d1eba8] = Attribute(false, \"Mohawk Thin\"); // 8\r\n        atts[0x1f7b5107846b1e32944ccf8aedeaa871fc859506f51e7d12d6e9ad594a4d7619] = Attribute(false, \"Beanie\"); // 8\r\n        atts[0xd35b2735e5fcc86991c8501996742b3b8c35772d92b69859de58ddd3559be46c] = Attribute(false, \"Cap\"); // 8\r\n        atts[0x2004722753f61acb2cefde9b14d2c01c6bcb589d749b4ea616b4e47d83fdb056] = Attribute(false, \"Clown Eyes Green\"); // 4\r\n        atts[0x05a5afe13f23e20e6cebabae910a492c91f4b862c2e1a5822914be79ab519bd8] = Attribute(false, \"Normal Beard Black\"); // 6\r\n        atts[0xac5194b2986dd9939aedf83029a6e0a1d7d482eb00a5dafa05fc0aaa9b616582] = Attribute(false, \"Medical Mask\"); // 11\r\n        atts[0xf94798c1aedb2dce1990e0dae94c15178ddd4229aff8031c9a5b7a77743a34d4] = Attribute(false, \"Normal Beard\"); // 6\r\n        atts[0x15854f7a2b735373aa76722c01e2f289d8b18cb1a70575796be435e4ce55e57a] = Attribute(false, \"VR\"); // 10\r\n        atts[0xd91f640608a7c1b2b750276d97d603512a02f4b84ca13c875a585b12a24320c2] = Attribute(false, \"Eye Patch\"); // 10\r\n        atts[0x6bb15b5e619a28950bae0eb6a03f13daea1b430ef5ded0c5606b335f5b077cda] = Attribute(false, \"Wild Hair\"); // 8\r\n        atts[0x7a8b4abb14bfe7b505902c23a9c4e59e5a70c7daf6e28a5f83049c13142cde5e] = Attribute(false, \"Top Hat\"); // 8\r\n        atts[0x72efa89c7645580b2d0d03f51f1a2b64a425844a5cd69f1b3bb6609a4a06e47f] = Attribute(false, \"Bandana\"); // 8\r\n        atts[0xfc1c0134d4441a1d7c81368f23d7dfcdeab3776687073c12af9d268e00d6c0a8] = Attribute(false, \"Handlebars\"); // 6\r\n        atts[0x6ced067c29d04b367c1f3cb5e7721ad5a662f5e338ee3e10c7d64d9d109ed606] = Attribute(false, \"Frumpy Hair\"); // 8\r\n        atts[0x66a6c35fd6db8b93449f29befe26e2e4bcb09799d56216ada0ef901c53cf439f] = Attribute(false, \"Crazy Hair\"); // 8\r\n        atts[0x85c5daead3bc85feb0d62d1f185f82fdc2627bdbc7f1f2ffed1c721c6fcc4b4d] = Attribute(false, \"Police Cap\"); // 8\r\n        atts[0x3d1f5637dfc56d4147818053fdcc0c0a35886121b7e4fc1a7cff584e4bb6414f] = Attribute(false, \"Buck Teeth\"); // 1\r\n        atts[0x64b53b34ebe074820dbda2f80085c52f209d5eba6c783abdae0a19950f0787ec] = Attribute(false, \"Do-rag\"); // 8\r\n        atts[0x833ca1b7f8f2ce28f7003fb78b72e259d5a484b13477ad8212edb844217225ac] = Attribute(false, \"Front Beard\"); // 6\r\n        atts[0x44c2482a71c9d39dac1cf9a7daf6de80db79735c0042846cb9d47f85ccc3ba9b] = Attribute(false, \"Spots\"); // 3\r\n        atts[0x4acd7797c5821ccc56add3739a55bcfd4e4cfd72b30274ec6c156b6c1d9185eb] = Attribute(false, \"Big Beard\"); // 6\r\n        atts[0xc0ac7bb45040825a6d9a997dc99a6ec94027d27133145018c0561b880ecdb389] = Attribute(false, \"Vampire Hair\"); // 8\r\n        atts[0xa756817780c8e400f79cdd974270d70e0cd172aa662d7cf7c9fe0b63a4a71d95] = Attribute(false, \"Peak Spike\"); // 8\r\n        atts[0x71c5ce05a579f7a6bbc9fb7517851ae9394c8cb6e4fcad99245ce296b6a3c541] = Attribute(false, \"Chinstrap\"); // 6\r\n        atts[0x283597377fbec1d21fb9d58af5fa0c43990b1f7c2fc6168412ceb4837d9bf86c] = Attribute(false, \"Fedora\"); // 8\r\n        atts[0xbb1f372f67259011c2e9e7346c8a03a11f260853a1fe248ddd29540219788747] = Attribute(false, \"Earring\"); // 7\r\n        atts[0xd5de5c20969a9e22f93842ca4d65bac0c0387225cee45a944a14f03f9221fd4a] = Attribute(false, \"Horned Rim Glasses\"); // 10\r\n        atts[0xb040fea53c68833d052aa3e7c8552b04390371501b9976c938d3bd8ec66e4734] = Attribute(false, \"Headband\"); // 8\r\n        atts[0x74ca947c09f7b62348c4f3c81b91973356ec81529d6220ff891012154ce517c7] = Attribute(false, \"Pipe\"); // 11\r\n        atts[0x30146eda149865d57c6ae9dac707d809120563fadb039d7bca3231041bea6b2e] = Attribute(false, \"Messy Hair\"); // 8\r\n        atts[0x8394d1b7af0d52a25908dc9123cc00aa0670debcac95a76c3e9a20dd6c7e7c23] = Attribute(false, \"Front Beard Dark\"); // 6\r\n        atts[0xeb787e7727b2d8d912a02d9ad4c30c964b40f4cebe754bb4d3bfb09959565c91] = Attribute(false, \"Hoodie\"); // 8\r\n        atts[0x6a36bcf4268827203e8a3f374b49c1ff69b62623e234e96858ff0f2d32fbf268] = Attribute(false, \"Gold Chain\"); // 5\r\n        atts[0x2f237bd68c6e318a6d0aa26172032a8a73a5e0e968ad3d74ef1178e64d209b48] = Attribute(false, \"Muttonchops\"); // 6\r\n        atts[0xad07511765ae4becdc5300c486c7806cd661840b0670d0f6670e8c4014de37b0] = Attribute(false, \"Stringy Hair\"); // 8\r\n        atts[0x49e0947b696384a658eeca7f5746ffbdd90a5f5526f8d15e6396056b7a0dc8af] = Attribute(false, \"Eye Mask\"); // 10\r\n        atts[0xc1695b389d89c71dc7afd5111f17f6540b3a28261e4d2bf5631c1484f322fc68] = Attribute(false, \"3D Glasses\"); // 10\r\n        atts[0x09c36cad1064f6107d2e3bef439f87a16c8ef2e95905a827b2ce7f111dd801d7] = Attribute(false, \"Clown Eyes Blue\"); // 4\r\n        atts[0xeb92e34266f6fa01c275db8379f6a521f15ab6f96297fe3266df2fe6b0e1422e] = Attribute(false, \"Mohawk\"); // 8\r\n        atts[0x1892c4c9cf47baf2c613f184114519fe8208c2bebabb732405aeac1c3031dc2b] = Attribute(false, \"Pilot Helmet\"); // 8\r\n        atts[0x250be814c80d8ca10bbef531b679392db8221a6fab289a6b5e637df663f48699] = Attribute(false, \"Tassle Hat\"); // 8\r\n        atts[0xcd87356aa78c4fcb95e51f57578570d377440e347e0869cf1b4749d5a26340b5] = Attribute(false, \"Hot Lipstick\"); // 1\r\n        atts[0x4fa682c6066fcc513a0511418aa85a0037ac59a899e9491c512b63e253697a8c] = Attribute(false, \"Blue Eye Shadow\"); // 4\r\n        atts[0x36f07f03014f047728880d9f390629140a5e7c44477290695c4c1ddda356d365] = Attribute(false, \"Straight Hair Dark\"); // 8\r\n        atts[0x68107f52c261820bd73e4046eb3fb5d5a1e0926611562c07054a3b89334cef34] = Attribute(false, \"Choker\"); // 5\r\n        atts[0xd395cf4acda004fbc9963f85c65bf3f190c2aceb0744a535d543bc261caf6ff0] = Attribute(false, \"Wild Blonde\"); // 8\r\n        atts[0xbad0fc475e9d35de67c426fc37eebb7fa38141bc2135fabd5504a911e1b05540] = Attribute(false, \"Wild White Hair\"); // 8\r\n        atts[0xd10bc0475e2a0eea9f6aca91e6e82c6416f894f27fc26bb0735f29b84c54a3e6] = Attribute(false, \"Tiara\"); // 8\r\n        atts[0xa0a2010e841ab7b343263c98f47a16b88656913e1353d96914f5fe492511893f] = Attribute(false, \"Orange Side\"); // 8\r\n        atts[0x0e6769a10f786458ca82b57684746fe8899e35f7772543acb6a8869c4ac780cd] = Attribute(false, \"Red Mohawk\"); // 8\r\n        atts[0x1004d2d00ccf8794739c7b7cbbe6048841f4c8af046b37d59e9a801a167544e2] = Attribute(false, \"Purple Eye Shadow\"); // 4\r\n        atts[0x629e82a55845ea763431647fcaecfb232e275a36d8427f2568377864193801cb] = Attribute(false, \"Dark Hair\"); // 8\r\n        atts[0xcd3633a5e96d615b834e90e67029f7f9f507b832e1cb263a29685b8e25f678cf] = Attribute(false, \"Blonde Short\"); // 8\r\n        atts[0xe81a9c78c0ec4339dc6772f1b9bbf406b53063f8408a91fe29f63ba1c2bc7b5a] = Attribute(false, \"Purple Lipstick\"); // 1\r\n        atts[0xe11278d6c191c8199a5b8bb49be7f806b837a9811195c903d844a74c4c4a704e] = Attribute(false, \"Pigtails\"); // 8\r\n        atts[0x411ec1566affa22bd67b13a7c49ac060c018e1c806cd314cd2186118dd55e129] = Attribute(false, \"Straight Hair Blonde\"); // 8\r\n        atts[0x1868a04ecae06e10c5b6dcbbed4befac1ed03dda2cf86ddbd855466cc588809f] = Attribute(false, \"Welding Goggles\"); // 10\r\n        atts[0x3511b04ac6a3d46305172269904dc469a40f380a4e7afa8742ce6e6a44825c4a] = Attribute(false, \"Pink With Hat\"); // 8\r\n        atts[0x2857e47dcac3b744dd7d41617ce362f1dd3ae8eb836685cc18338714205b036c] = Attribute(false, \"Blonde Bob\"); // 8\r\n        atts[0x2e9a5434da70e5ea2ed439b3a33aac60bd252c92698c1ba37e9ed77f975c6cab] = Attribute(false, \"Green Eye Shadow\"); // 4\r\n        atts[0x8c0e60b85ff0f8be1a87b28ae066a63dcc3c02589a213b0856321a73882515f9] = Attribute(false, \"Straight Hair\"); // 8\r\n        atts[0xe651be5dd43261e6e9c1098ec114ab5c44e7cb07377dc674336f1b3d34428fe4] = Attribute(false, \"Half Shaved\"); // 8\r\n        atts[0x1cd064e6db4e7c5180ccf5f2afe1370c6539b525fe3bea9c358f24a7cbdb50ad] = Attribute(false, \"Black Lipstick\"); // 1\r\n\r\n    }\r\n\r\n    // AttInit is used to pass data to completeInitialization1\r\n    struct AttInit {\r\n        bytes32 k;\r\n        bool isType;\r\n        string value;\r\n    }\r\n\r\n    /**\r\n    * completeInitialization1 sets up the CIG factory worker traits\r\n    */\r\n    function completeInitialization1(AttInit[] calldata _atts) external {\r\n        /**\r\n        // new traits\r\n        atts[0x398534927262d4f6993396751323ddd3e8326784a8e9a4808f17b99e6693835e] = Attribute(false, \"Stogie\"); // 11\r\n        atts[0x27dfd5e48f41fe8c82fecc41af933800fe5a5af6d9315a88932b9fb36d94a138] = Attribute(false, \"Headset\"); // 7\r\n        atts[0x550aa6da33a6eca427f83a70c2510cbc3c8bdb8a1ce5e5c3a32b2262f97c4aa1] = Attribute(false, \"Employee Cap\"); // 9\r\n        atts[0xd3ce42d23c6ec3bb95bfdee3de4e8d42889817871544fc9a07f05e4a2d21123e] = Attribute(false, \"Earbuds\"); // 9\r\n        atts[0x975e45b489dc6726c2a27eb784068ec791a22cf46fb780ced5e6b2083f32ebc3] = Attribute(false, \"Headphones Red\"); // 9\r\n        atts[0x421c9c08478a3dfb8a098fbef56342e7e0b53239aaa40dd2d56951cc6c178d35] = Attribute(false, \"Headphones Yellow\"); // 9\r\n        atts[0xaffb8a29fc5ed315e2a1103abc528d4f689c8365b54b17538f96e6bcae365633] = Attribute(false, \"Gas Mask\"); // 11\r\n        atts[0x314ff09b8866e566e22c7bf1fe4227185bc37e1167a84aaf299f5e016ca2ea7b] = Attribute(false, \"Goggles\"); // 10\r\n        atts[0xe5fd4286f4fc4347131889d24238df4b5ba8d8d4985cbd9cb30d447ec14cbb2f] = Attribute(false, \"Pen\"); // 7\r\n        atts[0xaeae7be74009ff61e63109240ea8e00b3bd6d166bf8a7f6584f64ff75e783f09] = Attribute(false, \"Pencil\"); // 10\r\n        atts[0x1cc630fd6d4fff8ca66aacb5acdba26a0a14ce5fd8f9cb60b002a153d1582b4e] = Attribute(false, \"Red Hat\"); // 8\r\n        atts[0xbbb91da98e74857ed34286d7efaf04751ac3f4d7081d62a0aa3b09278b5ee55a] = Attribute(false, \"Yellow Hat\"); // 8\r\n        atts[0x3fbda43b0bda236b4f6f6dba8b7052381641b3d92ce4b49b4a2e9be390980019] = Attribute(false, \"White Hat\"); // 8\r\n        atts[0x10214dd24c8822f95b3061229664e567e7da89d1f8a408179e12bf38be2c1430] = Attribute(false, \"Suit\"); // 5\r\n        atts[0xb52fd5c8112bb81b2c05dd854ac28867bf72fd52124cb27aee3de68a19c87812] = Attribute(false, \"Suit Black\"); // 5\r\n        atts[0xd7a861eff7c9242c2fc79148cdb44128460adae80afe1ba79c2d1eae290fb883] = Attribute(true, \"Bot\"); // 0\r\n        atts[0x7d3615eb6acf9ca19e31084888916f38df240bce4009857da690e4681bf8d4b0] = Attribute(true, \"Botina\"); // 0\r\n        atts[0x18a26173165d296055f2dfd8a12afc0a3e85434dd9d3f9c3ddd1eabc37ff56bc] = Attribute(true, \"Killer Bot\"); // 0\r\n        atts[0xb93c33f3b6e2e6aef9bd03b9ed7a064ed00f8306c06dfc93c76ae30db7a3f2b4] = Attribute(true, \"Killer Botina\"); // 0\r\n        atts[0x9242f3766d6363a612c9e88734e9c5667f4c82e07d00b794481f5b41b97047e8] = Attribute(true, \"Green Alien\"); // 0\r\n        atts[0x0c924a70f72135432a52769f20962602647a5b6528675c14bb318eaf4cbb2753] = Attribute(true, \"Green Alienette\"); // 0\r\n        atts[0xcd6f6379578617fc2da9c1d778e731bebaa21e9be1ed7265963ec43076d17a10] = Attribute(true, \"Blue Ape\"); // 0\r\n        atts[0x53f8bd0b36b2d3d9abc80e02d6fe9ed6a07068216cd737604c0c36ac60f458dc] = Attribute(true, \"Alien 2\"); // 0\r\n        atts[0xeca5ecd41019c8240974e9473044bf1a01598e7c650939425f53f561e959ec46] = Attribute(true, \"Alien 3\"); // 0\r\n        atts[0x061c5772160bfea6296a0317f6eff655398285ab18dbe89497436563445eeddc] = Attribute(true, \"Alien 4\"); // 0\r\n        atts[0x224b0f8059a7c50a19036c71e7500fd115adfd3af915c8d6d6639248c6e41283] = Attribute(true, \"Alien 5\"); // 0\r\n        atts[0xfb3556140e6f92df2d04796b8d8c5f6732abf43c07eb7034a90672cd4f9af372] = Attribute(true, \"Alien 6\"); // 0\r\n        atts[0xe9986a150e097f2cadc995279f34846ae9786b8ce35070b152f819d7a18d7760] = Attribute(true, \"Alienette 2\"); // 0\r\n        atts[0x0a215113c1e36c8cf69812b89dd912e3e2f1d70ab8c7691e0439a002d772f56d] = Attribute(true, \"Alienette 3\"); // 0\r\n        atts[0xac4fc861f4029388de1fa709cb865f504fb3198a6bf4dad71ff705a436c406c2] = Attribute(true, \"Alienette 4\"); // 0\r\n        atts[0xbefcd0e4ecf58c1d5e2a435bef572fca90d5fcedf6e2e3c1eb2f12b664d555a4] = Attribute(true, \"Alienette 5\"); // 0\r\n        atts[0x54526cc56c302d9d091979753406975ad06ca6a58c7bea1395ae25350268ab36] = Attribute(true, \"Alienette 6\"); // 0\r\n        atts[0xffa2b3215eb937dd3ebe2fc73a7dd3baa1f18b9906d0f69acb3ae76b99130ff7] = Attribute(true, \"Pink Ape\"); // 0\r\n        atts[0x46151bb75270ac0d6c45f21c75823f7da7a0c0281ddede44d207e1242e0a83f6] = Attribute(true, \"Male 5\"); // 0\r\n        atts[0xef8998f2252b6977b3cc239953db2f5fbcd066a5d454652f5107c59239265884] = Attribute(true, \"Male 6\"); // 0\r\n        atts[0x606da1a8306113f266975d1d05f6deed98d3b6bf84674cc69c7b1963cdc3ea86] = Attribute(true, \"Male 7\"); // 0\r\n        atts[0x804b2e3828825fc709d6d2db6078f393eafdcdedceae3bdb9b36e3c81630dd5e] = Attribute(true, \"Apette\"); // 0\r\n        atts[0x54354de4503fcf83c4214caefd1d4814c0eaf0ce462d1783be54ff9f952ec542] = Attribute(true, \"Female 5\"); // 0\r\n        atts[0x8a643536421eae5a22ba595625c8ba151b3cc48f2a4f86f9671f5c186b027ceb] = Attribute(true, \"Female 6\"); // 0\r\n        atts[0x4426d573f2858ebb8043f7fa39e34d1441d9b4fa4a8a8aa2c0ec0c78e755df0e] = Attribute(true, \"Female 7\"); // 0\r\n        atts[0x1908d72c46a0440b2cc449de243a20ac8ab3ab9a11c096f9c5abcb6de42c99e7] = Attribute(true, \"Alientina\"); // 0\r\n        atts[0xcedf32c147815fdc0d5f7e785f41a33dfc773e45bbd1a9a3b5d86c264e1b8ac5] = Attribute(true, \"Zombina\"); // 0\r\n        atts[0x691d9c552cd5457793c084f8bfce824df33aa7bcff69bb398b1c50c5283700ab] = Attribute(true, \"ZombieApe\"); // 0\r\n        atts[0x44cc2bd937a1ba84d91aa4ad1c68a4019d7441276f158686ca21113d9b58c736] = Attribute(true, \"Cigarina\"); // 0\r\n        atts[0x6ad96c1daca4b1c9f05d375a8cc7561b56dc9f8e0c47de6294d0b56e99baba9f] = Attribute(true, \"Cyborghina 1\"); // 0\r\n        atts[0x630cf72f7f662f0e4ad0e59518468203238cfd411fb9c5b474e65247043ff6ff] = Attribute(true, \"Cyborghina 2\"); // 0\r\n        atts[0x9c4d52ffba9e3fe6a536e1420a71503203fde6d50cc7dfd6dcffb18520ea92ac] = Attribute(true, \"Cyborghina 3\"); // 0\r\n        atts[0xa85374c4f65c797073c8536e4d19c56b86127fd476a9b5a4b3fbf026a0a631e9] = Attribute(true, \"Cyborghina 4\"); // 0\r\n        atts[0x53c4266e345ac07f4b1871310600f58edbc34ac584f94a14b301b73dab6f3eb7] = Attribute(true, \"Apexus 1\"); // 0\r\n        atts[0x6528e7d7c1f35ff1569dd65b8801909e5792c388e4c77a81c2861b7dba7d3800] = Attribute(true, \"Apexus 2\"); // 0\r\n        atts[0xbfaced9f8b3c58cbea8869f267e8c39500da9c86b500a8207a4f31667d37e9a4] = Attribute(true, \"Apexus 3\"); // 0\r\n        atts[0xb9c52250f5eef12475dec466c74c2d2eab10a1010f3a86073b1d92086882fb9a] = Attribute(true, \"Apexus 4\"); // 0\r\n        */\r\n        require(msg.sender == curator, \"only curator\");\r\n        for (uint256 i = 0; i < _atts.length; i++) {\r\n            atts[_atts[i].k] = Attribute(_atts[i].isType, bytes(_atts[i].value));\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n    * issue initial ids to whitelist\r\n    */\r\n    function completeInitialization2(address[] calldata _list) external {\r\n        require(msg.sender == curator, \"only curator\");\r\n        /*\r\n        address[27] memory list = [\r\n                        address(0xc43473fA66237e9AF3B2d886Ee1205b81B14b2C8),\r\n                    0xa80be8CAC8333330106585ee210C3F245D4f98Df,\r\n                    0x713282ECe7b1e34Bcb88c8f1922561A4EE369772,\r\n                    0x21077c224B7178b1Bb46af8dcd73F1EBAd869B0B,\r\n                    0xC088B1eEf1C08CE01A2aBF73531a61270481Fb0B,\r\n                    0x53B182152c57E37dde0E67675946169d44F3c005,\r\n                    0x614A61a3b7F2fd8750AcAAD63b2a0CFe8B8524F1,\r\n                    0xf20dC15A36D4E1Fdb3A767C6aB4A7e972574573d,\r\n                    0x0000000704dd12B781af73e9D7ac1f6BE3B46423,\r\n                    0x910E4220e1EDd15D4f5A6450521d0Cd06D275c00,\r\n                    0x64CB2f44AE5c5D4592920D49e57e9b3F005Da5dc,\r\n                    0x8C48b40dBa656187896147089545439E4fF4A01c,\r\n                    0xaf016eC2AfD326126d7f43498645A33a4aCf51F2,\r\n                    0x7539Eb7d68e49D4Ad65067577c47DfC92f5Fc1Ce,\r\n                    0xc50A0b4F31Cd5580c7a629178ff78CFF5973edB6,\r\n                    0xEE8dBE16568254450d890C1CB98180A770e82724,\r\n                    0x3E5a90F582d45Cf83e0446D53B3069E86162003b,\r\n                    0xB9CDEB51bD53fAF41Ea92c94526f40f15460c088,\r\n                    0x1CBa69a71c1D17a69Fc0cb9eD0945F9E7DeD702a,\r\n                    0x96aCe5Dc0404f2613ebCc5b04cD455b35b6Bf7c7,\r\n                    0x5B5b487aEd7D18ac677C73859270b0F6CF5bB69C,\r\n                    0xeb26E394da8d8AD5bEDDE97a281a9a9b63b3Eef3,\r\n                    0xACe239D889b5aceffC6F4ea7fF6DdCAFD3900936,\r\n                    0x17476d0Ed31f81d95b5ba8960b2D0b4dE4675e64,\r\n                    0x81c247e7923eb96Aeb908228A50eDec0dB8Ba09e,\r\n                    0x2A8bE03A5D65dE287648Ec176B74745ee9c164D2,\r\n                    0x1E0591255AdC9Cfb2cFbBfFF5AE48b7BeE6E253d\r\n            ];\r\n            */\r\n        uint256 min = minSTOG;\r\n        uint id = employeeHeight;\r\n        for (uint256 i = 0; i < _list.length; i++) {\r\n            _issueID(_list[i], min);\r\n            _transfer(address(0), _list[i], id, min);\r\n            id++;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Sending ETH to this contract will automatically issue Stogies and stake them\r\n    *    it will also issue a badge to the user. Can only be used by addresses that\r\n    *    have not minted. Limited yp 1 ETH or less.\r\n    */\r\n    receive() external payable {\r\n        bool mintID = (minters[msg.sender] == 0);\r\n        require(mintID == true, \"id already minted\");\r\n        uint256 minAmount = stogie.getMinETHDeposit();\r\n        require(msg.value >= minAmount, \"not enough ETH\");\r\n        stogie.onboard{value:minAmount}(msg.sender, 1, true, mintID);\r\n        if (msg.value > minAmount) {\r\n            (bool sent, ) = msg.sender.call{value: msg.value - minAmount}(\"\");\r\n            require(sent, \"failed to send change\");\r\n        }\r\n    }\r\n\r\n    /**\r\n    * getStats gets the information about the current user\r\n    */\r\n    function getStats(\r\n        address _holder\r\n    ) view external returns (\r\n        uint256[] memory,           // different stats, including balances, etc\r\n        Badge[] memory inventory,   // badges\r\n        string[] memory uris,       // uris\r\n        uint256[] memory ids,       // ids\r\n        Badge[] memory expInventory,// expired badges\r\n        string[] memory expUris,    // uris of expired tokens\r\n        uint256[] memory expIds     // expired ids\r\n    ) {\r\n        uint[] memory ret = new uint[](13);\r\n        ret[0] = minSTOG;                           // Minimum stogies required\r\n        ret[1] = minters[_holder];                  // timestamp of when account minted an id\r\n        ret[2] = minStogSum[_holder];               // minimum STOG required for that _holder\r\n        ret[3] = balanceOf(_holder);                // holder's balance of ids\r\n        ret[4] = balanceOf(EXPIRED);                // Balance of expired ids\r\n        ret[5] = employeeHeight;                    // that's also the totalSupply();\r\n        (ret[6], ret[7]) = stogie.farmers(_holder); // (deposit, rewardDebt)\r\n        ret[8] = GRACE_PERIOD;\r\n        ret[9] = DURATION_STATE_CHANGE;\r\n        ret[10] = DURATION_MIN_CHANGE;\r\n        ret[11] = primaryId(_holder);               // the primary id\r\n        (inventory,\r\n        , // don't need balance\r\n            uris,\r\n            ids) = getBadges(_holder, 0, 10);\r\n        (expInventory,, expUris, expIds) = getBadges(EXPIRED, 0, uint16(20));\r\n        ret[12] = stogie.getMinETHDeposit();\r\n        return (ret, inventory, uris, ids, expInventory, expUris, expIds);\r\n    }\r\n\r\n\r\n    /**\r\n    * avgMinSTOG is the public getter, to get the average minSTOG\r\n    * @param _a address of holder\r\n    * @return uint256 the average value.\r\n    */\r\n    function avgMinSTOG(address _a) view public returns (uint256) {\r\n        uint256 v = minStogSum[_a];\r\n        if (v == 0) {\r\n            return 0;\r\n        }\r\n        return _avg(v, balanceOf(_a));\r\n    }\r\n\r\n    /**\r\n    * _avg computes the average given sum and count\r\n    * @param _sum the total\r\n    * @param _count the count\r\n    */\r\n    function _avg(uint256 _sum, uint256 _count) internal pure returns (uint256 r) {\r\n        if (_count == 0) {\r\n            return 0;\r\n        } else if (_count == 1) {\r\n            return _sum;\r\n        }\r\n        r = _sum * 1e13 / _count / 1e13;\r\n    }\r\n\r\n    /**\r\n    * @dev getBadges get badges of a holder with pagination. It will dynamically\r\n    *   adjust the resulting array to match the amount of results returned. So,\r\n    *   if you start from page 0 with 30 items per page, and there are only 5\r\n    *   badges, it will return and array with 5 entries only.\r\n    *   Return an empty array if balance is 0\r\n    *   Throws if a non-existent page is requested.\r\n    * @param _holder address of account\r\n    * @param _page number starting from 0 for the first page\r\n    * @param _perPage how many tokens per gape\r\n    * @return inventory Badge[] memory result of badges.\r\n    * @return balance uint32 the total balance of all badges\r\n    * @return uris string[] of the tokenURI for each token\r\n    * @return ids uint256[] list of the token ids\r\n    */\r\n    function getBadges(address _holder, uint16 _page, uint16 _perPage) view public returns (\r\n        Badge[] memory,   // inventory\r\n        uint32 balance,\r\n        string[] memory, // uris\r\n        uint256[] memory // ids\r\n    ) {\r\n        balance = uint32(balanceOf(_holder));\r\n        if (balance == 0) {\r\n            return (new Badge[](0), 0, new string[](0), new uint256[](0));\r\n        }\r\n        uint256 offset = _page * _perPage;\r\n        require(offset < balance, \"page over\");\r\n        uint256 len = balance - offset;\r\n        if (len >= _perPage) {\r\n            len = _perPage;\r\n        }\r\n        Badge[] memory inventory = new Badge[](len);\r\n        string[] memory uris = new string[](len);\r\n        uint256[] memory ids = new uint256[](len);\r\n        uint256 id;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            id = tokenOfOwnerByIndex(_holder, offset + i);\r\n            inventory[i] = badges[id];\r\n            ids[i] = id;\r\n            uris[i] = tokenURI(id);\r\n        }\r\n        return (inventory, balance, uris, ids);\r\n    }\r\n\r\n    // for testing\r\n    function setMin(uint256 _m) external {\r\n        require(msg.sender == curator, \"only curator\");\r\n        minSTOG = _m;\r\n    }\r\n\r\n    /**\r\n    * @dev setStogie can only be called once\r\n    */\r\n    function setStogie(address _s) public {\r\n        require(msg.sender == curator, \"not curator\");\r\n        require(address(stogie) == address(0), \"stogie already set\");\r\n        stogie = IStogie(_s);\r\n    }\r\n\r\n    /**\r\n    * @dev issueID mints a new ID badge. The account must be an active stogie\r\n    *   staker. Can only be called by the Stogies contract.\r\n    */\r\n    function issueID(address _to) external {\r\n        require(msg.sender == address(stogie), \"you need to be stogie\");\r\n        uint256 min = minSTOG;\r\n        uint256 id = _issueID(_to, min);\r\n        (uint256 deposit,) = stogie.farmers(_to);\r\n        uint256 newSum = _transfer(address(0), _to, id, min);\r\n        require(\r\n            deposit >= newSum, \"need to stake more STOG\");\r\n    }\r\n\r\n    /**\r\n    * @dev issueID mints a new NFT. Caller needs to be holding enough STOG\r\n    */\r\n    function issueMeID() external {\r\n        uint256 min = minSTOG;\r\n        uint256 id = _issueID(msg.sender, min);\r\n        (uint256 deposit,) = stogie.farmers(msg.sender);\r\n        uint256 newSum = _transfer(address(0), msg.sender, id, min);\r\n        require(\r\n            deposit >= newSum, \"need to stake more STOG\");\r\n    }\r\n\r\n    function _issueID(address _to, uint256 min) internal returns (uint256 id) {\r\n        require(minters[_to] == 0, \"_to has already minted this pic\");\r\n        id = employeeHeight;\r\n        Badge storage c = badges[id];\r\n        c.state = State.Active;\r\n        c.minStog = min;                       // record the minSTOG\r\n        c.identiconSeed = _to;                 // save seed, used for the identicon\r\n        emit StateChanged(\r\n            id,\r\n            msg.sender,\r\n            State.Uninitialized,\r\n            State.Active\r\n        );\r\n        unchecked {employeeHeight = id + 1;}\r\n        minters[_to] = uint64(block.timestamp);// mark address as a minter\r\n    }\r\n\r\n    /**\r\n    * @dev expire a token.\r\n    *   Initiate s.PendingExpiry if account does not possess minimal stake.\r\n    *   Transfers the NFT to EXPIRED account.\r\n    * @param _tokenId the token to expire\r\n    */\r\n    function expire(uint256 _tokenId) external returns (State) {\r\n        Badge storage c = badges[_tokenId];\r\n        State s = c.state;\r\n        require(s == State.Active, \"invalid state\");     // must be Active\r\n        require(c.transferAt < block.number - uint256(GRACE_PERIOD),\r\n            \"during grace period\");                      // A 72 hour grace period is granted to recently transferred tokens\r\n        address o = c.owner;\r\n        uint256 bal = balanceOf(o);\r\n        (uint256 deposit,) = stogie.farmers(o);\r\n        uint256 min = (minStogSum[c.owner] * 1e13 / bal)\r\n            / 1e13 * bal;                                // assuming owner has at least 1\r\n        require(deposit < min, \"rule not satisfied\");    // deposit below the min?\r\n        expiredOwners[_tokenId] = o;\r\n        _transfer(c.owner, EXPIRED, _tokenId, c.minStog);// transfer to the expired address\r\n        c.state = State.PendingExpiry;                   // change state after transfer\r\n        emit StateChanged(\r\n            _tokenId,\r\n            msg.sender,\r\n            s,\r\n            State.PendingExpiry\r\n        );\r\n        return State.PendingExpiry;\r\n    }\r\n\r\n    /**\r\n    * @dev reactivate a token. Must be in State.PendingExpiry state.\r\n    *    At least a minimum of Stogies are needed to reactivate.\r\n    *    Can be called by expired owner.\r\n    * @param _tokenId the token to reactivate\r\n    * @return State the State.Active state if successful\r\n    */\r\n    function reactivate(uint256 _tokenId) external returns (State) {\r\n        Badge storage c = badges[_tokenId];\r\n        State s = c.state;\r\n        require(s == State.PendingExpiry, \"invalid state\");\r\n        address o = expiredOwners[_tokenId];\r\n        require(o == msg.sender, \"not your token\");\r\n        require(\r\n            block.number - c.transferAt >= DURATION_STATE_CHANGE,\r\n            \"time is up\");                                        // expiration must be under the deadline\r\n        uint256 newSum = _transfer(EXPIRED, o, _tokenId, minSTOG);// return token to owner\r\n        (uint256 deposit,) = stogie.farmers(o);\r\n        require(\r\n            deposit >= newSum, \"insert more STOG\");               // must have Stogies or staking Stogies\r\n        c.state = State.Active;\r\n        emit StateChanged(\r\n            _tokenId,\r\n            msg.sender,\r\n            State.PendingExpiry,\r\n            State.Active\r\n        );\r\n        expiredOwners[_tokenId] = address(0);\r\n        c.minStog = minSTOG;                                    // reset to current value\r\n        return State.Active;\r\n    }\r\n\r\n    /**\r\n    * @dev respawn an expired token. Can only be respawned by an address that\r\n    *    hasn't minted. This is because respawn changes the badge picture.\r\n    *    in other words, the c.identiconSeed is updated. The minimum Stogies\r\n    *    value of the NFT will be reset to the current minSTOG value.\r\n    * @param _tokenId the token id to respawn\r\n    */\r\n    function reclaim(uint256 _tokenId) external {\r\n        require(minters[msg.sender] == 0,\r\n            \"_to has minted a badge already\");                  // cannot mint more than one\r\n        Badge storage c = badges[_tokenId];\r\n        require(c.state == State.PendingExpiry, \"must be PendingExpiry\");\r\n        require(\r\n            c.transferAt < block.number - DURATION_STATE_CHANGE,\r\n            \"time is not up\");                                  // must be over the deadline\r\n        c.minStog = minSTOG;                                    // reset minStog\r\n        uint256 newSum = _transfer(EXPIRED, msg.sender, _tokenId, minSTOG);\r\n        (uint256 deposit,) = stogie.farmers(msg.sender);        // check caller's deposit\r\n        require(\r\n            deposit >= newSum,\r\n            \"insert more STOG\");                                // caller  must have Stogies or staking Stogies\r\n        emit StateChanged(\r\n            _tokenId,\r\n            msg.sender,\r\n            State.PendingExpiry,\r\n            State.Expired\r\n        );\r\n        emit StateChanged(\r\n            _tokenId,\r\n            msg.sender,\r\n            State.Expired,\r\n            State.Active\r\n        );\r\n        expiredOwners[_tokenId] = address(0);\r\n        c.state = State.Active;\r\n        c.identiconSeed = msg.sender;                           // change the identicon to reclaiming address\r\n        emit MetadataUpdate(_tokenId);\r\n        minters[c.identiconSeed] = 0;                           // allow original owner to mint again\r\n        minters[msg.sender] = uint64(block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * @notice allows the holder of the NFT to change the identiconSeed used to\r\n    *    generate the picture on the badge. Holder must not be on the minters\r\n    *    list. Can only be called once per address. See the rules for more details.\r\n    *\r\n    * @param _tokenId the token id to change the picture for\r\n    */\r\n    function snapshot(uint256 _tokenId) external {\r\n        Badge storage c = badges[_tokenId];\r\n        require(c.state == State.Active, \"state must be Active\");\r\n        require(c.owner == msg.sender, \"you must be the owner\");\r\n        require(\r\n            minters[msg.sender] == 0,\r\n            \"id with this pic already minted\"); // must be a fresh address\r\n        minters[c.identiconSeed] = 0;           // allow original minter user to mint again\r\n        c.identiconSeed = msg.sender;           // change to a new picture, destroying the old\r\n        emit MetadataUpdate(_tokenId);\r\n        minters[msg.sender] = uint64(block.number);\r\n        emit Snapshot(_tokenId, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * minSTOGChange allows the CEO of CryptoPunks to change the minSTOG\r\n    *    either increasing or decreasing by %2.5. Cannot be below 1 STOG, or\r\n    *    above 0.01% of staked SLP supply.\r\n    * @param _up increase by %2.5 if true, decrease otherwise.\r\n    */\r\n    function minSTOGChange(bool _up) external {unchecked {\r\n            require(msg.sender == cig.The_CEO(), \"need to be CEO\");\r\n            require(block.number > cig.taxBurnBlock() - 20, \"need to be CEO longer\");\r\n            require(block.number > minSTOGUpdatedAt + DURATION_MIN_CHANGE, \"wait more blocks\");\r\n            minSTOGUpdatedAt = uint64(block.number);\r\n            uint256 amt = minSTOG / 10000 * 250;                               // %2.5\r\n            uint256 newMin;\r\n            if (_up) {\r\n                newMin = minSTOG + amt;\r\n                require(newMin <= cig.stakedlpSupply() / 10000 * 1, \"too big\");// must be eq or less than 0.01% of staked supply\r\n            } else {\r\n                newMin = minSTOG - amt;\r\n                require(newMin > 1 ether, \"min too small\");\r\n            }\r\n            minSTOG = newMin;                                                  // write\r\n            emit MinSTOGChanged(minSTOG, amt);\r\n        }}\r\n\r\n    /**\r\n    * @dev called after an erc721 token transfer, after the counts have been updated\r\n    */\r\n    function _addEnumeration(address _to, uint256 _tokenId) internal {\r\n        uint256 last = balances[_to] - 1;  // the index of the last position\r\n        ownedBadges[_to][last] = _tokenId; // add a new entry\r\n        badges[_tokenId].index = uint64(last);\r\n    }\r\n\r\n    function _removeEnumeration(address _from, uint256 _tokenId) internal {\r\n        uint256 height = balances[_from] - 1;      // last index\r\n        uint256 i = badges[_tokenId].index;        // index\r\n        if (i != height) {\r\n            // If not last, move the last token to the slot of the token to be deleted\r\n            uint256 lastTokenId = ownedBadges[_from][height];\r\n            ownedBadges[_from][i] = lastTokenId;   // move the last token to the slot of the to-delete token\r\n            badges[lastTokenId].index = uint64(i); // update the moved token's index\r\n        }\r\n        badges[_tokenId].index = 0;                // delete from index\r\n        delete ownedBadges[_from][height];         // delete last slot\r\n    }\r\n\r\n    /***\r\n    * ERC721 functionality.\r\n    */\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256) {\r\n        return employeeHeight;\r\n    }\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `employeeHeight`.\r\n    /// @param _index A counter less than `employeeHeight`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < employeeHeight, \"index out of range\");\r\n        return _index; // index starts from 0\r\n    }\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\r\n        require(_index < balances[_owner], \"index out of range\");\r\n        require(_owner != address(0), \"invalid _owner\");\r\n        uint256 id = ownedBadges[_owner][_index];\r\n        require(badges[id].owner != address(0), \"token at _index not found\");\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address _holder) public view returns (uint256) {\r\n        require(_holder != address(0), \"invalid _owner\");\r\n        return balances[_holder];\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return \"Employee ID Badges\";\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return \"EMPLOYEE\";\r\n    }\r\n\r\n    bytes constant badgeStart = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"600\" height=\"500\" shape-rendering=\"crispEdges\"><defs><style>.g2,.g4,.g5{stroke:#000;fill:#a8a9a8;stroke-width:0}.g4,.g5{fill:#dcdddc}.g5{fill:#696a69}.g7{fill:#dedede}.g9{fill:#a0a0a0}.g10{fill:#7c7b7e}.w{fill:#fff}.boxb{fill:#38535e}</style></defs><path d=\"M30 100h230v10H30zM20 110h10v10H20zM10 120h10v360H10zM20 480h10v10H20zM30 490h540v10H30zM570 480h10v10h-10zM580 120h10v360h-10zM570 110h10v10h-10zM340 100h230v10H340z\"/><path d=\"M320 120h260v340H320z\" style=\"fill:#ebebeb\"/><path d=\"M20 130h300v340H20zM20 120h550v10H20z\" class=\"g7\"/><path d=\"M20 120h10v10H20zM20 460h10v10H20zM30 110h540v10H30zM570 120h10v10h-10z\" class=\"w\"/><path d=\"M570 130h10v10h-10zM570 450h10v10h-10z\" class=\"g7\"/><path d=\"M570 460h10v10h-10z\" class=\"w\"/><path d=\"M320 460h250v10H320z\" class=\"g4\"/><path d=\"M30 470h540v10H30z\" class=\"w\"/><path d=\"M30 480h540v10H30zM20 470h10v10H20zM570 470h10v10h-10z\" class=\"g9\"/><path d=\"M330 0h10v130h-10z\"/><path d=\"M260 0h80v10h-80zM260 120h80v10h-80z\"/><path d=\"M260 0h10v130h-10z\"/><path d=\"M270 10h20v60h-20z\" class=\"g2\"/><path d=\"M290 10h40v60h-40z\" style=\"stroke:#000;fill:#ccc;stroke-width:0\"/><path d=\"M270 70h60v20h-60z\" class=\"g4\"/><path d=\"M290 50h20v10h-20zM290 70h20v10h-20zM280 60h10v10h-10zM310 60h10v10h-10zM280 90h40v10h-40z\"/><path d=\"M280 70h10v10h-10zM310 70h10v10h-10zM320 60h10v10h-10z\" class=\"g2\"/><path d=\"M270 80h10v10h-10zM320 80h10v10h-10z\"/><path d=\"M270 100h60v20h-60z\" style=\"stroke:#000;fill:#7a7a7a;stroke-width:0\"/><path d=\"M280 100h40v10h-40zM270 90h10v10h-10zM320 90h10v10h-10z\" class=\"g5\"/><path d=\"M260 130h80v10h-80z\" style=\"fill:#bebfbe;stroke-width:0\"/><path d=\"M40 160h240v250H40z\" style=\"stroke:#38535e;fill:#598495;stroke-width:0;stroke-alignment:inner\"/><path d=\"M40 160h240v10H40z\" class=\"boxb\"/><path d=\"M40 160h10v250H40z\" class=\"boxb\"/><path d=\"M40 400h240v10H40z\" class=\"boxb\"/><path d=\"M270 160h10v250h-10z\" class=\"boxb\"/><path d=\"M310 380h240v20H310zM310 340h60v20h-60zM380 340h60v20h-60zM450 340h30v20h-30zM490 340h20v20h-20zM520 340h30v20h-30z\" class=\"g10\"/>';\r\n    bytes constant badgeText = '<svg><defs><style>@font-face {font-family: \"C64\";src: url(data:font/woff2;base64,d09GMgABAAAAAAVgAA0AAAAAFlgAAAUJAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGhgGYACCWhEICpsEkngLgRwAATYCJAOBbgQgBYQZB4NcG8oQIxGmjE4A4K+TJ0Osoz0yHHiUIkeu8JnCS5uIH1YhT02PLEKlTJ7cqgZVF/5IPHyugb2f7G5SAkXAGljj+Hr2gK6WSeiyg3PnT0iMUWvb91CYfvgbZppEPEaGUigFhE0YA/WRi3POTSggSRRs2fnJ2yeodbZZS3aT5NqzSb5BVxKj6QrdHMN9vERqLCweg+Eon8X6+uo2ar9f/XKLyXSxG1KhEc0iIT+B+6KChSLq0RKhkhiaSi2eIqURK5lMKJlF3GQEMrhGtO1N/74I+LMvU4FPHryBP75yAIXRGA8SOiTkMiVu6qk6hE6HTsjqyBRDN6RUIxAAcGSFcSOOGBYNRZgFcRm9ArNQyMiYhgJHMQLTsDaBqkqYK2DYGmaxS7RG+9l+oAIy6IiBAERCAgAEmQ4A+qH8VNQgwLhXk+wdpp+fVqc3GE1mEeRfRojWAPsAd7Ee0kfyaYhVENsAkGjkSLKQBEUiwcczH8tj/BlZjPR4gciOhukMmG/KPkMmmc0uuWmX7vPFjZQCTKpgN+4z58WghjLNctLuw6qV7mzQFaQCKPjwbOxyRrRqww5jG54lgTpsLi3QH/iqrBWMoFWcTDY6QmOfrVTozOCl7F1evHrv9iAMzShgDTA/KkFTbR4xVisj1YDKNcsYXonRTZiFGJc9rPsYza7KqMo4bBzqMTNDzNQ1l47OjQ3lXd26BA7vUdPRU4hvGaPT8ywb8swsskD+EsahHh1dPpzz9uUMix8UdUNi2YAfuxDlzC5gWqqmqWsjrK2laIRALSvnilvXRppxJ1ePi1aV47jqbJ9eQbiH7Sbfs48oewX3cKofdLojr+rLGjEyjpQIm+VOY/cJG3eK5DX7sJzeFFVHRuvep641aKXl+UL1ma56eRh9ldT9GDGyPCdL85UU+LA+qiN/zrHa2uGPJ/TIKHqeop5Ha3NLFHFspGdLghd6AgUoRpTdTSHLT9TqwVwc6y3IIatqwjAogOmjn+dVGgrzNfQLN34S35USopfAxoYuaOwykhOkB/bkWAKk6ZxgRWuw1nh5KkHiENHImzSY6+xKj3sC9taEpeknfdBVklDE0Id1GE8pKXVxSjU70sggixzyKKCIEsqgIUGGAhUWWGFLs/+lOf7hhAtueOCFD34EEEQIYUQQRQxxeeK4k+TuSfDjjeRcRgoqARYybCjfYTh8p25MpS0FFKifGgFi/c9/+De//W3YHHrPm8V/gagSCIqGEaASAIAlFVCFihEovLkrylL0tWavtplBK5dEecQJAvsQDJQEPCwkjPVSABZp6jQUV6QJ92g22Z92ir9pb2psuXgwxBmM6EbgIOg0jHVOmnCHZot8aWesv2hvQ6SHDEbHcR+zONk52Fnw5gEqouXmbWfOihCt3GjBSZDNcI041cvN6uhiSYIn3xCptvwCJPFfW9GJn3gTPyQ0b5DPWEQWF9ibnk3Ug0fY62T/XvjFcNjc0t3O2AV+pe2oOU8P6pq7uFo7OiAcrJwc1XRbPuF9MLQ6HS3H99AeknDy8qjeoYVnZdgqzUADbejzGxb0fHZFF+g3HMXT9PSmrAx+wX0gIskGk2hcqtQarU5vMJrMFqvN7nC63B4vgAgTyrAcL4iSHCCk0nTDtGzH9XyECWUcL4iSrKiabpiW7bhe/bf/7yORMBGixBBLXKovbQhnIAgMgcLAwhGfTgAEgSFQGFg44tMZgCAwBAoDq3Y=);}.t {fill: #ff04b4; stroke: none; font-size: 26px; font-family: \\'C64\\',monospace; text-anchor: end}</style></defs><text x=\"550px\" y=\"190px\" class=\"t\">CIG FACTORY</text><text x=\"550px\" y=\"232px\" class=\"t\">EMPLOYEE</text><text x=\"550px\" y=\"274px\" class=\"t\">#';\r\n    bytes constant badgeEnd = '</text><text x=\"550px\" y=\"320px\" style=\"font-family: \\'C64\\',monospace; text-anchor: end; font-size: 16.5px; fill: #a7a7a7;\">CONFIDIMUS IN CEO</text></svg></svg>';\r\n\r\n    function _generateBadge(uint256 _tokenId, address _seed) internal view\r\n    returns (bytes memory, bytes32[] memory traits) {\r\n        DynamicBufferLib.DynamicBuffer memory result;\r\n        string memory bars = barcode.draw(_tokenId, \"40\", \"408\", \"ebebeb\", 52, 6);\r\n        traits = identicons.pick(_seed, 0);\r\n        string memory punk = pblocks.svgFromKeys(traits, 40, 160, 240, orderConfigId);\r\n        result.append(badgeStart, bytes(bars), bytes(punk));\r\n        result.append(badgeText, bytes(_intToString(_tokenId)), badgeEnd);\r\n        return (result.data, traits);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 _tokenId) public view returns (string memory) {\r\n        DynamicBufferLib.DynamicBuffer memory result;\r\n        require(_tokenId < employeeHeight, \"index out of range\");\r\n        Badge storage c = badges[_tokenId];\r\n        (bytes memory badge, bytes32[] memory traits) = _generateBadge(_tokenId, c.identiconSeed);\r\n        result.append('{\\n\"description\": \"Employee ID Badges for the Cigarette Factory\",', \"\\n\",\r\n            '\"external_url\": \"https://cigtoken.eth.limo/#badge-');\r\n        result.append(bytes(_intToString(_tokenId)), '\",', \"\\n\");\r\n        result.append('\"image\": \"data:image/svg+xml;base64,');\r\n        result.append(bytes(Base64.encode(badge)), '\",', \"\\n\");\r\n        result.append('\"attributes\": [ ', _getAttributes(traits), \"]\\n}\");\r\n        return string(abi.encodePacked(\"data:application/json;base64,\",\r\n            Base64.encode(\r\n                result.data\r\n            )\r\n        ));\r\n    }\r\n\r\n    function _getAttributes(bytes32[] memory traits) internal view returns (bytes memory) {\r\n        DynamicBufferLib.DynamicBuffer memory result;\r\n        bytes memory comma = \"\";\r\n        for (uint256 i = 0; i < traits.length; i++) {\r\n            if (comma.length > 0) {\r\n                result.append(comma);\r\n            } else {\r\n                comma = \",\\n\";\r\n            }\r\n            Attribute memory a = atts[traits[i]];\r\n            if (a.isType) {\r\n                result.append('{\"trait_type\": \"Type\", \"value\": \"', a.value, '\"}');\r\n            } else {\r\n                result.append('{\"trait_type\": \"Accessory\", \"value\": \"', a.value, '\"}');\r\n            }\r\n        }\r\n        return result.data;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        require(_tokenId < employeeHeight, \"index out of range\");\r\n        Badge storage c = badges[_tokenId];\r\n        address o = c.owner;\r\n        require(o != address(0), \"not minted.\");\r\n        return o;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    *  operator, or the approved address for this NFT. Throws if `_from` is\r\n    *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    *  `_tokenId` is not a valid NFT.\r\n    * @param _from The current owner of the NFT\r\n    * @param _to The new owner\r\n    * @param _tokenId The NFT to transfer\r\n    */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) external {\r\n        require(_to != EXPIRED, \"cannot transfer there\");\r\n        _validateTransfer(_from, _tokenId);\r\n        _transfer(_from, _to, _tokenId, badges[_tokenId].minStog);\r\n        require(_checkOnERC721Received(_from, _to, _tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n    * @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    *  operator, or the approved address for this NFT. Throws if `_from` is\r\n    *  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    *  `_tokenId` is not a valid NFT.\r\n    * @param _from The current owner of the NFT\r\n    * @param _to The new owner\r\n    * @param _tokenId The NFT to transfer\r\n    */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        require(_to != EXPIRED, \"cannot transfer there\");\r\n        bytes memory data = new bytes(0);\r\n        _validateTransfer(_from, _tokenId);\r\n        _transfer(_from, _to, _tokenId, badges[_tokenId].minStog);\r\n        require(_checkOnERC721Received(_from, _to, _tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        require(_to != EXPIRED, \"cannot transfer there\");\r\n        _validateTransfer(_from, _tokenId);\r\n        _transfer(_from, _to, _tokenId, badges[_tokenId].minStog);\r\n    }\r\n\r\n    /**\r\n    * @dev _validateTransfer does a check to see if the _tokenId id an existing\r\n    *   id, and _form is the owner of the token. It then checks the approval.\r\n    */\r\n    function _validateTransfer(address _from, uint256 _tokenId) internal {\r\n        address a;\r\n        address o = badges[_tokenId].owner;                 // assuming o can never be address(0)\r\n        require(o == _from, \"_from must be owner\");         // also ensures that the badge exists & owner is not 0x0\r\n        a = badges[_tokenId].approval;                      // a is an address that has approval\r\n        require(\r\n            msg.sender == address(stogie) ||                // is executed by the Stogies contract\r\n            o == msg.sender ||                              // or executed by owner\r\n            a == msg.sender ||                              // or owner approved the sender\r\n            (approvalAll[o][msg.sender]), \"not permitted\"); // or owner approved the operator, who's the sender\r\n        if (a != address(0)) {\r\n            badges[_tokenId].approval = address(0);          // clear previous approval\r\n            emit Approval(msg.sender, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev _transfer is a low-level token transfer between addresses without\r\n    *    checking approvals. It can mint if _from is 0x0. It can send Active\r\n    *    tokens to the EXPIRED account, or tokens that are PendingExpiry out\r\n    *    of the EXPIRED account. On each transfer, the function will recalculate\r\n    *    the sum minSTOG (minimum STOG required) for both parties\r\n    *    The function also records the time of transfer and updates enumeration.\r\n    * @param _from address transferring from\r\n    * @param _to address transferring to\r\n    * @param _tokenId, the token identifier\r\n    * @param _min, the minimum stogie required for that token\r\n    * @return toSum the sum of minSTOG for the receiver\r\n\r\n    */\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        uint256 _min) internal\r\n    returns (uint256 toSum) {\r\n        if (_from != address(0)) {\r\n            //require(_tokenId < employeeHeight, \"index out of range\");\r\n            require(_from != _to, \"cannot send to self\");\r\n            require(_to != address(0), \"_to is zero\");\r\n            if (_from == EXPIRED) {\r\n                require(badges[_tokenId].state == State.PendingExpiry, \"state must be PendingExpiry\");\r\n            } else {\r\n                require(badges[_tokenId].state == State.Active, \"state must be Active\");\r\n            }\r\n            _removeEnumeration(_from, _tokenId);\r\n            --balances[_from];\r\n            minStogSum[_from] -= _min;\r\n        }\r\n        uint256 toBal;\r\n        unchecked {toBal = ++balances[_to];}\r\n        toSum = minStogSum[_to];\r\n        toSum += _min;\r\n        minStogSum[_to] = toSum;\r\n        badges[_tokenId].owner = _to;                            // set new owner\r\n        badges[_tokenId].transferAt = uint64(block.number);\r\n        _addEnumeration(_to, _tokenId);\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev approve can be set by the owner or operator\r\n    * @param _to The new approved NFT controller\r\n    * @param _tokenId The NFT to approve\r\n    */\r\n    function approve(address _to, uint256 _tokenId) external {\r\n        require(_tokenId < employeeHeight, \"index out of range\");\r\n        address o = badges[_tokenId].owner;\r\n        require(o == msg.sender || isApprovedForAll(o, msg.sender), \"action on token not permitted\");\r\n        badges[_tokenId].approval = _to;\r\n        emit Approval(msg.sender, _to, _tokenId);\r\n    }\r\n    /**\r\n    * @dev approve can be set by the owner or operator\r\n    * @param _operator Address to add to the set of authorized operators\r\n    * @param _approved True if the operator is approved, false to revoke approval\r\n    */\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        approvalAll[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n    * @notice Get the approved address for a single NFT\r\n    * @dev Throws if `_tokenId` is not a valid NFT.\r\n    * @param _tokenId The NFT to find the approved address for\r\n    * @return Will always return address(this)\r\n    */\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return badges[_tokenId].approval;\r\n    }\r\n\r\n    /**\r\n    * @param _owner The address that owns the NFTs\r\n    * @param _operator The address that acts on behalf of the owner\r\n    * @return Will always return false\r\n    */\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return approvalAll[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n    * @notice Query if a contract implements an interface\r\n    * @param interfaceId The interface identifier, as specified in ERC-165\r\n    * @dev Interface identification is specified in ERC-165. This function\r\n    *  uses less than 30,000 gas.\r\n    * @return `true` if the contract implements `interfaceID` and\r\n    *  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    */\r\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            interfaceId == type(IERC165).interfaceId ||\r\n            interfaceId == type(IERC721Enumerable).interfaceId ||\r\n            interfaceId == type(IERC721TokenReceiver).interfaceId;\r\n    }\r\n\r\n    // we do not allow NFTs to be send to this contract, except internally\r\n    function onERC721Received(\r\n        address /*_operator*/,\r\n        address /*_from*/,\r\n        uint256 /*_tokenId*/,\r\n        bytes memory /*_data*/) external view returns (bytes4) {\r\n        if (msg.sender == address(this)) {\r\n            return RECEIVED;\r\n        }\r\n        revert(\"nope\");\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n    * The call is not executed if the target address is not a contract.\r\n    *\r\n    * @param from address representing the previous owner of the given token ID\r\n    * @param to target address that will receive the tokens\r\n    * @param tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes optional data to send along with the call\r\n    * @return bool whether the call correctly returned the expected magic value\r\n    *\r\n    * credits https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol\r\n    */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (isContract(to)) {\r\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n            return false; // not needed, but the ide complains that there's \"no return statement\"\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n    /**\r\n    * owner is part of the Ownable interface\r\n    */\r\n    function owner() external view returns (address) {\r\n        return curator;\r\n    }\r\n    /**\r\n    * renounceOwnership is part of the Ownable interface\r\n    */\r\n    function renounceOwnership() external {\r\n        require(msg.sender == curator);\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        address oldOwner = curator;\r\n        curator = _newOwner;\r\n        emit OwnershipTransferred(oldOwner, _newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev return the primary id for the user. If none is set, return the first\r\n    *    token of owner with the index of 0.\r\n    * @return uin256 id chosen by the user as the primary\r\n    */\r\n    function primaryId(address _a) view public returns (uint256) {\r\n        uint256 id = pID[_a];\r\n        if (id == 0) {\r\n            if (balances[_a] == 0) {\r\n                return 0;                    // no primary set, and address has no badges\r\n            }\r\n            id = tokenOfOwnerByIndex(_a, 0); // no primary set\r\n        }\r\n        return id;\r\n    }\r\n\r\n    function setPrimaryId(uint256 _tokenId) external {\r\n        Badge storage c = badges[_tokenId];\r\n        require(msg.sender == c.owner, \"must be owner\");\r\n        pID[msg.sender] = _tokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * credits https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function _intToString(uint256 value) public pure returns (string memory) {\r\n        // Inspired by openzeppelin's implementation - MIT licence\r\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol#L15\r\n        // this version removes the decimals counting\r\n        uint8 count;\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 digits = 31;\r\n        // bytes and strings are big endian, so working on the buffer from right to left\r\n        // this means we won't need to reverse the string later\r\n        bytes memory buffer = new bytes(32);\r\n        while (value != 0) {\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n            digits -= 1;\r\n            count++;\r\n        }\r\n        uint256 temp;\r\n        assembly {\r\n            temp := mload(add(buffer, 32))\r\n            temp := shl(mul(sub(32, count), 8), temp)\r\n            mstore(add(buffer, 32), temp)\r\n            mstore(buffer, count)\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n/**\r\n* DynamicBufferLib adapted from\r\n* https://github.com/Vectorized/solady/blob/main/src/utils/DynamicBufferLib.sol\r\n*/\r\nlibrary DynamicBufferLib {\r\n    /// @dev Type to represent a dynamic buffer in memory.\r\n    /// You can directly assign to `data`, and the `append` function will\r\n    /// take care of the memory allocation.\r\n    struct DynamicBuffer {\r\n        bytes data;\r\n    }\r\n\r\n    /// @dev Appends `data` to `buffer`.\r\n    /// Returns the same buffer, so that it can be used for function chaining.\r\n    function append(DynamicBuffer memory buffer, bytes memory data)\r\n    internal\r\n    pure\r\n    returns (DynamicBuffer memory)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if mload(data) {\r\n                let w := not(31)\r\n                let bufferData := mload(buffer)\r\n                let bufferDataLength := mload(bufferData)\r\n                let newBufferDataLength := add(mload(data), bufferDataLength)\r\n            // Some random prime number to multiply `capacity`, so that\r\n            // we know that the `capacity` is for a dynamic buffer.\r\n            // Selected to be larger than any memory pointer realistically.\r\n                let prime := 1621250193422201\r\n                let capacity := mload(add(bufferData, w))\r\n\r\n            // Extract `capacity`, and set it to 0, if it is not a multiple of `prime`.\r\n                capacity := mul(div(capacity, prime), iszero(mod(capacity, prime)))\r\n\r\n            // Expand / Reallocate memory if required.\r\n            // Note that we need to allocate an exta word for the length, and\r\n            // and another extra word as a safety word (giving a total of 0x40 bytes).\r\n            // Without the safety word, the data at the next free memory word can be overwritten,\r\n            // because the backwards copying can exceed the buffer space used for storage.\r\n                for {} iszero(lt(newBufferDataLength, capacity)) {} {\r\n                // Approximately double the memory with a heuristic,\r\n                // ensuring more than enough space for the combined data,\r\n                // rounding up to the next multiple of 32.\r\n                    let newCapacity :=\r\n                    and(add(capacity, add(or(capacity, newBufferDataLength), 32)), w)\r\n\r\n                // If next word after current buffer is not eligible for use.\r\n                    if iszero(eq(mload(0x40), add(bufferData, add(0x40, capacity)))) {\r\n                    // Set the `newBufferData` to point to the word after capacity.\r\n                        let newBufferData := add(mload(0x40), 0x20)\r\n                    // Reallocate the memory.\r\n                        mstore(0x40, add(newBufferData, add(0x40, newCapacity)))\r\n                    // Store the `newBufferData`.\r\n                        mstore(buffer, newBufferData)\r\n                    // Copy `bufferData` one word at a time, backwards.\r\n                        for {let o := and(add(bufferDataLength, 32), w)} 1 {} {\r\n                            mstore(add(newBufferData, o), mload(add(bufferData, o)))\r\n                            o := add(o, w) // `sub(o, 0x20)`.\r\n                            if iszero(o) {break}\r\n                        }\r\n                    // Store the `capacity` multiplied by `prime` in the word before the `length`.\r\n                        mstore(add(newBufferData, w), mul(prime, newCapacity))\r\n                    // Assign `newBufferData` to `bufferData`.\r\n                        bufferData := newBufferData\r\n                        break\r\n                    }\r\n                // Expand the memory.\r\n                    mstore(0x40, add(bufferData, add(0x40, newCapacity)))\r\n                // Store the `capacity` multiplied by `prime` in the word before the `length`.\r\n                    mstore(add(bufferData, w), mul(prime, newCapacity))\r\n                    break\r\n                }\r\n            // Initalize `output` to the next empty position in `bufferData`.\r\n                let output := add(bufferData, bufferDataLength)\r\n            // Copy `data` one word at a time, backwards.\r\n                for {let o := and(add(mload(data), 32), w)} 1 {} {\r\n                    mstore(add(output, o), mload(add(data, o)))\r\n                    o := add(o, w) // `sub(o, 0x20)`.\r\n                    if iszero(o) {break}\r\n                }\r\n            // Zeroize the word after the buffer.\r\n                mstore(add(add(bufferData, 0x20), newBufferDataLength), 0)\r\n            // Store the `newBufferDataLength`.\r\n                mstore(bufferData, newBufferDataLength)\r\n            }\r\n        }\r\n        return buffer;\r\n    }\r\n    /*\r\n        /// @dev Appends `data0`, `data1` to `buffer`.\r\n    /// Returns the same buffer, so that it can be used for function chaining.\r\n    function append(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1)\r\n    internal\r\n    pure\r\n    returns (DynamicBuffer memory)\r\n    {\r\n        return append(append(buffer, data0), data1);\r\n    }\r\n*/\r\n    /// @dev Appends `data0`, `data1`, `data2` to `buffer`.\r\n    /// Returns the same buffer, so that it can be used for function chaining.\r\n    function append(\r\n        DynamicBuffer memory buffer,\r\n        bytes memory data0,\r\n        bytes memory data1,\r\n        bytes memory data2\r\n    ) internal pure returns (DynamicBuffer memory) {\r\n        return append(append(append(buffer, data0), data1), data2);\r\n    }\r\n    /*\r\n\r\n        /// @dev Appends `data0`, `data1`, `data2`, `data3` to `buffer`.\r\n    /// Returns the same buffer, so that it can be used for function chaining.\r\n    function append(\r\n        DynamicBuffer memory buffer,\r\n        bytes memory data0,\r\n        bytes memory data1,\r\n        bytes memory data2,\r\n        bytes memory data3\r\n    ) internal pure returns (DynamicBuffer memory) {\r\n        return append(append(append(append(buffer, data0), data1), data2), data3);\r\n    }\r\n\r\n    /// @dev Appends `data0`, `data1`, `data2`, `data3`, `data4` to `buffer`.\r\n    /// Returns the same buffer, so that it can be used for function chaining.\r\n    function append(\r\n        DynamicBuffer memory buffer,\r\n        bytes memory data0,\r\n        bytes memory data1,\r\n        bytes memory data2,\r\n        bytes memory data3,\r\n        bytes memory data4\r\n    ) internal pure returns (DynamicBuffer memory) {\r\n        append(append(append(append(buffer, data0), data1), data2), data3);\r\n        return append(buffer, data4);\r\n    }\r\n\r\n    /// @dev Appends `data0`, `data1`, `data2`, `data3`, `data4`, `data5` to `buffer`.\r\n    /// Returns the same buffer, so that it can be used for function chaining.\r\n    function append(\r\n        DynamicBuffer memory buffer,\r\n        bytes memory data0,\r\n        bytes memory data1,\r\n        bytes memory data2,\r\n        bytes memory data3,\r\n        bytes memory data4,\r\n        bytes memory data5\r\n    ) internal pure returns (DynamicBuffer memory) {\r\n        append(append(append(append(buffer, data0), data1), data2), data3);\r\n        return append(append(buffer, data4), data5);\r\n    }\r\n\r\n    /// @dev Appends `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6` to `buffer`.\r\n    /// Returns the same buffer, so that it can be used for function chaining.\r\n    function append(\r\n        DynamicBuffer memory buffer,\r\n        bytes memory data0,\r\n        bytes memory data1,\r\n        bytes memory data2,\r\n        bytes memory data3,\r\n        bytes memory data4,\r\n        bytes memory data5,\r\n        bytes memory data6\r\n    ) internal pure returns (DynamicBuffer memory) {\r\n        append(append(append(append(buffer, data0), data1), data2), data3);\r\n        return append(append(append(buffer, data4), data5), data6);\r\n    }\r\n    */\r\n}\r\n\r\n/**\r\n * @dev Provides a set of functions to operate with Base64 strings.\r\n *\r\n * _Available since v4.5._\r\n */\r\nlibrary Base64 {\r\n    /**\r\n     * @dev Base64 Encoding/Decoding Table\r\n     */\r\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n    /**\r\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\r\n     */\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        /**\r\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\r\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\r\n         */\r\n        if (data.length == 0) return \"\";\r\n\r\n        // Loads the table into memory\r\n        string memory table = _TABLE;\r\n\r\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\r\n        // and split into 4 numbers of 6 bits.\r\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\r\n        // - `data.length + 2`  -> Round up\r\n        // - `/ 3`              -> Number of 3-bytes chunks\r\n        // - `4 *`              -> 4 characters for each chunk\r\n        string memory result = new string(4 * ((data.length + 2) / 3));\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n        // Prepare the lookup table (skip the first \"length\" byte)\r\n            let tablePtr := add(table, 1)\r\n        // Prepare result pointer, jump over length\r\n            let resultPtr := add(result, 32)\r\n        // Run over the input, 3 bytes at a time\r\n            for {\r\n                let dataPtr := data\r\n                let endPtr := add(data, mload(data))\r\n            } lt(dataPtr, endPtr) {\r\n\r\n            } {\r\n            // Advance 3 bytes\r\n                dataPtr := add(dataPtr, 3)\r\n                let input := mload(dataPtr)\r\n            // To write each character, shift the 3 bytes (18 bits) chunk\r\n            // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\r\n            // and apply logical AND with 0x3F which is the number of\r\n            // the previous character in the ASCII table prior to the Base64 Table\r\n            // The result is then added to the table to get the character to write,\r\n            // and finally write it in the result pointer but with a left shift\r\n            // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n            }\r\n        // When data `bytes` is not exactly 3 bytes long\r\n        // it is padded with `=` characters at the end\r\n            switch mod(mload(data), 3)\r\n            case 1 {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n                mstore8(sub(resultPtr, 2), 0x3d)\r\n            }\r\n            case 2 {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\ninterface IStogie {\r\n    function farmers(address _user) external view returns (uint256 deposit, uint256 rewardDept);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function getMinETHDeposit() view external returns (uint256 r);\r\n    function onboard(\r\n        address _to,\r\n        uint256 _amountOutMin,\r\n        bool _depositIt,\r\n        bool _mintID\r\n    ) external payable returns(\r\n        uint[] memory swpAmt, uint addedA, uint addedB, uint liquidity\r\n    );\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n */\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns (bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface IERC721Enumerable {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165, IERC721Metadata, IERC721Enumerable, IERC721TokenReceiver {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface ICigToken {\r\n    function stakedlpSupply() external view returns (uint256);\r\n    function taxBurnBlock() external view returns (uint256);\r\n    function The_CEO() external view returns (address);\r\n}\r\n\r\ninterface IPunkIdenticons {\r\n    function pick(\r\n        address _a,\r\n        uint64 _cid) view external returns (bytes32[] memory);\r\n\r\n}\r\n\r\ninterface IPunkBlocks {\r\n    function svgFromKeys(\r\n        bytes32[] calldata _attributeKeys,\r\n        uint16 _x,\r\n        uint16 _y,\r\n        uint16 _size,\r\n        uint32 _orderID) external view returns (string memory);\r\n}\r\n\r\ninterface IBarcode {\r\n    function draw(\r\n        uint256 _in,\r\n        string memory _x,\r\n        string memory _y,\r\n        string memory _color,\r\n        uint16 _height,\r\n        uint8 _barWidth) view external returns (string memory);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cig\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_duration_min_change\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_duration_state_change\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"_gracePeriod\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_identicons\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pblocks\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_barcode\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_configId\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"MetadataUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minSTOG\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"MinSTOGChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Snapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum EmployeeIDBadges.State\",\"name\":\"s0\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum EmployeeIDBadges.State\",\"name\":\"s1\",\"type\":\"uint8\"}],\"name\":\"StateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"_intToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"avgMinSTOG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"badges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"identiconSeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStog\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"approval\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"transferAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"enum EmployeeIDBadges.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"k\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"isType\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"internalType\":\"struct EmployeeIDBadges.AttInit[]\",\"name\":\"_atts\",\"type\":\"tuple[]\"}],\"name\":\"completeInitialization1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_list\",\"type\":\"address[]\"}],\"name\":\"completeInitialization2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"employeeHeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"expire\",\"outputs\":[{\"internalType\":\"enum EmployeeIDBadges.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"expiredOwners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_page\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_perPage\",\"type\":\"uint16\"}],\"name\":\"getBadges\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"identiconSeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStog\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"approval\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"transferAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"enum EmployeeIDBadges.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"internalType\":\"struct EmployeeIDBadges.Badge[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint32\",\"name\":\"balance\",\"type\":\"uint32\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"identiconSeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStog\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"approval\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"transferAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"enum EmployeeIDBadges.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"internalType\":\"struct EmployeeIDBadges.Badge[]\",\"name\":\"inventory\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"uris\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"identiconSeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStog\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"approval\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"transferAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"enum EmployeeIDBadges.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"internalType\":\"struct EmployeeIDBadges.Badge[]\",\"name\":\"expInventory\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"expUris\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"expIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"issueID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"issueMeID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSTOG\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_up\",\"type\":\"bool\"}],\"name\":\"minSTOGChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSTOGUpdatedAt\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minStogSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minters\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a\",\"type\":\"address\"}],\"name\":\"primaryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"reactivate\",\"outputs\":[{\"internalType\":\"enum EmployeeIDBadges.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"reclaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_m\",\"type\":\"uint256\"}],\"name\":\"setMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"setPrimaryId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_s\",\"type\":\"address\"}],\"name\":\"setStogie\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"snapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stogie\",\"outputs\":[{\"internalType\":\"contract IStogie\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EmployeeIDBadges", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "000000000000000000000000cb56b52316041a62b6b5d0583dce4a8ae7a3c6290000000000000000000000000000000000000000000000000000000000034bc0000000000000000000000000000000000000000000000000000000000009e3400000000000000000000000000000000000000000000000000000000000005460000000000000000000000000c55c7913be9e9748ff10a4a7af86a5af25c46047000000000000000000000000e91eb909203c8c8cad61f86fc44edee9023bda4d0000000000000000000000004872bc4a6b29e8141868c3fe0d4aee70e9ea67350000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cebcd633788c0a062d0a324630e76433ba567f5644a56160fa9fd27d81aea83d"}