{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/FallbackHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\n\\nimport \\\"../helpers/Utils.sol\\\";\\nimport \\\"./CoreStorage.sol\\\";\\nimport \\\"./Lockers.sol\\\" as Lockers;\\n\\n/// @title Cyan Wallet Fallback Handler - A Cyan wallet's fallback handler.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\ncontract FallbackHandler is CoreStorage, IERC721Receiver, IERC1155Receiver {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"));\\n    bytes4 internal constant ERC1271_MAGIC_VALUE = 0x1626ba7e;\\n\\n    // bytes4(keccak256(\\\"supportsInterface(bytes4)\\\"))\\n    bytes4 private constant ERC165_INTERFACE = 0x01ffc9a7;\\n\\n    // bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    bytes4 private constant ERC1155_RECEIVED = 0xf23a6e61;\\n\\n    // bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"));\\n    bytes4 private constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\\n\\n    // bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"));\\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\\n\\n    event EthTransferred(address indexed receiver, uint256 value);\\n\\n    /// @notice Allows the wallet to receive an ERC721 tokens.\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure returns (bytes4) {\\n        return ERC721_RECEIVED;\\n    }\\n\\n    /// @notice Allows the wallet to receive an ERC1155 token.\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external pure returns (bytes4) {\\n        return ERC1155_RECEIVED;\\n    }\\n\\n    /// @notice Allows the wallet to receive an ERC1155 tokens.\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external pure returns (bytes4) {\\n        return ERC1155_BATCH_RECEIVED;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\n        return\\n            interfaceId == type(IERC1155Receiver).interfaceId ||\\n            interfaceId == type(IERC721Receiver).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n    /// @notice Return whether the signature provided is valid for the provided data.\\n    /// @param data Data signed on the behalf of the wallet.\\n    /// @param signature Signature byte array associated with the data.\\n    /// @return magicValue Returns a magic value (0x1626ba7e) if the given signature is correct.\\n    function isValidSignature(bytes32 data, bytes calldata signature) external view returns (bytes4 magicValue) {\\n        require(signature.length == 65, \\\"Invalid signature length.\\\");\\n        address signer = Utils.recoverSigner(data, signature);\\n        require(signer == _owner, \\\"Invalid signer.\\\");\\n        return ERC1271_MAGIC_VALUE;\\n    }\\n\\n    function isLockedERC721(address collection, uint256 tokenId) external view returns (bool) {\\n        return Lockers.isLockedERC721(collection, tokenId);\\n    }\\n\\n    function isLockedByCyanPlanERC721(address collection, uint256 tokenId) external view returns (bool) {\\n        return Lockers.isLockedByCyanPlanERC721(collection, tokenId);\\n    }\\n\\n    function isLockedByApePlan(address collection, uint256 tokenId) external view returns (bool) {\\n        return Lockers.isLockedByApePlan(collection, tokenId);\\n    }\\n\\n    function getLockedERC1155Amount(address collection, uint256 tokenId) external view returns (uint256) {\\n        return Lockers.getLockedERC1155Amount(collection, tokenId);\\n    }\\n\\n    function getApeLockState(address collection, uint256 tokenId) external view returns (uint8) {\\n        return Lockers.getApeLockState(collection, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nlibrary Utils {\\n    /// @notice Executes a transaction to the given address.\\n    /// @param to Target address.\\n    /// @param value Native token value to be sent to the address.\\n    /// @param data Data to be sent to the address.\\n    /// @return result Result of the transaciton.\\n    function _execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal returns (bytes memory result) {\\n        assembly {\\n            let success := call(gas(), to, value, add(data, 0x20), mload(data), 0, 0)\\n\\n            mstore(result, returndatasize())\\n            returndatacopy(add(result, 0x20), 0, returndatasize())\\n\\n            if eq(success, 0) {\\n                revert(add(result, 0x20), returndatasize())\\n            }\\n        }\\n    }\\n\\n    /// @notice Recover signer address from signature.\\n    /// @param signedHash Arbitrary length data signed on the behalf of the wallet.\\n    /// @param signature Signature byte array associated with signedHash.\\n    /// @return Recovered signer address.\\n    function recoverSigner(bytes32 signedHash, bytes memory signature) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        // we jump 32 (0x20) as the first slot of bytes contains the length\\n        // we jump 65 (0x41) per signature\\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n        require(v == 27 || v == 28, \\\"Bad v value in signature.\\\");\\n\\n        address recoveredAddress = ecrecover(signedHash, v, r, s);\\n        require(recoveredAddress != address(0), \\\"ecrecover returned 0.\\\");\\n        return recoveredAddress;\\n    }\\n\\n    /// @notice Helper method to parse the function selector from data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @return result Parsed function sighash.\\n    function parseFunctionSelector(bytes memory data) internal pure returns (bytes4 result) {\\n        require(data.length >= 4, \\\"Invalid data.\\\");\\n        assembly {\\n            result := mload(add(data, 0x20))\\n        }\\n    }\\n\\n    /// @notice Parse uint256 from given data.\\n    /// @param data Any data to be parsed, mostly calldata of transaction.\\n    /// @param position Position in the data.\\n    /// @return result Uint256 parsed from given data.\\n    function getUint256At(bytes memory data, uint8 position) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mload(add(data, add(position, 0x20)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/Lockers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n// keccak256(\\\"wallet.YugaModule.lockedApe\\\")\\nbytes32 constant APE_PLAN_LOCKER_SLOT = 0x010881fa8a1edce184936a8e4e08060bba49cb5145c9b396e6e80c0c6b0e1269;\\n\\n// keccak256(\\\"wallet.ERC721Module.lockedERC721\\\")\\nbytes32 constant CYAN_PLAN_LOCKER_SLOT_ERC721 = 0x25888debd3e1e584ccaebe1162c7763ec457a94078c5d0d9a1d32a926ff9973c;\\n\\n// keccak256(\\\"wallet.ERC1155Module.lockedERC1155\\\")\\nbytes32 constant CYAN_PLAN_LOCKER_SLOT_ERC1155 = 0xdcc609ac7fc3b6a216ce1445788736c9dbe88a58b25a13af71623e6da931efa0;\\n\\n// keccak256(\\\"wallet.CryptoPunksModule.lockedCryptoPunks\\\")\\nbytes32 constant CRYPTO_PUNKS_PLAN_LOCKER_SLOT = 0x67ae504a494a1bd5120fdcd8b3565de046d61ac7bb95311090f1976ec179a99a;\\n\\nstruct ApePlanLocker {\\n    /// @notice Map of the locked tokens.\\n    ///     Note: Collection Address => Token ID => Lock state\\n    mapping(address => mapping(uint256 => uint8)) tokens;\\n}\\n\\nstruct CyanPlanLockerERC721 {\\n    /// @notice Locked tokens count of the collection.\\n    ///     Note: Collection Address => Number of locked tokens\\n    mapping(address => uint256) count;\\n    /// @notice Map of the locked tokens.\\n    ///     Note: Collection Address => Token ID => isLocked\\n    mapping(address => mapping(uint256 => bool)) tokens;\\n}\\n\\nstruct CyanPlanLockerCryptoPunks {\\n    /// @notice Locked tokens count of the CryptoPunks.\\n    ///     Note: Number of locked tokens\\n    uint256 count;\\n    /// @notice Map of the locked tokens.\\n    ///     Note: CryptoPunk index => isLocked\\n    mapping(uint256 => bool) tokens;\\n}\\n\\nstruct CyanPlanLockerERC1155 {\\n    /// @notice Map of the locked ERC1155 tokens.\\n    ///     Note: Collection Address => Token ID => amount\\n    mapping(address => mapping(uint256 => uint256)) tokens;\\n}\\n\\n/// @notice Checks whether the NFT is locked or not. This method checks both ERC721 lock and ApePlan lock.\\n/// @param collection Collection address.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is locked or not.\\nfunction isLockedERC721(address collection, uint256 tokenId) view returns (bool) {\\n    return isLockedByCyanPlanERC721(collection, tokenId) || isLockedByApePlan(collection, tokenId);\\n}\\n\\n/// @notice Checks whether the ERC721 token is locked or not.\\n/// @param collection Collection address.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is locked or not.\\nfunction isLockedByCyanPlanERC721(address collection, uint256 tokenId) view returns (bool) {\\n    return getCyanPlanLockerERC721().tokens[collection][tokenId];\\n}\\n\\n/// @notice Checks whether the CryptoPunks token is locked or not.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is locked or not.\\nfunction isLockedByCryptoPunkPlan(uint256 tokenId) view returns (bool) {\\n    return getCyanPlanLockerCryptoPunks().tokens[tokenId];\\n}\\n\\n/// @notice Checks whether the BAYC, MAYC or BAKC token is locked or not.\\n/// @param collection Ape collection address.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is ape locked or not.\\nfunction isLockedByApePlan(address collection, uint256 tokenId) view returns (bool) {\\n    return getApePlanLocker().tokens[collection][tokenId] != 0;\\n}\\n\\n/// @notice Returns amount of locked ERC1155Token items.\\n/// @param collection Collection address.\\n/// @param tokenId Token ID.\\n/// @return isLocked Whether the token is locked or not.\\nfunction getLockedERC1155Amount(address collection, uint256 tokenId) view returns (uint256) {\\n    return getCyanPlanLockerERC1155().tokens[collection][tokenId];\\n}\\n\\n/// @notice Returns ape lock state.\\n/// @param collection Ape collection address.\\n/// @param tokenId Token ID.\\n/// @return Ape locks state.\\nfunction getApeLockState(address collection, uint256 tokenId) view returns (uint8) {\\n    return getApePlanLocker().tokens[collection][tokenId];\\n}\\n\\n/// @dev Returns the map of the locked ERC721 tokens.\\n/// @return result CyanPlanLockerERC721 struct of the locked tokens.\\n///     Note: Collection Address => Token ID => isLocked\\nfunction getCyanPlanLockerERC721() pure returns (CyanPlanLockerERC721 storage result) {\\n    assembly {\\n        result.slot := CYAN_PLAN_LOCKER_SLOT_ERC721\\n    }\\n}\\n\\n/// @dev Returns the map of the locked ERC1155 tokens.\\n/// @return result CyanPlanERC1155Locker struct of the locked tokens.\\n///     Note: Collection Address => Token ID => locked amount\\nfunction getCyanPlanLockerERC1155() pure returns (CyanPlanLockerERC1155 storage result) {\\n    assembly {\\n        result.slot := CYAN_PLAN_LOCKER_SLOT_ERC1155\\n    }\\n}\\n\\n/// @dev Returns the map of the locked Crypto Punks.\\n/// @return result CryptoPunksPlanLocker struct of the locked tokens.\\n///     Note: CryptoPunk index => isLocked\\nfunction getCyanPlanLockerCryptoPunks() pure returns (CyanPlanLockerCryptoPunks storage result) {\\n    assembly {\\n        result.slot := CRYPTO_PUNKS_PLAN_LOCKER_SLOT\\n    }\\n}\\n\\n/// @dev Returns the map of the locked tokens.\\n/// @return result ApePlanLocker struct of the locked tokens.\\n///     Note: Collection Address => Token ID => Lock state\\nfunction getApePlanLocker() pure returns (ApePlanLocker storage result) {\\n    assembly {\\n        result.slot := APE_PLAN_LOCKER_SLOT\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/CoreStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport { RoleManagerStorage } from \\\"./managers/RoleManager.sol\\\";\\nimport { ModuleManagerStorage } from \\\"./managers/ModuleManager.sol\\\";\\n\\n/// @title Cyan Wallet Core Storage - A Cyan wallet's core storage.\\n/// @dev This contract only needed if the Module wants to access main storage of the wallet.\\n///     Must be the very first parent of the Module contract.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract CoreStorage is RoleManagerStorage, ModuleManagerStorage {\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/core/managers/RoleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Cyan Wallet Role Manager - A Cyan wallet's role manager's storage.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract RoleManagerStorage {\\n    address[3] internal _deprecatedOperators; // Deprecated\\n    address internal _admin;\\n    address internal _owner;\\n    mapping(address => bool) internal _operators;\\n}\\n\\n/// @title Cyan Wallet Role Manager - A Cyan wallet's role manager's functionalities.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract IRoleManager is RoleManagerStorage {\\n    event SetOwner(address owner);\\n    event SetAdmin(address admin);\\n    event SetOperator(address operator, bool isActive);\\n\\n    modifier onlyOperator() {\\n        _checkOnlyOperator();\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        _checkOnlyAdmin();\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        _checkOnlyOwner();\\n        _;\\n    }\\n\\n    constructor(address admin) {\\n        require(admin != address(0x0), \\\"Invalid admin address.\\\");\\n        _admin = admin;\\n    }\\n\\n    /// @notice Returns current owner of the wallet.\\n    /// @return Address of the current owner.\\n    function getOwner() external view virtual returns (address);\\n\\n    /// @notice Changes the current admin.\\n    /// @param admin New admin address.\\n    function setAdmin(address admin) external virtual;\\n\\n    /// @notice Returns current admin of the core contract.\\n    /// @return Address of the current admin.\\n    function getAdmin() external view virtual returns (address);\\n\\n    /// @notice Sets the operator status.\\n    /// @param operator Operator address.\\n    /// @param isActive Is active or not.\\n    function setOperator(address operator, bool isActive) external virtual;\\n\\n    /// @notice Checks whether the given address is an operator.\\n    /// @param operator Address that will be checked.\\n    /// @return result Boolean result.\\n    function isOperator(address operator) external view virtual returns (bool result);\\n\\n    /// @notice Checks whether the message sender is an operator.\\n    function _checkOnlyOperator() internal view virtual;\\n\\n    /// @notice Checks whether the message sender is an admin.\\n    function _checkOnlyAdmin() internal view virtual;\\n\\n    /// @notice Checks whether the message sender is an owner.\\n    function _checkOnlyOwner() internal view virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/core/managers/ModuleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/// @title Cyan Wallet Module Manager Storage - A Cyan wallet's module manager's storage.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract ModuleManagerStorage {\\n    /// @notice Storing allowed contract methods.\\n    ///     Note: Target Contract Address => Sighash of method => Module address\\n    mapping(address => mapping(bytes4 => address)) internal _modules;\\n\\n    /// @notice Storing internally allowed module methods.\\n    ///     Note: Sighash of module method => Module address\\n    mapping(bytes4 => address) internal _internalModules;\\n}\\n\\n/// @title Cyan Wallet Module Manager - A Cyan wallet's module manager's functionalities.\\n/// @author Bulgantamir Gankhuyag - <bulgaa@usecyan.com>\\n/// @author Naranbayar Uuganbayar - <naba@usecyan.com>\\nabstract contract IModuleManager is ModuleManagerStorage {\\n    event SetModule(address target, bytes4 funcHash, address oldModule, address newModule);\\n    event SetInternalModule(bytes4 funcHash, address oldModule, address newModule);\\n\\n    /// @notice Sets the handler module of the target's function.\\n    /// @param target Address of the target contract.\\n    /// @param funcHash Sighash of the target contract's method.\\n    /// @param module Address of the handler module.\\n    function setModule(\\n        address target,\\n        bytes4 funcHash,\\n        address module\\n    ) external virtual;\\n\\n    /// @notice Returns a handling module of the target function.\\n    /// @param target Address of the target contract.\\n    /// @param funcHash Sighash of the target contract's method.\\n    /// @return module Handler module.\\n    function getModule(address target, bytes4 funcHash) external view returns (address) {\\n        return _modules[target][funcHash];\\n    }\\n\\n    /// @notice Sets the internal handler module of the function.\\n    /// @param funcHash Sighash of the module method.\\n    /// @param module Address of the handler module.\\n    function setInternalModule(bytes4 funcHash, address module) external virtual;\\n\\n    /// @notice Returns an internal handling module of the given function.\\n    /// @param funcHash Sighash of the module's method.\\n    /// @return module Handler module.\\n    function getInternalModule(bytes4 funcHash) external view returns (address) {\\n        return _internalModules[funcHash];\\n    }\\n\\n    /// @notice Used to call module functions on the wallet.\\n    ///     Usually used to call locking function of the module on the wallet.\\n    /// @param data Data payload of the transaction.\\n    /// @return Result of the execution.\\n    function executeModule(bytes memory data) external virtual returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EthTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApeLockState\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLockedERC1155Amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isLockedByApePlan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isLockedByCyanPlanERC721\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isLockedERC721\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"data\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FallbackHandler", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}