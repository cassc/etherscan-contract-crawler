{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/crowdfund/InitialETHCrowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { ETHCrowdfundBase } from \\\"./ETHCrowdfundBase.sol\\\";\\nimport { ProposalStorage } from \\\"../proposals/ProposalStorage.sol\\\";\\nimport { LibAddress } from \\\"../utils/LibAddress.sol\\\";\\nimport { LibRawResult } from \\\"../utils/LibRawResult.sol\\\";\\nimport { LibSafeCast } from \\\"../utils/LibSafeCast.sol\\\";\\nimport { Party, PartyGovernance } from \\\"../party/Party.sol\\\";\\nimport { Crowdfund } from \\\"../crowdfund/Crowdfund.sol\\\";\\nimport { MetadataProvider } from \\\"../renderers/MetadataProvider.sol\\\";\\nimport { IGateKeeper } from \\\"../gatekeepers/IGateKeeper.sol\\\";\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { IERC721 } from \\\"../tokens/IERC721.sol\\\";\\n\\n/// @notice A crowdfund for raising the initial funds for new parties.\\n///         Unlike other crowdfunds that are started for the purpose of\\n///         acquiring NFT(s), this crowdfund simply bootstraps a party with\\n///         funds and lets its members coordinate on what to do with it after.\\ncontract InitialETHCrowdfund is ETHCrowdfundBase {\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    // Options to be passed into `initialize()` when the crowdfund is created.\\n    struct InitialETHCrowdfundOptions {\\n        address payable initialContributor;\\n        address initialDelegate;\\n        uint96 minContribution;\\n        uint96 maxContribution;\\n        bool disableContributingForExistingCard;\\n        uint96 minTotalContributions;\\n        uint96 maxTotalContributions;\\n        uint160 exchangeRate;\\n        uint16 fundingSplitBps;\\n        address payable fundingSplitRecipient;\\n        uint40 duration;\\n        IGateKeeper gateKeeper;\\n        bytes12 gateKeeperId;\\n    }\\n\\n    struct ETHPartyOptions {\\n        // Name of the party.\\n        string name;\\n        // Symbol of the party.\\n        string symbol;\\n        // The ID of the customization preset to use for the party card.\\n        uint256 customizationPresetId;\\n        // Options to initialize party governance with.\\n        Crowdfund.FixedGovernanceOpts governanceOpts;\\n        // Options to initialize party proposal engine with.\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n        // The tokens that are considered precious by the party.These are\\n        // protected assets and are subject to extra restrictions in proposals\\n        // vs other assets.\\n        IERC721[] preciousTokens;\\n        // The IDs associated with each token in `preciousTokens`.\\n        uint256[] preciousTokenIds;\\n        // The timestamp until which ragequit is enabled.\\n        uint40 rageQuitTimestamp;\\n        // Initial authorities to set on the party\\n        address[] authorities;\\n    }\\n\\n    struct BatchContributeArgs {\\n        // IDs of cards to credit the contributions to. When set to 0, it means\\n        // a new one should be minted.\\n        uint256[] tokenIds;\\n        // The address to which voting power will be delegated for all\\n        // contributions. This will be ignored if recipient has already set a\\n        // delegate.\\n        address initialDelegate;\\n        // The contribution amounts in wei. The length of this array must be\\n        // equal to the length of `tokenIds`.\\n        uint96[] values;\\n        // The data required to be validated by the `gatekeeper`, if set. If no\\n        // `gatekeeper` is set, this can be empty.\\n        bytes[] gateDatas;\\n    }\\n\\n    struct BatchContributeForArgs {\\n        // IDs of cards to credit the contributions to. When set to 0, it means\\n        // a new one should be minted.\\n        uint256[] tokenIds;\\n        // Addresses of to credit the contributions under. Each contribution\\n        // amount in `values` corresponds to a recipient in this array.\\n        address payable[] recipients;\\n        // The delegate to set for each recipient. This will be ignored if\\n        // recipient has already set a delegate.\\n        address[] initialDelegates;\\n        // The contribution amounts in wei. The length of this array must be\\n        // equal to the length of `recipients`.\\n        uint96[] values;\\n        // The data required to be validated by the `gatekeeper`, if set. If no\\n        // `gatekeeper` is set, this can be empty.\\n        bytes[] gateDatas;\\n    }\\n\\n    event Refunded(address indexed contributor, uint256 indexed tokenId, uint256 amount);\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) ETHCrowdfundBase(globals) {}\\n\\n    /// @notice Initializer to be called prior to using the contract.\\n    /// @param crowdfundOpts Options to initialize the crowdfund with.\\n    /// @param partyOpts Options to initialize the party with.\\n    /// @param customMetadataProvider Optional provider to use for the party for\\n    ///                               rendering custom metadata.\\n    /// @param customMetadata Optional custom metadata to use for the party.\\n    function initialize(\\n        InitialETHCrowdfundOptions memory crowdfundOpts,\\n        ETHPartyOptions memory partyOpts,\\n        MetadataProvider customMetadataProvider,\\n        bytes memory customMetadata\\n    ) external payable onlyInitialize {\\n        // Create party the initial crowdfund will be for.\\n        Party party_ = _createParty(partyOpts, customMetadataProvider, customMetadata);\\n\\n        // Initialize the crowdfund.\\n        _initialize(\\n            ETHCrowdfundOptions({\\n                party: party_,\\n                initialContributor: crowdfundOpts.initialContributor,\\n                initialDelegate: crowdfundOpts.initialDelegate,\\n                minContribution: crowdfundOpts.minContribution,\\n                maxContribution: crowdfundOpts.maxContribution,\\n                disableContributingForExistingCard: crowdfundOpts\\n                    .disableContributingForExistingCard,\\n                minTotalContributions: crowdfundOpts.minTotalContributions,\\n                maxTotalContributions: crowdfundOpts.maxTotalContributions,\\n                exchangeRate: crowdfundOpts.exchangeRate,\\n                fundingSplitBps: crowdfundOpts.fundingSplitBps,\\n                fundingSplitRecipient: crowdfundOpts.fundingSplitRecipient,\\n                duration: crowdfundOpts.duration,\\n                gateKeeper: crowdfundOpts.gateKeeper,\\n                gateKeeperId: crowdfundOpts.gateKeeperId\\n            })\\n        );\\n\\n        // If the creator passed in some ETH during initialization, credit them\\n        // for the initial contribution.\\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\\n        if (initialContribution > 0) {\\n            _contribute(\\n                crowdfundOpts.initialContributor,\\n                crowdfundOpts.initialDelegate,\\n                initialContribution,\\n                0,\\n                \\\"\\\"\\n            );\\n        }\\n\\n        // Set up gatekeeper after initial contribution (initial always gets in).\\n        gateKeeper = crowdfundOpts.gateKeeper;\\n        gateKeeperId = crowdfundOpts.gateKeeperId;\\n    }\\n\\n    /// @notice Contribute ETH to this crowdfund.\\n    /// @param initialDelegate The address to which voting power will be delegated to\\n    ///                        during the governance phase. This will be ignored\\n    ///                        if recipient has already set a delegate.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    /// @return votingPower The voting power the contributor receives for their\\n    ///                     contribution.\\n    function contribute(\\n        address initialDelegate,\\n        bytes memory gateData\\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(\\n                payable(msg.sender),\\n                initialDelegate,\\n                msg.value.safeCastUint256ToUint96(),\\n                0, // Mint a new party card for the contributor.\\n                gateData\\n            );\\n    }\\n\\n    /// @notice Contribute ETH to this crowdfund.\\n    /// @param tokenId The ID of the card the contribution is being made towards.\\n    /// @param initialDelegate The address to which voting power will be delegated to\\n    ///                        during the governance phase. This will be ignored\\n    ///                        if recipient has already set a delegate.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    /// @return votingPower The voting power the contributor receives for their\\n    ///                     contribution.\\n    function contribute(\\n        uint256 tokenId,\\n        address initialDelegate,\\n        bytes memory gateData\\n    ) public payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(\\n                payable(msg.sender),\\n                initialDelegate,\\n                msg.value.safeCastUint256ToUint96(),\\n                tokenId,\\n                gateData\\n            );\\n    }\\n\\n    /// @notice `contribute()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param args The arguments to pass to each `contribute()` call.\\n    /// @return votingPowers The voting power received for each contribution.\\n    function batchContribute(\\n        BatchContributeArgs calldata args\\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\\n        uint256 numContributions = args.tokenIds.length;\\n\\n        if (numContributions != args.values.length || numContributions != args.gateDatas.length) {\\n            revert ArityMismatch();\\n        }\\n\\n        votingPowers = new uint96[](numContributions);\\n        uint256 valuesSum;\\n\\n        for (uint256 i; i < numContributions; ++i) {\\n            votingPowers[i] = _contribute(\\n                payable(msg.sender),\\n                args.initialDelegate,\\n                args.values[i],\\n                args.tokenIds[i],\\n                args.gateDatas[i]\\n            );\\n            valuesSum += args.values[i];\\n        }\\n        if (msg.value != valuesSum) {\\n            revert InvalidMessageValue();\\n        }\\n    }\\n\\n    /// @notice Contribute to this crowdfund on behalf of another address.\\n    /// @param tokenId The ID of the token to credit the contribution to, or\\n    ///                zero to mint a new party card for the recipient\\n    /// @param recipient The address to record the contribution under\\n    /// @param initialDelegate The address to which voting power will be delegated to\\n    ///                        during the governance phase. This will be ignored\\n    ///                        if recipient has already set a delegate.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility\\n    /// @return votingPower The voting power received for the contribution\\n    function contributeFor(\\n        uint256 tokenId,\\n        address payable recipient,\\n        address initialDelegate,\\n        bytes memory gateData\\n    ) external payable onlyDelegateCall returns (uint96 votingPower) {\\n        return\\n            _contribute(\\n                recipient,\\n                initialDelegate,\\n                msg.value.safeCastUint256ToUint96(),\\n                tokenId,\\n                gateData\\n            );\\n    }\\n\\n    /// @notice `contributeFor()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param args The arguments for the batched `contributeFor()` calls.\\n    /// @return votingPowers The voting power received for each contribution.\\n    function batchContributeFor(\\n        BatchContributeForArgs calldata args\\n    ) external payable onlyDelegateCall returns (uint96[] memory votingPowers) {\\n        uint256 numContributions = args.tokenIds.length;\\n\\n        if (\\n            numContributions != args.values.length ||\\n            numContributions != args.gateDatas.length ||\\n            numContributions != args.recipients.length\\n        ) {\\n            revert ArityMismatch();\\n        }\\n\\n        votingPowers = new uint96[](numContributions);\\n        uint256 valuesSum;\\n\\n        for (uint256 i; i < numContributions; ++i) {\\n            votingPowers[i] = _contribute(\\n                args.recipients[i],\\n                args.initialDelegates[i],\\n                args.values[i],\\n                args.tokenIds[i],\\n                args.gateDatas[i]\\n            );\\n            valuesSum += args.values[i];\\n        }\\n        if (msg.value != valuesSum) {\\n            revert InvalidMessageValue();\\n        }\\n    }\\n\\n    function _contribute(\\n        address payable contributor,\\n        address delegate,\\n        uint96 amount,\\n        uint256 tokenId,\\n        bytes memory gateData\\n    ) private returns (uint96 votingPower) {\\n        // Require a non-null delegate.\\n        if (delegate == address(0)) {\\n            revert InvalidDelegateError();\\n        }\\n\\n        // Must not be blocked by gatekeeper.\\n        IGateKeeper _gateKeeper = gateKeeper;\\n        if (_gateKeeper != IGateKeeper(address(0))) {\\n            // Checking msg.sender here instead of contributor is intentional to\\n            // allow someone who's allowed by a gatekeeper to invite others\\n            // into the Party. For example, to allow another contract, and\\n            // only that contract, to process contributions on behalf of\\n            // contributors.\\n            if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\\n                revert NotAllowedByGateKeeperError(msg.sender, _gateKeeper, gateKeeperId, gateData);\\n            }\\n        }\\n\\n        votingPower = _processContribution(contributor, delegate, amount);\\n\\n        // OK to contribute with zero just to update delegate.\\n        if (amount == 0) return 0;\\n\\n        if (tokenId == 0) {\\n            // Mint contributor a new party card.\\n            party.mint(contributor, votingPower, delegate);\\n        } else if (disableContributingForExistingCard) {\\n            revert ContributingForExistingCardDisabledError();\\n        } else if (party.ownerOf(tokenId) == contributor) {\\n            // Increase voting power of contributor's existing party card.\\n            party.increaseVotingPower(tokenId, votingPower);\\n        } else {\\n            revert NotOwnerError(tokenId);\\n        }\\n    }\\n\\n    /// @notice Refund the owner of a party card and burn it. Only available if\\n    ///         the crowdfund lost. Can be called to refund for self or on\\n    ///         another's behalf.\\n    /// @param tokenId The ID of the party card to refund the owner of then burn.\\n    /// @return amount The amount of ETH refunded to the contributor.\\n    function refund(uint256 tokenId) external returns (uint96 amount) {\\n        // Check crowdfund lifecycle.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Lost) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Get amount to refund.\\n        uint96 votingPower = party.votingPowerByTokenId(tokenId).safeCastUint256ToUint96();\\n        amount = convertVotingPowerToContribution(votingPower);\\n\\n        if (amount > 0) {\\n            // Get contributor to refund.\\n            address payable contributor = payable(party.ownerOf(tokenId));\\n\\n            // Burn contributor's party card.\\n            party.burn(tokenId);\\n\\n            // Refund contributor.\\n            contributor.transferEth(amount);\\n\\n            emit Refunded(contributor, tokenId, amount);\\n        }\\n    }\\n\\n    /// @notice `refund()` in batch form.\\n    ///         May not revert if any individual refund fails.\\n    /// @param tokenIds The IDs of the party cards to burn and refund the owners of.\\n    /// @param revertOnFailure If true, revert if any refund fails.\\n    /// @return amounts The amounts of ETH refunded for each refund.\\n    function batchRefund(\\n        uint256[] calldata tokenIds,\\n        bool revertOnFailure\\n    ) external returns (uint96[] memory amounts) {\\n        uint256 numRefunds = tokenIds.length;\\n        amounts = new uint96[](numRefunds);\\n\\n        for (uint256 i; i < numRefunds; ++i) {\\n            (bool s, bytes memory r) = address(this).call(\\n                abi.encodeCall(this.refund, (tokenIds[i]))\\n            );\\n\\n            if (!s) {\\n                if (revertOnFailure) {\\n                    r.rawRevert();\\n                }\\n            } else {\\n                amounts[i] = abi.decode(r, (uint96));\\n            }\\n        }\\n    }\\n\\n    function _createParty(\\n        ETHPartyOptions memory opts,\\n        MetadataProvider customMetadataProvider,\\n        bytes memory customMetadata\\n    ) private returns (Party) {\\n        uint256 authoritiesLength = opts.authorities.length + 1;\\n        address[] memory authorities = new address[](authoritiesLength);\\n        for (uint i = 0; i < authoritiesLength - 1; ++i) {\\n            authorities[i] = opts.authorities[i];\\n        }\\n        authorities[authoritiesLength - 1] = address(this);\\n\\n        if (address(customMetadataProvider) == address(0)) {\\n            return\\n                opts.governanceOpts.partyFactory.createParty(\\n                    opts.governanceOpts.partyImpl,\\n                    authorities,\\n                    Party.PartyOptions({\\n                        name: opts.name,\\n                        symbol: opts.symbol,\\n                        customizationPresetId: opts.customizationPresetId,\\n                        governance: PartyGovernance.GovernanceOpts({\\n                            hosts: opts.governanceOpts.hosts,\\n                            voteDuration: opts.governanceOpts.voteDuration,\\n                            executionDelay: opts.governanceOpts.executionDelay,\\n                            passThresholdBps: opts.governanceOpts.passThresholdBps,\\n                            totalVotingPower: 0,\\n                            feeBps: opts.governanceOpts.feeBps,\\n                            feeRecipient: opts.governanceOpts.feeRecipient\\n                        }),\\n                        proposalEngine: opts.proposalEngineOpts\\n                    }),\\n                    opts.preciousTokens,\\n                    opts.preciousTokenIds,\\n                    opts.rageQuitTimestamp\\n                );\\n        } else {\\n            return\\n                opts.governanceOpts.partyFactory.createPartyWithMetadata(\\n                    opts.governanceOpts.partyImpl,\\n                    authorities,\\n                    Party.PartyOptions({\\n                        name: opts.name,\\n                        symbol: opts.symbol,\\n                        customizationPresetId: opts.customizationPresetId,\\n                        governance: PartyGovernance.GovernanceOpts({\\n                            hosts: opts.governanceOpts.hosts,\\n                            voteDuration: opts.governanceOpts.voteDuration,\\n                            executionDelay: opts.governanceOpts.executionDelay,\\n                            passThresholdBps: opts.governanceOpts.passThresholdBps,\\n                            totalVotingPower: 0,\\n                            feeBps: opts.governanceOpts.feeBps,\\n                            feeRecipient: opts.governanceOpts.feeRecipient\\n                        }),\\n                        proposalEngine: opts.proposalEngineOpts\\n                    }),\\n                    opts.preciousTokens,\\n                    opts.preciousTokenIds,\\n                    opts.rageQuitTimestamp,\\n                    customMetadataProvider,\\n                    customMetadata\\n                );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/ETHCrowdfundBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/utils/FixedPointMathLib.sol\\\";\\n\\nabstract contract ETHCrowdfundBase is Implementation {\\n    using FixedPointMathLib for uint96;\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint96;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    enum CrowdfundLifecycle {\\n        // In practice, this state is never used. If the crowdfund is ever in\\n        // this stage, something is wrong (e.g. crowdfund was never initialized).\\n        Invalid,\\n        // Ready to accept contributions to reach contribution targets\\n        // until a deadline or the minimum contribution target is reached and\\n        // host finalizes.\\n        Active,\\n        // Expired and the minimum contribution target was not reached.\\n        Lost,\\n        // The crowdfund has expired and reached the minimum contribution\\n        // target. It is now ready to finalize.\\n        Won,\\n        // A won crowdfund has been finalized, with funds transferred to the\\n        // party and voting power successfully updated.\\n        Finalized\\n    }\\n\\n    // Options to be passed into `initialize()` when the crowdfund is created.\\n    struct ETHCrowdfundOptions {\\n        Party party;\\n        address payable initialContributor;\\n        address initialDelegate;\\n        uint96 minContribution;\\n        uint96 maxContribution;\\n        bool disableContributingForExistingCard;\\n        uint96 minTotalContributions;\\n        uint96 maxTotalContributions;\\n        uint160 exchangeRate;\\n        uint16 fundingSplitBps;\\n        address payable fundingSplitRecipient;\\n        uint40 duration;\\n        IGateKeeper gateKeeper;\\n        bytes12 gateKeeperId;\\n    }\\n\\n    error WrongLifecycleError(CrowdfundLifecycle lc);\\n    error NotAllowedByGateKeeperError(\\n        address contributor,\\n        IGateKeeper gateKeeper,\\n        bytes12 gateKeeperId,\\n        bytes gateData\\n    );\\n    error OnlyPartyHostError();\\n    error OnlyPartyDaoError(address notDao);\\n    error OnlyPartyDaoOrHostError(address notDao);\\n    error NotOwnerError(uint256 tokenId);\\n    error OnlyWhenEmergencyActionsAllowedError();\\n    error InvalidDelegateError();\\n    error NotEnoughContributionsError(uint96 totalContribution, uint96 minTotalContributions);\\n    error MinGreaterThanMaxError(uint96 min, uint96 max);\\n    error MinMaxDifferenceTooSmall(uint96 min, uint96 max);\\n    error MaxTotalContributionsCannotBeZeroError(uint96 maxTotalContributions);\\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\\n    error ExceedsRemainingContributionsError(uint96 amount, uint96 remaining);\\n    error InvalidExchangeRateError(uint160 exchangeRate);\\n    error InvalidFundingSplitRecipient();\\n    error ContributingForExistingCardDisabledError();\\n    error ZeroVotingPowerError();\\n    error FundingSplitAlreadyPaidError();\\n    error FundingSplitNotConfiguredError();\\n    error InvalidMessageValue();\\n    error ArityMismatch();\\n\\n    event Contributed(\\n        address indexed sender,\\n        address indexed contributor,\\n        uint256 amount,\\n        address delegate\\n    );\\n    event Finalized();\\n    event FundingSplitSent(address indexed fundingSplitRecipient, uint256 amount);\\n    event EmergencyExecuteDisabled();\\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The address of the `Party` contract instance associated\\n    ///         with the crowdfund.\\n    Party public party;\\n    /// @notice The minimum amount of ETH that a contributor can send to\\n    ///         participate in the crowdfund.\\n    uint96 public minContribution;\\n    /// @notice The maximum amount of ETH that a contributor can send to\\n    ///         participate in the crowdfund per address.\\n    uint96 public maxContribution;\\n    /// @notice A boolean flag that determines whether contributors are allowed\\n    ///         to increase the voting power of their existing party cards.\\n    bool public disableContributingForExistingCard;\\n    /// @notice Whether the funding split has been claimed by the funding split\\n    ///         recipient.\\n    bool public fundingSplitPaid;\\n    /// @notice Whether the DAO has emergency powers for this crowdfund.\\n    bool public emergencyExecuteDisabled;\\n    /// @notice The minimum amount of total ETH contributions required for the\\n    ///         crowdfund to be considered successful.\\n    uint96 public minTotalContributions;\\n    /// @notice The maximum amount of total ETH contributions allowed for the\\n    ///         crowdfund.\\n    uint96 public maxTotalContributions;\\n    /// @notice The total amount of ETH contributed to the crowdfund so far.\\n    uint96 public totalContributions;\\n    /// @notice The timestamp at which the crowdfund will end or ended. If 0, the\\n    ///         crowdfund has finalized.\\n    uint40 public expiry;\\n    /// @notice The exchange rate from contribution amount to voting power where\\n    ///         100% = 1e18. May be greater than 1e18 (100%).\\n    uint160 public exchangeRate;\\n    /// @notice The portion of contributions to send to the funding recipient in\\n    ///         basis points (e.g. 100 = 1%).\\n    uint16 public fundingSplitBps;\\n    /// @notice The address to which a portion of the contributions is sent to.\\n    address payable public fundingSplitRecipient;\\n    /// @notice The gatekeeper contract used to restrict who can contribute to the party.\\n    IGateKeeper public gateKeeper;\\n    /// @notice The ID of the gatekeeper to use for restricting contributions to the party.\\n    bytes12 public gateKeeperId;\\n    /// @notice The address a contributor is delegating their voting power to.\\n    mapping(address => address) public delegationsByContributor;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contract\\n    function _initialize(ETHCrowdfundOptions memory opts) internal {\\n        if (opts.minContribution > opts.maxContribution) {\\n            revert MinGreaterThanMaxError(opts.minContribution, opts.maxContribution);\\n        }\\n        if (opts.maxTotalContributions - opts.minTotalContributions + 1 < opts.minContribution) {\\n            revert MinMaxDifferenceTooSmall(opts.minTotalContributions, opts.maxTotalContributions);\\n        }\\n        // Set the minimum and maximum contribution amounts.\\n        minContribution = opts.minContribution;\\n        maxContribution = opts.maxContribution;\\n        // Set the min total contributions.\\n        minTotalContributions = opts.minTotalContributions;\\n        // Set the max total contributions.\\n        if (opts.maxTotalContributions == 0) {\\n            // Prevent this because when `maxTotalContributions` is 0 the\\n            // crowdfund is invalid in `getCrowdfundLifecycle()` meaning it has\\n            // never been initialized.\\n            revert MaxTotalContributionsCannotBeZeroError(opts.maxTotalContributions);\\n        }\\n        maxTotalContributions = opts.maxTotalContributions;\\n        // Set the party crowdfund is for.\\n        party = opts.party;\\n        // Set the crowdfund start and end timestamps.\\n        expiry = (block.timestamp + opts.duration).safeCastUint256ToUint40();\\n        // Set the exchange rate.\\n        if (opts.exchangeRate == 0) revert InvalidExchangeRateError(opts.exchangeRate);\\n        exchangeRate = opts.exchangeRate;\\n        // Set the funding split and its recipient.\\n        fundingSplitBps = opts.fundingSplitBps;\\n        fundingSplitRecipient = opts.fundingSplitRecipient;\\n        if (opts.fundingSplitBps > 0 && opts.fundingSplitRecipient == address(0)) {\\n            revert InvalidFundingSplitRecipient();\\n        }\\n        // Set whether to disable contributing for existing card.\\n        disableContributingForExistingCard = opts.disableContributingForExistingCard;\\n\\n        // Check that the voting power that one receives from a contribution of\\n        // size minContribution is not equal to zero\\n        if (convertContributionToVotingPower(opts.minContribution) == 0) {\\n            revert ZeroVotingPowerError();\\n        }\\n    }\\n\\n    /// @notice Get the current lifecycle of the crowdfund.\\n    function getCrowdfundLifecycle() public view returns (CrowdfundLifecycle lifecycle) {\\n        if (maxTotalContributions == 0) {\\n            return CrowdfundLifecycle.Invalid;\\n        }\\n\\n        uint256 expiry_ = expiry;\\n        if (expiry_ == 0) {\\n            return CrowdfundLifecycle.Finalized;\\n        }\\n\\n        if (block.timestamp >= expiry_) {\\n            if (totalContributions >= minTotalContributions) {\\n                return CrowdfundLifecycle.Won;\\n            } else {\\n                return CrowdfundLifecycle.Lost;\\n            }\\n        }\\n\\n        return CrowdfundLifecycle.Active;\\n    }\\n\\n    function _processContribution(\\n        address payable contributor,\\n        address delegate,\\n        uint96 contribution\\n    ) internal returns (uint96 votingPower) {\\n        address oldDelegate = delegationsByContributor[contributor];\\n        if (msg.sender == contributor || oldDelegate == address(0)) {\\n            // Update delegate.\\n            delegationsByContributor[contributor] = delegate;\\n        } else {\\n            // Prevent changing another's delegate if already delegated.\\n            delegate = oldDelegate;\\n        }\\n\\n        emit Contributed(msg.sender, contributor, contribution, delegate);\\n\\n        // OK to contribute with zero just to update delegate.\\n        if (contribution == 0) return 0;\\n\\n        // Only allow contributions while the crowdfund is active.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc != CrowdfundLifecycle.Active) {\\n            revert WrongLifecycleError(lc);\\n        }\\n\\n        // Check that the contribution amount is at or above the minimum.\\n        uint96 minContribution_ = minContribution;\\n        if (contribution < minContribution_) {\\n            revert BelowMinimumContributionsError(contribution, minContribution_);\\n        }\\n\\n        // Check that the contribution amount is at or below the maximum.\\n        uint96 maxContribution_ = maxContribution;\\n        if (contribution > maxContribution_) {\\n            revert AboveMaximumContributionsError(contribution, maxContribution_);\\n        }\\n\\n        uint96 newTotalContributions = totalContributions + contribution;\\n        uint96 maxTotalContributions_ = maxTotalContributions;\\n        if (newTotalContributions > maxTotalContributions_) {\\n            revert ExceedsRemainingContributionsError(\\n                contribution,\\n                maxTotalContributions_ - totalContributions\\n            );\\n        } else {\\n            totalContributions = newTotalContributions;\\n\\n            if (\\n                maxTotalContributions_ == newTotalContributions ||\\n                minContribution_ > maxTotalContributions_ - newTotalContributions\\n            ) {\\n                _finalize(newTotalContributions);\\n            }\\n        }\\n\\n        // Calculate voting power.\\n        votingPower = convertContributionToVotingPower(contribution);\\n\\n        if (votingPower == 0) revert ZeroVotingPowerError();\\n    }\\n\\n    /// @notice Calculate the voting power amount that would be received from\\n    ///         the given contribution.\\n    /// @param contribution The contribution amount.\\n    /// @return votingPower The voting power amount that would be received from\\n    ///                     the contribution.\\n    function convertContributionToVotingPower(\\n        uint96 contribution\\n    ) public view returns (uint96 votingPower) {\\n        contribution = _removeFundingSplitFromContribution(contribution);\\n        votingPower = _calculateContributionToVotingPower(contribution);\\n    }\\n\\n    /// @notice Calculate the contribution amount from the given voting power.\\n    /// @param votingPower The voting power to convert to a contribution amount.\\n    /// @return contribution The contribution amount.\\n    function convertVotingPowerToContribution(\\n        uint96 votingPower\\n    ) public view returns (uint96 contribution) {\\n        contribution = _calculateVotingPowerToContribution(votingPower);\\n        contribution = _addFundingSplitToContribution(contribution);\\n    }\\n\\n    function _calculateContributionToVotingPower(\\n        uint96 contribution\\n    ) private view returns (uint96) {\\n        return contribution.mulDivDown(exchangeRate, 1e18).safeCastUint256ToUint96();\\n    }\\n\\n    function _calculateVotingPowerToContribution(\\n        uint96 votingPower\\n    ) internal view returns (uint96) {\\n        return votingPower.mulDivUp(1e18, exchangeRate).safeCastUint256ToUint96();\\n    }\\n\\n    function _addFundingSplitToContribution(uint96 contribution) internal view returns (uint96) {\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitBps_ > 0) {\\n            // Downcast is safe since `contribution` cannot exceed\\n            // type(uint96).max. When the contribution is made, it cannot exceed\\n            // type(uint96).max, neither can `totalContributions` exceed it.\\n            contribution = uint96((uint256(contribution) * 1e4) / (1e4 - fundingSplitBps_));\\n        }\\n        return contribution;\\n    }\\n\\n    function _removeFundingSplitFromContribution(\\n        uint96 contribution\\n    ) internal view returns (uint96) {\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitBps_ > 0) {\\n            // Safe since contribution initially fits into uint96 and cannot get bigger\\n            contribution = uint96((uint256(contribution) * (1e4 - fundingSplitBps_)) / 1e4);\\n        }\\n        return contribution;\\n    }\\n\\n    function finalize() external {\\n        uint96 totalContributions_ = totalContributions;\\n\\n        // Check that the crowdfund is not already finalized.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc == CrowdfundLifecycle.Active) {\\n            // Allow host to finalize crowdfund early if it has reached its minimum goal.\\n            if (!party.isHost(msg.sender)) revert OnlyPartyHostError();\\n\\n            // Check that the crowdfund has reached its minimum goal.\\n            uint96 minTotalContributions_ = minTotalContributions;\\n            if (totalContributions_ < minTotalContributions_) {\\n                revert NotEnoughContributionsError(totalContributions_, minTotalContributions_);\\n            }\\n        } else {\\n            // Otherwise only allow finalization if the crowdfund has expired\\n            // and been won. Can be finalized by anyone.\\n            if (lc != CrowdfundLifecycle.Won) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n\\n        // Finalize the crowdfund.\\n        _finalize(totalContributions_);\\n    }\\n\\n    function _finalize(uint96 totalContributions_) internal {\\n        // Finalize the crowdfund.\\n        delete expiry;\\n\\n        // Transfer funding split to recipient if applicable.\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitBps_ > 0) {\\n            // Assuming fundingSplitBps_ <= 1e4, this cannot overflow uint96\\n            totalContributions_ -= uint96((uint256(totalContributions_) * fundingSplitBps_) / 1e4);\\n        }\\n\\n        // Update the party's total voting power.\\n        uint96 newVotingPower = _calculateContributionToVotingPower(totalContributions_);\\n        party.increaseTotalVotingPower(newVotingPower);\\n\\n        // Transfer ETH to the party.\\n        payable(address(party)).transferEth(totalContributions_);\\n\\n        emit Finalized();\\n    }\\n\\n    /// @notice Send the funding split to the recipient if applicable.\\n    function sendFundingSplit() external returns (uint96 splitAmount) {\\n        // Check that the crowdfund is finalized.\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc != CrowdfundLifecycle.Finalized) revert WrongLifecycleError(lc);\\n\\n        if (fundingSplitPaid) revert FundingSplitAlreadyPaidError();\\n\\n        uint16 fundingSplitBps_ = fundingSplitBps;\\n        if (fundingSplitBps_ == 0) {\\n            revert FundingSplitNotConfiguredError();\\n        }\\n\\n        fundingSplitPaid = true;\\n\\n        // Transfer funding split to recipient.\\n        // Assuming fundingSplitBps_ <= 1e4, this cannot overflow uint96\\n        address payable fundingSplitRecipient_ = fundingSplitRecipient;\\n        splitAmount = uint96((uint256(totalContributions) * fundingSplitBps_) / 1e4);\\n        payable(fundingSplitRecipient_).transferEth(splitAmount);\\n\\n        emit FundingSplitSent(fundingSplitRecipient_, splitAmount);\\n    }\\n\\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\\n    /// @dev Emergency actions must not be revoked for this to work.\\n    /// @param targetAddress The contract to call.\\n    /// @param targetCallData The data to pass to the contract.\\n    /// @param amountEth The amount of ETH to send to the contract.\\n    function emergencyExecute(\\n        address targetAddress,\\n        bytes calldata targetCallData,\\n        uint256 amountEth\\n    ) external payable {\\n        // Must be called by the DAO.\\n        if (_GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender) {\\n            revert OnlyPartyDaoError(msg.sender);\\n        }\\n        // Must not be disabled by DAO or host.\\n        if (emergencyExecuteDisabled) {\\n            revert OnlyWhenEmergencyActionsAllowedError();\\n        }\\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\\n        if (!success) {\\n            res.rawRevert();\\n        }\\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\\n    }\\n\\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\\n    /// @dev Either the DAO or the party host can call this.\\n    function disableEmergencyExecute() external {\\n        // Only the DAO or a host can call this.\\n        if (\\n            !party.isHost(msg.sender) &&\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET) != msg.sender\\n        ) {\\n            revert OnlyPartyDaoOrHostError(msg.sender);\\n        }\\n        emergencyExecuteDisabled = true;\\n        emit EmergencyExecuteDisabled();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proposals/ProposalStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./IProposalExecutionEngine.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\n\\n// The storage bucket shared by `PartyGovernance` and the `ProposalExecutionEngine`.\\n// Read this for more context on the pattern motivating this:\\n// https://github.com/dragonfly-xyz/useful-solidity-patterns/tree/main/patterns/explicit-storage-buckets\\nabstract contract ProposalStorage {\\n    using LibRawResult for bytes;\\n\\n    struct SharedProposalStorage {\\n        IProposalExecutionEngine engineImpl;\\n        ProposalEngineOpts opts;\\n        GovernanceValues governanceValues;\\n    }\\n\\n    /// @notice Governance values stored for a party\\n    struct GovernanceValues {\\n        uint40 voteDuration;\\n        uint40 executionDelay;\\n        uint16 passThresholdBps;\\n        uint96 totalVotingPower;\\n    }\\n\\n    struct ProposalEngineOpts {\\n        // Whether the party can add new authorities with the add authority proposal.\\n        bool enableAddAuthorityProposal;\\n        // Whether the party can spend ETH from the party's balance with\\n        // arbitrary call proposals.\\n        bool allowArbCallsToSpendPartyEth;\\n        // Whether operators can be used.\\n        bool allowOperators;\\n        // Whether distributions require a vote or can be executed by any active member.\\n        bool distributionsRequireVote;\\n    }\\n\\n    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;\\n    uint256 private constant SHARED_STORAGE_SLOT =\\n        uint256(keccak256(\\\"ProposalStorage.SharedProposalStorage\\\"));\\n\\n    function _initProposalImpl(IProposalExecutionEngine impl, bytes memory initData) internal {\\n        SharedProposalStorage storage stor = _getSharedProposalStorage();\\n        IProposalExecutionEngine oldImpl = stor.engineImpl;\\n        stor.engineImpl = impl;\\n        (bool s, bytes memory r) = address(impl).delegatecall(\\n            abi.encodeCall(IProposalExecutionEngine.initialize, (address(oldImpl), initData))\\n        );\\n        if (!s) {\\n            r.rawRevert();\\n        }\\n    }\\n\\n    function _getSharedProposalStorage()\\n        internal\\n        pure\\n        returns (SharedProposalStorage storage stor)\\n    {\\n        uint256 s = SHARED_STORAGE_SLOT;\\n        assembly {\\n            stor.slot := s\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibAddress {\\n    error EthTransferFailed(address receiver, bytes errData);\\n\\n    // Transfer ETH with full gas stipend.\\n    function transferEth(address payable receiver, uint256 amount) internal {\\n        if (amount == 0) return;\\n\\n        (bool s, bytes memory r) = receiver.call{ value: amount }(\\\"\\\");\\n        if (!s) {\\n            revert EthTransferFailed(receiver, r);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibRawResult.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibRawResult {\\n    // Revert with the data in `b`.\\n    function rawRevert(bytes memory b) internal pure {\\n        assembly {\\n            revert(add(b, 32), mload(b))\\n        }\\n    }\\n\\n    // Return with the data in `b`.\\n    function rawReturn(bytes memory b) internal pure {\\n        assembly {\\n            return(add(b, 32), mload(b))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibSafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nlibrary LibSafeCast {\\n    error Uint256ToUint96CastOutOfRange(uint256 v);\\n    error Uint256ToInt192CastOutOfRange(uint256 v);\\n    error Int192ToUint96CastOutOfRange(int192 i192);\\n    error Uint256ToInt128CastOutOfRangeError(uint256 u256);\\n    error Uint256ToUint128CastOutOfRangeError(uint256 u256);\\n    error Uint256ToUint40CastOutOfRangeError(uint256 u256);\\n    error Uint96ToUint16CastOutOfRange(uint96 u96);\\n\\n    function safeCastUint256ToUint96(uint256 v) internal pure returns (uint96) {\\n        if (v > uint256(type(uint96).max)) {\\n            revert Uint256ToUint96CastOutOfRange(v);\\n        }\\n        return uint96(v);\\n    }\\n\\n    function safeCastUint256ToUint128(uint256 v) internal pure returns (uint128) {\\n        if (v > uint256(type(uint128).max)) {\\n            revert Uint256ToUint128CastOutOfRangeError(v);\\n        }\\n        return uint128(v);\\n    }\\n\\n    function safeCastUint256ToUint160(uint256 v) internal pure returns (uint160) {\\n        if (v > uint256(type(uint160).max)) {\\n            revert Uint256ToUint128CastOutOfRangeError(v);\\n        }\\n        return uint160(v);\\n    }\\n\\n    function safeCastUint256ToInt192(uint256 v) internal pure returns (int192) {\\n        if (v > uint256(uint192(type(int192).max))) {\\n            revert Uint256ToInt192CastOutOfRange(v);\\n        }\\n        return int192(uint192(v));\\n    }\\n\\n    function safeCastUint96ToUint16(uint96 v) internal pure returns (uint16) {\\n        if (v > uint96(type(uint16).max)) {\\n            revert Uint96ToUint16CastOutOfRange(v);\\n        }\\n        return uint16(v);\\n    }\\n\\n    function safeCastUint96ToInt192(uint96 v) internal pure returns (int192) {\\n        return int192(uint192(v));\\n    }\\n\\n    function safeCastInt192ToUint96(int192 i192) internal pure returns (uint96) {\\n        if (i192 < 0 || i192 > int192(uint192(type(uint96).max))) {\\n            revert Int192ToUint96CastOutOfRange(i192);\\n        }\\n        return uint96(uint192(i192));\\n    }\\n\\n    function safeCastUint256ToInt128(uint256 x) internal pure returns (int128) {\\n        if (x > uint256(uint128(type(int128).max))) {\\n            revert Uint256ToInt128CastOutOfRangeError(x);\\n        }\\n        return int128(uint128(x));\\n    }\\n\\n    function safeCastUint256ToUint40(uint256 x) internal pure returns (uint40) {\\n        if (x > uint256(type(uint40).max)) {\\n            revert Uint256ToUint40CastOutOfRangeError(x);\\n        }\\n        return uint40(x);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/party/Party.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\n\\nimport \\\"./PartyGovernanceNFT.sol\\\";\\nimport \\\"./PartyGovernance.sol\\\";\\n\\n/// @notice The governance contract that also custodies the precious NFTs. This\\n///         is also the Governance NFT 721 contract.\\ncontract Party is PartyGovernanceNFT {\\n    // Arguments used to initialize the party.\\n    struct PartyOptions {\\n        PartyGovernance.GovernanceOpts governance;\\n        ProposalStorage.ProposalEngineOpts proposalEngine;\\n        string name;\\n        string symbol;\\n        uint256 customizationPresetId;\\n    }\\n\\n    // Arguments used to initialize the `PartyGovernanceNFT`.\\n    struct PartyInitData {\\n        PartyOptions options;\\n        IERC721[] preciousTokens;\\n        uint256[] preciousTokenIds;\\n        address[] authorities;\\n        uint40 rageQuitTimestamp;\\n    }\\n\\n    /// @notice Version ID of the party implementation contract.\\n    uint16 public constant VERSION_ID = 2;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) PartyGovernanceNFT(globals) {}\\n\\n    /// @notice Initializer to be called prior to using the contract.\\n    /// @param initData Options used to initialize the party governance.\\n    function initialize(PartyInitData memory initData) external onlyInitialize {\\n        PartyGovernanceNFT._initialize(\\n            initData.options.name,\\n            initData.options.symbol,\\n            initData.options.customizationPresetId,\\n            initData.options.governance,\\n            initData.options.proposalEngine,\\n            initData.preciousTokens,\\n            initData.preciousTokenIds,\\n            initData.authorities,\\n            initData.rageQuitTimestamp\\n        );\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/Crowdfund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"../utils/LibRawResult.sol\\\";\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../tokens/ERC721Receiver.sol\\\";\\nimport \\\"../party/Party.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../gatekeepers/IGateKeeper.sol\\\";\\nimport \\\"../party/IPartyFactory.sol\\\";\\nimport \\\"../renderers/RendererStorage.sol\\\";\\n\\nimport \\\"./CrowdfundNFT.sol\\\";\\n\\n// Base contract for AuctionCrowdfund/BuyCrowdfund.\\n// Holds post-win/loss logic. E.g., burning contribution NFTs and creating a\\n// party after winning.\\nabstract contract Crowdfund is Implementation, ERC721Receiver, CrowdfundNFT {\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibAddress for address payable;\\n\\n    enum CrowdfundLifecycle {\\n        Invalid,\\n        Active,\\n        Expired,\\n        Busy, // Temporary. mid-settlement state\\n        Lost,\\n        Won\\n    }\\n\\n    // PartyGovernance options that must be known and fixed at crowdfund creation.\\n    // This is a subset of PartyGovernance.GovernanceOpts.\\n    struct FixedGovernanceOpts {\\n        // The implementation of the party to be created.\\n        Party partyImpl;\\n        // The factory to use to create the party.\\n        IPartyFactory partyFactory;\\n        // Address of initial party hosts.\\n        address[] hosts;\\n        // How long people can vote on a proposal.\\n        uint40 voteDuration;\\n        // How long to wait after a proposal passes before it can be\\n        // executed.\\n        uint40 executionDelay;\\n        // Minimum ratio of accept votes to consider a proposal passed,\\n        // in bps, where 10,000 == 100%.\\n        uint16 passThresholdBps;\\n        // Fee bps for governance distributions.\\n        uint16 feeBps;\\n        // Fee recipeint for governance distributions.\\n        address payable feeRecipient;\\n    }\\n\\n    // Options to be passed into `_initialize()` when the crowdfund is created.\\n    struct CrowdfundOptions {\\n        string name;\\n        string symbol;\\n        uint256 customizationPresetId;\\n        address payable splitRecipient;\\n        uint16 splitBps;\\n        address initialContributor;\\n        address initialDelegate;\\n        uint96 minContribution;\\n        uint96 maxContribution;\\n        IGateKeeper gateKeeper;\\n        bytes12 gateKeeperId;\\n        FixedGovernanceOpts governanceOpts;\\n        ProposalStorage.ProposalEngineOpts proposalEngineOpts;\\n    }\\n\\n    // A record of a single contribution made by a user.\\n    // Stored in `_contributionsByContributor`.\\n    struct Contribution {\\n        // The value of `Crowdfund.totalContributions` when this contribution was made.\\n        uint96 previousTotalContributions;\\n        // How much was this contribution.\\n        uint96 amount;\\n    }\\n\\n    // A record of the refund and governance NFT owed to a contributor if it\\n    // could not be received by them from `burn()`.\\n    struct Claim {\\n        uint256 refund;\\n        uint256 governanceTokenId;\\n    }\\n\\n    error PartyAlreadyExistsError(Party party);\\n    error WrongLifecycleError(CrowdfundLifecycle lc);\\n    error InvalidGovernanceOptionsError();\\n    error InvalidDelegateError();\\n    error InvalidContributorError();\\n    error NoPartyError();\\n    error NotAllowedByGateKeeperError(\\n        address contributor,\\n        IGateKeeper gateKeeper,\\n        bytes12 gateKeeperId,\\n        bytes gateData\\n    );\\n    error SplitRecipientAlreadyBurnedError();\\n    error InvalidBpsError(uint16 bps);\\n    error ExceedsTotalContributionsError(uint96 value, uint96 totalContributions);\\n    error NothingToClaimError();\\n    error OnlyPartyHostError();\\n    error OnlyContributorError();\\n    error MissingHostsError();\\n    error OnlyPartyDaoError(address notDao);\\n    error OnlyPartyDaoOrHostError(address notDao);\\n    error OnlyWhenEmergencyActionsAllowedError();\\n    error BelowMinimumContributionsError(uint96 contributions, uint96 minContributions);\\n    error AboveMaximumContributionsError(uint96 contributions, uint96 maxContributions);\\n    error InvalidMessageValue();\\n    error ArityMismatch();\\n\\n    event Burned(address contributor, uint256 ethUsed, uint256 ethOwed, uint256 votingPower);\\n    event Contributed(\\n        address sender,\\n        address contributor,\\n        uint256 amount,\\n        address delegate,\\n        uint256 previousTotalContributions\\n    );\\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\\n    event EmergencyExecuteDisabled();\\n\\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\\\"DISABLE_RAGEQUIT_PERMANENTLY\\\")))\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The party instance created by `_createParty()`, if any after a\\n    ///         successful crowdfund.\\n    Party public party;\\n    /// @notice The total (recorded) ETH contributed to this crowdfund.\\n    uint96 public totalContributions;\\n    /// @notice The gatekeeper contract to use (if non-null) to restrict who can\\n    ///         contribute to the party.\\n    IGateKeeper public gateKeeper;\\n    /// @notice The ID of the gatekeeper strategy to use.\\n    bytes12 public gateKeeperId;\\n    /// @notice Who will receive a reserved portion of governance power when\\n    ///         the governance party is created.\\n    address payable public splitRecipient;\\n    /// @notice How much governance power to reserve for `splitRecipient`,\\n    ///         in bps, where 10,000 = 100%.\\n    uint16 public splitBps;\\n    // Whether the share for split recipient has been claimed through `burn()`.\\n    bool private _splitRecipientHasBurned;\\n    /// @notice Hash of party options passed into `initialize()`.\\n    ///         Used to check whether the options passed into `_createParty()`\\n    ///         matches.\\n    bytes32 public partyOptsHash;\\n    /// @notice Who a contributor last delegated to.\\n    mapping(address => address) public delegationsByContributor;\\n    // Array of contributions by a contributor.\\n    // One is created for every nonzero contribution made.\\n    // `internal` for testing purposes only.\\n    mapping(address => Contribution[]) internal _contributionsByContributor;\\n    /// @notice Stores the amount of ETH owed back to a contributor and governance NFT\\n    ///         that should be minted to them if it could not be transferred to\\n    ///         them with `burn()`.\\n    mapping(address => Claim) public claims;\\n    /// @notice Minimum amount of ETH that can be contributed to this crowdfund per address.\\n    uint96 public minContribution;\\n    /// @notice Maximum amount of ETH that can be contributed to this crowdfund per address.\\n    uint96 public maxContribution;\\n    /// @notice Whether the DAO has emergency powers for this party.\\n    bool public emergencyExecuteDisabled;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) CrowdfundNFT(globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts, credit initial contribution (if\\n    // any), and setup gatekeeper.\\n    function _initialize(CrowdfundOptions memory opts) internal {\\n        CrowdfundNFT._initialize(opts.name, opts.symbol, opts.customizationPresetId);\\n        // Check that BPS values do not exceed the max.\\n        if (opts.governanceOpts.feeBps > 1e4) {\\n            revert InvalidBpsError(opts.governanceOpts.feeBps);\\n        }\\n        if (opts.governanceOpts.passThresholdBps > 1e4) {\\n            revert InvalidBpsError(opts.governanceOpts.passThresholdBps);\\n        }\\n        if (opts.splitBps > 1e4) {\\n            revert InvalidBpsError(opts.splitBps);\\n        }\\n        partyOptsHash = _hashOpts(opts.governanceOpts, opts.proposalEngineOpts);\\n        splitRecipient = opts.splitRecipient;\\n        splitBps = opts.splitBps;\\n        // Set the minimum and maximum contribution amounts.\\n        minContribution = opts.minContribution;\\n        maxContribution = opts.maxContribution;\\n        // If the creator passed in some ETH during initialization, credit them\\n        // for the initial contribution.\\n        uint96 initialContribution = msg.value.safeCastUint256ToUint96();\\n        if (initialContribution > 0) {\\n            _setDelegate(opts.initialContributor, opts.initialDelegate);\\n            // If this ETH is passed in, credit it to the `initialContributor`.\\n            _contribute(opts.initialContributor, opts.initialDelegate, initialContribution, 0, \\\"\\\");\\n        }\\n        // Set up gatekeeper after initial contribution (initial always gets in).\\n        gateKeeper = opts.gateKeeper;\\n        gateKeeperId = opts.gateKeeperId;\\n    }\\n\\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\\n    /// @dev Emergency actions must not be revoked for this to work.\\n    /// @param targetAddress The contract to call.\\n    /// @param targetCallData The data to pass to the contract.\\n    /// @param amountEth The amount of ETH to send to the contract.\\n    function emergencyExecute(\\n        address targetAddress,\\n        bytes calldata targetCallData,\\n        uint256 amountEth\\n    ) external payable onlyDelegateCall {\\n        // Must be called by the DAO.\\n        if (!_isPartyDao(msg.sender)) {\\n            revert OnlyPartyDaoError(msg.sender);\\n        }\\n        // Must not be disabled by DAO or host.\\n        if (emergencyExecuteDisabled) {\\n            revert OnlyWhenEmergencyActionsAllowedError();\\n        }\\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\\n        if (!success) {\\n            res.rawRevert();\\n        }\\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\\n    }\\n\\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\\n    /// @dev Either the DAO or the party host can call this.\\n    /// @param governanceOpts The fixed governance opts the crowdfund was created with.\\n    /// @param proposalEngineOpts The options used to initialize the proposal\\n    ///                           engine in the `Party` instance.\\n    /// @param hostIndex The index of the party host (caller).\\n    function disableEmergencyExecute(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) external onlyDelegateCall {\\n        // Only the DAO or a host can call this.\\n        if (\\n            !_isHost(msg.sender, governanceOpts, proposalEngineOpts, hostIndex) &&\\n            !_isPartyDao(msg.sender)\\n        ) {\\n            revert OnlyPartyDaoOrHostError(msg.sender);\\n        }\\n        emergencyExecuteDisabled = true;\\n        emit EmergencyExecuteDisabled();\\n    }\\n\\n    /// @notice Burn the participation NFT for `contributor`, potentially\\n    ///         minting voting power and/or refunding unused ETH. `contributor`\\n    ///         may also be the split recipient, regardless of whether they are\\n    ///         also a contributor or not. This can be called by anyone on a\\n    ///         contributor's behalf to unlock their voting power in the\\n    ///         governance stage ensuring delegates receive their voting\\n    ///         power and governance is not stalled.\\n    /// @param contributor The contributor whose NFT to burn for.\\n    function burn(address payable contributor) public {\\n        return _burn(contributor, getCrowdfundLifecycle(), party);\\n    }\\n\\n    /// @dev Alias for `burn()`.\\n    function activateOrRefund(address payable contributor) external {\\n        burn(contributor);\\n    }\\n\\n    /// @notice `burn()` in batch form.\\n    ///         Will not revert if any individual burn fails.\\n    /// @param contributors The contributors whose NFT to burn for.\\n    /// @param revertOnFailure If true, revert if any burn fails.\\n    function batchBurn(address payable[] calldata contributors, bool revertOnFailure) public {\\n        for (uint256 i = 0; i < contributors.length; ++i) {\\n            (bool s, bytes memory r) = address(this).delegatecall(\\n                abi.encodeCall(this.burn, (contributors[i]))\\n            );\\n            if (revertOnFailure && !s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n\\n    /// @dev Alias for `batchBurn()`.\\n    function batchActivateOrRefund(\\n        address payable[] calldata contributors,\\n        bool revertOnFailure\\n    ) external {\\n        batchBurn(contributors, revertOnFailure);\\n    }\\n\\n    /// @notice Claim a governance NFT or refund that is owed back but could not be\\n    ///         given due to error in `_burn()` (e.g. a contract that does not\\n    ///         implement `onERC721Received()` or cannot receive ETH). Only call\\n    ///         this if refund and governance NFT minting could not be returned\\n    ///         with `burn()`.\\n    /// @param receiver The address to receive the NFT or refund.\\n    function claim(address payable receiver) external {\\n        Claim memory claimInfo = claims[msg.sender];\\n        delete claims[msg.sender];\\n\\n        if (claimInfo.refund == 0 && claimInfo.governanceTokenId == 0) {\\n            revert NothingToClaimError();\\n        }\\n\\n        if (claimInfo.refund != 0) {\\n            receiver.transferEth(claimInfo.refund);\\n        }\\n\\n        if (claimInfo.governanceTokenId != 0) {\\n            party.safeTransferFrom(address(this), receiver, claimInfo.governanceTokenId);\\n        }\\n    }\\n\\n    /// @notice Contribute to this crowdfund and/or update your delegation for the\\n    ///         governance phase should the crowdfund succeed.\\n    ///         For restricted crowdfunds, `gateData` can be provided to prove\\n    ///         membership to the gatekeeper.\\n    /// @param delegate The address to delegate to for the governance phase.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    function contribute(address delegate, bytes memory gateData) external payable onlyDelegateCall {\\n        _setDelegate(msg.sender, delegate);\\n\\n        _contribute(\\n            msg.sender,\\n            delegate,\\n            msg.value.safeCastUint256ToUint96(),\\n            // We cannot use `address(this).balance - msg.value` as the previous\\n            // total contributions in case someone forces (suicides) ETH into this\\n            // contract. This wouldn't be such a big deal for open crowdfunds\\n            // but private ones (protected by a gatekeeper) could be griefed\\n            // because it would ultimately result in governance power that\\n            // is unattributed/unclaimable, meaning that party will never be\\n            // able to reach 100% consensus.\\n            totalContributions,\\n            gateData\\n        );\\n    }\\n\\n    /// @notice Contribute to this crowdfund on behalf of another address.\\n    /// @param recipient The address to record the contribution under.\\n    /// @param initialDelegate The address to delegate to for the governance phase if recipient hasn't delegated.\\n    /// @param gateData Data to pass to the gatekeeper to prove eligibility.\\n    function contributeFor(\\n        address recipient,\\n        address initialDelegate,\\n        bytes memory gateData\\n    ) external payable onlyDelegateCall {\\n        _setDelegate(recipient, initialDelegate);\\n\\n        _contribute(\\n            recipient,\\n            initialDelegate,\\n            msg.value.safeCastUint256ToUint96(),\\n            totalContributions,\\n            gateData\\n        );\\n    }\\n\\n    /// @notice `contributeFor()` in batch form.\\n    ///         May not revert if any individual contribution fails.\\n    /// @param recipients The addresses to record the contributions under.\\n    /// @param initialDelegates The addresses to delegate to for each recipient.\\n    /// @param values The ETH to contribute for each recipient.\\n    /// @param gateDatas Data to pass to the gatekeeper to prove eligibility.\\n    function batchContributeFor(\\n        address[] memory recipients,\\n        address[] memory initialDelegates,\\n        uint96[] memory values,\\n        bytes[] memory gateDatas\\n    ) external payable {\\n        uint256 numRecipients = recipients.length;\\n\\n        if (\\n            numRecipients != initialDelegates.length ||\\n            numRecipients != values.length ||\\n            numRecipients != gateDatas.length\\n        ) {\\n            revert ArityMismatch();\\n        }\\n\\n        uint256 valuesSum;\\n        for (uint256 i; i < recipients.length; ++i) {\\n            _setDelegate(recipients[i], initialDelegates[i]);\\n\\n            _contribute(\\n                recipients[i],\\n                initialDelegates[i],\\n                values[i],\\n                totalContributions,\\n                gateDatas[i]\\n            );\\n            valuesSum += values[i];\\n        }\\n        if (msg.value != valuesSum) {\\n            revert InvalidMessageValue();\\n        }\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure override(ERC721Receiver, CrowdfundNFT) returns (bool) {\\n        return\\n            ERC721Receiver.supportsInterface(interfaceId) ||\\n            CrowdfundNFT.supportsInterface(interfaceId);\\n    }\\n\\n    /// @notice Retrieve info about a participant's contributions.\\n    /// @dev This will only be called off-chain so doesn't have to be optimal.\\n    /// @param contributor The contributor to retrieve contributions for.\\n    /// @return ethContributed The total ETH contributed by `contributor`.\\n    /// @return ethUsed The total ETH used by `contributor` to acquire the NFT.\\n    /// @return ethOwed The total ETH refunded back to `contributor`.\\n    /// @return votingPower The total voting power minted to `contributor`.\\n    function getContributorInfo(\\n        address contributor\\n    )\\n        external\\n        view\\n        returns (uint256 ethContributed, uint256 ethUsed, uint256 ethOwed, uint256 votingPower)\\n    {\\n        CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n        if (lc == CrowdfundLifecycle.Won || lc == CrowdfundLifecycle.Lost) {\\n            (ethUsed, ethOwed, votingPower) = _getFinalContribution(contributor);\\n            ethContributed = ethUsed + ethOwed;\\n        } else {\\n            Contribution[] memory contributions = _contributionsByContributor[contributor];\\n            uint256 numContributions = contributions.length;\\n            for (uint256 i; i < numContributions; ++i) {\\n                ethContributed += contributions[i].amount;\\n            }\\n        }\\n    }\\n\\n    /// @notice Get the current lifecycle of the crowdfund.\\n    function getCrowdfundLifecycle() public view virtual returns (CrowdfundLifecycle lifecycle);\\n\\n    // Get the final sale price of the bought assets. This will also be the total\\n    // voting power of the governance party.\\n    function _getFinalPrice() internal view virtual returns (uint256);\\n\\n    // Assert that `who` is a host at `governanceOpts.hosts[hostIndex]` and,\\n    // if so, assert that the governance opts is the same as the crowdfund\\n    // was created with.\\n    // Return true if `governanceOpts` was validated in the process.\\n    function _assertIsHost(\\n        address who,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) internal view {\\n        if (!_isHost(who, governanceOpts, proposalEngineOpts, hostIndex)) {\\n            revert OnlyPartyHostError();\\n        }\\n    }\\n\\n    // Check if `who` is a host at `hostIndex` index. Validates governance opts if so.\\n    function _isHost(\\n        address who,\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        uint256 hostIndex\\n    ) private view returns (bool isHost) {\\n        if (hostIndex < governanceOpts.hosts.length && who == governanceOpts.hosts[hostIndex]) {\\n            // Validate governance opts if the host was found.\\n            _assertValidOpts(governanceOpts, proposalEngineOpts);\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _isPartyDao(address who) private view returns (bool isPartyDao) {\\n        return who == _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\\n    }\\n\\n    // Assert that `who` is a contributor to the crowdfund.\\n    function _assertIsContributor(address who) internal view {\\n        if (_contributionsByContributor[who].length == 0) {\\n            revert OnlyContributorError();\\n        }\\n    }\\n\\n    // Can be called after a party has won.\\n    // Deploys and initializes a `Party` instance via the `PartyFactory`\\n    // and transfers the bought NFT to it.\\n    // After calling this, anyone can burn CF tokens on a contributor's behalf\\n    // with the `burn()` function.\\n    function _createParty(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        bool governanceOptsAlreadyValidated,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal returns (Party party_) {\\n        if (party != Party(payable(0))) {\\n            revert PartyAlreadyExistsError(party);\\n        }\\n        // If the governance opts haven't already been validated, make sure that\\n        // it hasn't been tampered with.\\n        if (!governanceOptsAlreadyValidated) {\\n            _assertValidOpts(governanceOpts, proposalEngineOpts);\\n        }\\n        // Get options used to create the party.\\n        RendererStorage rendererStorage = RendererStorage(\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE)\\n        );\\n        address[] memory authorities = new address[](1);\\n        authorities[0] = address(this);\\n        // Create a party.\\n        party = party_ = governanceOpts.partyFactory.createParty(\\n            governanceOpts.partyImpl,\\n            authorities,\\n            Party.PartyOptions({\\n                name: name,\\n                symbol: symbol,\\n                customizationPresetId: rendererStorage.getPresetFor(address(this)),\\n                governance: PartyGovernance.GovernanceOpts({\\n                    hosts: governanceOpts.hosts,\\n                    voteDuration: governanceOpts.voteDuration,\\n                    executionDelay: governanceOpts.executionDelay,\\n                    passThresholdBps: governanceOpts.passThresholdBps,\\n                    totalVotingPower: _getFinalPrice().safeCastUint256ToUint96(),\\n                    feeBps: governanceOpts.feeBps,\\n                    feeRecipient: governanceOpts.feeRecipient\\n                }),\\n                proposalEngine: proposalEngineOpts\\n            }),\\n            preciousTokens,\\n            preciousTokenIds,\\n            // Ragequit is not applicable for NFT parties which primarily own\\n            // non-fungible assets (which cannot be split) and can perform\\n            // distributions without needing a vote.\\n            DISABLE_RAGEQUIT_PERMANENTLY\\n        );\\n        // Transfer the acquired NFTs to the new party.\\n        for (uint256 i; i < preciousTokens.length; ++i) {\\n            preciousTokens[i].transferFrom(address(this), address(party_), preciousTokenIds[i]);\\n        }\\n    }\\n\\n    // Overloaded single token wrapper for _createParty()\\n    function _createParty(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        bool governanceOptsAlreadyValidated,\\n        IERC721 preciousToken,\\n        uint256 preciousTokenId\\n    ) internal returns (Party party_) {\\n        IERC721[] memory tokens = new IERC721[](1);\\n        tokens[0] = preciousToken;\\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = preciousTokenId;\\n        return\\n            _createParty(\\n                governanceOpts,\\n                proposalEngineOpts,\\n                governanceOptsAlreadyValidated,\\n                tokens,\\n                tokenIds\\n            );\\n    }\\n\\n    // Assert that the hash of `opts` matches the hash this crowdfund was initialized with.\\n    function _assertValidOpts(\\n        FixedGovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts\\n    ) private view {\\n        bytes32 partyOptsHash_ = _hashOpts(governanceOpts, proposalEngineOpts);\\n        if (partyOptsHash_ != partyOptsHash) {\\n            revert InvalidGovernanceOptionsError();\\n        }\\n    }\\n\\n    function _hashOpts(\\n        FixedGovernanceOpts memory govOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts\\n    ) internal pure returns (bytes32 h) {\\n        return keccak256(abi.encode(govOpts, proposalEngineOpts));\\n    }\\n\\n    function _getFinalContribution(\\n        address contributor\\n    ) internal view returns (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) {\\n        uint256 totalEthUsed = _getFinalPrice();\\n        {\\n            Contribution[] memory contributions = _contributionsByContributor[contributor];\\n            uint256 numContributions = contributions.length;\\n            for (uint256 i; i < numContributions; ++i) {\\n                Contribution memory c = contributions[i];\\n                if (c.previousTotalContributions >= totalEthUsed) {\\n                    // This entire contribution was not used.\\n                    ethOwed += c.amount;\\n                } else if (c.previousTotalContributions + c.amount <= totalEthUsed) {\\n                    // This entire contribution was used.\\n                    ethUsed += c.amount;\\n                } else {\\n                    // This contribution was partially used.\\n                    uint256 partialEthUsed = totalEthUsed - c.previousTotalContributions;\\n                    ethUsed += partialEthUsed;\\n                    ethOwed = c.amount - partialEthUsed;\\n                }\\n            }\\n        }\\n        // one SLOAD with optimizer on\\n        address splitRecipient_ = splitRecipient;\\n        uint256 splitBps_ = splitBps;\\n        if (splitRecipient_ == address(0)) {\\n            splitBps_ = 0;\\n        }\\n        votingPower = ((1e4 - splitBps_) * ethUsed) / 1e4;\\n        if (splitRecipient_ == contributor) {\\n            // Split recipient is also the contributor so just add the split\\n            // voting power.\\n            votingPower += (splitBps_ * totalEthUsed + (1e4 - 1)) / 1e4; // round up\\n        }\\n    }\\n\\n    function _setDelegate(address contributor, address delegate) private {\\n        if (delegate == address(0)) revert InvalidDelegateError();\\n\\n        // Only need to update delegate if there was a change.\\n        address oldDelegate = delegationsByContributor[contributor];\\n        if (oldDelegate == delegate) return;\\n\\n        // Only allow setting delegate on another's behalf if the delegate is unset.\\n        if (msg.sender != contributor && oldDelegate != address(0)) return;\\n\\n        // Update delegate.\\n        delegationsByContributor[contributor] = delegate;\\n    }\\n\\n    /// @dev While it is not necessary to pass in `delegate` to this because the\\n    ///      function does not require it, it is here to emit in the\\n    ///      `Contribute` event so that the PartyBid frontend can access it more\\n    ///      easily.\\n    function _contribute(\\n        address contributor,\\n        address delegate,\\n        uint96 amount,\\n        uint96 previousTotalContributions,\\n        bytes memory gateData\\n    ) private {\\n        if (contributor == address(this)) revert InvalidContributorError();\\n\\n        if (amount == 0) return;\\n\\n        // Must not be blocked by gatekeeper.\\n        {\\n            IGateKeeper _gateKeeper = gateKeeper;\\n            if (_gateKeeper != IGateKeeper(address(0))) {\\n                // Checking msg.sender here instead of contributor is intentional to\\n                // allow someone who's allowed by a gatekeeper to invite others\\n                // into the Party. For example, to allow another contract, and\\n                // only that contract, to process contributions on behalf of\\n                // contributors.\\n                if (!_gateKeeper.isAllowed(msg.sender, gateKeeperId, gateData)) {\\n                    revert NotAllowedByGateKeeperError(\\n                        msg.sender,\\n                        _gateKeeper,\\n                        gateKeeperId,\\n                        gateData\\n                    );\\n                }\\n            }\\n        }\\n        // Only allow contributions while the crowdfund is active.\\n        {\\n            CrowdfundLifecycle lc = getCrowdfundLifecycle();\\n            if (lc != CrowdfundLifecycle.Active) {\\n                revert WrongLifecycleError(lc);\\n            }\\n        }\\n        // Increase total contributions.\\n        totalContributions += amount;\\n        // Create contributions entry for this contributor.\\n        Contribution[] storage contributions = _contributionsByContributor[contributor];\\n        uint256 numContributions = contributions.length;\\n        uint96 ethContributed;\\n        for (uint256 i; i < numContributions; ++i) {\\n            ethContributed += contributions[i].amount;\\n        }\\n        // Check contribution is greater than minimum contribution.\\n        if (ethContributed + amount < minContribution) {\\n            revert BelowMinimumContributionsError(ethContributed + amount, minContribution);\\n        }\\n        // Check contribution is less than maximum contribution.\\n        if (ethContributed + amount > maxContribution) {\\n            revert AboveMaximumContributionsError(ethContributed + amount, maxContribution);\\n        }\\n\\n        emit Contributed(msg.sender, contributor, amount, delegate, previousTotalContributions);\\n\\n        // Notify third-party platforms that the crowdfund NFT metadata has updated.\\n        emit MetadataUpdate(uint256(uint160(contributor)));\\n\\n        if (numContributions >= 1) {\\n            Contribution memory lastContribution = contributions[numContributions - 1];\\n            // If no one else (other than this contributor) has contributed since,\\n            // we can just reuse this contributor's last entry.\\n            uint256 totalContributionsAmountForReuse = lastContribution.previousTotalContributions +\\n                lastContribution.amount;\\n            if (totalContributionsAmountForReuse == previousTotalContributions) {\\n                lastContribution.amount += amount;\\n                contributions[numContributions - 1] = lastContribution;\\n                return;\\n            }\\n        }\\n        // Add a new contribution entry.\\n        contributions.push(\\n            Contribution({ previousTotalContributions: previousTotalContributions, amount: amount })\\n        );\\n        // Mint a participation NFT if this is their first contribution.\\n        if (numContributions == 0) {\\n            _mint(contributor);\\n        }\\n    }\\n\\n    function _burn(address payable contributor, CrowdfundLifecycle lc, Party party_) private {\\n        // If the CF has won, a party must have been created prior.\\n        if (lc == CrowdfundLifecycle.Won) {\\n            if (party_ == Party(payable(0))) {\\n                revert NoPartyError();\\n            }\\n        } else if (lc != CrowdfundLifecycle.Lost) {\\n            // Otherwise it must have lost.\\n            revert WrongLifecycleError(lc);\\n        }\\n        // Split recipient can burn even if they don't have a token.\\n        {\\n            address splitRecipient_ = splitRecipient;\\n            if (contributor == splitRecipient_) {\\n                if (_splitRecipientHasBurned) {\\n                    revert SplitRecipientAlreadyBurnedError();\\n                }\\n                _splitRecipientHasBurned = true;\\n            }\\n            // Revert if already burned or does not exist.\\n            if (splitRecipient_ != contributor || _doesTokenExistFor(contributor)) {\\n                CrowdfundNFT._burn(contributor);\\n            }\\n        }\\n        // Compute the contributions used and owed to the contributor, along\\n        // with the voting power they'll have in the governance stage.\\n        (uint256 ethUsed, uint256 ethOwed, uint256 votingPower) = _getFinalContribution(\\n            contributor\\n        );\\n        if (votingPower > 0) {\\n            // Get the address to delegate voting power to. If null, delegate to self.\\n            address delegate = delegationsByContributor[contributor];\\n            if (delegate == address(0)) {\\n                // Delegate can be unset for the split recipient if they never\\n                // contribute. Self-delegate if this occurs.\\n                delegate = contributor;\\n            }\\n            // Mint governance NFT for the contributor.\\n            try party_.mint(contributor, votingPower, delegate) returns (uint256) {\\n                // OK\\n            } catch {\\n                // Mint to the crowdfund itself to escrow for contributor to\\n                // come claim later on.\\n                uint256 tokenId = party_.mint(address(this), votingPower, delegate);\\n                claims[contributor].governanceTokenId = tokenId;\\n            }\\n        }\\n        // Refund any ETH owed back to the contributor.\\n        (bool s, ) = contributor.call{ value: ethOwed }(\\\"\\\");\\n        if (!s) {\\n            // If the transfer fails, the contributor can still come claim it\\n            // from the crowdfund.\\n            claims[contributor].refund = ethOwed;\\n        }\\n        emit Burned(contributor, ethUsed, ethOwed, votingPower);\\n    }\\n}\\n\\nfunction _hashFixedGovernanceOpts(\\n    Crowdfund.FixedGovernanceOpts memory opts\\n) pure returns (bytes32 h) {\\n    // Hash in place.\\n    assembly {\\n        // Replace the address[] hosts field with its hash temporarily.\\n        let oldHostsFieldValue := mload(opts)\\n        mstore(opts, keccak256(add(oldHostsFieldValue, 0x20), mul(mload(oldHostsFieldValue), 32)))\\n        // Hash the entire struct.\\n        h := keccak256(opts, 0xC0)\\n        // Restore old hosts field value.\\n        mstore(opts, oldHostsFieldValue)\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/MetadataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { Multicall } from \\\"../utils/Multicall.sol\\\";\\nimport { MetadataRegistry } from \\\"./MetadataRegistry.sol\\\";\\nimport { IMetadataProvider } from \\\"./IMetadataProvider.sol\\\";\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { LibGlobals } from \\\"../globals/LibGlobals.sol\\\";\\n\\n/// @notice A contract that provides custom metadata for Party Cards.\\ncontract MetadataProvider is IMetadataProvider, Multicall {\\n    event MetadataSet(address indexed instance, bytes metadata);\\n\\n    error NotAuthorized(address caller, address instance);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals internal immutable _GLOBALS;\\n\\n    /// @inheritdoc IMetadataProvider\\n    bool public constant supportsRegistrars = true;\\n\\n    // The metadata for each Party instance.\\n    mapping(address instance => bytes metadata) internal _metadata;\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    /// @inheritdoc IMetadataProvider\\n    function getMetadata(\\n        address instance,\\n        uint256\\n    ) external view virtual override returns (bytes memory) {\\n        return _metadata[instance];\\n    }\\n\\n    /// @notice Set the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param metadata The encoded metadata.\\n    function setMetadata(address instance, bytes memory metadata) external virtual {\\n        if (instance != msg.sender) {\\n            MetadataRegistry registry = MetadataRegistry(\\n                _GLOBALS.getAddress(LibGlobals.GLOBAL_METADATA_REGISTRY)\\n            );\\n\\n            // Check if the caller is authorized to set metadata for the instance.\\n            if (!registry.isRegistrar(msg.sender, instance)) {\\n                revert NotAuthorized(msg.sender, instance);\\n            }\\n        }\\n\\n        _metadata[instance] = metadata;\\n\\n        emit MetadataSet(instance, metadata);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gatekeepers/IGateKeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Interface for a gatekeeper contract used for private crowdfund instances.\\ninterface IGateKeeper {\\n    /// @notice Check if a participant is eligible to participate in a crowdfund.\\n    /// @param participant The address of the participant.\\n    /// @param id The ID of the gate to eligibility against.\\n    /// @param userData The data used to check eligibility.\\n    /// @return `true` if the participant is allowed to participate, `false` otherwise.\\n    function isAllowed(\\n        address participant,\\n        bytes12 id,\\n        bytes memory userData\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/globals/IGlobals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/Implementation.sol\\\";\\n\\n// Single registry of global values controlled by multisig.\\n// See `LibGlobals` for all valid keys.\\ninterface IGlobals {\\n    function multiSig() external view returns (address);\\n\\n    function getBytes32(uint256 key) external view returns (bytes32);\\n\\n    function getUint256(uint256 key) external view returns (uint256);\\n\\n    function getBool(uint256 key) external view returns (bool);\\n\\n    function getAddress(uint256 key) external view returns (address);\\n\\n    function getImplementation(uint256 key) external view returns (Implementation);\\n\\n    function getIncludesBytes32(uint256 key, bytes32 value) external view returns (bool);\\n\\n    function getIncludesUint256(uint256 key, uint256 value) external view returns (bool);\\n\\n    function getIncludesAddress(uint256 key, address value) external view returns (bool);\\n\\n    function setBytes32(uint256 key, bytes32 value) external;\\n\\n    function setUint256(uint256 key, uint256 value) external;\\n\\n    function setBool(uint256 key, bool value) external;\\n\\n    function setAddress(uint256 key, address value) external;\\n\\n    function setIncludesBytes32(uint256 key, bytes32 value, bool isIncluded) external;\\n\\n    function setIncludesUint256(uint256 key, uint256 value, bool isIncluded) external;\\n\\n    function setIncludesAddress(uint256 key, address value, bool isIncluded) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\n// Minimal ERC721 interface.\\ninterface IERC721 {\\n    event Transfer(address indexed owner, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed operator, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function approve(address operator, uint256 tokenId) external;\\n\\n    function setApprovalForAll(address operator, bool isApproved) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function getApproved(uint256 tokenId) external view returns (address);\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant MAX_UINT256 = 2 ** 256 - 1;\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide x * y by the denominator.\\n            z := div(mul(x, y), denominator)\\n        }\\n    }\\n\\n    function mulDivUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\\n                revert(0, 0)\\n            }\\n\\n            // If x * y modulo the denominator is strictly greater than 0,\\n            // 1 is added to round up the division of x * y by the denominator.\\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\\n        }\\n    }\\n\\n    function rpow(uint256 x, uint256 n, uint256 scalar) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Mod x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Divide x by y. Note this will return\\n            // 0 instead of reverting if y is zero.\\n            r := div(x, y)\\n        }\\n    }\\n\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Add 1 to x * y if x % y > 0. Note this will\\n            // return 0 instead of reverting if y is zero.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proposals/IProposalExecutionEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\n\\n// Upgradeable proposals logic contract interface.\\ninterface IProposalExecutionEngine {\\n    struct ExecuteProposalParams {\\n        uint256 proposalId;\\n        bytes proposalData;\\n        bytes progressData;\\n        bytes extraData;\\n        uint256 flags;\\n        IERC721[] preciousTokens;\\n        uint256[] preciousTokenIds;\\n    }\\n\\n    function initialize(address oldImpl, bytes memory initData) external;\\n\\n    /// @notice Execute a proposal.\\n    /// @dev Must be delegatecalled into by PartyGovernance.\\n    ///      If the proposal is incomplete, continues its next step (if possible).\\n    ///      If another proposal is incomplete, this will fail. Only one\\n    ///      incomplete proposal is allowed at a time.\\n    /// @param params The data needed to execute the proposal.\\n    /// @return nextProgressData Bytes to be passed into the next `execute()` call,\\n    ///         if the proposal execution is incomplete. Otherwise, empty bytes\\n    ///         to indicate the proposal is complete.\\n    function executeProposal(\\n        ExecuteProposalParams memory params\\n    ) external payable returns (bytes memory nextProgressData);\\n\\n    /// @notice Forcibly cancel an incomplete proposal.\\n    /// @param proposalId The ID of the proposal to cancel.\\n    /// @dev This is intended to be a last resort as it can leave a party in a\\n    ///      broken step. Whenever possible, proposals should be allowed to\\n    ///      complete their entire lifecycle.\\n    function cancelProposal(uint256 proposalId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/party/PartyGovernanceNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibSafeCast.sol\\\";\\nimport \\\"../utils/LibAddress.sol\\\";\\nimport \\\"openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../vendor/solmate/ERC721.sol\\\";\\nimport \\\"./PartyGovernance.sol\\\";\\nimport \\\"../renderers/RendererStorage.sol\\\";\\n\\n/// @notice ERC721 functionality built on top of `PartyGovernance`.\\nabstract contract PartyGovernanceNFT is PartyGovernance, ERC721, IERC2981 {\\n    using LibSafeCast for uint256;\\n    using LibSafeCast for uint96;\\n    using LibERC20Compat for IERC20;\\n    using LibAddress for address payable;\\n\\n    error FixedRageQuitTimestampError(uint40 rageQuitTimestamp);\\n    error CannotRageQuitError(uint40 rageQuitTimestamp);\\n    error CannotDisableRageQuitAfterInitializationError();\\n    error CannotEnableRageQuitIfNotDistributionsRequireVoteError();\\n    error InvalidTokenOrderError();\\n    error BelowMinWithdrawAmountError(uint256 amount, uint256 minAmount);\\n    error NothingToBurnError();\\n\\n    event AuthorityAdded(address indexed authority);\\n    event AuthorityRemoved(address indexed authority);\\n    event RageQuitSet(uint40 oldRageQuitTimestamp, uint40 newRageQuitTimestamp);\\n    event Burn(address caller, uint256 tokenId, uint256 votingPower);\\n    event RageQuit(address caller, uint256[] tokenIds, IERC20[] withdrawTokens, address receiver);\\n    event PartyCardIntrinsicVotingPowerSet(uint256 indexed tokenId, uint256 intrinsicVotingPower);\\n\\n    uint40 private constant ENABLE_RAGEQUIT_PERMANENTLY = 0x6b5b567bfe; // uint40(uint256(keccak256(\\\"ENABLE_RAGEQUIT_PERMANENTLY\\\")))\\n    uint40 private constant DISABLE_RAGEQUIT_PERMANENTLY = 0xab2cb21860; // uint40(uint256(keccak256(\\\"DISABLE_RAGEQUIT_PERMANENTLY\\\")))\\n\\n    // Token address used to indicate ETH.\\n    address private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and its address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The number of tokens that have been minted.\\n    uint96 public tokenCount;\\n    /// @notice The total minted voting power.\\n    ///         Capped to `_governanceValues.totalVotingPower` unless minting\\n    ///         party cards for initial crowdfund.\\n    uint96 public mintedVotingPower;\\n    /// @notice The timestamp until which ragequit is enabled. Can be set to the\\n    ///         `ENABLE_RAGEQUIT_PERMANENTLY`/`DISABLE_RAGEQUIT_PERMANENTLY`\\n    ///         values to enable/disable ragequit permanently.\\n    ///         `DISABLE_RAGEQUIT_PERMANENTLY` can only be set during\\n    ///         initialization.\\n    uint40 public rageQuitTimestamp;\\n    /// @notice The voting power of `tokenId`.\\n    mapping(uint256 => uint256) public votingPowerByTokenId;\\n    /// @notice Address with authority to mint cards and update voting power for the party.\\n    mapping(address => bool) public isAuthority;\\n\\n    function _assertAuthority() internal view {\\n        if (!isAuthority[msg.sender]) {\\n            revert NotAuthorized();\\n        }\\n    }\\n\\n    modifier onlySelf() {\\n        if (msg.sender != address(this)) {\\n            revert NotAuthorized();\\n        }\\n        _;\\n    }\\n\\n    // Set the `Globals` contract. The name or symbol of ERC721 does not matter;\\n    // it will be set in `_initialize()`.\\n    constructor(IGlobals globals) payable PartyGovernance(globals) ERC721(\\\"\\\", \\\"\\\") {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts.\\n    function _initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 customizationPresetId,\\n        PartyGovernance.GovernanceOpts memory governanceOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        address[] memory authorities,\\n        uint40 rageQuitTimestamp_\\n    ) internal {\\n        PartyGovernance._initialize(\\n            governanceOpts,\\n            proposalEngineOpts,\\n            preciousTokens,\\n            preciousTokenIds\\n        );\\n        name = name_;\\n        symbol = symbol_;\\n        if (rageQuitTimestamp_ != 0) {\\n            if (!proposalEngineOpts.distributionsRequireVote) {\\n                revert CannotEnableRageQuitIfNotDistributionsRequireVoteError();\\n            }\\n\\n            rageQuitTimestamp = rageQuitTimestamp_;\\n        }\\n        unchecked {\\n            for (uint256 i; i < authorities.length; ++i) {\\n                isAuthority[authorities[i]] = true;\\n            }\\n        }\\n        if (customizationPresetId != 0) {\\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\\n                .useCustomizationPreset(customizationPresetId);\\n        }\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public pure override(PartyGovernance, ERC721, IERC165) returns (bool) {\\n        return\\n            PartyGovernance.supportsInterface(interfaceId) ||\\n            ERC721.supportsInterface(interfaceId) ||\\n            interfaceId == type(IERC2981).interfaceId;\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function tokenURI(uint256) public view override returns (string memory) {\\n        _delegateToRenderer();\\n        return \\\"\\\"; // Just to make the compiler happy.\\n    }\\n\\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\\n    function contractURI() external view returns (string memory) {\\n        _delegateToRenderer();\\n        return \\\"\\\"; // Just to make the compiler happy.\\n    }\\n\\n    /// @notice Called with the sale price to determine how much royalty\\n    //          is owed and to whom.\\n    function royaltyInfo(uint256, uint256) external view returns (address, uint256) {\\n        _delegateToRenderer();\\n        return (address(0), 0); // Just to make the compiler happy.\\n    }\\n\\n    /// @notice Return the distribution share amount of a token. Included as an alias\\n    ///         for `votePowerByTokenId` for backwards compatibility with old\\n    ///         `TokenDistributor` implementations.\\n    /// @param tokenId The token ID to query.\\n    /// @return share The distribution shares of `tokenId`.\\n    function getDistributionShareOf(uint256 tokenId) external view returns (uint256) {\\n        return votingPowerByTokenId[tokenId];\\n    }\\n\\n    /// @notice Return the voting power share of a token. Denominated\\n    ///         fractions of 1e18. I.e., 1e18 = 100%.\\n    /// @param tokenId The token ID to query.\\n    /// @return share The voting power percentage of `tokenId`.\\n    function getVotingPowerShareOf(uint256 tokenId) public view returns (uint256) {\\n        uint256 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;\\n        return\\n            totalVotingPower == 0 ? 0 : (votingPowerByTokenId[tokenId] * 1e18) / totalVotingPower;\\n    }\\n\\n    /// @notice Mint a governance NFT for `owner` with `votingPower` and\\n    ///         immediately delegate voting power to `delegate.` Only callable\\n    ///         by an authority.\\n    /// @param owner The owner of the NFT.\\n    /// @param votingPower The voting power of the NFT.\\n    /// @param delegate The address to delegate voting power to.\\n    function mint(\\n        address owner,\\n        uint256 votingPower,\\n        address delegate\\n    ) external returns (uint256 tokenId) {\\n        _assertAuthority();\\n        uint96 mintedVotingPower_ = mintedVotingPower;\\n        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;\\n\\n        // Cap voting power to remaining unminted voting power supply.\\n        uint96 votingPower_ = votingPower.safeCastUint256ToUint96();\\n        // Allow minting past total voting power if minting party cards for\\n        // initial crowdfund when there is no total voting power.\\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower_) {\\n            unchecked {\\n                votingPower_ = totalVotingPower - mintedVotingPower_;\\n            }\\n        }\\n\\n        // Update state.\\n        unchecked {\\n            tokenId = ++tokenCount;\\n        }\\n        mintedVotingPower += votingPower_;\\n        votingPowerByTokenId[tokenId] = votingPower_;\\n\\n        emit PartyCardIntrinsicVotingPowerSet(tokenId, votingPower_);\\n\\n        // Use delegate from party over the one set during crowdfund.\\n        address delegate_ = delegationsByVoter[owner];\\n        if (delegate_ != address(0)) {\\n            delegate = delegate_;\\n        }\\n\\n        _adjustVotingPower(owner, votingPower_.safeCastUint96ToInt192(), delegate);\\n        _safeMint(owner, tokenId);\\n    }\\n\\n    /// @notice Add voting power to an existing NFT. Only callable by an\\n    ///         authority.\\n    /// @param tokenId The ID of the NFT to add voting power to.\\n    /// @param votingPower The amount of voting power to add.\\n    function increaseVotingPower(uint256 tokenId, uint96 votingPower) external {\\n        _assertAuthority();\\n        uint96 mintedVotingPower_ = mintedVotingPower;\\n        uint96 totalVotingPower = _getSharedProposalStorage().governanceValues.totalVotingPower;\\n\\n        // Cap voting power to remaining unminted voting power supply. Allow\\n        // minting past total voting power if minting party cards for initial\\n        // crowdfund when there is no total voting power.\\n        if (totalVotingPower != 0 && totalVotingPower - mintedVotingPower_ < votingPower) {\\n            unchecked {\\n                votingPower = totalVotingPower - mintedVotingPower_;\\n            }\\n        }\\n\\n        // Update state.\\n        mintedVotingPower += votingPower;\\n        uint256 newIntrinsicVotingPower = votingPowerByTokenId[tokenId] + votingPower;\\n        votingPowerByTokenId[tokenId] = newIntrinsicVotingPower;\\n\\n        emit PartyCardIntrinsicVotingPowerSet(tokenId, newIntrinsicVotingPower);\\n\\n        _adjustVotingPower(ownerOf(tokenId), votingPower.safeCastUint96ToInt192(), address(0));\\n\\n        // Notify third-party platforms that the party NFT metadata has updated.\\n        emit MetadataUpdate(tokenId);\\n    }\\n\\n    /// @notice Remove voting power from an existing NFT. Only callable by an\\n    ///         authority.\\n    /// @param tokenId The ID of the NFT to remove voting power from.\\n    /// @param votingPower The amount of voting power to remove.\\n    function decreaseVotingPower(uint256 tokenId, uint96 votingPower) external {\\n        _assertAuthority();\\n        mintedVotingPower -= votingPower;\\n        votingPowerByTokenId[tokenId] -= votingPower;\\n\\n        _adjustVotingPower(ownerOf(tokenId), -votingPower.safeCastUint96ToInt192(), address(0));\\n\\n        // Notify third-party platforms that the party NFT metadata has updated.\\n        emit MetadataUpdate(tokenId);\\n    }\\n\\n    /// @notice Increase the total voting power of the party. Only callable by\\n    ///         an authority.\\n    /// @param votingPower The new total voting power to add.\\n    function increaseTotalVotingPower(uint96 votingPower) external {\\n        _assertAuthority();\\n        _getSharedProposalStorage().governanceValues.totalVotingPower += votingPower;\\n        lastTotalVotingPowerChangeTimestamp == uint40(block.timestamp);\\n\\n        // Notify third-party platforms that the party NFT metadata has updated\\n        // for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    /// @notice Decrease the total voting power of the party. Only callable by\\n    ///         an authority.\\n    /// @param votingPower The new total voting power to add.\\n    function decreaseTotalVotingPower(uint96 votingPower) external {\\n        _assertAuthority();\\n        _getSharedProposalStorage().governanceValues.totalVotingPower -= votingPower;\\n        lastTotalVotingPowerChangeTimestamp == uint40(block.timestamp);\\n\\n        // Notify third-party platforms that the party NFT metadata has updated\\n        // for all tokens.\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    /// @notice Burn governance NFTs and remove their voting power.\\n    /// @param tokenIds The IDs of the governance NFTs to burn.\\n    function burn(uint256[] memory tokenIds) public {\\n        _assertAuthority();\\n        _burnAndUpdateVotingPower(tokenIds, false);\\n    }\\n\\n    function _burnAndUpdateVotingPower(\\n        uint256[] memory tokenIds,\\n        bool checkIfAuthorizedToBurn\\n    ) private returns (uint96 totalVotingPowerBurned) {\\n        for (uint256 i; i < tokenIds.length; ++i) {\\n            uint256 tokenId = tokenIds[i];\\n            address owner = ownerOf(tokenId);\\n\\n            // Check if caller is authorized to burn the token.\\n            if (checkIfAuthorizedToBurn) {\\n                if (\\n                    msg.sender != owner &&\\n                    getApproved[tokenId] != msg.sender &&\\n                    !isApprovedForAll[owner][msg.sender]\\n                ) {\\n                    revert NotAuthorized();\\n                }\\n            }\\n\\n            // Must be retrieved before updating voting power for token to be burned.\\n            uint96 votingPower = votingPowerByTokenId[tokenId].safeCastUint256ToUint96();\\n\\n            totalVotingPowerBurned += votingPower;\\n\\n            // Update voting power for token to be burned.\\n            delete votingPowerByTokenId[tokenId];\\n            emit PartyCardIntrinsicVotingPowerSet(tokenId, 0);\\n            _adjustVotingPower(owner, -votingPower.safeCastUint96ToInt192(), address(0));\\n\\n            // Burn token.\\n            _burn(tokenId);\\n\\n            emit Burn(msg.sender, tokenId, votingPower);\\n        }\\n\\n        // Update minted voting power.\\n        mintedVotingPower -= totalVotingPowerBurned;\\n\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    /// @notice Burn governance NFT and remove its voting power.\\n    /// @param tokenId The ID of the governance NFTs to burn.\\n    function burn(uint256 tokenId) external {\\n        uint256[] memory tokenIds = new uint256[](1);\\n        tokenIds[0] = tokenId;\\n        burn(tokenIds);\\n    }\\n\\n    /// @notice Set the timestamp until which ragequit is enabled.\\n    /// @param newRageQuitTimestamp The new ragequit timestamp.\\n    function setRageQuit(uint40 newRageQuitTimestamp) external {\\n        _assertHost();\\n        // Prevent disabling ragequit after initialization.\\n        if (newRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY) {\\n            revert CannotDisableRageQuitAfterInitializationError();\\n        }\\n\\n        // Prevent enabling ragequit if distributions can be created without a vote.\\n        if (!_getSharedProposalStorage().opts.distributionsRequireVote)\\n            revert CannotEnableRageQuitIfNotDistributionsRequireVoteError();\\n\\n        uint40 oldRageQuitTimestamp = rageQuitTimestamp;\\n\\n        // Prevent setting timestamp if it is permanently enabled/disabled.\\n        if (\\n            oldRageQuitTimestamp == ENABLE_RAGEQUIT_PERMANENTLY ||\\n            oldRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY\\n        ) {\\n            revert FixedRageQuitTimestampError(oldRageQuitTimestamp);\\n        }\\n\\n        rageQuitTimestamp = newRageQuitTimestamp;\\n\\n        emit RageQuitSet(oldRageQuitTimestamp, newRageQuitTimestamp);\\n    }\\n\\n    /// @notice Burn a governance NFT and withdraw a fair share of fungible tokens from the party.\\n    /// @param tokenIds The IDs of the governance NFTs to burn.\\n    /// @param withdrawTokens The fungible tokens to withdraw. Specify the\\n    ///                       `ETH_ADDRESS` value to withdraw ETH.\\n    /// @param minWithdrawAmounts The minimum amount of to withdraw for each token.\\n    /// @param receiver The address to receive the withdrawn tokens.\\n    function rageQuit(\\n        uint256[] calldata tokenIds,\\n        IERC20[] calldata withdrawTokens,\\n        uint256[] calldata minWithdrawAmounts,\\n        address receiver\\n    ) external {\\n        if (tokenIds.length == 0) revert NothingToBurnError();\\n\\n        // Check if called by an authority.\\n        bool isAuthority_ = isAuthority[msg.sender];\\n\\n        // Check if ragequit is allowed.\\n        uint40 currentRageQuitTimestamp = rageQuitTimestamp;\\n        if (!isAuthority_) {\\n            if (currentRageQuitTimestamp != ENABLE_RAGEQUIT_PERMANENTLY) {\\n                if (\\n                    currentRageQuitTimestamp == DISABLE_RAGEQUIT_PERMANENTLY ||\\n                    currentRageQuitTimestamp < block.timestamp\\n                ) {\\n                    revert CannotRageQuitError(currentRageQuitTimestamp);\\n                }\\n            }\\n        }\\n\\n        // Used as a reentrancy guard. Will be updated back after ragequit.\\n        rageQuitTimestamp = DISABLE_RAGEQUIT_PERMANENTLY;\\n\\n        lastTotalVotingPowerChangeTimestamp = uint40(block.timestamp);\\n\\n        // Sum up total amount of each token to withdraw.\\n        uint256[] memory withdrawAmounts = new uint256[](withdrawTokens.length);\\n        {\\n            IERC20 prevToken;\\n            for (uint256 i; i < withdrawTokens.length; ++i) {\\n                // Check if order of tokens to transfer is valid.\\n                // Prevent null and duplicate transfers.\\n                if (prevToken >= withdrawTokens[i]) revert InvalidTokenOrderError();\\n\\n                prevToken = withdrawTokens[i];\\n\\n                // Check token's balance.\\n                uint256 balance = address(withdrawTokens[i]) == ETH_ADDRESS\\n                    ? address(this).balance\\n                    : withdrawTokens[i].balanceOf(address(this));\\n\\n                // Add fair share of tokens from the party to total.\\n                for (uint256 j; j < tokenIds.length; ++j) {\\n                    // Must be retrieved before burning the token.\\n                    withdrawAmounts[i] += (balance * getVotingPowerShareOf(tokenIds[j])) / 1e18;\\n                }\\n            }\\n        }\\n        {\\n            // Burn caller's party cards. This will revert if caller is not the\\n            // the owner or approved for any of the card they are attempting to\\n            // burn, not an authority, or if there are duplicate token IDs.\\n            uint96 totalVotingPowerBurned = _burnAndUpdateVotingPower(tokenIds, !isAuthority_);\\n\\n            // Update total voting power of party.\\n            _getSharedProposalStorage().governanceValues.totalVotingPower -= totalVotingPowerBurned;\\n        }\\n        {\\n            uint16 feeBps_ = feeBps;\\n            for (uint256 i; i < withdrawTokens.length; ++i) {\\n                IERC20 token = withdrawTokens[i];\\n                uint256 amount = withdrawAmounts[i];\\n\\n                // Take fee from amount.\\n                uint256 fee = (amount * feeBps_) / 1e4;\\n\\n                if (fee > 0) {\\n                    amount -= fee;\\n\\n                    // Transfer fee to fee recipient.\\n                    if (address(token) == ETH_ADDRESS) {\\n                        payable(feeRecipient).transferEth(fee);\\n                    } else {\\n                        token.compatTransfer(feeRecipient, fee);\\n                    }\\n                }\\n\\n                // Check amount is at least minimum.\\n                uint256 minAmount = minWithdrawAmounts[i];\\n                if (amount < minAmount) {\\n                    revert BelowMinWithdrawAmountError(amount, minAmount);\\n                }\\n\\n                if (amount > 0) {\\n                    // Transfer token from party to recipient.\\n                    if (address(token) == ETH_ADDRESS) {\\n                        payable(receiver).transferEth(amount);\\n                    } else {\\n                        token.compatTransfer(receiver, amount);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Update ragequit timestamp back to before.\\n        rageQuitTimestamp = currentRageQuitTimestamp;\\n\\n        emit RageQuit(msg.sender, tokenIds, withdrawTokens, receiver);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function transferFrom(address owner, address to, uint256 tokenId) public override {\\n        // Transfer voting along with token.\\n        _transferVotingPower(owner, to, votingPowerByTokenId[tokenId]);\\n        super.transferFrom(owner, to, tokenId);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function safeTransferFrom(address owner, address to, uint256 tokenId) public override {\\n        // super.safeTransferFrom() will call transferFrom() first which will\\n        // transfer voting power.\\n        super.safeTransferFrom(owner, to, tokenId);\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function safeTransferFrom(\\n        address owner,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) public override {\\n        // super.safeTransferFrom() will call transferFrom() first which will\\n        // transfer voting power.\\n        super.safeTransferFrom(owner, to, tokenId, data);\\n    }\\n\\n    /// @notice Add a new authority.\\n    /// @dev Used in `AddAuthorityProposal`. Only the party itself can add\\n    ///      authorities to prevent it from being used anywhere else.\\n    function addAuthority(address authority) external onlySelf {\\n        isAuthority[authority] = true;\\n\\n        emit AuthorityAdded(authority);\\n    }\\n\\n    /// @notice Relinquish the authority role.\\n    function abdicateAuthority() external {\\n        _assertAuthority();\\n        delete isAuthority[msg.sender];\\n\\n        emit AuthorityRemoved(msg.sender);\\n    }\\n\\n    function _delegateToRenderer() private view {\\n        _readOnlyDelegateCall(\\n            // Instance of IERC721Renderer.\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_GOVERNANCE_NFT_RENDER_IMPL),\\n            msg.data\\n        );\\n        assert(false); // Will not be reached.\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/party/PartyGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { ITokenDistributor } from \\\"../distribution/ITokenDistributor.sol\\\";\\nimport { ReadOnlyDelegateCall } from \\\"../utils/ReadOnlyDelegateCall.sol\\\";\\nimport { IERC721 } from \\\"../tokens/IERC721.sol\\\";\\nimport { IERC20 } from \\\"../tokens/IERC20.sol\\\";\\nimport { IERC721Receiver } from \\\"../tokens/IERC721Receiver.sol\\\";\\nimport { ERC1155TokenReceiverBase } from \\\"../vendor/solmate/ERC1155.sol\\\";\\nimport { LibERC20Compat } from \\\"../utils/LibERC20Compat.sol\\\";\\nimport { LibRawResult } from \\\"../utils/LibRawResult.sol\\\";\\nimport { LibSafeCast } from \\\"../utils/LibSafeCast.sol\\\";\\nimport { IERC4906 } from \\\"../utils/IERC4906.sol\\\";\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { LibGlobals } from \\\"../globals/LibGlobals.sol\\\";\\nimport { IProposalExecutionEngine } from \\\"../proposals/IProposalExecutionEngine.sol\\\";\\nimport { LibProposal } from \\\"../proposals/LibProposal.sol\\\";\\nimport { ProposalStorage } from \\\"../proposals/ProposalStorage.sol\\\";\\nimport { Implementation } from \\\"../utils/Implementation.sol\\\";\\nimport { Party } from \\\"./Party.sol\\\";\\n\\n/// @notice Base contract for a Party encapsulating all governance functionality.\\n/// @dev This contract uses IERC4906 however does not comply with the standard\\n///      since it does emit metadata events when distributions are claimed or\\n///      when a MetadaProvider changes its URI. This decision was made\\n///      intentionally which is why ERC4906 is not included in `supportsInterface`.\\nabstract contract PartyGovernance is\\n    ProposalStorage,\\n    Implementation,\\n    IERC4906,\\n    ReadOnlyDelegateCall\\n{\\n    using LibERC20Compat for IERC20;\\n    using LibRawResult for bytes;\\n    using LibSafeCast for uint256;\\n    using LibSafeCast for int192;\\n    using LibSafeCast for uint96;\\n\\n    // States a proposal can be in.\\n    enum ProposalStatus {\\n        // The proposal does not exist.\\n        Invalid,\\n        // The proposal has been proposed (via `propose()`), has not been vetoed\\n        // by a party host, and is within the voting window. Members can vote on\\n        // the proposal and party hosts can veto the proposal.\\n        Voting,\\n        // The proposal has either exceeded its voting window without reaching\\n        // `passThresholdBps` of votes or was vetoed by a party host.\\n        Defeated,\\n        // The proposal reached at least `passThresholdBps` of votes but is still\\n        // waiting for `executionDelay` to pass before it can be executed. Members\\n        // can continue to vote on the proposal and party hosts can veto at this time.\\n        Passed,\\n        // Same as `Passed` but now `executionDelay` has been satisfied. Any member\\n        // may execute the proposal via `execute()`, unless `maxExecutableTime`\\n        // has arrived.\\n        Ready,\\n        // The proposal has been executed at least once but has further steps to\\n        // complete so it needs to be executed again. No other proposals may be\\n        // executed while a proposal is in the `InProgress` state. No voting or\\n        // vetoing of the proposal is allowed, however it may be forcibly cancelled\\n        // via `cancel()` if the `cancelDelay` has passed since being first executed.\\n        InProgress,\\n        // The proposal was executed and completed all its steps. No voting or\\n        // vetoing can occur and it cannot be cancelled nor executed again.\\n        Complete,\\n        // The proposal was executed at least once but did not complete before\\n        // `cancelDelay` seconds passed since the first execute and was forcibly cancelled.\\n        Cancelled\\n    }\\n\\n    struct GovernanceOpts {\\n        // Address of initial party hosts.\\n        address[] hosts;\\n        // How long people can vote on a proposal.\\n        uint40 voteDuration;\\n        // How long to wait after a proposal passes before it can be\\n        // executed.\\n        uint40 executionDelay;\\n        // Minimum ratio of accept votes to consider a proposal passed,\\n        // in bps, where 10,000 == 100%.\\n        uint16 passThresholdBps;\\n        // Total voting power of governance NFTs.\\n        uint96 totalVotingPower;\\n        // Fee bps for distributions.\\n        uint16 feeBps;\\n        // Fee recipient for distributions.\\n        address payable feeRecipient;\\n    }\\n\\n    // A snapshot of voting power for a member.\\n    struct VotingPowerSnapshot {\\n        // The timestamp when the snapshot was taken.\\n        uint40 timestamp;\\n        // Voting power that was delegated to this user by others.\\n        uint96 delegatedVotingPower;\\n        // The intrinsic (not delegated from someone else) voting power of this user.\\n        uint96 intrinsicVotingPower;\\n        // Whether the user was delegated to another at this snapshot.\\n        bool isDelegated;\\n    }\\n\\n    // Proposal details chosen by proposer.\\n    struct Proposal {\\n        // Time beyond which the proposal can no longer be executed.\\n        // If the proposal has already been executed, and is still InProgress,\\n        // this value is ignored.\\n        uint40 maxExecutableTime;\\n        // The minimum seconds this proposal can remain in the InProgress status\\n        // before it can be cancelled.\\n        uint40 cancelDelay;\\n        // Encoded proposal data. The first 4 bytes are the proposal type, followed\\n        // by encoded proposal args specific to the proposal type. See\\n        // ProposalExecutionEngine for details.\\n        bytes proposalData;\\n    }\\n\\n    // Accounting and state tracking values for a proposal.\\n    struct ProposalStateValues {\\n        // When the proposal was proposed.\\n        uint40 proposedTime;\\n        // When the proposal passed the vote.\\n        uint40 passedTime;\\n        // When the proposal was first executed.\\n        uint40 executedTime;\\n        // When the proposal completed.\\n        uint40 completedTime;\\n        // Number of accept votes.\\n        uint96 votes; // -1 == vetoed\\n        // Number of total voting power at time proposal created.\\n        uint96 totalVotingPower;\\n        // Number of hosts at time proposal created\\n        uint8 numHosts;\\n        // Number of hosts that accepted proposal\\n        uint8 numHostsAccepted;\\n        // Cached vote duration from proposal creation.\\n        uint40 voteDuration;\\n        // Cached execution delay from proposal creation.\\n        uint40 executionDelay;\\n        // Cached pass threshold bps from proposal creation.\\n        uint16 passThresholdBps;\\n    }\\n\\n    // Storage states for a proposal.\\n    struct ProposalState {\\n        // Accounting and state tracking values.\\n        ProposalStateValues values;\\n        // Hash of the proposal.\\n        bytes32 hash;\\n        // Whether a member has voted for (accepted) this proposal already.\\n        mapping(address => bool) hasVoted;\\n    }\\n\\n    event Proposed(uint256 proposalId, address proposer, Proposal proposal);\\n    event ProposalAccepted(uint256 proposalId, address voter, uint256 weight);\\n    event EmergencyExecute(address target, bytes data, uint256 amountEth);\\n\\n    event ProposalPassed(uint256 indexed proposalId);\\n    event ProposalVetoed(uint256 indexed proposalId, address host);\\n    event ProposalExecuted(uint256 indexed proposalId, address executor, bytes nextProgressData);\\n    event ProposalCancelled(uint256 indexed proposalId);\\n    event DistributionCreated(\\n        ITokenDistributor.TokenType tokenType,\\n        address token,\\n        uint256 tokenId\\n    );\\n    event PartyDelegateUpdated(address indexed owner, address indexed delegate);\\n    event HostStatusTransferred(address oldHost, address newHost);\\n    event EmergencyExecuteDisabled();\\n    event PartyVotingSnapshotCreated(\\n        address indexed voter,\\n        uint40 timestamp,\\n        uint96 delegatedVotingPower,\\n        uint96 intrinsicVotingPower,\\n        bool isDelegated\\n    );\\n\\n    error MismatchedPreciousListLengths();\\n    error BadProposalStatusError(ProposalStatus status);\\n    error BadProposalHashError(bytes32 proposalHash, bytes32 actualHash);\\n    error ExecutionTimeExceededError(uint40 maxExecutableTime, uint40 timestamp);\\n    error NotAuthorized();\\n    error InvalidDelegateError();\\n    error BadPreciousListError();\\n    error OnlyWhenEmergencyActionsAllowedError();\\n    error OnlyWhenEnabledError();\\n    error AlreadyVotedError(address voter);\\n    error InvalidNewHostError();\\n    error ProposalCannotBeCancelledYetError(uint40 currentTime, uint40 cancelTime);\\n    error InvalidBpsError(uint16 bps);\\n    error InvalidGovernanceParameter(uint256 value);\\n    error DistributionsRequireVoteError();\\n    error PartyNotStartedError();\\n    error CannotModifyTotalVotingPowerAndAcceptError();\\n    error TooManyHosts();\\n\\n    uint256 private constant UINT40_HIGH_BIT = 1 << 39;\\n    uint96 private constant VETO_VALUE = type(uint96).max;\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice Whether the DAO has emergency powers for this party.\\n    bool public emergencyExecuteDisabled;\\n    /// @notice Distribution fee bps.\\n    uint16 public feeBps;\\n    /// @notice Distribution fee recipient.\\n    address payable public feeRecipient;\\n    /// @notice The timestamp of the last time total voting power changed in the party.\\n    uint40 public lastTotalVotingPowerChangeTimestamp;\\n    /// @notice The hash of the list of precious NFTs guarded by the party.\\n    bytes32 public preciousListHash;\\n    /// @notice The last proposal ID that was used. 0 means no proposals have been made.\\n    uint256 public lastProposalId;\\n    /// @notice Whether an address is a party host.\\n    mapping(address => bool) public isHost;\\n    /// @notice The last person a voter delegated its voting power to.\\n    mapping(address => address) public delegationsByVoter;\\n    /// @notice Number of hosts for this party\\n    uint8 public numHosts;\\n    /// @notice ProposalState by proposal ID.\\n    mapping(uint256 => ProposalState) private _proposalStateByProposalId;\\n    /// @notice Snapshots of voting power per user, each sorted by increasing time.\\n    mapping(address => VotingPowerSnapshot[]) private _votingPowerSnapshotsByVoter;\\n\\n    function _assertHost() internal view {\\n        if (!isHost[msg.sender]) {\\n            revert NotAuthorized();\\n        }\\n    }\\n\\n    function _assertActiveMember() internal view {\\n        VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\\n        // Must have either delegated voting power or intrinsic voting power.\\n        if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\\n            revert NotAuthorized();\\n        }\\n    }\\n\\n    // Only the party DAO multisig can call.\\n    modifier onlyPartyDao() {\\n        {\\n            address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\\n            if (msg.sender != partyDao) {\\n                revert NotAuthorized();\\n            }\\n        }\\n        _;\\n    }\\n\\n    // Only the party DAO multisig or a party host can call.\\n    modifier onlyPartyDaoOrHost() {\\n        address partyDao = _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET);\\n        if (msg.sender != partyDao && !isHost[msg.sender]) {\\n            revert NotAuthorized();\\n        }\\n        _;\\n    }\\n\\n    // Only if `emergencyExecuteDisabled` is not true.\\n    modifier onlyWhenEmergencyExecuteAllowed() {\\n        if (emergencyExecuteDisabled) {\\n            revert OnlyWhenEmergencyActionsAllowedError();\\n        }\\n        _;\\n    }\\n\\n    function _assertNotGloballyDisabled() internal view {\\n        if (_GLOBALS.getBool(LibGlobals.GLOBAL_DISABLE_PARTY_ACTIONS)) {\\n            revert OnlyWhenEnabledError();\\n        }\\n    }\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize storage for proxy contracts and initialize the proposal execution engine.\\n    function _initialize(\\n        GovernanceOpts memory govOpts,\\n        ProposalStorage.ProposalEngineOpts memory proposalEngineOpts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal virtual {\\n        // Check BPS are valid.\\n        if (govOpts.feeBps > 1e4) {\\n            revert InvalidBpsError(govOpts.feeBps);\\n        }\\n        if (govOpts.voteDuration < 1 hours) {\\n            revert InvalidGovernanceParameter(govOpts.voteDuration);\\n        }\\n        if (govOpts.passThresholdBps == 0 || govOpts.passThresholdBps > 1e4) {\\n            revert InvalidBpsError(govOpts.passThresholdBps);\\n        }\\n        if (govOpts.executionDelay == 0 || govOpts.executionDelay > 30 days) {\\n            revert InvalidGovernanceParameter(govOpts.executionDelay);\\n        }\\n        // Initialize the proposal execution engine.\\n        _initProposalImpl(\\n            IProposalExecutionEngine(_GLOBALS.getAddress(LibGlobals.GLOBAL_PROPOSAL_ENGINE_IMPL)),\\n            abi.encode(proposalEngineOpts)\\n        );\\n        // Set the governance parameters.\\n        _getSharedProposalStorage().governanceValues = GovernanceValues({\\n            voteDuration: govOpts.voteDuration,\\n            executionDelay: govOpts.executionDelay,\\n            passThresholdBps: govOpts.passThresholdBps,\\n            totalVotingPower: govOpts.totalVotingPower\\n        });\\n        numHosts = uint8(govOpts.hosts.length);\\n        // Set fees.\\n        feeBps = govOpts.feeBps;\\n        feeRecipient = govOpts.feeRecipient;\\n        // Set the precious list.\\n        _setPreciousList(preciousTokens, preciousTokenIds);\\n        // Set the party hosts.\\n        if (govOpts.hosts.length > type(uint8).max) {\\n            revert TooManyHosts();\\n        }\\n        for (uint256 i = 0; i < govOpts.hosts.length; ++i) {\\n            isHost[govOpts.hosts[i]] = true;\\n        }\\n    }\\n\\n    /// @dev Forward all unknown read-only calls to the proposal execution engine.\\n    ///      Initial use case is to facilitate eip-1271 signatures.\\n    fallback() external {\\n        bytes4 functionSelector = bytes4(msg.data[0:4]);\\n        if (\\n            functionSelector == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector ||\\n            functionSelector == ERC1155TokenReceiverBase.onERC1155Received.selector ||\\n            functionSelector == IERC721Receiver.onERC721Received.selector\\n        ) {\\n            assembly {\\n                let freeMem := mload(0x40)\\n                mstore(freeMem, functionSelector)\\n                mstore(0x40, add(freeMem, 0x20))\\n                return(freeMem, 0x20)\\n            }\\n        }\\n        _readOnlyDelegateCall(address(_getSharedProposalStorage().engineImpl), msg.data);\\n    }\\n\\n    /// @notice Query if a contract implements an interface.\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @return `true` if the contract implements `interfaceId` and\\n    ///         `interfaceId` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == type(IERC721Receiver).interfaceId ||\\n            interfaceId == type(ERC1155TokenReceiverBase).interfaceId;\\n    }\\n\\n    /// @notice Get the current `ProposalExecutionEngine` instance.\\n    function getProposalExecutionEngine() external view returns (IProposalExecutionEngine) {\\n        return _getSharedProposalStorage().engineImpl;\\n    }\\n\\n    /// @notice Get the current `ProposalEngineOpts` options.\\n    function getProposalEngineOpts() external view returns (ProposalEngineOpts memory) {\\n        return _getSharedProposalStorage().opts;\\n    }\\n\\n    /// @notice Get the total voting power of `voter` at a snapshot `snapIndex`, with checks to\\n    ///         make sure it is the latest voting snapshot =< `timestamp`.\\n    /// @param voter The address of the voter.\\n    /// @param timestamp The timestamp to get the voting power at.\\n    /// @param snapIndex The index of the snapshot to get the voting power at.\\n    /// @return votingPower The total voting power of `voter` at `timestamp`.\\n    function getVotingPowerAt(\\n        address voter,\\n        uint40 timestamp,\\n        uint256 snapIndex\\n    ) public view returns (uint96 votingPower) {\\n        VotingPowerSnapshot memory snap = _getVotingPowerSnapshotAt(voter, timestamp, snapIndex);\\n        return (snap.isDelegated ? 0 : snap.intrinsicVotingPower) + snap.delegatedVotingPower;\\n    }\\n\\n    /// @notice Get the state of a proposal.\\n    /// @param proposalId The ID of the proposal.\\n    /// @return status The status of the proposal.\\n    /// @return values The state of the proposal.\\n    function getProposalStateInfo(\\n        uint256 proposalId\\n    ) external view returns (ProposalStatus status, ProposalStateValues memory values) {\\n        values = _proposalStateByProposalId[proposalId].values;\\n        status = _getProposalStatus(values);\\n    }\\n\\n    /// @notice Retrieve fixed governance parameters.\\n    /// @return gv The governance parameters of this party.\\n    function getGovernanceValues() external view returns (GovernanceValues memory) {\\n        return _getSharedProposalStorage().governanceValues;\\n    }\\n\\n    /// @notice Get the hash of a proposal.\\n    /// @dev Proposal details are not stored on-chain so the hash is used to enforce\\n    ///      consistency between calls.\\n    /// @param proposal The proposal to hash.\\n    /// @return proposalHash The hash of the proposal.\\n    function getProposalHash(Proposal memory proposal) public pure returns (bytes32 proposalHash) {\\n        // Hash the proposal in-place. Equivalent to:\\n        // keccak256(abi.encode(\\n        //   proposal.maxExecutableTime,\\n        //   proposal.cancelDelay,\\n        //   keccak256(proposal.proposalData)\\n        // ))\\n        bytes32 dataHash = keccak256(proposal.proposalData);\\n        assembly {\\n            // Overwrite the data field with the hash of its contents and then\\n            // hash the struct.\\n            let dataPos := add(proposal, 0x40)\\n            let t := mload(dataPos)\\n            mstore(dataPos, dataHash)\\n            proposalHash := keccak256(proposal, 0x60)\\n            // Restore the data field.\\n            mstore(dataPos, t)\\n        }\\n    }\\n\\n    /// @notice Get the index of the most recent voting power snapshot <= `timestamp`.\\n    /// @param voter The address of the voter.\\n    /// @param timestamp The timestamp to get the snapshot index at.\\n    /// @return index The index of the snapshot.\\n    function findVotingPowerSnapshotIndex(\\n        address voter,\\n        uint40 timestamp\\n    ) public view returns (uint256 index) {\\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\\n\\n        // Derived from Open Zeppelin binary search\\n        // ref: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Checkpoints.sol#L39\\n        uint256 high = snaps.length;\\n        uint256 low = 0;\\n        while (low < high) {\\n            uint256 mid = (low + high) / 2;\\n            if (snaps[mid].timestamp > timestamp) {\\n                // Entry is too recent.\\n                high = mid;\\n            } else {\\n                // Entry is older. This is our best guess for now.\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // Return `type(uint256).max` if no valid voting snapshots found.\\n        return high == 0 ? type(uint256).max : high - 1;\\n    }\\n\\n    /// @notice Pledge your intrinsic voting power to a new delegate, removing it from\\n    ///         the old one (if any).\\n    /// @param delegate The address to delegating voting power to.\\n    function delegateVotingPower(address delegate) external {\\n        _adjustVotingPower(msg.sender, 0, delegate);\\n    }\\n\\n    /// @notice Transfer party host status to another.\\n    /// @param newPartyHost The address of the new host.\\n    function abdicateHost(address newPartyHost) external {\\n        _assertHost();\\n        // 0 is a special case burn address.\\n        if (newPartyHost != address(0)) {\\n            // Can only abdicate host\\n            revert InvalidNewHostError();\\n        } else {\\n            // Burned the host status\\n            --numHosts;\\n        }\\n        isHost[msg.sender] = false;\\n        emit HostStatusTransferred(msg.sender, newPartyHost);\\n    }\\n\\n    /// @notice Create a token distribution by moving the party's entire balance\\n    ///         to the `TokenDistributor` contract and immediately creating a\\n    ///         distribution governed by this party.\\n    /// @dev The `feeBps` and `feeRecipient` this party was created with will be\\n    ///      propagated to the distribution. Party members are entitled to a\\n    ///      share of the distribution's tokens proportionate to their relative\\n    ///      voting power in this party (less the fee).\\n    /// @dev Allow this to be called by the party itself for `FractionalizeProposal`.\\n    /// @param tokenType The type of token to distribute.\\n    /// @param token The address of the token to distribute.\\n    /// @param tokenId The ID of the token to distribute. Currently unused but\\n    ///                may be used in the future to support other distribution types.\\n    /// @return distInfo The information about the created distribution.\\n    function distribute(\\n        uint256 amount,\\n        ITokenDistributor.TokenType tokenType,\\n        address token,\\n        uint256 tokenId\\n    ) external returns (ITokenDistributor.DistributionInfo memory distInfo) {\\n        _assertNotGloballyDisabled();\\n        // Ignore if the party is calling functions on itself, like with\\n        // `FractionalizeProposal` and `DistributionProposal`.\\n        if (msg.sender != address(this)) {\\n            // Must not require a vote to create a distribution, otherwise\\n            // distributions can only be created through a distribution\\n            // proposal.\\n            if (_getSharedProposalStorage().opts.distributionsRequireVote) {\\n                revert DistributionsRequireVoteError();\\n            }\\n            // Must be an active member.\\n            VotingPowerSnapshot memory snap = _getLastVotingPowerSnapshotForVoter(msg.sender);\\n            if (snap.intrinsicVotingPower == 0 && snap.delegatedVotingPower == 0) {\\n                revert NotAuthorized();\\n            }\\n        }\\n        // Prevent creating a distribution if the party has not started.\\n        if (_getSharedProposalStorage().governanceValues.totalVotingPower == 0) {\\n            revert PartyNotStartedError();\\n        }\\n        // Get the address of the token distributor.\\n        ITokenDistributor distributor = ITokenDistributor(\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR)\\n        );\\n        emit DistributionCreated(tokenType, token, tokenId);\\n        _emitMetadataUpdateEvent();\\n\\n        // Create a native token distribution.\\n        address payable feeRecipient_ = feeRecipient;\\n        uint16 feeBps_ = feeBps;\\n        if (tokenType == ITokenDistributor.TokenType.Native) {\\n            return\\n                distributor.createNativeDistribution{ value: amount }(\\n                    Party(payable(address(this))),\\n                    feeRecipient_,\\n                    feeBps_\\n                );\\n        }\\n        // Otherwise must be an ERC20 token distribution.\\n        assert(tokenType == ITokenDistributor.TokenType.Erc20);\\n        IERC20(token).compatTransfer(address(distributor), amount);\\n        return\\n            distributor.createErc20Distribution(\\n                IERC20(token),\\n                Party(payable(address(this))),\\n                feeRecipient_,\\n                feeBps_\\n            );\\n    }\\n\\n    /// @notice Make a proposal for members to vote on and cast a vote to accept it\\n    ///         as well.\\n    /// @dev Only an active member (has voting power) can call this.\\n    ///      Afterwards, members can vote to support it with `accept()` or a party\\n    ///      host can unilaterally reject the proposal with `veto()`.\\n    /// @param proposal The details of the proposal.\\n    /// @param latestSnapIndex The index of the caller's most recent voting power\\n    ///                        snapshot before the proposal was created. Should\\n    ///                        be retrieved off-chain and passed in.\\n    function propose(\\n        Proposal memory proposal,\\n        uint256 latestSnapIndex\\n    ) external returns (uint256 proposalId) {\\n        _assertActiveMember();\\n        proposalId = ++lastProposalId;\\n\\n        ProposalStorage.GovernanceValues memory gv = _getSharedProposalStorage().governanceValues;\\n\\n        // Store the time the proposal was created and the proposal hash.\\n        (\\n            _proposalStateByProposalId[proposalId].values,\\n            _proposalStateByProposalId[proposalId].hash\\n        ) = (\\n            ProposalStateValues({\\n                proposedTime: uint40(block.timestamp),\\n                passedTime: 0,\\n                executedTime: 0,\\n                completedTime: 0,\\n                votes: 0,\\n                totalVotingPower: gv.totalVotingPower,\\n                numHosts: numHosts,\\n                numHostsAccepted: 0,\\n                voteDuration: gv.voteDuration,\\n                executionDelay: gv.executionDelay,\\n                passThresholdBps: gv.passThresholdBps\\n            }),\\n            getProposalHash(proposal)\\n        );\\n        emit Proposed(proposalId, msg.sender, proposal);\\n        accept(proposalId, latestSnapIndex);\\n        _emitMetadataUpdateEvent();\\n    }\\n\\n    /// @notice Vote to support a proposed proposal.\\n    /// @dev The voting power cast will be the effective voting power of the caller\\n    ///      just before `propose()` was called (see `getVotingPowerAt()`).\\n    ///      If the proposal reaches `passThresholdBps` acceptance ratio then the\\n    ///      proposal will be in the `Passed` state and will be executable after\\n    ///      the `executionDelay` has passed, putting it in the `Ready` state.\\n    /// @param proposalId The ID of the proposal to accept.\\n    /// @param snapIndex The index of the caller's last voting power snapshot\\n    ///                  before the proposal was created. Should be retrieved\\n    ///                  off-chain and passed in.\\n    /// @return totalVotes The total votes cast on the proposal.\\n    function accept(uint256 proposalId, uint256 snapIndex) public returns (uint256 totalVotes) {\\n        // Get the information about the proposal.\\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\\n        ProposalStateValues memory values = info.values;\\n\\n        // Can only vote in certain proposal statuses.\\n        {\\n            ProposalStatus status = _getProposalStatus(values);\\n            // Allow voting even if the proposal is passed/ready so it can\\n            // potentially reach 100% consensus, which unlocks special\\n            // behaviors for certain proposal types.\\n            if (\\n                status != ProposalStatus.Voting &&\\n                status != ProposalStatus.Passed &&\\n                status != ProposalStatus.Ready\\n            ) {\\n                revert BadProposalStatusError(status);\\n            }\\n        }\\n\\n        // Prevent voting in the same block as the last total voting power\\n        // change. This is to prevent an exploit where a member can, for\\n        // example, rage quit to reduce the total voting power of the party,\\n        // then propose and vote in the same block since `getVotingPowerAt()`\\n        // uses `values.proposedTime - 1`. This would allow them to use the\\n        // voting power snapshot just before their card was burned to vote,\\n        // potentially passing a proposal that would have otherwise not passed.\\n        if (lastTotalVotingPowerChangeTimestamp == block.timestamp) {\\n            revert CannotModifyTotalVotingPowerAndAcceptError();\\n        }\\n\\n        // Cannot vote twice.\\n        if (info.hasVoted[msg.sender]) {\\n            revert AlreadyVotedError(msg.sender);\\n        }\\n        // Mark the caller as having voted.\\n        info.hasVoted[msg.sender] = true;\\n\\n        // Increase the total votes that have been cast on this proposal.\\n        uint96 votingPower = getVotingPowerAt(msg.sender, values.proposedTime - 1, snapIndex);\\n        values.votes += votingPower;\\n        if (isHost[msg.sender]) {\\n            ++values.numHostsAccepted;\\n        }\\n        info.values = values;\\n        emit ProposalAccepted(proposalId, msg.sender, votingPower);\\n\\n        // Update the proposal status if it has reached the pass threshold.\\n        if (\\n            values.passedTime == 0 &&\\n            (uint256(values.votes) * 1e4) / uint256(values.totalVotingPower) >=\\n            uint256(values.passThresholdBps)\\n        ) {\\n            info.values.passedTime = uint40(block.timestamp);\\n            emit ProposalPassed(proposalId);\\n            _emitMetadataUpdateEvent();\\n        }\\n        return values.votes;\\n    }\\n\\n    /// @notice As a party host, veto a proposal, unilaterally rejecting it.\\n    /// @dev The proposal will never be executable and cannot be voted on anymore.\\n    ///      A proposal that has been already executed at least once (in the `InProgress` status)\\n    ///      cannot be vetoed.\\n    /// @param proposalId The ID of the proposal to veto.\\n    function veto(uint256 proposalId) external {\\n        _assertHost();\\n        // Setting `votes` to -1 indicates a veto.\\n        ProposalState storage info = _proposalStateByProposalId[proposalId];\\n        ProposalStateValues memory values = info.values;\\n\\n        {\\n            ProposalStatus status = _getProposalStatus(values);\\n            // Proposal must be in one of the following states.\\n            if (\\n                status != ProposalStatus.Voting &&\\n                status != ProposalStatus.Passed &&\\n                status != ProposalStatus.Ready\\n            ) {\\n                revert BadProposalStatusError(status);\\n            }\\n        }\\n\\n        // -1 indicates veto.\\n        info.values.votes = VETO_VALUE;\\n        emit ProposalVetoed(proposalId, msg.sender);\\n        _emitMetadataUpdateEvent();\\n    }\\n\\n    /// @notice Executes a proposal that has passed governance.\\n    /// @dev The proposal must be in the `Ready` or `InProgress` status.\\n    ///      A `ProposalExecuted` event will be emitted with a non-empty `nextProgressData`\\n    ///      if the proposal has extra steps (must be executed again) to carry out,\\n    ///      in which case `nextProgressData` should be passed into the next `execute()` call.\\n    ///      The `ProposalExecutionEngine` enforces that only one `InProgress` proposal\\n    ///      is active at a time, so that proposal must be completed or cancelled via `cancel()`\\n    ///      in order to execute a different proposal.\\n    ///      `extraData` is optional, off-chain data a proposal might need to execute a step.\\n    /// @param proposalId The ID of the proposal to execute.\\n    /// @param proposal The details of the proposal.\\n    /// @param preciousTokens The tokens that the party considers precious.\\n    /// @param preciousTokenIds The token IDs associated with each precious token.\\n    /// @param progressData The data returned from the last `execute()` call, if any.\\n    /// @param extraData Off-chain data a proposal might need to execute a step.\\n    function execute(\\n        uint256 proposalId,\\n        Proposal memory proposal,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        bytes calldata progressData,\\n        bytes calldata extraData\\n    ) external payable {\\n        _assertNotGloballyDisabled();\\n        _assertActiveMember();\\n        // Get information about the proposal.\\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\\n        // Proposal details must remain the same from `propose()`.\\n        _validateProposalHash(proposal, proposalState.hash);\\n        ProposalStateValues memory values = proposalState.values;\\n        ProposalStatus status = _getProposalStatus(values);\\n        // The proposal must be executable or have already been executed but still\\n        // has more steps to go.\\n        if (status != ProposalStatus.Ready && status != ProposalStatus.InProgress) {\\n            revert BadProposalStatusError(status);\\n        }\\n        if (status == ProposalStatus.Ready) {\\n            // If the proposal has not been executed yet, make sure it hasn't\\n            // expired. Note that proposals that have been executed\\n            // (but still have more steps) ignore `maxExecutableTime`.\\n            if (proposal.maxExecutableTime < block.timestamp) {\\n                revert ExecutionTimeExceededError(\\n                    proposal.maxExecutableTime,\\n                    uint40(block.timestamp)\\n                );\\n            }\\n            proposalState.values.executedTime = uint40(block.timestamp);\\n        }\\n        // Check that the precious list is valid.\\n        if (!_isPreciousListCorrect(preciousTokens, preciousTokenIds)) {\\n            revert BadPreciousListError();\\n        }\\n        // Preemptively set the proposal to completed to avoid it being executed\\n        // again in a deeper call.\\n        proposalState.values.completedTime = uint40(block.timestamp);\\n        // Execute the proposal.\\n        bool completed = _executeProposal(\\n            proposalId,\\n            proposal,\\n            preciousTokens,\\n            preciousTokenIds,\\n            _getProposalFlags(values),\\n            progressData,\\n            extraData\\n        );\\n        if (!completed) {\\n            // Proposal did not complete.\\n            proposalState.values.completedTime = 0;\\n        }\\n    }\\n\\n    /// @notice Cancel a (probably stuck) InProgress proposal.\\n    /// @dev `proposal.cancelDelay` seconds must have passed since it was first\\n    ///      executed for this to be valid. The currently active proposal will\\n    ///      simply be yeeted out of existence so another proposal can execute.\\n    ///      This is intended to be a last resort and can leave the party in a\\n    ///      broken state. Whenever possible, active proposals should be\\n    ///      allowed to complete their lifecycle.\\n    /// @param proposalId The ID of the proposal to cancel.\\n    /// @param proposal The details of the proposal to cancel.\\n    function cancel(uint256 proposalId, Proposal calldata proposal) external {\\n        _assertActiveMember();\\n        // Get information about the proposal.\\n        ProposalState storage proposalState = _proposalStateByProposalId[proposalId];\\n        // Proposal details must remain the same from `propose()`.\\n        _validateProposalHash(proposal, proposalState.hash);\\n        ProposalStateValues memory values = proposalState.values;\\n        {\\n            // Must be `InProgress`.\\n            ProposalStatus status = _getProposalStatus(values);\\n            if (status != ProposalStatus.InProgress) {\\n                revert BadProposalStatusError(status);\\n            }\\n        }\\n        {\\n            // Limit the `cancelDelay` to the global max and min cancel delay\\n            // to mitigate parties accidentally getting stuck forever by setting an\\n            // unrealistic `cancelDelay` or being reckless with too low a\\n            // cancel delay.\\n            uint256 cancelDelay = proposal.cancelDelay;\\n            uint256 globalMaxCancelDelay = _GLOBALS.getUint256(\\n                LibGlobals.GLOBAL_PROPOSAL_MAX_CANCEL_DURATION\\n            );\\n            uint256 globalMinCancelDelay = _GLOBALS.getUint256(\\n                LibGlobals.GLOBAL_PROPOSAL_MIN_CANCEL_DURATION\\n            );\\n            if (globalMaxCancelDelay != 0) {\\n                // Only if we have one set.\\n                if (cancelDelay > globalMaxCancelDelay) {\\n                    cancelDelay = globalMaxCancelDelay;\\n                }\\n            }\\n            if (globalMinCancelDelay != 0) {\\n                // Only if we have one set.\\n                if (cancelDelay < globalMinCancelDelay) {\\n                    cancelDelay = globalMinCancelDelay;\\n                }\\n            }\\n            uint256 cancelTime = values.executedTime + cancelDelay;\\n            // Must not be too early.\\n            if (block.timestamp < cancelTime) {\\n                revert ProposalCannotBeCancelledYetError(\\n                    uint40(block.timestamp),\\n                    uint40(cancelTime)\\n                );\\n            }\\n        }\\n        // Mark the proposal as cancelled by setting the completed time to the current\\n        // time with the high bit set.\\n        proposalState.values.completedTime = uint40(block.timestamp | UINT40_HIGH_BIT);\\n        {\\n            // Delegatecall into the proposal engine impl to perform the cancel.\\n            (bool success, bytes memory resultData) = (\\n                address(_getSharedProposalStorage().engineImpl)\\n            ).delegatecall(abi.encodeCall(IProposalExecutionEngine.cancelProposal, (proposalId)));\\n            if (!success) {\\n                resultData.rawRevert();\\n            }\\n        }\\n        emit ProposalCancelled(proposalId);\\n        _emitMetadataUpdateEvent();\\n    }\\n\\n    /// @notice As the DAO, execute an arbitrary function call from this contract.\\n    /// @dev Emergency actions must not be revoked for this to work.\\n    /// @param targetAddress The contract to call.\\n    /// @param targetCallData The data to pass to the contract.\\n    /// @param amountEth The amount of ETH to send to the contract.\\n    function emergencyExecute(\\n        address targetAddress,\\n        bytes calldata targetCallData,\\n        uint256 amountEth\\n    ) external payable onlyPartyDao onlyWhenEmergencyExecuteAllowed {\\n        (bool success, bytes memory res) = targetAddress.call{ value: amountEth }(targetCallData);\\n        if (!success) {\\n            res.rawRevert();\\n        }\\n        emit EmergencyExecute(targetAddress, targetCallData, amountEth);\\n    }\\n\\n    /// @notice Revoke the DAO's ability to call emergencyExecute().\\n    /// @dev Either the DAO or the party host can call this.\\n    function disableEmergencyExecute() external onlyPartyDaoOrHost {\\n        emergencyExecuteDisabled = true;\\n        emit EmergencyExecuteDisabled();\\n    }\\n\\n    function _executeProposal(\\n        uint256 proposalId,\\n        Proposal memory proposal,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        uint256 flags,\\n        bytes memory progressData,\\n        bytes memory extraData\\n    ) private returns (bool completed) {\\n        // Setup the arguments for the proposal execution engine.\\n        IProposalExecutionEngine.ExecuteProposalParams\\n            memory executeParams = IProposalExecutionEngine.ExecuteProposalParams({\\n                proposalId: proposalId,\\n                proposalData: proposal.proposalData,\\n                progressData: progressData,\\n                extraData: extraData,\\n                preciousTokens: preciousTokens,\\n                preciousTokenIds: preciousTokenIds,\\n                flags: flags\\n            });\\n        // Get the progress data returned after the proposal is executed.\\n        bytes memory nextProgressData;\\n        {\\n            // Execute the proposal.\\n            (bool success, bytes memory resultData) = address(\\n                _getSharedProposalStorage().engineImpl\\n            ).delegatecall(\\n                    abi.encodeCall(IProposalExecutionEngine.executeProposal, (executeParams))\\n                );\\n            if (!success) {\\n                resultData.rawRevert();\\n            }\\n            nextProgressData = abi.decode(resultData, (bytes));\\n        }\\n        emit ProposalExecuted(proposalId, msg.sender, nextProgressData);\\n        _emitMetadataUpdateEvent();\\n        // If the returned progress data is empty, then the proposal completed\\n        // and it should not be executed again.\\n        return nextProgressData.length == 0;\\n    }\\n\\n    // Get the most recent voting power snapshot <= timestamp using `hintindex` as a \\\"hint\\\".\\n    function _getVotingPowerSnapshotAt(\\n        address voter,\\n        uint40 timestamp,\\n        uint256 hintIndex\\n    ) internal view returns (VotingPowerSnapshot memory snap) {\\n        VotingPowerSnapshot[] storage snaps = _votingPowerSnapshotsByVoter[voter];\\n        uint256 snapsLength = snaps.length;\\n        if (snapsLength != 0) {\\n            if (\\n                // Hint is within bounds.\\n                hintIndex < snapsLength &&\\n                // Snapshot is not too recent.\\n                snaps[hintIndex].timestamp <= timestamp &&\\n                // Snapshot is not too old.\\n                (hintIndex == snapsLength - 1 || snaps[hintIndex + 1].timestamp > timestamp)\\n            ) {\\n                return snaps[hintIndex];\\n            }\\n\\n            // Hint was wrong, fallback to binary search to find snapshot.\\n            hintIndex = findVotingPowerSnapshotIndex(voter, timestamp);\\n            // Check that snapshot was found.\\n            if (hintIndex != type(uint256).max) {\\n                return snaps[hintIndex];\\n            }\\n        }\\n\\n        // No snapshot found.\\n        return snap;\\n    }\\n\\n    // Transfers some voting power of `from` to `to`. The total voting power of\\n    // their respective delegates will be updated as well.\\n    function _transferVotingPower(address from, address to, uint256 power) internal {\\n        int192 powerI192 = power.safeCastUint256ToInt192();\\n        _adjustVotingPower(from, -powerI192, address(0));\\n        _adjustVotingPower(to, powerI192, address(0));\\n    }\\n\\n    // Increase `voter`'s intrinsic voting power and update their delegate if delegate is nonzero.\\n    function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {\\n        VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);\\n        address oldDelegate = delegationsByVoter[voter];\\n        // If `oldDelegate` is zero and `voter` never delegated, then have\\n        // `voter` delegate to themself.\\n        oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;\\n        // If the new `delegate` is zero, use the current (old) delegate.\\n        delegate = delegate == address(0) ? oldDelegate : delegate;\\n\\n        VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({\\n            timestamp: uint40(block.timestamp),\\n            delegatedVotingPower: oldSnap.delegatedVotingPower,\\n            intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +\\n                votingPower).safeCastInt192ToUint96(),\\n            isDelegated: delegate != voter\\n        });\\n        _insertVotingPowerSnapshot(voter, newSnap);\\n        delegationsByVoter[voter] = delegate;\\n\\n        // This event is emitted even if the delegate did not change.\\n        emit PartyDelegateUpdated(voter, delegate);\\n\\n        // Handle rebalancing delegates.\\n        _rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);\\n    }\\n\\n    // Update the delegated voting power of the old and new delegates delegated to\\n    // by `voter` based on the snapshot change.\\n    function _rebalanceDelegates(\\n        address voter,\\n        address oldDelegate,\\n        address newDelegate,\\n        VotingPowerSnapshot memory oldSnap,\\n        VotingPowerSnapshot memory newSnap\\n    ) private {\\n        if (newDelegate == address(0) || oldDelegate == address(0)) {\\n            revert InvalidDelegateError();\\n        }\\n        if (oldDelegate != voter && oldDelegate != newDelegate) {\\n            // Remove past voting power from old delegate.\\n            VotingPowerSnapshot memory oldDelegateSnap = _getLastVotingPowerSnapshotForVoter(\\n                oldDelegate\\n            );\\n            VotingPowerSnapshot memory updatedOldDelegateSnap = VotingPowerSnapshot({\\n                timestamp: uint40(block.timestamp),\\n                delegatedVotingPower: oldDelegateSnap.delegatedVotingPower -\\n                    oldSnap.intrinsicVotingPower,\\n                intrinsicVotingPower: oldDelegateSnap.intrinsicVotingPower,\\n                isDelegated: oldDelegateSnap.isDelegated\\n            });\\n            _insertVotingPowerSnapshot(oldDelegate, updatedOldDelegateSnap);\\n        }\\n        if (newDelegate != voter) {\\n            // Not delegating to self.\\n            // Add new voting power to new delegate.\\n            VotingPowerSnapshot memory newDelegateSnap = _getLastVotingPowerSnapshotForVoter(\\n                newDelegate\\n            );\\n            uint96 newDelegateDelegatedVotingPower = newDelegateSnap.delegatedVotingPower +\\n                newSnap.intrinsicVotingPower;\\n            if (newDelegate == oldDelegate) {\\n                // If the old and new delegate are the same, subtract the old\\n                // intrinsic voting power of the voter, or else we will double\\n                // count a portion of it.\\n                newDelegateDelegatedVotingPower -= oldSnap.intrinsicVotingPower;\\n            }\\n            VotingPowerSnapshot memory updatedNewDelegateSnap = VotingPowerSnapshot({\\n                timestamp: uint40(block.timestamp),\\n                delegatedVotingPower: newDelegateDelegatedVotingPower,\\n                intrinsicVotingPower: newDelegateSnap.intrinsicVotingPower,\\n                isDelegated: newDelegateSnap.isDelegated\\n            });\\n            _insertVotingPowerSnapshot(newDelegate, updatedNewDelegateSnap);\\n        }\\n    }\\n\\n    // Append a new voting power snapshot, overwriting the last one if possible.\\n    function _insertVotingPowerSnapshot(address voter, VotingPowerSnapshot memory snap) private {\\n        emit PartyVotingSnapshotCreated(\\n            voter,\\n            snap.timestamp,\\n            snap.delegatedVotingPower,\\n            snap.intrinsicVotingPower,\\n            snap.isDelegated\\n        );\\n\\n        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];\\n        uint256 n = voterSnaps.length;\\n        // If same timestamp as last entry, overwrite the last snapshot, otherwise append.\\n        if (n != 0) {\\n            VotingPowerSnapshot memory lastSnap = voterSnaps[n - 1];\\n            if (lastSnap.timestamp == snap.timestamp) {\\n                voterSnaps[n - 1] = snap;\\n                return;\\n            }\\n        }\\n        voterSnaps.push(snap);\\n    }\\n\\n    function _getLastVotingPowerSnapshotForVoter(\\n        address voter\\n    ) private view returns (VotingPowerSnapshot memory snap) {\\n        VotingPowerSnapshot[] storage voterSnaps = _votingPowerSnapshotsByVoter[voter];\\n        uint256 n = voterSnaps.length;\\n        if (n != 0) {\\n            snap = voterSnaps[n - 1];\\n        }\\n    }\\n\\n    function _getProposalFlags(ProposalStateValues memory pv) private pure returns (uint256) {\\n        uint256 flags = 0;\\n        if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {\\n            flags = flags | LibProposal.PROPOSAL_FLAG_UNANIMOUS;\\n        }\\n        if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {\\n            flags = flags | LibProposal.PROPOSAL_FLAG_HOSTS_ACCEPT;\\n        }\\n        return flags;\\n    }\\n\\n    function _getProposalStatus(\\n        ProposalStateValues memory pv\\n    ) private view returns (ProposalStatus status) {\\n        // Never proposed.\\n        if (pv.proposedTime == 0) {\\n            return ProposalStatus.Invalid;\\n        }\\n        // Executed at least once.\\n        if (pv.executedTime != 0) {\\n            if (pv.completedTime == 0) {\\n                return ProposalStatus.InProgress;\\n            }\\n            // completedTime high bit will be set if cancelled.\\n            if (pv.completedTime & UINT40_HIGH_BIT == UINT40_HIGH_BIT) {\\n                return ProposalStatus.Cancelled;\\n            }\\n            return ProposalStatus.Complete;\\n        }\\n        // Vetoed.\\n        if (pv.votes == type(uint96).max) {\\n            return ProposalStatus.Defeated;\\n        }\\n        uint40 t = uint40(block.timestamp);\\n        if (pv.passedTime != 0) {\\n            // Ready.\\n            if (pv.passedTime + pv.executionDelay <= t) {\\n                return ProposalStatus.Ready;\\n            }\\n            // If unanimous, we skip the execution delay.\\n            if (_isUnanimousVotes(pv.votes, pv.totalVotingPower)) {\\n                return ProposalStatus.Ready;\\n            }\\n            // If all hosts voted, skip execution delay\\n            if (_hostsAccepted(pv.numHosts, pv.numHostsAccepted)) {\\n                return ProposalStatus.Ready;\\n            }\\n            // Passed.\\n            return ProposalStatus.Passed;\\n        }\\n        // Voting window expired.\\n        if (pv.proposedTime + pv.voteDuration <= t) {\\n            return ProposalStatus.Defeated;\\n        }\\n        return ProposalStatus.Voting;\\n    }\\n\\n    function _isUnanimousVotes(\\n        uint96 totalVotes,\\n        uint96 totalVotingPower\\n    ) private pure returns (bool) {\\n        uint256 acceptanceRatio = (uint256(totalVotes) * 1e4) / totalVotingPower;\\n        // If >= 99.99% acceptance, consider it unanimous.\\n        // The minting formula for voting power is a bit lossy, so we check\\n        // for slightly less than 100%.\\n        return acceptanceRatio >= 0.9999e4;\\n    }\\n\\n    function _hostsAccepted(\\n        uint8 snapshotNumHosts,\\n        uint8 numHostsAccepted\\n    ) private pure returns (bool) {\\n        return snapshotNumHosts > 0 && snapshotNumHosts == numHostsAccepted;\\n    }\\n\\n    function _areVotesPassing(\\n        uint96 voteCount,\\n        uint96 totalVotingPower,\\n        uint16 passThresholdBps\\n    ) private pure returns (bool) {\\n        return (uint256(voteCount) * 1e4) / uint256(totalVotingPower) >= uint256(passThresholdBps);\\n    }\\n\\n    function _setPreciousList(\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) private {\\n        if (preciousTokens.length != preciousTokenIds.length) {\\n            revert MismatchedPreciousListLengths();\\n        }\\n        preciousListHash = _hashPreciousList(preciousTokens, preciousTokenIds);\\n    }\\n\\n    function _isPreciousListCorrect(\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) private view returns (bool) {\\n        return preciousListHash == _hashPreciousList(preciousTokens, preciousTokenIds);\\n    }\\n\\n    function _hashPreciousList(\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal pure returns (bytes32 h) {\\n        assembly {\\n            mstore(0x00, keccak256(add(preciousTokens, 0x20), mul(mload(preciousTokens), 0x20)))\\n            mstore(0x20, keccak256(add(preciousTokenIds, 0x20), mul(mload(preciousTokenIds), 0x20)))\\n            h := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    function _emitMetadataUpdateEvent() internal {\\n        emit BatchMetadataUpdate(0, type(uint256).max);\\n    }\\n\\n    // Assert that the hash of a proposal matches expectedHash.\\n    function _validateProposalHash(Proposal memory proposal, bytes32 expectedHash) private pure {\\n        bytes32 actualHash = getProposalHash(proposal);\\n        if (expectedHash != actualHash) {\\n            revert BadProposalHashError(actualHash, expectedHash);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/ERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../utils/EIP165.sol\\\";\\nimport \\\"../vendor/solmate/ERC721.sol\\\";\\n\\n/// @notice Mixin for contracts that want to receive ERC721 tokens.\\n/// @dev Use this instead of solmate's ERC721TokenReceiver because the\\n///      compiler has issues when overriding EIP165/IERC721Receiver functions.\\nabstract contract ERC721Receiver is IERC721Receiver, EIP165, ERC721TokenReceiver {\\n    /// @inheritdoc IERC721Receiver\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override(IERC721Receiver, ERC721TokenReceiver) returns (bytes4) {\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        return\\n            EIP165.supportsInterface(interfaceId) ||\\n            interfaceId == type(IERC721Receiver).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/party/IPartyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { Party } from \\\"../party/Party.sol\\\";\\nimport { IERC721 } from \\\"../tokens/IERC721.sol\\\";\\nimport { MetadataProvider } from \\\"../renderers/MetadataProvider.sol\\\";\\n\\n// Creates generic Party instances.\\ninterface IPartyFactory {\\n    event PartyCreated(\\n        Party indexed party,\\n        Party.PartyOptions opts,\\n        IERC721[] preciousTokens,\\n        uint256[] preciousTokenIds,\\n        address creator\\n    );\\n\\n    /// @notice Deploy a new party instance.\\n    /// @param partyImpl The implementation of the party to deploy.\\n    /// @param authorities The addresses set as authorities for the party.\\n    /// @param opts Options used to initialize the party. These are fixed\\n    ///             and cannot be changed later.\\n    /// @param preciousTokens The tokens that are considered precious by the\\n    ///                       party.These are protected assets and are subject\\n    ///                       to extra restrictions in proposals vs other\\n    ///                       assets.\\n    /// @param preciousTokenIds The IDs associated with each token in `preciousTokens`.\\n    /// @param rageQuitTimestamp The timestamp until which ragequit is enabled.\\n    /// @return party The newly created `Party` instance.\\n    function createParty(\\n        Party partyImpl,\\n        address[] memory authorities,\\n        Party.PartyOptions calldata opts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        uint40 rageQuitTimestamp\\n    ) external returns (Party party);\\n\\n    /// @notice Deploy a new party instance with custom metadata.\\n    /// @param partyImpl The implementation of the party to deploy.\\n    /// @param authorities The addresses set as authorities for the party.\\n    /// @param opts Options used to initialize the party.\\n    /// @param preciousTokens The tokens that are considered precious by the\\n    ///                       party.These are protected assets and are subject\\n    ///                       to extra restrictions in proposals vs other\\n    ///                       assets.\\n    /// @param preciousTokenIds The IDs associated with each token in `preciousTokens`.\\n    /// @param rageQuitTimestamp The timestamp until which ragequit is enabled.\\n    /// @param provider The metadata provider to use for the party.\\n    /// @param metadata The metadata to use for the party.\\n    /// @return party The newly created `Party` instance.\\n    function createPartyWithMetadata(\\n        Party partyImpl,\\n        address[] memory authorities,\\n        Party.PartyOptions memory opts,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds,\\n        uint40 rageQuitTimestamp,\\n        MetadataProvider provider,\\n        bytes memory metadata\\n    ) external returns (Party party);\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/RendererStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"solmate/utils/SSTORE2.sol\\\";\\nimport \\\"../utils/Multicall.sol\\\";\\n\\ncontract RendererStorage is Multicall {\\n    error AlreadySetError();\\n    error NotOwnerError(address caller, address owner);\\n\\n    event OwnershipTransferred(address previousOwner, address newOwner);\\n\\n    uint256 constant CROWDFUND_CARD_DATA = 0;\\n    uint256 constant PARTY_CARD_DATA = 1;\\n\\n    /// @notice Address allowed to store new data.\\n    address public owner;\\n\\n    /// @notice Customization presets by ID, used for rendering cards. Begins at\\n    ///         1, 0 is reserved to indicate in `getPresetFor()` that a\\n    ///         party instance use the preset set by the crowdfund instance that\\n    ///         created it.\\n    mapping(uint256 => bytes) public customizationPresets;\\n    /// @notice Customization preset used by a crowdfund or party instance.\\n    mapping(address => uint256) public getPresetFor;\\n    /// @notice Addresses where URI data chunks are stored.\\n    mapping(uint256 => address) public files;\\n\\n    modifier onlyOwner() {\\n        address owner_ = owner;\\n        if (msg.sender != owner_) {\\n            revert NotOwnerError(msg.sender, owner_);\\n        }\\n\\n        _;\\n    }\\n\\n    constructor(address _owner) {\\n        // Set the address allowed to write new data.\\n        owner = _owner;\\n\\n        // Write URI data used by V1 of the renderers:\\n\\n        files[CROWDFUND_CARD_DATA] = SSTORE2.write(\\n            bytes(\\n                '<path class=\\\"o\\\" d=\\\"M118.4 419.5h5.82v1.73h-4.02v1.87h3.74v1.73h-3.74v1.94h4.11v1.73h-5.91v-9Zm9.93 1.76h-2.6v-1.76h7.06v1.76h-2.61v7.24h-1.85v-7.24Zm6.06-1.76h1.84v3.55h3.93v-3.55H142v9h-1.84v-3.67h-3.93v3.67h-1.84v-9Z\\\"/><path class=\\\"o\\\" d=\\\"M145 413a4 4 0 0 1 4 4v14a4 4 0 0 1-4 4H35a4 4 0 0 1-4-4v-14a4 4 0 0 1 4-4h110m0-1H35a5 5 0 0 0-5 5v14a5 5 0 0 0 5 5h110a5 5 0 0 0 5-5v-14a5 5 0 0 0-5-5Z\\\"/><path d=\\\"M239.24 399.83h3.04c1.7 0 2.82 1 2.82 2.55 0 2.1-1.27 3.32-3.57 3.32h-1.97l-.71 3.3h-1.56l1.96-9.17Zm2.34 4.38c1.23 0 1.88-.58 1.88-1.68 0-.73-.49-1.2-1.48-1.2h-1.51l-.6 2.88h1.7Zm3.57 1.86c0-2.27 1.44-3.83 3.57-3.83 1.82 0 3.06 1.25 3.06 3.09 0 2.28-1.43 3.83-3.57 3.83-1.82 0-3.06-1.25-3.06-3.09Zm3.13 1.74c1.19 0 1.93-1.02 1.93-2.52 0-1.06-.62-1.69-1.56-1.69-1.19 0-1.93 1.02-1.93 2.52 0 1.06.62 1.69 1.56 1.69Zm4.74-5.41h1.49l.28 4.73 2.25-4.73h1.64l.23 4.77 2.25-4.77h1.56l-3.3 6.61h-1.62l-.25-5.04-2.42 5.04h-1.63l-.48-6.61Zm9.54 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm3.46-2.59h1.55l-.28 1.28c.81-1.7 2.56-1.36 2.77-1.29l-.35 1.46c-.18-.06-2.3-.63-2.82 1.68l-.74 3.48h-1.55l1.42-6.61Zm3.91 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm2.25 1.36c0-2.44 1.36-4.1 3.26-4.1 1 0 1.76.53 2.05 1.31l.79-3.72h1.55l-1.96 9.17h-1.55l.2-.92a2.15 2.15 0 0 1-1.92 1.08c-1.49 0-2.43-1.18-2.43-2.82Zm3 1.51c.88 0 1.51-.58 1.73-1.56l.17-.81c.24-1.1-.31-1.93-1.36-1.93-1.19 0-1.94 1.08-1.94 2.59 0 1.06.55 1.71 1.4 1.71Zm9.6-.01-.25 1.16h-1.55l1.96-9.17h1.55l-.73 3.47a2.35 2.35 0 0 1 1.99-1.05c1.49 0 2.35 1.16 2.35 2.76 0 2.52-1.36 4.16-3.21 4.16-.98 0-1.81-.53-2.1-1.32Zm1.83.01c1.16 0 1.87-1.06 1.87-2.61 0-1.04-.5-1.69-1.39-1.69s-1.52.56-1.73 1.55l-.17.79c-.24 1.14.34 1.97 1.42 1.97Zm5.68 1.16-1.04-6.62h1.52l.66 4.75 2.66-4.75h1.69l-5.31 9.13h-1.73l1.55-2.51Zm23.48-6.8a42.14 42.14 0 0 0-.75 6.01 43.12 43.12 0 0 0 5.58 2.35 42.54 42.54 0 0 0 5.58-2.35 45.32 45.32 0 0 0-.75-6.01c-.91-.79-2.6-2.21-4.83-3.66a42.5 42.5 0 0 0-4.83 3.66Zm13.07-7.95s.82-.29 1.76-.45a14.9 14.9 0 0 0-9.53-3.81c.66.71 1.28 1.67 1.84 2.75 1.84.22 4.07.7 5.92 1.51Zm-2.71 18.36c-2.06-.4-4.05-.97-5.53-1.51a38.65 38.65 0 0 1-5.53 1.51c.12 1.5.35 3.04.76 4.58 0 0 1.54 1.82 4.78 2.8 3.23-.98 4.78-2.8 4.78-2.8.4-1.53.64-3.08.76-4.58Zm-13.77-18.37a22.3 22.3 0 0 1 5.93-1.51 12.4 12.4 0 0 1 1.84-2.75 14.97 14.97 0 0 0-9.53 3.81c.95.16 1.76.45 1.76.45Zm-4.72 8.77a25.74 25.74 0 0 0 3.58 2.94 37.48 37.48 0 0 1 4.08-4.04c.27-1.56.77-3.57 1.46-5.55a25.24 25.24 0 0 0-4.34-1.63s-2.35.42-4.81 2.74c-.77 3.29.04 5.54.04 5.54Zm25.92 0s.81-2.25.04-5.54c-2.46-2.31-4.81-2.74-4.81-2.74-1.53.42-2.99.99-4.34 1.63a37.79 37.79 0 0 1 1.46 5.55 37.44 37.44 0 0 1 4.08 4.04 25.86 25.86 0 0 0 3.58-2.94Zm-26.38.2s-.66-.56-1.27-1.3c-.7 3.34-.27 6.93 1.46 10.16.28-.93.8-1.94 1.46-2.97a22.32 22.32 0 0 1-1.66-5.88Zm8.24 14.27a22.07 22.07 0 0 1-4.27-4.38c-1.22.06-2.36 0-3.3-.22a14.91 14.91 0 0 0 8.07 6.34c-.34-.9-.5-1.75-.5-1.75Zm18.6-14.27s.66-.56 1.27-1.3c.7 3.34.27 6.93-1.46 10.16-.28-.93-.8-1.94-1.46-2.97a22.32 22.32 0 0 0 1.66-5.88Zm-8.24 14.27a22.07 22.07 0 0 0 4.27-4.38c1.22.06 2.36 0 3.3-.22a14.91 14.91 0 0 1-8.07 6.34c.34-.9.5-1.75.5-1.75ZM330 391.84l-4.12 2.45 1.26 3.91h5.72l1.26-3.91-4.12-2.45Zm-11.4 19.74 4.18 2.35 2.75-3.05-2.86-4.95-4.02.86-.06 4.79Zm22.79 0-.06-4.79-4.02-.86-2.86 4.95 2.75 3.05 4.18-2.35Z\\\" style=\\\"fill:#00c1fa\\\"/><use height=\\\"300\\\" transform=\\\"matrix(1 0 0 .09 29.85 444)\\\" width=\\\"300.15\\\" xlink:href=\\\"#a\\\"/><use height=\\\"21.15\\\" transform=\\\"translate(30 446.92)\\\" width=\\\"300\\\" xlink:href=\\\"#b\\\"/><g><path d=\\\"m191.54 428.67-28.09-24.34A29.98 29.98 0 0 0 143.8 397H30a15 15 0 0 0-15 15v98a15 15 0 0 0 15 15h300a15 15 0 0 0 15-15v-59a15 15 0 0 0-15-15H211.19a30 30 0 0 1-19.65-7.33Z\\\" style=\\\"fill:url(#i)\\\"/></g></svg>'\\n            )\\n        );\\n\\n        files[PARTY_CARD_DATA] = SSTORE2.write(\\n            bytes(\\n                ' d=\\\"M188 444.3h2.4l2.6 8.2 2.7-8.2h2.3l-3.7 10.7h-2.8l-3.5-10.7zm10.5 5.3c0-3.2 2.2-5.6 5.3-5.6 3.1 0 5.3 2.3 5.3 5.6 0 3.2-2.2 5.5-5.3 5.5-3.1.1-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.4 0-2.1-1.1-3.5-3-3.5s-3 1.3-3 3.5c0 2.1 1.1 3.4 3 3.4zm8.7-6.7h-3.1v-2.1h8.4v2.1h-3.1v8.6h-2.2v-8.6zm6.9-2.1h2.2V455h-2.2v-10.7zm4.3 0h2.9l4 8.2v-8.2h2.1V455h-2.9l-4-8.2v8.2h-2.1v-10.7zm10.6 5.4c0-3.4 2.3-5.6 6-5.6 1.2 0 2.3.2 3.1.6v2.3c-.9-.6-1.9-.8-3.1-.8-2.4 0-3.8 1.3-3.8 3.5 0 2.1 1.3 3.4 3.5 3.4.5 0 .9-.1 1.3-.2v-2.2h-2.2v-1.9h4.3v5.6c-1 .5-2.2.8-3.4.8-3.5 0-5.7-2.2-5.7-5.5zm15.1-5.4h4.3c2.3 0 3.7 1.3 3.7 3.5s-1.4 3.5-3.7 3.5h-2.1v3.7h-2.2v-10.7zm4.1 5c1.1 0 1.6-.5 1.6-1.5s-.5-1.5-1.6-1.5h-1.9v2.9h1.9zm4.8.3c0-3.2 2.2-5.6 5.3-5.6 3.1 0 5.3 2.3 5.3 5.6 0 3.2-2.2 5.5-5.3 5.5-3.1.1-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.4 0-2.1-1.1-3.5-3-3.5s-3 1.3-3 3.5c0 2.1 1.1 3.4 3 3.4zm5.8-8.8h2.3l1.7 7.8 1.9-7.8h2.4l1.8 7.8 1.8-7.8h2.3l-2.7 10.7h-2.5l-1.9-8.2-1.8 8.2h-2.5l-2.8-10.7zm15.4 0h6.9v2.1H287v2.2h4.5v2.1H287v2.3h4.9v2.1h-7v-10.8zm9 0h4.5c2 0 3.3 1.3 3.3 3.2 0 1.9-1.2 3.1-3 3.2l3.5 4.3h-2.7l-3.5-4.4v4.4h-2.1v-10.7zm4.1 4.8c1 0 1.5-.5 1.5-1.4 0-.9-.6-1.4-1.5-1.4h-2v2.9h2zM30 444.3h4.3c3 0 5.2 2.1 5.2 5.4s-2.1 5.4-5.2 5.4H30v-10.8zm4 8.6c2.1 0 3.2-1.2 3.2-3.2s-1.2-3.3-3.2-3.3h-1.8v6.5H34zm7.7-8.6h2.2V455h-2.2v-10.7zm4.8 10V452c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.7-1.5-2.7-3.1 0-2 1.5-3.2 3.9-3.2 1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4-1.1-.2-2.3-.5-3.3-1.1zm12-7.9h-3.1v-2.1h8.4v2.1h-3.1v8.6h-2.2v-8.6zm7.5-2.1h4.5c2 0 3.3 1.3 3.3 3.2 0 1.9-1.2 3.1-3 3.2l3.5 4.3h-2.7l-3.5-4.4v4.4H66v-10.7zm4.1 4.8c1 0 1.5-.5 1.5-1.4s-.6-1.4-1.5-1.4h-2v2.9h2zm6.1-4.8h2.2V455h-2.2v-10.7zm5 0h4.5c2 0 3.2 1.1 3.2 2.8 0 1.1-.5 1.9-1.4 2.3 1.1.3 1.8 1.3 1.8 2.5 0 1.9-1.3 3.1-3.5 3.1h-4.6v-10.7zm4.2 4.4c.9 0 1.4-.5 1.4-1.3s-.5-1.3-1.4-1.3h-2.1v2.5l2.1.1zm.3 4.4c.9 0 1.5-.5 1.5-1.3s-.6-1.3-1.5-1.3h-2.4v2.6h2.4zm5.7-2.5v-6.3h2.2v6.3c0 1.6.9 2.5 2.3 2.5s2.3-.9 2.3-2.5v-6.3h2.2v6.3c0 2.9-1.7 4.6-4.5 4.6s-4.6-1.7-4.5-4.6zm14.2-4.2h-3.1v-2.1h8.4v2.1h-3.1v8.6h-2.2v-8.6zm7.5-2.1h2.2V455h-2.2v-10.7zm4.5 5.3c0-3.2 2.2-5.6 5.3-5.6s5.3 2.3 5.3 5.6-2.2 5.5-5.3 5.5-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.5s-1.2-3.5-3-3.5-3 1.3-3 3.5 1.1 3.5 3 3.5zm7.5-8.8h2.9l4 8.2v-8.2h2.1V455h-2.9l-4-8.2v8.2h-2.1v-10.7zm11.7 10V452c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.6-1.5-2.6-3.1 0-2 1.5-3.2 3.9-3.2 1.1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4a9.7 9.7 0 0 1-3.4-1.1zM30 259.3h4.3c2.2 0 3.7 1.3 3.7 3.5s-1.4 3.5-3.7 3.5h-2.1v3.7H30v-10.7zm4.1 5c1.1 0 1.6-.5 1.6-1.5s-.5-1.5-1.6-1.5h-1.9v2.9h1.9zm6.1-5h4.5c2 0 3.3 1.3 3.3 3.2 0 1.9-1.2 3.1-3 3.2l3.5 4.3h-2.7l-3.5-4.4v4.4h-2.1v-10.7zm4.1 4.8c1 0 1.5-.5 1.5-1.4s-.6-1.4-1.5-1.4h-2v2.9h2zm5.4.5c0-3.2 2.2-5.6 5.3-5.6s5.3 2.3 5.3 5.6-2.2 5.5-5.3 5.5-5.3-2.2-5.3-5.5zm5.3 3.5c1.8 0 3-1.3 3-3.5s-1.2-3.5-3-3.5-3 1.3-3 3.5 1.1 3.5 3 3.5zm7.6-8.8h4.3c2.2 0 3.7 1.3 3.7 3.5s-1.4 3.5-3.7 3.5h-2.1v3.7h-2.2v-10.7zm4.1 5c1.1 0 1.6-.5 1.6-1.5s-.6-1.5-1.6-1.5h-1.9v2.9h1.9zm5.4.4c0-3.2 2.2-5.6 5.3-5.6s5.3 2.3 5.3 5.6-2.2 5.5-5.3 5.5-5.3-2.3-5.3-5.5zm5.4 3.4c1.8 0 3-1.3 3-3.5s-1.2-3.5-3-3.5-3 1.3-3 3.5 1.1 3.5 3 3.5zm7.2 1.2V267c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.7-1.5-2.7-3.1 0-2 1.5-3.2 3.9-3.2 1.1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4-1.1-.2-2.3-.5-3.3-1.1zm12.2-10h2.8l3.7 10.7h-2.3l-.8-2.5h-4l-.8 2.5h-2.2l3.6-10.7zm2.8 6.3-1.4-4.2-1.4 4.2h2.8zm5.7-6.3h2.2v8.6h4.7v2.1h-6.9v-10.7zm9.1 10V267c1 .7 2.1 1.1 3.2 1.1s1.7-.5 1.7-1.2-.4-1-1.2-1.2l-1.2-.3c-1.8-.5-2.7-1.5-2.7-3.1 0-2 1.5-3.2 3.9-3.2 1.1 0 2.1.2 2.9.7v2.3c-.9-.6-1.9-.8-3-.8-.9 0-1.6.4-1.6 1.1 0 .6.4.9 1.2 1.1l1.3.4c1.8.5 2.6 1.4 2.6 3.1 0 2.1-1.5 3.4-3.8 3.4-1.1-.2-2.3-.5-3.3-1.1zm-84.5-70h2.9l4 8.2v-8.2H39V210h-2.9l-4-8.2v8.2H30v-10.7zm14.7 0h2.8l3.7 10.7h-2.3l-.8-2.6h-4l-.8 2.6H41l3.7-10.7zm2.8 6.2-1.4-4.2-1.4 4.2h2.8zm5.7-6.2h3.3l2.5 8.2 2.5-8.2h3.3V210h-2v-8.6L60 210h-2.1l-2.7-8.5v8.5h-2v-10.7zm14.4 0h6.9v2.1h-4.8v2.2h4.4v2.1h-4.4v2.3h4.9v2.1h-7v-10.8z\\\" /><path d=\\\"M239.24 24.83h3.04c1.7 0 2.82 1 2.82 2.55 0 2.1-1.27 3.32-3.57 3.32h-1.97l-.71 3.3h-1.56l1.96-9.17Zm2.34 4.38c1.23 0 1.88-.58 1.88-1.68 0-.73-.49-1.2-1.48-1.2h-1.51l-.6 2.88h1.7Zm3.57 1.86c0-2.27 1.44-3.83 3.57-3.83 1.82 0 3.06 1.25 3.06 3.09 0 2.28-1.43 3.83-3.57 3.83-1.82 0-3.06-1.25-3.06-3.09Zm3.13 1.74c1.19 0 1.93-1.02 1.93-2.52 0-1.06-.62-1.69-1.56-1.69-1.19 0-1.93 1.02-1.93 2.52 0 1.06.62 1.69 1.56 1.69Zm4.74-5.41h1.49l.28 4.73 2.25-4.73h1.64l.23 4.77 2.25-4.77h1.56l-3.3 6.61h-1.62l-.25-5.04-2.42 5.04h-1.63l-.48-6.61Zm9.54 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm3.46-2.59h1.55l-.28 1.28c.81-1.7 2.56-1.36 2.77-1.29l-.35 1.46c-.18-.06-2.3-.63-2.82 1.68l-.74 3.48h-1.55l1.42-6.61Zm3.91 3.66c0-2.27 1.45-3.81 3.6-3.81 2 0 3.05 1.58 2.33 3.92h-4.46c0 1.1.81 1.68 2.05 1.68.8 0 1.45-.2 2.1-.59l-.31 1.46a4.2 4.2 0 0 1-2.04.44c-2.06 0-3.26-1.19-3.26-3.11Zm4.7-1.07c.12-.86-.31-1.46-1.22-1.46s-1.57.61-1.82 1.46h3.05Zm2.25 1.36c0-2.44 1.36-4.1 3.26-4.1 1 0 1.76.53 2.05 1.31l.79-3.72h1.55l-1.96 9.17h-1.55l.2-.92a2.15 2.15 0 0 1-1.92 1.08c-1.49 0-2.43-1.18-2.43-2.82Zm3 1.51c.88 0 1.51-.58 1.73-1.56l.17-.81c.24-1.1-.31-1.93-1.36-1.93-1.19 0-1.94 1.08-1.94 2.59 0 1.06.55 1.71 1.4 1.71Zm9.6-.01-.25 1.16h-1.55l1.96-9.17h1.55l-.73 3.47a2.35 2.35 0 0 1 1.99-1.05c1.49 0 2.35 1.16 2.35 2.76 0 2.52-1.36 4.16-3.21 4.16-.98 0-1.81-.53-2.1-1.32Zm1.83.01c1.16 0 1.87-1.06 1.87-2.61 0-1.04-.5-1.69-1.39-1.69s-1.52.56-1.73 1.55l-.17.79c-.24 1.14.34 1.97 1.42 1.97Zm5.68 1.16-1.04-6.62h1.52l.66 4.75 2.66-4.75h1.69l-5.31 9.13h-1.73l1.55-2.51Zm23.47-6.8c.91-.79 2.6-2.21 4.83-3.66a42.5 42.5 0 0 1 4.83 3.66c.23 1.18.62 3.36.75 6.01a43.12 43.12 0 0 1-5.58 2.35 42.54 42.54 0 0 1-5.58-2.35c.14-2.65.53-4.83.75-6.01Zm13.07-7.95s.82-.29 1.76-.45a14.9 14.9 0 0 0-9.53-3.81c.66.71 1.28 1.67 1.84 2.75 1.84.22 4.07.7 5.92 1.51Zm-2.71 18.36c-2.06-.4-4.05-.97-5.53-1.51a38.65 38.65 0 0 1-5.53 1.51c.12 1.5.35 3.04.76 4.58 0 0 1.54 1.82 4.78 2.8 3.23-.98 4.78-2.8 4.78-2.8.4-1.53.64-3.08.76-4.58Zm-13.77-18.37a22.3 22.3 0 0 1 5.93-1.51 12.4 12.4 0 0 1 1.84-2.75 14.97 14.97 0 0 0-9.53 3.81c.95.16 1.76.45 1.76.45Zm-4.72 8.77a25.74 25.74 0 0 0 3.58 2.94 37.48 37.48 0 0 1 4.08-4.04c.27-1.56.77-3.57 1.46-5.55a25.24 25.24 0 0 0-4.34-1.63s-2.35.42-4.81 2.74c-.77 3.29.04 5.54.04 5.54Zm25.92 0s.81-2.25.04-5.54c-2.46-2.31-4.81-2.74-4.81-2.74-1.53.42-2.99.99-4.34 1.63a37.79 37.79 0 0 1 1.46 5.55 37.44 37.44 0 0 1 4.08 4.04 25.86 25.86 0 0 0 3.58-2.94Zm-26.38.2s-.66-.56-1.27-1.3c-.7 3.34-.27 6.93 1.46 10.16.28-.93.8-1.94 1.46-2.97a22.32 22.32 0 0 1-1.66-5.88Zm8.24 14.27a22.07 22.07 0 0 1-4.27-4.38c-1.22.06-2.36 0-3.3-.22a14.91 14.91 0 0 0 8.07 6.34c-.34-.9-.5-1.75-.5-1.75Zm18.6-14.27s.66-.56 1.27-1.3c.7 3.34.27 6.93-1.46 10.16-.28-.93-.8-1.94-1.46-2.97a22.32 22.32 0 0 0 1.66-5.88Zm-8.24 14.27a22.07 22.07 0 0 0 4.27-4.38c1.22.06 2.36 0 3.3-.22a14.91 14.91 0 0 1-8.07 6.34c.34-.9.5-1.75.5-1.75Zm-5.18-25.66-4.12 2.45 1.26 3.91h5.72l1.26-3.91-4.12-2.45Zm-11.4 19.74 4.18 2.35 2.75-3.05-2.86-4.95-4.02.86-.06 4.79Zm22.79 0-.06-4.79-4.02-.86-2.86 4.95 2.75 3.05 4.18-2.35Z\\\" style=\\\"fill:#00c1fa\\\"/><path d=\\\"M106.67 109.1a304.9 304.9 0 0 0-3.72-10.89c5.04-5.53 35.28-40.74 24.54-68.91 10.57 10.67 8.19 28.85 3.59 41.95-4.79 13.14-13.43 26.48-24.4 37.84Zm30.89 20.82c-5.87 6.12-20.46 17.92-21.67 18.77a99.37 99.37 0 0 0 7.94 6.02 133.26 133.26 0 0 0 20.09-18.48 353.47 353.47 0 0 0-6.36-6.31Zm-29.65-16.74a380.9 380.9 0 0 1 3.13 11.56c-4.8-1.37-8.66-2.53-12.36-3.82a123.4 123.4 0 0 1-21.16 13.21l15.84 5.47c14.83-8.23 28.13-20.82 37.81-34.68 0 0 8.56-12.55 12.42-23.68 2.62-7.48 4.46-16.57 3.49-24.89-2.21-12.27-6.95-15.84-9.32-17.66 6.16 5.72 3.25 27.8-2.79 39.89-6.08 12.16-15.73 24.27-27.05 34.59Zm59.05-37.86c-.03 7.72-3.05 15.69-6.44 22.69 1.7 2.2 3.18 4.36 4.42 6.49 7.97-16.51 3.74-26.67 2.02-29.18ZM61.18 128.51l12.5 4.3a101.45 101.45 0 0 0 21.42-13.19 163.26 163.26 0 0 1-10.61-4.51 101.28 101.28 0 0 1-23.3 13.4Zm87.78-42.73c.86.77 5.44 5.18 6.75 6.59 6.39-16.61.78-28.86-1.27-30.56.72 8.05-2.02 16.51-5.48 23.98Zm-14.29 40.62-2.47-15.18a142.42 142.42 0 0 1-35.74 29.45c6.81 2.36 12.69 4.4 15.45 5.38a115.98 115.98 0 0 0 22.75-19.66Zm-42.62 34.73c4.48 2.93 12.94 4.24 18.8 1.23 6.03-3.84-.6-8.34-8.01-9.88-9.8-2.03-16.82 1.22-13.4 6.21.41.6 1.19 1.5 2.62 2.44m-1.84.4c-3.56-2.37-6.77-7.2-.23-10.08 10.41-3.43 28.39 3.2 24.99 9.22-.58 1.04-1.46 1.6-2.38 2.19h-.03v.02h-.03v.02h-.03c-7.04 3.65-17.06 2.13-22.3-1.36m5.48-3.86a4.94 4.94 0 0 0 5.06.49l1.35-.74-4.68-2.38-1.47.79c-.38.22-1.53.88-.26 1.84m-1.7.59c-2.35-1.57-.78-2.61-.02-3.11 1.09-.57 2.19-1.15 3.28-1.77 6.95 3.67 7.22 3.81 13.19 6.17l-1.38.81c-1.93-.78-4.52-1.82-6.42-2.68.86 1.4 1.99 3.27 2.9 4.64l-1.68.87c-.75-1.28-1.76-2.99-2.47-4.29-3.19 2.06-6.99-.36-7.42-.64\\\" style=\\\"fill:url(#f2)\\\"/><path d=\\\"M159.13 52.37C143.51 24.04 119.45 15 103.6 15c-11.92 0-25.97 5.78-36.84 13.17 9.54 4.38 21.86 15.96 22.02 16.11-7.94-3.05-17.83-6.72-33.23-7.87a135.1 135.1 0 0 0-19.77 20.38c.77 7.66 2.88 15.68 2.88 15.68-6.28-4.75-11.02-4.61-18 9.45-5.4 12.66-6.93 24.25-4.65 33.18 0 0 4.72 26.8 36.23 40.07-1.3-4.61-1.58-9.91-.93-15.73a87.96 87.96 0 0 1-15.63-9.87c.79-6.61 2.79-13.82 6-21.36 4.42-10.66 4.35-15.14 4.35-15.19.03.07 5.48 12.43 12.95 22.08 4.23-8.84 9.46-16.08 13.67-21.83l-3.77-6.75a143.73 143.73 0 0 1 18.19-18.75c2.05 1.07 4.79 2.47 6.84 3.58 8.68-7.27 19.25-14.05 30.56-18.29-7-11.49-16.02-19.27-16.02-19.27s27.7 2.74 42.02 15.69a25.8 25.8 0 0 1 8.65 2.89ZM28.58 107.52a70.1 70.1 0 0 0-2.74 12.52 55.65 55.65 0 0 1-6.19-8.84 69.17 69.17 0 0 1 2.65-12.1c1.77-5.31 3.35-5.91 5.86-2.23v-.05c2.14 3.07 1.81 6.14.42 10.7ZM61.69 72.2l-.05.05a221.85 221.85 0 0 1-7.77-18.1l.14-.14a194.51 194.51 0 0 1 18.56 6.98 144.44 144.44 0 0 0-10.88 11.22Zm54.84-47.38c-4.42.7-9.02 1.95-13.67 3.72a65.03 65.03 0 0 0-7.81-5.31 66.04 66.04 0 0 1 13.02-3.54c1.53-.19 6.23-.79 10.32 2.42v-.05c2.47 1.91.14 2.37-1.86 2.75Z\\\" style=\\\"fill:url(#h)\\\"/>'\\n            )\\n        );\\n    }\\n\\n    /// @notice Transfer ownership to a new owner.\\n    /// @param newOwner The address to transfer ownership to.\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    /// @notice Write data to be accessed by a given file key.\\n    /// @param key The key to access the written data.\\n    /// @param data The data to be written.\\n    function writeFile(uint256 key, string memory data) external onlyOwner {\\n        files[key] = SSTORE2.write(bytes(data));\\n    }\\n\\n    /// @notice Read data using a given file key.\\n    /// @param key The key to access the stored data.\\n    /// @return data The data stored at the given key.\\n    function readFile(uint256 key) external view returns (string memory data) {\\n        return string(SSTORE2.read(files[key]));\\n    }\\n\\n    /// @notice Create or set a customization preset for renderers to use.\\n    /// @param id The ID of the customization preset.\\n    /// @param customizationData Data decoded by renderers used to render the SVG according to the preset.\\n    function createCustomizationPreset(\\n        uint256 id,\\n        bytes memory customizationData\\n    ) external onlyOwner {\\n        customizationPresets[id] = customizationData;\\n    }\\n\\n    /// @notice For crowdfund or party instances to set the customization preset they want to use.\\n    /// @param id The ID of the customization preset.\\n    function useCustomizationPreset(uint256 id) external {\\n        getPresetFor[msg.sender] = id;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/crowdfund/CrowdfundNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\nimport \\\"../utils/ReadOnlyDelegateCall.sol\\\";\\nimport \\\"../utils/EIP165.sol\\\";\\nimport \\\"../utils/IERC4906.sol\\\";\\nimport \\\"../globals/IGlobals.sol\\\";\\nimport \\\"../globals/LibGlobals.sol\\\";\\nimport \\\"../renderers/RendererStorage.sol\\\";\\n\\n/// @notice NFT functionality for crowdfund types. This NFT is soulbound and read-only.\\nabstract contract CrowdfundNFT is IERC721, IERC4906, EIP165, ReadOnlyDelegateCall {\\n    error AlreadyMintedError(address owner, uint256 tokenId);\\n    error AlreadyBurnedError(address owner, uint256 tokenId);\\n    error InvalidTokenError(uint256 tokenId);\\n    error InvalidAddressError();\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice The name of the crowdfund. This will also carry over to the\\n    ///         governance party.\\n    string public name;\\n    /// @notice The token symbol for the crowdfund. This will also carry over to\\n    ///         the governance party.\\n    string public symbol;\\n\\n    mapping(uint256 => address) private _owners;\\n\\n    modifier alwaysRevert() {\\n        revert(\\\"ALWAYS FAILING\\\");\\n        _; // Compiler requires this.\\n    }\\n\\n    // Set the `Globals` contract.\\n    constructor(IGlobals globals) {\\n        _GLOBALS = globals;\\n    }\\n\\n    // Initialize name and symbol for crowdfund.\\n    function _initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 customizationPresetId\\n    ) internal virtual {\\n        name = name_;\\n        symbol = symbol_;\\n        if (customizationPresetId != 0) {\\n            RendererStorage(_GLOBALS.getAddress(LibGlobals.GLOBAL_RENDERER_STORAGE))\\n                .useCustomizationPreset(customizationPresetId);\\n        }\\n    }\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function transferFrom(address, address, uint256) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function safeTransferFrom(address, address, uint256) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function safeTransferFrom(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function approve(address, uint256) external pure alwaysRevert {}\\n\\n    /// @notice DO NOT CALL. This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always fail.\\n    function setApprovalForAll(address, bool) external pure alwaysRevert {}\\n\\n    /// @notice This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always return null.\\n    function getApproved(uint256) external pure returns (address) {\\n        return address(0);\\n    }\\n\\n    /// @notice This is a soulbound NFT and cannot be transferred.\\n    ///         Attempting to call this function will always return false.\\n    function isApprovedForAll(address, address) external pure returns (bool) {\\n        return false;\\n    }\\n\\n    /// @inheritdoc EIP165\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        return\\n            super.supportsInterface(interfaceId) ||\\n            // ERC721 interface ID\\n            interfaceId == 0x80ac58cd;\\n    }\\n\\n    /// @notice Returns a URI to render the NFT.\\n    function tokenURI(uint256) external view returns (string memory) {\\n        return _delegateToRenderer();\\n    }\\n\\n    /// @notice Returns a URI for the storefront-level metadata for your contract.\\n    function contractURI() external view returns (string memory) {\\n        return _delegateToRenderer();\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function ownerOf(uint256 tokenId) external view returns (address owner) {\\n        owner = _owners[tokenId];\\n        if (owner == address(0)) {\\n            revert InvalidTokenError(tokenId);\\n        }\\n    }\\n\\n    /// @inheritdoc IERC721\\n    function balanceOf(address owner) external view returns (uint256 numTokens) {\\n        return _doesTokenExistFor(owner) ? 1 : 0;\\n    }\\n\\n    function _doesTokenExistFor(address owner) internal view returns (bool) {\\n        return _owners[uint256(uint160(owner))] != address(0);\\n    }\\n\\n    function _mint(address owner) internal returns (uint256 tokenId) {\\n        if (owner == address(0)) revert InvalidAddressError();\\n        tokenId = uint256(uint160(owner));\\n        if (_owners[tokenId] != owner) {\\n            _owners[tokenId] = owner;\\n            emit Transfer(address(0), owner, tokenId);\\n        } else {\\n            revert AlreadyMintedError(owner, tokenId);\\n        }\\n    }\\n\\n    function _burn(address owner) internal {\\n        uint256 tokenId = uint256(uint160(owner));\\n        if (_owners[tokenId] == owner) {\\n            _owners[tokenId] = address(0);\\n            emit Transfer(owner, address(0), tokenId);\\n            return;\\n        }\\n        revert AlreadyBurnedError(owner, tokenId);\\n    }\\n\\n    function _delegateToRenderer() private view returns (string memory) {\\n        _readOnlyDelegateCall(\\n            // Instance of IERC721Renderer.\\n            _GLOBALS.getAddress(LibGlobals.GLOBAL_CF_NFT_RENDER_IMPL),\\n            msg.data\\n        );\\n        assert(false); // Will not be reached.\\n        return \\\"\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../utils/LibRawResult.sol\\\";\\n\\nabstract contract Multicall {\\n    using LibRawResult for bytes;\\n\\n    /// @notice Perform multiple delegatecalls on ourselves.\\n    function multicall(bytes[] calldata multicallData) external {\\n        for (uint256 i; i < multicallData.length; ++i) {\\n            (bool s, bytes memory r) = address(this).delegatecall(multicallData[i]);\\n            if (!s) {\\n                r.rawRevert();\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/MetadataRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport { IGlobals } from \\\"../globals/IGlobals.sol\\\";\\nimport { LibGlobals } from \\\"../globals/LibGlobals.sol\\\";\\nimport { IMetadataProvider } from \\\"./IMetadataProvider.sol\\\";\\nimport { Multicall } from \\\"../utils/Multicall.sol\\\";\\n\\n/// @notice A registry of custom metadata providers for Party Cards.\\ncontract MetadataRegistry is Multicall {\\n    event ProviderSet(address indexed instance, IMetadataProvider indexed provider);\\n    event RegistrarSet(address indexed registrar, address indexed instance, bool canSetData);\\n\\n    error NotAuthorized(address caller, address instance);\\n\\n    // The `Globals` contract storing global configuration values. This contract\\n    // is immutable and it\u2019s address will never change.\\n    IGlobals private immutable _GLOBALS;\\n\\n    /// @notice Get the metadata provider for a Party instance.\\n    mapping(address instance => IMetadataProvider provider) public getProvider;\\n\\n    /// @notice Whether or not an address is a registar that can set the\\n    ///         provider and metadata for another instance. If registrar is set\\n    ///         true for `address(1)`, the address is a universal registar and\\n    ///         can set data for any instance.\\n    /// @dev Registrars' ability to set metadata for another instance must also be\\n    ///      supported by the metadata provider used by that instance, indicated by\\n    ///      `IMetadataProvider.supportsRegistrars()`.\\n    mapping(address registrar => mapping(address instance => bool canSetData)) private _isRegistrar;\\n\\n    /// @param globals The address of the `Globals` contract.\\n    /// @param registrars The addresses of the initial universal registrars.\\n    constructor(IGlobals globals, address[] memory registrars) {\\n        _GLOBALS = globals;\\n\\n        // Set the initial universal registrars.\\n        for (uint256 i = 0; i < registrars.length; i++) {\\n            _isRegistrar[registrars[i]][address(1)] = true;\\n        }\\n    }\\n\\n    /// @notice Set the metadata provider for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param provider The address of the metadata provider.\\n    function setProvider(address instance, IMetadataProvider provider) external {\\n        // Check if the caller is authorized to set the provider for the instance.\\n        if (!isRegistrar(msg.sender, instance)) revert NotAuthorized(msg.sender, instance);\\n\\n        getProvider[instance] = provider;\\n\\n        emit ProviderSet(instance, provider);\\n    }\\n\\n    /// @notice Set whether or not an address can set metadata for a Party instance.\\n    /// @param registrar The address of the possible registrar.\\n    /// @param instance The address of the instance the registrar can set\\n    ///                 metadata for.\\n    /// @param canSetData Whether or not the address can set data for the instance.\\n    function setRegistrar(address registrar, address instance, bool canSetData) external {\\n        if (\\n            msg.sender != instance &&\\n            msg.sender != _GLOBALS.getAddress(LibGlobals.GLOBAL_DAO_WALLET)\\n        ) {\\n            revert NotAuthorized(msg.sender, instance);\\n        }\\n\\n        _isRegistrar[registrar][instance] = canSetData;\\n\\n        emit RegistrarSet(registrar, instance, canSetData);\\n    }\\n\\n    /// @notice Get whether or not an address can set metadata for a Party instance.\\n    /// @param registrar The address of the possible registrar.\\n    /// @param instance The address of the instance the registrar can set\\n    ///                 metadata for.\\n    /// @return canSetData Whether or not the address can set data for the instance.\\n    function isRegistrar(address registrar, address instance) public view returns (bool) {\\n        return\\n            registrar == instance ||\\n            _isRegistrar[registrar][address(1)] ||\\n            _isRegistrar[registrar][instance];\\n    }\\n\\n    /// @notice Get the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param tokenId The ID of the token to get the metadata for.\\n    /// @return metadata The encoded metadata.\\n    function getMetadata(address instance, uint256 tokenId) external view returns (bytes memory) {\\n        IMetadataProvider provider = getProvider[instance];\\n\\n        return\\n            address(provider) != address(0) ? provider.getMetadata(instance, tokenId) : bytes(\\\"\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/IMetadataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8;\\n\\ninterface IMetadataProvider {\\n    /// @notice Whether or not the metadata provider supports registrars that can\\n    ///         set metadata for other instances.\\n    /// @dev See `MetadataRegistry` for more information on the registrar role.\\n    function supportsRegistrars() external view returns (bool);\\n\\n    /// @notice Get the metadata for a Party instance.\\n    /// @param instance The address of the instance.\\n    /// @param tokenId The ID of the token to get the metadata for.\\n    /// @return metadata The encoded metadata.\\n    function getMetadata(\\n        address instance,\\n        uint256 tokenId\\n    ) external view returns (bytes memory metadata);\\n}\\n\"\r\n    },\r\n    \"contracts/globals/LibGlobals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Valid keys in `IGlobals`. Append-only.\\nlibrary LibGlobals {\\n    // The Globals commented out below were depreciated in 1.2; factories\\n    // can now choose the implementation address to deploy and no longer\\n    // deploy the latest implementation. They will no longer be updated\\n    // in future releases.\\n    //\\n    // See https://github.com/PartyDAO/party-migrations for\\n    // implementation addresses by release.\\n\\n    uint256 internal constant GLOBAL_PARTY_IMPL = 1;\\n    uint256 internal constant GLOBAL_PROPOSAL_ENGINE_IMPL = 2;\\n    uint256 internal constant GLOBAL_PARTY_FACTORY = 3;\\n    uint256 internal constant GLOBAL_GOVERNANCE_NFT_RENDER_IMPL = 4;\\n    uint256 internal constant GLOBAL_CF_NFT_RENDER_IMPL = 5;\\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_TIMEOUT = 6;\\n    uint256 internal constant GLOBAL_OS_ZORA_AUCTION_DURATION = 7;\\n    // uint256 internal constant GLOBAL_AUCTION_CF_IMPL = 8;\\n    // uint256 internal constant GLOBAL_BUY_CF_IMPL = 9;\\n    // uint256 internal constant GLOBAL_COLLECTION_BUY_CF_IMPL = 10;\\n    uint256 internal constant GLOBAL_DAO_WALLET = 11;\\n    uint256 internal constant GLOBAL_TOKEN_DISTRIBUTOR = 12;\\n    uint256 internal constant GLOBAL_OPENSEA_CONDUIT_KEY = 13;\\n    uint256 internal constant GLOBAL_OPENSEA_ZONE = 14;\\n    uint256 internal constant GLOBAL_PROPOSAL_MAX_CANCEL_DURATION = 15;\\n    uint256 internal constant GLOBAL_ZORA_MIN_AUCTION_DURATION = 16;\\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_DURATION = 17;\\n    uint256 internal constant GLOBAL_ZORA_MAX_AUCTION_TIMEOUT = 18;\\n    uint256 internal constant GLOBAL_OS_MIN_ORDER_DURATION = 19;\\n    uint256 internal constant GLOBAL_OS_MAX_ORDER_DURATION = 20;\\n    uint256 internal constant GLOBAL_DISABLE_PARTY_ACTIONS = 21;\\n    uint256 internal constant GLOBAL_RENDERER_STORAGE = 22;\\n    uint256 internal constant GLOBAL_PROPOSAL_MIN_CANCEL_DURATION = 23;\\n    // uint256 internal constant GLOBAL_ROLLING_AUCTION_CF_IMPL = 24;\\n    // uint256 internal constant GLOBAL_COLLECTION_BATCH_BUY_CF_IMPL = 25;\\n    uint256 internal constant GLOBAL_METADATA_REGISTRY = 26;\\n    // uint256 internal constant GLOBAL_CROWDFUND_FACTORY = 27;\\n    // uint256 internal constant GLOBAL_INITIAL_ETH_CF_IMPL = 28;\\n    // uint256 internal constant GLOBAL_RERAISE_ETH_CF_IMPL = 29;\\n    uint256 internal constant GLOBAL_SEAPORT = 30;\\n    uint256 internal constant GLOBAL_CONDUIT_CONTROLLER = 31;\\n    uint256 internal constant GLOBAL_OFF_CHAIN_SIGNATURE_VALIDATOR = 32;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Implementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\n// Base contract for all contracts intended to be delegatecalled into.\\nabstract contract Implementation {\\n    event Initialized();\\n\\n    error AlreadyInitialized();\\n    error OnlyDelegateCallError();\\n\\n    /// @notice The address of the implementation contract.\\n    address public immutable implementation;\\n\\n    /// @notice Whether or not the implementation has been initialized.\\n    bool public initialized;\\n\\n    constructor() {\\n        implementation = address(this);\\n    }\\n\\n    // Reverts if the current function context is not inside of a delegatecall.\\n    modifier onlyDelegateCall() virtual {\\n        if (address(this) == implementation) {\\n            revert OnlyDelegateCallError();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyInitialize() {\\n        if (initialized) revert AlreadyInitialized();\\n\\n        initialized = true;\\n        emit Initialized();\\n\\n        _;\\n    }\\n\\n    /// @notice The address of the implementation contract.\\n    /// @dev This is an alias for `implementation` for backwards compatibility.\\n    function IMPL() external view returns (address) {\\n        return implementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/solmate/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport \\\"../../tokens/IERC721.sol\\\";\\nimport \\\"../../utils/EIP165.sol\\\";\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Modified from Solmate\\nabstract contract ERC721 is IERC721, EIP165 {\\n    error NotMinted();\\n    error ZeroAddress();\\n    error UnsafeRecipient();\\n    error Unauthorized();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id /* view */) public virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        owner = _ownerOf[id];\\n        if (owner == address(0)) {\\n            revert NotMinted();\\n        }\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        if (msg.sender != owner && !isApprovedForAll[owner][msg.sender]) {\\n            revert Unauthorized();\\n        }\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(address from, address to, uint256 id) public virtual {\\n        if (from != _ownerOf[id]) {\\n            revert Unauthorized();\\n        }\\n\\n        if (to == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        if (\\n            msg.sender != from &&\\n            !isApprovedForAll[from][msg.sender] &&\\n            msg.sender != getApproved[id]\\n        ) {\\n            revert Unauthorized();\\n        }\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 id) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n            ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") !=\\n            ERC721TokenReceiver.onERC721Received.selector\\n        ) {\\n            revert UnsafeRecipient();\\n        }\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n            ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) !=\\n            ERC721TokenReceiver.onERC721Received.selector\\n        ) {\\n            revert UnsafeRecipient();\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n        // NOTE: modified from original to call super.\\n        return\\n            super.supportsInterface(interfaceId) ||\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        if (to == address(0)) {\\n            revert ZeroAddress();\\n        }\\n\\n        if (_ownerOf[id] != address(0)) {\\n            revert Unauthorized();\\n        }\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        if (owner == address(0)) {\\n            revert Unauthorized();\\n        }\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n            ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") !=\\n            ERC721TokenReceiver.onERC721Received.selector\\n        ) {\\n            revert UnsafeRecipient();\\n        }\\n    }\\n\\n    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {\\n        _mint(to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n            ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) !=\\n            ERC721TokenReceiver.onERC721Received.selector\\n        ) {\\n            revert UnsafeRecipient();\\n        }\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/distribution/ITokenDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC20.sol\\\";\\n\\nimport \\\"../party/Party.sol\\\";\\n\\n/// @notice Creates token distributions for parties.\\ninterface ITokenDistributor {\\n    enum TokenType {\\n        Native,\\n        Erc20\\n    }\\n\\n    // Info on a distribution, created by createDistribution().\\n    struct DistributionInfo {\\n        // Type of distribution/token.\\n        TokenType tokenType;\\n        // ID of the distribution. Assigned by createDistribution().\\n        uint256 distributionId;\\n        // The party whose members can claim the distribution.\\n        Party party;\\n        // Who can claim `fee`.\\n        address payable feeRecipient;\\n        // The token being distributed.\\n        address token;\\n        // Total amount of `token` that can be claimed by party members.\\n        uint128 memberSupply;\\n        // Amount of `token` to be redeemed by `feeRecipient`.\\n        uint128 fee;\\n        // Total shares at time distribution was created.\\n        uint96 totalShares;\\n    }\\n\\n    event DistributionCreated(Party indexed party, DistributionInfo info);\\n    event DistributionFeeClaimed(\\n        Party indexed party,\\n        address indexed feeRecipient,\\n        TokenType tokenType,\\n        address token,\\n        uint256 amount\\n    );\\n    event DistributionClaimedByPartyToken(\\n        Party indexed party,\\n        uint256 indexed partyTokenId,\\n        address indexed owner,\\n        TokenType tokenType,\\n        address token,\\n        uint256 amountClaimed\\n    );\\n\\n    /// @notice Create a new distribution for an outstanding native token balance\\n    ///         governed by a party.\\n    /// @dev Native tokens should be transferred directly into this contract\\n    ///      immediately prior (same tx) to calling `createDistribution()` or\\n    ///      attached to the call itself.\\n    /// @param party The party whose members can claim the distribution.\\n    /// @param feeRecipient Who can claim `fee`.\\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\\n    /// @return info Information on the created distribution.\\n    function createNativeDistribution(\\n        Party party,\\n        address payable feeRecipient,\\n        uint16 feeBps\\n    ) external payable returns (DistributionInfo memory info);\\n\\n    /// @notice Create a new distribution for an outstanding ERC20 token balance\\n    ///         governed by a party.\\n    /// @dev ERC20 tokens should be transferred directly into this contract\\n    ///      immediately prior (same tx) to calling `createDistribution()` or\\n    ///      attached to the call itself.\\n    /// @param token The ERC20 token to distribute.\\n    /// @param party The party whose members can claim the distribution.\\n    /// @param feeRecipient Who can claim `fee`.\\n    /// @param feeBps Percentage (in bps) of the distribution `feeRecipient` receives.\\n    /// @return info Information on the created distribution.\\n    function createErc20Distribution(\\n        IERC20 token,\\n        Party party,\\n        address payable feeRecipient,\\n        uint16 feeBps\\n    ) external returns (DistributionInfo memory info);\\n\\n    /// @notice Claim a portion of a distribution owed to a `partyTokenId` belonging\\n    ///         to the party that created the distribution. The caller\\n    ///         must own this token.\\n    /// @param info Information on the distribution being claimed.\\n    /// @param partyTokenId The ID of the party token to claim for.\\n    /// @return amountClaimed The amount of the distribution claimed.\\n    function claim(\\n        DistributionInfo calldata info,\\n        uint256 partyTokenId\\n    ) external returns (uint128 amountClaimed);\\n\\n    /// @notice Claim the fee for a distribution. Only a distribution's `feeRecipient`\\n    ///         can call this.\\n    /// @param info Information on the distribution being claimed.\\n    /// @param recipient The address to send the fee to.\\n    function claimFee(DistributionInfo calldata info, address payable recipient) external;\\n\\n    /// @notice Batch version of `claim()`.\\n    /// @param infos Information on the distributions being claimed.\\n    /// @param partyTokenIds The ID of the party tokens to claim for.\\n    /// @return amountsClaimed The amount of the distributions claimed.\\n    function batchClaim(\\n        DistributionInfo[] calldata infos,\\n        uint256[] calldata partyTokenIds\\n    ) external returns (uint128[] memory amountsClaimed);\\n\\n    /// @notice Batch version of `claimFee()`.\\n    /// @param infos Information on the distributions to claim fees for.\\n    /// @param recipients The addresses to send the fees to.\\n    function batchClaimFee(\\n        DistributionInfo[] calldata infos,\\n        address payable[] calldata recipients\\n    ) external;\\n\\n    /// @notice Compute the amount of a distribution's token are owed to a party\\n    ///         member, identified by the `partyTokenId`.\\n    /// @param info Information on the distribution being claimed.\\n    /// @param partyTokenId The ID of the party token to claim for.\\n    /// @return claimAmount The amount of the distribution owed to the party member.\\n    function getClaimAmount(\\n        DistributionInfo calldata info,\\n        uint256 partyTokenId\\n    ) external view returns (uint128);\\n\\n    /// @notice Check whether the fee has been claimed for a distribution.\\n    /// @param party The party to use for checking whether the fee has been claimed.\\n    /// @param distributionId The ID of the distribution to check.\\n    /// @return feeClaimed Whether the fee has been claimed.\\n    function wasFeeClaimed(Party party, uint256 distributionId) external view returns (bool);\\n\\n    /// @notice Check whether a `partyTokenId` has claimed their share of a distribution.\\n    /// @param party The party to use for checking whether the `partyTokenId` has claimed.\\n    /// @param partyTokenId The ID of the party token to check.\\n    /// @param distributionId The ID of the distribution to check.\\n    /// @return hasClaimed Whether the `partyTokenId` has claimed.\\n    function hasPartyTokenIdClaimed(\\n        Party party,\\n        uint256 partyTokenId,\\n        uint256 distributionId\\n    ) external view returns (bool);\\n\\n    /// @notice Get how much unclaimed member tokens are left in a distribution.\\n    /// @param party The party to use for checking the unclaimed member tokens.\\n    /// @param distributionId The ID of the distribution to check.\\n    /// @return remainingMemberSupply The amount of distribution supply remaining.\\n    function getRemainingMemberSupply(\\n        Party party,\\n        uint256 distributionId\\n    ) external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReadOnlyDelegateCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"./LibRawResult.sol\\\";\\n\\ninterface IReadOnlyDelegateCall {\\n    // Marked `view` so that `_readOnlyDelegateCall` can be `view` as well.\\n    function delegateCallAndRevert(address impl, bytes memory callData) external view;\\n}\\n\\n// Inherited by contracts to perform read-only delegate calls.\\nabstract contract ReadOnlyDelegateCall {\\n    using LibRawResult for bytes;\\n\\n    // Delegatecall into implement and revert with the raw result.\\n    function delegateCallAndRevert(address impl, bytes memory callData) external {\\n        // Attempt to gate to only `_readOnlyDelegateCall()` invocations.\\n        require(msg.sender == address(this));\\n        (bool s, bytes memory r) = impl.delegatecall(callData);\\n        // Revert with success status and return data.\\n        abi.encode(s, r).rawRevert();\\n    }\\n\\n    // Perform a `delegateCallAndRevert()` then return the raw result data.\\n    function _readOnlyDelegateCall(address impl, bytes memory callData) internal view {\\n        try IReadOnlyDelegateCall(address(this)).delegateCallAndRevert(impl, callData) {\\n            // Should never happen.\\n            assert(false);\\n        } catch (bytes memory r) {\\n            (bool success, bytes memory resultData) = abi.decode(r, (bool, bytes));\\n            if (!success) {\\n                resultData.rawRevert();\\n            }\\n            resultData.rawReturn();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\n// Minimal ERC20 interface.\\ninterface IERC20 {\\n    event Transfer(address indexed owner, address indexed to, uint256 amount);\\n    event Approval(address indexed owner, address indexed spender, uint256 allowance);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    function approve(address spender, uint256 allowance) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/solmate/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\n// Only modified to inherit IERC1155 and rename ERC1155TokenReceiver -> ERC1155TokenReceiverBase.\\npragma solidity ^0.8;\\n\\nimport \\\"../../tokens/IERC1155.sol\\\";\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 is IERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155BatchReceived(\\n                    msg.sender,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(\\n        address[] calldata owners,\\n        uint256[] calldata ids\\n    ) public view virtual returns (uint256[] memory balances) {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155Received(\\n                    msg.sender,\\n                    address(0),\\n                    id,\\n                    amount,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiverBase(to).onERC1155BatchReceived(\\n                    msg.sender,\\n                    address(0),\\n                    ids,\\n                    amounts,\\n                    data\\n                ) == ERC1155TokenReceiverBase.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiverBase {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiverBase.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiverBase.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/LibERC20Compat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC20.sol\\\";\\n\\n// Compatibility helpers for ERC20s.\\nlibrary LibERC20Compat {\\n    error NotATokenError(IERC20 token);\\n    error TokenTransferFailedError(IERC20 token, address to, uint256 amount);\\n    error TokenApprovalFailed(IERC20 token, address spender, uint256 amount);\\n\\n    // Perform an `IERC20.transfer()` handling non-compliant implementations.\\n    function compatTransfer(IERC20 token, address to, uint256 amount) internal {\\n        (bool s, bytes memory r) = address(token).call(\\n            abi.encodeCall(IERC20.transfer, (to, amount))\\n        );\\n        if (s) {\\n            if (r.length == 0) {\\n                uint256 cs;\\n                assembly {\\n                    cs := extcodesize(token)\\n                }\\n                if (cs == 0) {\\n                    revert NotATokenError(token);\\n                }\\n                return;\\n            }\\n            if (abi.decode(r, (bool))) {\\n                return;\\n            }\\n        }\\n        revert TokenTransferFailedError(token, to, amount);\\n    }\\n\\n    // Perform an `IERC20.transferFrom()` handling non-compliant implementations.\\n    function compatTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\\n        (bool s, bytes memory r) = address(token).call(\\n            abi.encodeCall(IERC20.transferFrom, (from, to, amount))\\n        );\\n        if (s) {\\n            if (r.length == 0) {\\n                uint256 cs;\\n                assembly {\\n                    cs := extcodesize(token)\\n                }\\n                if (cs == 0) {\\n                    revert NotATokenError(token);\\n                }\\n                return;\\n            }\\n            if (abi.decode(r, (bool))) {\\n                return;\\n            }\\n        }\\n        revert TokenTransferFailedError(token, to, amount);\\n    }\\n\\n    function compatApprove(IERC20 token, address spender, uint256 amount) internal {\\n        (bool s, bytes memory r) = address(token).call(\\n            abi.encodeCall(IERC20.approve, (spender, amount))\\n        );\\n        if (s) {\\n            if (r.length == 0) {\\n                uint256 cs;\\n                assembly {\\n                    cs := extcodesize(token)\\n                }\\n                if (cs == 0) {\\n                    revert NotATokenError(token);\\n                }\\n                return;\\n            }\\n            if (abi.decode(r, (bool))) {\\n                return;\\n            }\\n        }\\n        revert TokenApprovalFailed(token, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/IERC4906.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\ninterface IERC4906 {\\n    event MetadataUpdate(uint256 _tokenId);\\n\\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/proposals/LibProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nimport \\\"../tokens/IERC721.sol\\\";\\n\\nlibrary LibProposal {\\n    uint256 internal constant PROPOSAL_FLAG_UNANIMOUS = 0x1;\\n    uint256 internal constant PROPOSAL_FLAG_HOSTS_ACCEPT = 0x2;\\n\\n    function isTokenPrecious(\\n        IERC721 token,\\n        IERC721[] memory preciousTokens\\n    ) internal pure returns (bool) {\\n        for (uint256 i; i < preciousTokens.length; ++i) {\\n            if (token == preciousTokens[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function isTokenIdPrecious(\\n        IERC721 token,\\n        uint256 tokenId,\\n        IERC721[] memory preciousTokens,\\n        uint256[] memory preciousTokenIds\\n    ) internal pure returns (bool) {\\n        for (uint256 i; i < preciousTokens.length; ++i) {\\n            if (token == preciousTokens[i] && tokenId == preciousTokenIds[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/EIP165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.20;\\n\\nabstract contract EIP165 {\\n    /// @notice Query if a contract implements an interface.\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @return `true` if the contract implements `interfaceId` and\\n    ///         `interfaceId` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return interfaceId == this.supportsInterface.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SSTORE2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Read and write to persistent storage at a fraction of the cost.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\\nlibrary SSTORE2 {\\n    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               WRITE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function write(bytes memory data) internal returns (address pointer) {\\n        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.\\n        bytes memory runtimeCode = abi.encodePacked(hex\\\"00\\\", data);\\n\\n        bytes memory creationCode = abi.encodePacked(\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //\\n            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //\\n            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //\\n            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //\\n            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //\\n            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //\\n            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //\\n            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //\\n            // 0xf3    |  0xf3               | RETURN       |                                                                //\\n            //---------------------------------------------------------------------------------------------------------------//\\n            hex\\\"60_0B_59_81_38_03_80_92_59_39_F3\\\", // Returns all code in the contract except for the first 11 (0B in hex) bytes.\\n            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.\\n        );\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Deploy a new contract with the generated creation code.\\n            // We start 32 bytes into the code to avoid copying the byte length.\\n            pointer := create(0, add(creationCode, 32), mload(creationCode))\\n        }\\n\\n        require(pointer != address(0), \\\"DEPLOYMENT_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               READ LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function read(address pointer) internal view returns (bytes memory) {\\n        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);\\n    }\\n\\n    function read(address pointer, uint256 start) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n\\n        return readBytecode(pointer, start, pointer.code.length - start);\\n    }\\n\\n    function read(address pointer, uint256 start, uint256 end) internal view returns (bytes memory) {\\n        start += DATA_OFFSET;\\n        end += DATA_OFFSET;\\n\\n        require(pointer.code.length >= end, \\\"OUT_OF_BOUNDS\\\");\\n\\n        return readBytecode(pointer, start, end - start);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function readBytecode(address pointer, uint256 start, uint256 size) private view returns (bytes memory data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Get a pointer to some free memory.\\n            data := mload(0x40)\\n\\n            // Update the free memory pointer to prevent overriding our data.\\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\\n            // Adding 31 to size and running the result through the logic above ensures\\n            // the memory pointer remains word-aligned, following the Solidity convention.\\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\\n\\n            // Store the size of the data in the first 32 byte chunk of free memory.\\n            mstore(data, size)\\n\\n            // Copy the code into memory right after the 32 bytes we used to store the size.\\n            extcodecopy(pointer, add(data, 32), start, size)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8;\\n\\n// Minimal ERC1155 interface.\\ninterface IERC1155 {\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function balanceOf(address owner, uint256 tokenId) external view returns (uint256);\\n\\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\\n\\n    function balanceOfBatch(\\n        address[] calldata owners,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory balances);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"party-addresses/=lib/party-addresses/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"shanghai\",\r\n    \"libraries\": {\r\n      \"contracts/utils/LibRenderer.sol\": {\r\n        \"LibRenderer\": \"0xc23e0eb44b4468266d36568bbbf39b1766937932\"\r\n      }\r\n    },\r\n    \"viaIR\": true\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IGlobals\",\"name\":\"globals\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"contributions\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContributions\",\"type\":\"uint96\"}],\"name\":\"AboveMaximumContributionsError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ArityMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"contributions\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"minContributions\",\"type\":\"uint96\"}],\"name\":\"BelowMinimumContributionsError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContributingForExistingCardDisabledError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"errData\",\"type\":\"bytes\"}],\"name\":\"EthTransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"remaining\",\"type\":\"uint96\"}],\"name\":\"ExceedsRemainingContributionsError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FundingSplitAlreadyPaidError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FundingSplitNotConfiguredError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDelegateError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"exchangeRate\",\"type\":\"uint160\"}],\"name\":\"InvalidExchangeRateError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFundingSplitRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMessageValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"maxTotalContributions\",\"type\":\"uint96\"}],\"name\":\"MaxTotalContributionsCannotBeZeroError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"min\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"max\",\"type\":\"uint96\"}],\"name\":\"MinGreaterThanMaxError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"min\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"max\",\"type\":\"uint96\"}],\"name\":\"MinMaxDifferenceTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"},{\"internalType\":\"bytes\",\"name\":\"gateData\",\"type\":\"bytes\"}],\"name\":\"NotAllowedByGateKeeperError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"totalContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"minTotalContributions\",\"type\":\"uint96\"}],\"name\":\"NotEnoughContributionsError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NotOwnerError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyDelegateCallError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"notDao\",\"type\":\"address\"}],\"name\":\"OnlyPartyDaoError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"notDao\",\"type\":\"address\"}],\"name\":\"OnlyPartyDaoOrHostError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPartyHostError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyWhenEmergencyActionsAllowedError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"u256\",\"type\":\"uint256\"}],\"name\":\"Uint256ToUint40CastOutOfRangeError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"name\":\"Uint256ToUint96CastOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum ETHCrowdfundBase.CrowdfundLifecycle\",\"name\":\"lc\",\"type\":\"uint8\"}],\"name\":\"WrongLifecycleError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroVotingPowerError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"Contributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountEth\",\"type\":\"uint256\"}],\"name\":\"EmergencyExecute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EmergencyExecuteDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fundingSplitRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundingSplitSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IMPL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96[]\",\"name\":\"values\",\"type\":\"uint96[]\"},{\"internalType\":\"bytes[]\",\"name\":\"gateDatas\",\"type\":\"bytes[]\"}],\"internalType\":\"struct InitialETHCrowdfund.BatchContributeArgs\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"batchContribute\",\"outputs\":[{\"internalType\":\"uint96[]\",\"name\":\"votingPowers\",\"type\":\"uint96[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address payable[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"initialDelegates\",\"type\":\"address[]\"},{\"internalType\":\"uint96[]\",\"name\":\"values\",\"type\":\"uint96[]\"},{\"internalType\":\"bytes[]\",\"name\":\"gateDatas\",\"type\":\"bytes[]\"}],\"internalType\":\"struct InitialETHCrowdfund.BatchContributeForArgs\",\"name\":\"args\",\"type\":\"tuple\"}],\"name\":\"batchContributeFor\",\"outputs\":[{\"internalType\":\"uint96[]\",\"name\":\"votingPowers\",\"type\":\"uint96[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"revertOnFailure\",\"type\":\"bool\"}],\"name\":\"batchRefund\",\"outputs\":[{\"internalType\":\"uint96[]\",\"name\":\"amounts\",\"type\":\"uint96[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"gateData\",\"type\":\"bytes\"}],\"name\":\"contribute\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"votingPower\",\"type\":\"uint96\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"gateData\",\"type\":\"bytes\"}],\"name\":\"contribute\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"votingPower\",\"type\":\"uint96\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"gateData\",\"type\":\"bytes\"}],\"name\":\"contributeFor\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"votingPower\",\"type\":\"uint96\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"contribution\",\"type\":\"uint96\"}],\"name\":\"convertContributionToVotingPower\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"votingPower\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"votingPower\",\"type\":\"uint96\"}],\"name\":\"convertVotingPowerToContribution\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"contribution\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegationsByContributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableContributingForExistingCard\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableEmergencyExecute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"targetCallData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountEth\",\"type\":\"uint256\"}],\"name\":\"emergencyExecute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyExecuteDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expiry\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingSplitBps\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingSplitPaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingSplitRecipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeper\",\"outputs\":[{\"internalType\":\"contract IGateKeeper\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeperId\",\"outputs\":[{\"internalType\":\"bytes12\",\"name\":\"\",\"type\":\"bytes12\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCrowdfundLifecycle\",\"outputs\":[{\"internalType\":\"enum ETHCrowdfundBase.CrowdfundLifecycle\",\"name\":\"lifecycle\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"initialContributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialDelegate\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"minContribution\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxContribution\",\"type\":\"uint96\"},{\"internalType\":\"bool\",\"name\":\"disableContributingForExistingCard\",\"type\":\"bool\"},{\"internalType\":\"uint96\",\"name\":\"minTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"maxTotalContributions\",\"type\":\"uint96\"},{\"internalType\":\"uint160\",\"name\":\"exchangeRate\",\"type\":\"uint160\"},{\"internalType\":\"uint16\",\"name\":\"fundingSplitBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"fundingSplitRecipient\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"contract IGateKeeper\",\"name\":\"gateKeeper\",\"type\":\"address\"},{\"internalType\":\"bytes12\",\"name\":\"gateKeeperId\",\"type\":\"bytes12\"}],\"internalType\":\"struct InitialETHCrowdfund.InitialETHCrowdfundOptions\",\"name\":\"crowdfundOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"customizationPresetId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract Party\",\"name\":\"partyImpl\",\"type\":\"address\"},{\"internalType\":\"contract IPartyFactory\",\"name\":\"partyFactory\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"hosts\",\"type\":\"address[]\"},{\"internalType\":\"uint40\",\"name\":\"voteDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"executionDelay\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"passThresholdBps\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"address payable\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"internalType\":\"struct Crowdfund.FixedGovernanceOpts\",\"name\":\"governanceOpts\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"enableAddAuthorityProposal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowArbCallsToSpendPartyEth\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOperators\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"distributionsRequireVote\",\"type\":\"bool\"}],\"internalType\":\"struct ProposalStorage.ProposalEngineOpts\",\"name\":\"proposalEngineOpts\",\"type\":\"tuple\"},{\"internalType\":\"contract IERC721[]\",\"name\":\"preciousTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"preciousTokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint40\",\"name\":\"rageQuitTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"address[]\",\"name\":\"authorities\",\"type\":\"address[]\"}],\"internalType\":\"struct InitialETHCrowdfund.ETHPartyOptions\",\"name\":\"partyOpts\",\"type\":\"tuple\"},{\"internalType\":\"contract MetadataProvider\",\"name\":\"customMetadataProvider\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"customMetadata\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxContribution\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTotalContributions\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minContribution\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minTotalContributions\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"party\",\"outputs\":[{\"internalType\":\"contract Party\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendFundingSplit\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"splitAmount\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributions\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "InitialETHCrowdfund", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "0", "ConstructorArguments": "0000000000000000000000001ca20040ce6ad406bc2a6c89976388829e7fbade", "EVMVersion": "shanghai", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}