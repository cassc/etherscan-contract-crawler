{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AnnuitCoeptis.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at Etherscan.io on 2024-01-24\\n*/\\n/*\\n    tg: https://t.me/AnnuitErc\\n    Twitter: https://twitter.com/annuiterc\\n    Web: https://a-c.cash/\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC20.sol\\\";\\n\\ninterface IUniswapV2Factory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n}\\n\\ncontract AnnuitCoeptis is IERC20, Ownable {\\n    string public name;\\n    string public symbol; \\n    uint256 public decimals;\\n    uint256 public max_supply;\\n    uint256 public min_supply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => bool) public isExcludedFromFees;\\n    mapping(address => uint256) public  lastTXtime;\\n    mapping(address => uint256) private lastLT_TXtime;\\n    mapping(address => uint256) private lastST_TXtime;\\n    mapping(address => bool) private excludeFromMaxWallet;\\n    mapping(address => bool) public automatedMarketMakerPair;\\n    mapping(address => mapping(address => uint256)) private allowances;\\n    address[200] private airdropQualifiedAddresses;\\n    IUniswapV2Router02 public uniswap_router;\\n    address public uniswap_factory;\\n    address private treasuryAddr;\\n    address public airdropAddress;\\n    uint256 private _totalSupply;\\n    uint256 public maxWallet;\\n    uint256 public turn;\\n    uint256 public tx_n;\\n    uint256 private mint_pct;\\n    uint256 private burn_pct;\\n    uint256 public airdrop_pct;\\n    uint256 public treasury_pct;\\n    address public airdrop_address_toList;\\n    uint256 public airdropAddressCount;\\n    uint256 public minimum_for_airdrop;\\n    uint256 public onepct;\\n    uint256 public inactive_burn;\\n    uint256 public airdrop_threshold;\\n    uint256 private last_turnTime;\\n    uint256 private init_ceiling;\\n    uint256 private init_floor;\\n    uint256 public swapTokensAtAmount;\\n    bool private swapping;\\n    bool private limitsEnabled;\\n    bool public isBurning;\\n    bool public firstrun;\\n    bool private macro_contraction;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint256 _decimals,\\n        uint256 _supply,\\n        uint256 _min_supply,\\n        uint256 _max_supply\\n    ) Ownable(msg.sender) {\\n        uint256 init_supply = _supply * 10**_decimals;\\n        airdropAddress = msg.sender;\\n        treasuryAddr = msg.sender;\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n        balanceOf[msg.sender] = init_supply;\\n        lastTXtime[msg.sender] = block.timestamp;\\n        lastST_TXtime[msg.sender] = block.timestamp;\\n        lastLT_TXtime[msg.sender] = block.timestamp;\\n        _totalSupply = init_supply;\\n        min_supply = _min_supply * 10**_decimals;\\n        max_supply = _max_supply * 10**_decimals;\\n        init_ceiling = max_supply;\\n        init_floor = min_supply;\\n        macro_contraction = true;\\n        turn = 0;\\n        last_turnTime = block.timestamp;\\n        isBurning = true;\\n        limitsEnabled = true;\\n        tx_n = 0;\\n        uint256 deciCalc = 10**_decimals;\\n        mint_pct = (50 * deciCalc) / 10000;\\n        burn_pct = (50 * deciCalc) / 10000; \\n        airdrop_pct = (50 * deciCalc) / 10000; //0.0050\\n        treasury_pct = (350 * deciCalc) / 10000;\\n        inactive_burn = (5000 * deciCalc) / 10000; //0.5\\n        airdrop_threshold = (25 * deciCalc) / 10000; //0.0025\\n        onepct = (100 * deciCalc)/ 10000; //0.01\\n        swapTokensAtAmount = 66 * 10** _decimals;\\n\\n        airdropAddressCount = 1;\\n        firstrun = true;\\n        airdropQualifiedAddresses[0] = airdropAddress;\\n        airdrop_address_toList = airdropAddress;\\n        uniswap_router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n        uniswap_factory = uniswap_router.factory();\\n\\n        address _pair = IUniswapV2Factory(uniswap_factory).createPair(\\n            address(this),\\n            uniswap_router.WETH()\\n        );\\n\\n        automatedMarketMakerPair[_pair] = true;\\n        maxWallet = (_totalSupply * 2) / 100;\\n\\n        isExcludedFromFees[address(this)] = true;\\n\\n        emit Transfer(address(0), msg.sender, init_supply);\\n    }\\n\\n    function updateFees(uint256 _treasuryFee, uint256 _airdropFees) external onlyOwner {\\n        treasury_pct = (_treasuryFee * 10 ** decimals) / 10000;\\n        airdrop_pct = (_airdropFees * 10 ** decimals) / 10000;\\n    }\\n\\n    function _pctCalc_minusScale(uint256 _value, uint256 _pct) internal view returns (uint256) {\\n        return (_value * _pct) / 10**decimals;\\n    }\\n\\n    function totalSupply() external view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function allowance(address _owner, address _spender) external view virtual returns (uint256) {\\n        return allowances[_owner][_spender];\\n    }\\n\\n    function burnRate() external view returns (uint256) {\\n        return burn_pct;\\n    }\\n\\n    function mintRate() external view returns (uint256) {\\n        return mint_pct;\\n    }\\n\\n    function showAirdropThreshold() external view returns (uint256) {\\n        return airdrop_threshold;\\n    }\\n\\n    function showQualifiedAddresses() external view returns (address[200] memory) {\\n        return airdropQualifiedAddresses;\\n    }\\n\\n    function checkWhenLast_USER_Transaction(address _address) external view returns (uint256) {\\n        return lastTXtime[_address];\\n    }\\n\\n    function LAST_TX_LONGTERM_BURN_COUNTER(address _address) external view returns (uint256) {\\n        return lastLT_TXtime[_address];\\n    }\\n\\n    function LAST_TX_SHORTERM_BURN_COUNTER(address _address) external view returns (uint256) {\\n        return lastST_TXtime[_address];\\n    }\\n\\n    function lastTurnTime() external view returns (uint256) {\\n        return last_turnTime;\\n    }\\n\\n    function macroContraction() external view returns (bool) {\\n        return macro_contraction;\\n    }\\n\\n    function _rateadj() internal returns (bool) {\\n        if (isBurning) {\\n            burn_pct += burn_pct / 10;\\n            mint_pct += mint_pct / 10;\\n            airdrop_pct += airdrop_pct / 10;\\n            treasury_pct += treasury_pct / 10;\\n        } else {\\n            burn_pct -= burn_pct / 10;\\n            mint_pct += mint_pct / 10;\\n            airdrop_pct -= airdrop_pct / 10;\\n            treasury_pct -= treasury_pct / 10;\\n        }\\n\\n        if (burn_pct > onepct * 6) {\\n            burn_pct -= onepct * 2;\\n        }\\n\\n        if (mint_pct > onepct * 6) {\\n            mint_pct -= onepct * 2;\\n        }\\n\\n        if (airdrop_pct > onepct * 3) {\\n            airdrop_pct -= onepct;\\n        }\\n\\n        if (treasury_pct > onepct * 3) {\\n            treasury_pct -= onepct;\\n        }\\n\\n        if (burn_pct < onepct || mint_pct < onepct || airdrop_pct < onepct / 2) {\\n            uint256 deciCalc = 10**decimals;\\n            mint_pct = (50 * deciCalc)/ 10000;\\n            burn_pct = (50 * deciCalc)/ 10000;\\n            airdrop_pct = (50 * deciCalc)/ 10000; //0.0050\\n            treasury_pct = (350 * deciCalc)/ 10000;\\n        }\\n        return true;\\n    }\\n\\n    function _airdrop() internal returns (bool) {\\n        uint256 onepct_supply = _pctCalc_minusScale(balanceOf[airdropAddress], onepct);\\n        uint256 split = 0;\\n        if (balanceOf[airdropAddress] <= onepct_supply) {\\n            split = balanceOf[airdropAddress] / 250;\\n        } else if (balanceOf[airdropAddress] > onepct_supply * 2) {\\n            split = balanceOf[airdropAddress] / 180;\\n        } else {\\n            split = balanceOf[airdropAddress] / 220;\\n        }\\n\\n        if (balanceOf[airdropAddress] - split > 0) {\\n            balanceOf[airdropAddress] -= split;\\n            balanceOf[airdropQualifiedAddresses[airdropAddressCount]] += split;\\n            lastTXtime[airdropAddress] = block.timestamp;\\n            lastLT_TXtime[airdropAddress] = block.timestamp;\\n            lastST_TXtime[airdropAddress] = block.timestamp;\\n            emit Transfer(airdropAddress, airdropQualifiedAddresses[airdropAddressCount], split);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _mint(address _to, uint256 _value) internal returns (bool) {\\n        require(_to != address(0), \\\"Invalid address\\\");\\n        _totalSupply += _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(address(0), _to, _value);\\n        return true;\\n    }\\n\\n    function _macro_contraction_bounds() internal returns (bool) {\\n        if (isBurning) {\\n            min_supply = min_supply / 2;\\n        } else {\\n            max_supply = max_supply / 2;\\n        }\\n        return true;\\n    }\\n\\n    function _macro_expansion_bounds() internal returns (bool) {\\n        if (isBurning) {\\n            min_supply = min_supply * 2;\\n        } else {\\n            max_supply = max_supply * 2;\\n        }\\n        if (turn == 56) {\\n            max_supply = init_ceiling;\\n            min_supply = init_floor;\\n            turn = 0;\\n            macro_contraction = false;\\n        }\\n        return true;\\n    }\\n\\n    function _turn() internal returns (bool) {\\n        turn += 1;\\n        if (turn == 1 && !firstrun) {\\n            uint256 deciCalc = 10**decimals;\\n            mint_pct = (50 * deciCalc)/ 10000;\\n            mint_pct = (50 * deciCalc)/ 10000;\\n            airdrop_pct = (50 * deciCalc)/ 10000; //0.0050\\n            treasury_pct = (350 * deciCalc)/ 10000;\\n            macro_contraction = true;\\n        }\\n        if (turn >= 2 && turn <= 28) {\\n            _macro_contraction_bounds();\\n            macro_contraction = true;\\n            // handle mint supply scene\\n        } else if (turn >= 29 && turn <= 56) {\\n            _macro_expansion_bounds();\\n            macro_contraction = false;\\n            // handle mint supply scene\\n        }\\n        last_turnTime = block.timestamp;\\n        return true;\\n    }\\n\\n    function _burn(address _to, uint256 _value) internal returns (bool) {\\n        require(_to != address(0), \\\"Invalid address\\\");\\n        _totalSupply -= _value;\\n        balanceOf[_to] -= _value;\\n        emit Transfer(_to, address(0), _value);\\n        return true;\\n    }\\n    function isContract(address account) internal view returns (bool) { \\n        uint size; \\n        assembly { \\n            size := extcodesize(account) \\n        } \\n    return size > 0; \\n    } \\n    function burn_Inactive_Address(address _address) external returns (bool) {\\n        require(_address != address(0), \\\"Invalid address\\\");\\n        require(!isContract(_address), \\\"This is a contract address. Use the burn inactive contract function instead.\\\");\\n        require(_address != 0xd1927b0813A4413494C414b15fEDc05408c03b04, \\\"cannot burn staking contract\\\");\\n        uint256 inactive_bal = 0;\\n\\n        if (_address == airdropAddress) {\\n            require(block.timestamp > lastTXtime[_address] + 518400, \\\"Unable to burn, the airdrop address has been active for the last 7 days\\\");\\n            inactive_bal = _pctCalc_minusScale(balanceOf[_address], inactive_burn);\\n            _burn(_address, inactive_bal);\\n            lastTXtime[_address] = block.timestamp;\\n        } else {\\n            if (block.timestamp > lastST_TXtime[_address] + 259200) {\\n                inactive_bal = _pctCalc_minusScale(balanceOf[_address], inactive_burn);\\n                _burn(_address, inactive_bal);\\n                lastST_TXtime[_address] = block.timestamp;\\n            } \\n            else if (block.timestamp > lastLT_TXtime[_address] + 518400) {\\n                _burn(_address, balanceOf[_address]);\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n        function burn_Inactive_Contract(address _address) external returns (bool) {\\n        require(_address != address(0), \\\"Invalid address\\\");\\n        require(isContract(_address), \\\"Not a contract address.\\\");\\n        require(_address != address(uniswap_router), \\\"Invalid contract address\\\");\\n\\n        uint256 inactive_bal = 0;\\n\\n        if (block.timestamp > lastST_TXtime[_address] + 604800) {\\n            inactive_bal = _pctCalc_minusScale(balanceOf[_address], inactive_burn);\\n            _burn(_address, inactive_bal);\\n            lastST_TXtime[_address] = block.timestamp;\\n        } else if (block.timestamp > lastLT_TXtime[_address] + 1209600) {\\n            _burn(_address, balanceOf[_address]);\\n            lastLT_TXtime[_address] = block.timestamp;\\n        }\\n\\n        return true;\\n    }\\n\\n    function flashback(address[259] memory _list, uint256[259] memory _values) external onlyOwner returns (bool) {\\n        require(msg.sender != address(0), \\\"Invalid address\\\");\\n\\n        for (uint256 x = 0; x < 259; x++) {\\n            if (_list[x] != address(0)) {\\n                balanceOf[msg.sender] -= _values[x];\\n                balanceOf[_list[x]] += _values[x];\\n                lastTXtime[_list[x]] = block.timestamp;\\n                lastST_TXtime[_list[x]] = block.timestamp;\\n                lastLT_TXtime[_list[x]] = block.timestamp;\\n                emit Transfer(msg.sender, _list[x], _values[x]);\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function setisExcludedFromFees(address _address) external returns (bool) {\\n        require(_address != address(0), \\\"Invalid address\\\");\\n        require(_address == owner(), \\\"Not the owner\\\");\\n\\n        isExcludedFromFees[_address] = true;\\n        return true;\\n    }\\n\\n    function remisExcludedFromFees(address _address) external returns (bool) {\\n        require(_address != address(0), \\\"Invalid address\\\");\\n        require(_address == owner(), \\\"Not the owner\\\");\\n\\n        isExcludedFromFees[_address] = false;\\n        return true;\\n    }\\n\\n    function manager_burn(address _to, uint256 _value) external onlyOwner returns (bool) {\\n        require(_to != address(0), \\\"Invalid address\\\");\\n        require(msg.sender != address(0), \\\"Invalid address\\\");\\n\\n        _totalSupply -= _value;\\n        balanceOf[_to] -= _value;\\n        emit Transfer(_to, address(0), _value);\\n        return true;\\n    }\\n\\n    function setAirdropAddress(address _airdropAddress) external onlyOwner returns (bool) {\\n        require(msg.sender != address(0), \\\"Invalid address\\\");\\n        require(_airdropAddress != address(0), \\\"Invalid address\\\");\\n        require(msg.sender == airdropAddress, \\\"Not authorized\\\");\\n\\n        airdropAddress = _airdropAddress;\\n        return true;\\n    }\\n\\n    function setUniswapRouter(IUniswapV2Router02 _uniswapRouter) external onlyOwner returns (bool) {\\n        require(msg.sender != address(0), \\\"Invalid address\\\");\\n        require(address(_uniswapRouter) != address(0), \\\"Invalid address\\\");\\n\\n        uniswap_router = _uniswapRouter;\\n        return true;\\n    }\\n\\n    function airdropProcess(uint256 _amount, address _txorigin, address _sender, address _receiver) internal returns (bool) {\\n    minimum_for_airdrop = _pctCalc_minusScale(balanceOf[airdropAddress], airdrop_threshold);\\n    if (_amount >= minimum_for_airdrop && _txorigin != address(0)) {\\n            if (!isContract(_txorigin)) \\n            {\\n                airdrop_address_toList = _txorigin;\\n            } \\n            else \\n            {\\n                if (isContract(_sender)) {\\n                    airdrop_address_toList = _receiver;\\n                } else {\\n                    airdrop_address_toList = _sender;\\n                }\\n            }\\n\\n            if (firstrun) {\\n                if (airdropAddressCount < 199) {\\n                    airdropQualifiedAddresses[airdropAddressCount] = airdrop_address_toList;\\n                    airdropAddressCount += 1;\\n                } else if (airdropAddressCount == 199) {\\n                    firstrun = false;\\n                    airdropQualifiedAddresses[airdropAddressCount] = airdrop_address_toList;\\n                    airdropAddressCount = 0;\\n                    _airdrop();\\n                    airdropAddressCount += 1;\\n                }\\n            } else {\\n                if (airdropAddressCount < 199) {\\n                    _airdrop();\\n                    airdropQualifiedAddresses[airdropAddressCount] = airdrop_address_toList;\\n                    airdropAddressCount += 1;\\n                } else if (airdropAddressCount == 199) {\\n                    _airdrop();\\n                    airdropQualifiedAddresses[airdropAddressCount] = airdrop_address_toList;\\n                    airdropAddressCount = 0;\\n                }\\n            }\\n        \\n    }\\n    return true;\\n}\\n\\nfunction removeLimits() external onlyOwner {\\n    limitsEnabled = false;\\n}\\n\\nfunction transfer(address _to, uint256 _value) external returns(bool) {\\n    address _owner = msg.sender;\\n    _transfer(_owner, _to, _value);\\n    return true;\\n}\\n\\n    function setSwapTokensAtAmount(uint256 _amount) external onlyOwner {\\n        swapTokensAtAmount = _amount * 10 ** decimals;\\n    }\\n\\n\\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\\n        require(_value != 0, \\\"No zero value transfer allowed\\\");\\n        require(_to != address(0), \\\"Invalid Address\\\");\\n\\n        if(limitsEnabled) {\\n            if(_from != airdropAddress && _to != airdropAddress) {\\n                if(!swapping && automatedMarketMakerPair[_from] && !excludeFromMaxWallet[_to]) {\\n                    require(_value + balanceOf[_to] <= maxWallet,\\\"exceed max wallet\\\");\\n                }\\n            }\\n        }\\n\\n        uint256 contractTokenBalance = balanceOf[address(this)];\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if(canSwap && !swapping && !automatedMarketMakerPair[_from] && _from != address(this) && _to != address(this)) {\\n            swapping = true;\\n            swapTokensForEth(swapTokensAtAmount);\\n            swapping = false;\\n        }\\n        bool takeFee = !swapping;\\n\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (!automatedMarketMakerPair[_to] && !automatedMarketMakerPair[_from]) {\\n            takeFee = false;\\n        }\\n        if(takeFee) {\\n        \\n            if (block.timestamp > last_turnTime + 60) {\\n                if (_totalSupply >= max_supply) {\\n                    isBurning = true;\\n                    _turn();\\n                    if (!firstrun) {\\n                        uint256 turn_burn = _totalSupply - max_supply;\\n                        if (balanceOf[airdropAddress] - turn_burn * 2 > 0) {\\n                            _burn(airdropAddress, turn_burn * 2);\\n                        }\\n                    }\\n                } else if (_totalSupply <= min_supply) {\\n                    isBurning = false;\\n                    _turn();\\n                    uint256 turn_mint = min_supply - _totalSupply;\\n                    _mint(airdropAddress, turn_mint * 2);\\n                }\\n            }\\n\\n            if (airdropAddressCount == 0) {\\n                _rateadj();\\n            }\\n\\n            if (isBurning) {\\n                uint256 burn_amt = _pctCalc_minusScale(_value, burn_pct);\\n                uint256 airdrop_amt = _pctCalc_minusScale(_value, airdrop_pct);\\n                uint256 treasury_amt = _pctCalc_minusScale(_value, treasury_pct);\\n                uint256 tx_amt = _value - burn_amt - airdrop_amt - treasury_amt;\\n\\n                _burn(_from, burn_amt);\\n                balanceOf[_from] -= tx_amt;\\n                balanceOf[_to] += tx_amt;\\n                emit Transfer(_from, _to, tx_amt);\\n\\n                balanceOf[_from] -= treasury_amt;\\n                balanceOf[address(this)] += treasury_amt;\\n                emit Transfer(_from, address(this), treasury_amt);\\n\\n                balanceOf[_from] -= airdrop_amt;\\n                balanceOf[airdropAddress] += airdrop_amt;\\n                emit Transfer(_from, airdropAddress, airdrop_amt);\\n            } \\n            else if (!isBurning) {\\n                uint256 mint_amt = _pctCalc_minusScale(_value, mint_pct);\\n                uint256 airdrop_amt = _pctCalc_minusScale(_value, airdrop_pct);\\n                uint256 treasury_amt = _pctCalc_minusScale(_value, treasury_pct);\\n                uint256 tx_amt = _value - airdrop_amt - treasury_amt;\\n\\n                _mint(tx.origin, mint_amt);\\n                balanceOf[_from] -= tx_amt;\\n                balanceOf[_to] += tx_amt;\\n                emit Transfer(_from, _to, tx_amt);\\n\\n                balanceOf[_from] -= treasury_amt;\\n                balanceOf[address(this)] += treasury_amt;\\n                emit Transfer(_from, address(this), treasury_amt);\\n\\n                balanceOf[_from] -= airdrop_amt;\\n                balanceOf[airdropAddress] += airdrop_amt;\\n                emit Transfer(_from, airdropAddress, airdrop_amt);\\n            }\\n\\n        lastTXtime[tx.origin] = block.timestamp;\\n        lastTXtime[_from] = block.timestamp;\\n        lastTXtime[_to] = block.timestamp;\\n        lastLT_TXtime[tx.origin] = block.timestamp;\\n        lastLT_TXtime[_from] = block.timestamp;\\n        lastLT_TXtime[_to] = block.timestamp;\\n        lastST_TXtime[tx.origin] = block.timestamp;\\n        lastST_TXtime[_from] = block.timestamp;\\n        lastST_TXtime[_to] = block.timestamp;\\n        } else {\\n            _normalTransfer(_from, _to, _value);\\n        }\\n        tx_n += 1;\\n        airdropProcess(_value, tx.origin, _from, _to);\\n\\n        return true;\\n    }\\n\\n    function swapTokensForEth(uint256 _amount) public {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswap_router.WETH();\\n        _approve(address(this), address(uniswap_router), _amount);\\n        uniswap_router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            _amount,\\n            0,\\n            path,\\n            treasuryAddr,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _normalTransfer(address _from, address _to,uint256 _value) internal returns(bool) {\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool) {\\n        allowances[_from][msg.sender] -= _value;\\n        _transfer(_from, _to, _value);\\n        return true;\\n    } \\n\\n    function approve(address _spender, uint256 _value) external returns (bool) {\\n        address _owner = msg.sender;\\n        return _approve(_owner, _spender, _value);\\n    }\\n\\n    function _approve(address _owner, address _spender, uint256 _value) private returns(bool) {\\n        allowances[_owner][_spender] = _value;\\n        emit Approval(_owner, _spender, _value);\\n        return true;\\n    }\\n    receive() external payable {}\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_min_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_max_supply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"LAST_TX_LONGTERM_BURN_COUNTER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"LAST_TX_SHORTERM_BURN_COUNTER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropAddressCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdrop_address_toList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdrop_pct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdrop_threshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"burn_Inactive_Address\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"burn_Inactive_Contract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"checkWhenLast_USER_Transaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstrun\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[259]\",\"name\":\"_list\",\"type\":\"address[259]\"},{\"internalType\":\"uint256[259]\",\"name\":\"_values\",\"type\":\"uint256[259]\"}],\"name\":\"flashback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inactive_burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBurning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastTXtime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTurnTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"macroContraction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"manager_burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"min_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimum_for_airdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"onepct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"remisExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_airdropAddress\",\"type\":\"address\"}],\"name\":\"setAirdropAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"_uniswapRouter\",\"type\":\"address\"}],\"name\":\"setUniswapRouter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setisExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showAirdropThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"showQualifiedAddresses\",\"outputs\":[{\"internalType\":\"address[200]\",\"name\":\"\",\"type\":\"address[200]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"swapTokensForEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury_pct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"turn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tx_n\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap_factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap_router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_treasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_airdropFees\",\"type\":\"uint256\"}],\"name\":\"updateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AnnuitCoeptis", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000000000000000000000000000000082350000000000000000000000000000000000000000000000000000000000000d05000000000000000000000000000000000000000000000000000000000001046a000000000000000000000000000000000000000000000000000000000000000e416e6e75697420436f65707469730000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003415f430000000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}