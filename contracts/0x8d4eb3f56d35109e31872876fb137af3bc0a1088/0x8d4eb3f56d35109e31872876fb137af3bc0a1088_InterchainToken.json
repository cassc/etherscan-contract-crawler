{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@axelar-network/axelar-cgp-solidity/contracts/interfaces/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\ninterface IERC20Permit {\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function nonces(address account) external view returns (uint256);\\n\\n    function permit(\\n        address issuer,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    error InvalidAccount();\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IRolesBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IRolesBase Interface\\n * @notice IRolesBase is an interface that abstracts the implementation of a\\n * contract with role control internal functions.\\n */\\ninterface IRolesBase {\\n    error MissingRole(address account, uint8 role);\\n    error MissingAllRoles(address account, uint256 accountRoles);\\n    error MissingAnyOfRoles(address account, uint256 accountRoles);\\n\\n    error InvalidProposedRoles(address fromAccount, address toAccount, uint256 accountRoles);\\n\\n    event RolesProposed(address indexed fromAccount, address indexed toAccount, uint256 accountRoles);\\n    event RolesAdded(address indexed account, uint256 accountRoles);\\n    event RolesRemoved(address indexed account, uint256 accountRoles);\\n\\n    /**\\n     * @notice Checks if an account has a role.\\n     * @param account The address to check\\n     * @param role The role to check\\n     * @return True if the account has the role, false otherwise\\n     */\\n    function hasRole(address account, uint8 role) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/libs/AddressBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title AddressBytesUtils\\n * @dev This library provides utility functions to convert between `address` and `bytes`.\\n */\\nlibrary AddressBytes {\\n    error InvalidBytesLength(bytes bytesAddress);\\n\\n    /**\\n     * @dev Converts a bytes address to an address type.\\n     * @param bytesAddress The bytes representation of an address\\n     * @return addr The converted address\\n     */\\n    function toAddress(bytes memory bytesAddress) internal pure returns (address addr) {\\n        if (bytesAddress.length != 20) revert InvalidBytesLength(bytesAddress);\\n\\n        assembly {\\n            addr := mload(add(bytesAddress, 20))\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts an address to bytes.\\n     * @param addr The address to be converted\\n     * @return bytesAddress The bytes representation of the address\\n     */\\n    function toBytes(address addr) internal pure returns (bytes memory bytesAddress) {\\n        bytesAddress = new bytes(20);\\n        // we can test if using a single 32 byte variable that is the address with the length together and using one mstore would be slightly cheaper.\\n        assembly {\\n            mstore(add(bytesAddress, 20), addr)\\n            mstore(bytesAddress, 20)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@axelar-network/axelar-gmp-sdk-solidity/contracts/utils/RolesBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IRolesBase } from '../interfaces/IRolesBase.sol';\\n\\n/**\\n * @title RolesBase\\n * @notice A contract module which provides a set if internal functions\\n * for implementing role control features.\\n */\\ncontract RolesBase is IRolesBase {\\n    bytes32 internal constant ROLES_PREFIX = keccak256('roles');\\n    bytes32 internal constant PROPOSE_ROLES_PREFIX = keccak256('propose-roles');\\n\\n    /**\\n     * @notice Modifier that throws an error if called by any account missing the role.\\n     */\\n    modifier onlyRole(uint8 role) {\\n        if (!_hasRole(_getRoles(msg.sender), role)) revert MissingRole(msg.sender, role);\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Modifier that throws an error if called by an account without all the roles.\\n     */\\n    modifier withEveryRole(uint8[] memory roles) {\\n        uint256 accountRoles = _toAccountRoles(roles);\\n        if (!_hasAllTheRoles(_getRoles(msg.sender), accountRoles)) revert MissingAllRoles(msg.sender, accountRoles);\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Modifier that throws an error if called by an account without any of the roles.\\n     */\\n    modifier withAnyRole(uint8[] memory roles) {\\n        uint256 accountRoles = _toAccountRoles(roles);\\n        if (!_hasAnyOfRoles(_getRoles(msg.sender), accountRoles)) revert MissingAnyOfRoles(msg.sender, accountRoles);\\n\\n        _;\\n    }\\n\\n    /**\\n     * @notice Checks if an account has a role.\\n     * @param account The address to check\\n     * @param role The role to check\\n     * @return True if the account has the role, false otherwise\\n     */\\n    function hasRole(address account, uint8 role) public view returns (bool) {\\n        return _hasRole(_getRoles(account), role);\\n    }\\n\\n    /**\\n     * @notice Internal function to convert an array of roles to a uint256.\\n     * @param roles The roles to convert\\n     * @return accountRoles The roles in uint256 format\\n     */\\n    function _toAccountRoles(uint8[] memory roles) internal pure returns (uint256) {\\n        uint256 length = roles.length;\\n        uint256 accountRoles;\\n\\n        for (uint256 i = 0; i < length; ++i) {\\n            accountRoles |= (1 << roles[i]);\\n        }\\n\\n        return accountRoles;\\n    }\\n\\n    /**\\n     * @notice Internal function to get the key of the roles mapping.\\n     * @param account The address to get the key for\\n     * @return key The key of the roles mapping\\n     */\\n    function _rolesKey(address account) internal view virtual returns (bytes32 key) {\\n        return keccak256(abi.encodePacked(ROLES_PREFIX, account));\\n    }\\n\\n    /**\\n     * @notice Internal function to get the roles of an account.\\n     * @param account The address to get the roles for\\n     * @return accountRoles The roles of the account in uint256 format\\n     */\\n    function _getRoles(address account) internal view returns (uint256 accountRoles) {\\n        bytes32 key = _rolesKey(account);\\n        assembly {\\n            accountRoles := sload(key)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to set the roles of an account.\\n     * @param account The address to set the roles for\\n     * @param accountRoles The roles to set\\n     */\\n    function _setRoles(address account, uint256 accountRoles) private {\\n        bytes32 key = _rolesKey(account);\\n        assembly {\\n            sstore(key, accountRoles)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to get the key of the proposed roles mapping.\\n     * @param fromAccount The address of the current role\\n     * @param toAccount The address of the pending role\\n     * @return key The key of the proposed roles mapping\\n     */\\n    function _proposalKey(address fromAccount, address toAccount) internal view virtual returns (bytes32 key) {\\n        return keccak256(abi.encodePacked(PROPOSE_ROLES_PREFIX, fromAccount, toAccount));\\n    }\\n\\n    /**\\n     * @notice Internal function to get the proposed roles of an account.\\n     * @param fromAccount The address of the current role\\n     * @param toAccount The address of the pending role\\n     * @return proposedRoles_ The proposed roles of the account in uint256 format\\n     */\\n    function _getProposedRoles(address fromAccount, address toAccount) internal view returns (uint256 proposedRoles_) {\\n        bytes32 key = _proposalKey(fromAccount, toAccount);\\n        assembly {\\n            proposedRoles_ := sload(key)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to set the proposed roles of an account.\\n     * @param fromAccount The address of the current role\\n     * @param toAccount The address of the pending role\\n     * @param proposedRoles_ The proposed roles to set in uint256 format\\n     */\\n    function _setProposedRoles(\\n        address fromAccount,\\n        address toAccount,\\n        uint256 proposedRoles_\\n    ) private {\\n        bytes32 key = _proposalKey(fromAccount, toAccount);\\n        assembly {\\n            sstore(key, proposedRoles_)\\n        }\\n    }\\n\\n    /**\\n     * @notice Internal function to add a role to an account.\\n     * @dev emits a RolesAdded event.\\n     * @param account The address to add the role to\\n     * @param role The role to add\\n     */\\n    function _addRole(address account, uint8 role) internal {\\n        _addAccountRoles(account, 1 << role);\\n    }\\n\\n    /**\\n     * @notice Internal function to add roles to an account.\\n     * @dev emits a RolesAdded event.\\n     * @dev Called in the constructor to set the initial roles.\\n     * @param account The address to add roles to\\n     * @param roles The roles to add\\n     */\\n    function _addRoles(address account, uint8[] memory roles) internal {\\n        _addAccountRoles(account, _toAccountRoles(roles));\\n    }\\n\\n    /**\\n     * @notice Internal function to add roles to an account.\\n     * @dev emits a RolesAdded event.\\n     * @dev Called in the constructor to set the initial roles.\\n     * @param account The address to add roles to\\n     * @param accountRoles The roles to add\\n     */\\n    function _addAccountRoles(address account, uint256 accountRoles) internal {\\n        uint256 newAccountRoles = _getRoles(account) | accountRoles;\\n\\n        _setRoles(account, newAccountRoles);\\n\\n        emit RolesAdded(account, accountRoles);\\n    }\\n\\n    /**\\n     * @notice Internal function to remove a role from an account.\\n     * @dev emits a RolesRemoved event.\\n     * @param account The address to remove the role from\\n     * @param role The role to remove\\n     */\\n    function _removeRole(address account, uint8 role) internal {\\n        _removeAccountRoles(account, 1 << role);\\n    }\\n\\n    /**\\n     * @notice Internal function to remove roles from an account.\\n     * @dev emits a RolesRemoved event.\\n     * @param account The address to remove roles from\\n     * @param roles The roles to remove\\n     */\\n    function _removeRoles(address account, uint8[] memory roles) internal {\\n        _removeAccountRoles(account, _toAccountRoles(roles));\\n    }\\n\\n    /**\\n     * @notice Internal function to remove roles from an account.\\n     * @dev emits a RolesRemoved event.\\n     * @param account The address to remove roles from\\n     * @param accountRoles The roles to remove\\n     */\\n    function _removeAccountRoles(address account, uint256 accountRoles) internal {\\n        uint256 newAccountRoles = _getRoles(account) & ~accountRoles;\\n\\n        _setRoles(account, newAccountRoles);\\n\\n        emit RolesRemoved(account, accountRoles);\\n    }\\n\\n    /**\\n     * @notice Internal function to check if an account has a role.\\n     * @param accountRoles The roles of the account in uint256 format\\n     * @param role The role to check\\n     * @return True if the account has the role, false otherwise\\n     */\\n    function _hasRole(uint256 accountRoles, uint8 role) internal pure returns (bool) {\\n        return accountRoles & (1 << role) != 0;\\n    }\\n\\n    /**\\n     * @notice Internal function to check if an account has all the roles.\\n     * @param hasAccountRoles The roles of the account in uint256 format\\n     * @param mustHaveAccountRoles The roles the account must have\\n     * @return True if the account has all the roles, false otherwise\\n     */\\n    function _hasAllTheRoles(uint256 hasAccountRoles, uint256 mustHaveAccountRoles) internal pure returns (bool) {\\n        return (hasAccountRoles & mustHaveAccountRoles) == mustHaveAccountRoles;\\n    }\\n\\n    /**\\n     * @notice Internal function to check if an account has any of the roles.\\n     * @param hasAccountRoles The roles of the account in uint256 format\\n     * @param mustHaveAnyAccountRoles The roles to check in uint256 format\\n     * @return True if the account has any of the roles, false otherwise\\n     */\\n    function _hasAnyOfRoles(uint256 hasAccountRoles, uint256 mustHaveAnyAccountRoles) internal pure returns (bool) {\\n        return (hasAccountRoles & mustHaveAnyAccountRoles) != 0;\\n    }\\n\\n    /**\\n     * @notice Internal function to propose to transfer roles of message sender to a new account.\\n     * @dev Original account must have all the proposed roles.\\n     * @dev Emits a RolesProposed event.\\n     * @dev Roles are not transferred until the new role accepts the role transfer.\\n     * @param fromAccount The address of the current roles\\n     * @param toAccount The address to transfer roles to\\n     * @param role The role to transfer\\n     */\\n    function _proposeRole(\\n        address fromAccount,\\n        address toAccount,\\n        uint8 role\\n    ) internal {\\n        _proposeAccountRoles(fromAccount, toAccount, 1 << role);\\n    }\\n\\n    /**\\n     * @notice Internal function to propose to transfer roles of message sender to a new account.\\n     * @dev Original account must have all the proposed roles.\\n     * @dev Emits a RolesProposed event.\\n     * @dev Roles are not transferred until the new role accepts the role transfer.\\n     * @param fromAccount The address of the current roles\\n     * @param toAccount The address to transfer roles to\\n     * @param roles The roles to transfer\\n     */\\n    function _proposeRoles(\\n        address fromAccount,\\n        address toAccount,\\n        uint8[] memory roles\\n    ) internal {\\n        _proposeAccountRoles(fromAccount, toAccount, _toAccountRoles(roles));\\n    }\\n\\n    /**\\n     * @notice Internal function to propose to transfer roles of message sender to a new account.\\n     * @dev Original account must have all the proposed roles.\\n     * @dev Emits a RolesProposed event.\\n     * @dev Roles are not transferred until the new role accepts the role transfer.\\n     * @param fromAccount The address of the current roles\\n     * @param toAccount The address to transfer roles to\\n     * @param accountRoles The account roles to transfer\\n     */\\n    function _proposeAccountRoles(\\n        address fromAccount,\\n        address toAccount,\\n        uint256 accountRoles\\n    ) internal {\\n        if (!_hasAllTheRoles(_getRoles(fromAccount), accountRoles)) revert MissingAllRoles(fromAccount, accountRoles);\\n\\n        _setProposedRoles(fromAccount, toAccount, accountRoles);\\n\\n        emit RolesProposed(fromAccount, toAccount, accountRoles);\\n    }\\n\\n    /**\\n     * @notice Internal function to accept roles transferred from another account.\\n     * @dev Pending account needs to pass all the proposed roles.\\n     * @dev Emits RolesRemoved and RolesAdded events.\\n     * @param fromAccount The address of the current role\\n     * @param role The role to accept\\n     */\\n    function _acceptRole(\\n        address fromAccount,\\n        address toAccount,\\n        uint8 role\\n    ) internal virtual {\\n        _acceptAccountRoles(fromAccount, toAccount, 1 << role);\\n    }\\n\\n    /**\\n     * @notice Internal function to accept roles transferred from another account.\\n     * @dev Pending account needs to pass all the proposed roles.\\n     * @dev Emits RolesRemoved and RolesAdded events.\\n     * @param fromAccount The address of the current role\\n     * @param roles The roles to accept\\n     */\\n    function _acceptRoles(\\n        address fromAccount,\\n        address toAccount,\\n        uint8[] memory roles\\n    ) internal virtual {\\n        _acceptAccountRoles(fromAccount, toAccount, _toAccountRoles(roles));\\n    }\\n\\n    /**\\n     * @notice Internal function to accept roles transferred from another account.\\n     * @dev Pending account needs to pass all the proposed roles.\\n     * @dev Emits RolesRemoved and RolesAdded events.\\n     * @param fromAccount The address of the current role\\n     * @param accountRoles The account roles to accept\\n     */\\n    function _acceptAccountRoles(\\n        address fromAccount,\\n        address toAccount,\\n        uint256 accountRoles\\n    ) internal virtual {\\n        if (_getProposedRoles(fromAccount, toAccount) != accountRoles) {\\n            revert InvalidProposedRoles(fromAccount, toAccount, accountRoles);\\n        }\\n\\n        _setProposedRoles(fromAccount, toAccount, 0);\\n        _transferAccountRoles(fromAccount, toAccount, accountRoles);\\n    }\\n\\n    /**\\n     * @notice Internal function to transfer roles from one account to another.\\n     * @dev Original account must have all the proposed roles.\\n     * @param fromAccount The address of the current role\\n     * @param toAccount The address to transfer role to\\n     * @param role The role to transfer\\n     */\\n    function _transferRole(\\n        address fromAccount,\\n        address toAccount,\\n        uint8 role\\n    ) internal {\\n        _transferAccountRoles(fromAccount, toAccount, 1 << role);\\n    }\\n\\n    /**\\n     * @notice Internal function to transfer roles from one account to another.\\n     * @dev Original account must have all the proposed roles.\\n     * @param fromAccount The address of the current role\\n     * @param toAccount The address to transfer role to\\n     * @param roles The roles to transfer\\n     */\\n    function _transferRoles(\\n        address fromAccount,\\n        address toAccount,\\n        uint8[] memory roles\\n    ) internal {\\n        _transferAccountRoles(fromAccount, toAccount, _toAccountRoles(roles));\\n    }\\n\\n    /**\\n     * @notice Internal function to transfer roles from one account to another.\\n     * @dev Original account must have all the proposed roles.\\n     * @param fromAccount The address of the current role\\n     * @param toAccount The address to transfer role to\\n     * @param accountRoles The account roles to transfer\\n     */\\n    function _transferAccountRoles(\\n        address fromAccount,\\n        address toAccount,\\n        uint256 accountRoles\\n    ) internal {\\n        if (!_hasAllTheRoles(_getRoles(fromAccount), accountRoles)) revert MissingAllRoles(fromAccount, accountRoles);\\n\\n        _removeAccountRoles(fromAccount, accountRoles);\\n        _addAccountRoles(toAccount, accountRoles);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interchain-token/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol';\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is IERC20 {\\n    mapping(address => uint256) public override balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    uint256 public override totalSupply;\\n    uint256 internal constant UINT256_MAX = type(uint256).max;\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\\n        uint256 _allowance = allowance[sender][msg.sender];\\n\\n        if (_allowance != UINT256_MAX) {\\n            _approve(sender, msg.sender, _allowance - amount);\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender] - subtractedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        if (sender == address(0) || recipient == address(0)) revert InvalidAccount();\\n\\n        balanceOf[sender] -= amount;\\n        balanceOf[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        if (account == address(0)) revert InvalidAccount();\\n\\n        totalSupply += amount;\\n        balanceOf[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        if (account == address(0)) revert InvalidAccount();\\n\\n        balanceOf[account] -= amount;\\n        totalSupply -= amount;\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        if (owner == address(0) || spender == address(0)) revert InvalidAccount();\\n\\n        allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interchain-token/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol';\\nimport { IERC20Permit } from '@axelar-network/axelar-cgp-solidity/contracts/interfaces/IERC20Permit.sol';\\n\\nimport { ERC20 } from './ERC20.sol';\\n\\n/**\\n * @title ERC20Permit Contract\\n * @dev Extension of ERC20 to include permit functionality (EIP-2612).\\n * Allows for approval of ERC20 tokens by signature rather than transaction.\\n */\\nabstract contract ERC20Permit is IERC20, IERC20Permit, ERC20 {\\n    error PermitExpired();\\n    error InvalidS();\\n    error InvalidV();\\n    error InvalidSignature();\\n\\n    /**\\n     * @dev Represents hash of the EIP-712 Domain Separator.\\n     */\\n    bytes32 public nameHash;\\n\\n    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = '\\\\x19\\\\x01';\\n\\n    // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\\n    bytes32 private constant DOMAIN_TYPE_SIGNATURE_HASH = bytes32(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f);\\n\\n    // keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)')\\n    bytes32 private constant PERMIT_SIGNATURE_HASH = bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9);\\n\\n    /**\\n     * @dev Mapping of nonces for each address.\\n     */\\n    mapping(address => uint256) public nonces;\\n\\n    /**\\n     * @notice Internal function to set the token name hash\\n     * @param name The token name\\n     */\\n    function _setNameHash(string memory name) internal {\\n        nameHash = keccak256(bytes(name));\\n    }\\n\\n    /**\\n     * @notice Calculates the domain separator.\\n     * @dev This is not cached because chainid can change on chain forks.\\n     */\\n    // solhint-disable func-name-mixedcase\\n    // slither-disable-next-line naming-convention\\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\\n        return keccak256(abi.encode(DOMAIN_TYPE_SIGNATURE_HASH, nameHash, keccak256(bytes('1')), block.chainid, address(this)));\\n    }\\n\\n    // solhint-enable func-name-mixedcase\\n\\n    /**\\n     * @notice Permit the designated spender to spend the holder's tokens\\n     * @dev The permit function is used to allow a holder to designate a spender\\n     * to spend tokens on their behalf via a signed message.\\n     * @param issuer The address of the token holder\\n     * @param spender The address of the designated spender\\n     * @param value The number of tokens to be spent\\n     * @param deadline The time at which the permission to spend expires\\n     * @param v The recovery id of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function permit(address issuer, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\\n        if (block.timestamp > deadline) revert PermitExpired();\\n\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) revert InvalidS();\\n\\n        if (v != 27 && v != 28) revert InvalidV();\\n\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\\n                DOMAIN_SEPARATOR(),\\n                keccak256(abi.encode(PERMIT_SIGNATURE_HASH, issuer, spender, value, nonces[issuer]++, deadline))\\n            )\\n        );\\n\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n        if (recoveredAddress != issuer) revert InvalidSignature();\\n\\n        // _approve will revert if issuer is address(0x0)\\n        _approve(issuer, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interchain-token/InterchainToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressBytes } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/libs/AddressBytes.sol';\\n\\nimport { IInterchainToken } from '../interfaces/IInterchainToken.sol';\\n\\nimport { InterchainTokenStandard } from './InterchainTokenStandard.sol';\\nimport { ERC20 } from './ERC20.sol';\\nimport { ERC20Permit } from './ERC20Permit.sol';\\nimport { Minter } from '../utils/Minter.sol';\\n\\n/**\\n * @title InterchainToken\\n * @notice This contract implements an interchain token which extends InterchainToken functionality.\\n * @dev This contract also inherits Minter and Implementation logic.\\n */\\ncontract InterchainToken is InterchainTokenStandard, ERC20, ERC20Permit, Minter, IInterchainToken {\\n    using AddressBytes for bytes;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n    bytes32 internal tokenId;\\n    address internal immutable interchainTokenService_;\\n\\n    // bytes32(uint256(keccak256('interchain-token-initialized')) - 1);\\n    bytes32 internal constant INITIALIZED_SLOT = 0xc778385ecb3e8cecb82223fa1f343ec6865b2d64c65b0c15c7e8aef225d9e214;\\n\\n    /**\\n     * @notice Constructs the InterchainToken contract.\\n     * @dev Makes the implementation act as if it has been setup already to disallow calls to init() (even though that would not achieve anything really).\\n     */\\n    constructor(address interchainTokenServiceAddress) {\\n        _initialize();\\n\\n        if (interchainTokenServiceAddress == address(0)) revert InterchainTokenServiceAddressZero();\\n\\n        interchainTokenService_ = interchainTokenServiceAddress;\\n    }\\n\\n    /**\\n     * @notice Returns true if the contract has been setup.\\n     * @return initialized True if the contract has been setup, false otherwise.\\n     */\\n    function _isInitialized() internal view returns (bool initialized) {\\n        assembly {\\n            initialized := sload(INITIALIZED_SLOT)\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets initialized to true, to allow only a single init.\\n     */\\n    function _initialize() internal {\\n        assembly {\\n            sstore(INITIALIZED_SLOT, true)\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the interchain token service\\n     * @return address The interchain token service contract\\n     */\\n    function interchainTokenService() public view override(InterchainTokenStandard, IInterchainToken) returns (address) {\\n        return interchainTokenService_;\\n    }\\n\\n    /**\\n     * @notice Returns the tokenId for this token.\\n     * @return bytes32 The token manager contract.\\n     */\\n    function interchainTokenId() public view override(InterchainTokenStandard, IInterchainToken) returns (bytes32) {\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @notice Setup function to initialize contract parameters.\\n     * @param tokenId_ The tokenId of the token.\\n     * @param minter The address of the token minter.\\n     * @param tokenName The name of the token.\\n     * @param tokenSymbol The symbopl of the token.\\n     * @param tokenDecimals The decimals of the token.\\n     */\\n    function init(bytes32 tokenId_, address minter, string calldata tokenName, string calldata tokenSymbol, uint8 tokenDecimals) external {\\n        if (_isInitialized()) revert AlreadyInitialized();\\n\\n        _initialize();\\n\\n        if (tokenId_ == bytes32(0)) revert TokenIdZero();\\n        if (bytes(tokenName).length == 0) revert TokenNameEmpty();\\n        if (bytes(tokenSymbol).length == 0) revert TokenSymbolEmpty();\\n\\n        name = tokenName;\\n        symbol = tokenSymbol;\\n        decimals = tokenDecimals;\\n        tokenId = tokenId_;\\n\\n        /**\\n         * @dev Set the token service as a minter to allow it to mint and burn tokens.\\n         * Also add the provided address as a minter. If `address(0)` was provided,\\n         * add it as a minter to allow anyone to easily check that no custom minter was set.\\n         */\\n        _addMinter(interchainTokenService_);\\n        _addMinter(minter);\\n\\n        _setNameHash(tokenName);\\n    }\\n\\n    /**\\n     * @notice Function to mint new tokens.\\n     * @dev Can only be called by the minter address.\\n     * @param account The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to mint.\\n     */\\n    function mint(address account, uint256 amount) external onlyRole(uint8(Roles.MINTER)) {\\n        _mint(account, amount);\\n    }\\n\\n    /**\\n     * @notice Function to burn tokens.\\n     * @dev Can only be called by the minter address.\\n     * @param account The address that will have its tokens burnt.\\n     * @param amount The amount of tokens to burn.\\n     */\\n    function burn(address account, uint256 amount) external onlyRole(uint8(Roles.MINTER)) {\\n        _burn(account, amount);\\n    }\\n\\n    /**\\n     * @notice A method to be overwritten that will decrease the allowance of the `spender` from `sender` by `amount`.\\n     * @dev Needs to be overwritten. This provides flexibility for the choice of ERC20 implementation used. Must revert if allowance is not sufficient.\\n     */\\n    function _spendAllowance(address sender, address spender, uint256 amount) internal override {\\n        uint256 _allowance = allowance[sender][spender];\\n\\n        if (_allowance != UINT256_MAX) {\\n            _approve(sender, spender, _allowance - amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interchain-token/InterchainTokenStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IInterchainTokenStandard } from '../interfaces/IInterchainTokenStandard.sol';\\nimport { ITransmitInterchainToken } from '../interfaces/ITransmitInterchainToken.sol';\\n\\n/**\\n * @title An example implementation of the IInterchainTokenStandard.\\n * @notice The is an abstract contract that needs to be extended with an ERC20 implementation. See `InterchainToken` for an example implementation.\\n */\\nabstract contract InterchainTokenStandard is IInterchainTokenStandard {\\n    /**\\n     * @notice Getter for the tokenId used for this token.\\n     * @dev Needs to be overwritten.\\n     * @return tokenId_ The tokenId that this token is registerred under.\\n     */\\n    function interchainTokenId() public view virtual returns (bytes32 tokenId_);\\n\\n    /**\\n     * @notice Getter for the interchain token service.\\n     * @dev Needs to be overwritten.\\n     * @return service The address of the interchain token service.\\n     */\\n    function interchainTokenService() public view virtual returns (address service);\\n\\n    /**\\n     * @notice Implementation of the interchainTransfer method\\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or if no data is passed, just do a transfer.\\n     * A different implementation could use metadata to specify a function to invoke, or for other purposes as well.\\n     * @param destinationChain The destination chain identifier.\\n     * @param recipient The bytes representation of the address of the recipient.\\n     * @param amount The amount of token to be transferred.\\n     * @param metadata Either empty, just to facilitate an interchain transfer, or the data to be passed for an interchain contract call with transfer\\n     * as per semantics defined by the token service.\\n     */\\n    function interchainTransfer(\\n        string calldata destinationChain,\\n        bytes calldata recipient,\\n        uint256 amount,\\n        bytes calldata metadata\\n    ) external payable {\\n        address sender = msg.sender;\\n\\n        _beforeInterchainTransfer(msg.sender, destinationChain, recipient, amount, metadata);\\n\\n        ITransmitInterchainToken(interchainTokenService()).transmitInterchainTransfer{ value: msg.value }(\\n            interchainTokenId(),\\n            sender,\\n            destinationChain,\\n            recipient,\\n            amount,\\n            metadata\\n        );\\n    }\\n\\n    /**\\n     * @notice Implementation of the interchainTransferFrom method\\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or, if no data is passed, just do a transfer.\\n     * A different implementation could use metadata to specify a function to invoke, or for other purposes as well.\\n     * @param sender The sender of the tokens. They need to have approved `msg.sender` before this is called.\\n     * @param destinationChain The string representation of the destination chain.\\n     * @param recipient The bytes representation of the address of the recipient.\\n     * @param amount The amount of token to be transferred.\\n     * @param metadata Either empty, just to facilitate an interchain transfer, or the data to be passed to an interchain contract call and transfer.\\n     */\\n    function interchainTransferFrom(\\n        address sender,\\n        string calldata destinationChain,\\n        bytes calldata recipient,\\n        uint256 amount,\\n        bytes calldata metadata\\n    ) external payable {\\n        _spendAllowance(sender, msg.sender, amount);\\n\\n        _beforeInterchainTransfer(sender, destinationChain, recipient, amount, metadata);\\n\\n        ITransmitInterchainToken(interchainTokenService()).transmitInterchainTransfer{ value: msg.value }(\\n            interchainTokenId(),\\n            sender,\\n            destinationChain,\\n            recipient,\\n            amount,\\n            metadata\\n        );\\n    }\\n\\n    /**\\n     * @notice A method to be overwritten that will be called before an interchain transfer. One can approve the tokenManager here if needed,\\n     * to allow users for a 1-call transfer in case of a lock-unlock token manager.\\n     * @param from The sender of the tokens. They need to have approved `msg.sender` before this is called.\\n     * @param destinationChain The string representation of the destination chain.\\n     * @param destinationAddress The bytes representation of the address of the recipient.\\n     * @param amount The amount of token to be transferred.\\n     * @param metadata Either empty, just to facilitate an interchain transfer, or the data to be passed to an interchain contract call and transfer.\\n     */\\n    function _beforeInterchainTransfer(\\n        address from,\\n        string calldata destinationChain,\\n        bytes calldata destinationAddress,\\n        uint256 amount,\\n        bytes calldata metadata\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice A method to be overwritten that will decrease the allowance of the `spender` from `sender` by `amount`.\\n     * @dev Needs to be overwritten. This provides flexibility for the choice of ERC20 implementation used. Must revert if allowance is not sufficient.\\n     */\\n    function _spendAllowance(address sender, address spender, uint256 amount) internal virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20MintableBurnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IERC20MintableBurnable Interface\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20MintableBurnable {\\n    /**\\n     * @notice Function to mint new tokens.\\n     * @dev Can only be called by the minter address.\\n     * @param to The address that will receive the minted tokens.\\n     * @param amount The amount of tokens to mint.\\n     */\\n    function mint(address to, uint256 amount) external;\\n\\n    /**\\n     * @notice Function to burn tokens.\\n     * @dev Can only be called by the minter address.\\n     * @param from The address that will have its tokens burnt.\\n     * @param amount The amount of tokens to burn.\\n     */\\n    function burn(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Named.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IERC20.sol';\\n\\n/**\\n * @title IERC20Named Interface\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Named is IERC20 {\\n    /**\\n     * @notice Getter for the name of the token.\\n     * @return string Name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice Getter for the symbol of the token.\\n     * @return string The symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice Getter for the decimals of the token.\\n     * @return uint8 The decimals of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterchainToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IInterchainTokenStandard } from './IInterchainTokenStandard.sol';\\nimport { IMinter } from './IMinter.sol';\\nimport { IERC20MintableBurnable } from './IERC20MintableBurnable.sol';\\nimport { IERC20Named } from './IERC20Named.sol';\\n\\n/**\\n * @title IInterchainToken interface\\n * @dev Extends IInterchainTokenStandard and IMinter.\\n */\\ninterface IInterchainToken is IInterchainTokenStandard, IMinter, IERC20MintableBurnable, IERC20Named {\\n    error InterchainTokenServiceAddressZero();\\n    error TokenIdZero();\\n    error TokenNameEmpty();\\n    error TokenSymbolEmpty();\\n    error AlreadyInitialized();\\n\\n    /**\\n     * @notice Getter for the interchain token service contract.\\n     * @dev Needs to be overwitten.\\n     * @return interchainTokenServiceAddress The interchain token service address.\\n     */\\n    function interchainTokenService() external view returns (address interchainTokenServiceAddress);\\n\\n    /**\\n     * @notice Getter for the tokenId used for this token.\\n     * @dev Needs to be overwitten.\\n     * @return tokenId_ The tokenId for this token.\\n     */\\n    function interchainTokenId() external view returns (bytes32 tokenId_);\\n\\n    /**\\n     * @notice Setup function to initialize contract parameters.\\n     * @param tokenId_ The tokenId of the token.\\n     * @param minter The address of the token minter.\\n     * @param tokenName The name of the token.\\n     * @param tokenSymbol The symbopl of the token.\\n     * @param tokenDecimals The decimals of the token.\\n     */\\n    function init(bytes32 tokenId_, address minter, string calldata tokenName, string calldata tokenSymbol, uint8 tokenDecimals) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterchainTokenStandard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IInterchainTokenStandard interface\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IInterchainTokenStandard {\\n    /**\\n     * @notice Implementation of the interchainTransfer method.\\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or if no data is passed, just do a transfer.\\n     * A different implementation could use metadata to specify a function to invoke, or for other purposes as well.\\n     * @param destinationChain The destination chain identifier.\\n     * @param recipient The bytes representation of the address of the recipient.\\n     * @param amount The amount of token to be transferred.\\n     * @param metadata Optional metadata for the call for additional effects (such as calling a destination contract).\\n     */\\n    function interchainTransfer(\\n        string calldata destinationChain,\\n        bytes calldata recipient,\\n        uint256 amount,\\n        bytes calldata metadata\\n    ) external payable;\\n\\n    /**\\n     * @notice Implementation of the interchainTransferFrom method\\n     * @dev We chose to either pass `metadata` as raw data on a remote contract call, or, if no data is passed, just do a transfer.\\n     * A different implementation could use metadata to specify a function to invoke, or for other purposes as well.\\n     * @param sender The sender of the tokens. They need to have approved `msg.sender` before this is called.\\n     * @param destinationChain The string representation of the destination chain.\\n     * @param recipient The bytes representation of the address of the recipient.\\n     * @param amount The amount of token to be transferred.\\n     * @param metadata Optional metadata for the call for additional effects (such as calling a destination contract.)\\n     */\\n    function interchainTransferFrom(\\n        address sender,\\n        string calldata destinationChain,\\n        bytes calldata recipient,\\n        uint256 amount,\\n        bytes calldata metadata\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IRolesBase } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/interfaces/IRolesBase.sol';\\n\\n/**\\n * @title IMinter Interface\\n * @notice An interface for a contract module which provides a basic access control mechanism, where\\n * there is an account (a minter) that can be granted exclusive access to specific functions.\\n */\\ninterface IMinter is IRolesBase {\\n    /**\\n     * @notice Change the minter of the contract.\\n     * @dev Can only be called by the current minter.\\n     * @param minter_ The address of the new minter.\\n     */\\n    function transferMintership(address minter_) external;\\n\\n    /**\\n     * @notice Proposed a change of the minter of the contract.\\n     * @dev Can only be called by the current minter.\\n     * @param minter_ The address of the new minter.\\n     */\\n    function proposeMintership(address minter_) external;\\n\\n    /**\\n     * @notice Accept a change of the minter of the contract.\\n     * @dev Can only be called by the proposed minter.\\n     * @param fromMinter The previous minter.\\n     */\\n    function acceptMintership(address fromMinter) external;\\n\\n    /**\\n     * @notice Query if an address is a minter\\n     * @param addr the address to query for\\n     * @return bool Boolean value representing whether or not the address is a minter.\\n     */\\n    function isMinter(address addr) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITransmitInterchainToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ITransmitInterchainToken Interface\\n * @notice Interface for transmiting interchain tokens via the interchain token service\\n */\\ninterface ITransmitInterchainToken {\\n    /**\\n     * @notice Transmit an interchain transfer for the given tokenId.\\n     * @dev Only callable by a token registered under a tokenId.\\n     * @param tokenId The tokenId of the token (which must be the msg.sender).\\n     * @param sourceAddress The address where the token is coming from.\\n     * @param destinationChain The name of the chain to send tokens to.\\n     * @param destinationAddress The destinationAddress for the interchainTransfer.\\n     * @param amount The amount of token to give.\\n     * @param metadata Optional metadata for the call for additional effects (such as calling a destination contract).\\n     */\\n    function transmitInterchainTransfer(\\n        bytes32 tokenId,\\n        address sourceAddress,\\n        string calldata destinationChain,\\n        bytes memory destinationAddress,\\n        uint256 amount,\\n        bytes calldata metadata\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Minter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IMinter } from '../interfaces/IMinter.sol';\\n\\nimport { RolesBase } from '@axelar-network/axelar-gmp-sdk-solidity/contracts/utils/RolesBase.sol';\\nimport { RolesConstants } from './RolesConstants.sol';\\n\\n/**\\n * @title Minter Contract\\n * @notice A contract module which provides a basic access control mechanism, where\\n * there is an account (a minter) that can be granted exclusive access to\\n * specific functions.\\n * @dev This module is used through inheritance.\\n */\\ncontract Minter is IMinter, RolesBase, RolesConstants {\\n    /**\\n     * @notice Internal function that stores the new minter address in the correct storage slot.\\n     * @param minter_ The address of the new minter.\\n     */\\n    function _addMinter(address minter_) internal {\\n        _addRole(minter_, uint8(Roles.MINTER));\\n    }\\n\\n    /**\\n     * @notice Changes the minter of the contract.\\n     * @dev Can only be called by the current minter.\\n     * @param minter_ The address of the new minter.\\n     */\\n    function transferMintership(address minter_) external onlyRole(uint8(Roles.MINTER)) {\\n        _transferRole(msg.sender, minter_, uint8(Roles.MINTER));\\n    }\\n\\n    /**\\n     * @notice Proposes a change of the minter of the contract.\\n     * @dev Can only be called by the current minter.\\n     * @param minter_ The address of the new minter.\\n     */\\n    function proposeMintership(address minter_) external onlyRole(uint8(Roles.MINTER)) {\\n        _proposeRole(msg.sender, minter_, uint8(Roles.MINTER));\\n    }\\n\\n    /**\\n     * @notice Accept a change of the minter of the contract.\\n     * @dev Can only be called by the proposed minter.\\n     * @param fromMinter The previous minter.\\n     */\\n    function acceptMintership(address fromMinter) external {\\n        _acceptRole(fromMinter, msg.sender, uint8(Roles.MINTER));\\n    }\\n\\n    /**\\n     * @notice Query if an address is a minter\\n     * @param addr the address to query for\\n     * @return bool Boolean value representing whether or not the address is a minter.\\n     */\\n    function isMinter(address addr) external view returns (bool) {\\n        return hasRole(addr, uint8(Roles.MINTER));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/RolesConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title RolesConstants\\n * @notice This contract contains enum values representing different contract roles.\\n */\\ncontract RolesConstants {\\n    enum Roles {\\n        MINTER,\\n        OPERATOR,\\n        FLOW_LIMITER\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"interchainTokenServiceAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainTokenServiceAddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"accountRoles\",\"type\":\"uint256\"}],\"name\":\"InvalidProposedRoles\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidV\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"accountRoles\",\"type\":\"uint256\"}],\"name\":\"MissingAllRoles\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"accountRoles\",\"type\":\"uint256\"}],\"name\":\"MissingAnyOfRoles\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"MissingRole\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PermitExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIdZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNameEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenSymbolEmpty\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountRoles\",\"type\":\"uint256\"}],\"name\":\"RolesAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountRoles\",\"type\":\"uint256\"}],\"name\":\"RolesProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountRoles\",\"type\":\"uint256\"}],\"name\":\"RolesRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromMinter\",\"type\":\"address\"}],\"name\":\"acceptMintership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"role\",\"type\":\"uint8\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"tokenId_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"tokenDecimals\",\"type\":\"uint8\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchainTokenId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchainTokenService\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"recipient\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"interchainTransfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"destinationChain\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"recipient\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"interchainTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nameHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"}],\"name\":\"proposeMintership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"}],\"name\":\"transferMintership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "InterchainToken", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000b5fb4be02232b1bba4dc8f81dc24c26980de9e3c", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}