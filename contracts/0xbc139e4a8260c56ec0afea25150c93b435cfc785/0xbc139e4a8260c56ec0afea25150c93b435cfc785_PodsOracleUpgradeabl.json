{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@gnus.ai/contracts-upgradeable-diamond/contracts/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@gnus.ai/contracts-upgradeable-diamond/contracts/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/beanstalk/IBeanstalkUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IBeanstalkUpgradeable {\\n    event SetFertilizer(uint128 id, uint128 bpf);\\n\\n    function addFertilizerOwner(uint128 id, uint128 amount, uint256 minLP) external payable;\\n\\n    function balanceOfBatchFertilizer(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    ) external view returns (IFertilizer.Balance[] memory);\\n\\n    function balanceOfFertilized(\\n        address account,\\n        uint256[] memory ids\\n    ) external view returns (uint256 beans);\\n\\n    function balanceOfFertilizer(\\n        address account,\\n        uint256 id\\n    ) external view returns (IFertilizer.Balance memory);\\n\\n    function balanceOfUnfertilized(\\n        address account,\\n        uint256[] memory ids\\n    ) external view returns (uint256 beans);\\n\\n    function beansPerFertilizer() external view returns (uint128 bpf);\\n\\n    function claimFertilized(uint256[] memory ids, uint8 mode) external payable;\\n\\n    function getActiveFertilizer() external view returns (uint256);\\n\\n    function getCurrentHumidity() external view returns (uint128 humidity);\\n\\n    function getEndBpf() external view returns (uint128 endBpf);\\n\\n    function getFertilizer(uint128 id) external view returns (uint256);\\n\\n    function getFertilizers() external view returns (FertilizerFacet.Supply[] memory fertilizers);\\n\\n    function getFirst() external view returns (uint128);\\n\\n    function getHumidity(uint128 _s) external pure returns (uint128 humidity);\\n\\n    function getLast() external view returns (uint128);\\n\\n    function getNext(uint128 id) external view returns (uint128);\\n\\n    function isFertilizing() external view returns (bool);\\n\\n    function mintFertilizer(uint128 amount, uint256 minLP, uint8 mode) external payable;\\n\\n    function payFertilizer(address account, uint256 amount) external payable;\\n\\n    function remainingRecapitalization() external view returns (uint256);\\n\\n    function totalFertilizedBeans() external view returns (uint256 beans);\\n\\n    function totalFertilizerBeans() external view returns (uint256 beans);\\n\\n    function totalUnfertilizedBeans() external view returns (uint256 beans);\\n\\n    event AddUnripeToken(\\n        address indexed unripeToken,\\n        address indexed underlyingToken,\\n        bytes32 merkleRoot\\n    );\\n    event ChangeUnderlying(address indexed token, int256 underlying);\\n    event Chop(address indexed account, address indexed token, uint256 amount, uint256 underlying);\\n    event Pick(address indexed account, address indexed token, uint256 amount);\\n\\n    function _getPenalizedUnderlying(\\n        address unripeToken,\\n        uint256 amount,\\n        uint256 supply\\n    ) external view returns (uint256 redeem);\\n\\n    function addUnripeToken(\\n        address unripeToken,\\n        address underlyingToken,\\n        bytes32 root\\n    ) external payable;\\n\\n    function balanceOfPenalizedUnderlying(\\n        address unripeToken,\\n        address account\\n    ) external view returns (uint256 underlying);\\n\\n    function balanceOfUnderlying(\\n        address unripeToken,\\n        address account\\n    ) external view returns (uint256 underlying);\\n\\n    function chop(\\n        address unripeToken,\\n        uint256 amount,\\n        uint8 fromMode,\\n        uint8 toMode\\n    ) external payable returns (uint256 underlyingAmount);\\n\\n    function getPenalizedUnderlying(\\n        address unripeToken,\\n        uint256 amount\\n    ) external view returns (uint256 redeem);\\n\\n    function getPenalty(address unripeToken) external view returns (uint256 penalty);\\n\\n    function getPercentPenalty(address unripeToken) external view returns (uint256 penalty);\\n\\n    function getRecapFundedPercent(address unripeToken) external view returns (uint256 percent);\\n\\n    function getRecapPaidPercent() external view returns (uint256 penalty);\\n\\n    function getTotalUnderlying(address unripeToken) external view returns (uint256 underlying);\\n\\n    function getUnderlying(\\n        address unripeToken,\\n        uint256 amount\\n    ) external view returns (uint256 redeem);\\n\\n    function getUnderlyingPerUnripeToken(\\n        address unripeToken\\n    ) external view returns (uint256 underlyingPerToken);\\n\\n    function getUnderlyingToken(\\n        address unripeToken\\n    ) external view returns (address underlyingToken);\\n\\n    function isUnripe(address unripeToken) external view returns (bool unripe);\\n\\n    function pick(\\n        address token,\\n        uint256 amount,\\n        bytes32[] memory proof,\\n        uint8 mode\\n    ) external payable;\\n\\n    function picked(address account, address token) external view returns (bool);\\n\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function claimOwnership() external;\\n\\n    function owner() external view returns (address owner_);\\n\\n    function ownerCandidate() external view returns (address ownerCandidate_);\\n\\n    function transferOwnership(address _newOwner) external;\\n\\n    event Pause(uint256 timestamp);\\n    event Unpause(uint256 timestamp, uint256 timePassed);\\n\\n    function pause() external payable;\\n\\n    function unpause() external payable;\\n\\n    function addLiquidity(\\n        address pool,\\n        address registry,\\n        uint256[] memory amounts,\\n        uint256 minAmountOut,\\n        uint8 fromMode,\\n        uint8 toMode\\n    ) external payable;\\n\\n    function exchange(\\n        address pool,\\n        address registry,\\n        address fromToken,\\n        address toToken,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint8 fromMode,\\n        uint8 toMode\\n    ) external payable;\\n\\n    function exchangeUnderlying(\\n        address pool,\\n        address fromToken,\\n        address toToken,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint8 fromMode,\\n        uint8 toMode\\n    ) external payable;\\n\\n    function removeLiquidity(\\n        address pool,\\n        address registry,\\n        uint256 amountIn,\\n        uint256[] memory minAmountsOut,\\n        uint8 fromMode,\\n        uint8 toMode\\n    ) external payable;\\n\\n    function removeLiquidityImbalance(\\n        address pool,\\n        address registry,\\n        uint256[] memory amountsOut,\\n        uint256 maxAmountIn,\\n        uint8 fromMode,\\n        uint8 toMode\\n    ) external payable;\\n\\n    function removeLiquidityOneToken(\\n        address pool,\\n        address registry,\\n        address toToken,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint8 fromMode,\\n        uint8 toMode\\n    ) external payable;\\n\\n    function advancedPipe(\\n        AdvancedPipeCall[] memory pipes,\\n        uint256 value\\n    ) external payable returns (bytes[] memory results);\\n\\n    function etherPipe(\\n        PipeCall memory p,\\n        uint256 value\\n    ) external payable returns (bytes memory result);\\n\\n    function multiPipe(PipeCall[] memory pipes) external payable returns (bytes[] memory results);\\n\\n    function pipe(PipeCall memory p) external payable returns (bytes memory result);\\n\\n    function readPipe(PipeCall memory p) external view returns (bytes memory result);\\n\\n    function advancedFarm(\\n        AdvancedFarmCall[] memory data\\n    ) external payable returns (bytes[] memory results);\\n\\n    function farm(bytes[] memory data) external payable returns (bytes[] memory results);\\n\\n    event InternalBalanceChanged(address indexed user, address indexed token, int256 delta);\\n    event TokenApproval(\\n        address indexed owner,\\n        address indexed spender,\\n        address token,\\n        uint256 amount\\n    );\\n\\n    function approveToken(address spender, address token, uint256 amount) external payable;\\n\\n    function decreaseTokenAllowance(\\n        address spender,\\n        address token,\\n        uint256 subtractedValue\\n    ) external returns (bool);\\n\\n    function getAllBalance(\\n        address account,\\n        address token\\n    ) external view returns (Storage.Rain memory b);\\n\\n    function getAllBalances(\\n        address account,\\n        address[] memory tokens\\n    ) external view returns (Storage.Rain[] memory balances);\\n\\n    function getBalance(address account, address token) external view returns (uint256 balance);\\n\\n    function getBalances(\\n        address account,\\n        address[] memory tokens\\n    ) external view returns (uint256[] memory balances);\\n\\n    function getExternalBalance(\\n        address account,\\n        address token\\n    ) external view returns (uint256 balance);\\n\\n    function getExternalBalances(\\n        address account,\\n        address[] memory tokens\\n    ) external view returns (uint256[] memory balances);\\n\\n    function getInternalBalance(\\n        address account,\\n        address token\\n    ) external view returns (uint256 balance);\\n\\n    function getInternalBalances(\\n        address account,\\n        address[] memory tokens\\n    ) external view returns (uint256[] memory balances);\\n\\n    function increaseTokenAllowance(\\n        address spender,\\n        address token,\\n        uint256 addedValue\\n    ) external returns (bool);\\n\\n    function permitToken(\\n        address owner,\\n        address spender,\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable;\\n\\n    function tokenAllowance(\\n        address account,\\n        address spender,\\n        address token\\n    ) external view returns (uint256);\\n\\n    function tokenPermitDomainSeparator() external view returns (bytes32);\\n\\n    function tokenPermitNonces(address owner) external view returns (uint256);\\n\\n    function transferInternalTokenFrom(\\n        address token,\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        uint8 toMode\\n    ) external payable;\\n\\n    function transferToken(\\n        address token,\\n        address recipient,\\n        uint256 amount,\\n        uint8 fromMode,\\n        uint8 toMode\\n    ) external payable;\\n\\n    function unwrapEth(uint256 amount, uint8 mode) external payable;\\n\\n    function wrapEth(uint256 amount, uint8 mode) external payable;\\n\\n    function batchTransferERC1155(\\n        address token,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory values\\n    ) external payable;\\n\\n    function permitERC20(\\n        address token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable;\\n\\n    function permitERC721(\\n        address token,\\n        address spender,\\n        uint256 tokenId,\\n        uint256 deadline,\\n        bytes memory sig\\n    ) external payable;\\n\\n    function transferERC1155(address token, address to, uint256 id, uint256 value) external payable;\\n\\n    function transferERC721(address token, address to, uint256 id) external payable;\\n\\n    event Harvest(address indexed account, uint256[] plots, uint256 beans);\\n    event PodListingCancelled(address indexed account, uint256 index);\\n    event Sow(address indexed account, uint256 index, uint256 beans, uint256 pods);\\n\\n    function harvest(uint256[] memory plots, uint8 mode) external payable;\\n\\n    function harvestableIndex() external view returns (uint256);\\n\\n    function maxTemperature() external view returns (uint256);\\n\\n    function plot(address account, uint256 index) external view returns (uint256);\\n\\n    function podIndex() external view returns (uint256);\\n\\n    function remainingPods() external view returns (uint256);\\n\\n    function sow(\\n        uint256 beans,\\n        uint256 minTemperature,\\n        uint8 mode\\n    ) external payable returns (uint256 pods);\\n\\n    function sowWithMin(\\n        uint256 beans,\\n        uint256 minTemperature,\\n        uint256 minSoil,\\n        uint8 mode\\n    ) external payable returns (uint256 pods);\\n\\n    function temperature() external view returns (uint256);\\n\\n    function totalHarvestable() external view returns (uint256);\\n\\n    function totalHarvested() external view returns (uint256);\\n\\n    function totalPods() external view returns (uint256);\\n\\n    function totalSoil() external view returns (uint256);\\n\\n    function totalUnharvestable() external view returns (uint256);\\n\\n    function yield() external view returns (uint32);\\n\\n    event CompleteFundraiser(uint32 indexed id);\\n    event CreateFundraiser(uint32 indexed id, address payee, address token, uint256 amount);\\n    event FundFundraiser(address indexed account, uint32 indexed id, uint256 amount);\\n\\n    function createFundraiser(address payee, address token, uint256 amount) external payable;\\n\\n    function fund(uint32 id, uint256 amount, uint8 mode) external payable returns (uint256);\\n\\n    function fundingToken(uint32 id) external view returns (address);\\n\\n    function fundraiser(uint32 id) external view returns (Storage.Fundraiser memory);\\n\\n    function numberOfFundraisers() external view returns (uint32);\\n\\n    function remainingFunding(uint32 id) external view returns (uint256);\\n\\n    function totalFunding(uint32 id) external view returns (uint256);\\n\\n    event PlotTransfer(address indexed from, address indexed to, uint256 indexed id, uint256 pods);\\n    event PodApproval(address indexed owner, address indexed spender, uint256 pods);\\n    event PodListingCreated(\\n        address indexed account,\\n        uint256 index,\\n        uint256 start,\\n        uint256 amount,\\n        uint24 pricePerPod,\\n        uint256 maxHarvestableIndex,\\n        uint256 minFillAmount,\\n        bytes pricingFunction,\\n        uint8 mode,\\n        uint8 pricingType\\n    );\\n    event PodListingFilled(\\n        address indexed from,\\n        address indexed to,\\n        uint256 index,\\n        uint256 start,\\n        uint256 amount,\\n        uint256 costInBeans\\n    );\\n    event PodOrderCancelled(address indexed account, bytes32 id);\\n    event PodOrderCreated(\\n        address indexed account,\\n        bytes32 id,\\n        uint256 amount,\\n        uint24 pricePerPod,\\n        uint256 maxPlaceInLine,\\n        uint256 minFillAmount,\\n        bytes pricingFunction,\\n        uint8 priceType\\n    );\\n    event PodOrderFilled(\\n        address indexed from,\\n        address indexed to,\\n        bytes32 id,\\n        uint256 index,\\n        uint256 start,\\n        uint256 amount,\\n        uint256 costInBeans\\n    );\\n\\n    function allowancePods(address owner, address spender) external view returns (uint256);\\n\\n    function approvePods(address spender, uint256 amount) external payable;\\n\\n    function cancelPodListing(uint256 index) external payable;\\n\\n    function cancelPodOrder(\\n        uint24 pricePerPod,\\n        uint256 maxPlaceInLine,\\n        uint256 minFillAmount,\\n        uint8 mode\\n    ) external payable;\\n\\n    function cancelPodOrderV2(\\n        uint256 maxPlaceInLine,\\n        uint256 minFillAmount,\\n        bytes memory pricingFunction,\\n        uint8 mode\\n    ) external payable;\\n\\n    function createPodListing(\\n        uint256 index,\\n        uint256 start,\\n        uint256 amount,\\n        uint24 pricePerPod,\\n        uint256 maxHarvestableIndex,\\n        uint256 minFillAmount,\\n        uint8 mode\\n    ) external payable;\\n\\n    function createPodListingV2(\\n        uint256 index,\\n        uint256 start,\\n        uint256 amount,\\n        uint256 maxHarvestableIndex,\\n        uint256 minFillAmount,\\n        bytes memory pricingFunction,\\n        uint8 mode\\n    ) external payable;\\n\\n    function createPodOrder(\\n        uint256 beanAmount,\\n        uint24 pricePerPod,\\n        uint256 maxPlaceInLine,\\n        uint256 minFillAmount,\\n        uint8 mode\\n    ) external payable returns (bytes32 id);\\n\\n    function createPodOrderV2(\\n        uint256 beanAmount,\\n        uint256 maxPlaceInLine,\\n        uint256 minFillAmount,\\n        bytes memory pricingFunction,\\n        uint8 mode\\n    ) external payable returns (bytes32 id);\\n\\n    function fillPodListing(\\n        Listing.PodListing memory l,\\n        uint256 beanAmount,\\n        uint8 mode\\n    ) external payable;\\n\\n    function fillPodListingV2(\\n        Listing.PodListing memory l,\\n        uint256 beanAmount,\\n        bytes memory pricingFunction,\\n        uint8 mode\\n    ) external payable;\\n\\n    function fillPodOrder(\\n        Order.PodOrder memory o,\\n        uint256 index,\\n        uint256 start,\\n        uint256 amount,\\n        uint8 mode\\n    ) external payable;\\n\\n    function fillPodOrderV2(\\n        Order.PodOrder memory o,\\n        uint256 index,\\n        uint256 start,\\n        uint256 amount,\\n        bytes memory pricingFunction,\\n        uint8 mode\\n    ) external payable;\\n\\n    function getAmountBeansToFillOrderV2(\\n        uint256 placeInLine,\\n        uint256 amountPodsFromOrder,\\n        bytes memory pricingFunction\\n    ) external pure returns (uint256 beanAmount);\\n\\n    function getAmountPodsFromFillListingV2(\\n        uint256 placeInLine,\\n        uint256 podListingAmount,\\n        uint256 fillBeanAmount,\\n        bytes memory pricingFunction\\n    ) external pure returns (uint256 amount);\\n\\n    function podListing(uint256 index) external view returns (bytes32);\\n\\n    function podOrder(\\n        address account,\\n        uint24 pricePerPod,\\n        uint256 maxPlaceInLine,\\n        uint256 minFillAmount\\n    ) external view returns (uint256);\\n\\n    function podOrderById(bytes32 id) external view returns (uint256);\\n\\n    function podOrderV2(\\n        address account,\\n        uint256 maxPlaceInLine,\\n        uint256 minFillAmount,\\n        bytes memory pricingFunction\\n    ) external view returns (uint256);\\n\\n    function transferPlot(\\n        address sender,\\n        address recipient,\\n        uint256 id,\\n        uint256 start,\\n        uint256 end\\n    ) external payable;\\n\\n    function bdv(address token, uint256 amount) external view returns (uint256);\\n\\n    function beanToBDV(uint256 amount) external pure returns (uint256);\\n\\n    function curveToBDV(uint256 amount) external view returns (uint256);\\n\\n    function unripeBeanToBDV(uint256 amount) external view returns (uint256);\\n\\n    function unripeLPToBDV(uint256 amount) external view returns (uint256);\\n\\n    event Convert(\\n        address indexed account,\\n        address fromToken,\\n        address toToken,\\n        uint256 fromAmount,\\n        uint256 toAmount\\n    );\\n    event RemoveDeposits(\\n        address indexed account,\\n        address indexed token,\\n        uint32[] seasons,\\n        uint256[] amounts,\\n        uint256 amount\\n    );\\n\\n    function convert(\\n        bytes memory convertData,\\n        uint32[] memory crates,\\n        uint256[] memory amounts\\n    )\\n        external\\n        payable\\n        returns (\\n            uint32 toSeason,\\n            uint256 fromAmount,\\n            uint256 toAmount,\\n            uint256 fromBdv,\\n            uint256 toBdv\\n        );\\n\\n    function getAmountOut(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn\\n    ) external view returns (uint256 amountOut);\\n\\n    function getMaxAmountIn(\\n        address tokenIn,\\n        address tokenOut\\n    ) external view returns (uint256 amountIn);\\n\\n    event AddDeposit(\\n        address indexed account,\\n        address indexed token,\\n        uint32 season,\\n        uint256 amount,\\n        uint256 bdv\\n    );\\n    event AddWithdrawal(\\n        address indexed account,\\n        address indexed token,\\n        uint32 season,\\n        uint256 amount\\n    );\\n    event ClaimPlenty(address indexed account, uint256 plenty);\\n    event DepositApproval(\\n        address indexed owner,\\n        address indexed spender,\\n        address token,\\n        uint256 amount\\n    );\\n    event Plant(address indexed account, uint256 beans);\\n    event RemoveDeposit(\\n        address indexed account,\\n        address indexed token,\\n        uint32 season,\\n        uint256 amount\\n    );\\n    event RemoveWithdrawal(\\n        address indexed account,\\n        address indexed token,\\n        uint32 season,\\n        uint256 amount\\n    );\\n    event RemoveWithdrawals(\\n        address indexed account,\\n        address indexed token,\\n        uint32[] seasons,\\n        uint256 amount\\n    );\\n    event SeedsBalanceChanged(address indexed account, int256 delta);\\n    event StalkBalanceChanged(address indexed account, int256 delta, int256 deltaRoots);\\n\\n    function approveDeposit(address spender, address token, uint256 amount) external payable;\\n\\n    function balanceOfEarnedBeans(address account) external view returns (uint256 beans);\\n\\n    function balanceOfEarnedSeeds(address account) external view returns (uint256);\\n\\n    function balanceOfEarnedStalk(address account) external view returns (uint256);\\n\\n    function balanceOfGrownStalk(address account) external view returns (uint256);\\n\\n    function balanceOfPlenty(address account) external view returns (uint256 plenty);\\n\\n    function balanceOfRainRoots(address account) external view returns (uint256);\\n\\n    function balanceOfRoots(address account) external view returns (uint256);\\n\\n    function balanceOfSeeds(address account) external view returns (uint256);\\n\\n    function balanceOfSop(\\n        address account\\n    ) external view returns (SiloExit.AccountSeasonOfPlenty memory sop);\\n\\n    function balanceOfStalk(address account) external view returns (uint256);\\n\\n    function claimPlenty() external payable;\\n\\n    function claimWithdrawal(address token, uint32 season, uint8 mode) external payable;\\n\\n    function claimWithdrawals(address token, uint32[] memory seasons, uint8 mode) external payable;\\n\\n    function decreaseDepositAllowance(\\n        address spender,\\n        address token,\\n        uint256 subtractedValue\\n    ) external returns (bool);\\n\\n    function deposit(address token, uint256 amount, uint8 mode) external payable;\\n\\n    function depositAllowance(\\n        address account,\\n        address spender,\\n        address token\\n    ) external view returns (uint256);\\n\\n    function depositPermitDomainSeparator() external view returns (bytes32);\\n\\n    function depositPermitNonces(address owner) external view returns (uint256);\\n\\n    function enrootDeposit(address token, uint32 _season, uint256 amount) external;\\n\\n    function enrootDeposits(\\n        address token,\\n        uint32[] memory seasons,\\n        uint256[] memory amounts\\n    ) external;\\n\\n    function getDeposit(\\n        address account,\\n        address token,\\n        uint32 season\\n    ) external view returns (uint256, uint256);\\n\\n    function getTotalDeposited(address token) external view returns (uint256);\\n\\n    function getTotalWithdrawn(address token) external view returns (uint256);\\n\\n    function getWithdrawal(\\n        address account,\\n        address token,\\n        uint32 season\\n    ) external view returns (uint256);\\n\\n    function increaseDepositAllowance(\\n        address spender,\\n        address token,\\n        uint256 addedValue\\n    ) external returns (bool);\\n\\n    function lastSeasonOfPlenty() external view returns (uint32);\\n\\n    function lastUpdate(address account) external view returns (uint32);\\n\\n    function permitDeposit(\\n        address owner,\\n        address spender,\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable;\\n\\n    function permitDeposits(\\n        address owner,\\n        address spender,\\n        address[] memory tokens,\\n        uint256[] memory values,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable;\\n\\n    function plant() external payable returns (uint256 beans);\\n\\n    function tokenSettings(address token) external view returns (Storage.SiloSettings memory);\\n\\n    function totalEarnedBeans() external view returns (uint256);\\n\\n    function totalRoots() external view returns (uint256);\\n\\n    function totalSeeds() external view returns (uint256);\\n\\n    function totalStalk() external view returns (uint256);\\n\\n    function transferDeposit(\\n        address sender,\\n        address recipient,\\n        address token,\\n        uint32 season,\\n        uint256 amount\\n    ) external payable returns (uint256 bdv);\\n\\n    function transferDeposits(\\n        address sender,\\n        address recipient,\\n        address token,\\n        uint32[] memory seasons,\\n        uint256[] memory amounts\\n    ) external payable returns (uint256[] memory bdvs);\\n\\n    function update(address account) external payable;\\n\\n    function withdrawDeposit(address token, uint32 season, uint256 amount) external payable;\\n\\n    function withdrawDeposits(\\n        address token,\\n        uint32[] memory seasons,\\n        uint256[] memory amounts\\n    ) external payable;\\n\\n    function withdrawFreeze() external view returns (uint8);\\n\\n    event DewhitelistToken(address indexed token);\\n    event WhitelistToken(address indexed token, bytes4 selector, uint256 seeds, uint256 stalk);\\n\\n    function dewhitelistToken(address token) external payable;\\n\\n    function whitelistToken(\\n        address token,\\n        bytes4 selector,\\n        uint32 stalk,\\n        uint32 seeds\\n    ) external payable;\\n\\n    event Incentivization(address indexed account, uint256 beans);\\n    event Reward(uint32 indexed season, uint256 toField, uint256 toSilo, uint256 toFertilizer);\\n    event SeasonOfPlenty(uint256 indexed season, uint256 amount, uint256 toField);\\n    event Soil(uint32 indexed season, uint256 soil);\\n    event Sunrise(uint256 indexed season);\\n    event WeatherChange(uint256 indexed season, uint256 caseId, int8 change);\\n\\n    function abovePeg() external view returns (bool);\\n\\n    function gm(address account, uint8 mode) external payable returns (uint256);\\n\\n    function paused() external view returns (bool);\\n\\n    function plentyPerRoot(uint32 season) external view returns (uint256);\\n\\n    function poolDeltaB(address pool) external view returns (int256);\\n\\n    function rain() external view returns (Storage.Rain memory);\\n\\n    function season() external view returns (uint32);\\n\\n    function seasonTime() external view returns (uint32);\\n\\n    function sunrise() external payable returns (uint256);\\n\\n    function sunriseBlock() external view returns (uint32);\\n\\n    function time() external view returns (Storage.Season memory);\\n\\n    function totalDeltaB() external view returns (int256 deltaB);\\n\\n    function weather() external view returns (Storage.Weather memory);\\n}\\n\\nstruct AdvancedPipeCall {\\n    address target;\\n    bytes callData;\\n    bytes clipboard;\\n}\\n\\nstruct PipeCall {\\n    address target;\\n    bytes data;\\n}\\n\\nstruct AdvancedFarmCall {\\n    bytes callData;\\n    bytes clipboard;\\n}\\n\\ninterface IFertilizer {\\n    struct Balance {\\n        uint128 amount;\\n        uint128 lastBpf;\\n    }\\n}\\n\\ninterface FertilizerFacet {\\n    struct Supply {\\n        uint128 endBpf;\\n        uint256 supply;\\n    }\\n}\\n\\ninterface TokenFacet {\\n    struct Rain {\\n        uint256 deprecated;\\n        uint256 pods;\\n        uint256 roots;\\n    }\\n}\\n\\ninterface Storage {\\n    struct Rain {\\n        uint256 deprecated;\\n        uint256 pods;\\n        uint256 roots;\\n    }\\n\\n    struct Fundraiser {\\n        address payee;\\n        address token;\\n        uint256 total;\\n        uint256 remaining;\\n        uint256 start;\\n    }\\n\\n    struct SiloSettings {\\n        bytes4 selector;\\n        uint32 seeds;\\n        uint32 stalk;\\n    }\\n\\n    struct Season {\\n        uint32 current;\\n        uint32 lastSop;\\n        uint8 withdrawSeasons;\\n        uint32 lastSopSeason;\\n        uint32 rainStart;\\n        bool raining;\\n        bool fertilizing;\\n        uint32 sunriseBlock;\\n        bool abovePeg;\\n        uint256 start;\\n        uint256 period;\\n        uint256 timestamp;\\n    }\\n\\n    struct Weather {\\n        uint256[2] deprecated;\\n        uint128 lastDSoil;\\n        uint32 lastSowTime;\\n        uint32 thisSowTime;\\n        uint32 t;\\n    }\\n}\\n\\ninterface Listing {\\n    struct PodListing {\\n        address account;\\n        uint256 index;\\n        uint256 start;\\n        uint256 amount;\\n        uint24 pricePerPod;\\n        uint256 maxHarvestableIndex;\\n        uint256 minFillAmount;\\n        uint8 mode;\\n    }\\n}\\n\\ninterface Order {\\n    struct PodOrder {\\n        address account;\\n        uint24 pricePerPod;\\n        uint256 maxPlaceInLine;\\n        uint256 minFillAmount;\\n    }\\n}\\n\\ninterface SiloExit {\\n    struct AccountSeasonOfPlenty {\\n        uint32 lastRain;\\n        uint32 lastSop;\\n        uint256 roots;\\n        uint256 plentyPerRoot;\\n        uint256 plenty;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/WaterCommonStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\n\\nimport {IBeanstalkUpgradeable} from \\\"../beanstalk/IBeanstalkUpgradeable.sol\\\";\\nimport {IERC1155Upgradeable} from \\\"@gnus.ai/contracts-upgradeable-diamond/contracts/token/ERC1155/IERC1155Upgradeable.sol\\\";\\n\\nlibrary WaterCommonStorage {\\n    struct Layout {\\n        // Beanstalk protocol contract\\n        IBeanstalkUpgradeable beanstalk;\\n        // fertilizer token contract\\n        IERC1155Upgradeable fertilizer;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"irrigation.contracts.storage.WaterCommon\\\");\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPodsOracleUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IPodsOracleUpgradeable {\\n    ///@dev get virtual price of a plot with latest podIndex and harvestableIndex\\n    function latestPriceOfPods(uint256 placeInLine, uint256 pods) external returns (uint256);\\n\\n    /// getter for price of a plot at any podIndex\\n    /**\\n     * @notice Get price for any pods to 1e18\\n     * @param placeInLine with 1e6 decimals\\n     * @param pods with 1e6 decimals\\n     * @return price pods price\\n     */\\n    function priceOfPods(\\n        uint256 placeInLine,\\n        uint256 pods,\\n        uint256 podIndex,\\n        uint256 harvestableIndex\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Oracle/LibPrice.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary LibPrice {\\n    /// @dev factor to consider decimals of price and BEAN\\n    /// 10 ^ (18 - 6)\\n    uint256 private constant BDV_FACTOR = 1e12;\\n\\n    // getter for price\\n    /**\\n     * @notice Get price for any pods (decimals 18)\\n     * @param placeInLine with decimals 6\\n     * @param pods with decimals 6\\n     * @param podIndex with decimals 6\\n     * @param harvestableIndex with decimals 6\\n     * @return price pods price\\n     * @dev   pods price = (1 - (placeInLine + pods/2 - harvestableIndex)/(podIndex-harvestableIndex)) * pods\\n     */\\n    function getPriceOfPods(\\n        uint256 placeInLine,\\n        uint256 pods,\\n        uint256 podIndex,\\n        uint256 harvestableIndex\\n    ) internal pure returns (uint256) {\\n        uint256 unharvestable = podIndex - harvestableIndex;\\n        uint256 accumulatedPrice;\\n        if (unharvestable == 0 || placeInLine + pods <= harvestableIndex) {\\n            return pods * BDV_FACTOR;\\n        } else if (placeInLine <= harvestableIndex) {\\n            accumulatedPrice = (harvestableIndex - placeInLine) * BDV_FACTOR;\\n            pods -= (harvestableIndex - placeInLine);\\n            placeInLine = harvestableIndex;  \\n        }\\n        uint256 numerator = podIndex - placeInLine - pods / 2;\\n        return accumulatedPrice + ((numerator * pods) * BDV_FACTOR) / unharvestable;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracles/PodsOracleUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"../interfaces/IPodsOracleUpgradeable.sol\\\";\\nimport \\\"../core/WaterCommonStorage.sol\\\";\\nimport \\\"../libraries/Oracle/LibPrice.sol\\\";\\n\\ncontract PodsOracleUpgradeable is IPodsOracleUpgradeable {\\n\\n    /// @notice returns unharvestable pods price in BDV(based on BEAN price)\\n    /// @dev decimals of price is 18\\n    function latestPriceOfPods(\\n        uint256 placeInLine,\\n        uint256 pods\\n    ) external view returns (uint256 price) {\\n        uint256 podIndex = WaterCommonStorage.layout().beanstalk.podIndex();\\n        uint256 harvestableIndex = WaterCommonStorage.layout().beanstalk.harvestableIndex();\\n        price = LibPrice.getPriceOfPods(placeInLine, pods, podIndex, harvestableIndex);\\n    }\\n\\n    /// @dev see {IPodsOracleUpgradeable} and {LibPrice}\\n    function priceOfPods(\\n        uint256 placeInLine,\\n        uint256 pods,\\n        uint256 podIndex,\\n        uint256 harvestableIndex\\n    ) external pure returns (uint256 price) {\\n        price = LibPrice.getPriceOfPods(placeInLine, pods, podIndex, harvestableIndex);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"placeInLine\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pods\",\"type\":\"uint256\"}],\"name\":\"latestPriceOfPods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"placeInLine\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pods\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"podIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"harvestableIndex\",\"type\":\"uint256\"}],\"name\":\"priceOfPods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "PodsOracleUpgradeable", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}