{"SourceCode": "pragma solidity 0.4.25;\r\n\r\ncontract PantheonEcoSystem {\r\n\r\n    struct UserRecord {\r\n        address referrer;\r\n        uint tokens;\r\n        uint gained_funds;\r\n        uint ref_funds;\r\n        // this field can be negative\r\n        int funds_correction;\r\n    }\r\n\r\n    using SafeMath for uint;\r\n    using SafeMathInt for int;\r\n    using Fee for Fee.fee;\r\n    using ToAddress for bytes;\r\n\r\n    // ERC20\r\n    string constant public name = \"Pantheon Ecosystem\";\r\n    string constant public symbol = \"PAN\";\r\n    uint8 constant public decimals = 18;\r\n\r\n    // Fees\r\n    Fee.fee private fee_purchase = Fee.fee(1, 10); // 10%\r\n    Fee.fee private fee_selling  = Fee.fee(1, 20); // 5%\r\n    Fee.fee private fee_transfer = Fee.fee(1, 100); // 1%\r\n    Fee.fee private fee_referral = Fee.fee(33, 100); // 33%\r\n\r\n    // Minimal amount of tokens to be an participant of referral program\r\n    uint constant private minimal_stake = 10e18;\r\n\r\n    // Factor for converting eth <-> tokens with required precision of calculations\r\n    uint constant private precision_factor = 1e18;\r\n\r\n    // Pricing policy\r\n    //  - if user buy 1 token, price will be increased by \"price_offset\" value\r\n    //  - if user sell 1 token, price will be decreased by \"price_offset\" value\r\n    // For details see methods \"fundsToTokens\" and \"tokensToFunds\"\r\n    uint private price = 1e29; // 100 Gwei * precision_factor\r\n    uint constant private price_offset = 1e28; // 10 Gwei * precision_factor\r\n\r\n    // Total amount of tokens\r\n    uint private total_supply = 0;\r\n\r\n    // Total profit shared between token's holders. It's not reflect exactly sum of funds because this parameter\r\n    // can be modified to keep the real user's dividends when total supply is changed\r\n    // For details see method \"dividendsOf\" and using \"funds_correction\" in the code\r\n    uint private shared_profit = 0;\r\n\r\n    // Map of the users data\r\n    mapping(address => UserRecord) private user_data;\r\n\r\n    // ==== Modifiers ==== //\r\n\r\n    modifier onlyValidTokenAmount(uint tokens) {\r\n        require(tokens > 0, \"Amount of tokens must be greater than zero\");\r\n        require(tokens <= user_data[msg.sender].tokens, \"You have not enough tokens\");\r\n        _;\r\n    }\r\n\r\n    // ==== Public API ==== //\r\n\r\n    // ---- Write methods ---- //\r\n\r\n    function () public payable {\r\n        buy(msg.data.toAddr());\r\n    }\r\n\r\n    /*\r\n    * @dev Buy tokens from incoming funds\r\n    */\r\n    function buy(address referrer) public payable {\r\n\r\n        // apply fee\r\n        (uint fee_funds, uint taxed_funds) = fee_purchase.split(msg.value);\r\n        require(fee_funds != 0, \"Incoming funds is too small\");\r\n\r\n        // update user's referrer\r\n        //  - you cannot be a referrer for yourself\r\n        //  - user and his referrer will be together all the life\r\n        UserRecord storage user = user_data[msg.sender];\r\n        if (referrer != 0x0 && referrer != msg.sender && user.referrer == 0x0) {\r\n            user.referrer = referrer;\r\n        }\r\n\r\n        // apply referral bonus\r\n        if (user.referrer != 0x0) {\r\n            fee_funds = rewardReferrer(msg.sender, user.referrer, fee_funds, msg.value);\r\n            require(fee_funds != 0, \"Incoming funds is too small\");\r\n        }\r\n\r\n        // calculate amount of tokens and change price\r\n        (uint tokens, uint _price) = fundsToTokens(taxed_funds);\r\n        require(tokens != 0, \"Incoming funds is too small\");\r\n        price = _price;\r\n\r\n        // mint tokens and increase shared profit\r\n        mintTokens(msg.sender, tokens);\r\n        shared_profit = shared_profit.add(fee_funds);\r\n\r\n        emit Purchase(msg.sender, msg.value, tokens, price / precision_factor, now);\r\n    }\r\n\r\n    /*\r\n    * @dev Sell given amount of tokens and get funds\r\n    */\r\n    function sell(uint tokens) public onlyValidTokenAmount(tokens) {\r\n\r\n        // calculate amount of funds and change price\r\n        (uint funds, uint _price) = tokensToFunds(tokens);\r\n        require(funds != 0, \"Insufficient tokens to do that\");\r\n        price = _price;\r\n\r\n        // apply fee\r\n        (uint fee_funds, uint taxed_funds) = fee_selling.split(funds);\r\n        require(fee_funds != 0, \"Insufficient tokens to do that\");\r\n\r\n        // burn tokens and add funds to user's dividends\r\n        burnTokens(msg.sender, tokens);\r\n        UserRecord storage user = user_data[msg.sender];\r\n        user.gained_funds = user.gained_funds.add(taxed_funds);\r\n\r\n        // increase shared profit\r\n        shared_profit = shared_profit.add(fee_funds);\r\n\r\n        emit Selling(msg.sender, tokens, funds, price / precision_factor, now);\r\n    }\r\n\r\n    /*\r\n    * @dev Transfer given amount of tokens from sender to another user\r\n    * ERC20\r\n    */\r\n    function transfer(address to_addr, uint tokens) public onlyValidTokenAmount(tokens) returns (bool success) {\r\n\r\n        require(to_addr != msg.sender, \"You cannot transfer tokens to yourself\");\r\n\r\n        // apply fee\r\n        (uint fee_tokens, uint taxed_tokens) = fee_transfer.split(tokens);\r\n        require(fee_tokens != 0, \"Insufficient tokens to do that\");\r\n\r\n        // calculate amount of funds and change price\r\n        (uint funds, uint _price) = tokensToFunds(fee_tokens);\r\n        require(funds != 0, \"Insufficient tokens to do that\");\r\n        price = _price;\r\n\r\n        // burn and mint tokens excluding fee\r\n        burnTokens(msg.sender, tokens);\r\n        mintTokens(to_addr, taxed_tokens);\r\n\r\n        // increase shared profit\r\n        shared_profit = shared_profit.add(funds);\r\n\r\n        emit Transfer(msg.sender, to_addr, tokens);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * @dev Reinvest all dividends\r\n    */\r\n    function reinvest() public {\r\n\r\n        // get all dividends\r\n        uint funds = dividendsOf(msg.sender);\r\n        require(funds > 0, \"You have no dividends\");\r\n\r\n        // make correction, dividents will be 0 after that\r\n        UserRecord storage user = user_data[msg.sender];\r\n        user.funds_correction = user.funds_correction.add(int(funds));\r\n\r\n        // apply fee\r\n        (uint fee_funds, uint taxed_funds) = fee_purchase.split(funds);\r\n        require(fee_funds != 0, \"Insufficient dividends to do that\");\r\n\r\n        // apply referral bonus\r\n        if (user.referrer != 0x0) {\r\n            fee_funds = rewardReferrer(msg.sender, user.referrer, fee_funds, funds);\r\n            require(fee_funds != 0, \"Insufficient dividends to do that\");\r\n        }\r\n\r\n        // calculate amount of tokens and change price\r\n        (uint tokens, uint _price) = fundsToTokens(taxed_funds);\r\n        require(tokens != 0, \"Insufficient dividends to do that\");\r\n        price = _price;\r\n\r\n        // mint tokens and increase shared profit\r\n        mintTokens(msg.sender, tokens);\r\n        shared_profit = shared_profit.add(fee_funds);\r\n\r\n        emit Reinvestment(msg.sender, funds, tokens, price / precision_factor, now);\r\n    }\r\n\r\n    /*\r\n    * @dev Withdraw all dividends\r\n    */\r\n    function withdraw() public {\r\n\r\n        // get all dividends\r\n        uint funds = dividendsOf(msg.sender);\r\n        require(funds > 0, \"You have no dividends\");\r\n\r\n        // make correction, dividents will be 0 after that\r\n        UserRecord storage user = user_data[msg.sender];\r\n        user.funds_correction = user.funds_correction.add(int(funds));\r\n\r\n        // send funds\r\n        msg.sender.transfer(funds);\r\n\r\n        emit Withdrawal(msg.sender, funds, now);\r\n    }\r\n\r\n    /*\r\n    * @dev Sell all tokens and withraw dividends\r\n    */\r\n    function exit() public {\r\n\r\n        // sell all tokens\r\n        uint tokens = user_data[msg.sender].tokens;\r\n        if (tokens > 0) {\r\n            sell(tokens);\r\n        }\r\n\r\n        withdraw();\r\n    }\r\n\r\n    /*\r\n    * @dev CAUTION! This method distributes all incoming funds between token's holders and gives you nothing\r\n    * It will be used by another contracts/addresses from our ecosystem in future\r\n    * But if you want to donate, you're welcome :)\r\n    */\r\n    function donate() public payable {\r\n        shared_profit = shared_profit.add(msg.value);\r\n        emit Donation(msg.sender, msg.value, now);\r\n    }\r\n\r\n    // ---- Read methods ---- //\r\n\r\n    /*\r\n    * @dev Total amount of tokens\r\n    * ERC20\r\n    */\r\n    function totalSupply() public view returns (uint) {\r\n        return total_supply;\r\n    }\r\n\r\n    /*\r\n    * @dev Amount of user's tokens\r\n    * ERC20\r\n    */\r\n    function balanceOf(address addr) public view returns (uint) {\r\n        return user_data[addr].tokens;\r\n    }\r\n\r\n    /*\r\n    * @dev Amount of user's dividends\r\n    */\r\n    function dividendsOf(address addr) public view returns (uint) {\r\n\r\n        UserRecord memory user = user_data[addr];\r\n\r\n        // gained funds from selling tokens + bonus funds from referrals\r\n        // int because \"user.funds_correction\" can be negative\r\n        int d = int(user.gained_funds.add(user.ref_funds));\r\n        require(d >= 0);\r\n\r\n        // avoid zero divizion\r\n        if (total_supply > 0) {\r\n            // profit is proportional to stake\r\n            d = d.add(int(shared_profit.mul(user.tokens) / total_supply));\r\n        }\r\n\r\n        // correction\r\n        // d -= user.funds_correction\r\n        if (user.funds_correction > 0) {\r\n            d = d.sub(user.funds_correction);\r\n        }\r\n        else if (user.funds_correction < 0) {\r\n            d = d.add(-user.funds_correction);\r\n        }\r\n\r\n        // just in case\r\n        require(d >= 0);\r\n\r\n        // total sum must be positive uint\r\n        return uint(d);\r\n    }\r\n\r\n    /*\r\n    * @dev Amount of tokens can be gained from given amount of funds\r\n    */\r\n    function expectedTokens(uint funds, bool apply_fee) public view returns (uint) {\r\n        if (funds == 0) {\r\n            return 0;\r\n        }\r\n        if (apply_fee) {\r\n            (,uint _funds) = fee_purchase.split(funds);\r\n            funds = _funds;\r\n        }\r\n        (uint tokens,) = fundsToTokens(funds);\r\n        return tokens;\r\n    }\r\n\r\n    /*\r\n    * @dev Amount of funds can be gained from given amount of tokens\r\n    */\r\n    function expectedFunds(uint tokens, bool apply_fee) public view returns (uint) {\r\n        // empty tokens in total OR no tokens was sold\r\n        if (tokens == 0 || total_supply == 0) {\r\n            return 0;\r\n        }\r\n        // more tokens than were mined in total, just exclude unnecessary tokens from calculating\r\n        else if (tokens > total_supply) {\r\n            tokens = total_supply;\r\n        }\r\n        (uint funds,) = tokensToFunds(tokens);\r\n        if (apply_fee) {\r\n            (,uint _funds) = fee_selling.split(funds);\r\n            funds = _funds;\r\n        }\r\n        return funds;\r\n    }\r\n\r\n    /*\r\n    * @dev Purchase price of next 1 token\r\n    */\r\n    function buyPrice() public view returns (uint) {\r\n        return price / precision_factor;\r\n    }\r\n\r\n    /*\r\n    * @dev Selling price of next 1 token\r\n    */\r\n    function sellPrice() public view returns (uint) {\r\n        return price.sub(price_offset) / precision_factor;\r\n    }\r\n\r\n    // ==== Private API ==== //\r\n\r\n    /*\r\n    * @dev Mint given amount of tokens to given user\r\n    */\r\n    function mintTokens(address addr, uint tokens) internal {\r\n\r\n        UserRecord storage user = user_data[addr];\r\n\r\n        bool not_first_minting = total_supply > 0;\r\n\r\n        // make correction to keep dividends the rest of the users\r\n        if (not_first_minting) {\r\n            shared_profit = shared_profit.mul(total_supply.add(tokens)) / total_supply;\r\n        }\r\n\r\n        // add tokens\r\n        total_supply = total_supply.add(tokens);\r\n        user.tokens = user.tokens.add(tokens);\r\n\r\n        // make correction to keep dividends of user\r\n        if (not_first_minting) {\r\n            user.funds_correction = user.funds_correction.add(int(tokens.mul(shared_profit) / total_supply));\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Burn given amout of tokens from given user\r\n    */\r\n    function burnTokens(address addr, uint tokens) internal {\r\n\r\n        UserRecord storage user = user_data[addr];\r\n\r\n        // keep current dividents of user if last tokens will be burned\r\n        uint dividends_from_tokens = 0;\r\n        if (total_supply == tokens) {\r\n            dividends_from_tokens = shared_profit.mul(user.tokens) / total_supply;\r\n        }\r\n\r\n        // make correction to keep dividends the rest of the users\r\n        shared_profit = shared_profit.mul(total_supply.sub(tokens)) / total_supply;\r\n\r\n        // sub tokens\r\n        total_supply = total_supply.sub(tokens);\r\n        user.tokens = user.tokens.sub(tokens);\r\n\r\n        // make correction to keep dividends of the user\r\n        // if burned not last tokens\r\n        if (total_supply > 0) {\r\n            user.funds_correction = user.funds_correction.sub(int(tokens.mul(shared_profit) / total_supply));\r\n        }\r\n        // if burned last tokens\r\n        else if (dividends_from_tokens != 0) {\r\n            user.funds_correction = user.funds_correction.sub(int(dividends_from_tokens));\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Rewards the referrer from given amount of funds\r\n     */\r\n    function rewardReferrer(address addr, address referrer_addr, uint funds, uint full_funds) internal returns (uint funds_after_reward) {\r\n        UserRecord storage referrer = user_data[referrer_addr];\r\n        if (referrer.tokens >= minimal_stake) {\r\n            (uint reward_funds, uint taxed_funds) = fee_referral.split(funds);\r\n            referrer.ref_funds = referrer.ref_funds.add(reward_funds);\r\n            emit ReferralReward(addr, referrer_addr, full_funds, reward_funds, now);\r\n            return taxed_funds;\r\n        }\r\n        else {\r\n            return funds;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Calculate tokens from funds\r\n    *\r\n    * Given:\r\n    *   a[1] = price\r\n    *   d = price_offset\r\n    *   sum(n) = funds\r\n    * Here is used arithmetic progression's equation transformed to a quadratic equation:\r\n    *   a * n^2 + b * n + c = 0\r\n    * Where:\r\n    *   a = d\r\n    *   b = 2 * a[1] - d\r\n    *   c = -2 * sum(n)\r\n    * Solve it and first root is what we need - amount of tokens\r\n    * So:\r\n    *   tokens = n\r\n    *   price = a[n+1]\r\n    *\r\n    * For details see method below\r\n    */\r\n    function fundsToTokens(uint funds) internal view returns (uint tokens, uint _price) {\r\n        uint b = price.mul(2).sub(price_offset);\r\n        uint D = b.mul(b).add(price_offset.mul(8).mul(funds).mul(precision_factor));\r\n        uint n = D.sqrt().sub(b).mul(precision_factor) / price_offset.mul(2);\r\n        uint anp1 = price.add(price_offset.mul(n) / precision_factor);\r\n        return (n, anp1);\r\n    }\r\n\r\n    /*\r\n    * @dev Calculate funds from tokens\r\n    *\r\n    * Given:\r\n    *   a[1] = sell_price\r\n    *   d = price_offset\r\n    *   n = tokens\r\n    * Here is used arithmetic progression's equation (-d because of d must be negative to reduce price):\r\n    *   a[n] = a[1] - d * (n - 1)\r\n    *   sum(n) = (a[1] + a[n]) * n / 2\r\n    * So:\r\n    *   funds = sum(n)\r\n    *   price = a[n]\r\n    *\r\n    * For details see method above\r\n    */\r\n    function tokensToFunds(uint tokens) internal view returns (uint funds, uint _price) {\r\n        uint sell_price = price.sub(price_offset);\r\n        uint an = sell_price.add(price_offset).sub(price_offset.mul(tokens) / precision_factor);\r\n        uint sn = sell_price.add(an).mul(tokens) / precision_factor.mul(2);\r\n        return (sn / precision_factor, an);\r\n    }\r\n\r\n    // ==== Events ==== //\r\n\r\n    event Purchase(address indexed addr, uint funds, uint tokens, uint price, uint time);\r\n    event Selling(address indexed addr, uint tokens, uint funds, uint price, uint time);\r\n    event Reinvestment(address indexed addr, uint funds, uint tokens, uint price, uint time);\r\n    event Withdrawal(address indexed addr, uint funds, uint time);\r\n    event Donation(address indexed addr, uint funds, uint time);\r\n    event ReferralReward(address indexed referral_addr, address indexed referrer_addr, uint funds, uint reward_funds, uint time);\r\n\r\n    //ERC20\r\n    event Transfer(address indexed from_addr, address indexed to_addr, uint tokens);\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers\r\n    */\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        require(c / a == b, \"mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers\r\n    */\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        require(b <= a, \"sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers\r\n    */\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Gives square root from number\r\n     */\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = add(x, 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = add(x / z, z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMathInt {\r\n\r\n    /**\r\n    * @dev Subtracts two numbers\r\n    */\r\n    function sub(int a, int b) internal pure returns (int) {\r\n        int c = a - b;\r\n        require(c <= a, \"sub failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers\r\n    */\r\n    function add(int a, int b) internal pure returns (int) {\r\n        int c = a + b;\r\n        require(c >= a, \"add failed\");\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Fee {\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct fee {\r\n        uint num;\r\n        uint den;\r\n    }\r\n\r\n    /*\r\n    * @dev Splits given value to two parts: tax itself and taxed value\r\n    */\r\n    function split(fee memory f, uint value) internal pure returns (uint tax, uint taxed_value) {\r\n        if (value == 0) {\r\n            return (0, 0);\r\n        }\r\n        tax = value.mul(f.num) / f.den;\r\n        taxed_value = value.sub(tax);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns only tax part\r\n    */\r\n    function get_tax(fee memory f, uint value) internal pure returns (uint tax) {\r\n        if (value == 0) {\r\n            return 0;\r\n        }\r\n        tax = value.mul(f.num) / f.den;\r\n    }\r\n}\r\n\r\nlibrary ToAddress {\r\n\r\n    /*\r\n    * @dev Transforms bytes to address\r\n    */\r\n    function toAddr(bytes source) internal pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(source, 0x14))\r\n        }\r\n        return addr;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to_addr\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"apply_fee\",\"type\":\"bool\"}],\"name\":\"expectedFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"funds\",\"type\":\"uint256\"},{\"name\":\"apply_fee\",\"type\":\"bool\"}],\"name\":\"expectedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"funds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"funds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Selling\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"funds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Reinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"funds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"funds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Donation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"referral_addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"funds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reward_funds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"ReferralReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from_addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "PantheonEcoSystem", "CompilerVersion": "v0.4.25+commit.59dbf8f1", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://d955d83e2f50a5c7177643dd267b780a8970bb1eab8c7cc7e550b3edf856cb5f"}