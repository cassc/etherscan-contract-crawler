// SPDX-License-Identifier: GPL-3.0-only
pragma solidity ^0.8.0;

library DragonInfo {
    
    uint constant MASK = 0xF000000000000000000000000;

    enum Types { 
        Unknown,
        Common, 
        Rare16, 
        Rare17, 
        Rare18, 
        Rare19,
        Epic20, 
        Epic21,
        Epic22,
        Epic23,
        Epic24, 
        Legendary
    }

    struct Details { 
        uint genes;
        uint eggId;
        uint parent1Id;
        uint parent2Id;
        uint generation;
        uint strength;
        Types dragonType;
    }

    function getDetails(uint value) internal pure returns (Details memory) {
        return Details (
            {
                genes: uint256(uint104(value)),
                parent1Id: uint256(uint32(value >> 104)),
                parent2Id: uint256(uint32(value >> 136)),
                generation: uint256(uint16(value >> 168)),
                strength: uint256(uint16(value >> 184)),
                dragonType: Types(uint16(value >> 200)),
                eggId: uint256(uint32(value >> 216))
            }
        );
    }

    function getValue(Details memory details) internal pure returns (uint) {
        uint result = uint(details.genes);
        result |= details.parent1Id << 104;
        result |= details.parent2Id << 136;
        result |= details.generation << 168;
        result |= details.strength << 184;
        result |= uint(details.dragonType) << 200;
        result |= details.eggId << 216;
        return result;
    }

    function calcType(uint genes) internal pure returns (Types) {
        uint mask = MASK;
        uint numRare = 0;
        uint numEpic = 0;
        for (uint i = 0; i < 10; i++) { //just Rare and Epic genes are important to check
            if (genes & mask > 0) {
                if (i < 5) { //Epic-range
                    numEpic++;
                }
                else { //Rare-range
                    numRare++;
                }
            }
            mask = mask >> 4;
        }
        Types result = Types.Unknown;
        if (numEpic == 5 && numRare == 5) {
            result = Types.Legendary;
        }
        else if (numEpic < 5 && numRare == 5) {
            result = Types(6 + numEpic);
        }
        else if (numEpic == 0 && numRare < 5) {
            result = Types(1 + numRare);
        }
        else if (numEpic == 0 && numRare == 0) {
            result = Types.Common;
        }

        return result;
    }

    function calcStrength(uint genes) internal pure returns (uint) {
        uint mask = MASK;
        uint strength = 0;
        for (uint i = 0; i < 25; i++) { 
            uint gLevel = (genes & mask) >> ((24 - i) * 4);
            if (i < 6) { //Epic
                strength += 3 * (25 - i) * gLevel;
            } 
            else if (i < 10) { //Rare 
                strength += 2 * (25 - i) * gLevel;
            }
            else { //Common-range
                if (gLevel > 0) {
                    strength += (25 - i) * gLevel;
                }
                else {
                    strength += (25 - i);
                }
            }
            mask = mask >> 4;
        }
        return strength;
    }

    function calcGeneration(uint g1, uint g2) internal pure returns (uint) {
        return (g1 >= g2 ? g1 : g2) + 1;
    }
}