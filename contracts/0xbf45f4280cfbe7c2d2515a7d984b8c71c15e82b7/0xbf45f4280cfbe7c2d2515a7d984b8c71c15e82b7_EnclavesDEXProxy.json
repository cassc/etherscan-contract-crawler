{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\n// File: contracts/EtherDeltaI.sol\r\n\r\ncontract EtherDeltaI {\r\n\r\n  uint public feeMake; //percentage times (1 ether)\r\n  uint public feeTake; //percentage times (1 ether)\r\n\r\n  mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n\r\n  function deposit() payable;\r\n\r\n  function withdraw(uint amount);\r\n\r\n  function depositToken(address token, uint amount);\r\n\r\n  function withdrawToken(address token, uint amount);\r\n\r\n  function balanceOf(address token, address user) constant returns (uint);\r\n\r\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce);\r\n\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount);\r\n\r\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool);\r\n\r\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\r\n\r\n  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint);\r\n\r\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s);\r\n\r\n}\r\n\r\n// File: contracts/KindMath.sol\r\n\r\n/**\r\n * @title KindMath\r\n * @dev Math operations with safety checks that fail\r\n */\r\nlibrary KindMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    require(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/KeyValueStorage.sol\r\n\r\ncontract KeyValueStorage {\r\n\r\n  mapping(address => mapping(bytes32 => uint256)) _uintStorage;\r\n  mapping(address => mapping(bytes32 => address)) _addressStorage;\r\n  mapping(address => mapping(bytes32 => bool)) _boolStorage;\r\n  mapping(address => mapping(bytes32 => bytes32)) _bytes32Storage;\r\n\r\n  /**** Get Methods ***********/\r\n\r\n  function getAddress(bytes32 key) public view returns (address) {\r\n      return _addressStorage[msg.sender][key];\r\n  }\r\n\r\n  function getUint(bytes32 key) public view returns (uint) {\r\n      return _uintStorage[msg.sender][key];\r\n  }\r\n\r\n  function getBool(bytes32 key) public view returns (bool) {\r\n      return _boolStorage[msg.sender][key];\r\n  }\r\n\r\n  function getBytes32(bytes32 key) public view returns (bytes32) {\r\n      return _bytes32Storage[msg.sender][key];\r\n  }\r\n\r\n  /**** Set Methods ***********/\r\n\r\n  function setAddress(bytes32 key, address value) public {\r\n      _addressStorage[msg.sender][key] = value;\r\n  }\r\n\r\n  function setUint(bytes32 key, uint value) public {\r\n      _uintStorage[msg.sender][key] = value;\r\n  }\r\n\r\n  function setBool(bytes32 key, bool value) public {\r\n      _boolStorage[msg.sender][key] = value;\r\n  }\r\n\r\n  function setBytes32(bytes32 key, bytes32 value) public {\r\n      _bytes32Storage[msg.sender][key] = value;\r\n  }\r\n\r\n  /**** Delete Methods ***********/\r\n\r\n  function deleteAddress(bytes32 key) public {\r\n      delete _addressStorage[msg.sender][key];\r\n  }\r\n\r\n  function deleteUint(bytes32 key) public {\r\n      delete _uintStorage[msg.sender][key];\r\n  }\r\n\r\n  function deleteBool(bytes32 key) public {\r\n      delete _boolStorage[msg.sender][key];\r\n  }\r\n\r\n  function deleteBytes32(bytes32 key) public {\r\n      delete _bytes32Storage[msg.sender][key];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/StorageStateful.sol\r\n\r\ncontract StorageStateful {\r\n  KeyValueStorage public keyValueStorage;\r\n}\r\n\r\n// File: contracts/StorageConsumer.sol\r\n\r\ncontract StorageConsumer is StorageStateful {\r\n  function StorageConsumer(address _storageAddress) public {\r\n    require(_storageAddress != address(0));\r\n    keyValueStorage = KeyValueStorage(_storageAddress);\r\n  }\r\n}\r\n\r\n// File: contracts/TokenI.sol\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() public returns (uint256);\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) public returns (uint256);\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) public returns (uint256);\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint256 public decimals;\r\n  string public name;\r\n}\r\n\r\n// File: contracts/EnclavesDEXProxy.sol\r\n\r\ncontract EnclavesDEXProxy is StorageConsumer {\r\n  using KindMath for uint256;\r\n\r\n  address public admin; //the admin address\r\n  address public feeAccount; //the account that will receive fees\r\n\r\n  struct EtherDeltaInfo {\r\n    uint256 feeMake;\r\n    uint256 feeTake;\r\n  }\r\n\r\n  EtherDeltaInfo public etherDeltaInfo;\r\n\r\n  uint256 public feeTake; //percentage times 1 ether\r\n  uint256 public feeAmountThreshold; //gasPrice amount under which no fees are charged\r\n\r\n  address public etherDelta;\r\n\r\n  bool public useEIP712 = true;\r\n  bytes32 public tradeABIHash;\r\n  bytes32 public withdrawABIHash;\r\n\r\n  bool freezeTrading;\r\n  bool depositTokenLock;\r\n\r\n  mapping (address => mapping (uint256 => bool)) nonceCheck;\r\n\r\n  mapping (address => mapping (address => uint256)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)\r\n  mapping (address => mapping (bytes32 => bool)) public orders; //mapping of user accounts to mapping of order hashes to booleans (true = submitted by user, equivalent to offchain signature)\r\n  mapping (address => mapping (bytes32 => uint256)) public orderFills; //mapping of user accounts to mapping of order hashes to uints (amount of order that has been filled)\r\n\r\n  address internal implementation;\r\n  address public proposedImplementation;\r\n  uint256 public proposedTimestamp;\r\n\r\n  event Upgraded(address _implementation);\r\n  event UpgradedProposed(address _proposedImplementation, uint256 _proposedTimestamp);\r\n\r\n  modifier onlyAdmin {\r\n    require(msg.sender == admin);\r\n    _;\r\n  }\r\n\r\n  function EnclavesDEXProxy(address _storageAddress, address _implementation, address _admin, address _feeAccount, uint256 _feeTake, uint256 _feeAmountThreshold, address _etherDelta, bytes32 _tradeABIHash, bytes32 _withdrawABIHash) public\r\n    StorageConsumer(_storageAddress)\r\n  {\r\n    require(_implementation != address(0));\r\n    implementation = _implementation;\r\n    admin = _admin;\r\n    feeAccount = _feeAccount;\r\n    feeTake = _feeTake;\r\n    feeAmountThreshold = _feeAmountThreshold;\r\n    etherDelta = _etherDelta;\r\n    tradeABIHash = _tradeABIHash;\r\n    withdrawABIHash = _withdrawABIHash;\r\n    etherDeltaInfo.feeMake = EtherDeltaI(etherDelta).feeMake();\r\n    etherDeltaInfo.feeTake = EtherDeltaI(etherDelta).feeTake();\r\n  }\r\n\r\n  function getImplementation() public view returns(address) {\r\n    return implementation;\r\n  }\r\n\r\n  function proposeUpgrade(address _proposedImplementation) public onlyAdmin {\r\n    require(implementation != _proposedImplementation);\r\n    require(_proposedImplementation != address(0));\r\n    proposedImplementation = _proposedImplementation;\r\n    proposedTimestamp = now + 2 weeks;\r\n    UpgradedProposed(proposedImplementation, now);\r\n  }\r\n\r\n  function upgrade() public onlyAdmin {\r\n    require(proposedImplementation != address(0));\r\n    require(proposedTimestamp < now);\r\n    implementation = proposedImplementation;\r\n    Upgraded(implementation);\r\n  }\r\n\r\n  function () payable public {\r\n    bytes memory data = msg.data;\r\n    address impl = getImplementation();\r\n\r\n    assembly {\r\n      let result := delegatecall(gas, impl, add(data, 0x20), mload(data), 0, 0)\r\n      let size := returndatasize\r\n      let ptr := mload(0x40)\r\n      returndatacopy(ptr, 0, size)\r\n      switch result\r\n      case 0 { revert(ptr, size) }\r\n      default { return(ptr, size) }\r\n    }\r\n  }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderFills\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherDeltaInfo\",\"outputs\":[{\"name\":\"feeMake\",\"type\":\"uint256\"},{\"name\":\"feeTake\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAmountThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"useEIP712\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keyValueStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradeABIHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedImplementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orders\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeTake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposedImplementation\",\"type\":\"address\"}],\"name\":\"proposeUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherDelta\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawABIHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_storageAddress\",\"type\":\"address\"},{\"name\":\"_implementation\",\"type\":\"address\"},{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_feeAccount\",\"type\":\"address\"},{\"name\":\"_feeTake\",\"type\":\"uint256\"},{\"name\":\"_feeAmountThreshold\",\"type\":\"uint256\"},{\"name\":\"_etherDelta\",\"type\":\"address\"},{\"name\":\"_tradeABIHash\",\"type\":\"bytes32\"},{\"name\":\"_withdrawABIHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_proposedImplementation\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_proposedTimestamp\",\"type\":\"uint256\"}],\"name\":\"UpgradedProposed\",\"type\":\"event\"}]", "ContractName": "EnclavesDEXProxy", "CompilerVersion": "v0.4.21+commit.dfe3193c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000129caf12c70fe9633fe24b15497adafc913c842c000000000000000000000000ed06d46ffb309128c4458a270c99c824dc127f5d000000000000000000000000e03793e63776cf69fe42414ed03bb924d4d9157e000000000000000000000000e03793e63776cf69fe42414ed03bb924d4d9157e00000000000000000000000000000000000000000000000000071afd498d0000000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000008d12a197cb00d4747a1fe03395095ce2a5cc681957d54158692b43b05f55462695c3dc04b0217afddfda3f27a07ec31ee46b9c20369521fb20e3cff93d515dad43dc9f9f23dfdbb8d0ca564c480634d401bf9aa1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xed06d46ffb309128c4458a270c99c824dc127f5d", "SwarmSource": "bzzr://748c3fd36452cba2982dabc925ed50191b752dc57a2492bded2e68ee07306ed2"}