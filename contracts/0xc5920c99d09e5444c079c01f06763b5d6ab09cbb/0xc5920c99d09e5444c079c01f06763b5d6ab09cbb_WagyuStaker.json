{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/WagyuStaker.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\nimport { ITinyMevEth } from \\\"./interfaces/ITinyMevEth.sol\\\";\\nimport { IStakingModule } from \\\"./interfaces/IStakingModule.sol\\\";\\nimport { IBeaconDepositContract } from \\\"./interfaces/IBeaconDepositContract.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport { Auth } from \\\"./libraries/Auth.sol\\\";\\nimport { ERC20 } from \\\"solmate/tokens/ERC20.sol\\\";\\nimport { MevEthErrors } from \\\"./interfaces/Errors.sol\\\";\\n\\n/// @title \ud83e\udd69 Wagyu Staker \ud83e\udd69\\n/// @dev This contract stakes Ether inside of the BeaconChainDepositContract directly\\ncontract WagyuStaker is Auth, IStakingModule {\\n    using SafeTransferLib for ERC20;\\n\\n    struct Record {\\n        uint128 totalDeposited;\\n        uint128 totalWithdrawn;\\n        uint128 totalRewardsPaid;\\n        uint128 totalValidatorExitsPaid;\\n    }\\n\\n    /// @notice Record of total deposits, withdraws, rewards paid and validators exited\\n    Record public record;\\n    /// @notice The number of validators on the consensus layer registered under this contract\\n    uint256 public validators;\\n    /// @notice The address of the MevEth contract\\n    address public mevEth;\\n    /// @notice Validator deposit size.\\n    uint256 public constant override VALIDATOR_DEPOSIT_SIZE = 32 ether;\\n    /// @notice The Canonical Address of the BeaconChainDepositContract\\n    IBeaconDepositContract public immutable BEACON_CHAIN_DEPOSIT_CONTRACT;\\n\\n    /// @notice Event emitted when a validator is registered\\n    event NewValidator(address indexed operator, bytes pubkey, bytes32 withdrawalCredentials, bytes signature, bytes32 deposit_data_root);\\n    /// @notice Event emitted when tokens are recovered from the contract.\\n    event TokenRecovered(address indexed recipient, address indexed token, uint256 indexed amount);\\n    /// @notice Event emitted when rewards are paid to the MevEth contract.\\n    event RewardsPaid(uint256 indexed amount);\\n    /// @notice Event emitted when funds representing a validator withdrawal are sent to the MevEth contract.\\n    event ValidatorWithdraw(address sender, uint256 amount);\\n    /// @notice Event emitted when the mevEth address is updated.\\n    event MevEthUpdated(address indexed meveth);\\n\\n    /// @notice Construction sets authority, MevEth, and deposit contract addresses\\n    /// @param _authority The address of the controlling admin authority\\n    /// @param _depositContract The address of the beacon deposit contract\\n    /// @param _mevEth The address of the mevETH contract\\n    constructor(address _authority, address _depositContract, address _mevEth) Auth(_authority) {\\n        mevEth = _mevEth;\\n        BEACON_CHAIN_DEPOSIT_CONTRACT = IBeaconDepositContract(_depositContract);\\n    }\\n\\n    /// @notice Function to deposit funds into the BEACON_CHAIN_DEPOSIT_CONTRACT, and register a validator\\n    function deposit(IStakingModule.ValidatorData calldata data, bytes32 latestDepositRoot) external payable {\\n        // Only the MevEth contract can call this function\\n        if (msg.sender != mevEth) {\\n            revert MevEthErrors.UnAuthorizedCaller();\\n        }\\n        // Ensure the deposit amount is equal to the VALIDATOR_DEPOSIT_SIZE\\n        if (msg.value != VALIDATOR_DEPOSIT_SIZE) {\\n            revert MevEthErrors.WrongDepositAmount();\\n        }\\n        if (BEACON_CHAIN_DEPOSIT_CONTRACT.get_deposit_root() != latestDepositRoot) {\\n            revert MevEthErrors.DepositWasFrontrun();\\n        }\\n\\n        // Update the contract balance and validator count\\n        unchecked {\\n            record.totalDeposited += uint128(VALIDATOR_DEPOSIT_SIZE);\\n            validators += 1;\\n        }\\n\\n        // Deposit the funds into the BeaconChainDepositContract\\n        BEACON_CHAIN_DEPOSIT_CONTRACT.deposit{ value: VALIDATOR_DEPOSIT_SIZE }(\\n            data.pubkey, abi.encodePacked(data.withdrawal_credentials), data.signature, data.deposit_data_root\\n        );\\n\\n        // Emit an event inidicating a new validator has been registered, allowing for offchain listeners to track the validator registry\\n        emit NewValidator(data.operator, data.pubkey, data.withdrawal_credentials, data.signature, data.deposit_data_root);\\n    }\\n\\n    /// @notice Function to pay rewards to the MevEth contract\\n    /// @dev Only callable by an operator\\n    /// @param rewards rewards to pay to the MevEth contract\\n    function payRewards(uint256 rewards) external onlyOperator {\\n        if (rewards > address(this).balance) revert MevEthErrors.NotEnoughEth();\\n\\n        unchecked {\\n            record.totalRewardsPaid += uint128(rewards);\\n            // lagging withdrawn indicator, as including in receive can cause transfer out of gas\\n            record.totalWithdrawn += uint128(rewards);\\n        }\\n\\n        // Send the rewards to the MevEth contract\\n        ITinyMevEth(mevEth).grantRewards{ value: rewards }();\\n\\n        // Emit an event to track the rewards paid\\n        emit RewardsPaid(rewards);\\n    }\\n\\n    function registerExit() external {\\n        // Only the MevEth contract can call this function\\n        if (msg.sender != mevEth) {\\n            revert MevEthErrors.UnAuthorizedCaller();\\n        }\\n        uint128 exitSize = uint128(VALIDATOR_DEPOSIT_SIZE);\\n        unchecked {\\n            record.totalValidatorExitsPaid += exitSize;\\n            // lagging withdrawn indicator, as including in receive can cause transfer out of gas\\n            record.totalWithdrawn += exitSize;\\n        }\\n        if (validators > 0) {\\n            unchecked {\\n                validators -= 1;\\n            }\\n        }\\n    }\\n\\n    /// @notice Function to pay MevEth when withdrawing funds from a validator\\n    /// @dev This function is only callable by an operator and emits an event for offchain validator registry tracking.\\n    function payValidatorWithdraw() external onlyOperator {\\n        uint256 exitSize = VALIDATOR_DEPOSIT_SIZE;\\n        if (exitSize > address(this).balance) revert MevEthErrors.NotEnoughEth();\\n        ITinyMevEth(mevEth).grantValidatorWithdraw{ value: exitSize }();\\n        emit ValidatorWithdraw(msg.sender, exitSize);\\n    }\\n\\n    /// @notice Function to recover tokens sent to the contract.\\n    /// @dev This function is only callable by an admin.\\n    function recoverToken(address token, address recipient, uint256 amount) external onlyAdmin {\\n        ERC20(token).safeTransfer(recipient, amount);\\n        emit TokenRecovered(recipient, token, amount);\\n    }\\n\\n    /// @notice Function to set a new mevEth address.\\n    function setNewMevEth(address newMevEth) external onlyAdmin {\\n        if (newMevEth == address(0)) {\\n            revert MevEthErrors.ZeroAddress();\\n        }\\n        mevEth = newMevEth;\\n        emit MevEthUpdated(newMevEth);\\n    }\\n\\n    /// @notice Batch register Validators for migration\\n    /// @dev only Admin\\n    /// @param batchData list of each validators' data struct\\n    function batchMigrate(IStakingModule.ValidatorData[] calldata batchData) external onlyAdmin {\\n        uint256 length = batchData.length;\\n        // Update the contract balance and validator count\\n        unchecked {\\n            record.totalDeposited += uint128(length * VALIDATOR_DEPOSIT_SIZE);\\n            validators += length;\\n        }\\n\\n        for (uint256 i = 0; i < length;) {\\n            IStakingModule.ValidatorData calldata data = batchData[i];\\n            // Emit an event inidicating a new validator has been registered, allowing for offchain listeners to track the validator registry\\n            emit NewValidator(data.operator, data.pubkey, data.withdrawal_credentials, data.signature, data.deposit_data_root);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /// @notice Function to receive Ether\\n    receive() external payable { }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ITinyMevEth.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\n/// @title TinyMevEth\\n/// @notice smol interface for interacting with MevEth\\ninterface ITinyMevEth {\\n    /**\\n     * @dev Function to grant rewards to other users.\\n     * @notice This function is payable and should be called with the amount of rewards to be granted.\\n     */\\n    function grantRewards() external payable;\\n    /**\\n     * @dev Function to allow a validator to withdraw funds from the contract.\\n     * @notice This function must be called with a validator address and a payable amount.\\n     */\\n    function grantValidatorWithdraw() external payable;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStakingModule.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\ninterface IStakingModule {\\n    /**\\n     * @dev Structure for passing information about the validator deposit data.\\n     * @param operator - address of the operator.\\n     * @param pubkey - BLS public key of the validator, generated by the operator.\\n     * @param withdrawal_credentials - withdrawal credentials used for generating the deposit data.\\n     * @param signature - BLS signature of the validator, generated by the operator.\\n     * @param deposit_data_root - hash tree root of the deposit data, generated by the operator.\\n     */\\n    struct ValidatorData {\\n        address operator;\\n        bytes pubkey;\\n        bytes32 withdrawal_credentials;\\n        bytes signature;\\n        bytes32 deposit_data_root; // more efficient to be calculated off-chain\\n    }\\n\\n    /**\\n     * @dev Allows users to deposit funds into the contract.\\n     * @param data ValidatorData calldata containing the validator's public key, withdrawal credentials, and amount of tokens to be deposited.\\n     * @param latestDepositRoot bytes32 containing the latest deposit root.\\n     */\\n    function deposit(ValidatorData calldata data, bytes32 latestDepositRoot) external payable;\\n\\n    function validators() external view returns (uint256);\\n\\n    function mevEth() external view returns (address);\\n\\n    /**\\n     * @notice VALIDATOR_DEPOSIT_SIZE()\\n     *\\n     * This function returns the size of the validator deposit.\\n     *\\n     * @dev This function is used to determine the size of the validator deposit. It is used to ensure that validators have the correct amount of funds in order\\n     * to participate in the network.\\n     */\\n    function VALIDATOR_DEPOSIT_SIZE() external view returns (uint256);\\n\\n    // onlyAdmin Functions\\n    /**\\n     * @notice This function is used to pay rewards to the users.\\n     * @dev This function is used to pay rewards to the users. It takes in a uint256 rewards parameter which is the amount of rewards to be paid.\\n     */\\n    function payRewards(uint256 rewards) external;\\n    /**\\n     * @notice This function allows a validator to withdraw their rewards from the contract.\\n     * @dev This function is called by a validator to withdraw their rewards from the contract. It will transfer the rewards to the validator's address.\\n     */\\n    function payValidatorWithdraw() external;\\n    function recoverToken(address token, address recipient, uint256 amount) external;\\n    /**\\n     * @notice record() function is used to record the data in the smart contract.\\n     * @dev record() function takes no parameters and returns four uint128 values.\\n     */\\n    function record() external returns (uint128, uint128, uint128, uint128);\\n    /**\\n     * @notice registerExit() allows users to exit the system.\\n     * @dev registerExit() is a function that allows users to exit the system. It is triggered by an external call.\\n     */\\n    function registerExit() external;\\n\\n    function batchMigrate(IStakingModule.ValidatorData[] calldata batchData) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBeaconDepositContract.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\n/// Interface for the Beacon Chain Deposit Contract\\ninterface IBeaconDepositContract {\\n    /// @notice Submit a Phase 0 DepositData object.\\n    /// @param pubkey A BLS12-381 public key.\\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\\n    /// @param signature A BLS12-381 signature.\\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n\\n    /// Used as a protection against malformed input.\\n    function deposit(bytes calldata pubkey, bytes calldata withdrawal_credentials, bytes calldata signature, bytes32 deposit_data_root) external payable;\\n\\n    /// @notice Query the current deposit root hash.\\n    /// @return The deposit root hash.\\n    function get_deposit_root() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, from) // Append the \\\"from\\\" argument.\\n            mstore(36, to) // Append the \\\"to\\\" argument.\\n            mstore(68, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because that's the total length of our calldata (4 + 32 * 3)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 100, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // We'll write our calldata to this slot below, but restore it later.\\n            let memPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(0, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(4, to) // Append the \\\"to\\\" argument.\\n            mstore(36, amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because that's the total length of our calldata (4 + 32 * 2)\\n                // Counterintuitively, this call() must be positioned after the or() in the\\n                // surrounding and() because and() evaluates its arguments from right to left.\\n                call(gas(), token, 0, 0, 68, 0, 32)\\n            )\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, memPointer) // Restore the memPointer.\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Auth.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\ncontract Auth {\\n    error Unauthorized();\\n    error AlreadySet();\\n    error NoAdmin();\\n\\n    event AdminAdded(address indexed newAdmin);\\n    event AdminDeleted(address indexed oldAdmin);\\n    event OperatorAdded(address indexed newOperator);\\n    event OperatorDeleted(address indexed oldOperator);\\n\\n    // admin counter (assuming 255 admins to be max)\\n    uint8 adminsCounter;\\n\\n    // Keeps track of all operators\\n    mapping(address => bool) public operators;\\n\\n    // Keeps track of all admins\\n    mapping(address => bool) public admins;\\n\\n    /**\\n     * @notice This constructor sets the initialAdmin address as an admin and operator.\\n     * @dev The adminsCounter is incremented unchecked.\\n     */\\n    constructor(address initialAdmin) {\\n        admins[initialAdmin] = true;\\n        unchecked {\\n            ++adminsCounter;\\n        }\\n        operators[initialAdmin] = true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           Access Control Modifiers\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier onlyAdmin() {\\n        if (!admins[msg.sender]) {\\n            revert Unauthorized();\\n        }\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        if (!operators[msg.sender]) {\\n            revert Unauthorized();\\n        }\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           Maintenance Functions\\n    //////////////////////////////////////////////////////////////*/\\n    /**\\n     * @notice addAdmin() function allows an admin to add a new admin to the contract.\\n     * @dev This function is only accessible to the existing admins and requires the address of the new admin.\\n     * If the new admin is already set, the function will revert. Otherwise, the adminsCounter will be incremented and the new admin will be added to the admins\\n     * mapping. An AdminAdded event will be emitted.\\n     */\\n    function addAdmin(address newAdmin) external onlyAdmin {\\n        if (admins[newAdmin]) revert AlreadySet();\\n        ++adminsCounter;\\n        admins[newAdmin] = true;\\n        emit AdminAdded(newAdmin);\\n    }\\n\\n    /**\\n     * @notice Deletes an admin from the list of admins.\\n     * @dev Only admins can delete other admins. If the adminsCounter is 0, the transaction will revert.\\n     */\\n    function deleteAdmin(address oldAdmin) external onlyAdmin {\\n        if (!admins[oldAdmin]) revert AlreadySet();\\n        --adminsCounter;\\n        if (adminsCounter == 0) revert NoAdmin();\\n        admins[oldAdmin] = false;\\n        emit AdminDeleted(oldAdmin);\\n    }\\n\\n    /**\\n     * @notice Adds a new operator to the list of operators\\n     * @dev Only the admin can add a new operator\\n     * @param newOperator The address of the new operator\\n     */\\n    function addOperator(address newOperator) external onlyAdmin {\\n        if (operators[newOperator]) revert AlreadySet();\\n        operators[newOperator] = true;\\n        emit OperatorAdded(newOperator);\\n    }\\n\\n    function deleteOperator(address oldOperator) external onlyAdmin {\\n        if (!operators[oldOperator]) revert AlreadySet();\\n        operators[oldOperator] = false;\\n        emit OperatorDeleted(oldOperator);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/Errors.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: SSPL-1.-0\\n\\n/**\\n * @custom:org.protocol='mevETH LST Protocol'\\n * @custom:org.security='mailto:security@manifoldfinance.com'\\n * @custom:org.vcs-commit=$GIT_COMMIT_SHA\\n * @custom:org.vendor='CommodityStream, Inc'\\n * @custom:org.schema-version=\\\"1.0\\\"\\n * @custom.org.encryption=\\\"manifoldfinance.com/.well-known/pgp-key.asc\\\"\\n * @custom:org.preferred-languages=\\\"en\\\"\\n */\\n\\npragma solidity ^0.8.19;\\n\\ninterface MevEthErrors {\\n    /// Errors\\n    error StakingPaused();\\n    error NotEnoughEth();\\n    error ZeroValue();\\n    error InvalidOperator();\\n    error DepositTooSmall();\\n    error InvalidSender();\\n    error PrematureStakingModuleUpdateFinalization();\\n    error PrematureMevEthShareVaultUpdateFinalization();\\n    error InvalidPendingStakingModule();\\n    error InvalidPendingMevEthShareVault();\\n    error TransferExceedsAllowance();\\n    error TransferFailed();\\n    error ZeroAddress();\\n    error AlreadyInitialized();\\n    error SendError();\\n    error FeesTooHigh();\\n    error WrongDepositAmount();\\n    error WrongWithdrawAmount();\\n    error UnAuthorizedCaller();\\n    error WithdrawTooSmall();\\n    error NotFinalised();\\n    error AlreadyClaimed();\\n    error AlreadyFinalised();\\n    error IndexExceedsQueueLength();\\n    error DepositWasFrontrun();\\n    error SandwichProtection();\\n    error NonZeroVaultBalance();\\n    error AlreadyDeposited();\\n    error IncorrectWithdrawalCredentials();\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"safe-contracts/=lib/safe-tools/lib/safe-contracts/contracts/\",\r\n      \"safe-tools/=lib/safe-tools/src/\",\r\n      \"properties/=lib/properties/contracts/\",\r\n      \"solady/utils/=lib/solady/src/utils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 512,\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mevEth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DepositWasFrontrun\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughEth\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnAuthorizedCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongDepositAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"meveth\",\"type\":\"address\"}],\"name\":\"MevEthUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"withdrawalCredentials\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"deposit_data_root\",\"type\":\"bytes32\"}],\"name\":\"NewValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"}],\"name\":\"OperatorDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ValidatorWithdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BEACON_CHAIN_DEPOSIT_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IBeaconDepositContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VALIDATOR_DEPOSIT_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"withdrawal_credentials\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deposit_data_root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IStakingModule.ValidatorData[]\",\"name\":\"batchData\",\"type\":\"tuple[]\"}],\"name\":\"batchMigrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"}],\"name\":\"deleteAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldOperator\",\"type\":\"address\"}],\"name\":\"deleteOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"pubkey\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"withdrawal_credentials\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"deposit_data_root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IStakingModule.ValidatorData\",\"name\":\"data\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"latestDepositRoot\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mevEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"payRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payValidatorWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"record\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"totalDeposited\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalWithdrawn\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalRewardsPaid\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"totalValidatorExitsPaid\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMevEth\",\"type\":\"address\"}],\"name\":\"setNewMevEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validators\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WagyuStaker", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "512", "ConstructorArguments": "00000000000000000000000018f3e9ab3dcd396c2d3e6e598a9f77621ea50fc300000000000000000000000000000000219ab540356cbb839cbe05303d7705fa00000000000000000000000024ae2da0f361aa4be46b48eb19c91e02c5e4f27e", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}