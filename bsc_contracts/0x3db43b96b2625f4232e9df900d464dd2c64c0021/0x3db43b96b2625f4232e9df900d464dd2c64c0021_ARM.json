{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/v0.8/ccip/ARM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.19;\\n\\nimport {TypeAndVersionInterface} from \\\"../interfaces/TypeAndVersionInterface.sol\\\";\\nimport {IARM} from \\\"./interfaces/IARM.sol\\\";\\n\\nimport {OwnerIsCreator} from \\\"./../shared/access/OwnerIsCreator.sol\\\";\\n\\ncontract ARM is IARM, OwnerIsCreator, TypeAndVersionInterface {\\n  // STATIC CONFIG\\n  // solhint-disable-next-line chainlink-solidity/all-caps-constant-storage-variables\\n  string public constant override typeAndVersion = \\\"ARM 1.0.0\\\";\\n\\n  uint256 private constant MAX_NUM_VOTERS = 128;\\n\\n  // DYNAMIC CONFIG\\n  struct Voter {\\n    // This is the address the voter should use to call voteToBless.\\n    address blessVoteAddr;\\n    // This is the address the voter should use to call voteToCurse.\\n    address curseVoteAddr;\\n    // This is the address the voter should use to call unvoteToCurse.\\n    address curseUnvoteAddr;\\n    // The weight of this voter's vote for blessing.\\n    uint8 blessWeight;\\n    // The weight of this voter's vote for cursing.\\n    uint8 curseWeight;\\n  }\\n\\n  struct Config {\\n    Voter[] voters;\\n    // When the total weight of voters that have voted to bless a tagged root reaches\\n    // or exceeds blessWeightThreshold, the tagged root becomes blessed.\\n    uint16 blessWeightThreshold;\\n    // When the total weight of voters that have voted to curse reaches or\\n    // exceeds curseWeightThreshold, the ARM enters the cursed state.\\n    uint16 curseWeightThreshold;\\n  }\\n\\n  struct VersionedConfig {\\n    Config config;\\n    // The version is incremented every time the config changes.\\n    // The initial configuration on the contract will have configVersion == 1.\\n    uint32 configVersion;\\n    // The block number at which the config was last set. Helps the offchain\\n    // code check that the config was set in a stable block or double-check\\n    // that it has the correct config by querying logs at that block number.\\n    uint32 blockNumber;\\n  }\\n\\n  VersionedConfig private s_versionedConfig;\\n\\n  // STATE\\n  struct BlesserRecord {\\n    // The config version at which this BlesserRecord was last set. A blesser\\n    // is considered active iff this configVersion equals\\n    // s_versionedConfig.configVersion.\\n    uint32 configVersion;\\n    uint8 weight;\\n    uint8 index;\\n  }\\n\\n  mapping(address blessVoteAddr => BlesserRecord blesserRecord) private s_blesserRecords;\\n\\n  struct BlessVoteProgress {\\n    // A BlessVoteProgress is considered invalid if weightThresholdMet is false when\\n    // s_versionedConfig.configVersion changes. we don't want old in-progress\\n    // votes to continue when we set a new config!\\n    // The config version at which the bless vote for a tagged root was initiated.\\n    uint32 configVersion;\\n    uint16 accumulatedWeight;\\n    // Care must be taken that the bitmap has as many bits as MAX_NUM_VOTERS.\\n    uint128 voterBitmap;\\n    bool weightThresholdMet;\\n  }\\n\\n  mapping(bytes32 taggedRootHash => BlessVoteProgress blessVoteProgress) private s_blessVoteProgressByTaggedRootHash;\\n\\n  // voteCount and cursesHash can be reset through unvoteToCurse, and ownerUnvoteToCurse, and may be reset through\\n  // setConfig if the curser is not part of the new config.\\n  struct CurserRecord {\\n    bool active;\\n    uint8 weight;\\n    uint32 voteCount;\\n    address curseUnvoteAddr;\\n    bytes32 cursesHash;\\n  }\\n\\n  mapping(address curseVoteAddr => CurserRecord curserRecord) private s_curserRecords;\\n\\n  // Maintains a per-curser set of curseIds. Entries from this mapping are\\n  // never cleared. Once a curseId is used it can never be reused, even after\\n  // an unvoteToCurse or ownerUnvoteToCurse. This is to prevent accidental\\n  // re-votes to curse, e.g. caused by TOCTOU issues.\\n  mapping(address curseVoteAddr => mapping(bytes32 curseId => bool voted)) private s_curseVotes;\\n\\n  struct CurseVoteProgress {\\n    uint16 curseWeightThreshold;\\n    uint16 accumulatedWeight;\\n    // A curse becomes active after:\\n    // - accumulatedWeight becomes greater or equal than curseWeightThreshold; or\\n    // - the owner curses.\\n    // Once a curse is active, only the owner can lift it.\\n    bool curseActive;\\n  }\\n\\n  CurseVoteProgress private s_curseVoteProgress;\\n\\n  // AUXILLARY STRUCTS\\n  struct UnvoteToCurseRecord {\\n    address curseVoteAddr;\\n    bytes32 cursesHash;\\n    bool forceUnvote;\\n  }\\n\\n  // EVENTS, ERRORS\\n  event ConfigSet(uint32 indexed configVersion, Config config);\\n  error InvalidConfig();\\n\\n  event TaggedRootBlessed(uint32 indexed configVersion, IARM.TaggedRoot taggedRoot, uint16 accumulatedWeight);\\n  event TaggedRootBlessVotesReset(uint32 indexed configVersion, IARM.TaggedRoot taggedRoot, bool wasBlessed);\\n  event VotedToBless(uint32 indexed configVersion, address indexed voter, IARM.TaggedRoot taggedRoot, uint8 weight);\\n\\n  event VotedToCurse(\\n    uint32 indexed configVersion,\\n    address indexed voter,\\n    uint8 weight,\\n    uint32 voteCount,\\n    bytes32 curseId,\\n    bytes32 cursesHash,\\n    uint16 accumulatedWeight\\n  );\\n  event ReusedVotesToCurse(\\n    uint32 indexed configVersion,\\n    address indexed voter,\\n    uint8 weight,\\n    uint32 voteCount,\\n    bytes32 cursesHash,\\n    uint16 accumulatedWeight\\n  );\\n  event UnvotedToCurse(\\n    uint32 indexed configVersion,\\n    address indexed voter,\\n    uint8 weight,\\n    uint32 voteCount,\\n    bytes32 cursesHash\\n  );\\n  event SkippedUnvoteToCurse(address indexed voter, bytes32 expectedCursesHash, bytes32 actualCursesHash);\\n  event OwnerCursed(uint256 timestamp);\\n  event Cursed(uint32 indexed configVersion, uint256 timestamp);\\n\\n  // These events make it easier for offchain logic to discover that it performs\\n  // the same actions multiple times.\\n  event AlreadyVotedToBless(uint32 indexed configVersion, address indexed voter, IARM.TaggedRoot taggedRoot);\\n  event AlreadyBlessed(uint32 indexed configVersion, address indexed voter, IARM.TaggedRoot taggedRoot);\\n\\n  event RecoveredFromCurse();\\n\\n  error AlreadyVotedToCurse(address voter, bytes32 curseId);\\n  error InvalidVoter(address voter);\\n  error InvalidCurseState();\\n  error InvalidCursesHash(bytes32 expectedCursesHash, bytes32 actualCursesHash);\\n  error MustRecoverFromCurse();\\n\\n  constructor(Config memory config) {\\n    {\\n      // Ensure that the bitmap is large enough to hold MAX_NUM_VOTERS.\\n      // We do this in the constructor because MAX_NUM_VOTERS is constant.\\n      BlessVoteProgress memory vp;\\n      vp.voterBitmap = ~uint128(0);\\n      assert(vp.voterBitmap >> (MAX_NUM_VOTERS - 1) >= 1);\\n    }\\n    _setConfig(config);\\n  }\\n\\n  function _bitmapGet(uint128 bitmap, uint8 index) internal pure returns (bool) {\\n    assert(index < MAX_NUM_VOTERS);\\n    return bitmap & (uint128(1) << index) != 0;\\n  }\\n\\n  function _bitmapSet(uint128 bitmap, uint8 index) internal pure returns (uint128) {\\n    assert(index < MAX_NUM_VOTERS);\\n    return bitmap | (uint128(1) << index);\\n  }\\n\\n  function _bitmapCount(uint128 bitmap) internal pure returns (uint8 oneBits) {\\n    // https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan\\n    for (; bitmap != 0; ++oneBits) {\\n      bitmap &= bitmap - 1;\\n    }\\n  }\\n\\n  function _taggedRootHash(IARM.TaggedRoot memory taggedRoot) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(taggedRoot.commitStore, taggedRoot.root));\\n  }\\n\\n  /// @param taggedRoots A tagged root is hashed as `keccak256(abi.encode(taggedRoot.commitStore\\n  /// /* address */, taggedRoot.root /* bytes32 */))`.\\n  function voteToBless(IARM.TaggedRoot[] calldata taggedRoots) external {\\n    // If we have an active curse, something is really wrong. Let's err on the\\n    // side of caution and not accept further blessings during this time of\\n    // uncertainty.\\n    if (isCursed()) revert MustRecoverFromCurse();\\n\\n    uint32 configVersion = s_versionedConfig.configVersion;\\n    BlesserRecord memory blesserRecord = s_blesserRecords[msg.sender];\\n    if (blesserRecord.configVersion != configVersion) revert InvalidVoter(msg.sender);\\n\\n    for (uint256 i = 0; i < taggedRoots.length; ++i) {\\n      IARM.TaggedRoot memory taggedRoot = taggedRoots[i];\\n      bytes32 taggedRootHash = _taggedRootHash(taggedRoot);\\n      BlessVoteProgress memory voteProgress = s_blessVoteProgressByTaggedRootHash[taggedRootHash];\\n      if (voteProgress.weightThresholdMet) {\\n        // We don't revert here because it's unreasonable to expect from the\\n        // voter to know exactly when to stop voting. Most likely when they\\n        // voted they didn't realize the threshold would be reached by the time\\n        // their vote was counted.\\n        // Additionally, there might be other tagged roots for which votes might\\n        // count, and we want to allow that to happen.\\n        emit AlreadyBlessed(configVersion, msg.sender, taggedRoot);\\n        continue;\\n      }\\n      if (voteProgress.configVersion != configVersion) {\\n        // Note that voteProgress.weightThresholdMet must be false at this point\\n\\n        // If votes were received while an older config was in effect,\\n        // invalidate them and start from scratch.\\n        // If votes were never received, set the current config version.\\n        voteProgress = BlessVoteProgress({\\n          configVersion: configVersion,\\n          voterBitmap: 0,\\n          accumulatedWeight: 0,\\n          weightThresholdMet: false\\n        });\\n      }\\n      if (_bitmapGet(voteProgress.voterBitmap, blesserRecord.index)) {\\n        // We don't revert here because there might be other tagged roots for\\n        // which votes might count, and we want to allow that to happen.\\n        emit AlreadyVotedToBless(configVersion, msg.sender, taggedRoot);\\n        continue;\\n      }\\n      voteProgress.voterBitmap = _bitmapSet(voteProgress.voterBitmap, blesserRecord.index);\\n      voteProgress.accumulatedWeight += blesserRecord.weight;\\n      emit VotedToBless(configVersion, msg.sender, taggedRoot, blesserRecord.weight);\\n      if (voteProgress.accumulatedWeight >= s_versionedConfig.config.blessWeightThreshold) {\\n        voteProgress.weightThresholdMet = true;\\n        emit TaggedRootBlessed(configVersion, taggedRoot, voteProgress.accumulatedWeight);\\n      }\\n      s_blessVoteProgressByTaggedRootHash[taggedRootHash] = voteProgress;\\n    }\\n  }\\n\\n  /// @notice Can be called by the owner to remove unintentionally voted or even blessed tagged roots in a recovery\\n  /// scenario. The owner must ensure that there are no in-flight transactions by ARM nodes voting for any of the\\n  /// taggedRoots before calling this function, as such in-flight transactions could lead to the roots becoming\\n  /// re-blessed shortly after the call to this function, contrary to the original intention.\\n  function ownerResetBlessVotes(IARM.TaggedRoot[] calldata taggedRoots) external onlyOwner {\\n    uint32 configVersion = s_versionedConfig.configVersion;\\n    for (uint256 i = 0; i < taggedRoots.length; ++i) {\\n      IARM.TaggedRoot memory taggedRoot = taggedRoots[i];\\n      bytes32 taggedRootHash = _taggedRootHash(taggedRoot);\\n      BlessVoteProgress memory voteProgress = s_blessVoteProgressByTaggedRootHash[taggedRootHash];\\n      delete s_blessVoteProgressByTaggedRootHash[taggedRootHash];\\n      bool wasBlessed = voteProgress.weightThresholdMet;\\n      if (voteProgress.configVersion == configVersion || wasBlessed) {\\n        emit TaggedRootBlessVotesReset(configVersion, taggedRoot, wasBlessed);\\n      }\\n    }\\n  }\\n\\n  /// @notice Can be called by a curser to remove unintentional votes to curse.\\n  /// We expect this to be called very rarely, e.g. in case of a bug in the\\n  /// offchain code causing false voteToCurse calls.\\n  /// @notice Should be called from curser's corresponding curseUnvoteAddr.\\n  function unvoteToCurse(address curseVoteAddr, bytes32 cursesHash) external {\\n    CurserRecord memory curserRecord = s_curserRecords[curseVoteAddr];\\n\\n    // If a curse is active, only the owner is allowed to lift it.\\n    if (isCursed()) revert MustRecoverFromCurse();\\n\\n    if (msg.sender != curserRecord.curseUnvoteAddr) revert InvalidVoter(msg.sender);\\n\\n    if (!curserRecord.active || curserRecord.voteCount == 0) revert InvalidCurseState();\\n    if (curserRecord.cursesHash != cursesHash) revert InvalidCursesHash(curserRecord.cursesHash, cursesHash);\\n\\n    emit UnvotedToCurse(\\n      s_versionedConfig.configVersion,\\n      curseVoteAddr,\\n      curserRecord.weight,\\n      curserRecord.voteCount,\\n      cursesHash\\n    );\\n    curserRecord.voteCount = 0;\\n    curserRecord.cursesHash = 0;\\n    s_curserRecords[curseVoteAddr] = curserRecord;\\n    s_curseVoteProgress.accumulatedWeight -= curserRecord.weight;\\n  }\\n\\n  /// @notice A vote to curse is appropriate during unhealthy blockchain conditions\\n  /// (eg. finality violations).\\n  function voteToCurse(bytes32 curseId) external {\\n    CurserRecord memory curserRecord = s_curserRecords[msg.sender];\\n    if (!curserRecord.active) revert InvalidVoter(msg.sender);\\n    if (s_curseVotes[msg.sender][curseId]) revert AlreadyVotedToCurse(msg.sender, curseId);\\n    s_curseVotes[msg.sender][curseId] = true;\\n    ++curserRecord.voteCount;\\n    curserRecord.cursesHash = keccak256(abi.encode(curserRecord.cursesHash, curseId));\\n    s_curserRecords[msg.sender] = curserRecord;\\n\\n    CurseVoteProgress memory curseVoteProgress = s_curseVoteProgress;\\n\\n    if (curserRecord.voteCount == 1) {\\n      curseVoteProgress.accumulatedWeight += curserRecord.weight;\\n    }\\n\\n    // NOTE: We could pack configVersion into CurserRecord that we already load in the beginning of this function to\\n    // avoid the following extra storage read for it, but since voteToCurse is not on the hot path we'd rather keep\\n    // things simple.\\n    uint32 configVersion = s_versionedConfig.configVersion;\\n    emit VotedToCurse(\\n      configVersion,\\n      msg.sender,\\n      curserRecord.weight,\\n      curserRecord.voteCount,\\n      curseId,\\n      curserRecord.cursesHash,\\n      curseVoteProgress.accumulatedWeight\\n    );\\n    if (\\n      !curseVoteProgress.curseActive && curseVoteProgress.accumulatedWeight >= curseVoteProgress.curseWeightThreshold\\n    ) {\\n      curseVoteProgress.curseActive = true;\\n      emit Cursed(configVersion, block.timestamp);\\n    }\\n    s_curseVoteProgress = curseVoteProgress;\\n  }\\n\\n  /// @notice Enables the owner to immediately have the system enter the cursed state.\\n  function ownerCurse() external onlyOwner {\\n    emit OwnerCursed(block.timestamp);\\n    if (!s_curseVoteProgress.curseActive) {\\n      s_curseVoteProgress.curseActive = true;\\n      emit Cursed(s_versionedConfig.configVersion, block.timestamp);\\n    }\\n  }\\n\\n  /// @notice Enables the owner to remove curse votes. After the curse votes are removed,\\n  /// this function will check whether the curse is still valid and restore the uncursed state if possible.\\n  /// This function also enables the owner to lift a curse created through ownerCurse.\\n  function ownerUnvoteToCurse(UnvoteToCurseRecord[] calldata unvoteRecords) external onlyOwner {\\n    for (uint256 i = 0; i < unvoteRecords.length; ++i) {\\n      UnvoteToCurseRecord memory unvoteRecord = unvoteRecords[i];\\n      CurserRecord memory curserRecord = s_curserRecords[unvoteRecord.curseVoteAddr];\\n      // Owner can avoid the curses hash check by setting forceUnvote to true, in case\\n      // a malicious curser is flooding the system with votes to curse with the\\n      // intention to disallow the owner to clear their curse.\\n      if (!unvoteRecord.forceUnvote && curserRecord.cursesHash != unvoteRecord.cursesHash) {\\n        emit SkippedUnvoteToCurse(unvoteRecord.curseVoteAddr, curserRecord.cursesHash, unvoteRecord.cursesHash);\\n        continue;\\n      }\\n\\n      if (!curserRecord.active || curserRecord.voteCount == 0) continue;\\n\\n      emit UnvotedToCurse(\\n        s_versionedConfig.configVersion,\\n        unvoteRecord.curseVoteAddr,\\n        curserRecord.weight,\\n        curserRecord.voteCount,\\n        curserRecord.cursesHash\\n      );\\n      curserRecord.voteCount = 0;\\n      curserRecord.cursesHash = 0;\\n      s_curserRecords[unvoteRecord.curseVoteAddr] = curserRecord;\\n      s_curseVoteProgress.accumulatedWeight -= curserRecord.weight;\\n    }\\n\\n    if (\\n      s_curseVoteProgress.curseActive &&\\n      s_curseVoteProgress.accumulatedWeight < s_curseVoteProgress.curseWeightThreshold\\n    ) {\\n      s_curseVoteProgress.curseActive = false;\\n      emit RecoveredFromCurse();\\n      // Invalidate all in-progress votes to bless by bumping the config version.\\n      // They might have been based on false information about the source chain\\n      // (e.g. in case of a finality violation).\\n      _setConfig(s_versionedConfig.config);\\n    }\\n  }\\n\\n  /// @notice Will revert in case a curse is active. To avoid accidentally invalidating an in-progress curse vote, it\\n  /// may be advisable to remove voters one-by-one over time, rather than many at once.\\n  /// @dev The gas use of this function varies depending on the number of curse votes that are active. When calling this\\n  /// function, be sure to include a gas cushion to account for curse votes that may occur between your transaction\\n  /// being sent and mined.\\n  function setConfig(Config memory config) external onlyOwner {\\n    _setConfig(config);\\n  }\\n\\n  /// @inheritdoc IARM\\n  function isBlessed(IARM.TaggedRoot calldata taggedRoot) external view override returns (bool) {\\n    return s_blessVoteProgressByTaggedRootHash[_taggedRootHash(taggedRoot)].weightThresholdMet;\\n  }\\n\\n  /// @inheritdoc IARM\\n  function isCursed() public view override returns (bool) {\\n    return s_curseVoteProgress.curseActive;\\n  }\\n\\n  /// @notice Config version might be incremented for many reasons, including\\n  /// recovery from a curse and a regular config change.\\n  function getConfigDetails() external view returns (uint32 version, uint32 blockNumber, Config memory config) {\\n    version = s_versionedConfig.configVersion;\\n    blockNumber = s_versionedConfig.blockNumber;\\n    config = s_versionedConfig.config;\\n  }\\n\\n  /// @return blessVoteAddrs addresses of voters, will be empty if voting took place with an older config version\\n  /// @return accumulatedWeight sum of weights of voters, will be zero if voting took place with an older config version\\n  /// @return blessed will be accurate regardless of when voting took place\\n  /// @dev This is a helper method for offchain code so efficiency is not really a concern.\\n  function getBlessProgress(\\n    IARM.TaggedRoot calldata taggedRoot\\n  ) external view returns (address[] memory blessVoteAddrs, uint16 accumulatedWeight, bool blessed) {\\n    bytes32 taggedRootHash = _taggedRootHash(taggedRoot);\\n    BlessVoteProgress memory progress = s_blessVoteProgressByTaggedRootHash[taggedRootHash];\\n    blessed = progress.weightThresholdMet;\\n    if (progress.configVersion == s_versionedConfig.configVersion) {\\n      accumulatedWeight = progress.accumulatedWeight;\\n      uint128 bitmap = progress.voterBitmap;\\n      blessVoteAddrs = new address[](_bitmapCount(bitmap));\\n      Voter[] memory voters = s_versionedConfig.config.voters;\\n      uint256 j = 0;\\n      for (uint256 i = 0; i < voters.length; ++i) {\\n        if (_bitmapGet(bitmap, s_blesserRecords[voters[i].blessVoteAddr].index)) {\\n          blessVoteAddrs[j] = voters[i].blessVoteAddr;\\n          ++j;\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @dev This is a helper method for offchain code so efficiency is not really a concern.\\n  function getCurseProgress()\\n    external\\n    view\\n    returns (\\n      address[] memory curseVoteAddrs,\\n      uint32[] memory voteCounts,\\n      bytes32[] memory cursesHashes,\\n      uint16 accumulatedWeight,\\n      bool cursed\\n    )\\n  {\\n    accumulatedWeight = s_curseVoteProgress.accumulatedWeight;\\n    cursed = s_curseVoteProgress.curseActive;\\n    uint256 numCursers;\\n    Voter[] memory voters = s_versionedConfig.config.voters;\\n    for (uint256 i = 0; i < voters.length; ++i) {\\n      CurserRecord memory curserRecord = s_curserRecords[voters[i].curseVoteAddr];\\n      if (curserRecord.voteCount > 0) {\\n        ++numCursers;\\n      }\\n    }\\n    curseVoteAddrs = new address[](numCursers);\\n    voteCounts = new uint32[](numCursers);\\n    cursesHashes = new bytes32[](numCursers);\\n    uint256 j = 0;\\n    for (uint256 i = 0; i < voters.length; ++i) {\\n      address curseVoteAddr = voters[i].curseVoteAddr;\\n      CurserRecord memory curserRecord = s_curserRecords[curseVoteAddr];\\n      if (curserRecord.voteCount > 0) {\\n        curseVoteAddrs[j] = curseVoteAddr;\\n        voteCounts[j] = curserRecord.voteCount;\\n        cursesHashes[j] = curserRecord.cursesHash;\\n        ++j;\\n      }\\n    }\\n  }\\n\\n  function _validateConfig(Config memory config) internal pure returns (bool) {\\n    if (\\n      config.voters.length == 0 ||\\n      config.voters.length > MAX_NUM_VOTERS ||\\n      config.blessWeightThreshold == 0 ||\\n      config.curseWeightThreshold == 0\\n    ) {\\n      return false;\\n    }\\n\\n    uint256 totalBlessWeight = 0;\\n    uint256 totalCurseWeight = 0;\\n    address[] memory allAddrs = new address[](3 * config.voters.length);\\n    for (uint256 i = 0; i < config.voters.length; ++i) {\\n      Voter memory voter = config.voters[i];\\n      if (\\n        voter.blessVoteAddr == address(0) ||\\n        voter.curseVoteAddr == address(0) ||\\n        voter.curseUnvoteAddr == address(0) ||\\n        (voter.blessWeight == 0 && voter.curseWeight == 0)\\n      ) {\\n        return false;\\n      }\\n      allAddrs[3 * i + 0] = voter.blessVoteAddr;\\n      allAddrs[3 * i + 1] = voter.curseVoteAddr;\\n      allAddrs[3 * i + 2] = voter.curseUnvoteAddr;\\n      totalBlessWeight += voter.blessWeight;\\n      totalCurseWeight += voter.curseWeight;\\n    }\\n    for (uint256 i = 0; i < allAddrs.length; ++i) {\\n      address allAddrs_i = allAddrs[i];\\n      for (uint256 j = i + 1; j < allAddrs.length; ++j) {\\n        if (allAddrs_i == allAddrs[j]) {\\n          return false;\\n        }\\n      }\\n    }\\n\\n    return totalBlessWeight >= config.blessWeightThreshold && totalCurseWeight >= config.curseWeightThreshold;\\n  }\\n\\n  function _setConfig(Config memory config) private {\\n    if (isCursed()) revert MustRecoverFromCurse();\\n    if (!_validateConfig(config)) revert InvalidConfig();\\n\\n    Config memory oldConfig = s_versionedConfig.config;\\n\\n    // We can't directly assign s_versionedConfig.config to config\\n    // because copying a memory array into storage is not supported.\\n    {\\n      s_versionedConfig.config.blessWeightThreshold = config.blessWeightThreshold;\\n      s_versionedConfig.config.curseWeightThreshold = config.curseWeightThreshold;\\n      while (s_versionedConfig.config.voters.length != 0) {\\n        Voter memory voter = s_versionedConfig.config.voters[s_versionedConfig.config.voters.length - 1];\\n        delete s_blesserRecords[voter.blessVoteAddr];\\n        s_curserRecords[voter.curseVoteAddr].active = false;\\n        s_versionedConfig.config.voters.pop();\\n      }\\n      for (uint256 i = 0; i < config.voters.length; ++i) {\\n        s_versionedConfig.config.voters.push(config.voters[i]);\\n      }\\n    }\\n\\n    ++s_versionedConfig.configVersion;\\n    uint32 configVersion = s_versionedConfig.configVersion;\\n\\n    for (uint8 i = 0; i < config.voters.length; ++i) {\\n      Voter memory voter = config.voters[i];\\n      s_blesserRecords[voter.blessVoteAddr] = BlesserRecord({\\n        configVersion: configVersion,\\n        index: i,\\n        weight: voter.blessWeight\\n      });\\n      s_curserRecords[voter.curseVoteAddr] = CurserRecord({\\n        active: true,\\n        weight: voter.curseWeight,\\n        curseUnvoteAddr: voter.curseUnvoteAddr,\\n        voteCount: s_curserRecords[voter.curseVoteAddr].voteCount,\\n        cursesHash: s_curserRecords[voter.curseVoteAddr].cursesHash\\n      });\\n    }\\n    s_versionedConfig.blockNumber = uint32(block.number);\\n    emit ConfigSet(configVersion, config);\\n\\n    CurseVoteProgress memory newCurseVoteProgress = CurseVoteProgress({\\n      curseWeightThreshold: config.curseWeightThreshold,\\n      accumulatedWeight: 0,\\n      curseActive: false\\n    });\\n\\n    // Retain votes for the cursers who are still part of the new config and delete records for the cursers who are not.\\n    for (uint8 i = 0; i < oldConfig.voters.length; ++i) {\\n      // We could be more efficient with this but since this is only for\\n      // setConfig it will do for now.\\n      address curseVoteAddr = oldConfig.voters[i].curseVoteAddr;\\n      CurserRecord memory curserRecord = s_curserRecords[curseVoteAddr];\\n      if (!curserRecord.active) {\\n        delete s_curserRecords[curseVoteAddr];\\n      } else if (curserRecord.active && curserRecord.voteCount > 0) {\\n        newCurseVoteProgress.accumulatedWeight += curserRecord.weight;\\n        emit ReusedVotesToCurse(\\n          configVersion,\\n          curseVoteAddr,\\n          curserRecord.weight,\\n          curserRecord.voteCount,\\n          curserRecord.cursesHash,\\n          newCurseVoteProgress.accumulatedWeight\\n        );\\n      }\\n    }\\n    newCurseVoteProgress.curseActive =\\n      newCurseVoteProgress.accumulatedWeight >= newCurseVoteProgress.curseWeightThreshold;\\n    if (newCurseVoteProgress.curseActive) {\\n      emit Cursed(configVersion, block.timestamp);\\n    }\\n    s_curseVoteProgress = newCurseVoteProgress;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/interfaces/TypeAndVersionInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract TypeAndVersionInterface {\\n  function typeAndVersion() external pure virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/ccip/interfaces/IARM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice This interface contains the only ARM-related functions that might be used on-chain by other CCIP contracts.\\ninterface IARM {\\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\\n  struct TaggedRoot {\\n    address commitStore;\\n    bytes32 root;\\n  }\\n\\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\\n  function isBlessed(TaggedRoot calldata taggedRoot) external view returns (bool);\\n\\n  /// @notice When the ARM is \\\"cursed\\\", CCIP pauses until the curse is lifted.\\n  function isCursed() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/access/OwnerIsCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ConfirmedOwner} from \\\"./ConfirmedOwner.sol\\\";\\n\\n/// @title The OwnerIsCreator contract\\n/// @notice A contract with helpers for basic contract ownership.\\ncontract OwnerIsCreator is ConfirmedOwner {\\n  constructor() ConfirmedOwner(msg.sender) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/access/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IOwnable.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is IOwnable {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/v0.8/shared/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOwnable {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=foundry-lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=foundry-lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=foundry-lib/openzeppelin-contracts/contracts/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"@eth-optimism/=node_modules/@eth-optimism/\",\r\n      \"erc4626-tests/=foundry-lib/openzeppelin-contracts/lib/erc4626-tests/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 26000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"blessVoteAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curseVoteAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curseUnvoteAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"blessWeight\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"curseWeight\",\"type\":\"uint8\"}],\"internalType\":\"struct ARM.Voter[]\",\"name\":\"voters\",\"type\":\"tuple[]\"},{\"internalType\":\"uint16\",\"name\":\"blessWeightThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"curseWeightThreshold\",\"type\":\"uint16\"}],\"internalType\":\"struct ARM.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"curseId\",\"type\":\"bytes32\"}],\"name\":\"AlreadyVotedToCurse\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCurseState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expectedCursesHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actualCursesHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidCursesHash\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"InvalidVoter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MustRecoverFromCurse\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"commitStore\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct IARM.TaggedRoot\",\"name\":\"taggedRoot\",\"type\":\"tuple\"}],\"name\":\"AlreadyBlessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"commitStore\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct IARM.TaggedRoot\",\"name\":\"taggedRoot\",\"type\":\"tuple\"}],\"name\":\"AlreadyVotedToBless\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"blessVoteAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curseVoteAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curseUnvoteAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"blessWeight\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"curseWeight\",\"type\":\"uint8\"}],\"internalType\":\"struct ARM.Voter[]\",\"name\":\"voters\",\"type\":\"tuple[]\"},{\"internalType\":\"uint16\",\"name\":\"blessWeightThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"curseWeightThreshold\",\"type\":\"uint16\"}],\"indexed\":false,\"internalType\":\"struct ARM.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Cursed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OwnerCursed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RecoveredFromCurse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"weight\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"voteCount\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"cursesHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"accumulatedWeight\",\"type\":\"uint16\"}],\"name\":\"ReusedVotesToCurse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"expectedCursesHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"actualCursesHash\",\"type\":\"bytes32\"}],\"name\":\"SkippedUnvoteToCurse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"commitStore\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct IARM.TaggedRoot\",\"name\":\"taggedRoot\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasBlessed\",\"type\":\"bool\"}],\"name\":\"TaggedRootBlessVotesReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"commitStore\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct IARM.TaggedRoot\",\"name\":\"taggedRoot\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"accumulatedWeight\",\"type\":\"uint16\"}],\"name\":\"TaggedRootBlessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"weight\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"voteCount\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"cursesHash\",\"type\":\"bytes32\"}],\"name\":\"UnvotedToCurse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"commitStore\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct IARM.TaggedRoot\",\"name\":\"taggedRoot\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"weight\",\"type\":\"uint8\"}],\"name\":\"VotedToBless\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"configVersion\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"weight\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"voteCount\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"curseId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"cursesHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"accumulatedWeight\",\"type\":\"uint16\"}],\"name\":\"VotedToCurse\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"commitStore\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IARM.TaggedRoot\",\"name\":\"taggedRoot\",\"type\":\"tuple\"}],\"name\":\"getBlessProgress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"blessVoteAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint16\",\"name\":\"accumulatedWeight\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"blessed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfigDetails\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"blessVoteAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curseVoteAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curseUnvoteAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"blessWeight\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"curseWeight\",\"type\":\"uint8\"}],\"internalType\":\"struct ARM.Voter[]\",\"name\":\"voters\",\"type\":\"tuple[]\"},{\"internalType\":\"uint16\",\"name\":\"blessWeightThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"curseWeightThreshold\",\"type\":\"uint16\"}],\"internalType\":\"struct ARM.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurseProgress\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"curseVoteAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"voteCounts\",\"type\":\"uint32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"cursesHashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint16\",\"name\":\"accumulatedWeight\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"cursed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"commitStore\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IARM.TaggedRoot\",\"name\":\"taggedRoot\",\"type\":\"tuple\"}],\"name\":\"isBlessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCursed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerCurse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"commitStore\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IARM.TaggedRoot[]\",\"name\":\"taggedRoots\",\"type\":\"tuple[]\"}],\"name\":\"ownerResetBlessVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"curseVoteAddr\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"cursesHash\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"forceUnvote\",\"type\":\"bool\"}],\"internalType\":\"struct ARM.UnvoteToCurseRecord[]\",\"name\":\"unvoteRecords\",\"type\":\"tuple[]\"}],\"name\":\"ownerUnvoteToCurse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"blessVoteAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curseVoteAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curseUnvoteAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"blessWeight\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"curseWeight\",\"type\":\"uint8\"}],\"internalType\":\"struct ARM.Voter[]\",\"name\":\"voters\",\"type\":\"tuple[]\"},{\"internalType\":\"uint16\",\"name\":\"blessWeightThreshold\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"curseWeightThreshold\",\"type\":\"uint16\"}],\"internalType\":\"struct ARM.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"curseVoteAddr\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"cursesHash\",\"type\":\"bytes32\"}],\"name\":\"unvoteToCurse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"commitStore\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"internalType\":\"struct IARM.TaggedRoot[]\",\"name\":\"taggedRoots\",\"type\":\"tuple[]\"}],\"name\":\"voteToBless\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"curseId\",\"type\":\"bytes32\"}],\"name\":\"voteToCurse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ARM", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "26000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}