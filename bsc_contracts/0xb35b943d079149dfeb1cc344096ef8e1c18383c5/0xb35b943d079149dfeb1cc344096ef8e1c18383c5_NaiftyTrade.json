{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NaiftyTrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n    \\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(\\n            _initializing || !_initialized,\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {}\\n\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b)\\n        internal\\n        pure\\n        returns (bool, uint256)\\n    {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\\ninterface IBEP20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n/**\\n * @dev Implementation of the {IBEP165} interface.\\n *\\n * Contracts that want to implement BEP165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {BEP165Storage} provides an easier to use but more expensive implementation.\\n */\\ninterface IBEP165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n/**\\n * @dev Required interface of an BEP721 compliant contract.\\n */\\ninterface IBEP721Upgradeable is IBEP165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the BEP721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IBEP721Receiver-onBEP721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:      \\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IBEP721Receiver-onBEP721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/**\\n * @dev Required interface of an BEP1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IBEP1155Upgradeable is IBEP165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(\\n        address indexed account,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IBEP1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:BEP1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IBEP1155Receiver-onBEP1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:BEP1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IBEP1155Receiver-onBEP1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface NAIFTYCollection721 {\\n    function mint(\\n        string memory ipfsmetadata,\\n        address to,\\n        uint256 royal,\\n        uint256 id_\\n    ) external;\\n\\n    function getCreatorsAndRoyalty(uint256 tokenid)\\n        external\\n        view\\n        returns (address, uint256);\\n    function changeCollectionOwner(address to) external;\\n    function setRoyaltyPBEPentage(uint96 _royPer) external;\\n    function adminBurn(uint256 tokenId) external;\\n}\\n\\ninterface NAIFTYCollection1155 {\\n    function mint(\\n        string memory ipfsmetadata,\\n        address to,\\n        uint total,\\n        uint256 royal,\\n        uint256 id_\\n    ) external;\\n\\n    function getCreatorsAndRoyalty(uint256 tokenid)\\n        external\\n        view\\n        returns (address, uint256);\\n\\n    function TransferNFT(address to, uint256 tokenid, uint256 count) external;\\n    function changeCollectionOwner(address to) external;\\n    function setRoyaltyPBEPentage(uint96 _royPer) external;\\n    function adminBurn(uint256 tokenId, uint256 amount, address from) external;\\n}\\n\\ncontract NaiftyTrade is Initializable, OwnableUpgradeable {\\n    event OrderPlace(\\n        address indexed from,\\n        uint256 indexed tokenId,\\n        uint256 indexed value\\n    );\\n    event CancelOrder(address indexed from, uint256 indexed tokenId);\\n    event ColletionId(uint256 indexed collectionId, uint256 indexed cRoyalty);\\n    event ChangePrice(\\n        address indexed from,\\n        uint256 indexed tokenId,\\n        uint256 indexed value\\n    );\\n    event Create(\\n        address indexed _to,\\n        uint256 indexed tokenId,\\n        string status\\n    );\\n    using SafeMathUpgradeable for uint256;\\n\\n    function initialize() public initializer {\\n        __Ownable_init();\\n        serviceValue = 0;\\n        sellervalue = 3000000000000000000;\\n        deci = 18;\\n        publicMint = true;\\n        _tid = 1;\\n    }\\n\\n    struct Order {\\n        uint256 tokenId;\\n        uint256 price;\\n        address contractAddress;\\n    }\\n    mapping(address => mapping(uint256 => Order)) public order_place;\\n    mapping(string => address) private tokentype;\\n    mapping(address => mapping(address => bool)) public approveStatus;\\n    \\n    uint256 private serviceValue;\\n    uint256 private sellervalue;\\n    bool public publicMint;\\n    address public naifty721;\\n    address public naifty1155;\\n    uint256 deci;\\n    uint256 public _tid;\\n\\n    function getApproveStatus(address owneraddrrss, address contractaddress)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return approveStatus[owneraddrrss][contractaddress];\\n    }\\n\\n    function getServiceFee()\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (serviceValue, sellervalue);\\n    }\\n\\n    function setServiceValue(uint256 _serviceValue, uint256 sellerfee)\\n        public\\n        onlyOwner\\n    {\\n        serviceValue = _serviceValue;\\n        sellervalue = sellerfee;\\n    }\\n\\n    function getTokenAddress(string memory _type)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return tokentype[_type];\\n    }\\n\\n    function addTokenType(string[] memory _type, address[] memory tokenAddress)\\n        public\\n        onlyOwner\\n    {\\n        require(\\n            _type.length == tokenAddress.length,\\n            \\\"Not equal for type and tokenAddress\\\"\\n        );\\n        for (uint256 i = 0; i < _type.length; i++) {\\n            tokentype[_type[i]] = tokenAddress[i];\\n        }\\n    }\\n\\n    function pBEPent(uint256 value1, uint256 value2)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 result = value1.mul(value2).div(1e20);\\n        return (result);\\n    }\\n\\n    function calc(\\n        uint256 amount,\\n        uint256 royal,\\n        uint256 rewardPer,\\n        uint256 buyerRewardPer\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256        )\\n    {\\n        uint256 fee = pBEPent(amount, serviceValue);\\n        uint256 roy = pBEPent(amount, royal);\\n        uint256 netamount = 0;\\n        if (sellervalue != 0) {\\n            uint256 fee1 = pBEPent(amount, sellervalue);\\n            fee = fee.add(fee1);\\n            netamount = amount.sub(fee1.add(roy));\\n        } else {\\n            netamount = amount.sub(roy);\\n        }\\n        return (rewardPer != 0 ? fee.sub(pBEPent(fee, rewardPer).add(pBEPent(fee, buyerRewardPer))) : fee, roy, netamount, pBEPent(fee, rewardPer), pBEPent(fee, buyerRewardPer));\\n    }\\n\\n    function orderPlace(\\n        uint256 tokenId,\\n        uint256 _price,\\n        address _conAddress,\\n        uint256 _type,\\n        string memory _status\\n    ) public {\\n        if (\\n            keccak256(abi.encodePacked((_status))) ==\\n            keccak256(abi.encodePacked((\\\"order\\\")))\\n        ) {\\n            if (_type == 721) {\\n            require(\\n                IBEP721Upgradeable(_conAddress).ownerOf(tokenId) == msg.sender,\\n                \\\"Not a Owner\\\"\\n            );\\n        } else {\\n            require(\\n                IBEP1155Upgradeable(_conAddress).balanceOf(\\n                    msg.sender,\\n                    tokenId\\n                ) > 0 ,\\n                \\\"Not a Owner\\\"\\n            );\\n        }\\n        }\\n        require(_price > 0, \\\"Price Must be greater than zero\\\");\\n        approveStatus[msg.sender][_conAddress] = true;\\n        Order memory order;\\n        order.tokenId = tokenId;\\n        order.price = _price;\\n        order.contractAddress = _conAddress;\\n        order_place[msg.sender][tokenId] = order;\\n        emit OrderPlace(msg.sender, tokenId, _price);\\n    }\\n\\n    function cancelOrder(uint256 tokenId) public {\\n        delete order_place[msg.sender][tokenId];\\n        emit CancelOrder(msg.sender, tokenId);\\n    }\\n\\n    function changePrice(uint256 value, uint256 tokenId) public {\\n        require(value < order_place[msg.sender][tokenId].price);\\n        order_place[msg.sender][tokenId].price = value;\\n        emit ChangePrice(msg.sender, tokenId, value);\\n    }\\n\\n    // ids[0] - tokenId, ids[1] - amount, ids[2] -  nooftoken, ids[3] - nftType, ids[4] - rewardPer, ids[5] - buyerRewardPer\\n    //_conAddr[0] - Contract Address, _conAddr[1] - refere Address \\n    function saleToken(\\n        address payable from,\\n        uint256[] memory ids,\\n        address[] memory _conAddr\\n    ) public payable {\\n        require(\\n            ids[1] == order_place[from][ids[0]].price.mul(ids[2]) &&\\n                order_place[from][ids[0]].price.mul(ids[2]) > 0,\\n            \\\"Order Mismatch\\\"\\n        );\\n        _saleToken(from, ids, \\\"ETH\\\",_conAddr);\\n        if (ids[3] == 721) {\\n            IBEP721Upgradeable(_conAddr[0]).safeTransferFrom(\\n                from,\\n                msg.sender,\\n                ids[0]\\n            );\\n            if (order_place[from][ids[0]].price > 0) {\\n                delete order_place[from][ids[0]];\\n            }\\n            \\n        } else {\\n            if (IBEP1155Upgradeable(_conAddr[0]).balanceOf(from, ids[0]).sub(ids[2]) == 0) {\\n                if (order_place[from][ids[0]].price > 0) {\\n                    delete order_place[from][ids[0]];\\n                }\\n            }\\n            IBEP1155Upgradeable(_conAddr[0]).safeTransferFrom(\\n                from,\\n                msg.sender,\\n                ids[0],\\n                ids[2],\\n                \\\"\\\"\\n            );\\n            \\n        }\\n    }\\n\\n    // ids[0] - tokenId, ids[1] - amount, ids[2] -  nooftoken, ids[3] - nftType, ids[4] - rewardPer, ids[5] - buyerRewardPer\\n    //ldatas[0] = _royal, ldatas[1] = Tokendecimals, ldatas[2] = approveValue, ldatas[3] = _adminfee,\\n    //ldatas[4] = roy, ldatas[5] = netamount, ldatas[6] = val\\n    function _saleToken(\\n        address payable from,\\n        uint256[] memory ids,\\n        string memory bidtoken,\\n        address[] memory _conAddr\\n    ) internal {\\n        uint256[9] memory ldatas;\\n        ldatas[6] = pBEPent(ids[1], serviceValue).add(ids[1]);\\n        address create;\\n        if(naifty721    ==  _conAddr[0] || naifty1155    ==  _conAddr[0]){\\n        if (ids[3] == 721) {\\n            (create, ldatas[0]) = NAIFTYCollection721(naifty721)\\n                .getCreatorsAndRoyalty(ids[0]);\\n        } else {\\n            (create, ldatas[0]) = NAIFTYCollection1155(naifty1155)\\n                .getCreatorsAndRoyalty(ids[0]);\\n        }\\n        }\\n\\n        if (\\n            keccak256(abi.encodePacked((bidtoken))) ==\\n            keccak256(abi.encodePacked((\\\"ETH\\\")))\\n        ) {\\n            require(msg.value == ldatas[6], \\\"Mismatch the msg.value\\\");\\n            (ldatas[3], ldatas[4], ldatas[5], ldatas[6], ldatas[7]) = calc(\\n                ids[1],\\n                ldatas[0],\\n                ids[4],\\n                ids[5]\\n            );\\n            if (ldatas[3] != 0) {\\n                payable(owner()).transfer(ldatas[3]);\\n            }\\n            if (ldatas[6] != 0) {\\n                payable(_conAddr[1]).transfer(ldatas[6]);\\n            }\\n            if (ldatas[7] != 0) {\\n                payable(msg.sender).transfer(ldatas[7]);\\n            }\\n            if (ldatas[4] != 0) {\\n                payable(create).transfer(ldatas[4]);\\n            }\\n            if (ldatas[5] != 0) {\\n                from.transfer(ldatas[5]);\\n            }\\n        } else {\\n            IBEP20Upgradeable t = IBEP20Upgradeable(tokentype[bidtoken]);\\n            ldatas[1] = deci.sub(t.decimals());\\n            ldatas[2] = t.allowance(msg.sender, address(this));\\n            (ldatas[3], ldatas[4], ldatas[5], ldatas[6], ldatas[7]) = calc(\\n                ids[1],\\n                ldatas[0],\\n                ids[4],\\n                ids[5]\\n            );\\n            if (ldatas[3] != 0) {\\n                t.transferFrom(\\n                    msg.sender,\\n                    owner(),\\n                    ldatas[3].div(10**ldatas[1])\\n                );\\n            }\\n            if (ldatas[6] != 0) {\\n                t.transferFrom(msg.sender, _conAddr[1], ldatas[6].div(10**ldatas[1]));\\n            }\\n            if (ldatas[7] != 0) {\\n                t.transferFrom(msg.sender, msg.sender, ldatas[7].div(10**ldatas[1]));\\n            }\\n            if (ldatas[4] != 0) {\\n                t.transferFrom(msg.sender, create, ldatas[4].div(10**ldatas[1]));\\n            }\\n            if (ldatas[5] != 0) {\\n                t.transferFrom(msg.sender, from, ldatas[5].div(10**ldatas[1]));\\n            }\\n        }\\n    }\\n\\n    // ids[0] - tokenId, ids[1] - amount, ids[2] -  nooftoken, ids[3] - nftType, ids[4] - rewardPer, ids[5] - buyerRewardPer\\n    //_conAddr[0] - Contract Address, _conAddr[1] - refere Address \\n    function saleWithToken(\\n        string memory bidtoken,\\n        address payable from,\\n        uint256[] memory ids,\\n        address[] memory _conAddr\\n    ) public {\\n        require(\\n            ids[1] == order_place[from][ids[0]].price.mul(ids[2]),\\n            \\\"Order is Mismatch\\\"\\n        );\\n        _saleToken(from, ids, bidtoken,_conAddr);\\n        if (ids[3] == 721) {\\n            IBEP721Upgradeable(_conAddr[0]).safeTransferFrom(\\n                from,\\n                msg.sender,\\n                ids[0]\\n            );\\n            \\n            if (order_place[from][ids[0]].price > 0) {\\n                delete order_place[from][ids[0]];\\n            }\\n            \\n        } else {\\n             if (IBEP1155Upgradeable(_conAddr[0]).balanceOf(from, ids[0]).sub(ids[2]) == 0) {\\n                if (order_place[from][ids[0]].price > 0) {\\n                    delete order_place[from][ids[0]];\\n                }\\n            }\\n            IBEP1155Upgradeable(_conAddr[0]).safeTransferFrom(\\n                from,\\n                msg.sender,\\n                ids[0],\\n                ids[2],\\n                \\\"\\\"\\n            );\\n        }\\n    }\\n\\n    // ids[0] - tokenId, ids[1] - amount, ids[2] -  nooftoken, ids[3] - nftType, ids[4] - rewardPer, ids[5] - buyerRewardPer\\n    //_conAddr[0] - Contract Address, _conAddr[1] - refere Address, _conAddr[2] - from Address\\n    function acceptBId(\\n        string memory bidtoken,\\n        uint256[] memory ids,\\n        address[] memory _conAddr\\n    ) public {\\n        _acceptBId(bidtoken, ids,_conAddr);\\n        if (ids[3] == 721) {\\n            IBEP721Upgradeable(_conAddr[0]).safeTransferFrom(\\n                msg.sender,\\n                _conAddr[2],\\n                ids[0]\\n            );\\n            if (order_place[msg.sender][ids[0]].price > 0) {\\n                delete order_place[msg.sender][ids[0]];\\n            }\\n        \\n        } else {\\n             if (\\n                IBEP1155Upgradeable(_conAddr[0]).balanceOf(msg.sender, ids[0]).sub(ids[2]) == 0\\n            ) {\\n                if (order_place[msg.sender][ids[0]].price > 0) {\\n                    delete order_place[msg.sender][ids[0]];\\n                }\\n            }\\n            IBEP1155Upgradeable(_conAddr[0]).safeTransferFrom(\\n                msg.sender,\\n                _conAddr[2],\\n                ids[0],\\n                ids[2],\\n                \\\"\\\"\\n            );\\n           \\n        }\\n    }\\n\\n    // ids[0] - tokenId, ids[1] - amount, ids[2] -  nooftoken, ids[3] - nftType, ids[4] - rewardPer, ids[5] - buyerRewardPer\\n    //ldatas[0] = _royal, ldatas[1] = Tokendecimals, ldatas[2] = approveValue, ldatas[3] = _adminfee,\\n    //ldatas[4] = roy, ldatas[5] = netamount, ldatas[6] = val\\n    //_conAddr[0] - Contract Address, _conAddr[1] - refere Address, _conAddr[2] - from Address\\n    function _acceptBId(\\n        string memory tokenAss,\\n        uint256[] memory ids,\\n        address[] memory _conAddr\\n    ) internal {\\n        uint256[9] memory ldatas;\\n        ldatas[6] = pBEPent(ids[1], serviceValue).add(ids[1]);\\n        address create;\\n        if(naifty721    ==  _conAddr[0] || naifty1155    ==  _conAddr[0]){\\n\\n        if (ids[3] == 721) {\\n            (create, ldatas[0]) = NAIFTYCollection721(naifty721)\\n                .getCreatorsAndRoyalty(ids[0]);\\n        } else {\\n            (create, ldatas[0]) = NAIFTYCollection1155(naifty1155)\\n                .getCreatorsAndRoyalty(ids[0]);\\n        }\\n        }\\n        IBEP20Upgradeable t = IBEP20Upgradeable(tokentype[tokenAss]);\\n        ldatas[1] = deci.sub(t.decimals());\\n        ldatas[2] = t.allowance(_conAddr[2], address(this));\\n        (ldatas[3], ldatas[4], ldatas[5], ldatas[6], ldatas[7]) = calc(\\n            ids[1],\\n            ldatas[0],\\n            ids[4],\\n            ids[5]\\n        );\\n        if (ldatas[3] != 0) {\\n            t.transferFrom(_conAddr[2], owner(), ldatas[3].div(10**ldatas[1]));\\n        }\\n        if (ldatas[6] != 0) {\\n            t.transferFrom(_conAddr[2], _conAddr[1], ldatas[6].div(10**ldatas[1]));\\n        }\\n        if (ldatas[7] != 0) {\\n            t.transferFrom(_conAddr[2], _conAddr[2], ldatas[7].div(10**ldatas[1]));\\n        }\\n        if (ldatas[4] != 0) {\\n            t.transferFrom(_conAddr[2], create, ldatas[4].div(10**ldatas[1]));\\n        }\\n        if (ldatas[5] != 0) {\\n            t.transferFrom(_conAddr[2], msg.sender, ldatas[5].div(10**ldatas[1]));\\n        }\\n    }\\n\\n    // datas[0] - supply, datas[1] - nftType, datas[2] -  royal, datas[3] - price\\n    function minting(\\n        string memory ipfsmetadata,\\n        uint256[] memory datas,\\n        string memory status\\n    ) public {\\n        require(\\n            msg.sender == owner() || publicMint == true,\\n            \\\"Public Mint Not Available\\\"\\n        );\\n        _tid = _tid.add(1);\\n        uint256 id_ = _tid.add(block.timestamp);\\n        \\n        if (datas[1] == 721) {\\n            NAIFTYCollection721(naifty721).mint(\\n                ipfsmetadata,\\n                msg.sender,\\n                datas[2],\\n                id_\\n            );\\n            if (datas[3] > 0) {\\n                orderPlace(id_, datas[3], naifty721, datas[1], \\\"mint\\\");\\n            } else {\\n                emit OrderPlace(msg.sender, id_, datas[3]);\\n            }\\n        } else {\\n            NAIFTYCollection1155(naifty1155).mint(\\n                ipfsmetadata,\\n                msg.sender,\\n                datas[0],\\n                datas[2],\\n                id_\\n            );\\n            if (datas[3] > 0) {\\n                orderPlace(id_, datas[3], naifty1155, datas[1], \\\"mint\\\");\\n            } else {\\n                emit OrderPlace(msg.sender, id_, datas[3]);\\n            }\\n        }\\n        emit Create(msg.sender, id_,status);\\n    }\\n\\n    function enablePublicMint() public onlyOwner {\\n        publicMint = true;\\n    }\\n\\n    function disablePublicMint() public onlyOwner {\\n        publicMint = false;\\n    }\\n\\n    function setCollectionAddress(address _naifty721, address _naifty1155)\\n        public\\n        onlyOwner\\n    {\\n        naifty721 = _naifty721;\\n        naifty1155 = _naifty1155;\\n    }\\n    function SetRoyalty(uint96 _royPer) public onlyOwner{\\n        NAIFTYCollection721(naifty721).setRoyaltyPBEPentage(_royPer);\\n        NAIFTYCollection1155(naifty1155).setRoyaltyPBEPentage(_royPer);\\n    }\\n    function changeCollectionOwner(address to) public {\\n        NAIFTYCollection721(naifty721).changeCollectionOwner(to);\\n        NAIFTYCollection1155(naifty1155).changeCollectionOwner(to);\\n    }\\n    function _adminBurn(uint256 tokenId, uint256 amount, address from) public onlyOwner{\\n        NAIFTYCollection721(naifty721).adminBurn(tokenId);\\n        NAIFTYCollection1155(naifty1155).adminBurn(tokenId,amount,from);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"CancelOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cRoyalty\",\"type\":\"uint256\"}],\"name\":\"ColletionId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"OrderPlace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_royPer\",\"type\":\"uint96\"}],\"name\":\"SetRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"_adminBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"bidtoken\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_conAddr\",\"type\":\"address[]\"}],\"name\":\"acceptBId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_type\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddress\",\"type\":\"address[]\"}],\"name\":\"addTokenType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"approveStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"changeCollectionOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"changePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disablePublicMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enablePublicMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owneraddrrss\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"contractaddress\",\"type\":\"address\"}],\"name\":\"getApproveStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getServiceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_type\",\"type\":\"string\"}],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ipfsmetadata\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"datas\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"name\":\"minting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"naifty1155\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"naifty721\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_conAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_status\",\"type\":\"string\"}],\"name\":\"orderPlace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"order_place\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_conAddr\",\"type\":\"address[]\"}],\"name\":\"saleToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"bidtoken\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_conAddr\",\"type\":\"address[]\"}],\"name\":\"saleWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_naifty721\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_naifty1155\",\"type\":\"address\"}],\"name\":\"setCollectionAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_serviceValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerfee\",\"type\":\"uint256\"}],\"name\":\"setServiceValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NaiftyTrade", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}