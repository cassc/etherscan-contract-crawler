{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-09-30\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2023-09-04\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n \r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ncontract RaceGame {\r\n    event RaceCreated(uint raceId);\r\n    event JoinRace(uint raceId, address joined, uint nftJoined);\r\n    event RaceStarted(uint raceId);\r\n    event RaceFull(uint raceId);\r\n    event RaceComplete(uint raceId, address winner, uint amount);\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    struct Race {\r\n        uint id;\r\n        string eventName;\r\n        uint status; // 0 initialized, 1 complete, 2 finished\r\n        address[] players;\r\n        uint256[] nftIds;\r\n        uint maxPlayers;\r\n        uint entryFee;\r\n        bool started;\r\n        address winner;\r\n        uint nftWinner;\r\n        uint distance;\r\n        bool isGiveAway;\r\n        uint giveawayValue;\r\n        address tokenUsed;\r\n        uint qtyWinners;\r\n    }\r\n\r\n    struct RaceTimestamp {\r\n        uint id;\r\n        uint createdAt;\r\n        uint completedAt;\r\n    }\r\n\r\n    struct UserData {\r\n        address userAddress;\r\n        address tokenAddress;\r\n        uint amount;\r\n    }\r\n    \r\n    uint public raceCounter;\r\n    bool public gameIsPaused = false;\r\n    address claimWallet;\r\n    mapping(uint => Race) public races;\r\n    mapping(uint => RaceTimestamp) public racesTime;\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) public balancePerRacerAndToken;\r\n    mapping(uint => mapping(address => bool)) public racePlayers;\r\n    mapping(uint => uint) public countNftWinnings; // receive an nft id, and return cant of winnings\r\n    mapping(uint => uint) public countNftPoints;\r\n    mapping(address => uint) public countNftWinningsOnAddress; // receive an nft id, and return cant of winnings\r\n    mapping(address => uint) public countNftPointsOnAddress;\r\n\r\n    mapping(address => bool) public tokensAvailable;\r\n    address[] public tokenAvailableList;\r\n\r\n\r\n    mapping (uint => mapping (address => uint)) raceAddressNft;\r\n    mapping(address => bool) public isInBlacklist;\r\n\r\n\r\n    mapping(uint => uint) public xpForRacers;\r\n\r\n    uint256 public COMMISSION_ON_LEAVE = 4;\r\n\r\n    address public owner;\r\n    uint public commission;\r\n    uint public accumulatedCommission;\r\n    mapping(address => uint) public accumulatedCommissionPerToken;\r\n    address public tokenNft;\r\n\r\n    constructor(address _tokenNft)\r\n    {\r\n        owner = msg.sender;\r\n        claimWallet = msg.sender;\r\n        commission = 4;\r\n        tokenNft = _tokenNft;\r\n        xpForRacers[1] = 100;\r\n        xpForRacers[2] = 50;\r\n        xpForRacers[3] = 25;\r\n        tokensAvailable[DEAD] = true;\r\n        tokenAvailableList.push(DEAD);\r\n\r\n    }\r\n    \r\n    function createRace(uint _maxPlayers, uint _entryFee, uint _giveawayValue, uint _distance, string memory _eventName, uint _nftId, bool _isGiveAway, address _tokenToPlay, uint _qtyWinners) public payable {\r\n        require(tokensAvailable[_tokenToPlay], \"Token not able to pay.\");\r\n        require(!isInBlacklist[msg.sender], \"User is in blacklist\");\r\n        require(!gameIsPaused, \"Game is paused\");\r\n        require(_maxPlayers > 0, \"Max players must be greater than 0\");\r\n        if (_tokenToPlay != DEAD && _tokenToPlay != address(0)) {\r\n            if(_isGiveAway) {\r\n                require(_entryFee == 0, \"Entry fee has to be 0\");\r\n                require(_giveawayValue > 0, \"Giveaway value has to be greater than 0\");\r\n                require(_giveawayValue <= IERC20(_tokenToPlay).balanceOf(msg.sender), \"Balance has to be greater than giveaway value.\");\r\n                IERC20(_tokenToPlay).transferFrom(msg.sender, address(this), _giveawayValue);\r\n            } else {\r\n                require(_entryFee > 0, \"Entry fee has to be greater than 0\");\r\n                require(_entryFee <= IERC20(_tokenToPlay).balanceOf(msg.sender), \"Balance has to be greater than entry fee.\");\r\n                IERC20(_tokenToPlay).transferFrom(msg.sender, address(this), _entryFee);\r\n            }\r\n        } else {\r\n            if(_isGiveAway) {\r\n                require(_entryFee == 0, \"Entry fee has to be 0\");\r\n                require(_giveawayValue > 0, \"Giveaway value has to be greater than 0\");\r\n                require(msg.value >= _giveawayValue, \"Giveaway value has to be greater or equal to giveaway value.\");\r\n            } else {\r\n                require(_entryFee > 0, \"Entry fee has to be greater than 0\");\r\n                require(msg.value >= _entryFee, \"Entry fee has to be greater or equal to entry fee.\");\r\n            }\r\n        }\r\n        if (_nftId > 0) {\r\n            require(IERC721(tokenNft).ownerOf(_nftId) == msg.sender, \"You don't own this NFT\");\r\n        }\r\n\r\n        raceCounter++;\r\n        races[raceCounter] = Race(raceCounter, _eventName, 0, new address[](0), new uint256[](0), _maxPlayers, _entryFee, false, address(0), 0, _distance, _isGiveAway, _giveawayValue, _tokenToPlay, _qtyWinners);\r\n        racesTime[raceCounter] = RaceTimestamp(raceCounter, block.timestamp, block.timestamp);\r\n        emit RaceCreated(raceCounter);\r\n        if (!_isGiveAway) {\r\n            autoJoinRace(raceCounter, _nftId);\r\n        }\r\n    }\r\n\r\n    function autoJoinRace(uint _raceId, uint _nftId) internal {\r\n        races[_raceId].players.push(msg.sender);\r\n        races[_raceId].nftIds.push(_nftId);\r\n        racePlayers[_raceId][msg.sender] = true;\r\n        emit JoinRace(_raceId, msg.sender, _nftId);\r\n        if (races[_raceId].players.length == races[_raceId].maxPlayers) {\r\n            startRace(_raceId);\r\n            emit RaceFull(_raceId);\r\n        }\r\n    }\r\n    \r\n    function joinRace(uint _raceId, uint _nftId) public payable {\r\n        require(_raceId > 0 && _raceId <= raceCounter, \"Invalid race ID\");\r\n        require(!isInBlacklist[msg.sender], \"User is in blacklist\");\r\n        require(!gameIsPaused, \"Game is paused\");\r\n        require(!races[_raceId].started, \"Race has already started\");\r\n        require(races[_raceId].players.length < races[_raceId].maxPlayers, \"Race is already full\");\r\n        require(!racePlayers[_raceId][msg.sender], \"Already joined the race\");\r\n        if (races[_raceId].tokenUsed != DEAD) {\r\n            uint balanceOf = IERC20(races[_raceId].tokenUsed).balanceOf(msg.sender);\r\n            require((races[_raceId].isGiveAway && msg.value == 0) || (!races[_raceId].isGiveAway && balanceOf >= races[_raceId].entryFee), \"Entry fee is incorrect (t)\");\r\n            if(!races[_raceId].isGiveAway) {\r\n                IERC20(races[_raceId].tokenUsed).transferFrom(msg.sender, address(this), races[_raceId].entryFee);\r\n            }\r\n        } else {\r\n            require((races[_raceId].isGiveAway && msg.value == 0) || (!races[_raceId].isGiveAway && msg.value == races[_raceId].entryFee), \"Entry fee is incorrect\");\r\n        }\r\n\r\n        if (_nftId > 0) {\r\n            require(IERC721(tokenNft).ownerOf(_nftId) == msg.sender, \"You don't own this NFT\");\r\n            raceAddressNft[_raceId][msg.sender] = _nftId;\r\n        }\r\n\r\n        races[_raceId].players.push(msg.sender);\r\n        races[_raceId].nftIds.push(_nftId);\r\n        racePlayers[_raceId][msg.sender] = true;\r\n        emit JoinRace(_raceId, msg.sender, _nftId);\r\n        if (races[_raceId].players.length == races[_raceId].maxPlayers) {\r\n            startRace(_raceId);\r\n            emit RaceFull(_raceId);\r\n        }\r\n    }\r\n\r\n    function startRace(uint _raceId) internal {\r\n        require(_raceId > 0 && _raceId <= raceCounter, \"Invalid race ID\");\r\n        require(!races[_raceId].started, \"Race has already started\");\r\n        require(races[_raceId].players.length == races[_raceId].maxPlayers, \"Race is not full\");\r\n        races[_raceId].started = true;\r\n        races[_raceId].status = 1;\r\n        emit RaceStarted(_raceId);\r\n    }\r\n    \r\n    function completeRace(uint _raceId) public onlyOwner {\r\n        require(_raceId > 0 && _raceId <= raceCounter, \"Invalid race ID\");\r\n        require(races[_raceId].started, \"Race has not started yet\");\r\n        require(races[_raceId].winner == address(0), \"Race winner has already been determined\");\r\n\r\n        uint randomIndex = uint(keccak256(abi.encodePacked(block.timestamp, block.prevrandao))) % races[_raceId].players.length;\r\n\r\n        // Define winner\r\n        races[_raceId].winner = races[_raceId].players[randomIndex];\r\n        races[_raceId].nftWinner = raceAddressNft[_raceId][races[_raceId].players[randomIndex]];\r\n\r\n        uint totalPrize = races[_raceId].entryFee * races[_raceId].players.length;\r\n        uint commisionOfRaceDividend = totalPrize * commission;\r\n        uint commisionOfRace = commisionOfRaceDividend / 100;\r\n        address secondAddress = races[_raceId].players[(randomIndex + 1) % races[_raceId].players.length];\r\n        address thirdAddress = races[_raceId].players[(randomIndex + 2) % races[_raceId].players.length];\r\n\r\n        if (races[_raceId].isGiveAway) {\r\n            // We need to set the entry fee as the total amount (not multiply it with the total number of players)\r\n            totalPrize = races[_raceId].giveawayValue;\r\n            commisionOfRaceDividend = totalPrize * commission;\r\n            commisionOfRace = commisionOfRaceDividend / 100;\r\n\r\n            // If is giveaway i have to check if has 1 winner or 3\r\n            totalPrize = races[_raceId].giveawayValue - commisionOfRace;\r\n\r\n            if (races[_raceId].qtyWinners == 1) {\r\n                //Case of one winner, normal pay\r\n                if (races[_raceId].tokenUsed != DEAD) {\r\n                    balancePerRacerAndToken[races[_raceId].winner][races[_raceId].tokenUsed] += totalPrize;\r\n                    accumulatedCommissionPerToken[races[_raceId].tokenUsed] += commisionOfRace;\r\n                } else {\r\n                    balances[races[_raceId].winner] += totalPrize;\r\n                    accumulatedCommission += commisionOfRace;\r\n                }\r\n            } else {\r\n                // case of 3 winners, pay as equal\r\n                if (races[_raceId].tokenUsed != DEAD) {\r\n                    balancePerRacerAndToken[races[_raceId].winner][races[_raceId].tokenUsed] += totalPrize / 3;\r\n                    balancePerRacerAndToken[secondAddress][races[_raceId].tokenUsed] += totalPrize / 3;\r\n                    balancePerRacerAndToken[thirdAddress][races[_raceId].tokenUsed] += totalPrize / 3;\r\n                    accumulatedCommissionPerToken[races[_raceId].tokenUsed] += commisionOfRace;\r\n                } else {\r\n                    balances[races[_raceId].winner] += totalPrize / 3;\r\n                    balances[secondAddress] += totalPrize / 3;\r\n                    balances[thirdAddress] += totalPrize / 3;\r\n                    accumulatedCommission += commisionOfRace;\r\n                }\r\n            }\r\n        } else {\r\n            // Add points and winner race nft\r\n            countNftWinnings[races[_raceId].nftWinner] = countNftWinnings[races[_raceId].nftWinner] + 1;\r\n            countNftPoints[races[_raceId].nftWinner] = countNftPoints[races[_raceId].nftWinner] + xpForRacers[1];\r\n\r\n            // Add points and winner race address\r\n            countNftWinningsOnAddress[races[_raceId].winner] = countNftWinningsOnAddress[races[_raceId].winner] + 1;\r\n            countNftPointsOnAddress[races[_raceId].winner] = countNftPointsOnAddress[races[_raceId].winner] + xpForRacers[1];\r\n\r\n            //Define second\r\n            uint nftSecondPlace = raceAddressNft[_raceId][secondAddress];\r\n            // Add points to second nft\r\n            countNftPoints[nftSecondPlace] = countNftPoints[nftSecondPlace] + xpForRacers[2];\r\n\r\n            // Add points to second address\r\n            countNftPointsOnAddress[secondAddress] = countNftPointsOnAddress[secondAddress] + xpForRacers[2];\r\n\r\n            //Define Third\r\n            if (races[_raceId].players.length > 2) {\r\n                uint nftThirdPlace = raceAddressNft[_raceId][thirdAddress];\r\n                // Add points to third one\r\n                countNftPoints[nftThirdPlace] = countNftPoints[nftThirdPlace] + xpForRacers[3];\r\n\r\n                // Add points to third one address\r\n                countNftPointsOnAddress[thirdAddress] = countNftPointsOnAddress[thirdAddress] + xpForRacers[3];\r\n            }\r\n\r\n            if (races[_raceId].tokenUsed != DEAD) {\r\n                balancePerRacerAndToken[races[_raceId].winner][races[_raceId].tokenUsed] += totalPrize - commisionOfRace;\r\n                accumulatedCommissionPerToken[races[_raceId].tokenUsed] += commisionOfRace;\r\n            } else {\r\n                balances[races[_raceId].winner] += totalPrize - commisionOfRace;\r\n                accumulatedCommission += commisionOfRace;\r\n            }\r\n        }\r\n\r\n        races[_raceId].status = 2;\r\n        racesTime[_raceId].completedAt = block.timestamp;\r\n        emit RaceComplete(_raceId, races[_raceId].winner, totalPrize - commisionOfRace);\r\n\r\n    }\r\n\r\n    // Helpers\r\n    function getRace(uint _raceId) public view returns (Race memory) {\r\n        return races[_raceId];\r\n    }\r\n\r\n    function setIsInBlacklist(address _addy, bool _blacklisted) public onlyOwner {\r\n        isInBlacklist[_addy] = _blacklisted;\r\n    }\r\n\r\n    function setClaimWallet(address _claimWallet) public onlyOwner {\r\n        claimWallet = _claimWallet;\r\n    }\r\n\r\n    function setOptions(uint _commission, uint _commissionOnLeave, bool _gameIsPaused) public onlyOwner {\r\n        commission = _commission;\r\n        COMMISSION_ON_LEAVE = _commissionOnLeave;\r\n        gameIsPaused = _gameIsPaused;\r\n    }\r\n\r\n    function claim(address _tokenAddress) public  {\r\n        if (_tokenAddress == DEAD) {\r\n            require(balances[msg.sender] > 0, \"User doesnt have funds\");\r\n            payable(msg.sender).transfer(balances[msg.sender]);\r\n            balances[msg.sender] = 0;\r\n        } else {\r\n            require(balancePerRacerAndToken[msg.sender][_tokenAddress] > 0, \"User doesnt have funds (tokens)\");\r\n            IERC20(_tokenAddress).approve(address(this), IERC20(_tokenAddress).balanceOf(address(this)));\r\n            IERC20(_tokenAddress).transfer(msg.sender, balancePerRacerAndToken[msg.sender][_tokenAddress]);\r\n            balancePerRacerAndToken[msg.sender][_tokenAddress] = 0;\r\n        }\r\n    }\r\n\r\n    function claimCommission() public onlyOwner {\r\n        require(accumulatedCommission > 0, \"User doesnt have funds\");\r\n        payable(claimWallet).transfer(accumulatedCommission);\r\n        accumulatedCommission = 0;\r\n    }\r\n\r\n    function claimCommissionToken(address _tokenAddress) public onlyOwner {\r\n        IERC20(_tokenAddress).approve(address(this), IERC20(_tokenAddress).balanceOf(address(this)));\r\n        IERC20(_tokenAddress).transfer(claimWallet, accumulatedCommissionPerToken[_tokenAddress]);\r\n        accumulatedCommissionPerToken[_tokenAddress] = 0;\r\n    }\r\n\r\n    function getRacesIdByStatus(uint _status) public view returns (uint[] memory) {\r\n        require(_status >= 0 && _status <= 3, \"Invalid race status\");\r\n\r\n        // First, we need to determine how many races have the requested status\r\n        uint count = 0;\r\n        for (uint i = 1; i <= raceCounter; i++) {\r\n            if (races[i].status == _status) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Now we know the size of racesByStatus, so we can initialize it\r\n        uint[] memory racesByStatus = new uint[](count);\r\n        uint index = 0;\r\n        for (uint i = 1; i <= raceCounter; i++) {\r\n            if (races[i].status == _status) {\r\n                racesByStatus[index] = races[i].id;\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return racesByStatus;\r\n    }\r\n\r\n    function getRacesIdByStatusAndGiveAway(uint _status, bool _isGiveAway) public view returns (uint[] memory) {\r\n        require(_status >= 0 && _status <= 3, \"Invalid race status\");\r\n\r\n        // First, we need to determine how many races have the requested status\r\n        uint count = 0;\r\n        for (uint i = 1; i <= raceCounter; i++) {\r\n            if (races[i].status == _status && races[i].isGiveAway == _isGiveAway) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Now we know the size of racesByStatus, so we can initialize it\r\n        uint[] memory racesByStatus = new uint[](count);\r\n        uint index = 0;\r\n        for (uint i = 1; i <= raceCounter; i++) {\r\n            if (races[i].status == _status && races[i].isGiveAway == _isGiveAway) {\r\n                racesByStatus[index] = races[i].id;\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return racesByStatus;\r\n    }\r\n\r\n    function getNFTForRaceAndUser(uint256 _raceId, address _userId) public view returns (uint) {\r\n        return raceAddressNft[_raceId][_userId];\r\n    }\r\n\r\n    function setXpForRacers(uint index, uint value) public onlyOwner {\r\n        xpForRacers[index] = value;\r\n    }\r\n\r\n    function setTokenNft(address _tokenNft) public onlyOwner {\r\n        tokenNft = _tokenNft;\r\n    }\r\n\r\n    function setNftPointsAddresses(address[] memory nftIds, uint[] memory nftPoints) public onlyOwner {\r\n        require(nftIds.length == nftPoints.length, \"Sizes of ids and points has to be similar\");\r\n        \r\n        for(uint i = 0; i < nftIds.length; i++) {\r\n            countNftPointsOnAddress[nftIds[i]] = nftPoints[i];\r\n        }\r\n    }\r\n\r\n    function setNftWinningsAddresses(address[] memory nftIds, uint[] memory nftWinnings) public onlyOwner {\r\n        require(nftIds.length == nftWinnings.length, \"Sizes of ids and points has to be similar\");\r\n        \r\n        for(uint i = 0; i < nftIds.length; i++) {\r\n            countNftWinningsOnAddress[nftIds[i]] = nftWinnings[i];\r\n        }\r\n    }\r\n\r\n    function setNftPoints(uint[] memory nftIds, uint[] memory nftPoints) public onlyOwner {\r\n        require(nftIds.length == nftPoints.length, \"Sizes of ids and points has to be similar\");\r\n        \r\n        for(uint i = 0; i < nftIds.length; i++) {\r\n            countNftPoints[nftIds[i]] = nftPoints[i];\r\n        }\r\n    }\r\n\r\n    function setNftWinnings(uint[] memory nftIds, uint[] memory nftWinnings) public onlyOwner {\r\n        require(nftIds.length == nftWinnings.length, \"Sizes of ids and points has to be similar\");\r\n        \r\n        for(uint i = 0; i < nftIds.length; i++) {\r\n            countNftWinnings[nftIds[i]] = nftWinnings[i];\r\n        }\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can perform this action\");\r\n        _;\r\n    }\r\n\r\n    function leaveRace(uint _raceId) public {\r\n        require(_raceId > 0 && _raceId <= raceCounter, \"Invalid race ID\");\r\n        require(!races[_raceId].started, \"Race has already started\");\r\n        require(racePlayers[_raceId][msg.sender], \"You are not part of this race\");\r\n\r\n        // Remove player from the race\r\n        for (uint i = 0; i < races[_raceId].players.length; i++) {\r\n            if (races[_raceId].players[i] == msg.sender) {\r\n                races[_raceId].players[i] = races[_raceId].players[races[_raceId].players.length - 1];\r\n                races[_raceId].players.pop();\r\n\r\n                races[_raceId].nftIds[i] = races[_raceId].nftIds[races[_raceId].nftIds.length - 1];\r\n                races[_raceId].nftIds.pop();\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Update the race players mapping\r\n        racePlayers[_raceId][msg.sender] = false;\r\n\r\n        // If not giveaway, return fee\r\n        if (!races[_raceId].isGiveAway) {\r\n            uint commissionOnLeave = (races[_raceId].entryFee * COMMISSION_ON_LEAVE) / 100;\r\n\r\n            uint totalToReturn = races[_raceId].entryFee - commissionOnLeave;\r\n            accumulatedCommission += commissionOnLeave;\r\n\r\n            if (races[_raceId].tokenUsed != DEAD) {\r\n                IERC20(races[_raceId].tokenUsed).approve(address(this), IERC20(races[_raceId].tokenUsed).balanceOf(address(this)));\r\n                IERC20(races[_raceId].tokenUsed).transfer(msg.sender, totalToReturn);\r\n            } else {\r\n                payable(msg.sender).transfer(totalToReturn);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function addTokenPay(address tokenPay) external onlyOwner {\r\n        require(!tokensAvailable[tokenPay], \"Token pay already added.\");\r\n        tokensAvailable[tokenPay] = true;\r\n        tokenAvailableList.push(tokenPay);\r\n    }\r\n\r\n    function removeTokenPay(address tokenPay) external onlyOwner {\r\n        require(tokensAvailable[tokenPay], \"Token Pay not found.\");\r\n        tokensAvailable[tokenPay] = false;\r\n        for (uint i = 0; i < tokenAvailableList.length; i++) {\r\n            if (tokenAvailableList[i] == tokenPay) {\r\n                tokenAvailableList[i] = tokenAvailableList[tokenAvailableList.length - 1];\r\n                tokenAvailableList.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function ableToClaim(address _userAddy) public view returns (UserData[] memory) {\r\n        UserData[] memory returnData = new UserData[](tokenAvailableList.length + 1);\r\n        returnData[0] = UserData({userAddress: _userAddy, tokenAddress: address(0x0), amount: balances[_userAddy]});\r\n        \r\n        for (uint i = 0; i < tokenAvailableList.length; i++) {\r\n            returnData[i + 1] = UserData({userAddress: _userAddy, tokenAddress: tokenAvailableList[i], amount: balancePerRacerAndToken[_userAddy][tokenAvailableList[i]]});\r\n        }\r\n        \r\n        return returnData;\r\n    }\r\n\r\n    function cancelRace(uint _raceId) public onlyOwner {\r\n        require(_raceId > 0 && _raceId <= raceCounter, \"Invalid race ID\");\r\n        require(!races[_raceId].started, \"Race has already started\");\r\n\r\n        IERC20(races[_raceId].tokenUsed).approve(address(this), IERC20(races[_raceId].tokenUsed).balanceOf(address(this)));\r\n        // Refund all players if not giveAway\r\n        if (!races[_raceId].isGiveAway) {\r\n            for (uint i = 0; i < races[_raceId].players.length; i++) {\r\n                if (races[_raceId].tokenUsed != DEAD) {\r\n                    IERC20(races[_raceId].tokenUsed).transfer(races[_raceId].players[i], races[_raceId].entryFee);\r\n                } else if (!isContract(races[_raceId].players[i])) {\r\n                    payable(races[_raceId].players[i]).transfer(races[_raceId].entryFee);\r\n                } else {\r\n                    payable(owner).transfer(races[_raceId].entryFee);\r\n                }\r\n            }\r\n        }\r\n\r\n        races[_raceId].players = new address[](0);\r\n        races[_raceId].status = 3;\r\n    }\r\n\r\n    function getActiveRaces() public view returns (uint[] memory) {\r\n        uint count = 0;\r\n        for (uint i = 1; i <= raceCounter; i++) {\r\n            if (races[i].status == 0) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        uint[] memory activeRaces = new uint[](count);\r\n\r\n        uint j = 0;\r\n        for (uint i = 1; i <= raceCounter; i++) {\r\n            if (races[i].status == 0) {\r\n                activeRaces[j] = i;\r\n                j++;\r\n            }\r\n        }\r\n\r\n        return activeRaces;\r\n    }\r\n\r\n    function getPlayersByRaceId(uint256 raceId) public view returns (address[] memory) {\r\n        return races[raceId].players;\r\n    }\r\n\r\n    function getNftsByRaceId(uint256 raceId) public view returns (uint256[] memory) {\r\n        return races[raceId].nftIds;\r\n    }\r\n\r\n    function unstuck(uint256 _amount, address _addy) onlyOwner public {\r\n        if (_addy == address(0)) {\r\n            (bool sent,) = address(msg.sender).call{value: _amount}(\"\");\r\n            require(sent, \"funds has to be sent\");\r\n        } else {\r\n            bool approve_done = IERC20(_addy).approve(address(this), IERC20(_addy).balanceOf(address(this)));\r\n            require(approve_done, \"CA cannot approve tokens\");\r\n            require(IERC20(_addy).balanceOf(address(this)) > 0, \"No tokens\");\r\n            IERC20(_addy).transfer(msg.sender, _amount);\r\n        }\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        return addr.code.length > 0;\r\n    }\r\n\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenNft\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raceId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"joined\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftJoined\",\"type\":\"uint256\"}],\"name\":\"JoinRace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raceId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RaceComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raceId\",\"type\":\"uint256\"}],\"name\":\"RaceCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raceId\",\"type\":\"uint256\"}],\"name\":\"RaceFull\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raceId\",\"type\":\"uint256\"}],\"name\":\"RaceStarted\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"COMMISSION_ON_LEAVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddy\",\"type\":\"address\"}],\"name\":\"ableToClaim\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaceGame.UserData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accumulatedCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accumulatedCommissionPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenPay\",\"type\":\"address\"}],\"name\":\"addTokenPay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balancePerRacerAndToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_raceId\",\"type\":\"uint256\"}],\"name\":\"cancelRace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimCommission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"claimCommissionToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_raceId\",\"type\":\"uint256\"}],\"name\":\"completeRace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"countNftPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"countNftPointsOnAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"countNftWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"countNftWinningsOnAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPlayers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_entryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_giveawayValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_distance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_eventName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isGiveAway\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_tokenToPlay\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_qtyWinners\",\"type\":\"uint256\"}],\"name\":\"createRace\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameIsPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveRaces\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_raceId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_userId\",\"type\":\"address\"}],\"name\":\"getNFTForRaceAndUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raceId\",\"type\":\"uint256\"}],\"name\":\"getNftsByRaceId\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raceId\",\"type\":\"uint256\"}],\"name\":\"getPlayersByRaceId\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_raceId\",\"type\":\"uint256\"}],\"name\":\"getRace\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"eventName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"players\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxPlayers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"entryFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"started\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftWinner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isGiveAway\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"giveawayValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenUsed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qtyWinners\",\"type\":\"uint256\"}],\"internalType\":\"struct RaceGame.Race\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_status\",\"type\":\"uint256\"}],\"name\":\"getRacesIdByStatus\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_status\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isGiveAway\",\"type\":\"bool\"}],\"name\":\"getRacesIdByStatusAndGiveAway\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isInBlacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_raceId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"joinRace\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_raceId\",\"type\":\"uint256\"}],\"name\":\"leaveRace\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raceCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"racePlayers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"races\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"eventName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPlayers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"entryFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"started\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftWinner\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isGiveAway\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"giveawayValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenUsed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qtyWinners\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"racesTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"completedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenPay\",\"type\":\"address\"}],\"name\":\"removeTokenPay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_claimWallet\",\"type\":\"address\"}],\"name\":\"setClaimWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_blacklisted\",\"type\":\"bool\"}],\"name\":\"setIsInBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftPoints\",\"type\":\"uint256[]\"}],\"name\":\"setNftPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nftIds\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftPoints\",\"type\":\"uint256[]\"}],\"name\":\"setNftPointsAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftWinnings\",\"type\":\"uint256[]\"}],\"name\":\"setNftWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nftIds\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftWinnings\",\"type\":\"uint256[]\"}],\"name\":\"setNftWinningsAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commission\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_commissionOnLeave\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_gameIsPaused\",\"type\":\"bool\"}],\"name\":\"setOptions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenNft\",\"type\":\"address\"}],\"name\":\"setTokenNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setXpForRacers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenAvailableList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenNft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"unstuck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"xpForRacers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RaceGame", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d89c524f9016a5105a3f4318b402a1f3903f48f3", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6257217d1f328734a5e9d4d3a444dc16291933ec87044197f021039de2c48f9d"}