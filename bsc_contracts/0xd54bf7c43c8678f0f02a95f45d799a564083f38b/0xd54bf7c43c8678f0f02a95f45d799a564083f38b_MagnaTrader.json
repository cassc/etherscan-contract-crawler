{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        if (_status == _ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nstruct UserInfo {\\n    uint256 deposit;\\n    uint256 balance;\\n    uint256 lastClaim;\\n}\\n\\ninterface IMlmSystem {\\n    function usersByReferral(address user_) external view returns (address[] memory);\\n    function subscriptionIsValid(address owner_) external view returns (bool);\\n    function userMaxDepositAmount(address owner_) external view returns (uint256);\\n    function getRecruitors(address user_) external view returns (address[5] memory);\\n}\\n\\ninterface IMagnaLiquidity {\\n    function deposit(address sender_) external returns (uint256);\\n    function redeposit(address sender_, uint256 lastDeposit_) external returns (uint256);\\n    function withdraw(address sender_, uint256 amount_) external returns (uint256, uint256);\\n    function depositNetAmount(uint256 amount_) external view returns (uint256);\\n    function redepositNetAmount(uint256 amount_, uint256 userDeposited_) external view returns (uint256);\\n    function userDeposited(address owner_) external view returns (uint256);\\n    function userInfo(address owner_) external view returns (UserInfo memory);\\n    function depositForFund(uint256 amount_) external;\\n}\\n\"\r\n    },\r\n    \"src/MagnaTrader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport { Ownable } from \\\"openzeppelin/access/Ownable.sol\\\";\\nimport { IERC20 } from \\\"openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport { ReentrancyGuard } from \\\"openzeppelin/security/ReentrancyGuard.sol\\\";\\nimport { IMagnaLiquidity, IMlmSystem, UserInfo } from \\\"src/Interfaces.sol\\\";\\n\\n/**\\n * @title Magna Trader\\n * @notice Magna is a protocol that enables users to subscribe and trade the MAGNA token.\\n * Through a multi-level marketing system, subscribers can earn profits by inviting others\\n * to join and trade the token. The protocol also has a commission system for executed\\n * operations, which the company receives for various purposes.\\n * @notice MagnaTrader is a contract that enables subscribers to trade MAGNA for USDT.\\n * It interacts with MagnaLiquidity and holds investors' MAGNA tokens.\\n */\\ncontract MagnaTrader is Ownable, ReentrancyGuard {\\n    IMagnaLiquidity public immutable MagnaLiquidity;\\n    IMlmSystem public immutable MLMSystem;\\n    IERC20 public immutable MAGNA;\\n    IERC20 public immutable USDT;\\n\\n    struct DepositHistory {\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n\\n    address private _treasury = 0x8Ef46EDD3cc5b6C7285b912C176F727A189a1877;\\n    uint256 private constant FEE_DENOMINATOR = 100_000;\\n    uint256 private _withdrawProfitFee = 36000;\\n    uint256[5] private _withdrawProfitDistribution = [6000, 3000, 2000, 2000, 2000];\\n    uint256 private _liquidityFee = 3000;\\n    uint256 private _successReward = 6000;\\n    uint256 private _successRewardDirectReferralsMin = 6;\\n    uint256 private _successRewardInvestVolumeMin = 7500 * 1e18;\\n    uint256 private _autoClaimEpoch = 30 * 86400;\\n    mapping(address => uint256) private _magnaBalance;\\n    mapping(address => uint256) private _totalDeposit;\\n    mapping(address => uint256) private _depositHistoryLength;\\n    mapping(address => mapping(uint256 => DepositHistory)) private _depositHistory;\\n    mapping(address => mapping(uint256 => uint256)) private _userLevelVolume;\\n\\n    event Buy(address from, uint256 usdtSent, uint256 magnaReceived);\\n    event Sell(address from, uint256 magnaSent, uint256 usdtReceived);\\n    event Reward(address from_, address to_, uint256 amount_);\\n    event AutoBuy(address from, uint256 usdtSent, uint256 magnaReceived);\\n    event SetTreasury(address treasury);\\n    event SetWithdrawProfitFee(uint256 fee_);\\n    event SetWithdrawProfitDistribution(uint256[5] distribution_);\\n    event SetLiquidityFee(uint256 fee);\\n    event SetSuccessReward(uint256 reward_);\\n    event SetSuccessRewardRequirement(uint256 referralsMin_, uint256 investVolumeMin_);\\n    event SetAutoClaimEpoch(uint256 autoClaimEpoch);\\n\\n    /**\\n     * @notice Transfers ownership to the contract creator and declares all the contract variables.\\n     * @param magnaToken_ The address of MagnaToken contract.\\n     * @param magnaLiquidity_ The address of MagnaLiquidity contract.\\n     * @param mlmSystem_ The address of MLMSystem contract.\\n     * @param usdt_ The address of USDT contract.\\n     */\\n    constructor(address magnaToken_, address magnaLiquidity_, address mlmSystem_, address usdt_) Ownable(msg.sender) {\\n        MagnaLiquidity = IMagnaLiquidity(magnaLiquidity_);\\n        MLMSystem = IMlmSystem(mlmSystem_);\\n        MAGNA = IERC20(magnaToken_);\\n        USDT = IERC20(usdt_);\\n    }\\n\\n    /**\\n     * @notice Allows subscribers to buy MAGNA tokens through a trading contract.\\n     * Each buy operation vitrually performs purchases of 100$ until the exchange amount is settled.\\n     * A 2.5% operation fee is applied: 2% fee goes into the Liquidity Pool, which supports token \\n     * liquidity, and 0.5% fee is deposited into the treasury wallet for operational purposes.\\n     * @param amount_ The amount of USDT the user is willing to invest into MAGNA tokens.\\n     */\\n    function buy(uint256 amount_) external nonReentrant {\\n        if (USDT.allowance(msg.sender, address(this)) < amount_) revert MagnaTrader__InvalidAllowance();\\n        if (!MLMSystem.subscriptionIsValid(msg.sender)) revert MagnaTrader__NotSubscribed();\\n        uint256 maxDeposit = MLMSystem.userMaxDepositAmount(msg.sender);\\n        if (maxDeposit > 0)\\n            if (_totalDeposit[msg.sender] + amount_ > maxDeposit) revert MagnaTrader__MaxDepositExceeded();\\n        _totalDeposit[msg.sender] += amount_;\\n\\n        uint256 depositHistoryLength_ = _depositHistoryLength[msg.sender];\\n        _depositHistory[msg.sender][depositHistoryLength_] = DepositHistory({amount: amount_, timestamp: block.timestamp});\\n        _depositHistoryLength[msg.sender] = depositHistoryLength_ + 1;\\n\\n        bool success = USDT.transferFrom(msg.sender, address(MagnaLiquidity), amount_);\\n        if (!success) revert MagnaTrader__TransferFailed();\\n\\n        uint256 receivedMagna_ = MagnaLiquidity.deposit(msg.sender);\\n        emit Buy(msg.sender, MagnaLiquidity.depositNetAmount(amount_), receivedMagna_);\\n        _magnaBalance[msg.sender] += receivedMagna_;\\n    }\\n\\n    /**\\n     * @notice Allows subscribers and expired subscribers to sell their MAGNA tokens through a\\n     * trading contract. There are no restrictions on withdrawing funds or profits. If there are \\n     * profits, user receives 65% and 35% is distributed to direfent platform participants.\\n     * @param amount_ The amount of MAGNA the user is willing to sell to receive USDT in exchange.\\n     */\\n    function sell(uint256 amount_) external nonReentrant {\\n        (uint256 initialDeposit_, uint256 userProfit_) = _sell(msg.sender, amount_);\\n        emit Sell(msg.sender, amount_, initialDeposit_ + userProfit_);\\n        bool success = USDT.transfer(msg.sender, USDT.balanceOf(address(this)));\\n        if (!success) revert MagnaTrader__TransferFailed();\\n    }\\n\\n    /**\\n     * @notice Exchanges MAGNA and USDT from Trader to Liquidity.\\n     * This inner function is called in `sell` and `autoWithdraw`.\\n     */\\n    function _sell(address from_, uint256 amount_) internal returns (uint256, uint256) {\\n        if (amount_ > _magnaBalance[from_]) revert MagnaTrader__InvalidMagnaAmount();\\n        _magnaBalance[from_] -= (amount_);\\n\\n        bool successMagna = MAGNA.transfer(address(MagnaLiquidity), amount_);\\n        if (!successMagna) revert MagnaTrader__TransferFailed();\\n\\n        (uint256 outUsdt_, uint256 initialDeposit_) = MagnaLiquidity.withdraw(from_, amount_);\\n\\n        uint256 userProfit_ = 0;\\n        if (outUsdt_ > initialDeposit_) {\\n            userProfit_ = (outUsdt_ - initialDeposit_) * (FEE_DENOMINATOR - _withdrawProfitFee) / FEE_DENOMINATOR;\\n            _distributeRewards(from_, outUsdt_, initialDeposit_);\\n        }\\n        return (initialDeposit_, userProfit_);\\n    }\\n\\n    /**\\n     * @notice Distributes the `_withdrawProfitFee` of the user profits between recruitors, magna liquidity and treasury.\\n     * Recruitors rewards percentages by level follow `_withdrawProfitDistribution` and if the affiliates qualify for \\n     * success reward, `_successReward` is added. An additional `_liquidityFee` is sent to the liquidity pool.\\n     * The remaining amount from the `_withdrawProfitFee` goes to the treasury wallet.\\n     */\\n    function _distributeRewards(address from_, uint256 outUsdt_, uint256 initialDeposit_) internal {\\n        address[5] memory recruitors_ = MLMSystem.getRecruitors(from_);\\n        uint256 userRewards = (outUsdt_ - initialDeposit_) * (FEE_DENOMINATOR - _withdrawProfitFee) / FEE_DENOMINATOR;\\n        uint256 distributedRewards = outUsdt_ - initialDeposit_ - userRewards;\\n        uint256 remainingRewards = distributedRewards;\\n        uint256[5] memory reward;\\n\\n        // Calculates rewards.\\n        for (uint256 i = 0; i < 5; i++) {\\n            if (recruitors_[i] == address(0)) {\\n                reward[i] = 0;\\n            } else {\\n                reward[i] = userRewards * _withdrawProfitDistribution[i] / FEE_DENOMINATOR;\\n                if (successReward(recruitors_[i])) reward[i] += userRewards * _successReward / FEE_DENOMINATOR;\\n                _userLevelVolume[recruitors_[i]][i] += reward[i];\\n                remainingRewards -= reward[i];\\n            }\\n        }\\n        uint256 liquidityReward = userRewards * _liquidityFee / FEE_DENOMINATOR;\\n        remainingRewards -= liquidityReward;\\n\\n        // Transfers USDT to `recruitors`.\\n        for (uint256 i = 0; i < 5; i++)\\n            if (reward[i] > 0) {\\n                bool successRecruitor = USDT.transfer(recruitors_[i], reward[i]);\\n                if (!successRecruitor) revert MagnaTrader__TransferFailed();\\n                emit Reward(from_, recruitors_[i], reward[i]);\\n            }\\n\\n        // Transfers USDT to `MagnaLiquidity` through `depositForFund`.\\n        if (liquidityReward > 0) {\\n            USDT.approve(address(MagnaLiquidity), liquidityReward);\\n            MagnaLiquidity.depositForFund(liquidityReward);\\n        }\\n        \\n        // Transfers USDT to `treasury`.\\n        bool successTreasury = USDT.transfer(_treasury, remainingRewards);\\n        if (!successTreasury) revert MagnaTrader__TransferFailed();\\n    }\\n\\n    /**\\n     * @notice Owner functions\\n     *\\n     * @notice This function compounds the funds of the users after 30 days from last claim.\\n     * note If the subscription is expired returns all the funds to the user.\\n     * @param users The array of user addresses for whom autowithdraw should be executed.\\n     */\\n    function autoWithdraw(address[] calldata users) external nonReentrant onlyOwner {\\n        for (uint256 i = 0; i < users.length; i++)\\n            if (_magnaBalance[users[i]] > 0 && MagnaLiquidity.userInfo(users[i]).lastClaim + _autoClaimEpoch <= block.timestamp) {\\n                UserInfo memory userInfo = MagnaLiquidity.userInfo(users[i]);\\n                uint256 lastDeposit = userInfo.deposit;\\n                (uint256 initialDeposit_, uint256 userProfit_) = _sell(users[i], _magnaBalance[users[i]]);\\n                uint256 amount = initialDeposit_ + userProfit_;\\n                if (MLMSystem.subscriptionIsValid(users[i])) {\\n                    bool success = USDT.transfer(address(MagnaLiquidity), amount);\\n                    if (!success) revert MagnaTrader__TransferFailed();\\n                    uint256 receivedMagna_ = MagnaLiquidity.redeposit(users[i], lastDeposit);\\n                    emit AutoBuy(users[i], MagnaLiquidity.redepositNetAmount(amount, lastDeposit), receivedMagna_);\\n                    _magnaBalance[users[i]] += receivedMagna_;\\n                } else {\\n                    bool success = USDT.transfer(users[i], amount);\\n                    if (!success) revert MagnaTrader__TransferFailed();\\n                }\\n            }\\n    }\\n\\n    /**\\n     * @notice Sets new requirements for the success rewards.\\n     * @param referralsMin_ The minimum amount of referrals.\\n     * @param investVolumeMin_ The minimum amount of invested volume.\\n     */\\n    function setSuccessRewardRequirement(uint256 referralsMin_, uint256 investVolumeMin_) external onlyOwner {\\n        _successRewardDirectReferralsMin = referralsMin_;\\n        _successRewardInvestVolumeMin = investVolumeMin_;\\n        emit SetSuccessRewardRequirement(_successRewardDirectReferralsMin, _successRewardInvestVolumeMin);\\n    }\\n\\n    /**\\n     * @notice Sets a new liquidity fee.\\n     * @param fee_ The new fee.\\n     */\\n    function setLiquidityFee(uint256 fee_) external onlyOwner {\\n        _liquidityFee = fee_;\\n        emit SetLiquidityFee(fee_);\\n    }\\n\\n    /**\\n     * @notice Sets a new treasury address.\\n     * @param treasury_ The new treasury address.\\n     */\\n    function setTreasury(address treasury_) external onlyOwner {\\n        _treasury = treasury_;\\n        emit SetTreasury(treasury_);\\n    }\\n\\n    /**\\n     * @notice Sets a new auto claim epoch.\\n     * @param autoClaimEpoch_ The new auto claim epoch.\\n     */\\n    function setAutoClaimEpoch(uint256 autoClaimEpoch_) external onlyOwner {\\n        _autoClaimEpoch = autoClaimEpoch_;\\n        emit SetAutoClaimEpoch(autoClaimEpoch_);\\n    }\\n\\n    /**\\n     * @notice Sets a new withdraw profit fee.\\n     * @param fee_ The new withdraw profit fee.\\n     */\\n    function setWithdrawProfitFee(uint256 fee_) external onlyOwner {\\n        _withdrawProfitFee = fee_;\\n        emit SetWithdrawProfitFee(fee_);\\n    }\\n\\n    /**\\n     * @notice Sets a new withdraw profit distribution.\\n     * @param distribution_ The fee for each of the five levels.\\n     */\\n    function setWithdrawProfitDistribution(uint256[5] memory distribution_) external onlyOwner {\\n        _withdrawProfitDistribution = distribution_;\\n        emit SetWithdrawProfitDistribution(distribution_);\\n    }\\n\\n    /**\\n     * @notice Sets a new auto success reward.\\n     * @param reward_ The new success reward.\\n     */\\n    function setSuccessReward(uint256 reward_) external onlyOwner {\\n        _successReward = reward_;\\n        emit SetSuccessReward(_successReward);\\n    }\\n\\n    /**\\n     * @notice View / Pure functions\\n     */\\n    function getDepositHistory(address owner_, uint256 len_) external view returns (DepositHistory[] memory) {\\n        uint256 length = _depositHistoryLength[owner_];\\n        if (len_ > length) len_ = length;\\n        DepositHistory[] memory history = new DepositHistory[](len_);\\n        for (uint256 i = 0; i < len_; i++) \\n            history[i] = _depositHistory[owner_][length - (i + 1)];\\n        return history;\\n    }\\n\\n    function successReward(address user_) public view returns (bool) {\\n        address[] memory users = MLMSystem.usersByReferral(user_);\\n        uint256 totalDeposits;\\n        bool success = false;\\n        for (uint256 i = 0; i < users.length; i++) \\n            totalDeposits += MagnaLiquidity.userDeposited(users[i]);\\n        if (users.length >= _successRewardDirectReferralsMin) \\n            if (totalDeposits >= _successRewardInvestVolumeMin) success = true;\\n        return success;\\n    }\\n\\n    function liquidityFee() public view returns (uint256) {\\n        return _liquidityFee;\\n    }\\n\\n    function treasury() public view returns (address) {\\n        return _treasury;\\n    }\\n\\n    function withdrawProfitFee() external view returns (uint256) {\\n        return _withdrawProfitFee;\\n    }\\n\\n    function withdrawProfitDistribution() external view returns (uint256[5] memory) {\\n        return _withdrawProfitDistribution;\\n    }\\n\\n    function successReward() external view returns (uint256) {\\n        return _successReward;\\n    }\\n\\n    function successRewardRequirement() external view returns (uint256, uint256) {\\n        return (_successRewardDirectReferralsMin, _successRewardInvestVolumeMin);\\n    }\\n\\n    function autoClaimEpoch() external view returns (uint256) {\\n        return _autoClaimEpoch;\\n    }\\n\\n    function magnaBalance(address owner_) external view returns (uint256) {\\n        return _magnaBalance[owner_];\\n    }\\n\\n    function depositHistoryLength(address owner_) external view returns (uint256) {\\n        return _depositHistoryLength[owner_];\\n    }\\n\\n    function userLevelVolume(address user_, uint256 level_) public view returns (uint256) {\\n        return _userLevelVolume[user_][level_];\\n    }\\n\\n    function totalDeposit(address user_) public view returns (uint256) {\\n        return _totalDeposit[user_];\\n    }\\n\\n    function feeDenominator() external pure returns (uint256) {\\n        return FEE_DENOMINATOR;\\n    }\\n}\\n\\n/**\\n * @notice MagnaTrader custom errors.\\n */\\nerror MagnaTrader__InvalidAllowance();\\nerror MagnaTrader__NotSubscribed();\\nerror MagnaTrader__InvalidMagnaAmount();\\nerror MagnaTrader__CanNotWithdrawNow();\\nerror MagnaTrader__TransferFailed();\\nerror MagnaTrader__MaxDepositExceeded();\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"remappings\": [\r\n      \":ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \":forge-std/=lib/forge-std/src/\",\r\n      \":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \":openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"magnaToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"magnaLiquidity_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mlmSystem_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdt_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"MagnaTrader__InvalidAllowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MagnaTrader__InvalidMagnaAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MagnaTrader__MaxDepositExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MagnaTrader__NotSubscribed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MagnaTrader__TransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdtSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"magnaReceived\",\"type\":\"uint256\"}],\"name\":\"AutoBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdtSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"magnaReceived\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"Reward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"magnaSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdtReceived\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"autoClaimEpoch\",\"type\":\"uint256\"}],\"name\":\"SetAutoClaimEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"SetLiquidityFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_\",\"type\":\"uint256\"}],\"name\":\"SetSuccessReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralsMin_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investVolumeMin_\",\"type\":\"uint256\"}],\"name\":\"SetSuccessRewardRequirement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"SetTreasury\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[5]\",\"name\":\"distribution_\",\"type\":\"uint256[5]\"}],\"name\":\"SetWithdrawProfitDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"name\":\"SetWithdrawProfitFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAGNA\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MLMSystem\",\"outputs\":[{\"internalType\":\"contract IMlmSystem\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MagnaLiquidity\",\"outputs\":[{\"internalType\":\"contract IMagnaLiquidity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoClaimEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"}],\"name\":\"autoWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"depositHistoryLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"len_\",\"type\":\"uint256\"}],\"name\":\"getDepositHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct MagnaTrader.DepositHistory[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"magnaBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"autoClaimEpoch_\",\"type\":\"uint256\"}],\"name\":\"setAutoClaimEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward_\",\"type\":\"uint256\"}],\"name\":\"setSuccessReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"referralsMin_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investVolumeMin_\",\"type\":\"uint256\"}],\"name\":\"setSuccessRewardRequirement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"distribution_\",\"type\":\"uint256[5]\"}],\"name\":\"setWithdrawProfitDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"}],\"name\":\"setWithdrawProfitFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"successReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"successReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"successRewardRequirement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"totalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level_\",\"type\":\"uint256\"}],\"name\":\"userLevelVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawProfitDistribution\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawProfitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MagnaTrader", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000493cc727a96ada91f464bf2d3029ad67591171bc000000000000000000000000fb85578514bb892bd107a5e7e18befe5e72143de000000000000000000000000d2ac52057c96bccba909efbd78665624502cd2e200000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}