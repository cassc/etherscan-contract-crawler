{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-01-12\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity 0.7.0;\r\n\r\n/**\r\n * @dev The contract has an owner address, and provides basic authorization control whitch\r\n * simplifies the implementation of user permissions. This contract is based on the source code at:\r\n * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\r\n */\r\ncontract Ownable\r\n{\r\n    \r\n    mapping (address => bool) public isAuth;\r\n    address tokenLinkAddress;\r\n    \r\n  /**\r\n   * @dev Error constants.\r\n   */\r\n  string public constant NOT_CURRENT_OWNER = \"018001\";\r\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\r\n\r\n  /**\r\n   * @dev Current owner address.\r\n   */\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev An event which is triggered when the owner is changed.\r\n   * @param previousOwner The address of the previous owner.\r\n   * @param newOwner The address of the new owner.\r\n   */\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The constructor sets the original `owner` of the contract to the sender account.\r\n   */\r\n  constructor()\r\n  {\r\n    owner = msg.sender;\r\n    isAuth[owner] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner()\r\n  {\r\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAuthorized()\r\n  {\r\n    require(isAuth[msg.sender] || msg.sender == owner, \"Unauth\");\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/tokens/erc721-metadata.sol\r\n\r\n\r\n/**\r\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721Metadata\r\n{\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\r\n   * @return _name Representing name.\r\n   */\r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  /**\r\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\r\n   * @return _symbol Representing symbol.\r\n   */\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  /**\r\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\r\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\r\n   * that conforms to the \"ERC721 Metadata JSON Schema\".\r\n   * @return URI of _tokenId.\r\n   */\r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string memory);\r\n\r\n}\r\n\r\n// File: contracts/utils/address-utils.sol\r\n\r\n\r\n\r\n/**\r\n * @notice Based on:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n * Requires EIP-1052.\r\n * @dev Utility library of inline functions on addresses.\r\n */\r\nlibrary AddressUtils\r\n{\r\n\r\n  /**\r\n   * @dev Returns whether the target address is a contract.\r\n   * @param _addr Address to check.\r\n   * @return addressCheck True if _addr is a contract, false if not.\r\n   */\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    // This method relies in extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n    // for accounts without code, i.e. `keccak256('')`\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/utils/erc165.sol\r\n\r\n\r\n\r\n/**\r\n * @dev A standard for detecting smart contract interfaces. \r\n * See: https://eips.ethereum.org/EIPS/eip-165.\r\n */\r\ninterface ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Checks if the smart contract includes a specific interface.\r\n   * This function uses less than 30,000 gas.\r\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\r\n   * @return True if _interfaceID is supported, false otherwise.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n    \r\n}\r\n\r\n// File: contracts/utils/supports-interface.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of standard for detect smart contract interfaces.\r\n */\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n\r\n  /**\r\n   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check which interfaces are suported by this contract.\r\n   * @param _interfaceID Id of the interface.\r\n   * @return True if _interfaceID is supported, false otherwise.\r\n   */\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/tokens/erc721-token-receiver.sol\r\n\r\n\r\n\r\n/**\r\n * @dev ERC-721 interface for accepting safe transfers.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721TokenReceiver\r\n{\r\n\r\n  /**\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   * @return Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n   */\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n\r\n}\r\n\r\n// File: contracts/tokens/erc721.sol\r\n\r\n\r\n/**\r\n * @dev ERC-721 non-fungible token standard.\r\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\r\n */\r\ninterface ERC721\r\n{\r\n\r\n  /**\r\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n   * transfer, the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n   * address indicates there is no approved address. When a Transfer event emits, this also\r\n   * indicates that the approved address for that NFT (if any) is reset to none.\r\n   */\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  /**\r\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n   * all NFTs of the owner.\r\n   */\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  /**\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n   * `onERC721Received` on `_to` and throws if the return value is not\r\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n   * be changed to payable.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\"\r\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n   * be changed to payable.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they may be permanently lost.\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT.  This function can be changed to payable.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @param _approved The new approved NFT controller.\r\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\r\n   * @param _tokenId The NFT to approve.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @notice The contract MUST allow multiple operators per owner.\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @notice Count all NFTs assigned to an owner.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @notice Find the owner of an NFT.\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\r\n   * considered invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @dev Get the approved address for a single NFT.\r\n   * @param _tokenId The NFT to find the approved address for.\r\n   * @return Address that _tokenId is approved for.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  /**\r\n   * @notice Query if an address is an authorized operator for another address.\r\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/tokens/nf-token.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of ERC-721 non-fungible token standard.\r\n */\r\ncontract NFToken is\r\n  ERC721,\r\n  SupportsInterface\r\n{\r\n  using AddressUtils for address;\r\n\r\n  /**\r\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\r\n   * Based on 0xcert framework error codes.\r\n   */\r\n  string constant ZERO_ADDRESS = \"003001\";\r\n  string constant NOT_VALID_NFT = \"003002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\r\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\r\n  string constant NFT_ALREADY_EXISTS = \"003006\";\r\n  string constant NOT_OWNER = \"003007\";\r\n  string constant IS_OWNER = \"003008\";\r\n\r\n  /**\r\n   * @dev Magic value of a smart contract that can receive NFT.\r\n   * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n   */\r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  /**\r\n   * @dev A mapping from NFT ID to the address that owns it.\r\n   */\r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to approved address.\r\n   */\r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n   /**\r\n   * @dev Mapping from owner address to count of their tokens.\r\n   */\r\n  mapping (address => uint256) private ownerToNFTokenCount;\r\n\r\n  /**\r\n   * @dev Mapping from owner address to mapping of operator addresses.\r\n   */\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n   * @param _tokenId ID of the NFT to transfer.\r\n   */\r\n  modifier canTransfer(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_APPROVED_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Guarantees that _tokenId is a valid Token.\r\n   * @param _tokenId ID of the NFT to validate.\r\n   */\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n  }\r\n\r\n  /**\r\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n   * `onERC721Received` on `_to` and throws if the return value is not\r\n   * `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n   * be changed to payable.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  /**\r\n   * @notice This works identically to the other function with an extra data parameter, except this\r\n   * function just sets data to \"\".\r\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\r\n   * be changed to payable.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  /**\r\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n   * they may be permanently lost.\r\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n   * the current NFT owner, or an authorized operator of the current owner.\r\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\r\n   * @param _approved Address to be approved for the given NFT ID.\r\n   * @param _tokenId ID of the token to be approved.\r\n   */\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canOperate(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner, IS_OWNER);\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice This works even if sender doesn't own any tokens at the time.\r\n   * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n   * @param _operator Address to add to the set of authorized operators.\r\n   * @param _approved True if the operators is approved, false to revoke approval.\r\n   */\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n    override\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n   * considered invalid, and this function throws for queries about the zero address.\r\n   * @param _owner Address for whom to query the balance.\r\n   * @return Balance of _owner.\r\n   */\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return _getOwnerNFTCount(_owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\r\n   * considered invalid, and queries about them do throw.\r\n   * @param _tokenId The identifier for an NFT.\r\n   * @return _owner Address of _tokenId owner.\r\n   */\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n\r\n  /**\r\n   * @notice Throws if `_tokenId` is not a valid NFT.\r\n   * @dev Get the approved address for a single NFT.\r\n   * @param _tokenId ID of the NFT to query the approval of.\r\n   * @return Address that _tokenId is approved for.\r\n   */\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (address)\r\n  {\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n   * @param _owner The address that owns the NFTs.\r\n   * @param _operator The address that acts on behalf of the owner.\r\n   * @return True if approved for all, false otherwise.\r\n   */\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  /**\r\n   * @notice Does NO checks.\r\n   * @dev Actually performs the transfer.\r\n   * @param _to Address of a new owner.\r\n   * @param _tokenId The NFT that is being transferred.\r\n   */\r\n  function _transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    address from = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * mint function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @dev Mints a new NFT.\r\n   * @param _to The address that will own the minted NFT.\r\n   * @param _tokenId of the NFT to be minted by the msg.sender.\r\n   */\r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice This is an internal function which should be called from user-implemented external burn\r\n   * function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n   * NFT.\r\n   * @dev Burns a NFT.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n    _removeNFToken(tokenOwner, _tokenId);\r\n    emit Transfer(tokenOwner, address(0), _tokenId);\r\n  }\r\n\r\n  /**\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @dev Removes a NFT from owner.\r\n   * @param _from Address from which we want to remove the NFT.\r\n   * @param _tokenId Which NFT we want to remove.\r\n   */\r\n  function _removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    ownerToNFTokenCount[_from] -= 1;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n   * @dev Assigns a new NFT to owner.\r\n   * @param _to Address to which we want to add the NFT.\r\n   * @param _tokenId Which NFT we want to add.\r\n   */\r\n  function _addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] += 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\r\n   * extension to remove double storage (gas optimization) of owner NFT count.\r\n   * @param _owner Address for whom to query the count.\r\n   * @return Number of _owner NFTs.\r\n   */\r\n  function _getOwnerNFTCount(\r\n    address _owner\r\n  )\r\n    internal\r\n    virtual\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Actually perform the safeTransferFrom.\r\n   * @param _from The current owner of the NFT.\r\n   * @param _to The new owner.\r\n   * @param _tokenId The NFT to transfer.\r\n   * @param _data Additional data with no specified format, sent in call to `_to`.\r\n   */\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    private\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n\r\n    if (_to.isContract())\r\n    {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Clears the current approval of a given NFT ID.\r\n   * @param _tokenId ID of the NFT to be transferred.\r\n   */\r\n  function _clearApproval(\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    delete idToApproval[_tokenId];\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/tokens/nf-token-metadata.sol\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\r\n */\r\ncontract NFTokenMetadata is\r\n  NFToken,\r\n  ERC721Metadata\r\n{\r\n\r\n  /**\r\n   * @dev A descriptive name for a collection of NFTs.\r\n   */\r\n  string internal nftName;\r\n\r\n  /**\r\n   * @dev An abbreviated name for NFTokens.\r\n   */\r\n  string internal nftSymbol;\r\n\r\n  /**\r\n   * @dev Mapping from NFT ID to metadata uri.\r\n   */\r\n  mapping (uint256 => string) internal idToUri;\r\n\r\n  /**\r\n   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\r\n   * @dev Contract constructor.\r\n   */\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n  }\r\n\r\n  /**\r\n   * @dev Returns a descriptive name for a collection of NFTokens.\r\n   * @return _name Representing name.\r\n   */\r\n  function name()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _name)\r\n  {\r\n    _name = nftName;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an abbreviated name for NFTokens.\r\n   * @return _symbol Representing symbol.\r\n   */\r\n  function symbol()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = nftSymbol;\r\n  }\r\n\r\n  /**\r\n   * @dev A distinct URI (RFC 3986) for a given NFT.\r\n   * @param _tokenId Id for which we want uri.\r\n   * @return URI of _tokenId.\r\n   */\r\n  function tokenURI(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    virtual\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (string memory)\r\n  {\r\n    return idToUri[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * burn function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\r\n   * NFT.\r\n   * @dev Burns a NFT.\r\n   * @param _tokenId ID of the NFT to be burned.\r\n   */\r\n  function _burn(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    override\r\n    virtual\r\n  {\r\n    super._burn(_tokenId);\r\n\r\n    delete idToUri[_tokenId];\r\n  }\r\n\r\n  /**\r\n   * @notice This is an internal function which should be called from user-implemented external\r\n   * function. Its purpose is to show and properly initialize data structures when using this\r\n   * implementation.\r\n   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\r\n   * @param _tokenId Id for which we want URI.\r\n   * @param _uri String representing RFC 3986 URI.\r\n   */\r\n  function _setTokenUri(\r\n    uint256 _tokenId,\r\n    string memory _uri\r\n  )\r\n    internal\r\n    validNFToken(_tokenId)\r\n  {\r\n    idToUri[_tokenId] = _uri;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a uint256 to its ASCII string representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n \r\ncontract ScionSphynxCouncil is NFTokenMetadata, Ownable {\r\n \r\n  using Strings for uint256;  \r\n\r\n  uint256 _lastTokenId = 0;\r\n  uint256 price = 500000000000000000;\r\n  bool freeMint;\r\n  bool public mintEnabled;\r\n  mapping(address => bool) is_auth;\r\n  string public baseuri;\r\n  mapping(address => uint256) minted;\r\n\r\n  address fee1 = 0xe2339E4483aBa0877d760872304ddECd5e275C6C;\r\n  address fee2 = 0x05fe62e5657F6DAB00155976126BD09fC66bC699;\r\n  address fee3 = 0x779b034747f8ba010b251aDab5424Bd33FC9f652;\r\n  address fee4 = 0xCbeb3C6aEC7040e4949F22234573bd06B31DE83b;\r\n\r\n  modifier onlyAuth() {\r\n      require(msg.sender==owner || is_auth[msg.sender], \"Unauthorized\");\r\n      _;\r\n  }\r\n\r\nbool locked;\r\n\r\nmodifier safe() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n  }\r\n\r\n  constructor() {\r\n    nftName = \"Scion Sphynx Council\";\r\n    nftSymbol = \"SSC\";\r\n    owner = msg.sender;\r\n    is_auth[owner] = true;\r\n  }\r\n\r\n  function takeBalance (bool taxed) public onlyAuth {\r\n      if(taxed) {\r\n          uint256 balance = address(this).balance;\r\n          uint256 tax1 = (balance/10)*4;\r\n          uint256 tax2 = tax1;\r\n          uint256 tax3 = balance/10;\r\n          uint256 tax4 = tax3;\r\n          if ((tax1+tax2+tax3+tax4)> balance) {\r\n              tax1 -= ((tax1+tax2+tax3+tax4) - balance);\r\n          }\r\n          (bool sent1,) =fee1.call{value: (tax1)}(\"\");\r\n          (bool sent2,) =fee2.call{value: (tax2)}(\"\");\r\n          (bool sent3,) =fee3.call{value: (tax3)}(\"\");\r\n          (bool sent4,) =fee4.call{value: (tax4)}(\"\");\r\n          require(sent1);\r\n          require(sent2);\r\n          require(sent3);\r\n          require(sent4);\r\n      } else {\r\n        (bool sent,) =owner.call{value: (address(this).balance)}(\"\");\r\n        require(sent);\r\n      }\r\n  }\r\n\r\n  function setBaseuri(string calldata newUri) public onlyAuth {\r\n      baseuri = newUri;\r\n  }\r\n\r\n  function rawTakeBalance() public onlyAuth {\r\n        (bool sent,) =msg.sender.call{value: (address(this).balance)}(\"\");\r\n        require(sent);\r\n  }\r\n\r\n   function tokenURI(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (string memory)\r\n  {\r\n    return string(abi.encodePacked(baseuri, _tokenId.toString()));\r\n  }\r\n\r\n  function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n  function decimals() external pure returns (uint8) {\r\n        return 0;\r\n    }\r\n\r\n  function totalSupply() external view returns (uint256) {\r\n        return _lastTokenId;\r\n    }\r\n  \r\n  function setAuth(bool booly, address addy) public onlyAuth {\r\n      is_auth[addy] = booly;\r\n  }\r\n \r\n  function setMintingFree(bool booly) public onlyAuth {\r\n      freeMint = booly;\r\n  }\r\n\r\n  function setPrice(uint256 setprice) public onlyAuth {\r\n      price = setprice;\r\n  }\r\n\r\n  function enableMint(bool booly) public onlyAuth {\r\n      mintEnabled = booly;\r\n  }\r\n\r\n  \r\nfunction mintNFT(address _to, uint256 qty) payable public safe {\r\n    require(qty < 21, \"\");\r\n    require(mintEnabled, \"Minting enabled\");\r\n    if(!freeMint) {\r\n        require(msg.value >= price * qty, \"Wrong paid\");\r\n    }\r\n    require(_lastTokenId + qty <= 6805, \"Sold out\");\r\n    for(uint i=0; i< qty; i++) {\r\n        uint256 _tokenId = _lastTokenId;\r\n        super._mint(_to, _tokenId); \r\n        _lastTokenId = _tokenId + 1;\r\n    }\r\n  }\r\n \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANNOT_TRANSFER_TO_ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NOT_CURRENT_OWNER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseuri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"enableMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAuth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"name\":\"mintNFT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rawTakeBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setAuth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newUri\",\"type\":\"string\"}],\"name\":\"setBaseuri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"setMintingFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"setprice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"taxed\",\"type\":\"bool\"}],\"name\":\"takeBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ScionSphynxCouncil", "CompilerVersion": "v0.7.0+commit.9e61f92b", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d047720519f435a737927454b50012f7f806a0943ce50349cd7d7187d59c32a2"}