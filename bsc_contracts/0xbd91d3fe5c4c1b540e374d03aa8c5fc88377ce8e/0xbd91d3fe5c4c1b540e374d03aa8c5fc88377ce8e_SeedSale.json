{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the value of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from the caller\\u0027s account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\r\\n     * caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `value` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * The initial owner is set to the address provided by the deployer. This can\\r\\n * later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev The caller account is not authorized to perform an operation.\\r\\n     */\\r\\n    error OwnableUnauthorizedAccount(address account);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\r\\n     */\\r\\n    error OwnableInvalidOwner(address owner);\\r\\n\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\r\\n     */\\r\\n    constructor(address initialOwner) {\\r\\n        if (initialOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(initialOwner);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        _checkOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the owner.\\r\\n     */\\r\\n    function _checkOwner() internal view virtual {\\r\\n        if (owner() != _msgSender()) {\\r\\n            revert OwnableUnauthorizedAccount(_msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby disabling any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        if (newOwner == address(0)) {\\r\\n            revert OwnableInvalidOwner(address(0));\\r\\n        }\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"},\"Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the\\r\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\r\\n * the functions of your contract. Note that they will not be pausable by\\r\\n * simply including this module, only once the modifiers are put in place.\\r\\n */\\r\\nabstract contract Pausable is Context {\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n\\r\\n    bool private _paused;\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract in unpaused state.\\r\\n     */\\r\\n    constructor() {\\r\\n        _paused = false;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        _requireNotPaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        _requirePaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view virtual returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is paused.\\r\\n     */\\r\\n    function _requireNotPaused() internal view virtual {\\r\\n        require(!paused(), \\\"Pausable: paused\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the contract is not paused.\\r\\n     */\\r\\n    function _requirePaused() internal view virtual {\\r\\n        require(paused(), \\\"Pausable: not paused\\\");\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(_msgSender());\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(_msgSender());\\r\\n    }\\r\\n}\\r\\n\\r\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n    }\\r\\n\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\r\\n     * `nonReentrant` function in the call stack.\\r\\n     */\\r\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\r\\n        return _status == _ENTERED;\\r\\n    }\\r\\n}\\r\\n\"},\"SeedSale.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.19;\\r\\n\\r\\n\\r\\nimport \\\"./ReentrancyGuard.sol\\\";\\r\\nimport \\\"./Pausable.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n\\r\\ncontract SeedSale is Ownable, Pausable, ReentrancyGuard {\\r\\n\\r\\n    IERC20 public usdtToken;\\r\\n    uint256 public tokenPrice;\\r\\n    uint256 public maxTokens;\\r\\n    uint256 public totalTokensSold;\\r\\n    uint256 public maxTokensPerAddress;\\r\\n    IERC20 public mceToken;\\r\\n    mapping(address =\\u003e uint256) public tokensPurchased;\\r\\n    bool public saleEnded;\\r\\n    bool public enableClaimTokens;\\r\\n    address[] public buyers;\\r\\n    uint256 public saleEndDate;\\r\\n    uint256 public referralPercentage = 5;\\r\\n    uint256 public referralPercentageLine1 = 8;\\r\\n    uint256 public referralPercentageLine2 = 2;\\r\\n    uint256 public constant VESTING_CLIFF_MONTHS = 3;\\r\\n    uint256 public constant PERCENTAGE_WITHDRAWABLE_AFTER_CLIFF = 8;\\r\\n    uint256 public constant PERCENTAGE_WITHDRAWABLE_AFTER_LISTING = 4;\\r\\n    bool public tokensListed = false;\\r\\n\\r\\n\\r\\n    mapping(address =\\u003e uint256) public referralRewards;\\r\\n    mapping(address =\\u003e address) public referrers;\\r\\n    mapping(address =\\u003e address) public referrersLine2;\\r\\n    mapping(address =\\u003e uint256) public lastClaimTime;\\r\\n    mapping(address =\\u003e uint256) public tokensClaimed;\\r\\n\\r\\n\\r\\n    event TokensPurchased(address indexed buyer, uint256 amount);\\r\\n    event SaleEnded();\\r\\n    event EnableClaimTokens();\\r\\n    event TokensDistributed(address indexed buyer, uint256 amount);\\r\\n    event FundsWithdrawn(address indexed owner, uint256 amount);\\r\\n    event ReferralRewarded(address indexed referrer, uint256 reward);\\r\\n    event ReferralWithdrawn(address indexed referrer, uint256 amount);\\r\\n    event TokensLeftToPurchase(uint256 amount);\\r\\n    event MceTokenAddressSet(address indexed mceToken);\\r\\n    event SalePaused();\\r\\n    event SaleResumed();\\r\\n    event TokensListed();\\r\\n\\r\\n\\r\\n    constructor(address _usdtToken) Ownable(msg.sender)  {\\r\\n        usdtToken = IERC20(_usdtToken);\\r\\n        tokenPrice = 40000000000000000;\\r\\n        maxTokens = 5000000000000000000000000;\\r\\n        maxTokensPerAddress = 600000000000000000000000;\\r\\n        saleEnded = false;\\r\\n        enableClaimTokens = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Purchase the specified amount of tokens.\\r\\n     * @dev Checks if the sale is still on, calculates the necessary USDT amount, and transfers USDT to the contract.\\r\\n     * If a referrer is provided, assigns the referrer and calculates referral rewards.\\r\\n     * @param _tokenAmount The amount of tokens the buyer wants to purchase.\\r\\n     * @param referrer The address of the referrer if any.\\r\\n     */\\r\\n    function buyTokens(uint256 _tokenAmount, address referrer) public whenNotPaused {\\r\\n\\r\\n        require(!saleEnded, \\\"Sale ended\\\");\\r\\n\\r\\n        uint256 usdtAmount = (_tokenAmount * tokenPrice / 1e18);\\r\\n        require(usdtAmount \\u003e 0, \\\"No funds required\\\");\\r\\n        require(usdtToken.balanceOf(msg.sender) \\u003e= usdtAmount, \\\"Insufficient USDT balance for attempted purchase of USDT\\\");\\r\\n        require(tokensPurchased[msg.sender] + _tokenAmount \\u003c= maxTokensPerAddress, \\\"Purchase exceeds max tokens per address\\\");\\r\\n        require(totalTokensSold + _tokenAmount \\u003c= maxTokens, \\\"Not enough tokens left\\\");\\r\\n\\r\\n        if (tokensPurchased[msg.sender] == 0) {\\r\\n            buyers.push(msg.sender);\\r\\n        }\\r\\n\\r\\n        tokensPurchased[msg.sender] += _tokenAmount;\\r\\n        totalTokensSold += _tokenAmount;\\r\\n\\r\\n        if (referrer != address(0) \\u0026\\u0026 referrer != msg.sender) {\\r\\n            if (referrers[msg.sender] == address(0)) {\\r\\n                referrers[msg.sender] = referrer;\\r\\n            }\\r\\n\\r\\n            uint256 referralRewardLine1 = (usdtAmount * referralPercentageLine1) / 100;\\r\\n            referralRewards[referrer] += referralRewardLine1;\\r\\n            emit ReferralRewarded(referrer, referralRewardLine1);\\r\\n            address referrerLine2 = referrers[referrer];\\r\\n\\r\\n            uint256 referralRewardLine2 = (usdtAmount * referralPercentageLine2) / 100;\\r\\n            if (referrerLine2 != address(0) \\u0026\\u0026 referrerLine2 != msg.sender) {\\r\\n                if (referrersLine2[msg.sender] == address(0)) {// Sprawdzanie, czy polecony ma ju\u017c polecaj\u0105cego w 2. linii\\r\\n                    referrersLine2[msg.sender] = referrerLine2;\\r\\n                }\\r\\n\\r\\n                referralRewards[referrerLine2] += referralRewardLine2;\\r\\n                emit ReferralRewarded(referrerLine2, referralRewardLine2);\\r\\n            }\\r\\n\\r\\n        }\\r\\n\\r\\n        require(usdtToken.transferFrom(msg.sender, address(this), usdtAmount), \\\"Transfer failed\\\");\\r\\n\\r\\n        emit TokensPurchased(msg.sender, _tokenAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the available withdrawals for the specified user.\\r\\n     * @dev Returns both USDT referral rewards and undistributed MCE tokens.\\r\\n     * @param user The address of the user.\\r\\n     * @return usdtAmount Amount of USDT available for withdrawal.\\r\\n     * @return mceToDistribute Amount of MCE tokens yet to be distributed to the user.\\r\\n     */\\r\\n    function getAvailableWithdrawals(address user) external view returns (uint256 usdtAmount, uint256 mceToDistribute) {\\r\\n        usdtAmount = referralRewards[user];\\r\\n        mceToDistribute = tokensPurchased[user];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the amount of MCE tokens left to be purchased.\\r\\n     * @dev Calculates the difference between the max tokens and the total tokens sold.\\r\\n     * @return Amount of MCE tokens still available for purchase.\\r\\n     */\\r\\n    function getTokensLeftToPurchase() external view returns (uint256) {\\r\\n        uint256 tokensLeft = maxTokens - totalTokensSold;\\r\\n        return tokensLeft;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the amount of referral percentage for the first line.\\r\\n     * @return The percentage value for the first line referrers.\\r\\n     */\\r\\n    function getReferralPercentageLine1() public view returns (uint256) {\\r\\n        return referralPercentageLine1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the amount of referral percentage for the second line.\\r\\n     * @return The percentage value for the second line referrers.\\r\\n     */\\r\\n    function getReferralPercentageLine2() public view returns (uint256) {\\r\\n        return referralPercentageLine2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieve the price of the token in the sale.\\r\\n     * @return The price of the token.\\r\\n     */\\r\\n    function getTokenPrice() public view returns (uint256) {\\r\\n        return tokenPrice;\\r\\n    }\\r\\n    /**\\r\\n     * @notice End the token sale.\\r\\n     * @dev Can only be called by the contract owner and only if the sale hasn\\u0027t ended yet.\\r\\n     */\\r\\n    function endSale() external onlyOwner {\\r\\n        require(!saleEnded, \\\"Sale already ended\\\");\\r\\n        saleEnded = true;\\r\\n\\r\\n        // Rejestrujemy dat\u0119 zako\u0144czenia sprzeda\u017cy\\r\\n        emit SaleEnded();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Enable Claim Tokens.\\r\\n     * @dev Can only be called by the contract owner and only if the sale hasn\\u0027t ended yet.\\r\\n     */\\r\\n    function startClaimTokens() external onlyOwner {\\r\\n        require(!enableClaimTokens, \\\"ClaimTokens already possible\\\");\\r\\n        enableClaimTokens = true;\\r\\n        emit EnableClaimTokens();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Distribute MCE tokens to all buyers.\\r\\n     * @dev Can only be called by the contract owner and only if the sale has ended.\\r\\n     */\\r\\n    function distributeTokens() external onlyOwner {\\r\\n        require(saleEnded, \\\"Sale not ended yet\\\");\\r\\n        require(tokensListed, \\\"Sale not ended yet\\\");\\r\\n        require(enableClaimTokens, \\\"Claim Tokens is not possible on this moment\\\");\\r\\n        require(mceToken != IERC20(address(0)), \\\"MCE token address not set\\\");\\r\\n\\r\\n        uint256 contractBalance = mceToken.balanceOf(address(this));\\r\\n        require(contractBalance \\u003e 0, \\\"No MCE tokens in the contract\\\");\\r\\n\\r\\n        uint length = buyers.length;\\r\\n        for (uint i = 0; i \\u003c length; i++) {\\r\\n            address buyer = buyers[i];\\r\\n\\r\\n            uint256 tokensToDistribute = tokensPurchased[buyer];\\r\\n\\r\\n            if (tokensToDistribute \\u003e 0) {\\r\\n                require(mceToken.transfer(buyer, tokensToDistribute), \\\"Transfer failed\\\");\\r\\n                emit TokensDistributed(buyer, tokensToDistribute);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Calculate the number of tokens that the user can claim at this moment.\\r\\n    * @param user The address of the user.\\r\\n    * @return The number of tokens the user can currently claim.\\r\\n    */\\r\\n    function calculateClaimableTokens(address user) external view returns (uint256) {\\r\\n        uint256 claimableNow = _calculateClaimableTokens(user);\\r\\n        return claimableNow;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n    * @notice Calculate the number of tokens that the user can claim at this moment.\\r\\n    * @param user The address of the user.\\r\\n    * @return The number of tokens the user can currently claim.\\r\\n    */\\r\\n    function _calculateClaimableTokens(address user) internal view returns (uint256) {\\r\\n        if (!saleEnded || !enableClaimTokens) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 totalTokensForUser = tokensPurchased[user];\\r\\n        uint256 alreadyClaimed = tokensClaimed[user];\\r\\n\\r\\n        // No tokens to claim for the user or all tokens already claimed\\r\\n        if (totalTokensForUser == 0 || alreadyClaimed \\u003e= totalTokensForUser) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 totalVestedAvailable;\\r\\n\\r\\n        if(alreadyClaimed == 0 \\u0026\\u0026 tokensListed) {\\r\\n            totalVestedAvailable = totalTokensForUser * PERCENTAGE_WITHDRAWABLE_AFTER_LISTING / 100;\\r\\n        } else {\\r\\n            if (block.timestamp \\u003c saleEndDate + 90 days) {\\r\\n                // Vesting cliff not passed yet\\r\\n                return 0;\\r\\n            }\\r\\n\\r\\n            uint256 monthsSinceSaleEnd = (block.timestamp - saleEndDate) / 30 days;\\r\\n\\r\\n            if (monthsSinceSaleEnd \\u003c 1) {\\r\\n                return 0;\\r\\n            }\\r\\n\\r\\n            if (monthsSinceSaleEnd \\u003c VESTING_CLIFF_MONTHS) {\\r\\n                totalVestedAvailable = 0;\\r\\n            } else {\\r\\n                totalVestedAvailable = totalTokensForUser * (PERCENTAGE_WITHDRAWABLE_AFTER_LISTING + PERCENTAGE_WITHDRAWABLE_AFTER_CLIFF + (monthsSinceSaleEnd - VESTING_CLIFF_MONTHS) * PERCENTAGE_WITHDRAWABLE_AFTER_CLIFF) / 100;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 claimableNow = totalVestedAvailable - alreadyClaimed;\\r\\n\\r\\n        return claimableNow;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allow a user to claim their purchased MCE tokens based on the vesting schedule.\\r\\n     * @dev Ensures the vesting cliff has passed and only the vested amount can be claimed.\\r\\n     */\\r\\n    function claimTokens() external nonReentrant {\\r\\n\\r\\n        require(mceToken != IERC20(address(0)), \\\"MCE token address not set\\\");\\r\\n        uint256 claimableNow = _calculateClaimableTokens(msg.sender);\\r\\n\\r\\n        require(claimableNow \\u003e 0, \\\"No tokens available to claim now\\\");\\r\\n\\r\\n        if (lastClaimTime[msg.sender] == 0) {\\r\\n            lastClaimTime[msg.sender] = block.timestamp;\\r\\n        }\\r\\n\\r\\n        tokensClaimed[msg.sender] += claimableNow;\\r\\n\\r\\n        require(mceToken.transfer(msg.sender, claimableNow), \\\"Transfer failed\\\");\\r\\n        emit TokensDistributed(msg.sender, claimableNow);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allow the contract owner to withdraw all collected USDT.\\r\\n     * @dev Can only be called by the contract owner.\\r\\n     */\\r\\n    function withdrawFunds(uint256 _withdrawValue) external onlyOwner {\\r\\n        uint256 balance = usdtToken.balanceOf(address(this));\\r\\n        require(balance \\u003e 0, \\\"No funds to withdraw\\\");\\r\\n        require(balance \\u003e _withdrawValue, \\\"No required funds to withdraw\\\");\\r\\n        require(usdtToken.transfer(owner(), _withdrawValue), \\\"Transfer failed\\\");\\r\\n        emit FundsWithdrawn(owner(), _withdrawValue);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Define the MCE token contract that the sale will distribute.\\r\\n     * @param _mceToken The address of the MCE token contract.\\r\\n     */\\r\\n    function setMceTokenAddress(address _mceToken) external onlyOwner {\\r\\n        require(address(mceToken) == address(0), \\\"MCE token address already set\\\");\\r\\n        mceToken = IERC20(_mceToken);\\r\\n        emit MceTokenAddressSet(_mceToken);\\r\\n        // Nowe zdarzenie\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a referrer to withdraw their earned referral rewards.\\r\\n     * @dev This function uses nonReentrant to avoid reentrancy attacks.\\r\\n     */\\r\\n    function withdrawReferralReward() external nonReentrant {\\r\\n        uint256 reward = referralRewards[msg.sender];\\r\\n        require(reward \\u003e 0, \\\"No referral rewards\\\");\\r\\n        referralRewards[msg.sender] = 0;\\r\\n        require(usdtToken.transfer(msg.sender, reward), \\\"Transfer failed\\\");\\r\\n        emit ReferralWithdrawn(msg.sender, reward);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get a list of all buyer addresses.\\r\\n     * @return A list of addresses.\\r\\n     */\\r\\n    function getAllBuyers() external view returns (address[] memory) {\\r\\n        return buyers;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Fetch all buyers and the respective amounts they have purchased.\\r\\n     * @return Two arrays: one with buyer addresses and one with the amount of tokens they\\u0027ve purchased.\\r\\n     */\\r\\n    function getAllBuyersWithAmounts() external view returns (address[] memory, uint256[] memory) {\\r\\n        uint256 buyerCount = buyers.length;\\r\\n\\r\\n        address[] memory buyerAddresses = new address[](buyerCount);\\r\\n        uint256[] memory tokenAmounts = new uint256[](buyerCount);\\r\\n\\r\\n        for (uint i = 0; i \\u003c buyerCount; i++) {\\r\\n            buyerAddresses[i] = buyers[i];\\r\\n            tokenAmounts[i] = tokensPurchased[buyers[i]];\\r\\n        }\\r\\n\\r\\n        return (buyerAddresses, tokenAmounts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Pause the token sale.\\r\\n     * @dev This can only be done by the contract owner. Pausing halts the buying of tokens.\\r\\n     */\\r\\n    function pauseSale() external onlyOwner {\\r\\n        _pause();\\r\\n        emit SalePaused();\\r\\n        // Nowe zdarzenie\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Resume the token sale if it has been paused.\\r\\n     * @dev This can only be done by the contract owner.\\r\\n     */\\r\\n    function resumeSale() external onlyOwner {\\r\\n        _unpause();\\r\\n        emit SaleResumed();\\r\\n        // Nowe zdarzenie\\r\\n    }\\r\\n\\r\\n\\r\\n    function confirmTokenListing() external onlyOwner {\\r\\n        require(!tokensListed, \\\"Tokens already listed\\\");\\r\\n        tokensListed = true;\\r\\n        saleEndDate = block.timestamp;\\r\\n        emit TokensListed();\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdtToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EnableClaimTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"mceToken\",\"type\":\"address\"}],\"name\":\"MceTokenAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"ReferralRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SalePaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SaleResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensLeftToPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TokensListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PERCENTAGE_WITHDRAWABLE_AFTER_CLIFF\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTAGE_WITHDRAWABLE_AFTER_LISTING\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VESTING_CLIFF_MONTHS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"buyers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateClaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmTokenListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableClaimTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllBuyers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllBuyersWithAmounts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAvailableWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mceToDistribute\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReferralPercentageLine1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReferralPercentageLine2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokensLeftToPurchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokensPerAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mceToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralPercentageLine1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralPercentageLine2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrersLine2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resumeSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleEndDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mceToken\",\"type\":\"address\"}],\"name\":\"setMceTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startClaimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensPurchased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawValue\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReferralReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SeedSale", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://14abee6f10586dd9defa2ceb694dec14d3fa24fd25382578b9eb42824bf255aa"}