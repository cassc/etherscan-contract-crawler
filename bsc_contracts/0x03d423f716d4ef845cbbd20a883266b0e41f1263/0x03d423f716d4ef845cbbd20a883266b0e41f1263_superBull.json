{"SourceCode": "pragma solidity 0.5.10; \r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, 'SafeMath mul failed');\r\n    return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, 'SafeMath sub failed');\r\n    return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, 'SafeMath add failed');\r\n    return c;\r\n    }\r\n}\r\n\r\n \r\ncontract owned {\r\n    address  public owner;\r\n    address  internal newOwner;\r\n\r\nmodifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n   \r\n}\r\n\r\ninterface tokenInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n    function balanceOf(address _user) external view returns(uint);\r\n }\r\n\r\ncontract superBull is owned {\r\n\r\n    //for registration\r\n        struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint origRef;\r\n        uint lastBought;\r\n        uint totalBought;\r\n        address[] referral;\r\n    }\r\n\r\n    mapping (address => userInfo) public userInfos;\r\n    mapping (uint => address ) public userAddressByID; \r\n\r\n    mapping(address => bool) public levelEligible;  \r\n\r\n    mapping(uint => uint) public levelPayout;\r\n\r\n    uint maxLimit = 1000 * (10**18);\r\n\r\n\r\n\r\n    /*===============================\r\n    =         DATA STORAGE          =\r\n    ===============================*/\r\n\r\n    // Public variables of the token\r\n    using SafeMath for uint256;\r\n    string constant private _name = \"bull Token\";\r\n    string constant private _symbol = \"sptT\";\r\n    uint256 constant private _decimals = 18;\r\n    uint256 private _totalSupply;         //800 million tokens\r\n\r\n    address public USDTAddress;\r\n\r\n    uint public regPrice;\r\n    uint public lastBullCount;\r\n\r\n    address alternate;\r\n\r\n    uint256 constant public maxSupply = 80000000000000 * (10**_decimals);    //80000 million tokens\r\n    bool public safeguard;  //putting safeguard on will halt all non-owner functions\r\n\r\n    // This creates a mapping with all data storage\r\n    mapping (address => uint256) private _balanceOf;\r\n    mapping (address => mapping (address => uint256)) private _allowance;\r\n    mapping (address => bool) public frozenAccount;\r\n    mapping (address => uint) public totalBought;\r\n\r\n\r\n\r\n\r\n    // This generates a public event of token transfer\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n        \r\n    // This generates a public event for frozen (blacklisting) accounts\r\n    event FrozenAccounts(address target, bool frozen);\r\n    \r\n    // This will log approval of token Transfer\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n\r\n        uint multiply = 10 ** 18;\r\n\r\n        regPrice = 10 * multiply;\r\n\r\n        // In percent\r\n        levelPayout[1] = 10;\r\n        levelPayout[2] = 5;\r\n        levelPayout[3] = 5;\r\n        levelPayout[4] = 3;\r\n        levelPayout[5] = 2;\r\n        levelPayout[6] = 1;\r\n        levelPayout[7] = 1;\r\n        levelPayout[8] = 1;\r\n        levelPayout[9] = 1;\r\n        levelPayout[10]= 1;\r\n\r\n        userInfo memory UserInfo;\r\n        lastBullCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastBullCount,\r\n            origRef:lastBullCount,            \r\n            lastBought:0,\r\n            totalBought:0,\r\n            referral: new address[](0)\r\n        });\r\n        userInfos[owner] = UserInfo;\r\n        userAddressByID[lastBullCount] = owner;\r\n        levelEligible[owner] = true;\r\n    }\r\n\r\n    function changeMaxLimit(uint _maxLimit) public onlyOwner returns(bool)\r\n    {\r\n        maxLimit = _maxLimit;\r\n        return true;\r\n    }\r\n\r\n    function regUserOwn(address _refAddress, address _user) public onlyOwner returns(bool)\r\n    {\r\n        uint prc = regPrice;\r\n        tokenInterface(USDTAddress).transferFrom(msg.sender,address(this), prc);\r\n        regUser_(_refAddress, _user,prc);\r\n        return true;\r\n    }\r\n\r\n    function regUser(address _refAddress) public returns(bool)\r\n    {\r\n        uint prc = regPrice;\r\n        tokenInterface(USDTAddress).transferFrom(msg.sender,address(this), prc);\r\n        regUser_(_refAddress, msg.sender,prc);\r\n        return true;\r\n    }\r\n\r\n    event regUserEv(uint _lastBullCount,uint _referrerID,address _user );\r\n    function regUser_(address _refAddress, address msgsender, uint prc) internal returns(bool)\r\n    {\r\n\r\n        require(!userInfos[msgsender].joined, \"already joined\");\r\n        require(userInfos[_refAddress].joined, \"invalid referrer\");\r\n\r\n\r\n        //require(user4thParent<14, \"no place under this referrer\");\r\n       \r\n        address origRef = _refAddress;\r\n        uint _referrerID = userInfos[_refAddress].id;\r\n\r\n\r\n        lastBullCount++;\r\n        userInfo memory UserInfo;\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastBullCount,\r\n            origRef:userInfos[_refAddress].id,            \r\n            lastBought:prc,\r\n            totalBought:prc,\r\n            referral: new address[](0)\r\n        });\r\n        userInfos[msgsender] = UserInfo;\r\n        userAddressByID[lastBullCount] = msgsender;\r\n        userInfos[origRef].referral.push(msgsender);      \r\n\r\n        emit regUserEv(lastBullCount,_referrerID,msgsender );\r\n\r\n        tokenInterface(USDTAddress).transfer(address(uint160(_refAddress)), prc / 2);\r\n        increaseLiquidity(prc * 2 / 100, msgsender);\r\n\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n    // token sections.....................*********************************.........................\r\n    //......................................***************************.............................\r\n\r\n    function name() public pure returns(string memory){\r\n        return _name;\r\n    }\r\n    \r\n\r\n    function symbol() public pure returns(string memory){\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns(uint256){\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n\r\n    function balanceOf(address user) public view returns(uint256){\r\n        return _balanceOf[user];\r\n    }\r\n    \r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowance[owner][spender];\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        \r\n        //checking conditions\r\n        require(!safeguard);\r\n        require (_to != address(0));                      // Prevent transfer to 0x0 address. Use burn() instead\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\r\n        \r\n        // overflow and undeflow checked by SafeMath Library\r\n        burn( _value / 20); // 5% burn on each transfer\r\n        _balanceOf[_from] = _balanceOf[_from].sub(_value * 95 / 100);    // Subtract from the sender\r\n        _balanceOf[_to] = _balanceOf[_to].add(_value * 95 / 100);        // Add the same to the recipient\r\n        \r\n        // emit Transfer event\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //no need to check for input validations, as that is ruled by SafeMath\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //checking of allowance and token value is done by SafeMath\r\n        _allowance[_from][msg.sender] = _allowance[_from][msg.sender].sub(_value);\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        require(!safeguard);\r\n\r\n        _allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n\r\n    function increase_allowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].add(value);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decrease_allowance(address spender, uint256 value) public returns (bool) {\r\n        require(spender != address(0));\r\n        _allowance[msg.sender][spender] = _allowance[msg.sender][spender].sub(value);\r\n        emit Approval(msg.sender, spender, _allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function initialize(uint initialLiquidity, uint initialTokens, address _USDTAddress, address rewardWallet) public returns(bool) {\r\n        require(USDTAddress == address(0), \"can't call twice\");\r\n        USDTAddress = _USDTAddress;\r\n\r\n        alternate = rewardWallet;\r\n\r\n        tokenInterface(USDTAddress).transferFrom(msg.sender,address(this),initialLiquidity);\r\n\r\n        mintToken(msg.sender, initialTokens ); // 5% burnt\r\n        //emit Burn(msg.sender, initialTokens * 5 / 100);\r\n        emit Transfer(msg.sender, address(0), initialTokens * 5 / 100 );\r\n    }\r\n    \r\n \r\n\r\n    function mintToken(address target, uint256 mintedAmount) internal {\r\n        require(_totalSupply.add(mintedAmount) <= maxSupply, \"Cannot Mint more than maximum supply\");\r\n        _balanceOf[target] = _balanceOf[target].add(mintedAmount);\r\n        _totalSupply = _totalSupply.add(mintedAmount);\r\n        emit Transfer(address(0), target, mintedAmount);\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(!safeguard);\r\n        //checking of enough token balance is done by SafeMath\r\n        _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);  // Subtract from the sender\r\n        _totalSupply = _totalSupply.sub(_value);                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n        return true;\r\n    }\r\n\r\n   \r\n\r\n    function increaseLiquidity(uint _liquidity, address _caller) internal returns(bool)\r\n    {\r\n        uint amount = _liquidity * ( 10 ** 18 ) / currentRate();                 // calculates the amount\r\n        mintToken(_caller, amount * 8 / 10); // 20% burnt\r\n        emit Burn(msg.sender, amount /5);\r\n        emit Transfer(msg.sender, address(0), amount/5);\r\n        return true;\r\n    }\r\n\r\n    \r\n    //current rate is with divisor 1000000000000000000 , to adjust fractional values\r\n    function currentRate() public view returns(uint)\r\n    {\r\n        uint usdtBalance = tokenInterface(USDTAddress).balanceOf(address(this));\r\n        uint curRate =  usdtBalance * (10 ** 18 ) / totalSupply();\r\n        return curRate;\r\n    }\r\n\r\n    \r\n    function buyTokens(uint _amount ) public {\r\n        require(userInfos[msg.sender].joined, \"please register first\");\r\n        userInfo memory temp = userInfos[msg.sender];\r\n        \r\n        require(_amount >= temp.lastBought  && temp.totalBought + _amount <= maxLimit && _amount % 10 == 0, \"check amount\");\r\n        tokenInterface(USDTAddress).transferFrom(msg.sender,address(this),_amount);\r\n        userInfos[msg.sender].totalBought += _amount;\r\n        userInfos[msg.sender].lastBought = _amount;\r\n\r\n        uint amount = _amount * ( 10 ** 18 ) / currentRate();                 // calculates the amount\r\n        mintToken(msg.sender, (amount*40)/100); // 50% to buyer\r\n        mintToken(alternate, amount / 10); // 5% to alternate\r\n       // if(!levelEligible[msg.sender]) levelEligible[msg.sender] = true;\r\n\r\n        address ref = userAddressByID[userInfos[msg.sender].origRef];\r\n        for (uint i=1;i<11;i++)\r\n        {\r\n            mintToken(ref, amount * levelPayout[i]/ 100); // mint for level payout\r\n            ref = userAddressByID[userInfos[ref].origRef];\r\n           // if(!levelEligible[ref]) ref = getNextRef(ref);\r\n        }\r\n\r\n        emit Burn(msg.sender, amount/5); //20% burn\r\n        emit Transfer(msg.sender, address(0), amount/5);\r\n    }\r\n\r\n    function getNextRef(address _ref) public view returns(address)\r\n    {\r\n        for(uint j; j < 10; j++)\r\n        {\r\n            _ref = userAddressByID[userInfos[_ref].origRef];\r\n            if(levelEligible[_ref]) return _ref;\r\n        }\r\n        return owner;\r\n    }\r\n\r\n\r\n    function sellTokens(uint256 amount) public {\r\n        require(_balanceOf[msg.sender] >= amount, \"low balance\");\r\n        uint256 usdtAmount = amount * currentRate() /(10 ** 18);\r\n        usdtAmount = usdtAmount * 8 / 10;\r\n        require(tokenInterface(USDTAddress).balanceOf(address(this)) > usdtAmount,\"insufficient usdt available\");   // checks if the contract has enough usdt to buy\r\n        burn(amount * 95 / 100); // 95% burnt\r\n        transfer(alternate, amount * 5 / 100); // 5% to alternate\r\n        tokenInterface(USDTAddress).transfer(msg.sender,usdtAmount);\r\n    }\r\n    \r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"initialLiquidity\",\"type\":\"uint256\"},{\"name\":\"initialTokens\",\"type\":\"uint256\"},{\"name\":\"_USDTAddress\",\"type\":\"address\"},{\"name\":\"rewardWallet\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"levelEligible\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPayout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"regPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxLimit\",\"type\":\"uint256\"}],\"name\":\"changeMaxLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"name\":\"joined\",\"type\":\"bool\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"origRef\",\"type\":\"uint256\"},{\"name\":\"lastBought\",\"type\":\"uint256\"},{\"name\":\"totalBought\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBullCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decrease_allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refAddress\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"regUserOwn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"increase_allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"getNextRef\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safeguard\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_refAddress\",\"type\":\"address\"}],\"name\":\"regUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USDTAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenAccounts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_lastBullCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_referrerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"regUserEv\",\"type\":\"event\"}]", "ContractName": "superBull", "CompilerVersion": "v0.5.10+commit.5a6ea5b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://168da2e08b7e4b1e5412955ab03ed77c75a4e7ba3f7648743dfa001b7844f92f"}