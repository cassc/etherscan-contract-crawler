{"SourceCode": "// SPDX-License-Identifier: RXFNDTN\r\n\r\npragma solidity ^0.7.4;\r\n\r\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 //\r\n// \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\u2591\u2591 //  CONTRACT:\r\n// \u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d\u2591\u2591 //  DAILY AUCTIONS / \"RDA\"\r\n// \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591 //  PART OF \"REX\" SMART CONTRACTS\r\n// \u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2554\u2550\u2588\u2588\u2557\u2591\u2591\u2591 //\r\n// \u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2554\u255d\u2591\u2591\u2588\u2588\u2557\u2591\u2591 //  THIS CODE IS FOR DEPLOYMENT ON NETWORK:\r\n// \u2591\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591 //  BINANCE SMART CHAIN - ID: 56\r\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 //\r\n// \u2591\u2591 Latin: king, ruler, monarch \u2591\u2591 //\r\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 //\r\n// \u2591\u2591\u2591 Copyright (C) 2022 rex.io \u2591\u2591\u2591 //  SINGLE SOURCE OF TRUTH: rex.io\r\n// \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 //\r\n\r\n/**\r\n *\r\n * GENERAL SHORT DESCRIPTION\r\n *\r\n * REX is the world's first extended STAKING token protocol.\r\n * It is a store of value designed to provide passive income.\r\n * REX token and its functionality is described in the REX PAPER (whitepaper).\r\n *\r\n * This contract implements REX DAILY AUCTIONS and adds liquidity to PancakeSwap (INITIAL and DAILY).\r\n *\r\n * \"AUCTION PHASE\"\r\n * For creating the initial REX supply, REX tokens are being auctioned in 222 'Daily Auctions' (REX DAY 1 to 222).\r\n * A participant is sending BUSD as a bid for a portion of the daily auction pool.\r\n * The minimum bid is 100 BUSD, th maximum is 50,000 (100,000 when holding TREX), only one bid per day.\r\n * The daily auctioned REX are then distributed amongst the days' participants in proportion to their investment percentage.\r\n *\r\n * Auctioned REX must be actively claimed by the user (as liquid REX or as a REX stake).\r\n * When taking part in an auction and \"claiming REX as a STAKE\", the user is eligible for BigPayDays (paid in BUSD).\r\n * claiming the REX from auctions as liquid REX once, sets the user \"not eligible\" for BigPayDays forever\r\n * This incentivizes staking (and thus price appreciation of REX token).\r\n *\r\n * BigPayDays:\r\n * REX introduces Personal Random Big Pay Days that occur every 24 hours, where auction participants may win their BUSD back.\r\n * BigPayDay routine tries to give the winners ALL their invested BUSD back, every time they are hit, again and again.\r\n * As only 400 BigPayDays can be distributed safely (gas limits), the BigPayDay pool may rise and rise (if too many addresses are eligible) -\r\n * therefore an external function \"_createUserBPD()\" has been created that allows users to trigger a seperate BPD and empty the pool\r\n * \"Random\" number generation remark: The community has decided NOT to use oracles to create random numbers (due to safety).\r\n *\r\n * TREASURY:\r\n * All users, that are eligible for BigPayDays but never get one, shall get BUSD from the TREASURY, when the auctions end\r\n * They are tracked in \"address[] private userAddressesBPD\" (all BigPayDay addresses) and\r\n * also the contract knows whether the address is \"addressHitByRandom\" (= had a BigPayDay)\r\n * The donations of that address (BUSD sent to auctions) are saved in \"sumOfDonationsOfUnHit\" (used for ratio calculations):\r\n * When the TREASURY is opened, the addresses receive their portion of ALL BUSD in the contract at that time.\r\n * All unclaimed referralBUSD and randomBUSD must be claimed until LAST_CLAIM_DAY (day 250) or they are also sent to BUSDTREASURY.\r\n *\r\n * The contract has a referral system.\r\n * Referrers get 10% of the REX the referee gets, plus (when holding 1-5 MREX) 1-5% of the investor's BUSD ('referralBUSD')\r\n *\r\n * AUTOMATIC LIQUIDITY ADDING (to the REX-BUSD PancakeSwap pair)\r\n * 1) DAILY\r\n * This contract sends 10% of the daily received BUSD from auctions (and the corresponding amount of REX) to the pair\r\n * via calling (\"_fillLiquidityPool()\"). The LP tokens are burnt, so the liquidity can never be withdrawn from the pair.\r\n *\r\n * 2) INITIALLY (and maybe also DAILY):\r\n * Even before the auctions start on REX DAY 1, users may send BUSD to the contract using \"sendLiquidityBUSD()\"\r\n * (minimum invest per address: 100 BUSD, maximum per adress: 500,000 BUSD. 10,000,000 BUSD is the total maximum).\r\n * The total number of BUSD are saved in INITIAL_LIQ_BUSD. The BUSD are collected in the contract.\r\n * On the beginning of REX DAY 2, those BUSD (and the corresponding amount newly minted REX) are sent to the pair\r\n * As no REX have ever been sent to the pair before, this adding of liquidity sets the REX PRICE in the pair.\r\n * If more than 100k BUSD are available in INITIAL_LIQ_BUSD, only 100k BUSD are added as liquidity on REX DAY 2 -\r\n * the rest is added in the course of the next 200 days (1/200 of the remaining BUSD per day = EXTRA_DAILY_LIQ),\r\n * starting on REX DAY 3 - with the corresponding amount of REX tokens (newly minted, depending on the actual PCS reserves).\r\n * This leads to an ever rising liquidity in the pair, in the course of the auction phase\r\n * (together with the 10% of the BUSD that come from the daily auctions)\r\n * The LP_TOKENS received from this are collected in the contract and may be withdrawn\r\n * by the INITIAL LIQUIDITY providers from day 223. (Locked until then, then payout 10% every 30 days)\r\n *\r\n * Overview: AUCTION ARRIVING BUSD - DISRIBUTION:\r\n * 75% of the sent BUSD are GIVEN BACK to the auction participants of auctions via 'BigPayDays'.\r\n * 10% of the sent BUSD are SENT to PancakeSwap as liquidity, irrevokable (LP tokens burnt, see \"_fillLiquidityPool()\").\r\n * 5% are seperated: 1-5% are given back to referrers (if they hold MREX) and the rest (to 5%) is given back via the TREASURY.\r\n * 5% goes to a marketing fund\r\n * 5% goes to a development fund\r\n * In total, 90% are given back to investors, referrers or send to the PCS liquidity pool.\r\n *\r\n * Important REX days and INTERNAL timeline in DAILY AUCTIONS\r\n * 0 INITIAL LIQUIDITY PROVISION phase (\"DAY 0\" is from contract deployment until DAY 1 starts\r\n *  1 <=   DAILY AUCTIONS                  <= 222\r\n *  1 <=   BUSD claim phase of referralBUSD     <= 250\r\n *   2 <=   BUSD claim phase of randomBUSD      <= 250\r\n *     223 <=  INITIAL LIQUIDITY providers may withdraw LP_TOKENS (10% every 30 days)\r\n *       251 =    all BUSD are moved to BUSDTREASURY\r\n *        252 <=         BUSDTREASURY claimable     <= 258\r\n *         259 = end of all pools, end of claiming REX from Donations and Referrals = \"LAST_CONTRACT_DAY\"\r\n *\r\n *\r\n * PROCEDURE:\r\n * The \"supplyTrigger()\" modifier is used in every external contract (write) call. The mechanics are:\r\n *  1) Check for a new day has started (if so, calculate REX distribution from past day(s) and calculate BigPayDays),\r\n *  2) do whatever the caller wanted to do (claim tokens, send BUSD to auction,...)\r\n *  3) Check if there is new Liquidity from auction participation to add to PCS (capped) or from INITIAL_LIQ_BUSD (capped)\r\n *\r\n * \"ADMIN RIGHTS\"\r\n * The deploying address \"TOKEN_DEFINER\" has only one right (and task to do):\r\n * Calling initContracts() providing the addresses of the other REX contracts (REX and TREX).\r\n * This is needed to link the contracts after deployment.\r\n * Afterwards, the TOKEN_DEFINER shall call \"revokeAccess\", so this can only be done once.\r\n * No further special rights are granted to the TOKEN_DEFINER.\r\n *\r\n * \"GAS_REFUNDER\"\r\n * After deployment and initialization of this contract, one address, the \"GAS_REFUNDER\",\r\n * has special rights and access: This address is allowed to send BNB to this contract\r\n * (which will be used for refunding gas fees to users) and withdraw tokens from the contract\r\n * after the \u201cLAST CONTRACT DAY\u201d (when the auction phase is over and the TREASURY and all POOLS\r\n * have already been emptied by the users). This ability will be necessary to withdraw the\r\n * remaining BNB (that haven\u2019t been used for refunding gas fees) and for withdrawing other tokens\r\n * from the contract then - for example tokens that have accidentally been sent to the contract\r\n * and wouldn\u2019t be recoverable otherwise (which happens a lot). To grant full security, this\r\n * withdrawing ability explicitly excludes the REX-BUSD LP TOKENS that will wait in the contract\r\n * for initial liquidity providers even after the auction phase.\r\n *\r\n */\r\n\r\ninterface IREXToken {\r\n\r\n    function currentRxDay()\r\n        external view\r\n        returns (uint32);\r\n\r\n    function approve(\r\n        address _spender,\r\n        uint256 _value\r\n    ) external returns (bool success);\r\n\r\n    function mintSupply(\r\n        address _donatorAddress,\r\n        uint256 _amount\r\n    ) external;\r\n\r\n    function UNISWAP_PAIR()\r\n        external view\r\n        returns (IUniswapV2Pair);\r\n\r\n    function balanceOf(\r\n        address account\r\n    ) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    function createStake(\r\n        address _staker,\r\n        uint256 _amount,\r\n        uint32 _days,\r\n        string calldata _description,\r\n        bool _irrevocable\r\n    ) external;\r\n}\r\n\r\ninterface IBEP20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function factory() external pure returns (address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n}\r\n\r\ncontract RexDailyAuction {\r\n\r\n    using RexSafeMath for uint256;\r\n    using RexSafeMath32 for uint32;\r\n\r\n    address public TOKEN_DEFINER;   // for initializing contracts after deployment\r\n    address public GAS_REFUNDER;    // address that may send BNB to pay for gas refunds\r\n    IUniswapV2Pair public UNISWAP_PAIR;\r\n    IREXToken public REX_CONTRACT;\r\n    IBEP20 public TREX_TOKEN;\r\n    IBEP20 public MREX_TOKEN;\r\n    IBEP20 public BUSD_TOKEN;\r\n    IBEP20 public LP_TOKEN;\r\n\r\n    IUniswapV2Router02 public constant UNISWAP_ROUTER = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    address constant mrex_address = 0x76837D56D1105bb493CDDbEFeDDf136e7c34f0c4;\r\n    address constant busd_address = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address constant MARKETING_ADDR = 0x231f8084fECEee5b90021C42C083FEB73d4182F9;\r\n    address constant DEVELOPMENT_ADDR = 0xF3393b11Dc4CADFDc5BCed0F7BEB9d09Ce5C78D6;\r\n\r\n    uint32 constant DONATION_DAYS = 222;\r\n    uint32 constant LAST_CLAIM_DAY = 250;       // DONATION_DAYS + 28\r\n    uint32 constant TREASURY_CALC_DAY = 251;    // LAST_CLAIM_DAY + 1\r\n    uint32 constant TREASURY_CLAIM_DAY = 252;   // TREASURY_CALC_DAY + 1\r\n    uint32 constant LAST_CONTRACT_DAY = 259;    // TREASURY_CLAIM_DAY + 7\r\n\r\n    uint256 constant RX_DECIMALS = 1E18;        // decimals\r\n    uint256 constant HIGH_PRECISION = 100E18;\r\n    uint256 constant MIN_INVEST = 100E18;       // 100 BUSD minimum invest, for auctions and liquidity provision\r\n    uint256 constant MAX_INVEST = 50000E18;     // 50,000 BUSD maximum invest for auctions (per address per day)\r\n    uint256 constant DAILY_DIFF_SUPPLY = uint256(130000);  // daily supply reduction (day 4-222)\r\n    uint256 constant DAY_ONE_SUPPLY =    uint256(200E6);\r\n    uint256 constant DAY_TWO_SUPPLY =    uint256(140E6);\r\n    uint256 constant DAY_THREE_SUPPLY =  uint256(90E6);\r\n    uint256 constant DAY_LAST_SUPPLY =   uint256(53230000);\r\n    uint256 constant INTIAL_REX_PRICE = 7143;    // No of REX minted per BUSD => equals start price: 1/7143 = 0.0001399972 (BUSD/REX)\r\n\r\n    struct Globals {\r\n        uint32 generatedDays;\r\n        uint32 generatedBigPayDays;\r\n        uint256 totalDonatedBUSD;\r\n        uint256 totalGeneratedREX;\r\n        uint256 totalClaimedDonationREX;\r\n        uint256 totalClaimedReferralREX;\r\n        uint256 totalClaimedReferralBUSD;\r\n        uint256 totalClaimedRandomBUSD;\r\n    }\r\n\r\n    Globals public g;\r\n\r\n    bool public poolWasntEmpty;   // used to decide whether users can create an extra BigPayDay (where empty means 5000 BUSD or less were left)\r\n\r\n    mapping(uint32 => uint256) public dailyGeneratedREX;        // for calculating dailyRatio (REX)\r\n    mapping(uint32 => uint256) public dailyTotalDonation;       // for calculating dailyRatio (REX)\r\n    mapping(uint32 => uint256) public dailyTotalReferral;       // for calculating dailyRatio (REX)\r\n    mapping(uint32 => uint256) public dailyRatio;               // for calculating how many REX a BUSD gets (per day from auction investments)\r\n    uint32 public lastCheckedSupplyDay;                         // tracks successfully created past days of supply generation\r\n\r\n    mapping(uint32 => uint256) public donatorAccountCount;                    // numberOfDonators per day\r\n    mapping(address => mapping(uint32 => uint256)) public donatorBalances;    // address->day->amount\r\n    mapping(address => mapping(uint32 => bool)) public donatorBalancesDrawn;  // address->day->bool // set to true at withdrawal\r\n    mapping(address => uint256) public donatorTotalBalance;                   // donations per day including bonus (if MREX holder, if referrer set)\r\n    mapping(address => uint256) public donatorTotalRexReceived;               // total REX received from auctions\r\n    mapping(address => uint256) public originalDonation;                      // count donations for BUSDTREASURY\r\n    mapping (uint256 => address) public uniqueDonators;                       // address of x-th donator\r\n    uint256 public uniqueDonatorCount;\r\n\r\n    mapping(address => mapping(uint32 => uint256)) public referrerBalances;   // address->day => amount\r\n    mapping(address => mapping(uint32 => bool)) public referrerBalancesDrawn; // address->day => bool // set to true at withdrawal\r\n    mapping(address => uint256) public referralBUSD;                          // claimable referral BUSD of an address\r\n    mapping(address => uint256) public referrerTotalBalance;                  // Total received amount for referrals (10% of referred donations)\r\n    mapping (uint256 => address) public uniqueReferrers;                      // address of x-th referrer\r\n    uint256 public uniqueReferrerCount;\r\n\r\n    mapping(address => uint256) public randomBUSD;            // addresses' total amount of claimable BUSD from BPDs\r\n    mapping(address => bool) public addressHitByRandom;       // if not hit, take part in BUSDTREASURY claim phase (days 252-258)\r\n    mapping(address => bool) public addressBPDExcluded;       // if true, address may not take part in BPD\r\n    mapping(address => uint256) private userIndicesBPD;       // address index in the list \"userAddressesBPD\"\r\n    address[] private userAddressesBPD;                       // address list for BPD distribution\r\n\r\n    mapping(address => uint256) public liquidityBalances;       // BUSD sent by early investors (for PCS initial liquidity)\r\n    mapping(address => uint256) public liquidityBalancesDrawn;  // LP tokens withdrawn\r\n    uint256 public INITIAL_LIQ_BUSD;      // total liquidity send by users before DAY 1 (to add to PancakeSwap, initially and daily)\r\n    uint256 public EXTRA_DAILY_LIQ;       // the amount of BUSD in INITIAL_LIQ_BUSD that is exceeding 100k divided by 200\r\n    uint256 public totalLpTokens;         // total No of LP tokens received (from PCS) after sending initial liquidity to PCS (after day 1)\r\n\r\n    uint256 public toSendToPairBusd;      // pool of BUSD (10% from AUCTION amounts) that shall be sent be sent to PCS\r\n    uint256 public extraLiqBusdSent;      // total number of BUSD that have been sent to PCS (from EXTRA_DAILY_LIQ)\r\n    uint256 public BUSDPOOL;              // temporary pool of BUSD reserved for BPDs, unless distributed (to \"randomBUSD[user]\")\r\n    uint256 public BUSDTREASURY;          // pool of BUSD for donators not hit by random, claim phase: days 252-258\r\n    uint256 public treasuryRatio;         // 1E10 precision ratio, an unhit address gets from BUSDTREASURY\r\n    uint256 public sumOfDonationsOfUnHit; // needed for calculating treasuryRatio, updated with every donation\r\n\r\n    event DonationReceived(address indexed sender, uint32 indexed donationDay, uint256 amount);\r\n    event ReferralAdded(address indexed referrer, address indexed donator, uint256 amount);\r\n    event DistributedBigPayDay(uint32 round, uint256 participants, uint256 receivers, uint256 poolSizeStart, uint256 poolSizeEnd);\r\n    event SupplyGenerated(uint32 indexed donationDay, uint256 generatedREX);\r\n    event TreasuryGenerated(uint256 treasury, uint256 ratio);\r\n    event ClaimedBusdFromReferrals(address receiver, uint256 amount);\r\n    event ClaimedRexFromAuctions(address receiver, uint256 amount);\r\n    event ClaimedStakeFromAuctions(address receiver, uint256 amount);\r\n    event ClaimedRexFromReferrals(address receiver, uint256 amount);\r\n    event ClaimedBusdFromBPD(address receiver, uint256 amount);\r\n    event LiquidityGenerated(uint32 day, uint256 busdAmount, uint256 rexAmount);\r\n    event LiquidityReceived(address sender, uint256 busdAmount);\r\n    event LPtokensWithdrawn(address receiver, uint256 amountLpTokens);\r\n    event GasRefunded(address refundedAddress, uint256 refundedBNB);\r\n\r\n    /**\r\n     * @notice Triggers the daily distribution routines, checks for LIQUIDITY to add to the PCS PAIR\r\n     */\r\n    modifier supplyTrigger() {\r\n        require(_notContract(msg.sender) && msg.sender == tx.origin, 'REX: Invalid sender.');\r\n        _dailyDistributionRoutine();\r\n        _;\r\n        _fillLiquidityPool();\r\n    }\r\n\r\n    /**\r\n     * @notice For initializing the contract\r\n     */\r\n    modifier onlyTokenDefiner() {\r\n        require(\r\n            msg.sender == TOKEN_DEFINER,\r\n            'REX: Not allowed.'\r\n        );\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        require (\r\n            msg.sender == address(UNISWAP_ROUTER) ||\r\n            msg.sender == address(GAS_REFUNDER), 'REX: No direct deposits.'\r\n        );\r\n    }\r\n\r\n    fallback() external payable { revert(); }\r\n\r\n    /** @dev IMPORTANT PRE-DEPLOYMENT NOTICE:\r\n      * REX CONTRACT HAS TO BE DEPLOYED and initialized FIRST,\r\n      * because REX_CONTRACT.UNISWAP_PAIR is NEEDED for this init()\r\n      */\r\n    function initContracts(address _rex, address _trex) external onlyTokenDefiner {\r\n        REX_CONTRACT = IREXToken(_rex);\r\n        TREX_TOKEN = IBEP20(_trex);\r\n        UNISWAP_PAIR = REX_CONTRACT.UNISWAP_PAIR();\r\n        LP_TOKEN = IBEP20( address(UNISWAP_PAIR) );\r\n    }\r\n\r\n    function revokeAccess() external onlyTokenDefiner {\r\n        TOKEN_DEFINER = address(0x0);\r\n    }\r\n\r\n    constructor() {\r\n        TOKEN_DEFINER = msg.sender;\r\n        GAS_REFUNDER = msg.sender;\r\n        MREX_TOKEN = IBEP20(mrex_address);\r\n        BUSD_TOKEN = IBEP20(busd_address);\r\n    }\r\n\r\n    /** @notice A external function for a user (not a contract) to donate BUSD to daily auction's current day\r\n      * @dev This will require RDA contract to be approved as a spender (front-end)\r\n      * @param _busd_amount Amount of BUSD the sender wants to donate\r\n      * @param _referralAddress Referral address for 10% bonus\r\n      */\r\n    function donateBUSD(uint256 _busd_amount, address _referralAddress)\r\n        external supplyTrigger\r\n    {\r\n        require(_notContract(msg.sender) && msg.sender == tx.origin, 'REX: Not an address');\r\n\r\n        require(_currentRxDay() >= 1 && _currentRxDay() <= DONATION_DAYS, 'REX: Not in range.');\r\n        require(donatorBalances[msg.sender][_currentRxDay()] == 0, 'REX: Already donated.');\r\n        uint256 maxinvest = TREX_TOKEN.balanceOf(msg.sender) > 0 ? MAX_INVEST.mul(2) : MAX_INVEST; // TREX holders may donate 50% more\r\n        require(_busd_amount <= maxinvest, 'REX: donation above maximum');\r\n        require(_busd_amount >= MIN_INVEST, 'REX: donation below minimum');\r\n\r\n        require(BUSD_TOKEN.transferFrom(msg.sender, address(this), _busd_amount), \"REX: Transfer of BUSD failed.\");\r\n\r\n        _reserveRex(_referralAddress, msg.sender, _busd_amount);\r\n    }\r\n\r\n    /** @notice A private function doing the REX auction reservation and fills the pools, manages referral\r\n      * @param _referralAddress Referral address for BONUS (REX and BUSD)\r\n      * @param _senderAddress Address of donator\r\n      * @param _senderValue amount of BUSD (Wei)\r\n      */\r\n    function _reserveRex(\r\n        address _referralAddress,\r\n        address _senderAddress,\r\n        uint256 _senderValue\r\n    )\r\n        private\r\n    {\r\n          // self referral: allow, but no bonus (or if !_notContract) -> set to 0x0\r\n        if (_senderAddress == _referralAddress || !_notContract(_referralAddress)) { _referralAddress = address(0x0); }\r\n\r\n          // bonus: 10% more REX, if referrer provided\r\n        uint256 _donationBalance = _referralAddress == address(0x0)\r\n            ? _senderValue\r\n            : _senderValue.mul(11).div(10);\r\n\r\n          // bonus: up to 10% more REX, if MREX holder\r\n          // 2% more for every held MREX, capped at 5 MREX\r\n        uint256 mrex = MREX_TOKEN.balanceOf(_senderAddress);\r\n        if (mrex > 0)\r\n        {\r\n            if (mrex > 5) { mrex = 5; }  // limit\r\n            _donationBalance = _donationBalance.add( _senderValue.mul( mrex.mul(2) ).div(100) );\r\n        }\r\n\r\n          // this is for treasuryRatio calculation: add to the sum, if address has not been hit yet\r\n          // (the BigPayDay function subtracts, if an address is hit later, so the sum is always correct)\r\n        if (!addressHitByRandom[_senderAddress]) {\r\n            sumOfDonationsOfUnHit = sumOfDonationsOfUnHit.add(_senderValue);\r\n        }\r\n\r\n        _addDonationToDay(_senderAddress, _currentRxDay(), _donationBalance);\r\n        _trackDonators(_senderAddress, _donationBalance);             // count uniqueDonators\r\n        originalDonation[_senderAddress] = originalDonation[_senderAddress].add(_senderValue);\r\n        g.totalDonatedBUSD = g.totalDonatedBUSD.add(_senderValue);\r\n\r\n        BUSDPOOL = BUSDPOOL.add(_senderValue.mul(75).div(100));         // 75% for random BUSD BigPayDays\r\n        toSendToPairBusd = toSendToPairBusd.add(_senderValue.div(10));  // amount of BUSD to send to the PCS PAIR\r\n        BUSD_TOKEN.transfer(MARKETING_ADDR, _senderValue.div(20));      // 5% go to marketing\r\n        BUSD_TOKEN.transfer(DEVELOPMENT_ADDR, _senderValue.div(20));    // 5% go to development\r\n        // and 0-5% of BUSD go to the referrer, while 0-5% of BUSD of to TREASURY, so that ref + treasury = 5%\r\n        // 10% of BUSD go to liquidity, once a day (triggered by dailyRoutine)\r\n\r\n        if (_referralAddress != address(0x0)) {\r\n\r\n              // if referred: 10% of REX are reserved for referrer\r\n            uint256 amountREX = _senderValue.div(10);\r\n            _addReferralToDay(_referralAddress, _currentRxDay(), amountREX);\r\n            _trackReferrals(_referralAddress, amountREX);                             // count uniqueReferrers\r\n\r\n              // if referred: claimable BUSD for referrer (1% of BUSD per MREX held by referrer), rest goes to treasury\r\n            uint256 mrexRef = MREX_TOKEN.balanceOf(_referralAddress);\r\n            if (mrexRef > 5) { mrexRef = 5; }  // limit\r\n            referralBUSD[_referralAddress] = referralBUSD[_referralAddress].add( _senderValue.mul(mrexRef).div(100) );\r\n            BUSDTREASURY = BUSDTREASURY.add( _senderValue.mul( uint256(5).sub(mrexRef) ).div(100) );  // 0-5 MREX => rest goes to treasury\r\n\r\n            emit ReferralAdded(_referralAddress, _senderAddress, amountREX);\r\n        }\r\n        else\r\n        {\r\n            BUSDTREASURY = BUSDTREASURY.add( _senderValue.mul(5).div(100) );\r\n        }\r\n    }\r\n\r\n    /** @notice Record balance on specific day\r\n      * @param _senderAddress senders address\r\n      * @param _donationDay specific day\r\n      * @param _donationBalance amount (with bonus)\r\n      */\r\n    function _addDonationToDay(\r\n        address _senderAddress,\r\n        uint32 _donationDay,\r\n        uint256 _donationBalance\r\n    )\r\n        private\r\n    {\r\n        if (donatorBalances[_senderAddress][_donationDay] == 0) {\r\n            donatorAccountCount[_donationDay]++;\r\n        }\r\n        donatorBalances[_senderAddress][_donationDay] = donatorBalances[_senderAddress][_donationDay].add(_donationBalance);\r\n        dailyTotalDonation[_donationDay] = dailyTotalDonation[_donationDay].add(_donationBalance);\r\n\r\n        emit DonationReceived(_senderAddress, _donationDay, _donationBalance);\r\n    }\r\n\r\n    function _addReferralToDay(\r\n        address _referrer,\r\n        uint32 _donationDay,\r\n        uint256 _referralAmount\r\n    )\r\n        private\r\n    {\r\n        referrerBalances[_referrer][_donationDay] = referrerBalances[_referrer][_donationDay].add(_referralAmount);\r\n        dailyTotalReferral[_donationDay] = dailyTotalReferral[_donationDay].add(_referralAmount);\r\n    }\r\n\r\n    /** @notice Tracks donatorTotalBalance and uniqueDonators\r\n      * @dev used in _reserveRex() function\r\n      * @param _donatorAddress address of the donator\r\n      * @param _value BUSD invested (with bonus)\r\n      */\r\n    function _trackDonators(address _donatorAddress, uint256 _value) private {\r\n        if (donatorTotalBalance[_donatorAddress] == 0) {\r\n            uniqueDonators[uniqueDonatorCount] = _donatorAddress;\r\n            uniqueDonatorCount++;\r\n        }\r\n        donatorTotalBalance[_donatorAddress] = donatorTotalBalance[_donatorAddress].add(_value);\r\n    }\r\n\r\n    /** @notice Tracks referrerTotalBalance and uniqueReferrers\r\n      * @dev used in _reserveRex() internal function\r\n      * @param _referralAddress address of the referrer\r\n      * @param _value Amount referred during reservation\r\n      */\r\n    function _trackReferrals(address _referralAddress, uint256 _value) private {\r\n        if (referrerTotalBalance[_referralAddress] == 0) {\r\n            uniqueReferrers[uniqueReferrerCount] = _referralAddress;\r\n            uniqueReferrerCount++;\r\n        }\r\n        referrerTotalBalance[_referralAddress] = referrerTotalBalance[_referralAddress].add(_value);\r\n    }\r\n\r\n    /** @notice A function to allow an investor (not a contract) to send BUSD into this contract, before auctions start\r\n      * @dev This does not use the \"supplyTrigger\", because it is before day 1 and would fail\r\n      * Those BUSD will be added REX later and both will be added to REX/BUSD pair (on PancakeSwap V2)\r\n      * The LP tokens received after sending the liquidity, may be withdrawn (vested, after DONATION_DAYS)\r\n      * The user must APPROVE this contract to spend the user's BUSD (front-end)\r\n      * @param _busd_amount Amount of BUSD the sender wants to send\r\n      */\r\n    function sendLiquidityBUSD(uint256 _busd_amount)\r\n        external\r\n    {\r\n        require(_currentRxDay() < 1, 'REX: Too late');\r\n        require(_notContract(msg.sender) && msg.sender == tx.origin, 'REX: Invalid sender');\r\n        require(_busd_amount >= MIN_INVEST, 'REX: Below min');\r\n        require( (_busd_amount + liquidityBalances[msg.sender]) <= 5E23, 'REX: Address cap exceeded'); // 500,000 * 1E18 = 5E23\r\n        require( (_busd_amount + INITIAL_LIQ_BUSD) <= 1E25, 'REX: Liquidity cap exceeded'); // 10,000,000 * 1E18 = 1E25\r\n        require(_busd_amount.mod(MIN_INVEST) == 0, 'REX: Send full hundreds of BUSD only');\r\n\r\n        require(BUSD_TOKEN.transferFrom(msg.sender, address(this), _busd_amount), \"REX: Transfer of BUSD failed.\");\r\n\r\n        liquidityBalances[msg.sender] = liquidityBalances[msg.sender].add(_busd_amount);\r\n        INITIAL_LIQ_BUSD = INITIAL_LIQ_BUSD.add(_busd_amount);\r\n\r\n        emit LiquidityReceived(msg.sender, _busd_amount);\r\n    }\r\n\r\n    /** @notice A function to allow an investor to withdraw LP tokens this contract, after auctions ended\r\n      */\r\n    function withdrawLPTokens()\r\n        external supplyTrigger returns (uint256 lpTokensPayout)\r\n    {\r\n        require(_currentRxDay() > DONATION_DAYS, 'REX: Too early');          // LP token withdraw possible after DONATION_DAYS\r\n        require(liquidityBalances[msg.sender] > 0, 'REX: No LP tokens');     // sanity check for totalLpTokens > 0\r\n\r\n        lpTokensPayout = withdrawableLPTokens(msg.sender);\r\n        require(lpTokensPayout > 0, 'REX: No payout possible');\r\n\r\n        liquidityBalancesDrawn[msg.sender] = liquidityBalancesDrawn[msg.sender].add(lpTokensPayout);\r\n        LP_TOKEN.transfer(msg.sender, lpTokensPayout);\r\n\r\n        emit LPtokensWithdrawn(msg.sender, lpTokensPayout);\r\n    }\r\n\r\n    /** @notice A function to allow an investor to check for withdrawable LP tokens in this contract\r\n      * where 1/10 of LP tokens may be withdrawn every 30 days, beginning on day DONATION_DAYS+1 (after the auction phase)\r\n      */\r\n    function withdrawableLPTokens(address who)\r\n        public view returns (uint256 lpTokenPayout)\r\n    {\r\n        if (_currentRxDay() <= DONATION_DAYS) { return 0; }\r\n        if (liquidityBalances[who] == 0)  { return 0; }\r\n        if (INITIAL_LIQ_BUSD == 0)  { return 0; }\r\n\r\n        lpTokenPayout = totalLpTokens.mul(liquidityBalances[who]).div(INITIAL_LIQ_BUSD);  // payout = share of total\r\n        uint256 vestingPeriods = (uint256(_currentRxDay()).sub(uint256(DONATION_DAYS))).div(uint256(30)).add(uint256(1)); // = \"days after auction\" div(30) add(1) returns the number of \"vesting periods\"\r\n        vestingPeriods = vestingPeriods > 10 ? 10 : vestingPeriods; // if bigger than 10, cap to 10 (10=100%, see next line)\r\n        lpTokenPayout = lpTokenPayout.mul(vestingPeriods).div(10); // the possible payout is vestingPeriods/10\r\n        lpTokenPayout = lpTokenPayout > liquidityBalancesDrawn[who] ? lpTokenPayout.sub(liquidityBalancesDrawn[who]) : 0; // check if withdrawn LP tokens exist, then deduct from payout\r\n    }\r\n\r\n    /**\r\n     * @notice Allows to trigger routine (one day) without someone doing something\r\n     */\r\n    function triggerDailyRoutineOneDay()\r\n        external\r\n    {\r\n        require(_notContract(msg.sender) && msg.sender == tx.origin, 'REX: No contracts');\r\n\r\n        if (_currentRxDay() > 1)\r\n        {\r\n            uint32 _firstCheckDay = lastCheckedSupplyDay.add(1);\r\n            uint32 _lastCheckDay = _currentRxDay().sub(1);\r\n\r\n            if (_firstCheckDay <= _lastCheckDay) {\r\n                _generateSupplyAndCheckPools(_firstCheckDay);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    /** @notice Checks for past days if dailyRoutines have run, beginning on day2 for day1\r\n      * @dev triggered by any external contract call \"write\" via \"supplyTrigger\" modifier\r\n      */\r\n    function _dailyDistributionRoutine()\r\n        private\r\n    {\r\n          // the calculations must be made from day 2  - until LAST_CONTRACT_DAY == lastCheckedSupplyDay\r\n        if (_currentRxDay() > 1 && lastCheckedSupplyDay < LAST_CONTRACT_DAY)\r\n        {\r\n              // BPD list is randomly filled from day 1\r\n              // (shuffle from day 2 to have better randomness)\r\n            _shuffleBPDlist();\r\n\r\n            uint32 _firstCheckDay = lastCheckedSupplyDay.add(1);\r\n            uint32 _lastCheckDay = _currentRxDay().sub(1);\r\n\r\n            if (_firstCheckDay == _lastCheckDay) {                              // CHECK 1 DAY ONLY\r\n                _generateSupplyAndCheckPools(_firstCheckDay);\r\n            }\r\n            else\r\n            {\r\n                if (_firstCheckDay < _lastCheckDay) {                           // CHECK MORE DAYS\r\n                    for (uint32 _day = _firstCheckDay; _day <= _lastCheckDay; _day++) {\r\n                        _generateSupplyAndCheckPools(_day);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @notice Generates supply for past days and sets dailyRatio\r\n      * Calculate all bonuses and assign claimables\r\n      * @param _donationDay day index (from day 1 to DONATION_DAYS)\r\n      */\r\n    function _generateSupplyAndCheckPools(\r\n        uint32 _donationDay\r\n    )\r\n        private\r\n    {\r\n        uint256 gasAtStart = gasleft();   // TRACK THE GAS - to refund gas to the calling address at the end of this function\r\n\r\n          // Send initial liquidity (BUSD collected before REX DAY 1 + REX) to PancakeSwap pair\r\n          // A sandwich attack is not possible here, as no REX tokens exist at this moment\r\n        if (_donationDay == 1) { _sendInitialLiquidityToPCS(); }\r\n\r\n          // Generate REX supply for auction days (days 1-DONATION_DAYS)\r\n        if (_donationDay >= 1 && _donationDay <= DONATION_DAYS)\r\n        { _generateSupply(_donationDay); }\r\n\r\n          // if there is any investor that day, create BPD with up to 400 recipients\r\n        if (_donationDay >= 2 && _donationDay < LAST_CLAIM_DAY && BUSDPOOL >= MIN_INVEST)\r\n        { _createBPD(400); }\r\n\r\n          // BUSDTREASURY calculations trigger\r\n        if (_donationDay == TREASURY_CALC_DAY)\r\n        { _setTreasuryRatio(); }\r\n\r\n          // BUSDTREASURY is emptied, all unused balances are moved to MARKETING_ADDR\r\n        if (_donationDay == LAST_CONTRACT_DAY)\r\n        {\r\n            BUSDTREASURY = 0;\r\n            if (BUSD_TOKEN.balanceOf(address(this)) > 0) { uint256 amo = BUSD_TOKEN.balanceOf(address(this)); BUSD_TOKEN.transfer(MARKETING_ADDR, amo); }\r\n            if (address(this).balance > 0) { sendValue(payable(MARKETING_ADDR), address(this).balance); }\r\n        }\r\n\r\n        lastCheckedSupplyDay = lastCheckedSupplyDay.add(1);  // set the day checked\r\n\r\n        uint256 gasSpent = gasAtStart > gasleft() ? (gasAtStart - gasleft() + 21000) : 0; // calculate the \"gasSpent\"\r\n        uint256 refundBNB = gasSpent * tx.gasprice;                                       // calculate spent BNB\r\n        if (refundBNB > 5E16 && address(this).balance >= refundBNB) {                     // if msg.sender spent more than 0.05 BNB and if the money is available in the contract...\r\n            msg.sender.transfer(refundBNB);                                               // send it to the spender\r\n            emit GasRefunded(msg.sender, refundBNB);\r\n        }\r\n\r\n    }\r\n\r\n    /** @notice A function generating REX supply and setting the ratio (REX/BUSD) for that auction day\r\n      * @dev triggered by the dailyRoutines (once a day, with the first tx that day)\r\n      */\r\n    function _generateSupply(uint32 _donationDay)\r\n        private\r\n    {\r\n        if (dailyTotalDonation[_donationDay] > 0)\r\n        {\r\n            if (_donationDay == 1) { dailyGeneratedREX[_donationDay] = RX_DECIMALS.mul(DAY_ONE_SUPPLY); }\r\n            if (_donationDay == 2) { dailyGeneratedREX[_donationDay] = RX_DECIMALS.mul(DAY_TWO_SUPPLY); }\r\n            if (_donationDay >= 3 && _donationDay < DONATION_DAYS ) {\r\n                dailyGeneratedREX[_donationDay] = RX_DECIMALS.mul(DAY_THREE_SUPPLY.sub( (uint256(_donationDay).sub(3)).mul(DAILY_DIFF_SUPPLY) )); }\r\n            if (_donationDay == DONATION_DAYS) { dailyGeneratedREX[_donationDay] = RX_DECIMALS.mul(DAY_LAST_SUPPLY); }\r\n\r\n              // save generated amount in globals\r\n            g.totalGeneratedREX = g.totalGeneratedREX.add(dailyGeneratedREX[_donationDay]);\r\n            g.generatedDays++;\r\n\r\n              // set dailyRatio: Regard Donations and Referrals (everything counts for ratio calculation)\r\n            uint256 totalDonAndRef = dailyTotalDonation[_donationDay].add(dailyTotalReferral[_donationDay]);\r\n            uint256 ratio = dailyGeneratedREX[_donationDay].mul(HIGH_PRECISION).div(totalDonAndRef);\r\n            uint256 remainderCheck = dailyGeneratedREX[_donationDay].mul(HIGH_PRECISION).mod(totalDonAndRef);\r\n            dailyRatio[_donationDay] = remainderCheck == 0 ? ratio : ratio.add(1);\r\n\r\n            emit SupplyGenerated(_donationDay, dailyGeneratedREX[_donationDay]);\r\n        }\r\n        else\r\n        {\r\n            emit SupplyGenerated(_donationDay, uint256(0));\r\n        }\r\n\r\n    }\r\n\r\n    /** @notice Fill the liquidity pool on Pancakeswap V2 (BUSD from INITIAL_LIQ_BUSD and AUCTIONS) starting REX DAY 2\r\n      * @dev Function is called at the end of \"SupplyTrigger\" routines, after _generateSupplyAndCheckPools\r\n      * MAX 1000 BUSD shall be added per Tx to prevent from sandwich attacks\r\n      */\r\n    function _fillLiquidityPool()\r\n        private\r\n    {\r\n        if (_currentRxDay() > 1 && _currentRxDay() <= 250)   // on DAY 251 all BUSD in the contract are moved to TREASURY\r\n        {\r\n            uint256 totalAdd;   // to track that not more than 1000 BUSD are added in total\r\n\r\n              // STEP 1: INITIAL_LIQ_BUSD: add extra liquidity (if any), capped at 500 BUSD\r\n              // triggered only between REX DAY 3 and 203 (= 201 days), but on REX DAY 203 only check for a remainder\r\n            if (EXTRA_DAILY_LIQ > 0 && _currentRxDay() >= 3 && _currentRxDay() <= 203)\r\n            {\r\n                  // in case it is DAY 203 and the extraLiqBusdSent has not reached the FULL amount\r\n                  // or if it is before DAY 203 and the extraLiqBusdSent has not reached the DAILY amount: addLiquidity\r\n                if ( ( _currentRxDay() == 203 && extraLiqBusdSent < uint256(200).mul(EXTRA_DAILY_LIQ) ) ||\r\n                     ( _currentRxDay() < 203 && extraLiqBusdSent < uint256(_currentRxDay().sub(2)).mul(EXTRA_DAILY_LIQ)) )\r\n                {\r\n                        // \"EXTRA_DAILY_LIQ > 0\" means there must have been INITIAL_LIQ_BUSD and the reserves will already be > 0\r\n                    (uint256 reserveIn, uint256 reserveOut, ) = UNISWAP_PAIR.getReserves(); // reserveIn SHOULD be REX, may be BUSD\r\n\r\n                    uint256 _busdAmount;\r\n\r\n                    if (_currentRxDay() < 203)\r\n                    {\r\n                        _busdAmount = uint256(_currentRxDay().sub(2)).mul(EXTRA_DAILY_LIQ).sub(extraLiqBusdSent) > uint256(500E18)\r\n                            ? uint256(500E18)\r\n                            : uint256(_currentRxDay().sub(2)).mul(EXTRA_DAILY_LIQ).sub(extraLiqBusdSent);\r\n                    }\r\n                    else\r\n                    {\r\n                        _busdAmount = uint256(200).mul(EXTRA_DAILY_LIQ).sub(extraLiqBusdSent);\r\n                    }\r\n\r\n                    if (_busdAmount >= 1E18)  // skip if less than 1 BUSD would be added (PCS would fail)\r\n                    {\r\n                        uint256 _rexAmount = UNISWAP_PAIR.token0() == busd_address  // CreatePair() sometimes sets wrong token order\r\n                            ? _busdAmount.mul(reserveOut).div(reserveIn)            // BUSD to token0, sometimes BUSD to token1 - so it\r\n                            : _busdAmount.mul(reserveIn).div(reserveOut);           // must be checked to get the correct ratio\r\n\r\n                        REX_CONTRACT.mintSupply(address(this), _rexAmount);\r\n                        REX_CONTRACT.approve(address(UNISWAP_ROUTER), _rexAmount);\r\n                        BUSD_TOKEN.approve(address(UNISWAP_ROUTER), _busdAmount);\r\n\r\n                        (\r\n                            uint256 amountREX,\r\n                            uint256 amountBUSD,\r\n                        ) =\r\n\r\n                        UNISWAP_ROUTER.addLiquidity(\r\n                          address(REX_CONTRACT),\r\n                          busd_address,\r\n                          _rexAmount,\r\n                          _busdAmount,\r\n                          0,\r\n                          0,\r\n                          address(this),\r\n                          block.timestamp.add(2 hours)\r\n                        );\r\n\r\n                        extraLiqBusdSent = extraLiqBusdSent.add(amountBUSD);  // update \"extraLiqBusdSent\" with amountBUSD (not _busdAmount)\r\n                        totalAdd = amountBUSD;                                // update the total sent amount until now\r\n                        totalLpTokens = LP_TOKEN.balanceOf(address(this));    // update the total LP token amount (for later withdrawal by investors)\r\n\r\n                        emit LiquidityGenerated(_currentRxDay(), amountBUSD, amountREX);\r\n                    }\r\n                }\r\n            }\r\n\r\n              // STEP 2: add liquidity (BUSD received from AUCTIONS)\r\n              // capped at 500 BUSD (or up to 1000 if nothing has been sent in STEP 1 above)\r\n            if (toSendToPairBusd >= 500E18)\r\n            {\r\n                (uint256 reserveIn, uint256 reserveOut, ) = UNISWAP_PAIR.getReserves(); // reserveIn SHOULD be REX, may be BUSD\r\n\r\n                uint256 _busdAmount = toSendToPairBusd > uint256(1000E18).sub(totalAdd)\r\n                    ? uint256(1000E18).sub(totalAdd)\r\n                    : toSendToPairBusd;\r\n\r\n                uint256 _rexAmount;\r\n\r\n                if (reserveIn == 0)   // if there are NO RESERVES yet, the start price has not been set before and has to be set NOW\r\n                {\r\n                    _rexAmount = _busdAmount.mul(INTIAL_REX_PRICE);\r\n                }\r\n                else                  // if there ARE reserves, get the ratio - (reserveIn and reservwOut cannot be zero then)\r\n                {\r\n                    _rexAmount = UNISWAP_PAIR.token0() == busd_address      // CreatePair() sometimes sets wrong token order\r\n                        ? _busdAmount.mul(reserveOut).div(reserveIn)        // BUSD to token0, sometimes BUSD to token1 - so it\r\n                        : _busdAmount.mul(reserveIn).div(reserveOut);       // must be checked to get the correct ratio\r\n                }\r\n\r\n                REX_CONTRACT.mintSupply(address(this), _rexAmount);\r\n                REX_CONTRACT.approve(address(UNISWAP_ROUTER), _rexAmount);\r\n                BUSD_TOKEN.approve(address(UNISWAP_ROUTER), _busdAmount);\r\n\r\n                (\r\n                    uint256 amountREX,\r\n                    uint256 amountBUSD,\r\n                ) =\r\n\r\n                UNISWAP_ROUTER.addLiquidity(\r\n                  address(REX_CONTRACT),\r\n                  busd_address,\r\n                  _rexAmount,\r\n                  _busdAmount,\r\n                  0,\r\n                  0,\r\n                  address(0x0),\r\n                  block.timestamp.add(2 hours)\r\n                );\r\n\r\n                toSendToPairBusd = toSendToPairBusd.sub(amountBUSD);\r\n\r\n                emit LiquidityGenerated(_currentRxDay(), amountBUSD, amountREX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @notice Fill the liquidity pool on Pancakeswap V2 with initial liquidity, when day 1 has ended\r\n      * THIS creates the start PRICE of the PancakeSwap REX-BUSD pair (if there is any liquidity to be added).\r\n      * This initial LP provision is capped to 100k BUSD. If it is more, it will be added daily to PCS (1/200 for 200 days)\r\n      * The LP tokens are sent to this contract, can be fetched by liquidity providers after auction phase.\r\n      * (The REX needed to send to the PAIR are minted for FREE for the liquidity providers, based on the start price)\r\n      */\r\n    function _sendInitialLiquidityToPCS()\r\n        private\r\n    {\r\n        if (INITIAL_LIQ_BUSD > 0)       // sanity check\r\n        {\r\n            uint256 _startLiquidity;    // the amount of BUSD used to send as Initial Liquidity to the REX-BUSD pair on PCS\r\n\r\n            if (INITIAL_LIQ_BUSD > 100000E18)\r\n            {\r\n                _startLiquidity = uint256(100000E18);                               // cap at 100k BUSD\r\n                EXTRA_DAILY_LIQ = INITIAL_LIQ_BUSD.sub(_startLiquidity).div(200);   // set the daily EXTRA_DAILY_LIQ\r\n            }\r\n            else\r\n            {\r\n                _startLiquidity = INITIAL_LIQ_BUSD;\r\n            }\r\n\r\n            uint256 _rexAmount = _startLiquidity.mul(INTIAL_REX_PRICE);     // amount REX = BUSD * (REX/BUSD)\r\n\r\n            REX_CONTRACT.mintSupply(address(this), _rexAmount);             // mint those needed REX\r\n            REX_CONTRACT.approve(address(UNISWAP_ROUTER), _rexAmount);      // allow ROUTER to withdraw REX from here\r\n            BUSD_TOKEN.approve(address(UNISWAP_ROUTER), _startLiquidity);   // allow ROUTER to withdraw BUSD from here\r\n\r\n            (\r\n                uint256 amountREX,\r\n                uint256 amountBUSD,\r\n            ) =\r\n\r\n            UNISWAP_ROUTER.addLiquidity(\r\n              address(REX_CONTRACT),\r\n              busd_address,\r\n              _rexAmount,\r\n              _startLiquidity,\r\n              0,\r\n              0,\r\n              address(this),\r\n              block.timestamp.add(2 hours)\r\n            );\r\n\r\n              // save the received total LP token amount (for later withdrawal by investors)\r\n            totalLpTokens = LP_TOKEN.balanceOf(address(this));\r\n\r\n            emit LiquidityGenerated(0, amountBUSD, amountREX);\r\n        }\r\n    }\r\n\r\n    function _getRandomNumber(uint256 ceiling)\r\n        private view returns (uint256)\r\n    {\r\n        if (ceiling > 0) {\r\n            uint256 val = uint256(blockhash(block.number - 1)) * uint256(block.timestamp) + (block.difficulty);\r\n            val = val % uint(ceiling);\r\n            return val;\r\n        }\r\n        else return 0;\r\n    }\r\n\r\n    function _getAnotherRandomNumber(uint256 ceiling)\r\n        private view returns (uint256)\r\n    {\r\n        if (ceiling > 0) {\r\n            uint256 val = uint256(blockhash(block.number - 1)) * (block.difficulty) + uint256(block.timestamp);\r\n            val = val % uint(ceiling);\r\n            return val;\r\n        }\r\n        else return 0;\r\n    }\r\n\r\n    function isBPDeligibleAddr(\r\n        address _userAddress\r\n    )\r\n        public view\r\n        returns(bool)\r\n    {\r\n        if(userAddressesBPD.length == 0) return false;\r\n        return (userAddressesBPD[userIndicesBPD[_userAddress]] == _userAddress);\r\n    }\r\n\r\n    /** @notice Adds an address to the BigPayDay list at random position\r\n      * @dev triggered from claimStakeFromDonations\r\n      */\r\n    function _addEligibleAddr(\r\n        address _userAddress\r\n    )\r\n        private\r\n    {\r\n\r\n        if(!isBPDeligibleAddr(_userAddress))      // if not in list, add to list / array\r\n        {\r\n            if(userAddressesBPD.length < 6)   // first 5 addresses are just added chronically, then inserted randomly\r\n            {\r\n                userAddressesBPD.push(_userAddress);\r\n                userIndicesBPD[_userAddress] = userAddressesBPD.length - 1;\r\n            }\r\n            else\r\n            {\r\n                uint256 _pos = _getRandomNumber(userAddressesBPD.length - 1); // leave out \"userAddressesBPD.length\" as target, so relocation (in the next step) will work\r\n                userAddressesBPD.push(userAddressesBPD[_pos]);                // relocate address from _pos to userAddressesBPD.length\r\n                userIndicesBPD[userAddressesBPD[_pos]] = userAddressesBPD.length - 1;  // save its index\r\n                userAddressesBPD[_pos] = _userAddress;                        // save _userAddress (at _pos)\r\n                userIndicesBPD[_userAddress] = _pos;                          // save index of _userAddress (at _pos)\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @notice Removes an address to the BigPayDay list forever\r\n      * @dev triggered from claimRexFromDonations\r\n      */\r\n    function _removeEligibleAddr(\r\n        address _userAddress\r\n    )\r\n        private\r\n    {\r\n        addressBPDExcluded[_userAddress] = true;\r\n\r\n        if(isBPDeligibleAddr(_userAddress))\r\n        {\r\n            uint256 indexToDelete = userIndicesBPD[_userAddress];\r\n            address addressToMove = userAddressesBPD[userAddressesBPD.length-1];\r\n            userAddressesBPD[indexToDelete] = addressToMove;\r\n            userIndicesBPD[addressToMove] = indexToDelete;\r\n            userIndicesBPD[_userAddress] = 0;\r\n            userAddressesBPD.pop();\r\n        }\r\n    }\r\n\r\n    /** @notice A function to (constantly) mix the list BPD participants\r\n      */\r\n    function _shuffleBPDlist()\r\n        private\r\n    {\r\n        if (userAddressesBPD.length > 6 && _currentRxDay() < LAST_CLAIM_DAY)\r\n        {\r\n              // mix two random addresses (at _posA and _posB)\r\n            uint256 _posA = _getRandomNumber(userAddressesBPD.length);\r\n            uint256 _posB = _getAnotherRandomNumber(userAddressesBPD.length);\r\n\r\n            if (_posA != _posB) {\r\n                address _addrA = userAddressesBPD[_posA];   // get and save address of A\r\n                address _addrB = userAddressesBPD[_posB];   // get and save address of B\r\n                userIndicesBPD[_addrA] = _posB;             // write index of B to A\r\n                userIndicesBPD[_addrB] = _posA;             // write index of A to B\r\n                userAddressesBPD[_posA] = _addrB;           // write B to A's Index\r\n                userAddressesBPD[_posB] = _addrA;           // write A to B's Index\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @notice An external function to check the number of addresses that are eligible for BPD\r\n      */\r\n    function getBPDCount()\r\n        external view\r\n        returns(uint256)\r\n    {\r\n        return userAddressesBPD.length;\r\n    }\r\n\r\n    /** @notice An external function to distribute claimable BUSD to (up to 222) BPD winners (\"UserCreatedBigPayDay\")\r\n      */\r\n    function _createUserBPD()\r\n        external\r\n    {\r\n        require ( BUSDPOOL > 50000E18, 'REX: Pool too small.');\r\n        require ( poolWasntEmpty, 'REX: Pool was empty.');\r\n\r\n        _createBPD(222);\r\n    }\r\n\r\n    /** @notice A private function to distribute claimable BUSD to BPD winners\r\n      * Triggered by dailyRoutine (and maybe by users, see function above)\r\n      * Emits \"DistributedBigPayDay\" even if no BUSD were to be distributed\r\n      * @param _maxBpd Maximum number of distributed BigPayDays\r\n      */\r\n    function _createBPD(uint256 _maxBpd)\r\n        private\r\n    {\r\n        if (userAddressesBPD.length > 0)          // only run, if there are any addresses for BPD\r\n        {\r\n            address who;                          // the address to look up for BPD\r\n            uint256 maxBUSDtoClaim;               // the claimableAmount per address\r\n            uint256 busdPoolStart = BUSDPOOL;     // track the POOL at start and end, for the event\r\n            uint256 busdPoolTemp = BUSDPOOL;      // use a memory variable to count down BUSDPOOL (and not storage) in the loop\r\n            uint256 todaysNumOfBPD;               // count todays BigPayDays for the event\r\n            uint256 minNumOfBPD =                 // distribute minimum 50 BPDs\r\n                userAddressesBPD.length < 50      // (unless there are less than 50 participants -\r\n                    ? userAddressesBPD.length     // then use number of participants)\r\n                    : uint256(50);\r\n            uint256 maxNumOfBPD =                 // the max number of BigPayDays shall be limited due to gas cost\r\n                userAddressesBPD.length > _maxBpd\r\n                ? _maxBpd\r\n                : userAddressesBPD.length;\r\n\r\n            if (g.generatedBigPayDays.mod(2) == 0)    // on even rounds: distribute from array start -> end\r\n            {\r\n                for (uint256 i = 0; i < maxNumOfBPD; i++)\r\n                {\r\n                    if (busdPoolTemp > 0)\r\n                    {\r\n                        who = userAddressesBPD[i];                              // get address\r\n                        maxBUSDtoClaim = originalDonation[who];                 // get total donated BUSD of address\r\n                        maxBUSDtoClaim =                                        // limit maxBUSDtoClaim, depending on No of participants\r\n                            maxBUSDtoClaim > busdPoolStart.div(minNumOfBPD)\r\n                                ? busdPoolStart.div(minNumOfBPD)\r\n                                : maxBUSDtoClaim;\r\n                        maxBUSDtoClaim =\r\n                            maxBUSDtoClaim > busdPoolTemp                       // cap at BUSDPOOL\r\n                                ? busdPoolTemp\r\n                                : maxBUSDtoClaim;\r\n                        busdPoolTemp = busdPoolTemp.sub(maxBUSDtoClaim);        // reduce POOL\r\n                        randomBUSD[who] = randomBUSD[who].add(maxBUSDtoClaim);  // assign to address\r\n                        todaysNumOfBPD++;                                       // count BPD\r\n\r\n                        if (!addressHitByRandom[who]) {                         // track and count the hit address\r\n                            addressHitByRandom[who] = true;                     // to exclude from TREASURY opening\r\n                            sumOfDonationsOfUnHit = sumOfDonationsOfUnHit.sub(originalDonation[who]); // subtract amount of former donations from the sum (for treasury calculations)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else                  // on odd rounds: distribute from array end -> start\r\n            {\r\n                for (uint256 i = maxNumOfBPD; i > 0; i--)\r\n                {\r\n                    if (busdPoolTemp > 0)\r\n                    {\r\n                        who = userAddressesBPD[i-1];                            // get an address\r\n                        maxBUSDtoClaim = originalDonation[who];                 // get total donated BUSD of address\r\n                        maxBUSDtoClaim =                                        // limit maxBUSDtoClaim, depending on No of participants\r\n                            maxBUSDtoClaim > busdPoolStart.div(minNumOfBPD)\r\n                                ? busdPoolStart.div(minNumOfBPD)\r\n                                : maxBUSDtoClaim;\r\n                        maxBUSDtoClaim =\r\n                            maxBUSDtoClaim > busdPoolTemp                       // cap at BUSDPOOL\r\n                                ? busdPoolTemp\r\n                                : maxBUSDtoClaim;\r\n                        busdPoolTemp = busdPoolTemp.sub(maxBUSDtoClaim);        // reduce POOL\r\n                        randomBUSD[who] = randomBUSD[who].add(maxBUSDtoClaim);  // assign to address\r\n                        todaysNumOfBPD++;                                       // count BPD\r\n\r\n                        if (!addressHitByRandom[who]) {                         // track and count the hit address\r\n                            addressHitByRandom[who] = true;                     // to exclude from TREASURY opening\r\n                            sumOfDonationsOfUnHit = sumOfDonationsOfUnHit.sub(originalDonation[who]); // subtract amount of former donations from the sum (for treasury calculations)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            BUSDPOOL = busdPoolTemp;\r\n            poolWasntEmpty = BUSDPOOL > 5000E18;   // set a flag if more than 5000 BUSD left, so users CAN or CANNOT trigger BigPayDays manually\r\n            g.generatedBigPayDays++;\r\n            emit DistributedBigPayDay(g.generatedBigPayDays, maxNumOfBPD, todaysNumOfBPD, busdPoolStart, BUSDPOOL);\r\n        }\r\n    }\r\n\r\n    /** @notice Allows a user to directly create a stake from the claimable REX from auction\r\n      * @dev Uses REX_CONTRACT instance to create a stakes there, qualifies for BigPayDay\r\n      * @return _payout Amount staked for the donators address (principal)\r\n      */\r\n    function claimStakeFromDonations(\r\n        uint32 _stakingDays\r\n    )\r\n        supplyTrigger\r\n        external\r\n        returns (uint256 _payout)\r\n    {\r\n        require(_currentRxDay() > 1, 'REX: Too early.');\r\n        require(_currentRxDay() <= LAST_CONTRACT_DAY, 'REX: Too late.');\r\n        require(_stakingDays >= DONATION_DAYS && _stakingDays <= 3653, 'REX: Stake duration not in range.');\r\n\r\n        uint32 lastClaimableDay = _currentRxDay().sub(1);   // only past days claimable\r\n        if (lastClaimableDay > DONATION_DAYS) { lastClaimableDay = DONATION_DAYS; }\r\n\r\n        for (uint32 i = 1; i <= lastClaimableDay; i++) {\r\n            if (!donatorBalancesDrawn[msg.sender][i]) {\r\n                donatorBalancesDrawn[msg.sender][i] = true;\r\n                _payout += donatorBalances[msg.sender][i].mul(dailyRatio[i]).div(HIGH_PRECISION);\r\n            }\r\n        }\r\n\r\n        if (_payout > 0) {\r\n            if(!addressBPDExcluded[msg.sender]) { _addEligibleAddr(msg.sender); }\r\n            g.totalClaimedDonationREX = g.totalClaimedDonationREX.add(_payout);\r\n            donatorTotalRexReceived[msg.sender] = donatorTotalRexReceived[msg.sender].add(_payout);\r\n            REX_CONTRACT.createStake(msg.sender, _payout, _stakingDays, unicode'0', true);\r\n            emit ClaimedStakeFromAuctions(msg.sender, _payout);\r\n        }\r\n    }\r\n\r\n    /** @notice Allows to mint tokens for specific donator address\r\n      * @dev aggregates donators tokens across all donation days\r\n      * and uses REX_CONTRACT instance to mint all the REX tokens\r\n      * disqualifies from BigPayDays forever\r\n      * @return _payout amount minted to the donators address\r\n      */\r\n    function claimRexFromDonations()\r\n        supplyTrigger\r\n        external\r\n        returns (uint256 _payout)\r\n    {\r\n        require(_currentRxDay() > 1, 'REX: Too early.');\r\n        require(_currentRxDay() <= LAST_CONTRACT_DAY, 'REX: Too late.');\r\n\r\n        uint32 lastClaimableDay = _currentRxDay().sub(1);                           // only past days claimable\r\n        if (lastClaimableDay > DONATION_DAYS) { lastClaimableDay = DONATION_DAYS; } // max. 222 days\r\n\r\n        for (uint32 i = 1; i <= lastClaimableDay; i++) {                            // sum up all donations for payout\r\n            if (!donatorBalancesDrawn[msg.sender][i]) {                             // check if already withdrawn\r\n                donatorBalancesDrawn[msg.sender][i] = true;                         // set withdrawn to true\r\n                _payout += donatorBalances[msg.sender][i].mul(dailyRatio[i]).div(HIGH_PRECISION);  // count for payout\r\n            }\r\n        }\r\n\r\n        if (_payout > 0) {\r\n            if(!addressBPDExcluded[msg.sender]) { _removeEligibleAddr(msg.sender); }  // exclude address from BigPayDays FOREVER\r\n            g.totalClaimedDonationREX = g.totalClaimedDonationREX.add(_payout);\r\n            donatorTotalRexReceived[msg.sender] = donatorTotalRexReceived[msg.sender].add(_payout);\r\n            REX_CONTRACT.mintSupply(msg.sender, _payout);\r\n            emit ClaimedRexFromAuctions(msg.sender, _payout);\r\n        }\r\n    }\r\n\r\n    /** @notice Allows to mint tokens for specific referrer address\r\n      * @dev aggregates referrer tokens across all donation days\r\n      * and uses REX_CONTRACT instance to mint all the REX tokens\r\n      * @return _payout amount minted to the donators address\r\n      */\r\n    function claimRexFromReferrals()\r\n        supplyTrigger\r\n        external\r\n        returns (uint256 _payout)\r\n    {\r\n        require(_currentRxDay() > 1, 'REX: Too early.');\r\n        require(_currentRxDay() <= LAST_CONTRACT_DAY, 'REX: Too late.');\r\n        uint32 lastClaimableDay = _currentRxDay() - 1; // only past days\r\n        if (lastClaimableDay > DONATION_DAYS) { lastClaimableDay = DONATION_DAYS; } // max. 222 days\r\n        for (uint32 i = 1; i <= lastClaimableDay; i++) {\r\n            if (!referrerBalancesDrawn[msg.sender][i]) {\r\n                referrerBalancesDrawn[msg.sender][i] = true;\r\n                _payout += referrerBalances[msg.sender][i].mul(dailyRatio[i]).div(HIGH_PRECISION);\r\n            }\r\n        }\r\n        if (_payout > 0) {\r\n            g.totalClaimedReferralREX = g.totalClaimedReferralREX.add(_payout);\r\n            REX_CONTRACT.mintSupply(msg.sender, _payout);\r\n            emit ClaimedRexFromReferrals(msg.sender, _payout);\r\n        }\r\n    }\r\n\r\n    /** @notice Allows to claim BUSD for specific referrer address, allow low amount claims for TREX holders\r\n      * @return claimed Amount that has been claimed\r\n      */\r\n    function claimBusdFromReferrals()\r\n        supplyTrigger\r\n        external\r\n        returns (uint256 claimed)\r\n    {\r\n        require(_currentRxDay() <= LAST_CLAIM_DAY, 'REX: Too late to claim');     // day 250 is last BUSD claiming day\r\n        claimed = referralBUSD[msg.sender];                                       // get amount\r\n        require(claimed > 0, 'REX: No BUSD to to claim');                         // check for zero balance\r\n        referralBUSD[msg.sender] = 0;                                             // reset to zero\r\n        g.totalClaimedReferralBUSD = g.totalClaimedReferralBUSD.add(claimed);     // add to totalClaimed\r\n        BUSD_TOKEN.transfer(msg.sender, claimed);                                 // move BUSD to Referrer\r\n        emit ClaimedBusdFromReferrals(msg.sender, claimed);\r\n    }\r\n\r\n    /** @notice Allows an address to claim all its BUSD from \"randomBUSD\"\r\n      * @return claimed Amount that has been claimed successfully\r\n      */\r\n    function claimBusdFromBPD()\r\n        supplyTrigger\r\n        external\r\n        returns (uint256 claimed)\r\n    {\r\n        require(_currentRxDay() <= LAST_CLAIM_DAY, 'REX: Too late to claim.');  // day 250 is last BUSD claiming day\r\n        require(randomBUSD[msg.sender] > 0, 'REX: No BUSD to claim.');       // check positive balance\r\n        claimed = randomBUSD[msg.sender];                                       // get amount\r\n        randomBUSD[msg.sender] = 0;                                             // reset to zero\r\n        g.totalClaimedRandomBUSD = g.totalClaimedRandomBUSD.add(claimed);       // add to totalClaimed\r\n        BUSD_TOKEN.transfer(msg.sender, claimed);                               // move BUSD\r\n        emit ClaimedBusdFromBPD(msg.sender, claimed);\r\n    }\r\n\r\n    /** @notice Allows to claim BUSD from BUSDTREASURY for specific referrer address\r\n      * @return claimed Amount that has been claimed\r\n      */\r\n    function claimBusdFromTREASURY()\r\n        supplyTrigger\r\n        external\r\n        returns (uint256 claimed)\r\n    {\r\n        require(_currentRxDay() >= TREASURY_CLAIM_DAY, 'REX: Too early to claim'); // day 252 is first BUSD claiming day\r\n        require(_currentRxDay() < LAST_CONTRACT_DAY, 'REX: Too late to claim');    // day 258 is last BUSD claiming day\r\n        require(!addressHitByRandom[msg.sender], 'REX: Already hit by random');    // check address eligibility\r\n        require(BUSDTREASURY > 0, 'REX: TREASURY is empty');                       // sanity check\r\n        claimed = originalDonation[msg.sender].mul(treasuryRatio).div(1E10); // calculate payable claim amount\r\n        if (claimed > BUSDTREASURY) { claimed = BUSDTREASURY; }                       // sanity check\r\n        require(claimed > 0, 'REX: Nothing to claim.');                               // revert if 0\r\n        addressHitByRandom[msg.sender] = true;                                        // avoid double claiming / reentrancy\r\n        BUSDTREASURY = BUSDTREASURY.sub(claimed);                                     // deduct from POOL\r\n        BUSD_TOKEN.transfer(msg.sender, claimed);                                     // move BUSD\r\n    }\r\n\r\n    /** @notice Sets ratio for BUSDTREASURY with 1E10 precision, called on day 251 by DailyRoutine\r\n      * @dev Ratio equals BUSDTREASURY divided by sumOfDonationsOfUnHit\r\n      */\r\n    function _setTreasuryRatio()\r\n        private\r\n    {\r\n        BUSDPOOL = 0;                                         // reset pools :: no more claiming from pools\r\n        BUSDTREASURY = BUSD_TOKEN.balanceOf(address(this));   // put the whole BUSD balance into TREASURY\r\n\r\n        if (sumOfDonationsOfUnHit > 0) {\r\n            treasuryRatio = BUSDTREASURY.mul(1E10).div(sumOfDonationsOfUnHit);\r\n        }\r\n        else {\r\n            treasuryRatio = 0;\r\n        }\r\n        emit TreasuryGenerated(BUSDTREASURY, treasuryRatio);\r\n    }\r\n\r\n\r\n    // CLAIMABLES check functions\r\n\r\n    /** @notice Checks for callers claimable REX from donations\r\n      * @return _payout Total REX claimable\r\n      */\r\n    function myClaimableRexFromDonations(address who)\r\n        external\r\n        view\r\n        returns (uint256 _payout)\r\n    {\r\n        if (_currentRxDay() > 1 && _currentRxDay() <= LAST_CONTRACT_DAY)\r\n        {\r\n            uint32 lastClaimableDay = _currentRxDay() - 1;                                // only past days\r\n            if (lastClaimableDay > DONATION_DAYS) { lastClaimableDay = DONATION_DAYS; }   // limited to DONATION_DAYS\r\n            for (uint32 i = 1; i <= lastClaimableDay; i++) {\r\n                if (!donatorBalancesDrawn[who][i]) {\r\n                    _payout += donatorBalances[who][i].mul(dailyRatio[i]).div(HIGH_PRECISION);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @notice Checks for callers claimable REX from referrals\r\n      * @return _payout Total REX claimable\r\n      */\r\n    function myClaimableRexFromReferrals(address who)\r\n        external\r\n        view\r\n        returns (uint256 _payout)\r\n    {\r\n        if (_currentRxDay() > 1 && _currentRxDay() <= LAST_CONTRACT_DAY)\r\n        {\r\n            uint32 lastClaimableDay = _currentRxDay() - 1; // only past days\r\n            if (lastClaimableDay > DONATION_DAYS) { lastClaimableDay = DONATION_DAYS; }\r\n            for (uint32 i = 1; i <= lastClaimableDay; i++) {\r\n                if (!referrerBalancesDrawn[who][i]) {\r\n                    _payout += referrerBalances[who][i].mul(dailyRatio[i]).div(HIGH_PRECISION);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @notice Checks for number of BPD eligible addresses unhit by BigPayDay ( = TREASURY eligible addresses)\r\n      * @dev Will not deliver a return value for some 10,000 eligible addresses (gas), but not a problem\r\n      * @return unhit Number of not hit addresses (BigPayDay)\r\n      */\r\n    function getActualUnhitByRandom() external view returns (uint256 unhit) {\r\n        for (uint256 i = 0; i < userAddressesBPD.length; i++) {\r\n            if (!addressHitByRandom[userAddressesBPD[i]]) { unhit++; }\r\n        }\r\n    }\r\n\r\n    /** @notice Checks for REX that will be generated on current day\r\n      * @return REX amount\r\n      */\r\n    function auctionSupplyOnDay(uint32 _donationDay) external pure returns (uint256) {\r\n        if (_donationDay == 1) { return RX_DECIMALS.mul(DAY_ONE_SUPPLY); }\r\n        if (_donationDay == 2) { return RX_DECIMALS.mul(DAY_TWO_SUPPLY); }\r\n        if (_donationDay >= 3 && _donationDay < DONATION_DAYS ) {\r\n            return RX_DECIMALS.mul(DAY_THREE_SUPPLY.sub( (uint256(_donationDay).sub(3)).mul(DAILY_DIFF_SUPPLY) )); }\r\n        if (_donationDay == DONATION_DAYS) { return RX_DECIMALS.mul(DAY_LAST_SUPPLY); }\r\n        return 0;\r\n    }\r\n\r\n    function auctionStatsOfDay(uint32 _donationDay) external view returns (uint256[4] memory _stats) {\r\n        _stats[0] = dailyGeneratedREX[_donationDay];\r\n        _stats[1] = dailyTotalDonation[_donationDay] + dailyTotalReferral[_donationDay];\r\n        _stats[2] = donatorAccountCount[_donationDay];\r\n        _stats[3] = dailyRatio[_donationDay];\r\n    }\r\n\r\n    /** @notice Shows current day of RexToken\r\n      * @dev Fetched from REX_CONTRACT\r\n      * @return Iteration day since REX inception\r\n      */\r\n    function _currentRxDay() public view returns (uint32) {\r\n        return REX_CONTRACT.currentRxDay();\r\n    }\r\n\r\n    function _notContract(address _addr) internal view returns (bool) {\r\n        uint32 size; assembly { size := extcodesize(_addr) } return (size == 0); }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        (bool success, ) = recipient.call{value: amount}(''); require(success, 'Address: Failed to send value'); }\r\n\r\n    /** @notice A function allowing WITHDRAWING any tokens from the contract AFTER the contract has ended\r\n      * For example: BNB that the GAS_REFUNDER has sent for GAS_REFUND or tokens that have accidentially been sent to the contract\r\n      * @param token The token's address to withdraw (LP_TOKEN withdraws are forbidden)\r\n      */\r\n    function withdrawTokensAfterContractEnd(address token)\r\n        external\r\n    {\r\n        require(_currentRxDay() > LAST_CONTRACT_DAY, 'RDA: Too early.');\r\n        require(msg.sender == GAS_REFUNDER, 'REX: Not allowed.');         // only the GAS_REFUNDER may withdraw tokens\r\n        require(token != address(LP_TOKEN), 'REX: Not allowed.');         // LP_TOKENs are not allowed to be withdrawn\r\n\r\n        IBEP20 Token = IBEP20(token);\r\n        if ( Token.balanceOf(address(this)) > 0 )\r\n        {\r\n            uint256 amo = Token.balanceOf(address(this));\r\n            Token.transfer(MARKETING_ADDR, amo);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary RexSafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'REX: addition overflow');\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, 'REX: subtraction overflow');\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, 'REX: multiplication overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, 'REX: division by zero');\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, 'REX: modulo by zero');\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary RexSafeMath32 {\r\n\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        require(c >= a, 'REX: addition overflow');\r\n        return c;\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b <= a, 'REX: subtraction overflow');\r\n        uint32 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 c = a * b;\r\n        require(c / a == b, 'REX: multiplication overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b > 0, 'REX: division by zero');\r\n        uint32 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b != 0, 'REX: modulo by zero');\r\n        return a % b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedBusdFromBPD\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedBusdFromReferrals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedRexFromAuctions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedRexFromReferrals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedStakeFromAuctions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"participants\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivers\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolSizeStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolSizeEnd\",\"type\":\"uint256\"}],\"name\":\"DistributedBigPayDay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"donationDay\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonationReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refundedAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundedBNB\",\"type\":\"uint256\"}],\"name\":\"GasRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLpTokens\",\"type\":\"uint256\"}],\"name\":\"LPtokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"day\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rexAmount\",\"type\":\"uint256\"}],\"name\":\"LiquidityGenerated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"}],\"name\":\"LiquidityReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"donator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferralAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"donationDay\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"generatedREX\",\"type\":\"uint256\"}],\"name\":\"SupplyGenerated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treasury\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"TreasuryGenerated\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BUSDPOOL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSDTREASURY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSD_TOKEN\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXTRA_DAILY_LIQ\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GAS_REFUNDER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_LIQ_BUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP_TOKEN\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MREX_TOKEN\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REX_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IREXToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_DEFINER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREX_TOKEN\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_PAIR\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_createUserBPD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_currentRxDay\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressBPDExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressHitByRandom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_donationDay\",\"type\":\"uint32\"}],\"name\":\"auctionStatsOfDay\",\"outputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"_stats\",\"type\":\"uint256[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_donationDay\",\"type\":\"uint32\"}],\"name\":\"auctionSupplyOnDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBusdFromBPD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBusdFromReferrals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBusdFromTREASURY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRexFromDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRexFromReferrals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_stakingDays\",\"type\":\"uint32\"}],\"name\":\"claimStakeFromDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"dailyGeneratedREX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"dailyRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"dailyTotalDonation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"dailyTotalReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_busd_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"donateBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"donatorAccountCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"donatorBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"donatorBalancesDrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"donatorTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"donatorTotalRexReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraLiqBusdSent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"g\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"generatedDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"generatedBigPayDays\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"totalDonatedBUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalGeneratedREX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimedDonationREX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimedReferralREX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimedReferralBUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimedRandomBUSD\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActualUnhitByRandom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unhit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBPDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rex\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trex\",\"type\":\"address\"}],\"name\":\"initContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"isBPDeligibleAddr\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCheckedSupplyDay\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityBalancesDrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"myClaimableRexFromDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"myClaimableRexFromReferrals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_payout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"originalDonation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolWasntEmpty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"randomBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referralBUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"referrerBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"referrerBalancesDrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_busd_amount\",\"type\":\"uint256\"}],\"name\":\"sendLiquidityBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sumOfDonationsOfUnHit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toSendToPairBusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLpTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerDailyRoutineOneDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniqueDonatorCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uniqueDonators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniqueReferrerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uniqueReferrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLPTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpTokensPayout\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawTokensAfterContractEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"withdrawableLPTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpTokenPayout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RexDailyAuction", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://21802f7fc03a5b1a1e309523f8f08e472cae69430928219c6b2716b4c57e566e"}