{"SourceCode": "// SPDX-License-Identifier: MIT \r\npragma solidity >=0.4.22 <0.9.0;\r\n\r\ncontract Factory {\r\n\tusing SafeMath for uint256;\r\n\r\n    string public name = \"Dappy Factory\";\r\n\r\n    uint256 constant public ADMIN_FEE        = 20;  //2%\r\n\tuint256 constant public PERCENTS_DIVIDER = 1000;\r\n\tuint256 constant public TIME_STEP = 1 days;\r\n\r\n    uint256 public DEPOSIT_MIN_AMOUNT;\r\n    uint256 public DEPOSIT_MAX_AMOUNT;\r\n    uint256 public PUBLISH_FEE;\r\n\r\n\tstruct Investor {\r\n        uint256 principle;\r\n        uint256 position;\r\n\t\tuint256 checkpoint;\r\n        uint256 withdrawn;\r\n        uint256 overdraw;\r\n\t}\r\n\r\n    struct Dappy {\r\n        address owner;\r\n        uint256 start;\r\n        uint256 hedge;\r\n        uint256 rate;\r\n        uint256 ownerFee;\r\n        string title;\r\n        string description;\r\n        string accent;\r\n        bool theme;\r\n    }\r\n\r\n    Dappy[] internal dappys;\r\n\r\n    mapping(uint256 => mapping(address => Investor)) private investors;\r\n    mapping(uint256 => mapping(address => uint256)) private allowances;\r\n    mapping(uint256 => uint256) private balances;\r\n    mapping(address => uint256) private discounts;\r\n\r\n    address payable public admin;\r\n\r\n\r\n    constructor(uint256 networkMinimum) {\r\n        //set admin\r\n        admin = payable(msg.sender);\r\n\r\n        //set discount\r\n        setDiscount(admin, 1000);\r\n\r\n        //calibrate for destination network\r\n        DEPOSIT_MIN_AMOUNT = networkMinimum;\r\n        DEPOSIT_MAX_AMOUNT = DEPOSIT_MIN_AMOUNT.mul(1000);\r\n        PUBLISH_FEE        = DEPOSIT_MIN_AMOUNT.mul(2000);\r\n    }\r\n\r\n    modifier exists(uint256 atIndex) {\r\n        require(atIndex < dappys.length, \"Dappy at index does not exist.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner(uint256 atIndex) {\r\n        require(getDappy(atIndex).owner == msg.sender, \"Not authorized.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Not authorized.\");\r\n        _;\r\n    }\r\n\r\n    function publish(\r\n        uint256 start,\r\n        uint256 hedge,\r\n        uint256 rate,\r\n        uint256 fee,\r\n        string memory title,\r\n        string memory description,\r\n        string memory accent,\r\n        bool theme \r\n    ) \r\n        public\r\n        payable\r\n    {\r\n        //validate fee\r\n        uint256 publishFee = getPublishFee(msg.sender);\r\n\r\n        //validate payment\r\n        require(msg.value == publishFee, \"Incorrect publish fee paid.\");\r\n\r\n        //validate parameters\r\n        require(start >= block.timestamp, \"Invalid parameter: start (start cannot be < now).\");\r\n        require(hedge >= 510,  \"Invalid parameter: hedge (minimum is 510).\");\r\n        require(hedge <= 1000, \"Invalid parameter: hedge (maximum is 1000).\");\r\n        require(rate  >= 1,    \"Invalid parameter: rate  (minimum is 1).\");\r\n        require(rate  <= 50,   \"Invalid parameter: rate  (maximum is 50).\");\r\n        require(fee   >= 1,    \"Invalid parameter: fee   (minimum is 0).\");\r\n        require(fee   <= 50,   \"Invalid parameter: fee   (maximum is 50).\");\r\n\r\n        //pay admin\r\n        admin.transfer(publishFee);\r\n\r\n        //publish dappy\r\n        dappys.push(Dappy(msg.sender, start, hedge, rate, fee, title, description, accent, theme));\r\n    }\r\n\r\n    function invest(uint256 atIndex) public payable exists(atIndex) {\r\n\t\trequire(msg.value >= DEPOSIT_MIN_AMOUNT, \"Minimum deposit amount is 0.01\");\r\n\t\trequire(msg.value <= DEPOSIT_MAX_AMOUNT, \"Maximum deposit amount is 1000\");\r\n\r\n        //if outstanding rewards\r\n        uint256 rewards = calculateRewards(atIndex, msg.sender);\r\n        if(rewards > 0) { compound(atIndex); }\r\n\r\n        //dappy ref\r\n        Dappy memory dappy = getDappy(atIndex);\r\n\r\n        //owner fee\r\n        uint256 fee1 = msg.value.mul(dappy.ownerFee).div(PERCENTS_DIVIDER);\r\n        address payable owner = payable(dappy.owner);\r\n        owner.transfer(fee1);\r\n\r\n        //admin fee\r\n        uint256 fee2 = msg.value.mul(ADMIN_FEE).div(PERCENTS_DIVIDER);\r\n        admin.transfer(fee2);\r\n\r\n        //deposit amount\r\n        uint256 NETamount = msg.value.sub(fee1).sub(fee2); \r\n\r\n        //investor\r\n        Investor storage investor = investors[atIndex][msg.sender];\r\n        investor.principle = investor.principle.add(NETamount);\r\n        investor.position  = investor.position.add(NETamount);\r\n        investor.checkpoint= block.timestamp;\r\n\r\n        //balances\r\n        balances[atIndex] = balances[atIndex].add(NETamount);\r\n\r\n        //allowances\r\n        uint256 hedgeAmount = NETamount.mul(dappy.hedge).div(PERCENTS_DIVIDER);\r\n        uint256 newAllowance= getAllowance(atIndex, owner).add(NETamount.sub(hedgeAmount));\r\n        setAllowance(atIndex, owner, newAllowance);\r\n    }\r\n\r\n    function compound(uint256 atIndex) public exists(atIndex) {\r\n        //get rewards\r\n        uint256 rewards = calculateRewards(atIndex, msg.sender);\r\n        require(rewards > 0, \"No rewards.\");\r\n\r\n        //investor\r\n        Investor storage investor = investors[atIndex][msg.sender];\r\n        investor.position = investor.position.add(rewards);\r\n        investor.checkpoint = block.timestamp;\r\n\r\n        //dappy ref\r\n        Dappy memory dappy = getDappy(atIndex);\r\n\r\n        //overdraw\r\n        if(investor.withdrawn < investor.principle) {\r\n            investor.overdraw = investor.overdraw > 0 ? investor.overdraw.sub(dappy.rate.div(10)) : 0;\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 atIndex) public exists(atIndex) {\r\n        //get rewards\r\n        uint256 rewards = calculateRewards(atIndex, msg.sender);\r\n        require(rewards > 0, \"No rewards.\");\r\n\r\n        //balance?\r\n        if(rewards > balances[atIndex]) {\r\n           rewards = balances[atIndex]; \r\n        }\r\n\r\n        //admin fee\r\n        uint256 fee = rewards.mul(ADMIN_FEE).div(PERCENTS_DIVIDER);\r\n        admin.transfer(fee);\r\n\r\n        //rewards amount\r\n        uint256 NETamount = rewards.sub(fee);\r\n\r\n        //investor\r\n        Investor storage investor = investors[atIndex][msg.sender];\r\n        investor.checkpoint= block.timestamp;\r\n        investor.withdrawn = investor.withdrawn.add(NETamount);\r\n\r\n        //dappy ref\r\n        Dappy memory dappy= getDappy(atIndex);\r\n\r\n        //overdraw\r\n        investor.overdraw = investor.overdraw < dappy.rate.sub(dappy.rate.div(10)) ? investor.overdraw.add(dappy.rate.div(10)) : investor.overdraw;\r\n\r\n        //balances\r\n        balances[atIndex] = balances[atIndex].sub(rewards);\r\n\r\n        //allowance\r\n        address owner       = dappy.owner;\r\n        uint256 hedgeAmount = NETamount.mul(dappy.hedge).div(PERCENTS_DIVIDER);\r\n        uint256 allowance   = getAllowance(atIndex, owner);\r\n\r\n        //workaround of subtraction overflow\r\n        if(allowance >= NETamount.sub(hedgeAmount)) {\r\n            allowance = allowance.sub(NETamount.sub(hedgeAmount));\r\n        } else {\r\n            allowance = 0;\r\n        }\r\n        setAllowance(atIndex, owner, allowance);\r\n\r\n        //transfer\r\n        payable(msg.sender).transfer(NETamount);\r\n    }\r\n\r\n    function calculateRewards(uint256 atIndex, address atAddress) public view exists(atIndex) returns (uint256 result) {\r\n        Dappy memory dappy = getDappy(atIndex);\r\n\r\n        //is started?\r\n        if(block.timestamp < dappy.start) return 0;\r\n\r\n        //if started? continue\r\n        Investor memory investor = getInvestor(atIndex, atAddress);\r\n        uint256 rate      = dappy.rate;\r\n        uint256 checkpoint= investor.checkpoint;\r\n        uint256 position  = investor.position;\r\n        uint256 overdraw  = investor.overdraw;\r\n\r\n        //has checkpoint?\r\n        if(checkpoint == 0) return 0;\r\n\r\n        //period\r\n        uint256 from      = checkpoint > dappy.start ? checkpoint : dappy.start;\r\n        uint256 period    = block.timestamp.sub(from);\r\n        uint256 periodDays= period.div(TIME_STEP); \r\n\r\n        //overdraw penalty\r\n        uint256 penalties = overdraw;\r\n        \r\n        //hoarding penalty\r\n        uint256 perPeriod;\r\n\r\n        for (uint256 i = 0; i < periodDays; i++) {\r\n            perPeriod = perPeriod.add(position.mul(rate.sub(penalties)).div(PERCENTS_DIVIDER));\r\n            penalties = penalties < dappy.rate.sub(dappy.rate.div(10)) ? penalties.add(dappy.rate.div(10)) : penalties;\r\n        }\r\n\r\n        //returns\r\n        result = perPeriod;\r\n    }\r\n\r\n    function calculatePenalties(uint256 atIndex, address atAddress) public view returns (uint256 result) {\r\n        Dappy memory dappy = getDappy(atIndex);\r\n\r\n        //is started?\r\n        if(block.timestamp < dappy.start) return 0;\r\n\r\n        //investor\r\n        Investor memory investor = getInvestor(atIndex, atAddress);\r\n        uint256 checkpoint= investor.checkpoint;\r\n        uint256 overdraw  = investor.overdraw;\r\n\r\n        //has checkpoint?\r\n        if(checkpoint == 0) return 0;\r\n\r\n        //period\r\n        uint256 from      = checkpoint > dappy.start ? checkpoint : dappy.start;\r\n        uint256 period    = block.timestamp.sub(from);\r\n        uint256 periodDays= period.div(TIME_STEP); \r\n\r\n        //overdraw penalty\r\n        uint256 penalties = overdraw;\r\n\r\n        for (uint256 i = 0; i < periodDays; i++) {\r\n            penalties = penalties < dappy.rate.sub(dappy.rate.div(10)) ? penalties.add(dappy.rate.div(10)) : penalties;\r\n        }\r\n\r\n        //returns\r\n        result = penalties;\r\n    }\r\n\r\n    function ownerWithdraw(uint256 atIndex, uint256 amount) public exists(atIndex) onlyOwner(atIndex) {\r\n        //validate amount\r\n        address atOwner = msg.sender;\r\n        require(amount <= getAllowance(atIndex, atOwner), \"Amount exceeds allowance.\");\r\n\r\n        //balances\r\n        balances[atIndex] = balances[atIndex].sub(amount);\r\n\r\n        //allowances\r\n        uint256 newAllowance= getAllowance(atIndex, atOwner).sub(amount);\r\n        setAllowance(atIndex, atOwner, newAllowance);\r\n\r\n        //transfer\r\n        payable(atOwner).transfer(amount);\r\n    }\r\n\r\n    function ownerDeposit(uint256 atIndex) public payable exists(atIndex) onlyOwner(atIndex) {\r\n        uint256 amount = msg.value;\r\n        address atOwner= msg.sender;\r\n\r\n        //balances\r\n        balances[atIndex] = balances[atIndex].add(amount);\r\n\r\n        //allowances\r\n        uint256 newAllowance= getAllowance(atIndex, atOwner).add(amount);\r\n        setAllowance(atIndex, atOwner, newAllowance);\r\n    }\r\n\r\n    function setAllowance(uint256 atIndex, address atAddress, uint256 toAmount) private exists(atIndex) {\r\n        allowances[atIndex][atAddress] = toAmount;\r\n    }\r\n\r\n    function setDiscount(address atAddress, uint256 toPercent) public onlyAdmin() {\r\n        discounts[atAddress] = toPercent;\r\n    }\r\n\r\n    function getDiscount(address atAddress) public view returns (uint256) {\r\n        return discounts[atAddress];\r\n    }\r\n\r\n    function getPublishFee(address atAddress) public view returns (uint256) {\r\n        uint256 fee = PUBLISH_FEE;\r\n        return fee.sub(fee.mul(getDiscount(atAddress)).div(PERCENTS_DIVIDER));\r\n    }\r\n\r\n    function getDappy(uint256 atIndex) public view returns (Dappy memory) {\r\n        return dappys[atIndex];\r\n    }\r\n\r\n    function getDappys() public view returns (Dappy[] memory) {\r\n        return dappys;\r\n    }\r\n\r\n    function getInvestor(uint256 atIndex, address atAddress) public view returns (Investor memory) {\r\n        return investors[atIndex][atAddress];\r\n    }\r\n\r\n    function getBalance(uint256 atIndex) public view returns (uint256) {\r\n        return balances[atIndex];\r\n    }\r\n\r\n    function getAllowance(uint256 atIndex, address atAddress) public view returns (uint256) {\r\n        return allowances[atIndex][atAddress];\r\n    }\r\n\r\n\tfunction getContractBalance() public view returns (uint256) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"networkMinimum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ADMIN_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_MAX_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_MIN_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUBLISH_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"atAddress\",\"type\":\"address\"}],\"name\":\"calculatePenalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"atAddress\",\"type\":\"address\"}],\"name\":\"calculateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"}],\"name\":\"compound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"atAddress\",\"type\":\"address\"}],\"name\":\"getAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"}],\"name\":\"getDappy\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hedge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownerFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"accent\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"theme\",\"type\":\"bool\"}],\"internalType\":\"struct Factory.Dappy\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDappys\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hedge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownerFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"accent\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"theme\",\"type\":\"bool\"}],\"internalType\":\"struct Factory.Dappy[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"atAddress\",\"type\":\"address\"}],\"name\":\"getDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"atAddress\",\"type\":\"address\"}],\"name\":\"getInvestor\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"principle\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"overdraw\",\"type\":\"uint256\"}],\"internalType\":\"struct Factory.Investor\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"atAddress\",\"type\":\"address\"}],\"name\":\"getPublishFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"}],\"name\":\"ownerDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ownerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hedge\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"accent\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"theme\",\"type\":\"bool\"}],\"name\":\"publish\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"atAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toPercent\",\"type\":\"uint256\"}],\"name\":\"setDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"atIndex\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Factory", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000bb9551fc24000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://498908afdab1665af169beecee9a041c788451d95bcce8c0b24e0c0bdc8e9f28"}