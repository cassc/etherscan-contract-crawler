{"SourceCode": "{\"Address.sol\":{\"content\":\"/**\\n * @title Address\\n * @dev Address.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn\\u0027t rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length \\u003e 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance \\u003e= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                0,\\n                \\\"Address: low-level call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance \\u003e= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        (bool success, bytes memory returndata) = target.call{value: value}(\\n            data\\n        );\\n        return\\n            verifyCallResultFromTarget(\\n                target,\\n                success,\\n                returndata,\\n                errorMessage\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                \\\"Address: low-level static call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return\\n            verifyCallResultFromTarget(\\n                target,\\n                success,\\n                returndata,\\n                errorMessage\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionDelegateCall(\\n                target,\\n                data,\\n                \\\"Address: low-level delegate call failed\\\"\\n            );\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return\\n            verifyCallResultFromTarget(\\n                target,\\n                success,\\n                returndata,\\n                errorMessage\\n            );\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage)\\n        private\\n        pure\\n    {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length \\u003e 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"},\"Bribe.sol\":{\"content\":\"/**\\n * @title Bribe\\n * @dev Bribe.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\nimport \\\"./IReferrals.sol\\\";\\nimport \\\"./IGaugeFactory.sol\\\";\\nimport \\\"./IBribe.sol\\\";\\nimport \\\"./IProtocolGovernance.sol\\\";\\n\\ncontract Bribe is IBribe, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public constant WEEK = 1 weeks; // rewards are released over 7 days\\n    uint256 public firstBribeTimestamp;\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    struct Reward {\\n        uint256 periodFinish;\\n        uint256 rewardsPerEpoch;\\n        uint256 lastUpdateTime;\\n    }\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e Reward)) public rewardData; // token -\\u003e startTimestamp -\\u003e Reward\\n    mapping(address =\\u003e bool) public isRewardToken;\\n    address[] public rewardTokens;\\n    address public gaugeFactory;\\n    address public bribeFactory;\\n\\n    // user -\\u003e reward token -\\u003e lastTime\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public userTimestamp;\\n\\n    // uint256 private _totalSupply;\\n    mapping(uint256 =\\u003e uint256) public _totalSupply;\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public _balances; //user -\\u003e timestamp -\\u003e amount\\n\\n    // outputs the fee variables.\\n    uint256 public referralFee;\\n    address public referralContract;\\n    uint256[] public refLevelPercent = [60000, 30000, 10000];\\n    uint256 internal divisor = 100000;\\n\\n    // user -\\u003e reward token -\\u003e earned amount\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public earnedRefs;\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) public whitelisted;\\n\\n    mapping(address =\\u003e uint256) public userFirstDeposit;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(address _gaugeFactory, address _bribeFactory) public {\\n        gaugeFactory = _gaugeFactory;\\n        bribeFactory = _bribeFactory;\\n        firstBribeTimestamp = IGaugeFactory(_gaugeFactory).epoch();\\n        referralContract = IProtocolGovernance(_gaugeFactory)\\n            .baseReferralsContract();\\n        referralFee = IProtocolGovernance(_gaugeFactory).baseReferralFee();\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function getEpoch() public view returns (uint256) {\\n        return IGaugeFactory(gaugeFactory).epoch();\\n    }\\n\\n    function rewardsListLength() external view returns (uint256) {\\n        return rewardTokens.length;\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        uint256 _currentEpochStart = getEpoch(); // claim until current epoch\\n        return _totalSupply[_currentEpochStart];\\n    }\\n\\n    function totalSupplyNextEpoch() external view returns (uint256) {\\n        uint256 _currentEpochStart = getEpoch() + 1; // claim until current epoch\\n        return _totalSupply[_currentEpochStart];\\n    }\\n\\n    function totalSupplyAt(uint256 _timestamp) external view returns (uint256) {\\n        return _totalSupply[_timestamp];\\n    }\\n\\n    function balanceOfAt(address _voter, uint256 _timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return _balances[_voter][_timestamp];\\n    }\\n\\n    // Get last deposit available balance (getNextEpochStart)\\n    function balanceOf(address _voter) public view returns (uint256) {\\n        uint256 _timestamp = getEpoch() + 1;\\n        return _balances[_voter][_timestamp];\\n    }\\n\\n    // Calculates the total rewards earned by a user for a particular reward token.\\n    // If a user has not collected any rewards for 50 epochs (about 1 year), they are lost the upcoming rewards.\\n    // We believe that it\\u0027s not logical to assume that a user actively votes in the protocol\u2019s governance,\\n    // but does not claim his rewards for 50 consecutive weeks which are visibly on display every time he votes using the frontend. \\n    function earned(address _voter, address _rewardToken)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 k = 0;\\n        uint256 reward = 0;\\n        uint256 _endTimestamp = getEpoch(); // claim until current epoch\\n        uint256 _userLastTime = userTimestamp[_voter][_rewardToken];\\n\\n        if (_endTimestamp == _userLastTime) {\\n            return 0;\\n        }\\n\\n        // if user first time then set it to first bribe\\n        if (_userLastTime == 0) {\\n            _userLastTime = userFirstDeposit[_voter] - 1;\\n        }\\n\\n        for (k; k \\u003c 50; k++) {\\n            if (_userLastTime == _endTimestamp) {\\n                // if we reach the current epoch, exit\\n                break;\\n            }\\n            reward += _earned(_voter, _rewardToken, _userLastTime);\\n            _userLastTime += 1;\\n        }\\n        return reward;\\n    }\\n\\n    function _earned(\\n        address _voter,\\n        address _rewardToken,\\n        uint256 _timestamp\\n    ) public view returns (uint256) {\\n        uint256 _balance = balanceOfAt(_voter, _timestamp);\\n        if (_balance == 0) {\\n            return 0;\\n        } else {\\n            uint256 _rewardPerToken = rewardPerToken(_rewardToken, _timestamp);\\n            uint256 _rewards = (_rewardPerToken * _balance) / 1e18;\\n            return _rewards;\\n        }\\n    }\\n\\n    // Calculates the reward per token for a given rewards token and timestamp\\n    function rewardPerToken(address _rewardsToken, uint256 _timestamap)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (_totalSupply[_timestamap] == 0) {\\n            return rewardData[_rewardsToken][_timestamap].rewardsPerEpoch;\\n        }\\n        return\\n            (rewardData[_rewardsToken][_timestamap].rewardsPerEpoch * 1e18) /\\n            _totalSupply[_timestamap];\\n    }\\n\\n    //---------------------------\\n\\n    // GaugeFactory deposit Votingpower amount for voter\\n    function _deposit(uint256 amount, address _voter) external nonReentrant {\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\n        require(msg.sender == gaugeFactory);\\n        uint256 _startTimestamp = getEpoch() + 1;\\n        if (userFirstDeposit[_voter] == 0) {\\n            userFirstDeposit[_voter] = _startTimestamp;\\n        }\\n        uint256 _oldSupply = _totalSupply[_startTimestamp];\\n        _totalSupply[_startTimestamp] = _oldSupply + amount;\\n        _balances[_voter][_startTimestamp] =\\n            _balances[_voter][_startTimestamp] +\\n            amount;\\n        emit Staked(_voter, amount);\\n    }\\n\\n    // GaugeFactory withdraw Votingpower amount for voter\\n    function _withdraw(uint256 amount, address _voter) public nonReentrant {\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\n        require(msg.sender == gaugeFactory);\\n        uint256 _startTimestamp = getEpoch() + 1;\\n        if (amount \\u003c= _balances[_voter][_startTimestamp]) {\\n            uint256 _oldSupply = _totalSupply[_startTimestamp];\\n            uint256 _oldBalance = _balances[_voter][_startTimestamp];\\n            _totalSupply[_startTimestamp] = _oldSupply - amount;\\n            _balances[_voter][_startTimestamp] = _oldBalance - amount;\\n            emit Withdrawn(_voter, amount);\\n        }\\n    }\\n\\n    // depostit rewards in rewardToken for next epoch\\n    function notifyRewardAmount(address _rewardsToken, uint256 reward)\\n        external\\n        nonReentrant\\n    {\\n        require(isRewardToken[_rewardsToken], \\\"reward token not verified\\\");\\n        require(reward \\u003e WEEK, \\\"reward amount should be greater than DURATION\\\");\\n        IERC20(_rewardsToken).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            reward\\n        );\\n\\n        uint256 _startTimestamp = getEpoch() + 1; // period points to the current distribute day. Bribes are distributed from next epoch in 7 days\\n        if (firstBribeTimestamp == 0) {\\n            firstBribeTimestamp = _startTimestamp;\\n        }\\n\\n        uint256 _lastReward = rewardData[_rewardsToken][_startTimestamp]\\n            .rewardsPerEpoch;\\n\\n        rewardData[_rewardsToken][_startTimestamp].rewardsPerEpoch =\\n            _lastReward +\\n            reward;\\n        rewardData[_rewardsToken][_startTimestamp].lastUpdateTime = block\\n            .timestamp;\\n        rewardData[_rewardsToken][_startTimestamp].periodFinish =\\n            getEpoch() +\\n            1;\\n\\n        emit RewardAdded(_rewardsToken, reward, _startTimestamp);\\n    }\\n\\n    // Claim all your rewards\\n    function getReward() external {\\n        getRewardForOwnerToOtherOwner(msg.sender, msg.sender);\\n    }\\n\\n    // Give the owner all earned rewards\\n    function getRewardForOwner(address voter) external {\\n        getRewardForOwnerToOtherOwner(voter, voter);\\n    }\\n\\n    // Get the reward from a owner to a whistlistet address or self\\n    function getRewardForOwnerToOtherOwner(address _voter, address _receiver)\\n        public\\n        nonReentrant\\n    {\\n        if (_voter != _receiver) {\\n            require(\\n                _voter == msg.sender || whitelisted[_voter][_receiver] == true,\\n                \\\"not owner or whitelisted\\\"\\n            );\\n        }\\n\\n        uint256 _endTimestamp = getEpoch(); // claim until current epoch\\n        uint256 reward = 0;\\n\\n        for (uint256 i = 0; i \\u003c rewardTokens.length; i++) {\\n            address _rewardToken = rewardTokens[i];\\n            reward = earned(_voter, _rewardToken);\\n\\n            if (reward \\u003e 0) {\\n                uint256 _divisor = divisor;\\n                uint256 refReward = (reward * referralFee) / _divisor;\\n                uint256 remainingRefReward = refReward;\\n\\n                IERC20(_rewardToken).safeTransfer(\\n                    _receiver,\\n                    reward - refReward\\n                );\\n                emit RewardPaid(\\n                    _voter,\\n                    _receiver,\\n                    _rewardToken,\\n                    reward - refReward\\n                );\\n                address ref = IReferrals(referralContract).getSponsor(_voter);\\n\\n                uint256 x = 0;\\n                while (x \\u003c refLevelPercent.length \\u0026\\u0026 refLevelPercent[x] \\u003e 0) {\\n                    if (ref != IReferrals(referralContract).membersList(0)) {\\n                        uint256 refFeeAmount = (refReward *\\n                            refLevelPercent[x]) / _divisor;\\n                        remainingRefReward = remainingRefReward - refFeeAmount;\\n                        IERC20(_rewardToken).safeTransfer(ref, refFeeAmount);\\n                        earnedRefs[ref][_rewardToken] =\\n                            earnedRefs[ref][_rewardToken] +\\n                            refFeeAmount;\\n                        emit RefRewardPaid(ref, _rewardToken, reward);\\n                        ref = IReferrals(referralContract).getSponsor(ref);\\n                        x++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if (remainingRefReward \\u003e 0) {\\n                    address _mainRefFeeReceiver = IProtocolGovernance(\\n                        gaugeFactory\\n                    ).mainRefFeeReceiver();\\n                    IERC20(_rewardToken).safeTransfer(\\n                        _mainRefFeeReceiver,\\n                        remainingRefReward\\n                    );\\n                    earnedRefs[_mainRefFeeReceiver][_rewardToken] =\\n                        earnedRefs[_mainRefFeeReceiver][_rewardToken] +\\n                        remainingRefReward;\\n                    emit RefRewardPaid(\\n                        _mainRefFeeReceiver,\\n                        _rewardToken,\\n                        remainingRefReward\\n                    );\\n                }\\n            }\\n            userTimestamp[_voter][_rewardToken] = _endTimestamp;\\n        }\\n    }\\n\\n    // Same like getRewardForOwnerToOtherOwner but with Single Token claim (in case one is broken or pause)\\n    function getRewardForOwnerToOtherOwnerSingleToken(\\n        address _voter,\\n        address _receiver,\\n        address[] calldata tokens\\n    ) external nonReentrant {\\n        if (_voter != _receiver) {\\n            require(\\n                _voter == msg.sender || whitelisted[_voter][_receiver] == true,\\n                \\\"not owner or whitelisted\\\"\\n            );\\n        }\\n\\n        uint256 _endTimestamp = getEpoch(); // claim until current epoch\\n        uint256 reward = 0;\\n\\n        for (uint256 i = 0; i \\u003c tokens.length; i++) {\\n            address _rewardToken = tokens[i];\\n            reward = earned(_voter, _rewardToken);\\n\\n            if (reward \\u003e 0) {\\n                uint256 _divisor = divisor;\\n                uint256 refReward = (reward * referralFee) / _divisor;\\n                uint256 remainingRefReward = refReward;\\n\\n                IERC20(_rewardToken).safeTransfer(\\n                    _receiver,\\n                    reward - refReward\\n                );\\n                emit RewardPaid(\\n                    _voter,\\n                    _receiver,\\n                    _rewardToken,\\n                    reward - refReward\\n                );\\n                address ref = IReferrals(referralContract).getSponsor(_voter);\\n\\n                uint256 x = 0;\\n                while (x \\u003c refLevelPercent.length \\u0026\\u0026 refLevelPercent[x] \\u003e 0) {\\n                    if (ref != IReferrals(referralContract).membersList(0)) {\\n                        uint256 refFeeAmount = (refReward *\\n                            refLevelPercent[x]) / _divisor;\\n                        remainingRefReward = remainingRefReward - refFeeAmount;\\n                        IERC20(_rewardToken).safeTransfer(ref, refFeeAmount);\\n                        earnedRefs[ref][_rewardToken] =\\n                            earnedRefs[ref][_rewardToken] +\\n                            refFeeAmount;\\n                        emit RefRewardPaid(ref, _rewardToken, reward);\\n                        ref = IReferrals(referralContract).getSponsor(ref);\\n                        x++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                if (remainingRefReward \\u003e 0) {\\n                    address _mainRefFeeReceiver = IProtocolGovernance(\\n                        gaugeFactory\\n                    ).mainRefFeeReceiver();\\n                    IERC20(_rewardToken).safeTransfer(\\n                        _mainRefFeeReceiver,\\n                        remainingRefReward\\n                    );\\n                    earnedRefs[_mainRefFeeReceiver][_rewardToken] =\\n                        earnedRefs[_mainRefFeeReceiver][_rewardToken] +\\n                        remainingRefReward;\\n                    emit RefRewardPaid(\\n                        _mainRefFeeReceiver,\\n                        _rewardToken,\\n                        remainingRefReward\\n                    );\\n                }\\n            }\\n            userTimestamp[_voter][_rewardToken] = _endTimestamp;\\n        }\\n    }\\n\\n    // Set whitelist for other receiver in getRewardForOwnerToOtherOwner\\n    function setWhitelisted(address _receiver, bool _whitlist) public {\\n        whitelisted[msg.sender][_receiver] = _whitlist;\\n        emit Whitelisted(msg.sender, _receiver);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    // transfer a token out of the contract that is not a wanted token (airdrop tokens)\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external {\\n        require(\\n            msg.sender == IProtocolGovernance(gaugeFactory).governance() ||\\n                msg.sender == IProtocolGovernance(gaugeFactory).admin(),\\n            \\\"Pair: only factory\\u0027s feeAmountOwner or admin\\\"\\n        );\\n        require(tokenAmount \\u003c= IERC20(tokenAddress).balanceOf(address(this)));\\n        require(!isRewardToken[tokenAddress], \\\"Reward token not allowed\\\");\\n        IERC20(tokenAddress).safeTransfer(msg.sender, tokenAmount);\\n        emit Recovered(tokenAddress, tokenAmount);\\n    }\\n\\n    // add a token as bribe reward token\\n    function addRewardtoken(address _rewardsToken) external {\\n        require(\\n            msg.sender == bribeFactory ||\\n                msg.sender == IProtocolGovernance(gaugeFactory).governance() ||\\n                msg.sender == IProtocolGovernance(gaugeFactory).admin(),\\n            \\\"Pair: only factory\\u0027s feeAmountOwner or admin\\\"\\n        );\\n        require(!isRewardToken[_rewardsToken], \\\"Reward token already exists\\\");\\n        require(_rewardsToken != address(0));\\n        isRewardToken[_rewardsToken] = true;\\n        rewardTokens.push(_rewardsToken);\\n        emit AddRewardtoken(_rewardsToken);\\n    }\\n\\n    /* ========== REFERRAL FUNCTIONS ========== */\\n\\n    // Update the referral Variables\\n    function updateReferral(\\n        address _referralsContract,\\n        uint256 _referralFee,\\n        uint256[] calldata _refLevelPercent\\n    ) external {\\n        require(\\n            msg.sender == IProtocolGovernance(gaugeFactory).governance() ||\\n                msg.sender == IProtocolGovernance(gaugeFactory).admin(),\\n            \\\"Pair: only factory\\u0027s feeAmountOwner or admin\\\"\\n        );\\n        referralContract = _referralsContract;\\n        referralFee = _referralFee;\\n        refLevelPercent = _refLevelPercent;\\n        emit UpdateReferral(referralContract, referralFee, refLevelPercent);\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RewardAdded(\\n        address rewardToken,\\n        uint256 reward,\\n        uint256 startTimestamp\\n    );\\n    event Staked(address indexed voter, uint256 amount);\\n    event Withdrawn(address indexed voter, uint256 amount);\\n    event RewardPaid(\\n        address indexed user,\\n        address indexed rewardsToken,\\n        uint256 reward\\n    );\\n    event Recovered(address token, uint256 amount);\\n    event RefRewardPaid(\\n        address indexed user,\\n        address indexed token,\\n        uint256 reward\\n    );\\n    event RewardPaid(\\n        address indexed user,\\n        address indexed receiver,\\n        address indexed rewardsToken,\\n        uint256 reward\\n    );\\n    event AddRewardtoken(address token);\\n    event Whitelisted(address user, address whitelistedUser);\\n    event UpdateReferral(\\n        address referralContract,\\n        uint256 referralFee,\\n        uint256[] refLevelPercent\\n    );\\n}\\n\"},\"IBribe.sol\":{\"content\":\"/**\\n * @title Interface Bribe\\n * @dev IBribe.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IBribe {\\n    function WEEK() external view returns (uint256);\\n\\n    function firstBribeTimestamp() external view returns (uint256);\\n\\n    function isRewardToken(address token) external view returns (bool);\\n\\n    function rewardTokens(uint256 ID) external view returns (address);\\n\\n    function gaugeFactory() external view returns (address);\\n\\n    function bribeFactory() external view returns (address);\\n\\n    function userTimestamp(address owner, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function _totalSupply(uint256 timestamp) external view returns (uint256);\\n\\n    function _balances(address owner, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function referralFee() external view returns (uint256);\\n\\n    function referralContract() external view returns (address);\\n\\n    function refLevelPercent(uint256 level) external view returns (uint256);\\n\\n    function earnedRefs(address owner, address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function whitelisted(address owner, address receiver)\\n        external\\n        view\\n        returns (bool);\\n\\n    function userFirstDeposit(address owner) external view returns (uint256);\\n\\n    function getEpoch() external view returns (uint256);\\n\\n    function rewardsListLength() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function totalSupplyNextEpoch() external view returns (uint256);\\n\\n    function totalSupplyAt(uint256 timestamp) external view returns (uint256);\\n\\n    function balanceOfAt(address voter, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address voter) external view returns (uint256);\\n\\n    function earned(address voter, address rewardToken)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function _earned(\\n        address voter,\\n        address rewardToken,\\n        uint256 timestamp\\n    ) external view returns (uint256);\\n\\n    function rewardPerToken(address rewardsToken, uint256 timestmap)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function _deposit(uint256 amount, address voter) external;\\n\\n    function _withdraw(uint256 amount, address voter) external;\\n\\n    function notifyRewardAmount(address rewardsToken, uint256 reward) external;\\n\\n    function getReward() external;\\n\\n    function getRewardForOwner(address voter) external;\\n\\n    function getRewardForOwnerToOtherOwner(address voter, address receiver)\\n        external;\\n\\n    function getRewardForOwnerToOtherOwnerSingleToken(\\n        address voter,\\n        address receiver,\\n        address[] memory tokens\\n    ) external;\\n\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external;\\n\\n    function addRewardtoken(address rewardsToken) external;\\n\\n    function setWhitelisted(address receiver, bool whitlist) external;\\n\\n    function updateReferral(\\n        address referralsContract,\\n        uint256 referralFee,\\n        uint256[] memory refLevelPercent\\n    ) external;\\n}\\n\"},\"IERC20.sol\":{\"content\":\"/**\\n * @title Interface ERC20\\n * @dev IERC20.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"},\"IGaugeFactory.sol\":{\"content\":\"/**\\n * @title Interface Gauge Factory\\n * @dev IGaugeFactory.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IGaugeFactory {\\n    function tokens() external view returns (address[] memory);\\n\\n    function getGauge(address token) external view returns (address);\\n\\n    function getBribes(address gauge) external view returns (address);\\n\\n    function reset(address user) external;\\n\\n    function poke(address owner) external;\\n\\n    function vote(\\n        address user,\\n        address[] calldata tokenVote,\\n        uint256[] calldata weights\\n    ) external;\\n\\n    function addGauge(address tokenLP, uint256 maxVotesToken)\\n        external\\n        returns (address);\\n\\n    function deprecateGauge(address token) external;\\n\\n    function resurrectGauge(address token) external;\\n\\n    function length() external view returns (uint256);\\n\\n    function distribute(uint256 start, uint256 end) external;\\n\\n    function updateVeProxy(address veProxy) external;\\n\\n    function updatePokeDelay(uint256 pokeDelay) external;\\n\\n    function updateMaxVotesToken(uint256 ID, uint256 maxVotesToken) external;\\n\\n    function updateReferrals(\\n        address gauge,\\n        address referralsContract,\\n        uint256 referralFee,\\n        uint256[] memory refLevelPercent\\n    ) external;\\n\\n    function bribeFactory() external view returns (address);\\n\\n    function totalWeight() external view returns (uint256);\\n\\n    function delay() external view returns (uint256);\\n\\n    function lastDistribute() external view returns (uint256);\\n\\n    function lastVote(address user) external view returns (uint256);\\n\\n    function nextPoke(address user) external view returns (uint256);\\n\\n    function lockedTotalWeight() external view returns (uint256);\\n\\n    function lockedBalance() external view returns (uint256);\\n\\n    function locktime() external view returns (uint256);\\n\\n    function epoch() external view returns (uint256);\\n\\n    function lockedWeights(address user) external view returns (uint256);\\n\\n    function maxVotesToken(address user) external view returns (uint256);\\n\\n    function hasDistributed(address user) external view returns (bool);\\n\\n    function _tokens(uint256 tokenID) external view returns (address);\\n\\n    function gauges(address token) external view returns (address);\\n\\n    function gaugeStatus(address token) external view returns (bool);\\n\\n    function gaugeExists(address token) external view returns (bool);\\n\\n    function pokeDelay() external view returns (uint256);\\n\\n    function bribes(address gauge) external view returns (address);\\n\\n    function weights(address token) external view returns (uint256);\\n\\n    function votes(address user, address token) external view returns (uint256);\\n\\n    function tokenVote(address user, uint256 tokenID)\\n        external\\n        view\\n        returns (address);\\n\\n    function usedWeights(address user) external view returns (uint256);\\n}\\n\"},\"IProtocolGovernance.sol\":{\"content\":\"/**\\n * @title Interface Protocol Governance\\n * @dev IProtocolGovernance.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IProtocolGovernance {\\n    function setGovernance(address governance) external;\\n\\n    function acceptGovernance() external;\\n\\n    function setAdminAndVoter(address admin, address voter) external;\\n\\n    function setStableMiner(address stableMiner) external;\\n\\n    function updateBaseReferrals(\\n        address referralsContract,\\n        uint256 baseReferralFee,\\n        address mainRefFeeReceiver\\n    ) external;\\n\\n    function governance() external view returns (address);\\n\\n    function pendingGovernance() external view returns (address);\\n\\n    function admin() external view returns (address);\\n\\n    function voter() external view returns (address);\\n\\n    function stableMiner() external view returns (address);\\n\\n    function baseReferralsContract() external view returns (address);\\n\\n    function baseReferralFee() external view returns (uint256);\\n\\n    function mainRefFeeReceiver() external view returns (address);\\n}\\n\"},\"IReferrals.sol\":{\"content\":\"/**\\n * @title Interface Referrals\\n * @dev IReferrals contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: Business Source License 1.1\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ninterface IReferrals {\\n    function getSponsor(address account) external view returns (address);\\n\\n    function isMember(address user) external view returns (bool);\\n\\n    function membersList(uint256 id) external view returns (address);\\n}\\n\"},\"Math.sol\":{\"content\":\"/**\\n * @title Math\\n * @dev Math.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003e= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"/**\\n * @title Reentrancy Guard\\n * @dev ReentrancyGuard.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\ncontract ReentrancyGuard {\\n    /// @dev counter to allow mutex lock with only one SSTORE operation\\n    uint256 private _guardCounter;\\n\\n    constructor() {\\n        // The counter starts at one to prevent changing it from zero to a non-zero\\n        // value, which is a more expensive operation.\\n        _guardCounter = 1;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _guardCounter += 1;\\n        uint256 localCounter = _guardCounter;\\n        _;\\n        require(\\n            localCounter == _guardCounter,\\n            \\\"ReentrancyGuard: reentrant call\\\"\\n        );\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"/**\\n * @title Safe ERC20\\n * @dev SafeERC20.sol contract\\n *\\n * @author - \\u003cUSDFI TRUST\\u003e\\n * for the USDFI Trust\\n *\\n * SPDX-License-Identifier: MIT\\n *\\n **/\\n\\npragma solidity =0.8.17;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        // solhint-disable-next-line max-line-length\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) - value;\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gaugeFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bribeFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"AddRewardtoken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RefRewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardsToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardsToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referralContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"refLevelPercent\",\"type\":\"uint256[]\"}],\"name\":\"UpdateReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whitelistedUser\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"_deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"_earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"_withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"addRewardtoken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bribeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"earnedRefs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstBribeTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugeFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getRewardForOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"getRewardForOwnerToOtherOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"getRewardForOwnerToOtherOwnerSingleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRewardToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refLevelPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"periodFinish\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timestamap\",\"type\":\"uint256\"}],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_whitlist\",\"type\":\"bool\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referralsContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_referralFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_refLevelPercent\",\"type\":\"uint256[]\"}],\"name\":\"updateReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userFirstDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Bribe", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000f5a11086a8bbf349c55dd16b7b9913932696a50c0000000000000000000000002b837d9ef4449f6569985961ab670fcdfe36a4da", "EVMVersion": "Default", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://52effcd26205c6dfed5da2ce1c3e13dfa2ae716cdf096ba964c707f28c05538c"}