{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface Token {\r\n    function transfer(address to, uint tokens) external returns (bool success);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) ;\r\n      function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    }\r\ncontract DuStake\r\n    {\r\n       \r\n        address  public owner=0x949535BB1192e5509fff513A72eC4381228ff59b;              \r\n\r\n\r\n        address Staking_token = 0xe298eD3543B45037A2D4037ac6dfeB2E801f9803; //DU\r\n\r\n\r\n        uint public totalusers;\r\n        uint private key;\r\n\r\n        uint public per_day_divider= 1 days;\r\n        \r\n        uint public bonus= 8*10**18;\r\n        uint public minimum_investment=10*10**18;\r\n        uint public minimum_withdraw_reward_limit=1*10**18;\r\n        uint public maximum_withdraw_reward_limit=2500*10**18;\r\n\r\n        uint public penaltybefore30days= 8*10**18;\r\n        uint public withdrawfee= 5*10**18;\r\n\r\n        mapping(address=>uint) public trasactionCount;\r\n\r\n        mapping(address=>uint) public Total_TeamStakeOf;\r\n\r\n        uint64[12] public levelpercentage = [0.4 ether,0.33 ether,0.1666 ether,0.1 ether,0.0667 ether,0.033 ether,0.033 ether,0.033 ether,0.033 ether,0.033 ether,0.0667 ether,0.1 ether];\r\n        uint[12] public level_tokens= [5000 *10**18,10000 *10**18,15000 *10**18,20000 *10**18,25000 *10**18,30000 *10**18,35000 *10**18,40000 *10**18,45000 *10**18,50000 *10**18,55000 *10**18,60000 *10**18];\r\n\r\n        uint public totalbusiness; \r\n        uint public totalwithdraw; \r\n\r\n\r\n        struct allInvestments{\r\n\r\n            uint investedAmount;\r\n            uint withdrawnTime;\r\n            uint DepositTime;\r\n            uint investmentNum;\r\n            uint unstakeTime;\r\n            bool unstake;\r\n            uint apr;\r\n            uint timeframe;\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n        struct Data{\r\n\r\n            mapping(uint=>allInvestments) investment;\r\n            uint noOfInvestment;\r\n            uint totalInvestment;\r\n            uint totalWithdraw_reward;\r\n            bool investBefore;\r\n            address[] myReferrals;\r\n            address referralFrom;  \r\n            mapping(uint=>level_data) level;\r\n            uint totalDirects;\r\n            uint totalTeam;\r\n        }\r\n\r\n\r\n        struct time_Apy\r\n        {\r\n            uint timeframe;\r\n            uint APR;\r\n        }\r\n\r\n        struct level_data\r\n        {\r\n            bool eligible;\r\n            uint eligible_time;\r\n            uint count; \r\n\r\n\r\n        }\r\n\r\n        struct history\r\n        {\r\n            uint events;\r\n            uint amount;\r\n            uint time;\r\n\r\n\r\n        }\r\n\r\n        mapping(address=>Data) public user;\r\n        mapping(uint=>time_Apy) public details;\r\n        mapping(address=>mapping(uint=>history)) public historyOf;\r\n        mapping(address=>uint) public BonusOf;\r\n\r\n\r\n        mapping(address=>mapping(uint=>allInvestments)) public user_investments;\r\n\r\n        modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _; \r\n    }\r\n        constructor(uint _key){\r\n            \r\n\r\n            key=_key;\r\n\r\n\r\n            details[0].timeframe=200 days;\r\n            details[1].timeframe=400 days;\r\n\r\n\r\n            details[0].APR=100;\r\n            details[1].APR=240;\r\n\r\n\r\n\r\n\r\n        }\r\n        \r\n        function sendRewardToReferrals(address investor,uint _investedAmount)  internal  //this is the freferral function to transfer the reawards to referrals\r\n        { \r\n \r\n            address temp = investor;\r\n            uint i=0;\r\n\r\n                do\r\n                {\r\n\r\n                    Total_TeamStakeOf[temp]+=_investedAmount;\r\n\r\n\r\n                    if(user[investor].noOfInvestment==1)\r\n                    {\r\n                        user[temp].totalTeam++;\r\n\r\n                        if(user[temp].referralFrom!=address(0))\r\n                        {\r\n                            user[user[temp].referralFrom].level[i].count++;\r\n\r\n                        }\r\n                    }\r\n\r\n                    for(uint j=0;j<12;j++)\r\n                    {\r\n                        if((Total_TeamStakeOf[temp]>=level_tokens[j]) && !user[temp].level[j].eligible)\r\n                        {\r\n                            user[temp].level[j].eligible=true;\r\n                            user[temp].level[j].eligible_time=block.timestamp;\r\n\r\n                            uint count=trasactionCount[temp];\r\n                            historyOf[temp][count].events=4;\r\n                            historyOf[temp][count].amount=level_tokens[j];\r\n                            historyOf[temp][count].time=block.timestamp;\r\n                            trasactionCount[temp]++;\r\n\r\n                        }\r\n                    }\r\n                    temp=user[temp].referralFrom;\r\n\r\n                    i++;\r\n                    \r\n                } \r\n                while(temp!=address(0));\r\n\r\n        }\r\n       \r\n\r\n\r\n        function Stake(uint _investedamount,uint choose_val,uint _key,address _ref) external returns(bool success)\r\n        {\r\n\r\n            require(key==_key);\r\n            require(_investedamount >= minimum_investment  );     //ensuring that investment amount is not less than zero\r\n\r\n            require(details[choose_val].APR > 0);\r\n            require(_investedamount > 0);     \r\n            require(Token(Staking_token).allowance(msg.sender,address(this))>=_investedamount);\r\n\r\n            if(user[msg.sender].investBefore == false && msg.sender!=owner)\r\n            { \r\n\r\n\r\n                if(_ref==address(0) || _ref==msg.sender || _ref==owner)\r\n                {\r\n                    \r\n                    user[msg.sender].referralFrom=owner;\r\n                    _ref=owner;\r\n                    user[_ref].myReferrals.push(msg.sender);\r\n                    uint bon = (bonus * _investedamount)/(100*10**18);\r\n                    BonusOf[_ref]+=bon;\r\n                }\r\n                else \r\n                {\r\n                    user[msg.sender].referralFrom=_ref;\r\n                    user[_ref].myReferrals.push(msg.sender);\r\n                    uint bon = (bonus * _investedamount)/(100*10**18);\r\n                    BonusOf[_ref]+=bon;\r\n\r\n                }\r\n                \r\n                user[_ref].totalDirects++;\r\n\r\n                totalusers++;                                     \r\n            }\r\n\r\n            \r\n            uint num = user[msg.sender].noOfInvestment;\r\n            user[msg.sender].investment[num].investedAmount =_investedamount;\r\n            user[msg.sender].investment[num].DepositTime=block.timestamp;\r\n            user[msg.sender].investment[num].withdrawnTime=block.timestamp + details[choose_val].timeframe ;  \r\n            \r\n            user[msg.sender].investment[num].investmentNum=num;\r\n            user[msg.sender].investment[num].apr=details[choose_val].APR;\r\n            user[msg.sender].investment[num].timeframe=(details[choose_val].timeframe/per_day_divider);  \r\n\r\n            user[msg.sender].totalInvestment+=_investedamount;\r\n            user[msg.sender].noOfInvestment++;\r\n            totalbusiness+=_investedamount;\r\n\r\n            Token(Staking_token).transferFrom(msg.sender,address(this),_investedamount);\r\n            user_investments[msg.sender][num] = user[msg.sender].investment[num];\r\n            user[msg.sender].investBefore=true;\r\n\r\n            uint temp=trasactionCount[msg.sender];\r\n            historyOf[msg.sender][temp].events=1;\r\n            historyOf[msg.sender][temp].amount=_investedamount;\r\n            historyOf[msg.sender][temp].time=block.timestamp;\r\n            trasactionCount[msg.sender]++;\r\n            sendRewardToReferrals( msg.sender, _investedamount);\r\n\r\n            return true;\r\n            \r\n        }\r\n\r\n       function get_TotalReward() view public returns(uint)\r\n       { \r\n            uint totalReward;\r\n            uint depTime;\r\n            uint rew;\r\n            uint temp = user[msg.sender].noOfInvestment;\r\n            for( uint i = 0;i < temp;i++)\r\n            {   \r\n                if(!user[msg.sender].investment[i].unstake)\r\n                {\r\n                    if(block.timestamp < user[msg.sender].investment[i].withdrawnTime)\r\n                    {\r\n                        depTime =block.timestamp - user[msg.sender].investment[i].DepositTime;\r\n                    }\r\n                    else\r\n                    {    \r\n                        depTime =user[msg.sender].investment[i].withdrawnTime - user[msg.sender].investment[i].DepositTime;\r\n                    }                \r\n                }\r\n                else{\r\n                    depTime =user[msg.sender].investment[i].unstakeTime - user[msg.sender].investment[i].DepositTime;\r\n                }\r\n                depTime=depTime/per_day_divider; //1 day\r\n                if(depTime>0)\r\n                {\r\n                     rew  =  (((user[msg.sender].investment[i].investedAmount * ((user[msg.sender].investment[i].apr) *10**18) )/ (100*10**18) )/(user[msg.sender].investment[i].timeframe));\r\n\r\n\r\n                    totalReward += depTime * rew;\r\n                }\r\n            }\r\n            return totalReward;\r\n        }\r\n\r\n\r\n\r\n        function getReward_perInv(uint i,uint point) view public returns(uint){ \r\n            uint totalReward;\r\n            uint depTime;\r\n            uint rew;\r\n            uint apr;\r\n\r\n                if(!user[msg.sender].investment[i].unstake)\r\n                {\r\n                    if(block.timestamp < user[msg.sender].investment[i].withdrawnTime)\r\n                    {\r\n                        depTime =block.timestamp - user[msg.sender].investment[i].DepositTime;\r\n                    }\r\n                    else\r\n                    {    \r\n                        depTime =user[msg.sender].investment[i].withdrawnTime - user[msg.sender].investment[i].DepositTime;\r\n                    }                \r\n                }\r\n                else{\r\n                    depTime =user[msg.sender].investment[i].unstakeTime - user[msg.sender].investment[i].DepositTime;\r\n                }\r\n                depTime=depTime/per_day_divider; //1 day\r\n                if(depTime>0)\r\n                {\r\n                    if(point==1)\r\n                    {\r\n                        if(user[msg.sender].investment[i].apr==100)\r\n                        {\r\n                            apr=66.6 ether;\r\n                        }\r\n                        else{\r\n                            apr=173.2 ether;\r\n\r\n                        }\r\n                    }\r\n                    else{\r\n                        if(user[msg.sender].investment[i].apr==100)\r\n                        {\r\n                            apr=100 ether;\r\n                        }\r\n                        else{\r\n                            apr=200 ether;\r\n\r\n                        }\r\n                    }\r\n\r\n                     rew  =  (((user[msg.sender].investment[i].investedAmount * apr  )/ (100*10**18) )/(user[msg.sender].investment[i].timeframe));\r\n\r\n\r\n                    totalReward += depTime * rew;\r\n                }\r\n            \r\n\r\n            return totalReward;\r\n        }\r\n\r\n\r\n        function getLevelReward_perInv(uint i,address inv,uint _level,address main) view public returns(uint){ //this function is get the total reward balance of the investor\r\n            uint totalReward;\r\n            uint depTime;\r\n            uint rew;\r\n\r\n                if(!user[inv].investment[i].unstake)\r\n                {\r\n                    \r\n                    if(block.timestamp < user[inv].investment[i].withdrawnTime)\r\n                    {\r\n                        depTime =block.timestamp - user[main].level[_level].eligible_time;\r\n                    }\r\n                    else\r\n                    {    \r\n                        depTime =user[inv].investment[i].withdrawnTime - user[main].level[_level].eligible_time;\r\n                    }                        \r\n                \r\n                }\r\n                else\r\n                {\r\n                    depTime =user[inv].investment[i].unstakeTime - user[main].level[_level].eligible_time;\r\n                }\r\n                depTime=depTime/per_day_divider; //1 day\r\n                if(depTime>0)\r\n                {\r\n                     rew  =  (((user[inv].investment[i].investedAmount * ((user[inv].investment[i].apr) *10**18) )/ (100*10**18) )/(user[inv].investment[i].timeframe));\r\n\r\n\r\n                    totalReward += depTime * rew;\r\n                }\r\n            \r\n\r\n            return totalReward;\r\n        }\r\n\r\n\r\n        function unStake(uint num) external  returns (bool success)\r\n        {\r\n            require(user[msg.sender].investment[num].investedAmount>0);            \r\n            require(!user[msg.sender].investment[num].unstake);\r\n            uint amount=user[msg.sender].investment[num].investedAmount;\r\n            totalbusiness-=amount;\r\n            if(user[msg.sender].investment[num].DepositTime + 30 days > block.timestamp)\r\n            {\r\n                uint penalty_fee=(amount*penaltybefore30days)/(100 ether) ;\r\n                Token(Staking_token).transfer(owner,penalty_fee);            \r\n                amount=amount-penalty_fee;\r\n            }\r\n            else if(user[msg.sender].investment[num].withdrawnTime > block.timestamp)\r\n            {\r\n                uint penalty_fee=getReward_perInv(num,2) - getReward_perInv(num,1);\r\n                Token(Staking_token).transfer(owner,penalty_fee);            \r\n                amount=amount-penalty_fee;\r\n            }\r\n            Token(Staking_token).transfer(msg.sender,amount);            \r\n          \r\n            user[msg.sender].investment[num].unstake =true;    \r\n            user[msg.sender].investment[num].unstakeTime =block.timestamp;    \r\n\r\n            user[msg.sender].totalInvestment-=user[msg.sender].investment[num].investedAmount;\r\n            user_investments[msg.sender][num] = user[msg.sender].investment[num];\r\n\r\n            uint temp=trasactionCount[msg.sender];\r\n            historyOf[msg.sender][temp].events=2;\r\n            historyOf[msg.sender][temp].amount=amount;\r\n            historyOf[msg.sender][temp].time=block.timestamp;\r\n            trasactionCount[msg.sender]++;\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n\r\n\r\n        function getTotalInvestment() public view returns(uint) {   //this function is to get the total investment of the ivestor\r\n            \r\n            return user[msg.sender].totalInvestment;\r\n\r\n        }\r\n        \r\n        function get_totalEarning() public view returns(uint) {   //this function is to get the total investment of the ivestor\r\n            \r\n            uint[] memory arr= new uint[](12);\r\n            arr=Level_earning(msg.sender);\r\n            uint total_levelReward;\r\n            for(uint i=0;i<12;i++)\r\n            {\r\n                total_levelReward+=arr[i];\r\n            }\r\n            return (( get_TotalReward() + BonusOf[msg.sender] + total_levelReward) - user[msg.sender].totalWithdraw_reward );\r\n\r\n        }\r\n\r\n        function withdrawReward(uint _vlaue) external returns (bool success){\r\n            uint Total_reward = get_totalEarning();\r\n            \r\n            require(_vlaue >= minimum_withdraw_reward_limit && _vlaue <= maximum_withdraw_reward_limit ,\"limit issue\");     //ensuring that investment amount is not less than zero\r\n\r\n            require(Total_reward>=_vlaue);         //ensuring that if the investor have rewards to withdraw\r\n            totalwithdraw+=_vlaue;\r\n            user[msg.sender].totalWithdraw_reward+=_vlaue;\r\n\r\n            uint withdraw_fee=(_vlaue*(withdrawfee))/(100*10**18);\r\n            Token(Staking_token).transfer(owner,withdraw_fee);            \r\n            _vlaue=_vlaue-withdraw_fee;\r\n\r\n            Token(Staking_token).transfer(msg.sender,_vlaue);             // transfering the reward to investor             \r\n            uint temp=trasactionCount[msg.sender];\r\n\r\n            historyOf[msg.sender][temp].events=3;\r\n            historyOf[msg.sender][temp].amount=_vlaue;\r\n            historyOf[msg.sender][temp].time=block.timestamp;\r\n            trasactionCount[msg.sender]++;\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n        function getAll_investments() public view returns (allInvestments[] memory Invested)\r\n        { \r\n            uint num = user[msg.sender].noOfInvestment;\r\n            uint temp;\r\n            uint currentIndex;\r\n            \r\n            for(uint i=0;i<num;i++)\r\n            {\r\n               if(!user[msg.sender].investment[i].unstake )\r\n               {\r\n                   temp++;\r\n               }\r\n\r\n            }\r\n         \r\n           allInvestments[] memory temp_arr =  new allInvestments[](temp) ;\r\n            Invested =  new allInvestments[](temp) ;\r\n\r\n            for(uint i=0;i<num;i++)\r\n            {\r\n               if( !user[msg.sender].investment[i].unstake ){\r\n\r\n                   temp_arr[currentIndex]=user[msg.sender].investment[i];\r\n\r\n                   currentIndex++;\r\n               }\r\n\r\n            }\r\n\r\n            uint count=temp;\r\n            for(uint i=0;i<temp;i++)\r\n            {\r\n                count--;\r\n                Invested[i]=temp_arr[count];\r\n\r\n            }\r\n\r\n            return Invested;\r\n\r\n        }\r\n        \r\n        function get_upliner(address inv) public view returns(address)\r\n        {\r\n            return user[inv].referralFrom;\r\n        }\r\n\r\n\r\n        function Level_earning(address inv) public view returns( uint[] memory arr1 )\r\n        { \r\n\r\n            uint[] memory levelRewards = new uint[](12);\r\n\r\n            uint calc_rew; \r\n            address[] memory direct_members = user[inv].myReferrals;\r\n            uint next_member_count;\r\n\r\n            for(uint j=0; j < 12;j++) //levels\r\n            {\r\n\r\n                if(user[inv].level[j].eligible)\r\n                {\r\n                    for( uint k = 0;k < direct_members.length;k++) //members\r\n                    {   \r\n                        \r\n                        next_member_count+=user[direct_members[k]].myReferrals.length;\r\n\r\n                        uint temp = user[direct_members[k]].noOfInvestment; \r\n\r\n                        for( uint i = 0;i < temp;i++) //investments\r\n                        {   \r\n                            // if(user[direct_members[k]].investment[i].DepositTime<=user[inv].level[j].eligible_time)\r\n                            // {\r\n                            uint temp_amount = getLevelReward_perInv(i,direct_members[k],j,inv);\r\n                            calc_rew +=  ((temp_amount * (levelpercentage[j]) )/ (100*10**18) );\r\n\r\n                            // }\r\n                            \r\n                        }\r\n\r\n\r\n                                    \r\n                    }\r\n                    levelRewards[j]=calc_rew;\r\n                    calc_rew=0;\r\n\r\n                    address[] memory next_members=new address[](next_member_count) ;\r\n\r\n                    for( uint m = 0;m < direct_members.length;m++) //members\r\n                    {   \r\n                        for( uint n = 0; n < user[direct_members[m]].myReferrals.length; n++) //members\r\n                        {   \r\n                            next_members[calc_rew]= user[direct_members[m]].myReferrals[n];\r\n                            calc_rew++;\r\n                        }\r\n                    }\r\n                    direct_members=next_members; \r\n                    next_member_count=0;\r\n                    calc_rew=0;\r\n\r\n\r\n                }\r\n                \r\n            }\r\n                \r\n\r\n            \r\n            \r\n\r\n            return levelRewards;\r\n        }\r\n\r\n\r\n\r\n        function Level_count(address inv) public view returns( uint[] memory _arr )\r\n        {\r\n            uint[] memory referralLevels_count=new uint[](12);\r\n\r\n            for(uint i=0;i<12;i++)\r\n            {\r\n                referralLevels_count[i] = user[inv].level[i].count;\r\n            }\r\n            return referralLevels_count ;\r\n\r\n\r\n        }\r\n        \r\n        function get_history(address inv) public view returns( history[] memory _arr )\r\n        {\r\n            uint temp=trasactionCount[msg.sender];\r\n\r\n            _arr=new history[](temp);\r\n            for(uint i=0;i<temp;i++)\r\n            {\r\n\r\n                    _arr[i] = historyOf[inv][i];\r\n\r\n\r\n\r\n            }\r\n            return _arr ;\r\n\r\n\r\n        }\r\n\r\n  \r\n        function transferOwnership(address _owner)  public\r\n        {\r\n            require(msg.sender==owner);\r\n            owner = _owner;\r\n        }\r\n\r\n        function total_withdraw_reaward() view public returns(uint){\r\n\r\n\r\n            return user[msg.sender].totalWithdraw_reward;\r\n\r\n            \r\n\r\n        }\r\n        \r\n\r\n\r\n\r\n       function withdrawFunds(uint _amount)  public\r\n        {\r\n            require(msg.sender==owner);\r\n\r\n            uint bal = Token(Staking_token).balanceOf(address(this));\r\n            _amount*=10**18;\r\n            require(bal>=_amount);\r\n\r\n            Token(Staking_token).transfer(owner,_amount); \r\n        }\r\n\r\n        //updtae values\r\n\r\n        function update_minimum_withdraw_reward_limit(uint inv) onlyOwner public\r\n        {\r\n\r\n            minimum_withdraw_reward_limit=inv;\r\n        }\r\n\r\n        function update_minimum_investment(uint inv) onlyOwner public\r\n        {\r\n\r\n            minimum_investment=inv;\r\n        }        \r\n        \r\n        function update_maximum_withdraw_reward_limit(uint inv) onlyOwner public\r\n        {\r\n\r\n            maximum_withdraw_reward_limit=inv;\r\n        }\r\n        \r\n        function update_Unstake_penaltybefore30days(uint inv) onlyOwner public\r\n        {\r\n\r\n            penaltybefore30days=inv;\r\n        }        \r\n        function update_key(uint _key) onlyOwner public\r\n        {\r\n            key=_key;\r\n        }        \r\n        \r\n        function update_withdrawfee(uint inv) onlyOwner public\r\n        {\r\n            withdrawfee=inv;\r\n        } \r\n    }", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_key\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BonusOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inv\",\"type\":\"address\"}],\"name\":\"Level_count\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_arr\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inv\",\"type\":\"address\"}],\"name\":\"Level_earning\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"arr1\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_investedamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"choose_val\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_key\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"Stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Total_TeamStakeOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"details\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timeframe\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"APR\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAll_investments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"investedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DepositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeframe\",\"type\":\"uint256\"}],\"internalType\":\"struct DuStake.allInvestments[]\",\"name\":\"Invested\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"inv\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"main\",\"type\":\"address\"}],\"name\":\"getLevelReward_perInv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"point\",\"type\":\"uint256\"}],\"name\":\"getReward_perInv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_TotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inv\",\"type\":\"address\"}],\"name\":\"get_history\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"events\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct DuStake.history[]\",\"name\":\"_arr\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_totalEarning\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inv\",\"type\":\"address\"}],\"name\":\"get_upliner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"historyOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"events\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"level_tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelpercentage\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximum_withdraw_reward_limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimum_investment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimum_withdraw_reward_limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltybefore30days\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"per_day_divider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_withdraw_reaward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalbusiness\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalusers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalwithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"trasactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"unStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inv\",\"type\":\"uint256\"}],\"name\":\"update_Unstake_penaltybefore30days\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"update_key\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inv\",\"type\":\"uint256\"}],\"name\":\"update_maximum_withdraw_reward_limit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inv\",\"type\":\"uint256\"}],\"name\":\"update_minimum_investment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inv\",\"type\":\"uint256\"}],\"name\":\"update_minimum_withdraw_reward_limit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inv\",\"type\":\"uint256\"}],\"name\":\"update_withdrawfee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"user\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"noOfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdraw_reward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"investBefore\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referralFrom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDirects\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"user_investments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"investedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DepositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakeTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstake\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeframe\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vlaue\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawfee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DuStake", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000006f603588ef8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://270ccf0d181e2ac62358a0cd0fe7153174a9125e5320d56d1a53e9c851c143ef"}