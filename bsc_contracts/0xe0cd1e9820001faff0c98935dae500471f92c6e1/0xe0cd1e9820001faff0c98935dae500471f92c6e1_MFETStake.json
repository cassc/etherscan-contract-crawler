{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// MFET - Multi Functional Environmental Token\r\n// We are Developing New Generation Projects and Funding These Projects with Green Blockchain.\r\n\r\n// A Sustainable World\r\n// MFET is an ecosystem that supports sustainable projects, provides mentoring to companies in carbon footprint studies,\r\n// provides consultancy on environmental and climate studies, and makes decisions without being dependent on an authority\r\n// with the community it has created, thanks to the blockchain.\r\n\r\n// MFET - Stake Contract\r\n\r\n// Mens et Manus\r\npragma solidity ^0.8.0;\r\n\r\ninterface IBEP20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeBEP20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IBEP20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IBEP20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeBEP20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(\r\n                oldAllowance >= value,\r\n                \"SafeBEP20: decreased allowance below zero\"\r\n            );\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(\r\n                token,\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    newAllowance\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeBEP20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeBEP20: BEP20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\ncontract MFETStake is Context, Ownable, ReentrancyGuard {\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    struct Stake {\r\n        address user;\r\n        uint256 amount;\r\n        uint256 since;\r\n        uint256 rewardRatio;\r\n        uint256 rate;\r\n        bool isActive;\r\n    }\r\n\r\n    uint256 public stakeId;\r\n    uint256[] public allStakeIds;\r\n\r\n    uint256 public totalStakedAmount;\r\n    uint256 public totalStakeRewardClaimed;\r\n\r\n    mapping(address => uint256[]) private stakesByAddress;\r\n\r\n    mapping(uint256 => Stake) public stakedToken;\r\n    mapping(uint256 => uint256) public stakeRates;\r\n    mapping(uint256 => uint256) private totalStakesByRate;\r\n\r\n    event Staked(\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 timestamp,\r\n        uint256 rewardRatio,\r\n        uint256 rate,\r\n        bool isActive\r\n    );\r\n\r\n    IBEP20 public mfetToken;\r\n    uint256 emergencyFee;\r\n    uint256 stakeFee;\r\n    address public stakeFeeAddress;\r\n    uint256 public stakePlus;\r\n\r\n    constructor(\r\n        uint256 stakeFee_,\r\n        uint256 emergencyFee_,\r\n        uint256 stakePlus_,\r\n        address stakeFeeAddress_,\r\n        address mfetToken_\r\n    ) {\r\n        stakeFee = stakeFee_;\r\n        emergencyFee = emergencyFee_;\r\n        stakePlus = stakePlus_;\r\n        stakeFeeAddress = stakeFeeAddress_;\r\n        mfetToken = IBEP20(mfetToken_);\r\n\r\n        addStakeRate(1, 5);\r\n        addStakeRate(3, 16);\r\n        addStakeRate(6, 34);\r\n        addStakeRate(9, 53);\r\n        addStakeRate(12, 72);\r\n        addStakeRate(18, 110);\r\n        addStakeRate(24, 150);\r\n    }\r\n\r\n    modifier onlyEOA() {\r\n        require(tx.origin == _msgSender(), \"MFET Stake : should be EOA\");\r\n        _;\r\n    }\r\n\r\n    function addStakeRate(uint256 _rate, uint256 _rewardRatio)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        stakeRates[_rate] = _rewardRatio;\r\n        return true;\r\n    }\r\n\r\n    function setStakePlus(uint256 _stakePlus)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        // calculation over 1000 be careful\r\n        stakePlus = _stakePlus;\r\n        return true;\r\n    }\r\n\r\n    function setMfetToken(address _contract) external onlyOwner returns (bool) {\r\n        require(\r\n            _contract != address(0),\r\n            \"MFET Stake : contract adress is zero address\"\r\n        );\r\n\r\n        mfetToken = IBEP20(_contract);\r\n        return true;\r\n    }\r\n\r\n    function setEmergencyWithdrawFee(uint256 _fee)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        emergencyFee = _fee;\r\n        return true;\r\n    }\r\n\r\n    function setStakeFee(uint256 _fee) external onlyOwner returns (bool) {\r\n        stakeFee = _fee;\r\n        return true;\r\n    }\r\n\r\n    function setStakeFeeAddress(address _address)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        require(\r\n            _address != address(0),\r\n            \"MFET Stake : user adress is zero address\"\r\n        );\r\n        stakeFeeAddress = _address;\r\n        return true;\r\n    }\r\n\r\n    function getAddressAllStakeIds(address _user)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return stakesByAddress[_user];\r\n    }\r\n\r\n    function getSingleStakeDetails(uint256 _id)\r\n        external\r\n        view\r\n        returns (\r\n            address user,\r\n            uint256 amount,\r\n            uint256 since,\r\n            uint256 rewardRatio,\r\n            uint256 rate,\r\n            bool isActive\r\n        )\r\n    {\r\n        return (\r\n            stakedToken[_id].user,\r\n            stakedToken[_id].amount,\r\n            stakedToken[_id].since,\r\n            stakedToken[_id].rewardRatio,\r\n            stakedToken[_id].rate,\r\n            stakedToken[_id].isActive\r\n        );\r\n    }\r\n\r\n    function getAddressActiveTotalStakedAmount(address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256[] memory userStakes = stakesByAddress[_user];\r\n\r\n        uint256 totalStaked = 0;\r\n        for (uint256 i = 0; i < userStakes.length; i++) {\r\n            if (stakedToken[userStakes[i]].isActive) {\r\n                totalStaked = totalStaked + stakedToken[userStakes[i]].amount;\r\n            }\r\n        }\r\n        return totalStaked;\r\n    }\r\n\r\n    function _stake(\r\n        address _user,\r\n        uint256 _amount,\r\n        uint256 _rate\r\n    ) internal returns (uint256) {\r\n        require(_amount > 0, \"MFET Stake : cant stake nothing\");\r\n        require(\r\n            stakeRates[_rate] != 0,\r\n            \"MFET Stake: there is no stake reward ratio for this rate\"\r\n        );\r\n\r\n        uint256 stakeFeeAmount = 0;\r\n        uint256 stakeAmount = _amount;\r\n\r\n        if (stakeFee > 0) {\r\n            stakeFeeAmount = (_amount * stakeFee) / 1000;\r\n            require(stakeFeeAmount > 0, \"MFET Stake : fee calculation error\");\r\n            stakeAmount = stakeAmount - stakeFeeAmount;\r\n\r\n            // user send tokens to fee address\r\n            mfetToken.safeTransferFrom(\r\n                _msgSender(),\r\n                stakeFeeAddress,\r\n                stakeFeeAmount\r\n            );\r\n        }\r\n\r\n        uint256 _id = ++stakeId;\r\n        allStakeIds.push(_id);\r\n        stakesByAddress[_user].push(_id);\r\n        totalStakesByRate[_rate] = totalStakesByRate[_rate] + stakeAmount;\r\n\r\n        totalStakedAmount = totalStakedAmount + stakeAmount;\r\n\r\n        stakedToken[_id].user = _user;\r\n        stakedToken[_id].amount = stakeAmount;\r\n        stakedToken[_id].since = block.timestamp;\r\n        stakedToken[_id].rewardRatio = stakeRates[_rate];\r\n        stakedToken[_id].rate = _rate;\r\n        stakedToken[_id].isActive = true;\r\n\r\n        // user send tokens to stake contract\r\n        mfetToken.safeTransferFrom(_msgSender(), address(this), stakeAmount);\r\n\r\n        emit Staked(\r\n            _msgSender(),\r\n            stakeAmount,\r\n            block.timestamp,\r\n            stakeRates[_rate],\r\n            _rate,\r\n            true\r\n        );\r\n\r\n        return _id;\r\n    }\r\n\r\n    function stake(uint256 _amount, uint256 _rate)\r\n        external\r\n        nonReentrant\r\n        onlyEOA\r\n        returns (uint256)\r\n    {\r\n        require(_amount > 0, \"MFET Stake : you cant stake zero\");\r\n        uint256 _addressBalance = mfetToken.balanceOf(_msgSender());\r\n        require(\r\n            _addressBalance >= _amount,\r\n            \"MFET Stake: cannot stake more than you own\"\r\n        );\r\n\r\n        return _stake(_msgSender(), _amount, _rate);\r\n    }\r\n\r\n    function stakeFor(\r\n        address _user,\r\n        uint256 _amount,\r\n        uint256 _rate\r\n    ) external nonReentrant onlyEOA returns (uint256) {\r\n        require(\r\n            _user != address(0),\r\n            \"MFET Stake : user adress is zero address\"\r\n        );\r\n        require(_amount > 0, \"MFET Stake : you cant stake zero\");\r\n        uint256 _addressBalance = mfetToken.balanceOf(_msgSender());\r\n        require(\r\n            _addressBalance >= _amount,\r\n            \"MFET Stake: cannot stake more than you own\"\r\n        );\r\n\r\n        return _stake(_user, _amount, _rate);\r\n    }\r\n\r\n    function getRewardsLeft() public view returns (uint256) {\r\n        uint256 contractTotalBalance = mfetToken.balanceOf(address(this));\r\n        unchecked {\r\n            return contractTotalBalance - totalStakedAmount;\r\n        }\r\n    }\r\n\r\n    function calculateStakeRewards(uint256 _id) public view returns (uint256) {\r\n        uint256 rewardAmount = ((stakedToken[_id].rewardRatio *\r\n            stakedToken[_id].amount) / 1000);\r\n        return rewardAmount;\r\n    }\r\n\r\n    function _monthlyRewards(uint256 _id) internal returns (uint256) {\r\n        uint256 extraReward = 0;\r\n        uint256 totalDaysPast = (block.timestamp - stakedToken[_id].since) /\r\n            1 days;\r\n\r\n        require(\r\n            totalDaysPast > 0,\r\n            \"MFET Stake : total day past must bigger then 0\"\r\n        );\r\n\r\n        uint256 dayPassRatio = (totalDaysPast *\r\n            stakedToken[_id].rewardRatio *\r\n            1e9) / (stakedToken[_id].rate * 30);\r\n\r\n        require(dayPassRatio > 0, \"MFET Stake : day pass must bigger then 0\");\r\n\r\n        uint256 mRewardAmount = (stakedToken[_id].amount * dayPassRatio) / 1e12;\r\n\r\n        if (stakePlus > 0) {\r\n            extraReward = (stakedToken[_id].amount * stakePlus) / 1000;\r\n            require(\r\n                extraReward > 0,\r\n                \"MFET Stake : extra reward must bigger then 0\"\r\n            );\r\n        }\r\n\r\n        mRewardAmount = mRewardAmount + extraReward;\r\n\r\n        require(\r\n            mRewardAmount > 0,\r\n            \"MFET Stake : monthly reward must bigger then 0\"\r\n        );\r\n\r\n        uint256 rewardsLeftInContract = getRewardsLeft();\r\n\r\n        if (rewardsLeftInContract < mRewardAmount) {\r\n            mRewardAmount = rewardsLeftInContract;\r\n        }\r\n\r\n        totalStakeRewardClaimed = totalStakeRewardClaimed + mRewardAmount;\r\n\r\n        return mRewardAmount;\r\n    }\r\n\r\n    function monthlyClaim(uint256 _id) external nonReentrant onlyEOA {\r\n        require(stakedToken[_id].isActive, \"MFET Stake : not active\");\r\n        require(\r\n            stakedToken[_id].rate >= 3,\r\n            \"MFET Stake : monthy claim only over 30 day stakes\"\r\n        );\r\n        require(\r\n            totalStakedAmount > 0,\r\n            \"MFET Stake : there are no stake in there\"\r\n        );\r\n        require(\r\n            _msgSender() == stakedToken[_id].user,\r\n            \"MFET Stake : this is not your token\"\r\n        );\r\n        require(\r\n            block.timestamp > stakedToken[_id].since + 30 days,\r\n            \"MFET Stake : monthly claim time not yet\"\r\n        );\r\n\r\n        uint256 stakeMonthlyReward = _monthlyRewards(_id);\r\n        require(\r\n            stakeMonthlyReward > 0,\r\n            \"MFET Stake : monthly reward bigger then 0\"\r\n        );\r\n\r\n        stakedToken[_id].since = block.timestamp;\r\n        mfetToken.safeTransfer(_msgSender(), stakeMonthlyReward);\r\n    }\r\n\r\n    function _withdraw(uint256 _id) internal returns (uint256) {\r\n        uint256 stakeAmount = stakedToken[_id].amount;\r\n        uint256 rewardAmount = calculateStakeRewards(_id);\r\n\r\n        uint256 rewardsLeftInContract = getRewardsLeft();\r\n\r\n        if (rewardsLeftInContract < rewardAmount) {\r\n            rewardAmount = rewardsLeftInContract;\r\n        }\r\n\r\n        unchecked {\r\n            totalStakedAmount = totalStakedAmount - stakedToken[_id].amount;\r\n        }\r\n\r\n        unchecked {\r\n            totalStakesByRate[stakedToken[_id].rate] =\r\n                totalStakesByRate[stakedToken[_id].rate] -\r\n                stakedToken[_id].amount;\r\n        }\r\n\r\n        totalStakeRewardClaimed = totalStakeRewardClaimed + rewardAmount;\r\n\r\n        return stakeAmount + rewardAmount;\r\n    }\r\n\r\n    function withdraw(uint256 _id) external nonReentrant onlyEOA {\r\n        require(\r\n            totalStakedAmount > 0,\r\n            \"MFET Stake : there are no stake in there\"\r\n        );\r\n\r\n        require(stakedToken[_id].isActive, \"MFET Stake : not active\");\r\n\r\n        require(\r\n            _msgSender() == stakedToken[_id].user,\r\n            \"MFET Stake : this is not your token\"\r\n        );\r\n\r\n        require(\r\n            block.timestamp >\r\n                stakedToken[_id].since + (stakedToken[_id].rate * 30 days),\r\n            \"MFET Stake : time not yet\"\r\n        );\r\n\r\n        stakedToken[_id].isActive = false;\r\n\r\n        uint256 stakeAndReward = _withdraw(_id);\r\n\r\n        mfetToken.safeTransfer(_msgSender(), stakeAndReward);\r\n    }\r\n\r\n    function emergencyWithdraw(uint256 _id) external nonReentrant onlyEOA {\r\n        require(\r\n            stakedToken[_id].rate <= 3,\r\n            \"MFET Stake : over 90 days stake cant emergency withdraw\"\r\n        );\r\n\r\n        require(stakedToken[_id].isActive, \"Stake : stake is not active\");\r\n\r\n        require(\r\n            _msgSender() == stakedToken[_id].user,\r\n            \"MFET Stake : this is not your token\"\r\n        );\r\n\r\n        require(totalStakedAmount > 0, \"Stake : there are no stake in there\");\r\n\r\n        require(\r\n            mfetToken.balanceOf(address(this)) >= stakedToken[_id].amount,\r\n            \"MFET Stake : can not withdraw more then contract have\"\r\n        );\r\n\r\n        stakedToken[_id].isActive = false;\r\n\r\n        uint256 feeAmount = (stakedToken[_id].amount * emergencyFee) / 1000;\r\n\r\n        uint256 afterFee = stakedToken[_id].amount - feeAmount;\r\n\r\n        unchecked {\r\n            totalStakedAmount = totalStakedAmount - stakedToken[_id].amount;\r\n        }\r\n\r\n        unchecked {\r\n            totalStakesByRate[stakedToken[_id].rate] =\r\n                totalStakesByRate[stakedToken[_id].rate] -\r\n                stakedToken[_id].amount;\r\n        }\r\n        //send fee to fee address\r\n        mfetToken.safeTransfer(stakeFeeAddress, feeAmount);\r\n        // send balance after fee staked tokens to user\r\n        mfetToken.safeTransfer(_msgSender(), afterFee);\r\n    }\r\n\r\n    function getTotalStakesByRate(uint256 _rate)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalStakesByRate[_rate];\r\n    }\r\n\r\n    function addLiquidityWithContract(address _contract, uint256 _amount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        uint256 currentAllowance = IBEP20(_contract).allowance(\r\n            _msgSender(),\r\n            address(this)\r\n        );\r\n        require(\r\n            currentAllowance >= _amount,\r\n            \"MFET MFETStake : allowance is not enough\"\r\n        );\r\n        IBEP20(_contract).safeTransferFrom(\r\n            _msgSender(),\r\n            address(this),\r\n            _amount\r\n        );\r\n    }\r\n\r\n    function removeLiquidityWithContract(\r\n        address _contract,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        require(_to != address(0), \"MFET Stake : to address is zero address\");\r\n        require(\r\n            IBEP20(_contract).balanceOf(address(this)) >= _amount,\r\n            \"MFET Stake : insufficient liquidity\"\r\n        );\r\n        IBEP20(_contract).safeTransfer(_to, _amount);\r\n    }\r\n}\r\n// Made with love.", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"emergencyFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakePlus_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"stakeFeeAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mfetToken_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityWithContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRatio\",\"type\":\"uint256\"}],\"name\":\"addStakeRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allStakeIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"calculateStakeRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAddressActiveTotalStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAddressAllStakeIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardsLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getSingleStakeDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"since\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"getTotalStakesByRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mfetToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"monthlyClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityWithContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setEmergencyWithdrawFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setMfetToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setStakeFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setStakeFeeAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakePlus\",\"type\":\"uint256\"}],\"name\":\"setStakePlus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"stakeFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakePlus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"since\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakeRewardClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MFETStake", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000d1fe6b50c6ff6b6df3354d9e407251de0e69e7f70000000000000000000000006d23970ce32cb0f1929bece7c56d71319e1b4f01", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d81aa26f285d6ec69d98f9457645da176906a79e14d4902bf11f1b6387cba09f"}