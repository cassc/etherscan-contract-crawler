{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2021-10-19\r\n*/\r\n\r\n// File: iSYNTHVAULT.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iSYNTHVAULT{\r\n   function depositForMember(address synth, address member) external;\r\n   function setReserveClaim(uint256 _setSynthClaim) external;\r\n}\r\n// File: iSYNTHFACTORY.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iSYNTHFACTORY {\r\n    function isSynth(address) external view returns (bool);\r\n    function getSynth(address) external view returns (address);\r\n    function removeSynth(address _token) external;\r\n    function synthCount() external returns(uint);\r\n}\r\n// File: iSYNTH.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iSYNTH {\r\n    function genesis() external view returns(uint);\r\n    function TOKEN() external view returns(address);\r\n    function POOL() external view returns(address);\r\n    function mintSynth(address, uint) external returns(uint256);\r\n    function burnSynth(uint) external returns(uint);\r\n    function realise() external;\r\n}\r\n\r\n// File: iROUTER.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iROUTER {\r\n    function addLiquidityForMember(uint, uint, address, address) external payable returns (uint);\r\n      function synthMinting() external view returns (bool);\r\n}\r\n// File: iDAOVAULT.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iDAOVAULT{\r\n  function getMemberWeight(address) external view returns (uint256);\r\n  function getMemberPoolBalance(address, address) external view returns(uint);\r\n  function getMemberLPWeight(address) external view returns(uint, uint);\r\n  function depositLP(address, uint, address) external;\r\n  function withdraw(address, address) external returns (bool);\r\n  function totalWeight() external view returns (uint);\r\n  function mapTotalPool_balance(address) external view returns (uint);\r\n}\r\n// File: iDAO.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iDAO {\r\n    function ROUTER() external view returns(address);\r\n    function BASE() external view returns(address);\r\n    function LEND() external view returns(address);\r\n    function UTILS() external view returns(address);\r\n    function DAO() external view returns (address);\r\n    function RESERVE() external view returns(address);\r\n    function SYNTHVAULT() external view returns(address);\r\n    function BONDVAULT() external view returns(address);\r\n    function SYNTHFACTORY() external view returns(address);\r\n    function POOLFACTORY() external view returns(address);\r\n    function depositForMember(address pool, uint256 amount, address member) external;\r\n    function currentProposal() external view returns (uint);\r\n    function mapPID_open(uint) external view returns (bool);\r\n    function isListed(address) external view returns (bool);\r\n}\r\n// File: iBASE.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\ninterface iBASE {\r\n    function DAO() external view returns (iDAO);\r\n    function secondsPerEra() external view returns (uint256);\r\n    function changeDAO(address) external;\r\n    function setParams(uint256, uint256) external;\r\n    function flipEmissions() external;\r\n    function mintFromDAO(uint256, address) external; \r\n    function burn(uint256) external; \r\n}\r\n// File: iUTILS.sol\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.3;\r\ninterface iUTILS {\r\n    function calcShare(uint, uint, uint) external pure returns (uint);\r\n    function getFeeOnTransfer(uint256, uint256) external view returns(uint);\r\n    function getPoolShareWeight(address, uint)external view returns(uint);\r\n    function calcLiquidityUnits(uint, uint, uint, uint, uint) external pure returns (uint);\r\n    function calcLiquidityHoldings(uint, address, address) external pure returns (uint);\r\n    function calcSwapOutput(uint, uint, uint) external pure returns (uint);\r\n    function calcSwapFee(uint, uint, uint) external pure returns (uint);\r\n    function calcSwapValueInBase(address, uint) external view returns (uint);\r\n    function calcSwapValueInToken(address, uint) external view returns (uint);\r\n    function calcSpotValueInBaseWithSynth(address, uint) external view returns (uint);\r\n    function calcSpotValueInBase(address, uint) external view returns (uint);\r\n    function calcPart(uint, uint) external pure returns (uint);\r\n    function calcLiquidityUnitsAsym(uint, address)external pure returns (uint);\r\n    function calcActualSynthUnits(address, uint) external view returns (uint);\r\n}\r\n// File: iBEP20.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\ninterface iBEP20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function transfer(address, uint256) external returns (bool);\r\n    function allowance(address, address) external view returns (uint256);\r\n    function approve(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns (bool);\r\n    function burn(uint) external;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: Pool.sol\r\n\r\n\r\npragma solidity 0.8.3;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Pool is iBEP20 {  \r\n    address public immutable BASE;  // Address of SPARTA base token contract\r\n    address public immutable TOKEN; // Address of the layer1 TOKEN represented in this pool\r\n    uint256 public synthCap;    // Basis points hard cap of synths that can be minted vs tokenDepth\r\n    uint256 public baseCap;     // Cap on the depth of the pool (in SPARTA)\r\n    uint256 public oldRate;    // Pool ratio from last period\r\n    uint256 private period;     // Timestamp of next period\r\n    uint256 private freezePoint; // Basis points change to trigger a freeze\r\n    bool public freeze;         // Freeze status of the pool\r\n    uint256 private oneWeek;\r\n\r\n    uint256 public stirRate; // Rate of steaming\r\n    uint public lastStirred; // timestamp of last steamed\r\n    uint public stirStamp; // timestamp of last time stir rate was adjusted\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 public override immutable decimals;\r\n    uint256 public override totalSupply;\r\n    mapping(address => uint) private _balances;\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n\r\n    uint256 public baseAmount;  // SPARTA amount that should be in the pool\r\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\r\n\r\n    uint private lastMonth;          // Timestamp of the start of current metric period (For UI)\r\n    uint public immutable genesis;  // Timestamp from when the pool was first deployed (For UI)\r\n\r\n    uint256 public map30DPoolRevenue;       // Tally of revenue during current incomplete metric period (for UI)\r\n    uint256 public mapPast30DPoolRevenue;   // Tally of revenue from last full metric period (for UI)\r\n    uint256 [] private revenueArray;         // Array of the last two full metric periods (For UI)\r\n    \r\n    event AddLiquidity(address indexed member, address indexed tokenAddress, uint inputBase, uint inputToken, uint unitsIssued);\r\n    event RemoveLiquidity(address indexed member, address indexed tokenAddress, uint outputBase, uint outputToken, uint unitsClaimed);\r\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\r\n    event MintSynth(address indexed member, address indexed synthAddress, uint256 baseAmount, uint256 liqUnits, uint256 synthAmount);\r\n    event BurnSynth(address indexed member, address indexed synthAddress, uint256 baseAmount, uint256 liqUnits, uint256 synthAmount);\r\n\r\n    function SYNTH() public view returns(address) {\r\n        return iSYNTHFACTORY(_DAO().SYNTHFACTORY()).getSynth(TOKEN); // Get the relevant synth address\r\n    }\r\n\r\n    function _DAO() internal view returns(iDAO) {\r\n        return iBASE(BASE).DAO(); // Get the DAO address reported by Sparta base contract\r\n    }\r\n\r\n    // Restrict access\r\n    modifier onlyPROTOCOL() {\r\n        require(msg.sender == _DAO().ROUTER() || msg.sender == _DAO().SYNTHVAULT() || msg.sender == _DAO().POOLFACTORY()); \r\n        _;\r\n    }\r\n    modifier onlyDAO() {\r\n        require(msg.sender == _DAO().DAO() || msg.sender == _DAO().ROUTER() || msg.sender == _DAO().SYNTHVAULT());\r\n        _;\r\n    }\r\n     modifier onlySYNTH() {\r\n        require(msg.sender == SYNTH());\r\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(SYNTH()));\r\n        _;\r\n    }\r\n\r\n    constructor (address _base, address _token) {\r\n        BASE = _base;\r\n        TOKEN = _token;\r\n        string memory poolName = \"-SpartanProtocolPool\";\r\n        string memory poolSymbol = \"-SPP\";\r\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\r\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\r\n        decimals = 18;\r\n        genesis = block.timestamp;\r\n        period = block.timestamp + 60; \r\n        lastMonth = block.timestamp;\r\n        synthCap = 2500; //25%\r\n        freezePoint = 3000; //30%\r\n        baseCap = 100000*10**18; //RAISE THE CAPS\r\n        lastStirred = 0;\r\n        oneWeek = 604800;//604800 mainnet\r\n    }\r\n\r\n    //========================================iBEP20=========================================//\r\n\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"!approval\");\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"!owner\");\r\n        require(spender != address(0), \"!spender\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"!approval\");\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"!sender\");\r\n        require(recipient != address(0), '!BURN');\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"!balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"!account\");\r\n        totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function burn(uint256 amount) external onlySYNTH virtual override {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"!account\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"!balance\");\r\n        _balances[account] = accountBalance - amount;\r\n        totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    //====================================POOL FUNCTIONS =================================//\r\n\r\n    // Contract adds liquidity for user \r\n    function addForMember(address member) external onlyPROTOCOL returns (uint liquidityUnits){\r\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\r\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\r\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\r\n        if(baseAmount == 0 || tokenAmount == 0){\r\n            uint createFee = 100 * liquidityUnits / 10000; // First liqAdd charges 1% fee to the base contract (permanently removed from circulation; prevent 1wei rounding)\r\n            liquidityUnits -= createFee; // Remove fee from the calculated LP units\r\n            _mint(BASE, createFee); // Mint the fee portion of the LP units to the BASE contract (permanently removed from circulation)\r\n            oldRate = (10**18 * _actualInputBase) / _actualInputToken; // Set the first / initial rate\r\n        }\r\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\r\n        _mint(member, liquidityUnits); // Mint the remaining LP tokens directly to the user\r\n        emit AddLiquidity(member, TOKEN, _actualInputBase, _actualInputToken, liquidityUnits);\r\n        return liquidityUnits;\r\n    }\r\n\r\n    // Contract removes liquidity for the user\r\n    function removeForMember(address recipient, address actualMember) external onlyPROTOCOL returns (uint outputBase, uint outputToken) {\r\n        require(block.timestamp > (genesis + oneWeek)); // Can not remove liquidity until 7 days after pool's creation\r\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\r\n        iUTILS _utils = iUTILS(_DAO().UTILS()); // Interface the UTILS contract\r\n        outputBase = _utils.calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\r\n        outputToken = _utils.calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\r\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded SPARTA and TOKEN amounts\r\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\r\n        _safeTransfer(BASE, recipient,outputBase);        \r\n        _safeTransfer(TOKEN, recipient,outputToken);\r\n        emit RemoveLiquidity(actualMember, TOKEN, outputBase, outputToken, _actualInputUnits);\r\n        return (outputBase, outputToken);\r\n    }\r\n\r\n    // Contract swaps tokens for the member\r\n    function swapTo(address token, address member) external onlyPROTOCOL returns (uint outputAmount, uint fee) {\r\n        require((token == BASE || token == TOKEN)); // Must be SPARTA or the pool's relevant TOKEN\r\n        address _fromToken; uint _amount;\r\n        if(token == BASE){\r\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\r\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\r\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\r\n        } else {\r\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\r\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\r\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\r\n        }\r\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\r\n        _safeTransfer(token, member,outputAmount);  \r\n        return (outputAmount, fee);\r\n    }\r\n\r\n    // Swap SPARTA for Synths\r\n    function mintSynth(address member) external onlyPROTOCOL returns(uint outputAmount, uint fee) {\r\n        address synthOut = SYNTH(); // Get the synth address\r\n        require(iROUTER(_DAO().ROUTER()).synthMinting());  \r\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut)); // Must be a valid Synth\r\n        iUTILS _utils = iUTILS(_DAO().UTILS()); // Interface the UTILS contract\r\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\r\n        uint256 steamedSynths = stirCauldron(synthOut);\r\n        uint256 output = _utils.calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN (virtualised)\r\n        lastStirred = block.timestamp;\r\n        outputAmount = output * 9900 / 10000; //1% fee reduction\r\n        require(outputAmount <= steamedSynths); //steam synths\r\n        uint _liquidityUnits = _utils.calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\r\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\r\n        uint _fee = _utils.calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN (virtualised)\r\n        fee = _utils.calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\r\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\r\n        iSYNTH(synthOut).mintSynth(address(_DAO().SYNTHVAULT()), outputAmount); // Mint the Synth tokens directly to the synthVault\r\n        iSYNTHVAULT(_DAO().SYNTHVAULT()).depositForMember(synthOut, member); //Deposit on behalf of member\r\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\r\n        emit MintSynth(member,synthOut, _actualInputBase, _liquidityUnits, outputAmount);\r\n        return (outputAmount, fee);\r\n    }\r\n    \r\n    // Swap Synths for SPARTA\r\n    function burnSynth(address recipient, address actualMember) external onlyPROTOCOL returns(uint outputAmount, uint fee) {\r\n        address synthIN = SYNTH(); // Get the synth address\r\n        require(synthIN != address(0)); // Must be a valid Synth\r\n        iUTILS _utils = iUTILS(_DAO().UTILS()); // Interface the UTILS contract\r\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\r\n        uint output = _utils.calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA (virtualised)\r\n        uint outputBase = output * 9500 / 10000; //5% reduction\r\n        fee = _utils.calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA (virtualised)\r\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\r\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\r\n        uint liqUnits = iSYNTH(synthIN).burnSynth(_actualInputSynth); // Burn the input SYNTH units \r\n        _burn(synthIN, liqUnits); // Burn the synth-held LP units\r\n        _safeTransfer(BASE, recipient,outputBase);  \r\n        emit BurnSynth(actualMember,synthIN, outputBase, liqUnits, _actualInputSynth);\r\n        return (outputBase, fee);\r\n    }\r\n\r\n    function stirCauldron(address synth) public returns (uint256 steamedSynths){ \r\n          uint256 synthsCap = tokenAmount * synthCap / 10000;\r\n          uint256 liquidSynths; uint256 totalSup = iBEP20(synth).totalSupply();\r\n          steamedSynths = 0;\r\n         if(synthsCap >= totalSup){\r\n             liquidSynths = synthsCap - totalSup; \r\n         }\r\n         if(lastStirred != 0){ \r\n            uint secondsSinceStirred = block.timestamp - lastStirred; //Get last time since stirred\r\n            steamedSynths = secondsSinceStirred * stirRate; //time since last minted\r\n         }else{\r\n            lastStirred = block.timestamp;\r\n            stirStamp = block.timestamp;\r\n            stirRate = liquidSynths / oneWeek;\r\n            steamedSynths = 14400 * stirRate;  //4hrs\r\n         }\r\n         if(block.timestamp > (stirStamp + oneWeek)){\r\n            stirRate = liquidSynths / oneWeek;\r\n            stirStamp = block.timestamp;\r\n         }\r\n    }\r\n\r\n    //=======================================INTERNAL MATHS======================================//\r\n\r\n    // Check the SPARTA amount received by this Pool\r\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\r\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this));\r\n        if(_baseBalance > baseAmount){\r\n            _actual = _baseBalance - baseAmount;\r\n        } else {\r\n            _actual = 0;\r\n        }\r\n        return _actual;\r\n    }\r\n  \r\n    // Check the TOKEN amount received by this Pool\r\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\r\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \r\n        if(_tokenBalance > tokenAmount){\r\n            _actual = _tokenBalance - tokenAmount;\r\n        } else {\r\n            _actual = 0;\r\n        }\r\n        return _actual;\r\n    }\r\n\r\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\r\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\r\n        uint256 _X = baseAmount;\r\n        uint256 _Y = tokenAmount;\r\n        iUTILS _utils = iUTILS(_DAO().UTILS());\r\n        _y =  _utils.calcSwapOutput(_x, _X, _Y); // Calc TOKEN output \r\n        uint fee = _utils.calcSwapFee(_x, _X, _Y); // Calc TOKEN fee \r\n        _fee = _utils.calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\r\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\r\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\r\n        return (_y, _fee);\r\n    }\r\n\r\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\r\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\r\n        uint256 _X = tokenAmount;\r\n        uint256 _Y = baseAmount;\r\n        iUTILS _utils = iUTILS(_DAO().UTILS());\r\n        _y = _utils.calcSwapOutput(_x, _X, _Y); // Calc SPARTA output \r\n        _fee = _utils.calcSwapFee(_x, _X, _Y); // Calc SPARTA fee \r\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\r\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\r\n        return (_y, _fee);\r\n    }\r\n\r\n    //=======================================BALANCES=========================================//\r\n\r\n    // Sync internal balances to actual\r\n    function sync() external onlyDAO  {\r\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\r\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\r\n    }\r\n\r\n    // Set internal balances\r\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal {\r\n        baseAmount = _baseAmount;\r\n        tokenAmount = _tokenAmount; \r\n        _safetyCheck();\r\n    }\r\n\r\n    // Increment internal balances\r\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal {\r\n        require((baseAmount + _baseAmount) < baseCap); // SPARTA input must not push TVL over the cap\r\n        baseAmount += _baseAmount;\r\n        tokenAmount += _tokenAmount;\r\n        _safetyCheck();\r\n    }\r\n\r\n    // Decrement internal balances\r\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal {\r\n        baseAmount -= _baseAmount;\r\n        tokenAmount -= _tokenAmount; \r\n        _safetyCheck();\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    function _safetyCheck() internal {\r\n            uint currentRate = (10**18 * baseAmount) / tokenAmount; // Get current rate\r\n            uint rateDiff; uint256 rateDiffBP;\r\n            if (currentRate > oldRate) {\r\n                rateDiff = currentRate - oldRate; // Get absolute rate diff\r\n                rateDiffBP = rateDiff * 10000 / currentRate; // Get basispoints difference\r\n            } else {\r\n                rateDiff = oldRate - currentRate; // Get absolute rate diff\r\n                rateDiffBP = rateDiff * 10000 / oldRate; // Get basispoints difference\r\n            }\r\n            if (rateDiffBP >= freezePoint) {\r\n                freeze = true; // If exceeding; flip freeze to true\r\n            } else if (block.timestamp > period) {\r\n                period = block.timestamp + 3600; // Set new period\r\n                oldRate = currentRate; // Update the stored ratio\r\n            }\r\n            if(freeze){\r\n                if(rateDiffBP <= freezePoint){\r\n                    freeze = false; // If exceeding; flip freeze to false\r\n                }\r\n                if (block.timestamp > period) {\r\n                    period = block.timestamp + 3600; // Set new period\r\n                    oldRate = (currentRate + oldRate ) / 2; //Smooth rate increase\r\n                }\r\n            }  \r\n    }\r\n  \r\n    //===========================================POOL FEE ROI=================================//\r\n\r\n    function _addPoolMetrics(uint256 _fee) internal {\r\n        if (block.timestamp <= (lastMonth + 2592000)) {\r\n            map30DPoolRevenue = map30DPoolRevenue + _fee;\r\n        } else {\r\n            lastMonth = block.timestamp;\r\n            mapPast30DPoolRevenue = map30DPoolRevenue;\r\n            _archiveRevenue(mapPast30DPoolRevenue);\r\n            map30DPoolRevenue = _fee;\r\n        }\r\n    }\r\n\r\n    function _archiveRevenue(uint _totalRev) internal {\r\n        if (revenueArray.length == 2) {\r\n            revenueArray[0] = revenueArray[1]; // Shift previous value to start of array\r\n            revenueArray[1] = _totalRev; // Replace end of array with new value\r\n        } else {\r\n            revenueArray.push(_totalRev);\r\n        }\r\n    }\r\n\r\n    //=========================================== SYNTH CAPS =================================//\r\n    \r\n    function setSynthCap(uint256 _synthCap) external onlyPROTOCOL {\r\n        require(_synthCap <= 3000);\r\n        synthCap = _synthCap;\r\n    }\r\n\r\n    function RTC(uint256 _newRTC) external onlyPROTOCOL {\r\n        require(_newRTC <= (baseCap * 2));\r\n        baseCap = _newRTC;\r\n    }\r\n\r\n    function setFreezePoint(uint256 _newFreezePoint) external onlyPROTOCOL {\r\n        freezePoint = _newFreezePoint;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputBase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitsIssued\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"synthAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liqUnits\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"synthAmount\",\"type\":\"uint256\"}],\"name\":\"BurnSynth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"synthAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liqUnits\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"synthAmount\",\"type\":\"uint256\"}],\"name\":\"MintSynth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputBase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unitsClaimed\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenFrom\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRTC\",\"type\":\"uint256\"}],\"name\":\"RTC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SYNTH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"addForMember\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityUnits\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actualMember\",\"type\":\"address\"}],\"name\":\"burnSynth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeze\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesis\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastStirred\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"map30DPoolRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mapPast30DPoolRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"mintSynth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"actualMember\",\"type\":\"address\"}],\"name\":\"removeForMember\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputToken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFreezePoint\",\"type\":\"uint256\"}],\"name\":\"setFreezePoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_synthCap\",\"type\":\"uint256\"}],\"name\":\"setSynthCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"synth\",\"type\":\"address\"}],\"name\":\"stirCauldron\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"steamedSynths\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stirRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stirStamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"swapTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synthCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Pool", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003910db0600ea925f63c36ddb1351ab6e2c6eb1020000000000000000000000008AC76a51cc950d9822D68b83fE1Ad97B32Cd580d", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dcb4e66bc66284c9837cb9036f74f77f8757537e7c41b0512968b041af41b40f"}