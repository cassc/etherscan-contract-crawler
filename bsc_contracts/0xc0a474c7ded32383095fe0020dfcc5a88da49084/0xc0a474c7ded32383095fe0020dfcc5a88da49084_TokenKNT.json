{"SourceCode": "pragma solidity ^0.8.0;\r\n\r\n\r\ncontract TokenGCT {\r\n\r\n   \r\n    string public name;\r\n\r\n    address public orePooladdress;\r\n\r\n    address public platformAddress;\r\n\r\n    address public technology;\r\n\r\n    address public pgAddress;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public decimals = 18;\r\n    uint256 private fee; \r\n    uint256 private burnFee;\r\n    address private burnAddress;\r\n    uint256 public totalSupply;\r\n    address public owne;\r\n    address private incomeAddress;\r\n    uint256 private rabit;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n    ControlContract udstContract;\r\n    constructor () public {\r\n        totalSupply = 21000 * 10 ** uint256(decimals); \r\n        orePooladdress = 0x732596Cc153b664Ab35700e168391D452758796D;\r\n        burnAddress = 0x0000000000000000000000000000000000000000;\r\n        balanceOf[orePooladdress] = totalSupply; \r\n        name = \"Genesis Classic\";                             \r\n        symbol = \"GCT\";  \r\n        owne= msg.sender;        \r\n        allowance[orePooladdress][address(this)] = totalSupply;\r\n        udstContract = ControlContract(0x27714A1B4414a43bAbd23f47c6c41c8Fd586cB0F);\r\n        incomeAddress = 0x638C696Fd8fE780eb36c7201b2c62cab8c2DaE17;\r\n        rabit =3;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n             \r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        uint256 burn_account =  _value*rabit/1000;\r\n        _transfer(msg.sender, _to, _value-burn_account);\r\n        _transfer(msg.sender, burnAddress,burn_account);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]); \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n\r\n    }\r\n    \r\n    function transferArray(address[] calldata _to, uint256[] calldata _value) public returns (bool success) {\r\n        for(uint256 i = 0; i < _to.length; i++){\r\n            _transfer(msg.sender, _to[i], _value[i]);\r\n        }\r\n        return true;\r\n    }\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n    function _rabit(uint256 _rabit) public returns (bool success) {\r\n        require(msg.sender == owne); \r\n        rabit  = _rabit;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ControlContract {\r\n    struct Employee {\r\n        string name;\r\n        uint8 no;\r\n    }\r\n    mapping (bytes => Employee) bytesMapping;  //\u5b57\u8282\u6570\u7ec4\u4f5c\u4e3akey\r\n    mapping (address => Employee) addressMapping; // address\u4f5c\u4e3akey \r\n    mapping (string => mapping(uint => Employee)) complexMapping;  // mapping\u4f5c\u4e3avalue\uff0c\u662f\u53ef\u4ee5\u7684\u3002\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n    mapping (address => uint256) public tmp;\r\n    address public owne;\r\n\r\n    constructor() public {\r\n        owne= msg.sender;\r\n    }\r\n     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]); \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n\r\n    }\r\n     function _transfer(address _from, address _to, uint _value) internal {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n             \r\n    }\r\n \r\n}\r\n\r\n\r\n\r\ncontract SwarpContract {\r\n    struct Employee {\r\n        string name;\r\n        uint8 no;\r\n    }\r\n    mapping (bytes => Employee) bytesMapping;  //\u5b57\u8282\u6570\u7ec4\u4f5c\u4e3akey\r\n    mapping (address => Employee) addressMapping; // address\u4f5c\u4e3akey \r\n    mapping (string => mapping(uint => Employee)) complexMapping;  // mapping\u4f5c\u4e3avalue\uff0c\u662f\u53ef\u4ee5\u7684\u3002\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n     mapping (address => uint256) public lockOf;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n    mapping (address => uint256) public tmp;\r\n    address public owne;\r\n    address private gct_address;\r\n    uint256 private rabit;\r\n    uint256 private free_account;\r\n    address private receipt_address;\r\n    ControlContract udstContract;\r\n    ControlContract glpContract;\r\n    constructor() public {\r\n        owne= msg.sender;\r\n        rabit = 120;      \r\n        free_account=3;       \r\n    }\r\n     function swarp(uint256 _value) public returns (bool success) {\r\n        udstContract.transferFrom(msg.sender,receipt_address,_value);\r\n        glpContract.transferFrom(gct_address,msg.sender,_value/rabit);\r\n        return true;\r\n\r\n    }\r\n\r\n    function pledge(uint256 _value)public returns (bool success) {\r\n       glpContract.transferFrom(msg.sender,gct_address,_value);\r\n       lockOf[msg.sender] +=_value;\r\n       return true;\r\n    }\r\n\r\n    function unlock(uint256 _value) public returns (bool success){\r\n       require(_value <= lockOf[msg.sender]); \r\n       uint256 account =  _value - _value*free_account/1000;\r\n       glpContract.transferFrom(gct_address,msg.sender,account);\r\n       lockOf[msg.sender] = 0;\r\n       return true;\r\n    }\r\n    function sysn(address usdt,address glt) public returns (bool success) {\r\n        require(msg.sender == owne); \r\n        udstContract = ControlContract(usdt);\r\n        glpContract = ControlContract(glt);\r\n        return true;\r\n    }\r\n     function sysn_ybg_address(address _gct_address) public returns (bool success) {\r\n        require(msg.sender == owne); \r\n        gct_address  = _gct_address;\r\n    }\r\n    function sysn_usdt_receipt_address(address _receipt_address) public returns (bool success) {\r\n        require(msg.sender == owne); \r\n        receipt_address  = _receipt_address;\r\n    }\r\n\r\n    function _rabit(uint256 _rabit) public returns (bool success) {\r\n        require(msg.sender == owne); \r\n        rabit  = _rabit;\r\n        return true;\r\n    }\r\n   function free(uint256 _free_account) public returns (bool success) {\r\n        require(msg.sender == owne); \r\n        free_account  = _free_account;\r\n        return true;\r\n    }\r\n    function batchSynchLock(address[] calldata _to, uint256[] calldata _value) public returns (bool success) {\r\n        require(msg.sender == owne); \r\n        for(uint256 i = 0; i < _to.length; i++){\r\n             lockOf[ _to[i]] = _value[i] *10 ** uint256(18); \r\n        }\r\n        return true;\r\n    }\r\n    function synchLock(address  _to, uint256  _value) public returns (bool success) {\r\n        require(msg.sender == owne); \r\n        lockOf[ _to] = _value *10 ** uint256(18); \r\n        return true;\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n// contract UpSwarpContract {\r\n//     struct Employee {\r\n//         string name;\r\n//         uint8 no;\r\n//     }\r\n//     mapping (bytes => Employee) bytesMapping;  //\u5b57\u8282\u6570\u7ec4\u4f5c\u4e3akey\r\n//     mapping (address => Employee) addressMapping; // address\u4f5c\u4e3akey \r\n//     mapping (string => mapping(uint => Employee)) complexMapping;  // mapping\u4f5c\u4e3avalue\uff0c\u662f\u53ef\u4ee5\u7684\u3002\r\n//     mapping (address => uint256) public balanceOf;\r\n//     mapping (address => mapping (address => uint256)) public allowance;\r\n//     event Transfer(address indexed from, address indexed to, uint256 value);\r\n//     event Burn(address indexed from, uint256 value);\r\n//     mapping (address => uint256) public tmp;\r\n//     address public owne;\r\n//     address private gct_address;\r\n//     uint256 private rabit;\r\n//     uint256 private free_account;\r\n//     address private receipt_address;\r\n//     ControlContract udstContract;\r\n//     ControlContract glpContract;\r\n//     SwarpContract swarpContrac;\r\n//        constructor() public {\r\n//         owne= msg.sender;\r\n//         rabit = 120;      \r\n//         free_account=300000000000000000;    \r\n//         swarpContrac = SwarpContract(0xac3FEe5202A8b1833f94987D08cFC686EB37Bae9);\r\n        \r\n//     }\r\n//      function swarp(uint256 _value) public returns (bool success) {\r\n//         udstContract.transferFrom(msg.sender,receipt_address,_value);\r\n//         glpContract.transferFrom(gct_address,msg.sender,_value/rabit);\r\n//         return true;\r\n\r\n//     }\r\n\r\n//     function pledge(uint256 _value)public returns (bool success) {\r\n//        glpContract.transferFrom(msg.sender,gct_address,_value);\r\n//        swarpContrac.lockOf[msg.sender] ;\r\n//        return true;\r\n//     }\r\n\r\n//     function unlock(uint256 _value) public returns (bool success){\r\n//        require(_value <= swarpContrac.lockOf[msg.sender]); \r\n//        glpContract.transferFrom(gct_address,msg.sender,_value-free_account);\r\n//        require(free_account <= _value); \r\n//        swarpContrac.lockOf[msg.sender] -= _value;\r\n//        return true;\r\n//     }\r\n//     function sysn(address usdt,address glt) public returns (bool success) {\r\n//         require(msg.sender == owne); \r\n//         udstContract = ControlContract(usdt);\r\n//         glpContract = ControlContract(glt);\r\n//         return true;\r\n//     }\r\n//      function sysn_ybg_address(address _gct_address) public returns (bool success) {\r\n//         require(msg.sender == owne); \r\n//         gct_address  = _gct_address;\r\n//     }\r\n//     function sysn_usdt_receipt_address(address _receipt_address) public returns (bool success) {\r\n//         require(msg.sender == owne); \r\n//         receipt_address  = _receipt_address;\r\n//     }\r\n\r\n//     function _rabit(uint256 _rabit) public returns (bool success) {\r\n//         require(msg.sender == owne); \r\n//         rabit  = _rabit;\r\n//         return true;\r\n//     }\r\n//    function free(uint256 _free_account) public returns (bool success) {\r\n//         require(msg.sender == owne); \r\n//         free_account  = _free_account;\r\n//         return true;\r\n//     }\r\n    \r\n    \r\n// }\r\n\r\n\r\n\r\ncontract TokenKNT {\r\n\r\n   \r\n    string public name;\r\n\r\n    address public orePooladdress;\r\n\r\n    address public platformAddress;\r\n\r\n    address public technology;\r\n\r\n    address public pgAddress;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public decimals = 18;\r\n    uint256 private fee; \r\n    uint256 private burnFee;\r\n    address private burnAddress;\r\n    uint256 public totalSupply;\r\n    address public owne;\r\n    address private incomeAddress;\r\n    uint256 private rabit;\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed from, uint256 value);\r\n    ControlContract udstContract;\r\n    constructor () public {\r\n        totalSupply = 2100 * 10 ** uint256(decimals); \r\n        orePooladdress = 0x963c8b87D298a157726DdFcf850945b73027E0dE;\r\n\r\n        platformAddress = 0x7960aC4fEb3e26b3f93225cc185Ef0a5c49c0E7C;\r\n\r\n        technology = 0xA61d15eD66d0Cf039A00EE87d8c7FB967058382c;\r\n\r\n        burnAddress = 0x0000000000000000000000000000000000000000;\r\n\r\n        balanceOf[orePooladdress] = totalSupply*80/100; \r\n\r\n        balanceOf[platformAddress] = totalSupply*12/100; \r\n\r\n        balanceOf[technology] = totalSupply*8/100; \r\n\r\n        burnAddress = 0x0000000000000000000000000000000000000000;\r\n   \r\n        name = \"Kinght Journey\";                             \r\n        symbol = \"KNT\";  \r\n        owne= msg.sender;        \r\n        rabit =3;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n             \r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to,_value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]); \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n\r\n    }\r\n    \r\n    function transferArray(address[] calldata _to, uint256[] calldata _value) public returns (bool success) {\r\n        for(uint256 i = 0; i < _to.length; i++){\r\n            _transfer(msg.sender, _to[i], _value[i]);\r\n        }\r\n        return true;\r\n    }\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }\r\n    function _rabit(uint256 _rabit) public returns (bool success) {\r\n        require(msg.sender == owne); \r\n        rabit  = _rabit;\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rabit\",\"type\":\"uint256\"}],\"name\":\"_rabit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orePooladdress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owne\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pgAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"technology\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"transferArray\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenKNT", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://db59eef99edfe89e4d86f7e20a34420e93e10caed51fef7ac704e751c02f6f89"}