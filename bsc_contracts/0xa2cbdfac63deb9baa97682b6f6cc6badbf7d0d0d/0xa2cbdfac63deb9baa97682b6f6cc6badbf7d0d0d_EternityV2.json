{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n}\r\n\r\n\r\n// safe transfer\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        // (bool success,) = to.call.value(value)(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n\r\n// Interface of the ERC20 standard as defined in the EIP.\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address from, address to) external view returns (uint256);\r\n    function approve(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\n// linkedin inferface\r\ninterface ILinkedin {\r\n    function mySuper(address user) external view returns (address);\r\n    function myJuniors(address user) external view returns (address[] memory);\r\n    function getSuperList(address user, uint256 list) external view returns (address[] memory);\r\n}\r\n\r\ninterface IEternityV1 {\r\n    function poolInfo(uint256 index) external view returns (PoolInfoV1 memory);\r\n    function userInfo(uint256 pid, address account) external view returns (UserInfoV1 memory);\r\n    function juniorMsg(uint256 pid, address account) external view returns (JuniorMsgV1 memory);\r\n}\r\nstruct PoolInfoV1 {\r\n    address token;                    // token address.\r\n    uint256 totalDepositAmount;       // token deposit in pool.\r\n    uint256 totalStaked;              // total staked. The current dividend amount shall be calculated once a day.\r\n    uint256 leastDepositAmount;       // least deposit amount.\r\n    uint256 luckyPoolEarnLimitAmount; // lucky pool earn limit.\r\n    uint256 nextRewardTime;           // next share time. The time of the next dividend, once a day\r\n    uint256 teamEarnCount;            // tean earn count.\r\n    uint256 teamEarnAmount;           // team earn amount.\r\n    uint256 teamEarnLimitAmount;      // team earn limit amount.\r\n    uint256 juniorAmount;             // junior amount condition.\r\n    uint256 userTokenPerShare;        // Accumulated Token per share, times SCALING_FACTOR. Check code.\r\n    bool isOpen;                      // is open.\r\n}\r\nstruct UserInfoV1 {\r\n    uint256 depositAmount;        // deposit amount.\r\n    uint256 takedAmount;          // already taked amount.\r\n    uint256 takeLimitAmount;      // taked amount limit.\r\n    uint256 rewardDebt;           // reward debt. Accumulated Token per share, times SCALING_FACTOR. Check code.\r\n    uint256 residueAmount;        // residue amount. release residue.\r\n    uint256 releaseStartTime;     // release start time.\r\n    uint256 releaseEndTime;       // release end time.\r\n}\r\nstruct JuniorMsgV1 {\r\n    address oneJunior;    // 1-3 juniro and amount.\r\n    address twoJunior;\r\n    address threeJunior;\r\n    uint256 oneAmount;\r\n    uint256 twoAmount;\r\n    uint256 threeAmount;\r\n}\r\n\r\n    \r\n\r\n// owner\r\nabstract contract Ownable {\r\n    address public owner = address(0);\r\n    address public oneAddress;\r\n\r\n    constructor() {\r\n        oneAddress = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == oneAddress, 'one address error');\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            oneAddress = newOwner;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// non reentrant\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// non contract\r\nabstract contract ContractGuard {\r\n\r\n    constructor() {}\r\n\r\n    modifier nonContract() {\r\n        require(!isContract(msg.sender), \"ContractGuard: not user1 error\");\r\n        require(tx.origin == msg.sender, \"ContractGuard: not user2 error\");\r\n        _;\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n}\r\n\r\n\r\n// eternity V2.\r\ncontract EternityV2 is Ownable, ReentrancyGuard, ContractGuard {\r\n    using SafeMath for uint256;\r\n    PoolInfoV1 public poolInfoV1;\r\n    UserInfoV1 public userInfoV1;\r\n    JuniorMsgV1 public juniorMsgV1;\r\n\r\n\r\n    // pid is deposit pool.\r\n    struct PoolInfo {\r\n        address token;                    // token address.\r\n        address earnToken;                // earn token.\r\n        uint256 totalDepositAmount;       // token deposit in pool.\r\n        uint256 totalStaked;              // total staked. The current dividend amount shall be calculated once a day.\r\n        uint256 leastDepositAmount;       // least deposit amount.\r\n        uint256 luckyPoolEarnLimitAmount; // lucky pool earn limit.\r\n        uint256 nextRewardTime;           // next share time. The time of the next dividend, once a day.\r\n        uint256 teamEarnCount;            // tean earn count.\r\n        uint256 teamEarnAmount;           // team earn amount.\r\n        uint256 teamEarnLimitAmount;      // team earn limit amount.\r\n        uint256 juniorAmount;             // junior amount condition.\r\n        uint256 userTokenPerShare;        // Accumulated Token per share, times SCALING_FACTOR. Check code.\r\n        bool isOpen;                      // is open.\r\n    }\r\n    PoolInfo[] public poolInfo;   // (index pid 0 start)\r\n    // user deposit. poolID => ID => msg.\r\n    mapping(uint256 => mapping(uint256 => UserInfo)) public userInfo;\r\n    struct UserInfo {\r\n        address ownerOf;              // account\r\n        uint256 depositAmount;        // deposit amount.\r\n        uint256 takedAmount;          // already taked amount.\r\n        uint256 takeLimitAmount;      // taked amount limit.\r\n        uint256 rewardDebt;           // reward debt. Accumulated Token per share, times SCALING_FACTOR. Check code.\r\n        uint256 residueAmount;        // residue amount. release residue.\r\n        uint256 releaseStartTime;     // release start time.\r\n        uint256 releaseEndTime;       // release end time.\r\n    }\r\n    // 30 day release dividend.\r\n    uint256 public releaseTime;\r\n    bool public allIsOpen = false;\r\n\r\n    // lucky pool\r\n    uint256 private constant LUCKY_SEATS = 50;        // Seats limit, default 50.\r\n    uint256 private immutable ONE_DAY_SECOND_NUMBER;  // mainnet=86400, testnet=60.\r\n    uint256 public luckyIntervalTime;                 // interval time\r\n    struct LuckyPool {\r\n        uint256 earnTotalAmount;                      // earn total amount.\r\n        uint256 expireTime;                           // expire time.\r\n        uint256 isState;                              // 1=underway, 2=poised, 3=complete.\r\n        uint256 luckyNextIndex;                       // next index, (0 start)\r\n    }\r\n    // (luck pool id 1 start)      \r\n    mapping(uint256 => mapping(uint256 => LuckyPool)) public luckyPool;                        // lucky pool.         pid => round => lucky pool infor\r\n    mapping(uint256 => mapping(uint256 => address[LUCKY_SEATS])) public luckyPoolAccounts;     // lucky address.      pid => round => luckyaddress\r\n    mapping(uint256 => uint256) public luckyPoolCount;                                         // lucky pool count.   pid => luck pool count\r\n    uint256 public luckyLastAddrssRatio = 3000;                                                // last address earn ratio. default. %%\r\n\r\n    // 0 = super ratio. 1 = super super ratio. 2 = super super super ratio. %%\r\n    uint256[3] public superRatio = [2000, 1000, 500];\r\n    // mining pool ratio. lucky pool ratio. team pool ratio. leader address ratio.  %%\r\n    uint256 public miningPoolRatio = 4000;\r\n    uint256 public luckyPoolRatio = 500;\r\n    uint256 public teamPoolRatio = 1500;\r\n    uint256 public leaderRatio = 500;\r\n    uint256 private constant RATIO_DENOMINATOR = 10000;   // denominator\r\n    uint256 private constant SCALING_FACTOR = 1e18;       // Scaling this up increases support for high supply tokens\r\n    // 2 mul earn limit.\r\n    uint256 public earnMul = 2;\r\n\r\n    // super earn condition.\r\n    mapping(uint256 => mapping(address => JuniorMsg)) public juniorMsg;   // pid => account => junior msg.\r\n    struct JuniorMsg {\r\n        address oneJunior;    // 1-3 juniro and amount.\r\n        address twoJunior;\r\n        address threeJunior;\r\n        uint256 oneAmount;\r\n        uint256 twoAmount;\r\n        uint256 threeAmount;\r\n    }\r\n\r\n    // linkedin. teamEarn. leader. leaderLucky.\r\n    address public linkedin;\r\n    address public leader;\r\n    address public leaderLucky;\r\n    // stLTC, coin\r\n    address public stLTC;\r\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    // twoAddress\r\n    address public twoAddress;                      // sign address.\r\n    mapping(uint256 => bool) public nonceUsed;      // nonce only one.\r\n\r\n    mapping(address => bool) public blackList;                          // black list.\r\n    uint256 public totalID;                                             // total ID.\r\n    mapping(uint256 => mapping(address => uint256)) public accountID;   // account ID. (if is 0 add ID, else default)\r\n    bool public isCanMoveData = true;                                   // is can move data\r\n    address public EternityV1;                                          // Eternity v1\r\n    struct PoolInfoThen {\r\n        address recycleToken;             // recycle token.\r\n        uint256 limitDepositAmount;       // limit deposit amount.\r\n        bool isOpen;\r\n    }\r\n    mapping(uint256 => PoolInfoThen) public poolInfoThen; // pool info then.\r\n    \r\n\r\n    constructor(\r\n        uint256 oneDaySecondNumber_,\r\n        address linkedin_,\r\n        address leader_,\r\n        address leaderLucky_,\r\n        address stLTC_,\r\n        address twoAddress_,\r\n        address EternityV1_\r\n    ) {\r\n        ONE_DAY_SECOND_NUMBER = oneDaySecondNumber_;     // mainnet=86400, testnet=60.\r\n        releaseTime = 30 * ONE_DAY_SECOND_NUMBER;        // default 30 day.\r\n        luckyIntervalTime = 3 * ONE_DAY_SECOND_NUMBER;   // default 3 day.\r\n\r\n        linkedin = linkedin_;\r\n        leader = leader_;\r\n        leaderLucky = leaderLucky_;\r\n        stLTC = stLTC_;\r\n\r\n        twoAddress = twoAddress_;\r\n        EternityV1 = EternityV1_;\r\n    }\r\n\r\n\r\n    event Mining(uint256 pid, address token, address account, uint256 amount, uint256 surplus);\r\n    event UserTake(uint256 pid, address token, address account, uint256 amount);\r\n    event TeamEarn(uint256 pid, address token, uint256 count, uint256 amount);\r\n    event SuperEarn(uint256 pid, address token, address account, address superAddress, uint256 amount);\r\n    event BackendTransferToken(uint256 pid, address token, address user, uint256 amount, uint256 nonce);\r\n\r\n    event CreatedAccountID(address account, uint256 userID);\r\n    \r\n\r\n    // set releaseTime.\r\n    function setReleaseTime(uint256 dayNumber) external onlyOwner {\r\n        require(dayNumber > 0 && dayNumber <= 100, \"Eternity-setReleaseTime: day number error\");\r\n        releaseTime = dayNumber * ONE_DAY_SECOND_NUMBER;\r\n    }\r\n\r\n    // set allIsOpen.\r\n    function setAllIsOpen(bool newAllIsOpen) external onlyOwner {\r\n        allIsOpen = newAllIsOpen;\r\n    }\r\n\r\n    // add pool.\r\n    function addPool(\r\n        address token, \r\n        address earnToken,\r\n        uint256 leastDepositAmount,\r\n        uint256 luckyPoolEarnLimitAmount,\r\n        uint256 teamEarnLimitAmount,\r\n        uint256 juniorAmount\r\n    ) external onlyOwner {\r\n        require(token != address(0), \"Eternity-addPool: token is zaro address error\");\r\n        require(earnToken != address(0), \"Eternity-addPool: earn token is zaro address error\");\r\n        require(leastDepositAmount > 0, \"Eternity-addPool: least depoist amount is zero error\");\r\n        require(luckyPoolEarnLimitAmount > 0, \"Eternity-addPool: lucky pool earn limit amount is zero error\");\r\n        _startNewLuckPool(poolInfo.length, 0, address(0));\r\n\r\n        // add pool\r\n        poolInfo.push(PoolInfo({\r\n            token: token,\r\n            earnToken: earnToken,\r\n            totalDepositAmount: 0,\r\n            totalStaked: 0,\r\n            leastDepositAmount: leastDepositAmount,\r\n            luckyPoolEarnLimitAmount: luckyPoolEarnLimitAmount,\r\n            nextRewardTime: block.timestamp.add(ONE_DAY_SECOND_NUMBER),\r\n            teamEarnCount: 0,\r\n            teamEarnAmount: 0,\r\n            teamEarnLimitAmount: teamEarnLimitAmount,\r\n            juniorAmount: juniorAmount,\r\n            userTokenPerShare: 0,\r\n            isOpen: true\r\n        }));\r\n    }\r\n\r\n    // change pool.\r\n    function changePool(\r\n        uint256 pid, \r\n        address token, \r\n        address earnToken,\r\n        uint256 leastDepositAmount, \r\n        uint256 luckyPoolEarnLimitAmount, \r\n        uint256 teamEarnLimitAmount, \r\n        uint256 juniorAmount,\r\n        bool isOpen2\r\n    ) external onlyOwner {\r\n        PoolInfo storage _PoolInfo = poolInfo[pid];\r\n        _PoolInfo.token = token;\r\n        _PoolInfo.earnToken = earnToken;\r\n\r\n        _PoolInfo.leastDepositAmount = leastDepositAmount;\r\n        _PoolInfo.luckyPoolEarnLimitAmount = luckyPoolEarnLimitAmount;\r\n        _PoolInfo.teamEarnLimitAmount = teamEarnLimitAmount;\r\n        _PoolInfo.juniorAmount = juniorAmount;\r\n        _PoolInfo.isOpen = isOpen2;\r\n    }\r\n    function changePool2(\r\n        uint256 pid, \r\n        uint256 totalDepositAmount, \r\n        uint256 totalStaked,\r\n        uint256 nextRewardTime, \r\n        uint256 teamEarnCount, \r\n        uint256 teamEarnAmount, \r\n        uint256 userTokenPerShare\r\n    ) external onlyOwner {\r\n        PoolInfo storage _PoolInfo = poolInfo[pid];\r\n\r\n        _PoolInfo.totalDepositAmount = totalDepositAmount;\r\n        _PoolInfo.totalStaked = totalStaked;\r\n        _PoolInfo.nextRewardTime = nextRewardTime;\r\n        _PoolInfo.teamEarnCount = teamEarnCount;\r\n        _PoolInfo.teamEarnAmount = teamEarnAmount;\r\n        _PoolInfo.userTokenPerShare = userTokenPerShare;\r\n    }\r\n\r\n    function setPoolThen(uint256 pid, address recycleToken, uint256 limitDepositAmount, bool isOpen2) external onlyOwner {\r\n        require(recycleToken != address(0), \"0 address error\");\r\n        require(limitDepositAmount > 0, \"0 amount error\");\r\n\r\n        poolInfoThen[pid].recycleToken = recycleToken;\r\n        poolInfoThen[pid].limitDepositAmount = limitDepositAmount;\r\n        poolInfoThen[pid].isOpen = isOpen2;\r\n    }\r\n\r\n    // new a luck pool.\r\n    function _startNewLuckPool(uint256 pid, uint256 amount, address firstAccount) private {\r\n        luckyPoolCount[pid]++;\r\n        LuckyPool storage _LuckyPool = luckyPool[pid][luckyPoolCount[pid]];\r\n        _LuckyPool.earnTotalAmount = amount;\r\n        _LuckyPool.expireTime = block.timestamp.add(luckyIntervalTime);\r\n        _LuckyPool.isState = 1;\r\n        if(firstAccount != address(0)) {\r\n            luckyPoolAccounts[pid][luckyPoolCount[pid]][0] = firstAccount;\r\n            _LuckyPool.luckyNextIndex = 1;\r\n        }\r\n    }\r\n\r\n    // get all pool\r\n    function getAllPool() external view returns(PoolInfo[] memory) {\r\n        return poolInfo;\r\n    }\r\n\r\n    // git pid all lucky pool\r\n    function getAllLuckyPool(uint256 pid) external view returns(LuckyPool[] memory) {\r\n        uint256 _length = luckyPoolCount[pid];\r\n        LuckyPool[] memory _LuckyPool = new LuckyPool[](_length);\r\n        for(uint256 i = 0; i < _length; i++) {\r\n            _LuckyPool[i] = luckyPool[pid][i+1];\r\n        }\r\n        return _LuckyPool;\r\n    }\r\n\r\n    // set luckyIntervalTime.\r\n    function setLuckyIntervalTime(uint256 dayNumber) external onlyOwner {\r\n        require(dayNumber > 0 && dayNumber <= 30, \"Eternity-setLuckyIntervalTime: day number error\");\r\n        luckyIntervalTime = dayNumber * ONE_DAY_SECOND_NUMBER;\r\n    }\r\n\r\n    // set luckyLastAddrssRatio.\r\n    function setLuckyLastAddrssRatio(uint256 newLuckyLastAddrssRatio) external onlyOwner {\r\n        require(newLuckyLastAddrssRatio > 0 && newLuckyLastAddrssRatio < 10000, \"Eternity-setLuckyLastAddrssRatio: ratio error\");\r\n        luckyLastAddrssRatio = newLuckyLastAddrssRatio;\r\n    }\r\n\r\n    // set all ratio.\r\n    function setAllRatio(uint256[7] memory allRatio) external onlyOwner {\r\n        uint256 _total;\r\n        for(uint256 i = 0; i < 7; i++) {\r\n            _total += allRatio[i];\r\n        }\r\n        require(_total == 10000, \"Eternity-setAllRatio: ratio total error\");\r\n        superRatio[0] = allRatio[0];\r\n        superRatio[1] = allRatio[1];\r\n        superRatio[2] = allRatio[2];\r\n        miningPoolRatio = allRatio[3];\r\n        luckyPoolRatio = allRatio[4];\r\n        teamPoolRatio = allRatio[5];\r\n        leaderRatio = allRatio[6];\r\n    }\r\n\r\n    // set earnMul.\r\n    function setEarnMul(uint256 newEarnMul) external onlyOwner {\r\n        require(newEarnMul > 0, \"Eternity-setEarnMul: earnMul error\");\r\n        earnMul = newEarnMul;\r\n    }\r\n\r\n    // set linkedin.\r\n    function setLinkedin(address newLinkedin) external onlyOwner {\r\n        require(newLinkedin != address(0), \"Eternity-setLinkedin: address error\");\r\n        linkedin = newLinkedin;\r\n    }\r\n\r\n    // set leader.\r\n    function setLeader(address newLeader) external onlyOwner {\r\n        require(newLeader != address(0), \"Eternity-setLeader: address error\");\r\n        leader = newLeader;\r\n    }\r\n\r\n    // set leader lucky.\r\n    function setLeaderLucky(address newLeaderLucky) external onlyOwner {\r\n        require(newLeaderLucky != address(0), \"Eternity-newLeaderLucky: address error\");\r\n        leaderLucky = newLeaderLucky;\r\n    }\r\n\r\n    // set stLTC.\r\n    function setStLTC(address newStLTC) external onlyOwner {\r\n        require(newStLTC != address(0), \"Eternity-setStLTC: address error\");\r\n        stLTC = newStLTC;\r\n    }\r\n\r\n    // set blackList\r\n    function setBlackList(address account, bool isBlack) external onlyOwner {\r\n        require(account != address(0), \"Eternity-setStLTC: address error\");\r\n        blackList[account] = isBlack;\r\n    }\r\n\r\n    // set isCanMoveData\r\n    function setIsCanMoveData(bool newIsCanMoveData) external onlyOwner {\r\n        isCanMoveData = newIsCanMoveData;\r\n    }\r\n    \r\n    // git pid lucky pool account.\r\n    function getLuckyPoolAccount(uint256 pid, uint256 luckyPoolID) external view returns(address[LUCKY_SEATS] memory) {\r\n        return luckyPoolAccounts[pid][luckyPoolID];\r\n    }\r\n\r\n    // user deposit.\r\n    function deposit(uint256 pid, uint256 amount) external payable nonReentrant nonContract {\r\n        if(isCanMoveData) {\r\n            // if can move data. then only move data.\r\n            _moveData(pid);\r\n            return;\r\n        }\r\n\r\n        address msg_sender = msg.sender;\r\n        PoolInfo storage _PoolInfo = poolInfo[pid];\r\n        require(!blackList[msg_sender], \"Eternity-deposit: is black list\");\r\n        require(allIsOpen, \"Eternity-deposit: not all open\");\r\n        require(_PoolInfo.isOpen, \"Eternity-deposit: not open\");\r\n        require(amount >= _PoolInfo.leastDepositAmount, \"Eternity-deposit: amount least error\");\r\n\r\n        if(_PoolInfo.token == ETH) {\r\n            // is bnb.\r\n            require(msg.value == amount, \"Eternity-deposit: amount and value is error\");\r\n        }else {\r\n            // is token.\r\n            TransferHelper.safeTransferFrom(_PoolInfo.token, msg_sender, address(this), amount);\r\n        }\r\n\r\n        // is created order\r\n        if(accountID[pid][msg_sender] == 0) _createdAccountID(pid, msg_sender);\r\n\r\n        // amount .\r\n        uint256 minging_amount = amount.mul(miningPoolRatio).div(RATIO_DENOMINATOR);\r\n        uint256 lucky_amount = amount.mul(luckyPoolRatio).div(RATIO_DENOMINATOR);\r\n        uint256 team_amount = amount.mul(teamPoolRatio).div(RATIO_DENOMINATOR);\r\n        uint256 leader_amount = amount.mul(leaderRatio).div(RATIO_DENOMINATOR);\r\n\r\n        // user.\r\n        _userEarn(pid, msg_sender, amount, minging_amount);\r\n        // mining.\r\n        _updatePool(pid, minging_amount); // 0.5\r\n        // lucky.\r\n        _luckyPool(pid, lucky_amount, msg_sender);\r\n        // team.\r\n        _teamEarn(pid, team_amount);\r\n\r\n        // super.\r\n        if(_PoolInfo.token != stLTC) _superEarn(pid, msg_sender, amount);\r\n\r\n        // leader.\r\n        if(leader_amount > 0) _transferTokenOrETH(_PoolInfo.earnToken, leader, leader_amount);\r\n    }\r\n\r\n    // mass update pools\r\n    function massUpdatePools() external nonReentrant nonContract {\r\n        uint256 _length = poolInfo.length;\r\n        for (uint256 i = 0; i < _length; i++) {\r\n            _updatePool(i, 0);\r\n        }\r\n    }\r\n\r\n    // update pool\r\n    function updatePool(uint256 pid) external nonReentrant nonContract {\r\n        _updatePool(pid, 0);\r\n    }\r\n\r\n    function _updatePool(uint256 pid, uint256 amount) private {\r\n        PoolInfo storage _PoolInfo = poolInfo[pid];\r\n        if (block.timestamp <= _PoolInfo.nextRewardTime) {\r\n            // not reward time || not reward\r\n            _PoolInfo.totalStaked += amount;\r\n            _PoolInfo.totalDepositAmount += amount;\r\n            return;\r\n        }\r\n        if(_PoolInfo.totalStaked != 0) {\r\n            uint256 add_per = _PoolInfo.totalStaked.mul(SCALING_FACTOR).div(_PoolInfo.totalDepositAmount);\r\n            _PoolInfo.userTokenPerShare += add_per;\r\n        }\r\n        _PoolInfo.totalStaked = amount;\r\n        _PoolInfo.totalDepositAmount += amount;\r\n        _PoolInfo.nextRewardTime = block.timestamp.add(ONE_DAY_SECOND_NUMBER);\r\n    }\r\n\r\n    // pending token\r\n    function pendingToken(uint256 pid, address account) public view returns (uint256, uint256) {\r\n        PoolInfo memory _PoolInfo = poolInfo[pid];\r\n        uint256 _ID = accountID[pid][account];\r\n        UserInfo memory _UserInfo = userInfo[pid][_ID];\r\n        if(_UserInfo.depositAmount == 0) return (0, 0);\r\n        uint256 amount = _UserInfo.depositAmount.mul(_PoolInfo.userTokenPerShare).div(SCALING_FACTOR).sub(_UserInfo.rewardDebt);\r\n        amount = amount + _UserInfo.residueAmount;\r\n        if(amount == 0 ) return (0, 0);\r\n\r\n        // 30 day release dividend.\r\n        if(block.timestamp >= _UserInfo.releaseEndTime) {\r\n            return (amount, amount);\r\n        }\r\n        uint256 _totalReleaseTime = _UserInfo.releaseEndTime - _UserInfo.releaseStartTime;\r\n        uint256 _perTimeAmount = amount.mul(1e10).div(_totalReleaseTime);\r\n        uint256 take_amount = block.timestamp.sub(_UserInfo.releaseStartTime).mul(_perTimeAmount).div(1e10);\r\n        // amount=total eran. take_amount=now can take earn.\r\n        return (amount, take_amount);\r\n    }\r\n\r\n    function _userTake(uint256 pid, address account) private {\r\n        uint256 _ID = accountID[pid][account];\r\n        UserInfo storage _UserInfo = userInfo[pid][_ID];\r\n        (uint256 _amount, uint256 take_amount) = pendingToken(pid, account);\r\n        take_amount = _UserInfo.takedAmount + take_amount > _UserInfo.takeLimitAmount ? _UserInfo.takeLimitAmount - _UserInfo.takedAmount : take_amount;\r\n\r\n        if(take_amount > 0) _transferTokenOrETH(poolInfo[pid].earnToken, account, take_amount);\r\n        _UserInfo.takedAmount += take_amount;\r\n        _UserInfo.residueAmount = _amount.sub(take_amount);\r\n        emit UserTake(pid, poolInfo[pid].earnToken, account, take_amount);\r\n    }\r\n\r\n    // user earn.\r\n    function _userEarn(uint256 pid, address account, uint256 amount, uint256 depositAmount) private {\r\n        _userTake(pid, account);\r\n\r\n        uint256 _ID = accountID[pid][account];\r\n        UserInfo storage _UserInfo = userInfo[pid][_ID];\r\n        _UserInfo.takeLimitAmount += amount.mul(earnMul);\r\n        uint256 _partAmount = depositAmount / 2;\r\n        _UserInfo.depositAmount += _partAmount;\r\n        _UserInfo.residueAmount += _partAmount;\r\n        _UserInfo.rewardDebt = _UserInfo.depositAmount.mul(poolInfo[pid].userTokenPerShare).div(SCALING_FACTOR);\r\n        _UserInfo.releaseStartTime = block.timestamp;\r\n        _UserInfo.releaseEndTime = block.timestamp + releaseTime;\r\n\r\n        emit Mining(pid, poolInfo[pid].token, account, depositAmount, _UserInfo.depositAmount);\r\n        // verify limit depost.\r\n        require(_UserInfo.depositAmount <= poolInfoThen[pid].limitDepositAmount, \"deposit limit amount\");\r\n    }\r\n\r\n    // lucky pool.\r\n    function _luckyPool(uint256 pid, uint256 amount, address account) private {\r\n        LuckyPool storage _LuckyPool = luckyPool[pid][luckyPoolCount[pid]];\r\n\r\n        // is expire.\r\n        if(block.timestamp > _LuckyPool.expireTime) {\r\n            // now lucky pool is poised. start new lucky pool.\r\n            _LuckyPool.isState = 2;\r\n            _startNewLuckPool(pid, amount, account);\r\n        }else {\r\n            // add pool amount. lengthen time. add lucky account address.\r\n            _LuckyPool.earnTotalAmount = _LuckyPool.earnTotalAmount.add(amount);\r\n            _LuckyPool.expireTime = block.timestamp.add(luckyIntervalTime);\r\n            uint256 _nowLuckyIndex = _LuckyPool.luckyNextIndex >= LUCKY_SEATS ? 0 : _LuckyPool.luckyNextIndex;\r\n            luckyPoolAccounts[pid][luckyPoolCount[pid]][_nowLuckyIndex] = account;\r\n            _LuckyPool.luckyNextIndex = _nowLuckyIndex + 1;\r\n            if(_LuckyPool.earnTotalAmount >= poolInfo[pid].luckyPoolEarnLimitAmount) {\r\n                // take 50%.\r\n                uint256 _newEarnTotalAmount = _LuckyPool.earnTotalAmount.div(2);\r\n                if(_newEarnTotalAmount > 0) _transferTokenOrETH(poolInfo[pid].earnToken, leaderLucky, _newEarnTotalAmount);\r\n                _LuckyPool.earnTotalAmount = _newEarnTotalAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    // team earn.\r\n    function _teamEarn(uint256 pid, uint256 amount) private {\r\n        PoolInfo storage _PoolInfo = poolInfo[pid];\r\n        _PoolInfo.teamEarnAmount += amount;\r\n        if(_PoolInfo.teamEarnAmount >= _PoolInfo.teamEarnLimitAmount) {\r\n            _PoolInfo.teamEarnCount++;\r\n            emit TeamEarn(pid, _PoolInfo.earnToken, _PoolInfo.teamEarnCount, _PoolInfo.teamEarnAmount);\r\n            _PoolInfo.teamEarnAmount = 0;\r\n        }\r\n    }\r\n\r\n    // super earn.\r\n    function _superEarn(uint256 pid, address account, uint256 amount) private {\r\n        address[] memory super_three  = ILinkedin(linkedin).getSuperList(account, 3);\r\n        require(super_three.length == 3, \"Eternity-_superEarn: super list error\");\r\n        address _earnToken = poolInfo[pid].earnToken;\r\n\r\n        // update condition.\r\n        _juniorRecord(pid, account, super_three[0]);\r\n\r\n        uint256 super_amount;\r\n        for(uint256 i = 0; i < 3; i++) {\r\n            super_amount =  amount.mul(superRatio[i]).div(RATIO_DENOMINATOR);\r\n            if(super_three[i] != address(0)) {\r\n                if(_superTakeVerify(pid, super_three[i], i)) {\r\n                    uint256 _ID = accountID[pid][super_three[i]];\r\n                    UserInfo storage _UserInfo = userInfo[pid][_ID];\r\n                    super_amount = _UserInfo.takedAmount + super_amount > _UserInfo.takeLimitAmount ? _UserInfo.takeLimitAmount - _UserInfo.takedAmount : super_amount;\r\n                    _UserInfo.takedAmount = _UserInfo.takedAmount + super_amount;\r\n                    if(super_amount > 0) _transferTokenOrETH(_earnToken, super_three[i], super_amount);\r\n                    emit SuperEarn(pid, _earnToken, account, super_three[i], super_amount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // is min.\r\n    function _isMin(uint256 a, uint256 b, uint256 c) private pure returns(uint256) {\r\n        if (a <= b && a <= c) {\r\n            return a;\r\n        } else if (b <= a && b <= c) {\r\n            return b;\r\n        } else {\r\n            return c;\r\n        }\r\n    }\r\n\r\n    // junior record.\r\n    function _juniorRecord(uint256 pid, address account, address superAddress) private {\r\n        uint256 _ID = accountID[pid][account];\r\n        UserInfo memory _UserInfo = userInfo[pid][_ID];\r\n        JuniorMsg storage _JuniorMsg = juniorMsg[pid][superAddress];\r\n\r\n        uint256 min_number = _isMin(_JuniorMsg.oneAmount, _JuniorMsg.twoAmount, _JuniorMsg.threeAmount);\r\n        if(_UserInfo.depositAmount <= min_number) return;\r\n        if(account == _JuniorMsg.oneJunior) {\r\n            _JuniorMsg.oneAmount = _UserInfo.depositAmount;\r\n        }else if(account == _JuniorMsg.twoJunior) {\r\n            _JuniorMsg.twoAmount = _UserInfo.depositAmount;\r\n        }else if(account == _JuniorMsg.threeJunior) {\r\n            _JuniorMsg.threeAmount = _UserInfo.depositAmount;\r\n        }else {\r\n            if(_JuniorMsg.oneAmount == min_number) {\r\n                _JuniorMsg.oneJunior = account;\r\n                _JuniorMsg.oneAmount = _UserInfo.depositAmount;\r\n            }else if(_JuniorMsg.twoAmount == min_number) {\r\n                _JuniorMsg.twoJunior = account;\r\n                _JuniorMsg.twoAmount = _UserInfo.depositAmount;\r\n            }else {\r\n                _JuniorMsg.threeJunior = account;\r\n                _JuniorMsg.threeAmount = _UserInfo.depositAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    // super take verify.\r\n    // rank is 0-2, corresponding 1-3.\r\n    function _superTakeVerify(uint256 pid, address superAddress, uint256 rankIndex) private view returns(bool) {\r\n        PoolInfo memory _PoolInfo = poolInfo[pid];\r\n        JuniorMsg memory _JuniorMsg = juniorMsg[pid][superAddress];\r\n        uint256 _amount = _PoolInfo.juniorAmount;\r\n        uint256 _count = 0;\r\n        if(_JuniorMsg.oneAmount >= _amount) {\r\n            _count++;\r\n        }\r\n        if(_JuniorMsg.twoAmount >= _amount) {\r\n            _count++;\r\n        }\r\n        if(_JuniorMsg.threeAmount >= _amount) {\r\n            _count++;\r\n        }\r\n\r\n        if(rankIndex == 0) {\r\n            return _count >= 1;\r\n        }else if(rankIndex == 1) {\r\n            return _count >= 2;\r\n        }else {\r\n            return _count >= 3;\r\n        }\r\n    }\r\n\r\n    // user withdraw.\r\n    function withdraw(uint256 pid) external nonReentrant nonContract {\r\n        address msg_sender = msg.sender;\r\n        require(allIsOpen, \"Eternity-withdraw: not all open\");\r\n        require(!blackList[msg_sender], \"Eternity-withdraw: is black list\");\r\n        _userTake(pid, msg_sender);\r\n        uint256 _ID = accountID[pid][msg_sender];\r\n        UserInfo storage _UserInfo = userInfo[pid][_ID];\r\n        \r\n        _UserInfo.rewardDebt = _UserInfo.depositAmount.mul(poolInfo[pid].userTokenPerShare).div(SCALING_FACTOR);\r\n        _UserInfo.releaseStartTime = block.timestamp;\r\n    }\r\n\r\n    // anybody can give lucky pool earn\r\n    function anybodyLuckyPoolEarn(uint256 pid, uint256 luckyPoolID) external nonReentrant nonContract {\r\n        LuckyPool storage _LuckyPool = luckyPool[pid][luckyPoolID];\r\n        require(_LuckyPool.isState == 2, \"Eternity-anybodyLuckyPoolEarn: state error\");\r\n        require(_LuckyPool.earnTotalAmount > 0, \"Eternity-anybodyLuckyPoolEarn: amount1 error\");\r\n        _LuckyPool.isState = 3;\r\n\r\n        address _earnToken = poolInfo[pid].earnToken;\r\n        // luckyLastAddrssRatio\r\n        uint256 _soLuckyIndex = _LuckyPool.luckyNextIndex == 0 ? LUCKY_SEATS - 1 : _LuckyPool.luckyNextIndex - 1;\r\n        uint256 _soLuckyAmount = _LuckyPool.earnTotalAmount.mul(luckyLastAddrssRatio).div(RATIO_DENOMINATOR);\r\n        uint256 _luckAmount = _LuckyPool.earnTotalAmount.sub(_soLuckyAmount).div((LUCKY_SEATS - 1));\r\n        require(_soLuckyAmount > 0, \"Eternity-anybodyLuckyPoolEarn: amount2 error\");\r\n        require(_luckAmount > 0, \"Eternity-anybodyLuckyPoolEarn: amount3 error\");\r\n\r\n        address[LUCKY_SEATS] memory _luckyAccounts = luckyPoolAccounts[pid][luckyPoolID];\r\n        for(uint256 i = 0; i < _luckyAccounts.length; i++) {\r\n            if(i == _soLuckyIndex) {\r\n                if(_luckyAccounts[i] != address(0) && _soLuckyAmount > 0) _transferTokenOrETH(_earnToken, _luckyAccounts[i], _soLuckyAmount);\r\n            }else {\r\n                if(_luckyAccounts[i] != address(0) && _luckAmount > 0) _transferTokenOrETH(_earnToken, _luckyAccounts[i], _luckAmount);\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    // set twoAddress_.\r\n    function setTwoAddress(address newTwoAddress_) public onlyOwner {\r\n        require(newTwoAddress_ != address(0), \"0 address error\");\r\n        twoAddress = newTwoAddress_;\r\n    }\r\n\r\n    // set nonce is true\r\n    function setNonceUsed(uint256 nonce) public onlyOwner {\r\n        nonceUsed[nonce] = true;\r\n    }\r\n\r\n    // sign take token.\r\n    // data: (this contract address, pid, token address, user address, token amount, random nonce).\r\n    function backendTransferToken(uint256 _pid,address _token,address _to,uint256 _amount,uint256 _nonce,bytes memory _signature) external nonReentrant nonContract {\r\n        require(allIsOpen, \"not is open\");\r\n        // only myself\r\n        require(msg.sender == _to, \"not you\");\r\n        //require(!blackList[_to], \"Eternity-backendTransferToken: is black list\");\r\n\r\n        bytes32 hashData = keccak256(abi.encodePacked(address(this),_pid,_token,_to,_amount,_nonce));\r\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hashData));\r\n        address signer = recoverSigner(messageHash, _signature);\r\n        require(signer == twoAddress, \"Signer is not two address\");\r\n        require(signer != address(0), \"Signer is 0 address\");\r\n        require(!nonceUsed[_nonce], \"nonce used\");\r\n        nonceUsed[_nonce] = true;\r\n\r\n        // transfer\r\n        _transferTokenOrETH(_token, _to, _amount);\r\n        // emit\r\n        emit BackendTransferToken(_pid, _token, _to, _amount, _nonce);\r\n\r\n        // amount limit\r\n        uint256 _ID = accountID[_pid][_to];\r\n        UserInfo storage _UserInfo = userInfo[_pid][_ID];\r\n        require(_UserInfo.takeLimitAmount >= _UserInfo.takedAmount.add(_amount), \"Eternity-backendTransferToken: earm limit error\");\r\n        _UserInfo.takedAmount = _UserInfo.takedAmount.add(_amount);\r\n    }\r\n\r\n    function recoverSigner(bytes32 message, bytes memory sig) internal pure returns (address) {\r\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\r\n        return ecrecover(message, v, r, s);\r\n    }\r\n\r\n    function splitSignature(bytes memory sig) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\r\n        require(sig.length == 65);\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        return (v, r, s);\r\n    }\r\n\r\n    // take token.\r\n    function takeToken(address _token, address _to , uint256 _value) external onlyOwner {\r\n        require(_to != address(0), \"zero address error\");\r\n        require(_value > 0, \"value zero error\");\r\n        TransferHelper.safeTransfer(_token, _to, _value);\r\n    }\r\n\r\n    // receive eth\r\n    receive() external payable {}\r\n\r\n    // take eth.\r\n    function takeETH(address _to, uint256 _value) public onlyOwner {\r\n        require(_to != address(0), \"zero address error\");\r\n        require(_value > 0, \"value zero error\");\r\n        TransferHelper.safeTransferETH(_to, _value);\r\n    }\r\n\r\n    // transfer \r\n    function _transferTokenOrETH(address _token, address _to, uint256 _value) private {\r\n        if(_token == ETH) {\r\n            // if 0xeeee.. transfer bnb\r\n            TransferHelper.safeTransferETH(_to, _value);\r\n        }else {\r\n            TransferHelper.safeTransfer(_token, _to, _value);\r\n        }\r\n    }\r\n\r\n    // created account ID\r\n    function _createdAccountID(uint256 _pid, address _account) private returns(uint256) {\r\n        totalID++;\r\n        accountID[_pid][_account] = totalID;\r\n        userInfo[_pid][totalID].ownerOf = _account;\r\n\r\n        emit CreatedAccountID(_account, totalID);\r\n        return totalID;\r\n    }\r\n\r\n    // account ID transfer\r\n    function transferAccountID(uint256 _pid, address _newOwnerOf) public nonReentrant nonContract {\r\n        require(!blackList[msg.sender], \"Eternity-transferAccountID: is black list\");\r\n        require(allIsOpen, \"Eternity-transferAccountID: not all open\");\r\n        \r\n\r\n        address msg_sender = msg.sender;\r\n        uint256 _ID = accountID[_pid][msg_sender];\r\n        UserInfo storage _UserInfo = userInfo[_pid][_ID];\r\n        require(_ID != 0, \"Eternity-transferAccountID: zero error\");\r\n        require(_UserInfo.ownerOf == msg_sender, \"Eternity-transferAccountID: not your\");\r\n\r\n        uint256 _ID2 = accountID[_pid][_newOwnerOf];\r\n        require(_ID2 == 0, \"Eternity-transferAccountID: zero error 2\"); // new owner must not order\r\n\r\n        // transfer account ID\r\n        userInfo[_pid][_ID].ownerOf = _newOwnerOf;\r\n        accountID[_pid][_newOwnerOf] = _ID;\r\n        delete accountID[_pid][msg_sender];\r\n    }\r\n\r\n    // recycleToken\r\n    function recycleOrder(uint256 _pid) public nonReentrant nonContract {\r\n        require(!blackList[msg.sender], \"Eternity-recycleOrder: is black list\");\r\n        require(allIsOpen, \"Eternity-recycleOrder not all open\");\r\n\r\n        address msg_sender = msg.sender;\r\n        uint256 _ID = accountID[_pid][msg_sender];\r\n        UserInfo storage _UserInfo = userInfo[_pid][_ID];\r\n        require(_ID != 0, \"Eternity-recycleOrder: zero error\");\r\n        require(_UserInfo.ownerOf == msg_sender, \"Eternity-recycleOrder: not your\");\r\n\r\n        (uint256 _amount, ) = pendingToken(_pid, msg_sender);\r\n        // pool sub.\r\n        PoolInfo storage _PoolInfo = poolInfo[_pid];\r\n        _PoolInfo.totalDepositAmount = _PoolInfo.totalDepositAmount - _UserInfo.depositAmount;\r\n        // delete order\r\n        delete userInfo[_pid][_ID];\r\n        delete accountID[_pid][msg_sender];\r\n\r\n        // transfer\r\n        PoolInfoThen memory _PoolInfoThen = poolInfoThen[_pid];\r\n        require(_PoolInfoThen.isOpen, \"Eternity-recycleOrder: not open then\");\r\n        require(_PoolInfoThen.recycleToken != address(0), \"Eternity-recycleOrder: zero address then\");\r\n        _transferTokenOrETH(_PoolInfoThen.recycleToken, msg_sender, _amount);\r\n    }\r\n\r\n    // owner set account order.\r\n    function setAccountOrder(uint256 _pid, address _account, uint256 _takeLimitAmount, uint256 _residueAmount, uint256 _releaseEndTime) public onlyOwner {\r\n        require(_account != address(0), \"zero address error\");\r\n        uint256 _ID = accountID[_pid][_account];\r\n        UserInfo storage _UserInfo = userInfo[_pid][_ID];\r\n        require(_ID != 0, \"Eternity-setAccountOrder: zero error\");\r\n        require(_UserInfo.ownerOf == _account, \"Eternity-setAccountOrder: not your\");\r\n        require(_releaseEndTime >= block.timestamp, \"Eternity-setAccountOrder: time error\");\r\n        \r\n        _UserInfo.takeLimitAmount  = _takeLimitAmount;\r\n        _UserInfo.residueAmount = _residueAmount;\r\n        _UserInfo.releaseEndTime = _releaseEndTime;\r\n    }\r\n\r\n    // move data\r\n    function _moveData(uint256 pid) private {\r\n        require(isCanMoveData, \"Eternity-moveData: not move\");\r\n        require(poolInfo[pid].isOpen, \"Eternity-moveData: pool not open\");\r\n        address msg_sender = msg.sender;\r\n        UserInfoV1 memory _UserInfoV1 = IEternityV1(EternityV1).userInfo(pid, msg_sender);\r\n\r\n        uint256 _ID = accountID[pid][msg_sender];\r\n        require(_ID == 0, \"Eternity-moveData: must not id\");\r\n        uint256 _newID = _createdAccountID(pid, msg_sender);\r\n        // deposit\r\n        UserInfo storage _UserInfo = userInfo[pid][_newID];\r\n        _UserInfo.depositAmount = _UserInfoV1.depositAmount;\r\n        _UserInfo.takedAmount = _UserInfoV1.takedAmount;\r\n        _UserInfo.takeLimitAmount = _UserInfoV1.takeLimitAmount;\r\n        _UserInfo.rewardDebt = _UserInfoV1.rewardDebt;\r\n        _UserInfo.residueAmount = _UserInfoV1.residueAmount;\r\n        _UserInfo.releaseStartTime = _UserInfoV1.releaseStartTime;\r\n        _UserInfo.releaseEndTime = _UserInfoV1.releaseEndTime;\r\n\r\n        // junior msg\r\n        JuniorMsgV1 memory _JuniorMsgV1 = IEternityV1(EternityV1).juniorMsg(pid, msg_sender);\r\n        JuniorMsg storage _JuniorMsg = juniorMsg[pid][msg_sender];\r\n        _JuniorMsg.oneJunior = _JuniorMsgV1.oneJunior;\r\n        _JuniorMsg.twoJunior = _JuniorMsgV1.twoJunior;\r\n        _JuniorMsg.threeJunior = _JuniorMsgV1.threeJunior;\r\n        _JuniorMsg.oneAmount = _JuniorMsgV1.oneAmount;\r\n        _JuniorMsg.twoAmount = _JuniorMsgV1.twoAmount;\r\n        _JuniorMsg.threeAmount = _JuniorMsgV1.threeAmount;\r\n    } \r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"oneDaySecondNumber_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"linkedin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leader_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leaderLucky_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stLTC_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"twoAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"EternityV1_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"BackendTransferToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"}],\"name\":\"CreatedAccountID\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"}],\"name\":\"Mining\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"superAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SuperEarn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TeamEarn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UserTake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EternityV1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"earnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"leastDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckyPoolEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorAmount\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allIsOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckyPoolID\",\"type\":\"uint256\"}],\"name\":\"anybodyLuckyPoolEarn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"backendTransferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"earnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"leastDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckyPoolEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpen2\",\"type\":\"bool\"}],\"name\":\"changePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userTokenPerShare\",\"type\":\"uint256\"}],\"name\":\"changePool2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earnMul\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"getAllLuckyPool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"earnTotalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"isState\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckyNextIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct EternityV2.LuckyPool[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPool\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"earnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leastDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckyPoolEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"internalType\":\"struct EternityV2.PoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckyPoolID\",\"type\":\"uint256\"}],\"name\":\"getLuckyPoolAccount\",\"outputs\":[{\"internalType\":\"address[50]\",\"name\":\"\",\"type\":\"address[50]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCanMoveData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"juniorMsg\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oneJunior\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"twoJunior\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"threeJunior\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oneAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twoAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"juniorMsgV1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oneJunior\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"twoJunior\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"threeJunior\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oneAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"twoAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leader\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaderLucky\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaderRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkedin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"luckyIntervalTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"luckyLastAddrssRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckyPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"earnTotalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"isState\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckyNextIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckyPoolAccounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"luckyPoolCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"luckyPoolRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miningPoolRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nonceUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"earnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leastDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckyPoolEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfoThen\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recycleToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limitDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfoV1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leastDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"luckyPoolEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamEarnLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"juniorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userTokenPerShare\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"recycleOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_takeLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_residueAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_releaseEndTime\",\"type\":\"uint256\"}],\"name\":\"setAccountOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newAllIsOpen\",\"type\":\"bool\"}],\"name\":\"setAllIsOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[7]\",\"name\":\"allRatio\",\"type\":\"uint256[7]\"}],\"name\":\"setAllRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBlack\",\"type\":\"bool\"}],\"name\":\"setBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newEarnMul\",\"type\":\"uint256\"}],\"name\":\"setEarnMul\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newIsCanMoveData\",\"type\":\"bool\"}],\"name\":\"setIsCanMoveData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLeader\",\"type\":\"address\"}],\"name\":\"setLeader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLeaderLucky\",\"type\":\"address\"}],\"name\":\"setLeaderLucky\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLinkedin\",\"type\":\"address\"}],\"name\":\"setLinkedin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dayNumber\",\"type\":\"uint256\"}],\"name\":\"setLuckyIntervalTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newLuckyLastAddrssRatio\",\"type\":\"uint256\"}],\"name\":\"setLuckyLastAddrssRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"setNonceUsed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recycleToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limitDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOpen2\",\"type\":\"bool\"}],\"name\":\"setPoolThen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dayNumber\",\"type\":\"uint256\"}],\"name\":\"setReleaseTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStLTC\",\"type\":\"address\"}],\"name\":\"setStLTC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTwoAddress_\",\"type\":\"address\"}],\"name\":\"setTwoAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stLTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"superRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"takeETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"takeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamPoolRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_newOwnerOf\",\"type\":\"address\"}],\"name\":\"transferAccountID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"ownerOf\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"residueAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseEndTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userInfoV1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takeLimitAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"residueAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseStartTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseEndTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EternityV2", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000001518000000000000000000000000023d23d3d4910c4405d4121d9cef3373e4fc4308600000000000000000000000002b6c5523943d3b1d8378e1ac55dd23d5de4240c000000000000000000000000d01907619d6af6ab70b9e892df4f6e05a7b037c7000000000000000000000000ee04ece2064aab454c5c5ec0a07a2aa9422651fb000000000000000000000000cf5725dd2929c0d076a6e7a107da60c2080fe4ff00000000000000000000000009d7b0bd67e73480bb924a25612f6e2d4fbf4a5c", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://556527d2ba2637046849ea2b244b8f1f8adfd556f6256300f9b3484da911f366"}