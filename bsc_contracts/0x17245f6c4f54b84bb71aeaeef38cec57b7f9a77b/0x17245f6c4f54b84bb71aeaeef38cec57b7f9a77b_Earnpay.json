{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/** \r\n*\r\n   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\r\n   \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d\r\n   \u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591\r\n   \u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591\r\n   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\r\n   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591      \r\n*   EarnPay: an EHB Protocol powered payment rewards token featuring built-in payment rewards gamification.\r\n*   (Protocol codebase credit: woofydev - EarnHubBSC)\r\n*   Whale Timer Fee Multiplier/Transfer Fee/Merchant Fee/Payment Reward Pool Gamification (MegaPay, BuyBoost, Space Dust)/Reflection Switching/Custom Paying Settings\r\n*/\r\ninterface IDividendDistributor {\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minPeriodCustom, uint256 _minDistribution, uint256 _minDistributionCustom, uint256 _defaultThreshold, uint256 _rotatingThreshold) external;\r\n    function setShare(address shareholder, uint256 amount, bool distributeEarnings, bool _enabledCustomRewards) external;\r\n    function deposit(bool depositDefault) external payable;\r\n    function process(uint256 gas) external;\r\n    function processManually(bool _enabledCustomRewards) external;\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n    bool    private _isLocked;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        _isLocked = false;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(!_isLocked, \"Contract locked, wait until unlocked\");\r\n        require(newOwner != address(0), \"new owner is the 0 address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function geUnlockTime() public view returns (uint256) {\r\n        return _lockTime;\r\n    }\r\n\r\n    //Locks the contract from owner for the amount of time provided\r\n    function lock(uint256 time) public virtual onlyOwner {\r\n        _previousOwner = _owner;\r\n        _owner = address(0);\r\n        _lockTime = block.timestamp + time;\r\n        _isLocked=true;\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n\r\n    //Unlocks the contract for owner when lockTime is exceeded\r\n    function unlock() public virtual {\r\n        require(_previousOwner == msg.sender, \"You don't have permission to unlock\");\r\n        require(_owner != msg.sender, \"Contract is already unlocked\");\r\n        require(block.timestamp > _lockTime , \"Contract is locked\");\r\n        emit OwnershipTransferred(_owner, _previousOwner);\r\n        _owner = _previousOwner;\r\n        _previousOwner = address(0);\r\n        _isLocked=false;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\n// Original dividend protocol credit: Woofydev with EarnHubBSC\r\n// EarnPay customization includes dual reward pools utilizing the same distributor with space dust integration\r\ncontract DividendDistributor is IDividendDistributor {\r\n    \r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    // EarnPay Contract\r\n    address _token;\r\n    // Share of the Reflections\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n    // Share of the Rotating Token Pie\r\n    struct ShareCustom {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n    // safeearn contract address\r\n    address public TOK = 0x0cAE6c43fe2f43757a767Df90cf5054280110F3e;  //Affinity\r\n    address public TOK2 = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; //BUSD for launch (Earnhub launch delayed)\r\n    // bnb address\r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    IUniswapV2Router02 router;\r\n    // shareholder fields\r\n    address[] shareholders;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping (address => uint256) shareholderClaims;\r\n    mapping (address => Share) public shares;\r\n    // custom token shareholder fields\r\n    address[] shareholdersCustom;\r\n    mapping (address => uint256) shareholderIndexesCustom;\r\n    mapping (address => uint256) shareholderClaimsCustom;\r\n    mapping (address => ShareCustom) public sharesCustom;\r\n    // shares math and fields\r\n    uint256 public          totalShares;\r\n    uint256 public          totalDividends;\r\n    uint256 public          totalDistributed;\r\n    uint256 public          dividendsPerShare;\r\n    uint256 public          totalSharesCustom;\r\n    uint256 public          totalDividendsCustom;\r\n    uint256 public          totalDistributedCustom;\r\n    uint256 public          dividendsPerShareCustom;\r\n    uint256 public          dividendsPerShareAccuracyFactor = 10 ** 36;\r\n    // dust math\r\n    uint256 public          rewardDustDivider = 20; // 3/20 = 15%\r\n    uint256 public          rewardDustMultiplier = 3;\r\n    uint256 public          rewardRateDivider = 2;  // 1/2 = 50%\r\n    uint256 public          rewardRateMultiplier = 1;\r\n    uint256 public          rotatingDust;\r\n    uint256 public          defaultDust;\r\n    uint256 public          rotatingThreshold = 0;\r\n    uint256 public          defaultThreshold = 0;\r\n    // distributes every hour\r\n    uint256 public          minPeriod = 1 hours;\r\n    uint256 public          minPeriodCustom = 1 hours;\r\n    // 1 Million SafeEarn/EarnHub Minimum Distribution\r\n    uint256 public          minDistribution = 1 * (10 ** 15);\r\n    uint256 public          minDistributionCustom = 1 * (10 ** 15);\r\n    // current index in shareholder array \r\n    uint256 currentIndex;\r\n    uint256 currentIndexCustom;\r\n    bool    rotateProcess = true;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token); _;\r\n    }\r\n\r\n    constructor (address _router) {\r\n        router = _router != address(0)\r\n        ? IUniswapV2Router02(_router)\r\n        : IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); //testnet\r\n        _token = msg.sender;\r\n    }\r\n\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minPeriodCustom, uint256 _minDistribution, uint256 _minDistributionCustom, uint256 _defaultThreshold, uint256 _rotatingThreshold) external override onlyToken {\r\n        minPeriod = _minPeriod;\r\n        minPeriodCustom = _minPeriodCustom;\r\n        minDistribution = _minDistribution;\r\n        minDistributionCustom = _minDistributionCustom;\r\n        rotatingThreshold = _rotatingThreshold;\r\n        defaultThreshold = _defaultThreshold;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount, bool distributeEarnings, bool _enabledCustomRewards) external override onlyToken {\r\n        if(distributeEarnings && (_enabledCustomRewards ?  sharesCustom[shareholder].amount > 0 : shares[shareholder].amount > 0)){\r\n            distributeDividend(shareholder, _enabledCustomRewards);\r\n        }\r\n        if(_enabledCustomRewards) {\r\n            if(amount > 0 && sharesCustom[shareholder].amount == 0){\r\n                addShareholder(shareholder, _enabledCustomRewards);\r\n            }else if(amount == 0 && sharesCustom[shareholder].amount > 0){\r\n                removeShareholder(shareholder, _enabledCustomRewards);\r\n            }\r\n\r\n            totalSharesCustom = totalSharesCustom.sub(sharesCustom[shareholder].amount).add(amount);\r\n            sharesCustom[shareholder].amount = amount;\r\n            sharesCustom[shareholder].totalExcluded = getCumulativeDividends(sharesCustom[shareholder].amount, _enabledCustomRewards);\r\n        }\r\n        else {\r\n            if(amount > 0 && shares[shareholder].amount == 0){\r\n                addShareholder(shareholder, _enabledCustomRewards);\r\n            }else if(amount == 0 && shares[shareholder].amount > 0){\r\n                removeShareholder(shareholder, _enabledCustomRewards);\r\n            }\r\n\r\n            totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n            shares[shareholder].amount = amount;\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount, _enabledCustomRewards);\r\n        }\r\n    }\r\n    \r\n    function deposit(bool depositDefault) external payable override onlyToken {\r\n        address TOKEN = depositDefault ?  TOK : TOK2;\r\n        uint256 _balanceBefore = IERC20(TOKEN).balanceOf(address(this));\r\n        buyDepositTokens(TOKEN);\r\n        uint256 amount = IERC20(TOKEN).balanceOf(address(this)).sub(_balanceBefore);\r\n        uint256 allocation = amount.div(rewardDustDivider).mul(rewardDustMultiplier);\r\n        amount = amount.sub(allocation);\r\n        if(depositDefault) {\r\n            defaultDust = defaultDust.add(allocation);\r\n            totalDividends = totalDividends.add(amount);\r\n            dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n        }\r\n        else {\r\n            rotatingDust = rotatingDust.add(allocation);\r\n            totalDividendsCustom = totalDividendsCustom.add(amount);\r\n            dividendsPerShareCustom = dividendsPerShareCustom.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalSharesCustom));\r\n        }\r\n    }\r\n\r\n    function buyDepositTokens(address contractAddress) internal {\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = address(contractAddress);\r\n\r\n        try router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp.add(30)\r\n        ) {} catch {}\r\n\r\n    }\r\n\r\n    function process(uint256 gas) external override onlyToken {\r\n        uint256 shareholderCount;\r\n        rotateProcess = !rotateProcess;\r\n        if(rotateProcess) {\r\n            shareholderCount = shareholdersCustom.length;\r\n\r\n            if(shareholderCount == 0) { return; }\r\n            uint256 gasUsed = 0;\r\n            uint256 iterations = 0;\r\n            uint256 gasLeft = gasleft();\r\n            while(gasUsed < gas && iterations < shareholderCount) {\r\n                if(currentIndexCustom >= shareholderCount){\r\n                    currentIndexCustom = 0;\r\n                }\r\n\r\n                if(shouldDistribute(shareholdersCustom[currentIndexCustom], true)){\r\n                    distributeDividend(shareholdersCustom[currentIndexCustom], true);\r\n                }\r\n\r\n                gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n                gasLeft = gasleft();\r\n                currentIndexCustom++;\r\n                iterations++;\r\n            }\r\n        }\r\n        else {\r\n            shareholderCount = shareholders.length;\r\n\r\n            if(shareholderCount == 0) { return; }\r\n            uint256 gasUsed = 0;\r\n            uint256 iterations = 0;\r\n            uint256 gasLeft = gasleft();\r\n            while(gasUsed < gas && iterations < shareholderCount) {\r\n                if(currentIndex >= shareholderCount){\r\n                    currentIndex = 0;\r\n                }\r\n\r\n                if(shouldDistribute(shareholders[currentIndex], false)){\r\n                    distributeDividend(shareholders[currentIndex], false);\r\n                }\r\n\r\n                gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n                gasLeft = gasleft();\r\n                currentIndex++;\r\n                iterations++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function processManually(bool _enabledCustomRewards) external override onlyToken {\r\n        uint256 shareholderCount;\r\n        uint256 iterations = 0;\r\n        if(_enabledCustomRewards) {\r\n            shareholderCount = shareholdersCustom.length;\r\n        \r\n            if(shareholderCount == 0) { return; }\r\n\r\n            currentIndexCustom = 0;\r\n\r\n            while(iterations < shareholderCount) {\r\n                if(currentIndexCustom >= shareholderCount){\r\n                    currentIndexCustom = 0;\r\n                }\r\n\r\n                if(shouldDistribute(shareholdersCustom[currentIndexCustom], true)){\r\n                    distributeDividend(shareholdersCustom[currentIndexCustom], true);\r\n                }\r\n                currentIndexCustom++;\r\n                iterations++;\r\n            }\r\n        }\r\n        else {\r\n            shareholderCount = shareholders.length;\r\n            \r\n            if(shareholderCount == 0) { return; }\r\n\r\n            currentIndex = 0;\r\n\r\n            while(iterations < shareholderCount) {\r\n                if(currentIndex >= shareholderCount){\r\n                    currentIndex = 0;\r\n                }\r\n\r\n                if(shouldDistribute(shareholders[currentIndex], false)){\r\n                    distributeDividend(shareholders[currentIndex], false);\r\n                }\r\n                currentIndex++;\r\n                iterations++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function shouldDistribute(address shareholder, bool _enabledCustomRewards) internal view returns (bool) {\r\n        if(_enabledCustomRewards) {\r\n            return shareholderClaimsCustom[shareholder] + minPeriodCustom < block.timestamp\r\n            && getUnpaidEarnings(shareholder, _enabledCustomRewards) > minDistributionCustom;\r\n        }\r\n        else {\r\n            return shareholderClaims[shareholder] + minPeriod < block.timestamp\r\n            && getUnpaidEarnings(shareholder, _enabledCustomRewards) > minDistribution;\r\n        }\r\n    }\r\n\r\n    function distributeDividend(address shareholder, bool _enabledCustomRewards) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder, _enabledCustomRewards);\r\n        if(_enabledCustomRewards){\r\n            if(sharesCustom[shareholder].amount == 0){ return; }\r\n\r\n            if(amount > 0){\r\n                totalDistributedCustom = totalDistributedCustom.add(amount);\r\n                IERC20(TOK2).transfer(shareholder, amount);\r\n                shareholderClaimsCustom[shareholder] = block.timestamp;\r\n                sharesCustom[shareholder].totalRealised = sharesCustom[shareholder].totalRealised.add(amount);\r\n                sharesCustom[shareholder].totalExcluded = getCumulativeDividends(sharesCustom[shareholder].amount, _enabledCustomRewards);\r\n            }\r\n        }\r\n        else {\r\n            if(shares[shareholder].amount == 0){ return; }\r\n\r\n            if(amount > 0){\r\n                totalDistributed = totalDistributed.add(amount);\r\n                IERC20(TOK).transfer(shareholder, amount);\r\n                shareholderClaims[shareholder] = block.timestamp;\r\n                shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n                shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount, _enabledCustomRewards);\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimDividend(bool _enabledCustomRewards, address holder) external {\r\n        if(_enabledCustomRewards)\r\n            require(shareholderClaimsCustom[holder] + minPeriodCustom < block.timestamp, 'Must wait claim period to claim dividend!');\r\n        else\r\n            require(shareholderClaims[holder] + minPeriod < block.timestamp, 'Must wait claim period to claim dividend!');\r\n        distributeDividend(holder, _enabledCustomRewards);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder, bool _enabledCustomRewards) public view returns (uint256) {\r\n        if(_enabledCustomRewards){\r\n            if(sharesCustom[shareholder].amount == 0){ return 0; }\r\n\r\n            uint256 shareholderTotalDividendsCustom = getCumulativeDividends(sharesCustom[shareholder].amount, _enabledCustomRewards);\r\n            uint256 shareholderTotalExcludedCustom = sharesCustom[shareholder].totalExcluded;\r\n\r\n            if(shareholderTotalDividendsCustom <= shareholderTotalExcludedCustom){ return 0; }\r\n\r\n            return shareholderTotalDividendsCustom.sub(shareholderTotalExcludedCustom);\r\n        }\r\n        else {\r\n            if(shares[shareholder].amount == 0){ return 0; }\r\n\r\n            uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount, _enabledCustomRewards);\r\n            uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n\r\n            if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\r\n\r\n            return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n        }\r\n    }\r\n\r\n    function getTotalEarnings(address shareholder) public view returns (uint256, uint256) {\r\n        return (shares[shareholder].totalRealised, sharesCustom[shareholder].totalRealised);\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share, bool _enabledCustomRewards) internal view returns (uint256) {\r\n        if(_enabledCustomRewards){\r\n            return share.mul(dividendsPerShareCustom).div(dividendsPerShareAccuracyFactor);\r\n        }\r\n        else {\r\n            return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n        }\r\n    }\r\n\r\n    function addShareholder(address shareholder, bool _enabledCustomRewards) internal {\r\n        if(_enabledCustomRewards) {\r\n            shareholderIndexesCustom[shareholder] = shareholdersCustom.length;\r\n            shareholdersCustom.push(shareholder);\r\n        }\r\n        else {\r\n            shareholderIndexes[shareholder] = shareholders.length;\r\n            shareholders.push(shareholder);\r\n        }\r\n    }\r\n\r\n    function removeShareholder(address shareholder, bool _enabledCustomRewards) internal {\r\n        if(_enabledCustomRewards) {\r\n            shareholdersCustom[shareholderIndexesCustom[shareholder]] = shareholdersCustom[shareholdersCustom.length-1];\r\n            shareholderIndexesCustom[shareholdersCustom[shareholdersCustom.length-1]] = shareholderIndexesCustom[shareholder];\r\n            shareholdersCustom.pop();\r\n            delete shareholderIndexesCustom[shareholder];\r\n        }\r\n        else {\r\n            shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n            shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n            shareholders.pop();\r\n            delete shareholderIndexes[shareholder];\r\n        }\r\n    }\r\n    \r\n    //Transfer remaining dust back to the contract and reset the rotating dust balance\r\n    function setTokenAddress(address nToken) external onlyToken {\r\n        if(defaultDust>0)\r\n            IERC20(TOK).transfer(msg.sender, defaultDust);\r\n        defaultDust = 0;\r\n        TOK = nToken;\r\n    }\r\n\r\n    //Transfer remaining dust back to the contract and reset the rotating dust balance\r\n    function setCustomTokenAddress(address nToken) external onlyToken {\r\n        if(rotatingDust>0)\r\n            IERC20(TOK2).transfer(msg.sender, rotatingDust);\r\n        rotatingDust = 0;\r\n        TOK2 = nToken;\r\n    }\r\n\r\n    //Set reward rate for all Dust. RewardRate of Multiplier 1 & Divider 1 = Rewarding the entire pool\r\n    function setDustDividers(uint256 _rewardDustDivider, uint256 _rewardDustMultiplier, uint256 _rewardRateDivider, uint256 _rewardRateMultiplier) external onlyToken {\r\n        rewardDustDivider = _rewardDustDivider;\r\n        rewardDustMultiplier = _rewardDustMultiplier;\r\n        rewardRateDivider = _rewardRateDivider;\r\n        rewardRateMultiplier = _rewardRateMultiplier;\r\n    }\r\n    \r\n    //Function called by the blackhole mechanism to allow users to claim reward dust by burning EarnPay\r\n    function transferRewardDust(address winner) external onlyToken returns (uint256,uint256){\r\n        uint256 rewardAmount=0;\r\n        uint256 rewardAmountRotating=0;\r\n        if(rotatingDust>rotatingThreshold)\r\n        {\r\n            rewardAmountRotating = rotatingDust.div(rewardRateDivider).mul(rewardRateMultiplier);\r\n            IERC20(TOK2).transfer(winner, rewardAmountRotating); \r\n            rotatingDust = rotatingDust.sub(rewardAmountRotating);\r\n        }\r\n        if(defaultDust>defaultThreshold)\r\n        {\r\n            rewardAmount = defaultDust.div(rewardRateDivider).mul(rewardRateMultiplier);\r\n            IERC20(TOK).transfer(winner, rewardAmount);\r\n            defaultDust = defaultDust.sub(rewardAmount);\r\n        }\r\n        return (rewardAmount, rewardAmountRotating);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n}\r\n\r\n/**\r\n * Allow Recovery of any ERC20/BEP20 token sent into the contract in error. Please open a support ticket if you accidentally send an amount so we may investigate\r\n */\r\ncontract TokenRecover is Ownable {\r\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) public onlyOwner {\r\n        IERC20(tokenAddress).transfer(owner(), tokenAmount);\r\n    }\r\n}\r\n\r\n/** \r\n * Contract: EarnPay \r\n *  An EHB Protocol powered payment rewards token featuring built-in payment rewards gamification.\r\n *  (Original dividend protocol codebase credit: woofydev - EarnHubBSC)\r\n *  Whale Timer Fee Multiplier/Transfer Fee/Merchant Fee/Payment Reward Pool Gamification (MegaPay, BuyBoost, Space Dust)/Reflection Switching/Custom Paying Settings\r\n *  Buyback & Burn have been adjusted to kick off only during Buys/Sells to minimize wallet-wallet gas transfer fees. \r\n *  Whale timer limits buyback & burn on sell to prevent high slippage issues\r\n *  Includes the ability to convert the token to a basic token without having to exempt everyone. This is for emergency use.\r\n *\r\n *  This contract awards daily to holders in their choice of available tokens, weighted by how much you hold in addition to switching to a rotating pool\r\n *\r\n   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\r\n   \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d\r\n   \u2588\u2588\u2588\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591\r\n   \u2588\u2588\u2554\u2550\u2550\u255d\u2591\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\u2591\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591\r\n   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\r\n   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u2550\u255d\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591                   \r\n *   EarnPay: A payment rewards token featuring built-in dividend payouts & payment rewards gamification.\r\n *   Reflecting in EarnHub/Affinity\r\n *  \r\n *  Buy Fee:            10%\r\n *  Sell Fee:           20%\r\n *  Whale Timer Fee:    30%\r\n *  Transfer Fee:        1%\r\n *  Merchant Pay Fee:   0.5%\r\n * \r\n *  Standard Sell Fee Breakdown:\r\n *  Rewards:.................................17%                       \r\n *      -13% EarnHub/Affinity Distribution\r\n *          -> 15% Space Dust\r\n *          -> 85% Distribution\r\n *      -4% Native Reward Gamification\r\n *          -> 50% MegaPay\r\n *          -> 25% BuyBoost\r\n *          -> 25% Space Dust\r\n *  Buyback: Burn & Auto Liquidity...........1.5% \r\n *  Token Sustainability/Marketing...........1.5%\r\n *\r\n */\r\ncontract Earnpay is IERC20, Context, Ownable, TokenRecover {\r\n    \r\n    using SafeMath for uint256;\r\n    using SafeMath for uint8;\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n    \r\n    address WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c; //mainnet\r\n\r\n    address constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    address public interfaceAddress; //custom fee available for interfacing address\r\n\r\n    string  constant _name = \"EarnPay\";\r\n    string  constant _symbol = \"EARNPAY\";\r\n    uint8   constant _decimals = 9;\r\n    // 1 Trillion Max Supply\r\n    uint256 _totalSupply = 1 * 10**12 * (10 ** _decimals);\r\n    uint256 public _maxTxAmount = _totalSupply.div(200);           // 0.5% or 5 Billion\r\n    // balances\r\n    mapping (address => uint256) _balances; \r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n    mapping (address => uint256) _buyBonusEarnings;                 //Tracks holders buy bonus earnings\r\n    mapping (address => uint256) _megaPayEarnings;                  //Tracks holders mega pay earnings\r\n    mapping (address => uint256) public spaceDustEarnings;          //Tracks holders spacedust earnings\r\n    mapping (address => uint) public boostRewardIndex;\r\n    // registered merchant\r\n    mapping (address => bool) isMerchant;\r\n    // exemptions\r\n    mapping (address => bool) isFeeExempt;\r\n    mapping (address => bool) isTxLimitExempt;\r\n    mapping (address => bool) isDividendExempt;\r\n    //toggles\r\n    mapping (address => bool) enabledTransferDividends;            // \"disabled\" by default\r\n    mapping (address => bool) disabledTransferEarnings;            // \"enabled\" by default\r\n    mapping (address => bool) enabledCustomRewards;                // \"disabled\" by default\r\n    mapping (address => bool) disabledRewardDust;                  // \"enabled\" be default\r\n    // anti-whale settings \r\n    uint256 public whaleSellThreshold = 1 * 10**9 * 10**9;         // 1 billion\r\n    uint    public whaleSellTimer     = 259200;                    // 72 hours/3 days at Launch\r\n    mapping (address => uint256) public lastSellAmount;\r\n    mapping (address => uint) public _timeSinceFirstSell;\r\n    uint8   public whaleFeeMultiplier          = 3;\r\n    uint8   public whaleFeeDivider             = 2;\r\n    // fees\r\n    uint256 public liquidityFee                 = 75;\r\n    uint256 public buybackFee                   = 75;\r\n    uint256 public reflectionFee                = 1300;\r\n    uint256 public sustainingFee                = 150;\r\n    uint256 public rocketPoolFee                = 400;\r\n    // total fees\r\n    uint256 totalFeeSells                       = 2000;\r\n    uint256 totalFeeBuys                        = 1000;\r\n    uint256 totalFeeTransfers                   = 100;\r\n    uint256 totalFeeTransfersMerchant           = 50;\r\n    uint256 interfaceFee                        = 250;\r\n    uint256 feeDenominator                      = 10000;\r\n\r\n    // megapay pool\r\n    bool    public  enableRocketPools             = true;                // Enabled on deployment\r\n    bool    public  bonusContributionBuys         = true;                // Enabled on deployment - Allows Buys to Contribute to the Bonus Buy\r\n    uint256 public  megaPay                       = 0;                   // How many reflections are in the megapay pool\r\n    uint256 public  buyBoost                      = 0;                   // How many reflections are in the bonus pool\r\n    uint    public  megaPayChance                 = 10;                  // 1% chance of winning\r\n    uint    public  megaPayTransferChance         = 3;                   // 0.3% chance of winning\r\n    uint    public  bonusChance                   = 90;                  // 9% chance of winning boost at buy\r\n    uint    public  rewardIndex                   = 5;                   // Every 5th buy kick in chance buy boost chance multiplier;\r\n    uint    public  rewardIndexMult               = 3;\r\n    uint    public  rewardIndex2                  = 10;                   // Must be > than rewardIndex always\r\n    uint    public  rewardIndex2Mult              = 4;\r\n    uint256 public  megaPayThreshold              = 10 * 10**6 * 10**9;  // initial 10 million tokens required to be in the pool before megapay pool can be triggered\r\n    uint256 public  megaPayMinimumSpend           = 1 * 10**6 * 10**9;   // initial 1 million tokens required to buy before megapay pool can be triggered\r\n    uint256 public  megaPayMinimumTransfer        = 1 * 10**6 * 10**9;   // initial 1 million tokens required to transfer before before megapay pool can be triggered\r\n    uint256 public  megaPayMinimumHODL            = 10 * 10**6 * 10**9;  // initial 10 million tokens required to HODL before megapay pool can be triggered\r\n    uint256 public  chanceMultiplierBuyThreshold  = 50 * 10**6 * 10**9;  // initially 50 million tokens required to purchase for multiplier \r\n    address public  previousWinner;\r\n    uint256 public  previousWonAmount;\r\n    uint    public  previousWinTime;\r\n    address public  previousBoostWinner;\r\n    uint    public  lastRoll;\r\n    uint256 private _nonce;\r\n    // space dust --- enabled by rocket pools\r\n    uint256 public  blackHoleMinimum                = 1 * 10**5 * 10**9;   // initial 100K tokens required to claim space dust through sending to blackhole\r\n    uint256 public  blackHoleMinimumMP              = 10 * 10**5 * 10**9;  // initial 1M tokens required to burn to roll for megabuy & megapay\r\n    uint    public  bHchanceMultiplier              = 2;                   // Set to 2x to start\r\n    uint256 public  spaceDust                       = 0;                   // How many reflections are in the dust pool\r\n    uint256 public  spaceDustBurned                 = 0;                   // Tracks space dust burned through black hole\r\n    uint    public  spaceDustRateDivider            = 2;                   // Initially set to reward half the bonus allocation\r\n    uint    public  spaceDustRateMultiplier         = 1;                   // Value can be used to fine tune rewarding greater than 50%\r\n    uint    public  earnPayDustDivider              = 2;                   // Initially set to take half of the buy bonus allocation\r\n    uint    public  earnPayDustMultiplier           = 1;                   // Value can be used to fine tune rewarding greater than 50%\r\n    // sustaining wallet & auto LP receiver\r\n    address public sustainingFeeReceiver = 0x71De1Af1e55b6A70E273A853CF8DF52fE510010C;\r\n    address public autoLiquidityReceiver;\r\n    // target liquidity is 12%\r\n    uint256 targetLiquidity = 12;\r\n    uint256 targetLiquidityDenominator = 100;\r\n    // Pancakeswap V2 Router\r\n    IUniswapV2Router02 public router;\r\n    address public pair;\r\n    // buy back data\r\n    bool public autoBuybackEnabled = true;\r\n    uint256 autoBuybackAccumulator = 0; // Tracks how many tokens have been bought back AND burned from circulation\r\n    uint256 autoBuybackAmount = 1 * 10**18;\r\n    uint256 autoBuybackBlockPeriod = 3600; // 1 hour\r\n    uint256 autoBuybackBlockLast = block.number;\r\n    // gas for distributor\r\n    DividendDistributor distributor;\r\n    uint256 distributorGas = 500000;\r\n    uint256 customTokenRewardBalance = 0; // Tracks EarnPay reflections that will be converted to custom token\r\n    uint256 tokenRewardBalance       = 0; // Tracks EarnPay reflections that will be converted to default token\r\n    // in charge of swapping from EarnPay -> BNB to fund EarnPay reflections + sustaining\r\n    bool public swapEnabled = true;\r\n    uint256 public swapThreshold = _totalSupply.div(1000); // 0.1% or 1 Billion to start\r\n    // true if our threshold decreases with circulating supply\r\n    bool basicTransfers = false;\r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n    // Uniswap Router V2\r\n    address private _dexRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E; //mainnet\r\n\r\n    // false if we should disable auto liquidity pairing for any reason\r\n    bool public shouldPairLiquidity = true;\r\n    uint256 public reverseRugAccumulator = 0; //tracks how much EarnPay devs send back to the community via Rocket Pools\r\n    \r\n    \r\n    constructor () {\r\n        // Pancakeswap V2 Router\r\n        router = IUniswapV2Router02(_dexRouter);\r\n        // Liquidity Pool Address for BNB -> EarnPay\r\n        pair = IUniswapV2Factory(router.factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(router)] = _totalSupply;\r\n        // Wrapped BNB Address used for trading on PCS\r\n        WBNB = router.WETH();\r\n        // our dividend Distributor\r\n        distributor = new DividendDistributor(_dexRouter);\r\n        // exempt deployer/sustaining from fees\r\n        isFeeExempt[msg.sender] = true;\r\n        isFeeExempt[sustainingFeeReceiver] = true;\r\n        // exempt deployer/sustaining from TX limit\r\n        isTxLimitExempt[msg.sender] = true;\r\n        isTxLimitExempt[sustainingFeeReceiver] = true;\r\n        isTxLimitExempt[address(this)] = true;\r\n        // exempt this contract, the LP, and OUR burn wallet from receiving SafeEarn/EarnHub Rewards\r\n        isDividendExempt[pair] = true;\r\n        isDividendExempt[address(this)] = true;\r\n        isDividendExempt[DEAD] = true;\r\n        approve(_dexRouter, _totalSupply);\r\n        approve(address(pair), _totalSupply);\r\n        _balances[msg.sender] = _totalSupply;\r\n        autoLiquidityReceiver = msg.sender;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function internalApprove(address spender, uint256 amount) internal returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        return true;\r\n    }\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, _totalSupply);\r\n    }\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != _totalSupply){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n    /** Internal Transfer */\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        // during internal or interface triggered swaps perform a basic transfer\r\n        if(inSwap || recipient == interfaceAddress || sender == interfaceAddress || basicTransfers){ if(basicTransfers) emit Transfer(sender, recipient, amount); return _basicTransfer(sender, recipient, amount); }\r\n\r\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        require(amount <= _maxTxAmount || isTxLimitExempt[sender], \"TX Limit Exceeded\");\r\n        \r\n        // pool threshold & minimum required to spend for award are updated to always be relative to % of circulating supply\r\n        bool    _isBuy             = (sender == pair);\r\n        bool    _isSell            = (recipient == pair);\r\n        bool    _isTransfer        = !(_isBuy || _isSell); \r\n\r\n        /*\r\n            \u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2584\u2580\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2580\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\r\n            \u2588\u2580\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2591\u2588\u2003\u2588\u2588\u2584\u2003\u2591\u2588\u2591\u2003 \u2003\u2588\u2580\u2580\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2584\u2003\u2584\u2588\r\n        */\r\n        //If the transaction is a buy or transfer, then we roll to see if we award any extra tokens from the Rocket Pools\r\n        if(enableRocketPools &&  ((!isDividendExempt[recipient] && (amount >= megaPayMinimumSpend && _isBuy)) || (!isDividendExempt[sender] && (amount >= megaPayMinimumTransfer && _isTransfer && _balances[sender] >= megaPayMinimumHODL)))){\r\n    \r\n            uint256 poolReward = calculatePoolReward(_isTransfer, 1); //calculates pool reward based on the buy or wallet-wallet transfer chance\r\n            if (_isBuy){\r\n                if (poolReward > 0) {\r\n                    rocketPoolTransfer(recipient, poolReward, true); \r\n                }\r\n                uint256 chance_multiplier;\r\n                if(boostRewardIndex[recipient] == rewardIndex)\r\n                    chance_multiplier = rewardIndexMult;\r\n                else \r\n                    chance_multiplier = boostRewardIndex[recipient] >= rewardIndex2 ? rewardIndex2Mult : 1;\r\n                if(amount >= chanceMultiplierBuyThreshold){\r\n                    boostRewardIndex[recipient] = boostRewardIndex[recipient] >= rewardIndex2 ? 0 : boostRewardIndex[recipient].add(1);\r\n                }\r\n                if (buyBoost > 0 && (random() <= bonusChance.mul(chance_multiplier))) {\r\n                    rocketPoolTransfer(recipient, buyBoost, false); //Awards bonus pool from last sells if won\r\n                }\r\n            }\r\n            if (_isTransfer){\r\n                if (poolReward > 0) {\r\n                    rocketPoolTransfer(sender, poolReward, true);\r\n                }\r\n                if (!disabledRewardDust[sender] && spaceDust > 0) {\r\n                    uint256 dustAllocation = spaceDust.div(spaceDustRateDivider).mul(spaceDustRateMultiplier);\r\n                    _balances[sender] = _balances[sender].add(dustAllocation);\r\n                    spaceDustEarnings[sender] = spaceDustEarnings[sender].add(dustAllocation);\r\n                    emit DustTransfer(sender, dustAllocation, block.timestamp);\r\n                    emit Transfer(address(this), sender, dustAllocation);\r\n                    spaceDust = spaceDust.sub(dustAllocation);\r\n                }\r\n            }\r\n        } \r\n\r\n        uint256 amountReceived;\r\n        // limit gas consumption by splitting up operations\r\n        // limit buyback & swapback during whale timer sell to prevent high slippage issues\r\n        if(_isTransfer){\r\n            amountReceived = handleTransferBody(sender, recipient, amount);\r\n            if(enabledTransferDividends[sender]){\r\n                tryToProcess();\r\n            }\r\n            emit Transfer(sender, recipient, amountReceived);\r\n            return true;\r\n        } //Are we about to enter a whale sell in amount sold? To avoid high slippage errors, we skip buyback & swapback\r\n        else if(lastSellAmount[sender].add(amount) > whaleSellThreshold && _isSell) {\r\n            amountReceived = handleTransferBody(sender, recipient, amount);\r\n            tryToProcess();\r\n            emit Transfer(sender, recipient, amountReceived);\r\n            return true;\r\n        } //Should SwapBack? (swaps EARNPAY for BNB)\r\n        else if(shouldSwapBack()) { \r\n            swapBack();\r\n        } //Should AutoBuyBack (buy & burn)?\r\n        else if(!inSwap && autoBuybackEnabled && autoBuybackBlockLast + autoBuybackBlockPeriod <= block.number && address(this).balance >= autoBuybackAmount) {\r\n            //Trigger Autobuyback \r\n            buyTokens(autoBuybackAmount, DEAD);\r\n            autoBuybackBlockLast = block.number;\r\n            autoBuybackAccumulator = autoBuybackAccumulator.add(autoBuybackAmount); \r\n        } //process as normal\r\n        amountReceived = handleTransferBody(sender, recipient, amount);\r\n        tryToProcess();\r\n        \r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n    /** Takes Associated Fees and sets holders' new Share for the SafeEarn/EarnHub Distributor */\r\n    function handleTransferBody(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        if(basicTransfers)\r\n        {\r\n            _balances[recipient] = _balances[recipient].add(amount);\r\n            return amount;\r\n        }\r\n        uint256 amountReceived = !isFeeExempt[sender] ? takeFee(sender, recipient, amount) : amount; // !isFeeExempt[sender] == should take fee?\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n        // If this is a transfer, set to triggerDividends based on user. Default to true for buy/sell\r\n        bool triggerDividends = !(sender == pair || recipient == pair) ? !disabledTransferEarnings[sender] : true;\r\n        if(!isDividendExempt[sender]){\r\n            try distributor.setShare(sender, _balances[sender], triggerDividends, enabledCustomRewards[sender]) {} catch {} \r\n        }\r\n        if(!isDividendExempt[recipient]){\r\n            try distributor.setShare(recipient, _balances[recipient], triggerDividends, enabledCustomRewards[recipient]) {} catch {} \r\n        }\r\n\r\n        return amountReceived;\r\n    }\r\n    /** Basic Transfer with no swaps for BNB -> EarnPay or EarnPay -> BNB or Fees taken - Converts the token to a basic Token*/\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        handleTransferBody(sender, recipient, amount);\r\n        return true;\r\n    }\r\n    /** Tries to process */\r\n    function tryToProcess() internal {\r\n        uint256 gasToUse = distributorGas > gasleft() ? gasleft().mul(3).div(4) : distributorGas;\r\n        try distributor.process(gasToUse) {} catch {}\r\n    }\r\n    /** Takes Tax Fee (10% buys , 1% transfers, 20% on sells, 30% Whale Timer Tax) and delegate reflection pool allocations and store remaining fees in contract */\r\n    function takeFee(address sender, address receiver, uint256 amount) internal returns (uint256) {\r\n        uint256 feeAmount = amount.mul(getTotalFee(sender, receiver, amount)).div(feeDenominator);\r\n        uint256 _finalFeeAmount = feeAmount;\r\n        if(enableRocketPools) {\r\n            uint256 poolAllocation = feeAmount.mul(rocketPoolFee).div(totalFeeSells); //calculates fees to allocate towards reflection pool\r\n            bool conditionsMet = bonusContributionBuys ? (receiver == pair || sender == pair) : (receiver == pair); \r\n            uint256 _buyBonusAdd = conditionsMet ? poolAllocation.div(2) : 0; //if it's a sell allocate 1/2 of the pool allocation for the buy bonus\r\n            uint256 _newAllocation = _buyBonusAdd.div(earnPayDustDivider).mul(earnPayDustMultiplier);\r\n            buyBoost = buyBoost.add(_newAllocation);\r\n            spaceDust = spaceDust.add(_buyBonusAdd.sub(_newAllocation));\r\n            megaPay = megaPay.add(poolAllocation.sub(_buyBonusAdd)); //transfer pool allocations to reflection pool\r\n            _finalFeeAmount = feeAmount.sub(poolAllocation);\r\n        }\r\n\r\n        //If it's a buy/sell, split the fee for dividend allocation between both pools. During a transfer allocate to only the holder reward pool\r\n        if(sender == pair || receiver == pair){\r\n            uint256 fee_alloc = _finalFeeAmount.div(2);\r\n            customTokenRewardBalance = customTokenRewardBalance.add(fee_alloc);//remove pool allocations from total fee amount & add to custom + default token balance\r\n            tokenRewardBalance = tokenRewardBalance.add(_finalFeeAmount.sub(fee_alloc));\r\n        }\r\n        else {\r\n            if(enabledCustomRewards[sender]) { customTokenRewardBalance = customTokenRewardBalance.add(_finalFeeAmount);//remove pool allocations from total fee amount & add to custom token balance\r\n            }\r\n            else { tokenRewardBalance = tokenRewardBalance.add(_finalFeeAmount);\r\n            }\r\n        }\r\n        _balances[address(this)] = _balances[address(this)].add(_finalFeeAmount); //remove pool allocations from total fee amount & add to contract balance\r\n        //subtract total fee amount (including pool allocations)\r\n        return amount.sub(feeAmount);\r\n    }\r\n    function getTotalFee(address sender, address receiver, uint256 amount) internal returns (uint256) {\r\n        //Determine if we are 1. Transferring or 2. Selling or 3. Are you interfacing with a swapper contract. Otherwise assign the buy Fee as the default fee\r\n        if(!(sender == pair || receiver == pair)){\r\n            return (isMerchant[sender] || isMerchant[receiver]) ? totalFeeTransfersMerchant : totalFeeTransfers;\r\n        } //checks if we're selling\r\n        if(receiver == pair){ \r\n            // We will assume that the normal sell tax rate will apply\r\n            uint256 fee = totalFeeSells;\r\n            // Get the time difference in seconds between now and the first sell\r\n            uint delta = block.timestamp.sub(_timeSinceFirstSell[sender]);\r\n            // Get the new total to see if it has spilled over the threshold\r\n            uint256 newTotal = lastSellAmount[sender].add(amount);\r\n            /*\r\n                                \r\n                \u2588\u2591\u2588\u2591\u2588\u2003\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\r\n                \u2580\u2584\u2580\u2584\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2003\u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584\r\n            */\r\n            // If an existing wallet started their selling within the whale timer, check if they're trying to spill over the whale tax sell threshold\r\n            // If they are then increase the tax amount\r\n            if (delta > 0 && delta < whaleSellTimer && _timeSinceFirstSell[sender] != 0) {\r\n                if (newTotal > whaleSellThreshold) {\r\n                    fee = fee.mul(whaleFeeMultiplier).div(whaleFeeDivider); \r\n                }\r\n                lastSellAmount[sender] = newTotal;\r\n            } else if (_timeSinceFirstSell[sender] == 0 && newTotal > whaleSellThreshold) {\r\n                fee = fee.mul(whaleFeeMultiplier).div(whaleFeeDivider);\r\n                lastSellAmount[sender] = newTotal;\r\n            } else {\r\n                // Otherwise we reset their sold amount and timer\r\n                _timeSinceFirstSell[sender] = block.timestamp;\r\n                lastSellAmount[sender] = amount;\r\n            }\r\n            return fee; }\r\n        if(receiver == interfaceAddress || sender == interfaceAddress)\r\n        {\r\n            return interfaceFee;\r\n        }\r\n        return totalFeeBuys;\r\n    }\r\n\r\n    /** True if we should swap from EarnPay => BNB, we only swapsback during buy/sell to save transfer gas fees */\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        bool tokenThresholdMet = (_balances[address(this)].sub(tokenRewardBalance) >= swapThreshold) || (_balances[address(this)].sub(customTokenRewardBalance) >= swapThreshold);\r\n        return !inSwap\r\n        && swapEnabled\r\n        && tokenThresholdMet;\r\n    }\r\n    /**\r\n     *  Swaps EarnPay for BNB if threshold is reached and the swap is enabled and fund lp/buyback/burns/marketing\r\n     */\r\n    function swapBack() internal swapping {\r\n        \r\n        // check if we need to add liquidity\r\n        uint256 _totalFeeSells = totalFeeSells.sub(rocketPoolFee);\r\n        uint256 dynamicLiquidityFee = (isOverLiquified(targetLiquidity, targetLiquidityDenominator) || !shouldPairLiquidity)? 0 : liquidityFee;\r\n        uint256 amountToLiquify = swapThreshold.mul(dynamicLiquidityFee).div(_totalFeeSells).div(2);\r\n        uint256 amountToSwap = swapThreshold.sub(amountToLiquify);\r\n        // path from token -> BNB\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        uint256 balanceBefore = address(this).balance;\r\n        bool swapDefault = _balances[address(this)].sub(customTokenRewardBalance) >= swapThreshold; //determine who met threshold during swapback check\r\n        // swap tokens for BNB\r\n        try router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        ) {\r\n            if(swapDefault){ tokenRewardBalance = tokenRewardBalance.sub(amountToSwap); }\r\n            else { customTokenRewardBalance = customTokenRewardBalance.sub(amountToSwap);}\r\n\r\n        } catch{}\r\n        // how much BNB did we swap?\r\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\r\n\r\n        // total amount of BNB to allocate\r\n        uint256 totalBNBFee = _totalFeeSells.sub(dynamicLiquidityFee.div(2));\r\n        // how much bnb is sent to liquidity, reflections, and sustaining\r\n        uint256 amountBNBLiquidity = amountBNB.mul(dynamicLiquidityFee).div(totalBNBFee).div(2);\r\n        uint256 amountBNBReflection = amountBNB.mul(reflectionFee).div(totalBNBFee);\r\n        uint256 amountBNBSustaining = amountBNB.mul(sustainingFee).div(totalBNBFee);\r\n        // deposit BNB for reflections and sustaining and identify which reflection to purchase\r\n        transferToDistributorAndSustaining(amountBNBReflection, amountBNBSustaining, swapDefault);\r\n        \r\n        // add liquidity to liquidity pair as needed and send to the liquidity address\r\n        if(amountToLiquify > 0 && shouldPairLiquidity ){\r\n            try router.addLiquidityETH{value: amountBNBLiquidity}(\r\n                address(this),\r\n                amountToLiquify,\r\n                0,\r\n                0,\r\n                autoLiquidityReceiver,\r\n                block.timestamp\r\n            ) {\r\n                if(swapDefault){ tokenRewardBalance = tokenRewardBalance.sub(amountToLiquify); }\r\n                else { customTokenRewardBalance = customTokenRewardBalance.sub(amountToLiquify);}\r\n            } catch {}\r\n        }\r\n    }\r\n    /** Transfers BNB to EarnHub Distributor and Sustaining Wallet */\r\n    function transferToDistributorAndSustaining(uint256 distributorBNB, uint256 sustainingBNB, bool swapDefault) internal {\r\n            bool successful;\r\n            try distributor.deposit{value: distributorBNB}(swapDefault) {} catch {}\r\n            (successful,) = payable(sustainingFeeReceiver).call{value: sustainingBNB, gas: 30000}(\"\");\r\n    }\r\n    \r\n    /**\r\n     * Buys EarnPay with bnb in the contract and then sends to the dead wallet\r\n     */ \r\n    function buyTokens(uint256 amount, address to) internal swapping {\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = address(this);\r\n\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\r\n            0,\r\n            path,\r\n            to,\r\n            block.timestamp.add(30)\r\n        );\r\n    }\r\n    \r\n    /** 0 = process manually | 1 = process with standard gas | Above 1 = process with custom gas limit */\r\n    function manuallyProcessDividends(uint256 distributorGasFee, bool _processDefault) external {\r\n        if (distributorGasFee == 0) {\r\n            try distributor.processManually(_processDefault) {} catch {}\r\n        } else if (distributorGasFee == 1) {\r\n            try distributor.process(distributorGas) {} catch {}\r\n        } else {\r\n            try distributor.process(distributorGasFee) {} catch {}\r\n        }\r\n    }\r\n    \r\n    function setInterface(address _interface, uint256 _interfaceFee) external onlyOwner {\r\n        interfaceAddress = _interface;\r\n        isDividendExempt[interfaceAddress] = true;\r\n        interfaceFee = _interfaceFee;\r\n    }\r\n\r\n    //designed to skip mechanisms in the event of the contract reverting or a vulnerability being found\r\n    function setBasicTransfers(bool _enableBasicTransfers) external onlyOwner {\r\n        basicTransfers = _enableBasicTransfers;\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n    function setIsTxLimitExempt(address holder, bool exempt) external onlyOwner {\r\n        isTxLimitExempt[holder] = exempt;\r\n    }\r\n\r\n    function getExemptions(address holder) external view returns (bool, bool, bool, bool) {\r\n        return (isFeeExempt[holder], isDividendExempt[holder], isTxLimitExempt[holder], isMerchant[holder]);\r\n    }\r\n    \r\n    function setFeeReceivers(address _autoLiquidityReceiver, address _sustainingFeeReceiver) external onlyOwner {\r\n        autoLiquidityReceiver = _autoLiquidityReceiver;\r\n        sustainingFeeReceiver = _sustainingFeeReceiver;\r\n    }\r\n\r\n    function setAutoBuybackSettings(bool _enabled, uint256 _amount, uint256 _period) external onlyOwner {\r\n        autoBuybackEnabled = _enabled;\r\n        autoBuybackAmount = _amount;\r\n        autoBuybackBlockPeriod = _period;\r\n        autoBuybackBlockLast = block.number;\r\n    }\r\n\r\n    function setSwapBackSettings(bool _swapEnabled, uint256 _swapThreshold, bool shouldAutomateLiquidity) external onlyOwner {\r\n        swapEnabled = _swapEnabled;\r\n        swapThreshold = _swapThreshold;\r\n        shouldPairLiquidity = shouldAutomateLiquidity;\r\n    }\r\n\r\n    function setTargetLiquidity(uint256 _targetLiquidity, uint256 _targetLiquidityDenominator) external onlyOwner {\r\n        targetLiquidity = _targetLiquidity;\r\n        targetLiquidityDenominator = _targetLiquidityDenominator;\r\n    }\r\n\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minPeriodCustom, uint256 _minDistribution, uint256 _minDistributionCustom, uint256 _defaultThreshold, uint256 _rotatingThreshold) external onlyOwner {\r\n        distributor.setDistributionCriteria(_minPeriod, _minPeriodCustom, _minDistribution, _minDistributionCustom, _defaultThreshold, _rotatingThreshold);\r\n    }\r\n\r\n    function setDistributorGas(uint256 gas) external onlyOwner {\r\n        require(gas < 10000000);\r\n        distributorGas = gas;\r\n    }\r\n\r\n    function setTxLimit(uint256 amount) external onlyOwner {\r\n        require(amount >= _totalSupply / 2500);\r\n        _maxTxAmount = amount;\r\n    }\r\n\r\n    function setIsDividendExempt(address holder, bool exempt) external onlyOwner {\r\n        require(holder != address(this) && holder != pair && holder != DEAD);\r\n        isDividendExempt[holder] = exempt;\r\n        if(exempt){\r\n            distributor.setShare(holder, 0, true, true); //ensures both Custom Rewards & Default Rewards are disabled\r\n            distributor.setShare(holder, 0, true, false); //ensures both Custom Rewards & Default Rewards are disabled\r\n        }\r\n        else {\r\n            distributor.setShare(holder, _balances[holder], true, enabledCustomRewards[holder]); //enabled rewards based on selected pool\r\n        }\r\n    }\r\n    /**\r\n     * Buy and Burn EarnPay with bnb stored in contract\r\n     */\r\n    function triggerEarnPayBuyback(uint256 amount) external onlyOwner {\r\n        buyTokens(amount, DEAD);\r\n    }\r\n    /** Sets Various Fees */\r\n    function setFees(uint256 _liquidityFee, uint256 _buybackFee, uint256 _reflectionFee, uint256 _sustainingFee, uint256 _rocketPoolFee, uint256 _feeDenominator) external onlyOwner {\r\n        liquidityFee = _liquidityFee;\r\n        buybackFee = _buybackFee;\r\n        reflectionFee = _reflectionFee;\r\n        sustainingFee = _sustainingFee;\r\n        rocketPoolFee = _rocketPoolFee;\r\n        totalFeeSells = _liquidityFee.add(_buybackFee).add(_reflectionFee).add(_sustainingFee).add(_rocketPoolFee);\r\n        feeDenominator = _feeDenominator;\r\n        require(totalFeeSells < feeDenominator/2);\r\n    }\r\n    function setOtherFees(uint256 _buyFee, uint256 _transferFee, uint256 _merchantFee) external onlyOwner {\r\n        totalFeeBuys = _buyFee;\r\n        totalFeeTransfers = _transferFee;\r\n        totalFeeTransfersMerchant = _merchantFee;\r\n    }\r\n    function setDexRouter(address nRouter) external onlyOwner{\r\n        _dexRouter = nRouter;\r\n        router = IUniswapV2Router02(nRouter);\r\n        _allowances[address(this)][address(router)] = _totalSupply;\r\n    }\r\n\r\n    function setBuyBoostRewardMultipliers(uint _rewardIndex, uint _rewardIndexMult, uint _rewardIndex2, uint _rewardIndex2Mult, uint256 _chanceMultiplierBuyThreshold) external onlyOwner {\r\n        rewardIndex = _rewardIndex;\r\n        rewardIndexMult = _rewardIndexMult;\r\n        rewardIndex2 = _rewardIndex2;\r\n        rewardIndex2Mult = _rewardIndex2Mult;\r\n        chanceMultiplierBuyThreshold = _chanceMultiplierBuyThreshold;\r\n    }\r\n    \r\n    function setTokenContractAddress(address _nToken, bool _processManually) external onlyOwner {\r\n        if(_processManually)\r\n            try distributor.processManually(false) {} catch {} //manuallyprocesses all owed dividends before resetting contract address to avoid balance errors\r\n        distributor.setTokenAddress(_nToken);\r\n        emit SwappedTokenAddresses(_nToken);\r\n    }\r\n\r\n    function setTokenContractAddressRotating(address _nToken, bool _processManually) external onlyOwner {\r\n        if(_processManually)\r\n            try distributor.processManually(true) {} catch {} //manuallyprocesses all owed dividends before resetting contract address to avoid balance errors\r\n        distributor.setCustomTokenAddress(_nToken);\r\n        emit SwappedTokenAddresses(_nToken);\r\n    }\r\n\r\n\r\n    function isCustomTokenEnabled(address holder) external view returns (bool)\r\n    {\r\n        return enabledCustomRewards[holder];\r\n    }\r\n    function switchReflections() external {\r\n        require(!isDividendExempt[msg.sender], 'address dividend exempt');\r\n\r\n        if(!enabledCustomRewards[msg.sender]) {\r\n            enabledCustomRewards[msg.sender] = true;\r\n            try distributor.setShare(msg.sender, 0, true, false) { //pay dividends then remove from regular shareholder list\r\n\t\t\t\tdistributor.setShare(msg.sender,_balances[msg.sender], false, true); //adds to custom token shareholder list\r\n\t\t\t}\r\n\t\t\tcatch {\r\n\t\t\t\tdistributor.setShare(msg.sender, 0, false, false);  //if balance owed reverts due to Reward Contract being updated, do not try to process dividends\r\n\t\t\t\tdistributor.setShare(msg.sender,_balances[msg.sender], false, true); //adds to custom token shareholder list\r\n\t\t\t}\r\n        }\r\n        else {\r\n            enabledCustomRewards[msg.sender] = false;\r\n            try distributor.setShare(msg.sender, 0, true, true) { //pay dividends then remove from custom token shareholder list\r\n\t\t\t\tdistributor.setShare(msg.sender,_balances[msg.sender], false, false); //adds to regular shareholder list\r\n\t\t\t}\r\n\t\t\tcatch {\r\n\t\t\t\tdistributor.setShare(msg.sender, 0, false, true); //if balance owed reverts due to Reward Contract being updated, do not try to process dividends\r\n\t\t\t\tdistributor.setShare(msg.sender,_balances[msg.sender], false, false); //adds to regular shareholder list\r\n\t\t\t}\r\n        }\r\n    }\r\n\r\n    function getBalances() public view returns(uint256, uint256, uint256, uint256){\r\n        return (address(this).balance, _balances[address(this)], tokenRewardBalance, customTokenRewardBalance);\r\n    }\r\n    \r\n    /** Returns the Circulating Supply of EarnPay ( supply not owned by Burn Wallet ) */\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(address(0)));\r\n    }\r\n\r\n    function isOverLiquified(uint256 target, uint256 accuracy) public view returns (bool) {\r\n        return accuracy.mul(balanceOf(pair).mul(2)).div(getCirculatingSupply()) > target;\r\n    }\r\n    \r\n    function getDistributorAddress() external view returns (address) {\r\n        return address(distributor);\r\n    }\r\n    \r\n    function togglePaySettings(uint _option) external {\r\n        //toggle Transfer Dividends\r\n        if(_option == 1){\r\n            enabledTransferDividends[msg.sender] = !enabledTransferDividends[msg.sender];\r\n        }\r\n        //toggle Transfer Earnings\r\n        if(_option == 2){\r\n            disabledTransferEarnings[msg.sender] = !disabledTransferEarnings[msg.sender];\r\n        }\r\n        //toggle Dust Rewards\r\n        if(_option == 3){\r\n            disabledRewardDust[msg.sender] = !disabledRewardDust[msg.sender];\r\n        }\r\n    }\r\n    function getTransferSettings(address holder) external view returns (bool, bool, bool) {\r\n        return (enabledTransferDividends[holder],!disabledTransferEarnings[holder], !disabledRewardDust[holder]);\r\n    }\r\n    function claimEarnings() external returns (bool) {\r\n        distributor.claimDividend(enabledCustomRewards[msg.sender], msg.sender);\r\n        return true;\r\n    }\r\n\r\n    //meant to handle resetting shares if holder address reverts at claiming after switching contracts. If it does not revert, it will distribute dividends to avoid loss of shares.\r\n    function emergencyResetShares() external {\r\n        try distributor.setShare(msg.sender, _balances[msg.sender], true, enabledCustomRewards[msg.sender]) {}\r\n        catch {distributor.setShare(msg.sender, _balances[msg.sender], false, enabledCustomRewards[msg.sender]);} \r\n    }\r\n\r\n    //Allow holders to process swapbacks for a multiplier reward credit\r\n    function manualSwapBack() external {\r\n        if(shouldSwapBack()) { \r\n            swapBack();\r\n            if(!isDividendExempt[msg.sender] && _balances[msg.sender] >= megaPayThreshold)\r\n                boostRewardIndex[msg.sender] = boostRewardIndex[msg.sender].add(1);\r\n        }\r\n    }\r\n    function getUnpaidReflections(address holder) external view returns (uint256) {\r\n        return distributor.getUnpaidEarnings(holder, enabledCustomRewards[msg.sender]);\r\n    }\r\n    function getUserReflectionsEarnedAndWinnings(address holder) external view returns (uint256, uint256, uint256, uint256, uint256) {\r\n        (uint256 DefaultTotalRealised, uint256 RotatingTotalRealised) = distributor.getTotalEarnings(holder);\r\n        return  (DefaultTotalRealised, RotatingTotalRealised,_buyBonusEarnings[holder], _megaPayEarnings[holder], spaceDustEarnings[holder]);\r\n    }\r\n    function setIsMerchant(address holder, bool isRegisteredMerchant) external onlyOwner {\r\n        isMerchant[holder] = isRegisteredMerchant;\r\n    }\r\n\r\n\r\n            /*\r\n                                \r\n                \u2588\u2591\u2588\u2591\u2588\u2003\u2588\u2591\u2588\u2003\u2584\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003 \u2003\u2580\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\r\n                \u2580\u2584\u2580\u2584\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003 \u2003\u2591\u2588\u2591\u2003\u2588\u2003\u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584\r\n            */\r\n\r\n    function inWhaleTimer(address account) external view returns (bool, uint256, uint) {\r\n        uint256 delta = block.timestamp.sub(_timeSinceFirstSell[account]);\r\n        return ((delta > 0 && delta < whaleSellTimer && lastSellAmount[account] > whaleSellThreshold), lastSellAmount[account], _timeSinceFirstSell[account]);\r\n    }\r\n    function setWhaleSettings(uint256 _sellThreshold, uint _time, uint8 _feeMultiplier, uint8 _feeDivider) external onlyOwner {\r\n        whaleSellThreshold = _sellThreshold;\r\n        whaleSellTimer = _time;\r\n        whaleFeeMultiplier = _feeMultiplier;\r\n        whaleFeeDivider = _feeDivider;\r\n    }\r\n\r\n        /*\r\n            \u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2584\u2580\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2580\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\r\n            \u2588\u2580\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2591\u2588\u2003\u2588\u2588\u2584\u2003\u2591\u2588\u2591\u2003 \u2003\u2588\u2580\u2580\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2584\u2003\u2584\u2588\r\n        */\r\n\r\n    //Allows the contract owner to enable the reflection pool feature\r\n    function enableRocketPool(bool _enablePool, bool _enableContributionOnBuys) external onlyOwner {\r\n        \r\n        enableRocketPools = _enablePool;\r\n        bonusContributionBuys = _enableContributionOnBuys;\r\n    }\r\n\r\n    //Calculates whether the reflection pool is awarded by rolling a random number\r\n    function calculatePoolReward(bool _transferring, uint _chanceMultiplier) private returns (uint256) {\r\n        // If the transfer is a buy or wallet-wallet transfer, and the reflection pool is above a certain token threshold, start to award it\r\n        uint256 reward = 0;\r\n        uint256 poolTokens = megaPay;\r\n        uint _cPoolChance = _transferring ? megaPayTransferChance : megaPayChance;\r\n        if (poolTokens >= megaPayThreshold) {\r\n            // Generates a random number between 1 and 1000\r\n            lastRoll = random(); \r\n            if(lastRoll <= _cPoolChance.mul(_chanceMultiplier)) {\r\n                reward = poolTokens;\r\n            }\r\n        } \r\n        return reward;\r\n    }\r\n\r\n    // Calculates a random number by:\r\n    // 1. Taking the current mining block difficulty (set differently for each transaction), current block timestamp (unique value), and a private incrementing nonce (number used only once) value\r\n    // 2. \"Encode & Pack\" the inputs and use keccak256 to generate a unique 256-bit hash value\r\n    // 3. Convert the hash value to an unsigned integer value, then use modulus 1000 to take only the last 3 digits. This will give us a random number between 0 and 999, we add 1 to make 1-1000\r\n    function random() private returns (uint) {\r\n        uint r = uint(uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, _nonce))) % 1000);\r\n        r = r.add(1);\r\n        _nonce++;\r\n        return r;\r\n    }\r\n\r\n    function setDustDividers(uint256 _earnPayDustDivider, uint256 _earnPayDustMultiplier, uint256 _earnPayDustRateDivider, uint256 _earnPayDustRateMultiplier, uint256 _distributorDustDivider, uint256 _distributorDustMultiplier, uint256 _rewardRateDivider, uint256 _rewardRateMultiplier) external onlyOwner {\r\n        require(_earnPayDustDivider > 0 && _earnPayDustRateDivider > 0 && _distributorDustDivider > 0 && _rewardRateDivider > 0, 'Divs must be > 0');\r\n        require(_earnPayDustDivider >= _earnPayDustMultiplier && _earnPayDustRateDivider >= _earnPayDustRateMultiplier && _distributorDustDivider >= _distributorDustMultiplier && _rewardRateDivider >= _rewardRateMultiplier, 'Divider must be >= Multiplier');\r\n        distributor.setDustDividers(_distributorDustDivider, _distributorDustMultiplier,  _rewardRateDivider, _rewardRateMultiplier); //distributor values are seperate from the main contract (this)\r\n        earnPayDustDivider = _earnPayDustDivider;\r\n        earnPayDustMultiplier = _earnPayDustMultiplier;\r\n        spaceDustRateDivider = _earnPayDustRateDivider;\r\n        spaceDustRateMultiplier = _earnPayDustRateMultiplier;\r\n    }\r\n\r\n    //Handles internal rewarding of the rocket pools (megabuy, buyboost) \r\n    function rocketPoolTransfer(address winner, uint256 rewardAmount, bool awardMega) internal {\r\n        if(awardMega) //Rewards MegaPay\r\n        {\r\n            _balances[winner] = _balances[winner].add(rewardAmount);\r\n            _megaPayEarnings[winner] = _megaPayEarnings[winner].add(rewardAmount);\r\n            megaPay = 0;\r\n            previousWinner = winner;\r\n            previousWonAmount = rewardAmount;\r\n            previousWinTime = block.timestamp;\r\n            emit MegaPayAward(winner, rewardAmount, block.timestamp);\r\n            emit Transfer(address(this), winner, rewardAmount);\r\n        }\r\n        else{ //Rewards Buy Boost\r\n            _balances[winner] = _balances[winner].add(rewardAmount);\r\n            _buyBonusEarnings[winner] = _buyBonusEarnings[winner].add(rewardAmount);\r\n            buyBoost = 0;\r\n            previousBoostWinner = winner;\r\n            emit BonusBuyAward(winner, rewardAmount);\r\n            emit Transfer(address(this), winner, rewardAmount);\r\n        }\r\n    }\r\n\r\n    function setMegaPaySettings(uint256 _threshold, uint256 _minimumSpend, uint256 _minimumHODL, uint256 _minimumTransfer, uint _buyChance, uint _bonusChance, uint _walletToWalletChance) external onlyOwner {\r\n        megaPayThreshold = _threshold; \r\n        megaPayMinimumSpend = _minimumSpend; \r\n        megaPayMinimumHODL = _minimumHODL; \r\n        megaPayChance = _buyChance;\r\n        bonusChance = _bonusChance;\r\n        megaPayTransferChance = _walletToWalletChance;\r\n        megaPayMinimumTransfer = _minimumTransfer;\r\n    }\r\n    function getMegaPaySettings() external view returns (uint256, uint256, uint256, uint256, uint, uint, uint) {\r\n        return (megaPayThreshold, megaPayMinimumSpend, megaPayMinimumHODL, megaPayMinimumTransfer, megaPayChance, bonusChance, megaPayTransferChance);\r\n    }\r\n    function getUserQualifiesForMegaPay(address holder) external view returns (bool) {\r\n        return  enableRocketPools && !isDividendExempt[holder] && (_balances[holder] >= megaPayMinimumHODL);\r\n    }\r\n\r\n/*\r\n\r\n        \u2588\u2591\u2588\u2591\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2584\u2580\u2588\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003 \u2003\u2584\u2580\u2003\u2588\u2591\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2584\u2591\u2588\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2003\u2588\u2580\u2580\u2003 \u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2003\u2580\u2584\r\n        \u2580\u2584\u2580\u2584\u2580\u2003\u2588\u2584\u2588\u2003\u2588\u2580\u2584\u2003\u2588\u2591\u2580\u2591\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003 \u2003\u2580\u2584\u2003\u2580\u2584\u2580\u2584\u2580\u2003\u2588\u2588\u2584\u2003\u2588\u2591\u2580\u2588\u2003 \u2003\u2588\u2580\u2584\u2003\u2588\u2588\u2584\u2003\u2580\u2584\u2580\u2003\u2588\u2588\u2584\u2003\u2588\u2580\u2584\u2003\u2584\u2588\u2003\u2588\u2588\u2584\u2003 \u2003\u2588\u2580\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2588\u2003\u2591\u2584\u2003\u2584\u2580\r\n\r\n*/\r\n    //allows the ability for devs/owners to send token directly to the reward pools for holders to claim \r\n    function wenReverseRug(uint256 megaPayAmount, uint256 buyBoostAmount, uint256 spaceDustAmount) external returns(bool){\r\n        require(megaPayAmount > 0 || buyBoostAmount > 0 || spaceDustAmount > 0, 'Amnt needs to be > 0 for 1 field');\r\n        require(_balances[msg.sender] >= megaPayAmount.add(buyBoostAmount).add(spaceDustAmount), 'user does not own enough tokens');\r\n        _balances[msg.sender] = _balances[msg.sender].sub(megaPayAmount).sub(buyBoostAmount).sub(spaceDustAmount,'cannot have neg tokens');\r\n        megaPay = megaPay.add(megaPayAmount);\r\n        buyBoost = buyBoost.add(buyBoostAmount);\r\n        spaceDust = spaceDust.add(spaceDustAmount); \r\n        reverseRugAccumulator = reverseRugAccumulator.add(megaPayAmount).add(buyBoostAmount).add(spaceDustAmount);\r\n        emit WenReverseRug(msg.sender, megaPayAmount, buyBoostAmount, spaceDustAmount);\r\n        return true;\r\n    } \r\n\r\n/*\r\n\r\n        \u2588\u2584\u2584\u2003\u2588\u2591\u2591\u2003\u2584\u2580\u2588\u2003\u2588\u2580\u2580\u2003\u2588\u2584\u2580\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2591\u2591\u2003\u2588\u2580\u2580\u2003\u2588\u2580\r\n        \u2588\u2584\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2591\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2584\u2584\u2003\u2588\u2588\u2584\u2003\u2584\u2588\r\n\r\n*/\r\n    function setBlackHole(uint256 _blackHoleMinimumSD, uint256 _blackHoleMinimumMP, uint _bHchanceMultiplier) external onlyOwner {\r\n        blackHoleMinimum = _blackHoleMinimumSD;\r\n        blackHoleMinimumMP = _blackHoleMinimumMP;\r\n        bHchanceMultiplier = _bHchanceMultiplier;\r\n    }\r\n\r\n    //Holder can claim space dust \r\n    function sendToBlackHole(uint256 tokenAmount, bool blackHoleMechanismChoice) external {\r\n        require(!isDividendExempt[msg.sender] && enableRocketPools,'is exempt or off');\r\n        require(_balances[msg.sender] >= tokenAmount && _balances[msg.sender] >=megaPayThreshold, 'does not hodl enough');\r\n        uint256 alloc = tokenAmount.mul(totalFeeSells).div(feeDenominator); // Take sell fee alloc and send back to BuyBoost + MegaPay\r\n        buyBoost = buyBoost.add(alloc.div(2)); //split alloc between rewards pools\r\n        megaPay = megaPay.add(alloc.sub(alloc.div(2)));\r\n        uint256 amountReceived = tokenAmount.sub(alloc);\r\n        _totalSupply = _totalSupply.sub(amountReceived, 'supply cannot be neg');\r\n        _balances[msg.sender] = _balances[msg.sender].sub(tokenAmount);\r\n        spaceDustBurned = spaceDustBurned.add(amountReceived);\r\n        if(blackHoleMechanismChoice)\r\n        {\r\n            require(tokenAmount >= blackHoleMinimum, 'amnt not enough');\r\n            require(!disabledRewardDust[msg.sender], 'collect dust not enabled');\r\n            uint256 dustAllocation=0;\r\n            if (spaceDust > 0) {\r\n                        dustAllocation = spaceDust.div(spaceDustRateDivider).mul(spaceDustRateMultiplier);\r\n                        _balances[msg.sender] = _balances[msg.sender].add(dustAllocation);\r\n                        spaceDustEarnings[msg.sender] = spaceDustEarnings[msg.sender].add(dustAllocation);\r\n                        emit DustTransfer(msg.sender, dustAllocation, block.timestamp);\r\n                        emit Transfer(address(this), msg.sender, dustAllocation);\r\n                        spaceDust = spaceDust.sub(dustAllocation);\r\n                        try distributor.transferRewardDust(msg.sender) {} catch {}\r\n                        try distributor.setShare(msg.sender, _balances[msg.sender], !disabledTransferEarnings[msg.sender], enabledCustomRewards[msg.sender]) {} catch {} \r\n            }\r\n        }\r\n        else{\r\n            require(tokenAmount >= blackHoleMinimumMP, 'amnt not enough');\r\n            uint256 chance_multiplier = boostRewardIndex[msg.sender] >= rewardIndex2 ? rewardIndex2Mult : 0;\r\n            uint256 poolReward = calculatePoolReward(false, bHchanceMultiplier.add(chance_multiplier));\r\n            if (poolReward > 0) {\r\n                rocketPoolTransfer(msg.sender, poolReward, true);\r\n            }\r\n            if (buyBoost > 0 && (random() <= bonusChance.mul(bHchanceMultiplier.add(chance_multiplier)))) {\r\n                rocketPoolTransfer(msg.sender, buyBoost, false); \r\n            }\r\n            try distributor.setShare(msg.sender, _balances[msg.sender], true, enabledCustomRewards[msg.sender]) {} catch {} \r\n            boostRewardIndex[msg.sender] = boostRewardIndex[msg.sender].add(1);  \r\n        }\r\n        internalApprove(_dexRouter, _totalSupply);\r\n        internalApprove(address(pair), _totalSupply);\r\n        emit Transfer(msg.sender, address(0), amountReceived);\r\n        emit SentToBlackHole(msg.sender, amountReceived);\r\n    }\r\n    \r\n    event SentToBlackHole(address sender, uint256 tokenAmount);\r\n    event MegaPayAward(address winner, uint256 amount, uint time);\r\n    event BonusBuyAward(address winner, uint256 amount);\r\n    event DustTransfer(address winner, uint256 amount, uint time);\r\n    event WenReverseRug(address sender, uint256 megaPayAmount, uint256 buyBoostAmount, uint256 spaceDustAmount);\r\n    event SwappedTokenAddresses(address newToken);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BonusBuyAward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"DustTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"MegaPayAward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"SentToBlackHole\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"SwappedTokenAddresses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"megaPayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyBoostAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spaceDustAmount\",\"type\":\"uint256\"}],\"name\":\"WenReverseRug\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_timeSinceFirstSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoBuybackEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bHchanceMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blackHoleMinimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blackHoleMinimumMP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusChance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusContributionBuys\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boostRewardIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chanceMultiplierBuyThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimEarnings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earnPayDustDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earnPayDustMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyResetShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enablePool\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_enableContributionOnBuys\",\"type\":\"bool\"}],\"name\":\"enableRocketPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableRocketPools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"geUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getExemptions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMegaPaySettings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getTransferSettings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getUnpaidReflections\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getUserQualifiesForMegaPay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getUserReflectionsEarnedAndWinnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"inWhaleTimer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interfaceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"isCustomTokenEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRoll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"distributorGasFee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_processDefault\",\"type\":\"bool\"}],\"name\":\"manuallyProcessDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"megaPay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"megaPayChance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"megaPayMinimumHODL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"megaPayMinimumSpend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"megaPayMinimumTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"megaPayThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"megaPayTransferChance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousBoostWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousWinTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousWonAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reflectionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reverseRugAccumulator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardIndex2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardIndex2Mult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardIndexMult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rocketPoolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"blackHoleMechanismChoice\",\"type\":\"bool\"}],\"name\":\"sendToBlackHole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setAutoBuybackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enableBasicTransfers\",\"type\":\"bool\"}],\"name\":\"setBasicTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blackHoleMinimumSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blackHoleMinimumMP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bHchanceMultiplier\",\"type\":\"uint256\"}],\"name\":\"setBlackHole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardIndexMult\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardIndex2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardIndex2Mult\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chanceMultiplierBuyThreshold\",\"type\":\"uint256\"}],\"name\":\"setBuyBoostRewardMultipliers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nRouter\",\"type\":\"address\"}],\"name\":\"setDexRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPeriodCustom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistributionCustom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_defaultThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rotatingThreshold\",\"type\":\"uint256\"}],\"name\":\"setDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"setDistributorGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_earnPayDustDivider\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earnPayDustMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earnPayDustRateDivider\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earnPayDustRateMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_distributorDustDivider\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_distributorDustMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRateDivider\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRateMultiplier\",\"type\":\"uint256\"}],\"name\":\"setDustDividers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sustainingFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buybackFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reflectionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sustainingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rocketPoolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeDenominator\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_interface\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_interfaceFee\",\"type\":\"uint256\"}],\"name\":\"setInterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isRegisteredMerchant\",\"type\":\"bool\"}],\"name\":\"setIsMerchant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumSpend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumHODL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumTransfer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyChance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusChance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_walletToWalletChance\",\"type\":\"uint256\"}],\"name\":\"setMegaPaySettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transferFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_merchantFee\",\"type\":\"uint256\"}],\"name\":\"setOtherFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_swapThreshold\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"shouldAutomateLiquidity\",\"type\":\"bool\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_targetLiquidityDenominator\",\"type\":\"uint256\"}],\"name\":\"setTargetLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_processManually\",\"type\":\"bool\"}],\"name\":\"setTokenContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_processManually\",\"type\":\"bool\"}],\"name\":\"setTokenContractAddressRotating\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_feeMultiplier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_feeDivider\",\"type\":\"uint8\"}],\"name\":\"setWhaleSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldPairLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spaceDust\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spaceDustBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"spaceDustEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spaceDustRateDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spaceDustRateMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sustainingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sustainingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"switchReflections\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_option\",\"type\":\"uint256\"}],\"name\":\"togglePaySettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"triggerEarnPayBuyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"megaPayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBoostAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spaceDustAmount\",\"type\":\"uint256\"}],\"name\":\"wenReverseRug\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whaleFeeDivider\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whaleFeeMultiplier\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whaleSellThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whaleSellTimer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Earnpay", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f4bf94b68aa5df1fc75cb182214e2fd13c81095e9cdcafb4fddc066c0d50b486"}