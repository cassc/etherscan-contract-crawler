{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/IclickVaultCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\n\\ncontract IclickVaultCore is ReentrancyGuard{\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    IERC20 public immutable _iclickToken;\\n    IERC20 internal immutable _usdToken;\\n    IUniswapRouter public immutable uniswapRouter;\\n    address immutable internal dev;\\n    // System Settings [on buying tokens]\\n    address internal immutable adminWallet; // 50%\\n    uint internal constant MLTIPLR          = 1e9;\\n    uint internal constant DECIMAL          = 1e18;\\n    uint internal constant DIVIDER          = 10000;\\n    uint internal constant ACTIVATION_ADMIN = 5000; // 50% goes to admin wallet\\n    uint internal constant ACTIVATION_RSRVD = 3000; // 50% goes to liquidty reserve\\n    uint internal constant MINWDRW          = 1 ether; // $1 Minimum\\n    uint internal constant MAXWDRW          = 500 ether; // $500 Maximum\\n    \\n    // system config\\n    uint[] internal PACKS        = [ 50 ether, 100 ether, 250 ether, 500 ether, 1000 ether, 2000 ether, 5000 ether, 7500 ether, 10000 ether ];\\n    uint[] internal ECAPS        = [ 60 ether, 122 ether, 312.5 ether, 650 ether, 1320 ether, 2700 ether, 6850 ether, 10500 ether, 14500 ether ];\\n    uint internal EXPIR          = 30; // number of activities days for each packs\\n    uint[] internal COMMI        = [ 300, 200, 100 ]; // 5% commission [on activation]\\n    uint internal COMCL          = 50; // 0.5% commission [on click]\\n    uint internal SWAPG          = 500; // +5% while swapping\\n    uint internal constant DAILY = 24 hours; // 24 hours;\\n    bool internal enabled; // enable/disable activations\\n    uint internal _lstRqt;\\n\\n    // user structure\\n    struct User{\\n        uint uid; // unique user id\\n        address sponsor;\\n        uint balance; // active usdt balance\\n        uint earningsCredited; // total credited\\n        uint commissionEarned; // updates on click records\\n        uint earningCap; // updates on activation\\n        uint8 currentPack; // [Last pack activated] \\n        uint totalActivation; // total token spent\\n        uint daysLeft; // activities days left\\n        uint lastRecord;\\n        uint lastWithdrawal;\\n    }\\n\\n    struct Stats{\\n        uint totalUsers;\\n        uint totalActivation; // total in iclick\\n        uint totalSold; // iclick\\n        uint totalBalance; // total usdt to pay\\n        uint totalWithdrawn; // total usdt\\n        uint totalUSDTactivation; // total activation in usdt\\n    }\\n    \\n    mapping (address => User) public users;\\n\\n    Stats public stats;\\n\\n    bool private inSwapAndLiquify;\\n    \\n    modifier onlyAuth () {\\n        require(msg.sender == dev || msg.sender == adminWallet, 'unAuthorized');\\n        _;\\n    }\\n\\n    // Only Members\\n    modifier isMember () {\\n        require(users[msg.sender].uid > 0, '_Memb');\\n        _;\\n    }\\n\\n    // only Active User\\n    modifier onlyActive (){\\n        require(users[msg.sender].daysLeft > 0, '_Actv');\\n        _;\\n    }\\n\\n    // Can Earn\\n    modifier canEarn () {\\n        require(users[msg.sender].earningCap > 0, '_Earn');\\n        _;\\n    }\\n\\n    // Daily Record\\n    modifier allowDaily () {\\n        require(users[msg.sender].lastRecord + DAILY <= block.timestamp, 'Daily Only');\\n        _;\\n    }\\n\\n    modifier withdrawDaily() {\\n        require(users[msg.sender].lastWithdrawal + DAILY <= block.timestamp, '24hrsHold');\\n        _;\\n    }\\n\\n    // Has balance\\n    modifier hasBalance (uint _amount) {\\n        require (users[msg.sender].balance >= _amount, 'NoBalce');\\n        _;\\n    }\\n\\n    // Minimum Withdrawal\\n    modifier minWithd (uint _amount) {\\n        require(_amount >= MINWDRW, 'MinWithd');\\n        _;\\n    }\\n\\n    // Valid Pack\\n    modifier packExists (uint8 _packId) {\\n        require (_packId < PACKS.length, 'WgPck');\\n        _;\\n    }\\n    \\n    modifier lockTheSwap {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    // events\\n    // new user\\n    event NewUser (address indexed _sender, address indexed _refBy);\\n    // pack activation\\n    event NewPackActivation (address indexed _sender, uint indexed _packId, uint _tokenSpent);\\n    // Daily click recorded \\n    event NewRecord (address indexed _sender, uint indexed _sysId, uint _earnings);\\n    // commission earned\\n    event CommissionEarned (address indexed _benefactor, address _from, uint indexed _level, uint _amount, bool _activation);\\n    // successful withdrawal\\n    event Withdrawan (address indexed _sender, uint _amount);\\n    // token sold\\n    event Tokensold (address indexed _sender, uint _amount);   \\n    // token Sent\\n    event TokenSent(address indexed _sender, uint amount);\\n\\n    constructor(){ \\n        dev = msg.sender; \\n        adminWallet = address(0xfCb339d1e5F06fec7E6646A2d70C6d0e587ACDE0); // testnet 0x2ECe85C590313fFB84A6ba5978e53Ca5551234f0 // mainnet 0xfCb339d1e5F06fec7E6646A2d70C6d0e587ACDE0\\n        _iclickToken = IERC20(address(0xc8C06a58E4ad7c01b9bb5Af6C76a7a1CfEBd0319)); // testnet 0x80247A78b06bac28B2086D0eb0012feCD0442B66 // mainnet 0xc8C06a58E4ad7c01b9bb5Af6C76a7a1CfEBd0319\\n        _usdToken = IERC20(address(0x55d398326f99059fF775485246999027B3197955)); // testnet 0xC6Efc0f7AF6e0B3e413d8FdD339FAf4d9a6e2D8F // mainnet 0x55d398326f99059fF775485246999027B3197955\\n        IUniswapRouter _uniswapV2Router = IUniswapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E); // testnet 0xD99D1c33F9fC3444f8101754aBC46c52416550D1 // mainnet 0x10ED43C718714eb63d5aA57B78B54704E256024E\\n        uniswapRouter = _uniswapV2Router;\\n    }\\n\\n    // register user\\n    function register (address _sender, address _refBy) internal {\\n        User storage _user = users[msg.sender];\\n        if(_refBy == address(0) || _refBy == _sender || users[_refBy].uid == 0){\\n            _refBy = dev;\\n        }\\n        stats.totalUsers++;\\n        _user.uid = stats.totalUsers;\\n        _user.sponsor = _refBy;\\n    }\\n\\n    function dispatchTokens (uint _amount) internal {\\n        // 50% Admin Funds\\n        uint _admin = _amount * ACTIVATION_ADMIN / DIVIDER;\\n        _iclickToken.transfer(adminWallet, _admin);\\n        emit TokenSent(adminWallet, _admin);\\n    }\\n\\n    function processActivation (address _sender, uint8 _packId, uint _tokens) internal {\\n        User storage _user = users[_sender];\\n        if(_user.currentPack < _packId) _user.currentPack = _packId;\\n        _user.earningCap       += ECAPS[_packId];\\n        _user.daysLeft         += EXPIR;\\n        _user.totalActivation  += _tokens; // total token spent\\n        _user.lastRecord        = block.timestamp;\\n\\n        stats.totalActivation     += _tokens;\\n        stats.totalUSDTactivation += PACKS[_packId];\\n        // dispatch tokens\\n        dispatchTokens(_tokens);\\n        // dispatch commissions [usdt value]\\n        dipatchCommission(_sender, PACKS[_packId], true);\\n    }\\n\\n    function dipatchCommission(address _sender, uint _reward, bool _activation) internal {\\n        uint _comm = _reward * COMCL / DIVIDER;\\n        address _upline = users[_sender].sponsor;\\n        for(uint8 i = 0; i < 3; i++){\\n            if(_upline == address(0)) break;\\n            if(_activation) _comm = _reward * COMMI[i] / DIVIDER;\\n            users[_upline].balance          += _comm;\\n            users[_upline].commissionEarned += _comm;\\n            stats.totalBalance              += _comm;\\n            emit CommissionEarned (_upline, _sender, i + 1, _comm, _activation);\\n            \\n            _upline = users[_upline].sponsor;\\n        }\\n    }\\n\\n    function getDailyRewrd(User memory _sender) internal pure returns(uint _reward) {\\n        // uint8 _packId   = _user.currentPack;\\n        // _reward         = ECAPS[_packId] / EXPIR;\\n        if(_sender.daysLeft > 0) _reward         = _sender.earningCap / _sender.daysLeft;\\n        if(_sender.earningCap < _reward) _reward = _sender.earningCap;\\n    }\\n\\n    // get TOKEN_USDT rate\\n    function getTokenAmount(\\n        address _tokenA,\\n        address _tokenB,\\n        uint _amountIn\\n    ) internal view returns (uint256 _tokens) {\\n        address[] memory path = new address[](2);\\n        path[0] = _tokenA;\\n        path[1] = _tokenB;\\n        uint[] memory amounts = uniswapRouter.getAmountsOut(_amountIn, path);\\n        return amounts[1];\\n    }\\n\\n    // swap \\n    function swapAndLiquify(IERC20 _token1, IERC20 _token2, uint tokenAmount) internal lockTheSwap{\\n        // uint256 tokenAmount = _busdAddress.balanceOf(address(this));\\n        _token1.approve(address(uniswapRouter), tokenAmount);\\n        // generate the uniswap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(_token1);\\n        path[1] = address(_token2);\\n        // path[1] = uniswapRouter.WETH();\\n        // make the swap\\n        uniswapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        emit Tokensold(address(this), tokenAmount);\\n    }\\n\\n    function getTokenPrice () public view returns (uint){\\n        uint oneCTRLtoUSDT = getTokenAmount(address(_iclickToken), address(_usdToken), (1 ether / MLTIPLR));\\n        return oneCTRLtoUSDT * MLTIPLR;\\n    }\\n\\n    // prevent token loss\\n    function getTokens (uint _amount, IERC20 _token) public onlyAuth {\\n        require(IERC20(_token).balanceOf(address(this)) >= _amount, 'LowBlce');\\n        IERC20(_token).transfer(msg.sender, _amount);\\n        emit TokenSent(msg.sender, _amount);\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(\\n                abi.decode(returndata, (bool)),\\n                \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n            );\\n        }\\n    }\\n}\\n\\ninterface IERC20 {\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly {\\n            codehash := extcodehash(account)\\n        }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n}\\n\\ninterface IUniswapRouter {\\n    function WETH() external pure returns (address);\\n\\n    function getAmountsOut(\\n        uint amountIn,\\n        address[] calldata path\\n    ) external view returns (uint[] memory amounts);\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IclickVaultEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./IclickVaultCore.sol\\\";\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\n\\ncontract IclickVaultEngine is IclickVaultCore {\\n\\n    constructor(){}\\n\\n    // activate pack\\n    function activateAcc (address _refBy, uint8 _packId) public nonReentrant packExists(_packId) {\\n        address _sender = msg.sender;\\n        if(users[_sender].uid == 0 || users[_sender].sponsor == address(0)){\\n            register(_sender, _refBy);\\n        }\\n\\n        uint _packValue = PACKS[_packId]; // usdt Value\\n\\n        // get usdt Value\\n        uint oneICLICKtoUSDT = getTokenAmount(address(_iclickToken), address(_usdToken), (1 ether / MLTIPLR));\\n\\n        uint _iclickValue = (_packValue / (oneICLICKtoUSDT * MLTIPLR)) * DECIMAL;\\n        require (_iclickToken.transferFrom(_sender, address(this), _iclickValue));\\n        // activate Pack \\n        processActivation (_sender, _packId, _iclickValue);\\n        emit NewPackActivation(_sender, _packId, _iclickValue);\\n    }\\n\\n    // record click [once daily]\\n    function recordDailyClick (uint _sysId) public nonReentrant onlyActive canEarn allowDaily{\\n        User storage _user = users[msg.sender];\\n        uint _reward            = getDailyRewrd(_user);\\n        \\n        _user.balance          += _reward;\\n        _user.earningCap       -= _reward;\\n        _user.earningsCredited += _reward;\\n        _user.lastRecord        = block.timestamp; // updates once daily\\n        _user.daysLeft          -= 1;\\n        if(_user.earningCap == 0) _user.daysLeft = 0;\\n        // pay affiliate commissions\\n        dipatchCommission(msg.sender, _reward, false);\\n        stats.totalBalance     += _reward;\\n        emit NewRecord (msg.sender, _sysId, _reward);\\n    }\\n\\n    // withdraw usdt\\n    function withdrawEarnings (uint _amount) public nonReentrant minWithd(_amount) onlyActive withdrawDaily hasBalance(_amount) {\\n        User storage _user = users[msg.sender];\\n        // maxi withdrawal is $200 [withdrawal is once daily]\\n        // contract must sell to withdraw.\\n        uint _contractBalance = _usdToken.balanceOf(address(this));\\n        if(_contractBalance < _amount){\\n            // swap and liquify [get usdt]\\n            uint _tokenAmount = (_amount / getTokenPrice()) * DECIMAL;\\n            _tokenAmount     += _tokenAmount * SWAPG / DIVIDER; // + 5%\\n            swapAndLiquify(_iclickToken, _usdToken, _tokenAmount);\\n            stats.totalSold += _tokenAmount; \\n            emit Tokensold(msg.sender, _tokenAmount);\\n            _contractBalance = _usdToken.balanceOf(address(this));\\n        }\\n        \\n        // maxi withdrawal is $500 [withdrawal is once daily] [save any extra to users balance]\\n        if(_amount > MAXWDRW){\\n            _amount = MAXWDRW; // withdrawal limit\\n        }\\n\\n        require(_amount < _contractBalance, 'noLqty');\\n\\n        _user.balance        -= _amount;\\n        stats.totalBalance   -= _amount;\\n        stats.totalWithdrawn += _amount;\\n        _user.lastWithdrawal  = block.timestamp;\\n        require(_usdToken.transfer(msg.sender, _amount));\\n        emit Withdrawan (msg.sender, _amount);\\n    }\\n}\"\r\n    },\r\n    \"contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.19;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\n\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier isHuman() {\\n        require(tx.origin == msg.sender, \\\"sorry humans only\\\");\\n        _;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_benefactor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_activation\",\"type\":\"bool\"}],\"name\":\"CommissionEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_packId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenSpent\",\"type\":\"uint256\"}],\"name\":\"NewPackActivation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_sysId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_earnings\",\"type\":\"uint256\"}],\"name\":\"NewRecord\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_refBy\",\"type\":\"address\"}],\"name\":\"NewUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Tokensold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawan\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_iclickToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refBy\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_packId\",\"type\":\"uint8\"}],\"name\":\"activateAcc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sysId\",\"type\":\"uint256\"}],\"name\":\"recordDailyClick\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalUsers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalActivation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUSDTactivation\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"uid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earningsCredited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commissionEarned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earningCap\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"currentPack\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalActivation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daysLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRecord\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IclickVaultEngine", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}