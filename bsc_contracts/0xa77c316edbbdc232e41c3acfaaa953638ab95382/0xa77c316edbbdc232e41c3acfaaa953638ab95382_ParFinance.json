{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n\r\n// File: contracts/Fiverr/parifinance/parifinanceV3.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ParFinance is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant BASE = 10**18;\r\n    uint256 public constant DIVIDEND_PERCENTAGE = 10;\r\n    uint256 public constant CASHBACK_PERCENTAGE = 15;\r\n    uint256 public constant APR = 12;\r\n    uint256 public constant MAX_LTV = 80;\r\n    // uint256 public constant LIQUIDATION_THRESHOLD = 49;\r\n    uint256 public constant WITHDRAWAL_FEE = 39;\r\n    uint256 public constant BORROWING_FEE = 39;\r\n    // uint256 public constant BORROWING_UTILIZATION_THRESHOLD = 80;\r\n    // uint256 public constant BORROWING_INTEREST_RATE = 12;\r\n    // uint256 public constant BORROWING_INTEREST_RATE_THRESHOLD = 30;\r\n    uint256 public constant maxLendAmount = 9000 * BASE;\r\n    uint256 public constant maxBNBDeposit = 30 * BASE;\r\n    uint256 public constant maxBETHDeposit = 5 * BASE;\r\n    uint256 public constant maxADADeposit = 39000 * BASE;\r\n    uint256 public constant depositFee = 0.001 ether;\r\n\r\n\r\n\r\n    uint256 public depositFeeCollected;\r\n    uint256 public lendingApr = 1020;\r\n\r\n    uint256 public totalBorrowings;\r\n\r\n\r\n    //tokens\r\n    address public dai;\r\n    address public usdc;\r\n    address public usdt;\r\n\r\n    //deposit tokens\r\n    address public eth;\r\n    address public ada;\r\n\r\n    //price feeds\r\n    address private daiPriceFeed;\r\n    address private usdcPriceFeed;\r\n    address private usdtPriceFeed;\r\n    address private ethPriceFeed;\r\n    address private adaPriceFeed;\r\n\r\n\r\n    struct Token {\r\n        address tokenAddress;\r\n        uint256 balance;\r\n    }\r\n\r\n    struct Collateral {\r\n        address tokenAddress;\r\n        uint256 amount;\r\n        uint256 depositTime;\r\n    }\r\n\r\n    struct Lend {\r\n        address tokenAddress;\r\n        uint256 amount;\r\n        uint256 lastDepositTime;\r\n    }\r\n\r\n    struct Loan {\r\n        uint256 id;\r\n        address borrower;\r\n        address token;\r\n        uint256 amount;\r\n        address collatToken;\r\n        uint256 bnbCollateral;\r\n        uint256 tokenCollateral;\r\n        uint256 apr;\r\n        uint256 startTimestamp;\r\n        bool active;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        IERC20 lpToken; // Address of LP token contract.\r\n        uint256 APY;\r\n        uint256 totalInterest;\r\n        uint256 totalDeposited;\r\n        uint256 totalBorrowed;\r\n        uint256 dividendReward;\r\n        uint256 lastCalculatedInterest;\r\n        uint256 lastCalculatedBorrow;\r\n    }\r\n\r\n    struct depositToken {\r\n        address tokenAddress;\r\n        uint256 balance;\r\n    }\r\n\r\n    struct diviDend {\r\n        uint256 amount;\r\n        uint256 lastCalculatedDividend;\r\n        uint256 lastRewardTimeStamp;\r\n    }\r\n\r\n    address [] public lendingTokens;\r\n\r\n    mapping(address => uint256) public totalDividend;\r\n    mapping(address => depositToken) public deposittokens;\r\n    mapping (address => PoolInfo) public pools;\r\n    mapping(address => Token) public tokens;\r\n    mapping (address => uint256) public bnbCollat;\r\n    mapping(address =>mapping(address => Collateral)) public collatDet;\r\n    mapping(address =>mapping(address => Lend)) public lendDet;\r\n    mapping(address =>mapping(address => uint256)) public earnedInterest;\r\n    mapping(address => uint256) public borrowingDebt;\r\n    mapping(address => Loan[]) public loansByBorrower;\r\n    mapping (address => mapping(address => diviDend)) public totalBorrowedAmountByUser;\r\n    mapping (address => bool) private lenders;\r\n    mapping (address => bool) private borrowers;\r\n    mapping (address => uint256) public adminFee;\r\n    mapping (address => uint256) public totalDeposits;\r\n\r\n\r\n    event NewDeposit(address indexed from, address indexed tokenAddress, uint256 amount);\r\n    event NewWithdrawal(address indexed from, address indexed tokenAddress, uint256 amount, uint256 fee);\r\n    event NewLoan(address indexed borrower, uint256 amount, uint256 collateral);\r\n    event LoanRepayed(uint256 indexed loanId, address indexed borrower, uint256 amount, uint256 interest);\r\n    event DividendPaid(address indexed to, uint256 amount);\r\n    event CashbackPaid(address indexed to, uint256 amount);\r\n\r\n    constructor(address _daiPriceFeed,address _usdcPriceFeed,address _usdtPriceFeed, address _ethPriceFeed, address _adaPriceFeed, address _dai, address _usdc, address _usdt, address _eth, address _ada) {\r\n        daiPriceFeed = _daiPriceFeed;\r\n        usdcPriceFeed = _usdcPriceFeed;\r\n        usdtPriceFeed = _usdtPriceFeed;\r\n        ethPriceFeed = _ethPriceFeed;\r\n        adaPriceFeed = _adaPriceFeed;\r\n\r\n\r\n        tokens[_dai] = Token(_dai, 0);\r\n        tokens[_usdc] = Token(_usdc, 0);\r\n        tokens[_usdt] = Token(_usdt, 0);\r\n        deposittokens[_eth] = depositToken(_eth, 0);\r\n        deposittokens[_ada] = depositToken(_ada, 0);\r\n\r\n        dai = _dai;\r\n        usdc = _usdc;\r\n        usdt = _usdt;\r\n        eth = _eth;\r\n        ada = _ada;\r\n\r\n        lendingTokens.push(dai);\r\n        lendingTokens.push(usdc);\r\n        lendingTokens.push(usdt);\r\n\r\n    }\r\n\r\nfunction addPool(IERC20 _lpToken, uint256 _APY, uint256 _totalInterest, uint256 _totalDeposited,uint256 _totalBorrowed)public onlyOwner {\r\n    require(tokens[address(_lpToken)].tokenAddress != address(0), \"Invalid token address\");\r\n\r\n    pools[address(_lpToken)] = PoolInfo({\r\n        lpToken: _lpToken,\r\n        APY: _APY,\r\n        totalInterest: _totalInterest,\r\n        totalDeposited:_totalDeposited,\r\n        totalBorrowed:_totalBorrowed,\r\n        dividendReward: 0,\r\n        lastCalculatedInterest:0,\r\n        lastCalculatedBorrow:0\r\n    });\r\n}\r\n\r\nfunction addLiquidity( address _lpTokenAddress, uint256 amount) public onlyOwner{\r\n    require(amount > 0, \"Amount must be greater than 0\");\r\n    pools[_lpTokenAddress].lpToken.transferFrom(msg.sender, address(this), amount);\r\n\r\n    pools[_lpTokenAddress].totalDeposited += amount;\r\n    tokens[_lpTokenAddress].balance += amount;\r\n    totalDeposits[_lpTokenAddress] += amount;\r\n}\r\n\r\nfunction depositTokenCollat(address tokenAddress, uint256 amount) public payable {\r\n    uint256 maxDeposit = tokenAddress == eth ? maxBETHDeposit : maxADADeposit;\r\n    require(amount > 0 && amount <= maxDeposit, \"Invalid Amount\");\r\n    require(tokenAddress != address(0), \"Invalid token address\");\r\n    require(msg.value == depositFee, \"Wrong Fee\");\r\n    depositToken storage deposittoken = deposittokens[tokenAddress];\r\n    require(deposittoken.tokenAddress == tokenAddress, \"Invalid token address\");\r\n\r\n    IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\r\n    deposittoken.balance += amount;\r\n    totalDeposits[tokenAddress] += amount;\r\n\r\n    depositFeeCollected += msg.value;\r\n\r\n    collatDet[msg.sender][deposittoken.tokenAddress].tokenAddress = deposittoken.tokenAddress;\r\n    collatDet[msg.sender][deposittoken.tokenAddress].amount += amount;\r\n    collatDet[msg.sender][deposittoken.tokenAddress].depositTime = block.timestamp;\r\n\r\n    emit NewDeposit(msg.sender, tokenAddress, amount);\r\n}\r\n\r\nfunction depositBNB() public payable {\r\n    require(msg.value > 0 && msg.value <= maxBNBDeposit , \"Invalid amount\");\r\n\r\n    bnbCollat[msg.sender] += msg.value - depositFee;\r\n    depositFeeCollected += depositFee;\r\n    payable(address(this)).transfer(msg.value);\r\n    emit NewDeposit(msg.sender, address(this), msg.value);\r\n}\r\n\r\nreceive() external payable{}\r\n\r\nfunction withdrawToken(address tokenAddress, uint256 amount) public {\r\n    require(amount > 0, \"Amount must be greater than 0\");\r\n    Token storage token = tokens[tokenAddress];\r\n    require(token.tokenAddress != address(0), \"Invalid token address\");\r\n    require(amount <= token.balance, \"Insufficient balance\");\r\n\r\n    PoolInfo storage pool = pools[tokenAddress];\r\n    require(address(pool.lpToken) != address(0), \"Invalid token address\");\r\n\r\n    uint256 fee = (amount * WITHDRAWAL_FEE) / 10000;\r\n\r\n    uint256 dividendAmt = (fee * DIVIDEND_PERCENTAGE).div(100);\r\n\r\n    totalDividend[tokenAddress] += dividendAmt;\r\n\r\n    adminFee[tokenAddress] += fee.sub(dividendAmt);\r\n        \r\n    uint256 netAmount = amount - fee;\r\n\r\n    require(netAmount + fee <= lendDet[msg.sender][tokenAddress].amount, \"Don't have enough tokens\");\r\n\r\n\r\n    token.balance -= amount;\r\n\r\n    lendDet[msg.sender][token.tokenAddress].amount -= amount;\r\n    pool.totalDeposited -= amount;\r\n\r\n    totalDeposits[tokenAddress] -= amount;\r\n\r\n    IERC20(tokenAddress).transfer(msg.sender, netAmount);\r\n\r\n    if(lendDet[msg.sender][token.tokenAddress].amount == 0){\r\n        lenders[msg.sender] = false;\r\n    }\r\n\r\n    emit NewWithdrawal(msg.sender, tokenAddress, netAmount, fee);\r\n}\r\n\r\nfunction withdrawBNBCollat(uint256 amount)public {\r\n    require(amount <=bnbCollat[msg.sender], \"You don't have enough balance.\");\r\n    uint256 repaid = 0;\r\n    uint256 notRepaid = 0;\r\n    uint256 loans = loansByBorrower[msg.sender].length;\r\n    if(loans > 0){\r\n    for (uint256 i= 0; i <loans; i++){\r\n        if(loansByBorrower[msg.sender][i].active == false){\r\n           repaid++;\r\n        }else if(loansByBorrower[msg.sender][i].active == true){\r\n            notRepaid++;\r\n        }\r\n    }\r\n        require(notRepaid == 0, \"You have active loan to repay\");\r\n        bnbCollat[msg.sender] -= amount;\r\n        payable(msg.sender).transfer(amount);\r\n    }else{\r\n        bnbCollat[msg.sender] -= amount;\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n}\r\n\r\n//withdraw token collat\r\nfunction withdrawTokenCollat(address _token, uint256 amount)public {\r\n    require(amount <=collatDet[msg.sender][_token].amount, \"You don't have enough balance.\");\r\n    require(_token == collatDet[msg.sender][_token].tokenAddress, \"No collateral\" );\r\n    require(amount <= IERC20(_token).balanceOf(address(this)), \"Not enough balance.\");\r\n    uint256 repaid = 0;\r\n    uint256 notRepaid = 0;\r\n    uint256 loans = loansByBorrower[msg.sender].length;\r\n    if(loans > 0){\r\n    for (uint256 i= 0; i <loans; i++){\r\n        if(loansByBorrower[msg.sender][i].active == false){\r\n           repaid++;\r\n        }else if(loansByBorrower[msg.sender][i].active == true){\r\n            notRepaid++;\r\n        }\r\n    }\r\n        require(notRepaid == 0, \"You have active loan to repay\");\r\n        collatDet[msg.sender][_token].amount -= amount;\r\n        totalDeposits[_token] -= amount;\r\n        IERC20(_token).transfer(msg.sender, amount);\r\n    }else{\r\n        collatDet[msg.sender][_token].amount -= amount;\r\n        totalDeposits[_token] -= amount;\r\n        IERC20(_token).transfer(msg.sender, amount);\r\n    }\r\n\r\n}\r\n\r\n// admin withdraw\r\nfunction withdraw(address tokenAddress) external onlyOwner{\r\n        require(tokenAddress!= address(0), \"Invalid token address\");\r\n        uint256 amount = adminFee[tokenAddress];\r\n        require(amount > 0, \"No amount\");\r\n        require(amount <= IERC20(tokenAddress).balanceOf(address(this)), \"Not enough balance\");\r\n\r\n        adminFee[tokenAddress] = 0;\r\n\r\n        IERC20(tokenAddress).transfer(owner(), amount);\r\n}\r\n\r\nfunction withdrawBNBFee() external onlyOwner{\r\n    require(depositFeeCollected > 0 , \"No fee to withdraw\");\r\n\r\n    uint256 amount = depositFeeCollected;\r\n\r\n    depositFeeCollected = 0;\r\n\r\n    payable(owner()).transfer(amount);\r\n}\r\n\r\n\r\n//borrow with token\r\nfunction borrowWithToken(address tokenAddress, uint256 amount, address collateralToken) public {\r\n    require(amount > 0, \"Amount must be greater than 0\");\r\n    require(lenders[msg.sender] == false, \"Lenders can't borrow\");\r\n    require(tokens[tokenAddress].tokenAddress != address(0), \"Invalid token address\");\r\n\r\n    PoolInfo storage pool = pools[tokenAddress];\r\n    require(address(pool.lpToken) != address(0) && address(pool.lpToken) == tokenAddress, \"Invalid token address\");\r\n    require(IERC20(pool.lpToken).balanceOf(address(this)) >= amount, \"Not enough token\");\r\n\r\n    uint256 collateralAmount = calculateTokenCollateralValue(collateralToken, tokenAddress, amount, msg.sender);\r\n\r\n    uint256 maxCollateral = ((collatDet[msg.sender][collateralToken].amount) * MAX_LTV) / 100;\r\n    require(collateralAmount > 0 && collateralAmount.add(calculateCollateralAmount(msg.sender, collateralToken)) <= maxCollateral, \"Invalid collateral amount\");\r\n\r\n\r\n    uint256 borrowingInterest = APR;\r\n\r\n    uint256 borrowingFee = (amount * BORROWING_FEE) / 10000;\r\n    // uint256 interest = (amount * borrowingInterest) / 100;\r\n\r\n    uint256 dividendAmt = (borrowingFee * DIVIDEND_PERCENTAGE).div(100);\r\n\r\n    totalDividend[tokenAddress] += dividendAmt;\r\n\r\n    adminFee[tokenAddress] += (borrowingFee).sub(dividendAmt);\r\n\r\n    uint256 remainingAmount = (amount - borrowingFee);\r\n\r\n    tokens[tokenAddress].balance -= amount;\r\n    totalBorrowings += amount;\r\n\r\n    pool.totalBorrowed += amount;\r\n\r\n    Loan memory loan = Loan({\r\n        id: loansByBorrower[msg.sender].length + 1,\r\n        borrower: msg.sender,\r\n        token: tokenAddress,\r\n        collatToken: collateralToken,\r\n        amount: amount,\r\n        bnbCollateral: 0,\r\n        tokenCollateral: collateralAmount,\r\n        apr: borrowingInterest,\r\n        startTimestamp: block.timestamp,\r\n        active: true\r\n    });\r\n\r\n    loansByBorrower[msg.sender].push(loan);\r\n\r\n    // borrowingCollateral[collateralToken] += collateralAmount;\r\n    borrowingDebt[tokenAddress] += amount;\r\n    totalBorrowedAmountByUser[msg.sender][tokenAddress].amount += amount;\r\n    totalBorrowedAmountByUser[msg.sender][tokenAddress].lastCalculatedDividend = totalDividend[tokenAddress];\r\n    if(totalBorrowedAmountByUser[msg.sender][tokenAddress].lastRewardTimeStamp == 0){\r\n        totalBorrowedAmountByUser[msg.sender][tokenAddress].lastRewardTimeStamp = block.timestamp;\r\n    }\r\n\r\n    totalDeposits[tokenAddress] -= amount;\r\n\r\n    IERC20(tokenAddress).transfer(msg.sender, remainingAmount);\r\n\r\n    borrowers[msg.sender] = true;\r\n\r\n    emit NewLoan(msg.sender, amount, collateralAmount);\r\n}\r\n\r\nfunction borrowWithBNB(address tokenAddress, uint256 amount) public {\r\n    require(amount > 0, \"Amount must be greater than 0\");\r\n    require(lenders[msg.sender] == false, \"Lenders can't borrow\");\r\n    Token storage token = tokens[tokenAddress];\r\n    require(token.tokenAddress != address(0), \"Invalid token address\");\r\n\r\n    PoolInfo storage pool = pools[tokenAddress];\r\n    require(address(pool.lpToken) != address(0), \"Invalid token address\");\r\n    require(IERC20(pool.lpToken).balanceOf(address(this)) >= amount, \"Not enough token\");\r\n\r\n    uint256 collateralAmount = calculateBNBCollateralValue(tokenAddress, amount, msg.sender);\r\n\r\n    uint256 maxCollateral = (bnbCollat[msg.sender] * MAX_LTV) / 100;\r\n    require(collateralAmount > 0 && collateralAmount.add(calculateCollateralAmount(msg.sender, address(0))) <= maxCollateral, \"Invalid collateral amount\");\r\n\r\n\r\n    uint256 borrowingInterest = APR;\r\n\r\n    uint256 borrowingFee = (amount * BORROWING_FEE) / 10000;\r\n\r\n    uint256 dividendAmt = (borrowingFee * DIVIDEND_PERCENTAGE).div(100);\r\n\r\n    totalDividend[tokenAddress] += dividendAmt;\r\n\r\n    adminFee[tokenAddress] += (borrowingFee).sub(dividendAmt);\r\n\r\n    uint256 remainingAmount = (amount - borrowingFee);\r\n\r\n    \r\n    token.balance -= amount;\r\n    totalBorrowings += amount;\r\n\r\n    pool.totalBorrowed += amount;\r\n\r\n    Loan memory loan = Loan({\r\n        id: loansByBorrower[msg.sender].length + 1,\r\n        borrower: msg.sender,\r\n        token: tokenAddress,\r\n        collatToken: address(0),\r\n        amount: amount,\r\n        bnbCollateral: collateralAmount,\r\n        tokenCollateral: 0,\r\n        apr: borrowingInterest,\r\n        startTimestamp: block.timestamp,\r\n        active: true\r\n    });\r\n\r\n    loansByBorrower[msg.sender].push(loan);\r\n    borrowingDebt[tokenAddress] += amount;\r\n\r\n    totalBorrowedAmountByUser[msg.sender][tokenAddress].amount += amount;\r\n    totalBorrowedAmountByUser[msg.sender][tokenAddress].lastCalculatedDividend = totalDividend[tokenAddress];\r\n    if(totalBorrowedAmountByUser[msg.sender][tokenAddress].lastRewardTimeStamp == 0){\r\n        totalBorrowedAmountByUser[msg.sender][tokenAddress].lastRewardTimeStamp = block.timestamp;\r\n    }\r\n\r\n    totalDeposits[tokenAddress] -= amount;\r\n\r\n    IERC20(tokenAddress).transfer(msg.sender, remainingAmount);\r\n\r\n    borrowers[msg.sender] = true;\r\n\r\n    emit NewLoan(msg.sender, amount, amount);\r\n}\r\n\r\nfunction lend(address tokenAddress, uint256 _amount) public {\r\n    require(borrowers[msg.sender] == false, \"Borrowers can't be lender\");\r\n    require(_amount > 0 && _amount <= maxLendAmount, \"Invalid amount\");\r\n    require(tokenAddress != address(0), \"Invalid token address\");\r\n    require(tokens[tokenAddress].tokenAddress != address(0), \"Invalid token address\");\r\n    require(address(pools[tokenAddress].lpToken) != address(0), \"Invalid token address\");\r\n\r\n    tokens[tokenAddress].balance += _amount;\r\n    totalDeposits[tokenAddress] += _amount;\r\n\r\n    pools[tokenAddress].totalDeposited += _amount;\r\n\r\n    uint256 intAmount = calculateInterest(tokenAddress);\r\n\r\n    lendDet[msg.sender][tokens[tokenAddress].tokenAddress].tokenAddress = tokens[tokenAddress].tokenAddress;\r\n    lendDet[msg.sender][tokens[tokenAddress].tokenAddress].amount += _amount;\r\n    lendDet[msg.sender][tokens[tokenAddress].tokenAddress].lastDepositTime = block.timestamp;\r\n\r\n    lenders[msg.sender] = true;\r\n    earnedInterest[msg.sender][tokens[tokenAddress].tokenAddress] += intAmount;\r\n\r\n    IERC20(tokenAddress).transferFrom(msg.sender, address(this), _amount);\r\n\r\n    emit NewDeposit(msg.sender, tokenAddress, _amount);\r\n\r\n}\r\n\r\n\r\nfunction repayLoan(uint256 loanId, address _token) public {\r\n    Loan storage loan = loansByBorrower[msg.sender][loanId];\r\n    require(loan.active, \"Loan is not active\");\r\n    require(loan.token == _token, \"Invalid Token\");\r\n\r\n    Token storage token = tokens[_token];\r\n    PoolInfo storage pool = pools[_token];\r\n\r\n    uint256 time = (block.timestamp).sub(loan.startTimestamp);\r\n\r\n    uint256 loanInterest = (((loan.amount).mul(loan.apr)).mul(time)).div(365 days * 100);\r\n\r\n    uint256 cashback = (loanInterest * CASHBACK_PERCENTAGE) / 100;\r\n\r\n    uint256 netInterest = loanInterest.sub(cashback);\r\n\r\n    uint256 netRepayment = ((loan.amount).add(loanInterest));\r\n\r\n    totalBorrowedAmountByUser[msg.sender][token.tokenAddress].amount -= loan.amount;\r\n\r\n    token.balance += netRepayment;\r\n\r\n    pool.totalBorrowed -= loan.amount;\r\n\r\n    pool.totalInterest += netInterest;\r\n\r\n    borrowingDebt[_token] -= loan.amount;\r\n    loan.bnbCollateral = 0;\r\n    loan.tokenCollateral = 0;\r\n\r\n    totalDeposits[_token] += loan.amount;\r\n\r\n    IERC20(token.tokenAddress).transferFrom(msg.sender, address(this), netRepayment);\r\n\r\n    IERC20(token.tokenAddress).transfer(loan.borrower, cashback);\r\n\r\n    loan.active = false;\r\n    \r\n    uint256 repaid = 0;\r\n    uint256 notRepaid = 0;\r\n\r\n    uint256 loans = loansByBorrower[msg.sender].length;\r\n    for (uint256 i= 0; i <loans; i++){\r\n        if(loansByBorrower[msg.sender][i].active == false){\r\n           repaid++;\r\n        }else if(loansByBorrower[msg.sender][i].active == true){\r\n            notRepaid++;\r\n        }\r\n    }\r\n    \r\n    if(notRepaid == 0){\r\n        borrowers[msg.sender] = false;\r\n    }\r\n    emit LoanRepayed(loanId, loan.borrower, loan.amount, loanInterest);\r\n\r\n}\r\n\r\n\r\nfunction loanToInterest(uint256 loanId, address _owner) public view returns(uint256){\r\n    Loan storage loan = loansByBorrower[_owner][loanId];\r\n    require(loan.active, \"Loan is not active\");\r\n    \r\n    uint256 time = ((block.timestamp).sub(loan.startTimestamp)).add(90);\r\n\r\n    uint256 loanInterest = (((loan.amount).mul(loan.apr)).mul(time)).div(365 days * 100);\r\n\r\n    uint256 netRepayment = ((loan.amount).add(loanInterest));\r\n\r\n    return netRepayment;\r\n}\r\n\r\nfunction claimReward(address _token) public {\r\n    require(totalBorrowedAmountByUser[msg.sender][_token].amount > 0, \"Nothing to claim\");\r\n    // require(block.timestamp.sub(totalBorrowedAmountByUser[msg.sender][_token].lastRewardTimeStamp) > 1 days, \"Claim after 1 day\");\r\n\r\n    uint256 lastDivAmt = (totalDividend[_token]).sub(totalBorrowedAmountByUser[msg.sender][_token].lastCalculatedDividend);\r\n\r\n    uint256 rewardPerToken = calculateDividends(_token, lastDivAmt);\r\n\r\n    uint256 rewardAmount = ((totalBorrowedAmountByUser[msg.sender][_token].amount).mul(rewardPerToken)).div(BASE);\r\n    require(rewardAmount > 0, \"No Reward\");\r\n    require(rewardAmount <= IERC20(_token).balanceOf(address(this)), \"Not enough balance\");\r\n    IERC20(_token).transfer(msg.sender, rewardAmount);\r\n    totalBorrowedAmountByUser[msg.sender][_token].lastRewardTimeStamp = block.timestamp;\r\n}\r\n\r\nfunction calculateInterest(address _token) internal view returns(uint256){\r\n    uint256 timeDiff = (block.timestamp).sub(lendDet[msg.sender][_token].lastDepositTime);\r\n\r\n    uint256 interestAmt = (((lendDet[msg.sender][_token].amount).mul(lendingApr)).mul(timeDiff)).div(10000 * 365 days);\r\n\r\n    return interestAmt;\r\n}\r\n\r\nfunction claimInterest(address _token) public {\r\n    require(lendDet[msg.sender][_token].amount > 0, \"Nothing to claim\");\r\n    PoolInfo storage pool = pools[_token];\r\n\r\n    uint256 interestAmt = calculateInterest( _token);\r\n\r\n    require(interestAmt > 0 && interestAmt <= pool.totalInterest, \"No interest\");\r\n\r\n    uint256 totalInterest = earnedInterest[msg.sender][_token] + interestAmt;\r\n    require(totalInterest <= IERC20(_token).balanceOf(address(this)), \"Not enough balance\");\r\n\r\n    earnedInterest[msg.sender][_token] = 0;\r\n\r\n    IERC20(_token).transfer(msg.sender, interestAmt);\r\n\r\n    lendDet[msg.sender][_token].lastDepositTime = block.timestamp;\r\n}\r\n\r\nfunction calculateDividends(address _token, uint256 lastDivAmt) internal view returns(uint256){\r\n\r\n    PoolInfo storage pool = pools[_token];\r\n\r\n    uint256 reward = (lastDivAmt.mul(BASE)).div(pool.totalBorrowed);\r\n\r\n    return reward;\r\n}\r\n\r\n\r\nfunction calculateBNBCollateralValue(address _token, uint256 _amount, address _owner) public view returns (uint256) {\r\n    uint256 bnbBalance = bnbCollat[_owner];\r\n    require(bnbBalance > 0, \"No collateral\");\r\n    uint256 price;\r\n    uint256 decimals;\r\n    (price, decimals) = getPrice(_token);\r\n    return (_amount * price).div(10 ** (decimals));\r\n}\r\n\r\nfunction calculateTokenCollateralValue(address collatToken, address _token, uint256 _amount, address _owner) public view returns (uint256) {\r\n    uint256 tokenCollatBalance = collatDet[_owner][collatToken].amount;\r\n    require(tokenCollatBalance > 0, \"No collateral\");\r\n    uint256 collatprice;\r\n    uint256 collatdecimals;\r\n    (collatprice, collatdecimals) = getPrice(collatToken);\r\n\r\n    uint256 tokenprice;\r\n    uint256 tokendecimals;\r\n    (tokenprice, tokendecimals) = getPrice(_token);\r\n    return (_amount * tokenprice).div(collatprice);\r\n}\r\n\r\nfunction getPrice(address _token) public view returns (uint256, uint256) {\r\n    AggregatorV3Interface priceFeed;\r\n    if(_token == dai){\r\n        priceFeed = AggregatorV3Interface(daiPriceFeed);\r\n    }else if(_token == usdc){\r\n        priceFeed = AggregatorV3Interface(usdcPriceFeed);\r\n    }else if(_token == usdt){\r\n        priceFeed = AggregatorV3Interface(usdtPriceFeed);\r\n    }else if(_token == eth){\r\n        priceFeed = AggregatorV3Interface(ethPriceFeed);\r\n    }else if(_token == ada){\r\n        priceFeed = AggregatorV3Interface(adaPriceFeed);\r\n    }\r\n    (,int256 price,,,) = priceFeed.latestRoundData();\r\n    uint256 decimals = priceFeed.decimals();\r\n    return (uint256(price), uint256(decimals));\r\n}\r\n\r\n\r\n\r\nfunction calculateCollateralAmount(address _owner, address _collatToken) internal view returns(uint256){\r\n    uint256 collatAmount = 0;\r\n    uint256 loans = loansByBorrower[_owner].length;\r\n    if(loans > 0){\r\n    for (uint256 i= 0; i <loans; i++) {\r\n        Loan storage loan = loansByBorrower[msg.sender][i];\r\n\r\n        if(_collatToken == address(0)){\r\n            collatAmount += loan.bnbCollateral;\r\n        }else if(_collatToken == loan.collatToken){\r\n            collatAmount += loan.tokenCollateral;\r\n        }\r\n\r\n        }\r\n    }\r\n\r\n    return collatAmount;\r\n}\r\n\r\nfunction calculateLTVToToken(address _token, address _collatAddr, address _account) public view returns(uint256){\r\n    uint256 maxCollateral;\r\n    uint256 collatAmt = calculateCollateralAmount(msg.sender, _collatAddr);\r\n    if(_collatAddr == address(0)){\r\n        maxCollateral = (bnbCollat[_account] * MAX_LTV) / 100;\r\n    }else{\r\n        maxCollateral = (collatDet[_account][_collatAddr].amount * MAX_LTV) / 100;\r\n    }\r\n    require(maxCollateral > 0 && maxCollateral > collatAmt, \"Invalid Collateral\");\r\n\r\n    uint256 remainCollat = maxCollateral - collatAmt;\r\n\r\n    uint256 collatprice;\r\n    uint256 collatdecimals;\r\n    uint256 tokenprice;\r\n    uint256 tokendecimals;\r\n\r\n    if(_collatAddr == address(0)){\r\n        (tokenprice, tokendecimals) = getPrice(_token);\r\n        return remainCollat.div(tokenprice);\r\n    }else{\r\n        (collatprice, collatdecimals) = getPrice(_collatAddr);\r\n        (tokenprice, tokendecimals) = getPrice(_token);\r\n        return (remainCollat * collatprice).div(tokenprice);\r\n    }\r\n}\r\n\r\n\r\nfunction getBorrowList(address _borrower) public view returns(Loan[] memory) {\r\n    return loansByBorrower[_borrower];\r\n}\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daiPriceFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdcPriceFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtPriceFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ethPriceFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adaPriceFeed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_eth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ada\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CashbackPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DividendPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interest\",\"type\":\"uint256\"}],\"name\":\"LoanRepayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"}],\"name\":\"NewLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"NewWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"APR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BORROWING_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CASHBACK_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DIVIDEND_PERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LTV\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAWAL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ada\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_APY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalBorrowed\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"adminFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bnbCollat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"borrowWithBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateralToken\",\"type\":\"address\"}],\"name\":\"borrowWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowingDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"calculateBNBCollateralValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collatAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"calculateLTVToToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collatToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"calculateTokenCollateralValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collatDet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFeeCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTokenCollat\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deposittokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"earnedInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_borrower\",\"type\":\"address\"}],\"name\":\"getBorrowList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collatToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bnbCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct ParFinance.Loan[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lendDet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDepositTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingApr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lendingTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"loanToInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loansByBorrower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collatToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bnbCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"apr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxADADeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBETHDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBNBDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLendAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"APY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dividendReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCalculatedInterest\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCalculatedBorrow\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"repayLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBorrowedAmountByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCalculatedDividend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTimeStamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBorrowings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBNBCollat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBNBFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenCollat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ParFinance", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008ec213e7191488c7873cec6dac8e97cdbadb7b3500000000000000000000000045f86ca2a8bc9ebd757225b19a1a0d7051be46db000000000000000000000000d5c40f5144848bd4ef08a9605d860e727b99151300000000000000000000000063d407f32aa72e63c7209ce1c2f5da40b3aae7260000000000000000000000002d5fc41d1365ffe13d03d91e82e04ca878d69f4b0000000000000000000000001af3f329e8be154074d8769d1ffa4ee058b1dbc30000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000002170ed0880ac9a755fd29b2688956bd959f933f80000000000000000000000003ee2200efb3400fabb9aacf31297cbdd1d435d47", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://76b67f962d725f51f00c21d612f11682bc5c96d811ea63f53594ed211a0a6c1f"}