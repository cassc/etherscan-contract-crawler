{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract QuickPay {\r\n    address public owner;\r\n    address private guard;\r\n    address public Registrar;\r\n    address public collector;\r\n    uint256 public totalParticipants;\r\n    IBEP20 contractToken;\r\n   // IBEP20 NativeContractToken;\r\n    \r\n\r\n    //uint256[20] public levelPayouts; // Array to store payout percentages for each level\r\n    mapping(address => bytes32) private uniqueIds;\r\n\r\n\r\n    struct Participant {\r\n        address referrer;\r\n        address[] downline;\r\n        uint256 earnings;\r\n        bool exists;\r\n        uint time;\r\n\r\n    }\r\n\r\n    mapping(address => Participant) public participants;\r\n    address[] public registeredParticipants;\r\n\r\n\r\n    constructor(/*uint256[20] memory _payouts,*/address UsdAddress,address _gaurd,address _register, address _collector) {\r\n        owner = msg.sender;\r\n        totalParticipants = 1; // The owner is the first participant\r\n        participants[owner] = Participant(owner, new address[](0), 0,true, block.timestamp);\r\n       // levelPayouts = _payouts; // Initialize the payout percentages\r\n        contractToken = IBEP20(UsdAddress);\r\n       // NativeContractToken = IBEP20(_nativeToken);\r\n       guard = _gaurd;\r\n       Registrar = _register;\r\n       collector = _collector;\r\n       \r\n    }\r\n    function register(address referrer)  public {\r\n        require(msg.sender != referrer && !isRegistered(msg.sender), \"Invalid registration\");\r\n\r\n        participants[msg.sender] = Participant(referrer, new address[](0), 0,true,block.timestamp);\r\n        participants[referrer].downline.push(msg.sender);\r\n        registeredParticipants.push(msg.sender);\r\n        generateUniqueId(referrer,false,block.timestamp);\r\n\r\n        totalParticipants++;\r\n       // contractToken.transferFrom(msg.sender,owner, amount);\r\n        // Pay commissions to upline\r\n        /*address currentParticipant = msg.sender;\r\n        \r\n        for (uint256 level = 1; level <= 20; level++) {\r\n            address upline = participants[currentParticipant].referrer;\r\n            if (upline == address(0) ) {\r\n                break; // Stop when we reach the owner or an unregistered participant\r\n            }\r\n\r\n            uint256 commission = (amount * levelPayouts[level - 1]) / 100; // Calculate commission based on the level's payout percentage\r\n            participants[upline].earnings += commission; // Pay the commission to the upline\r\n\r\n            currentParticipant = upline;\r\n        }*/\r\n    }\r\n    function stake(uint amount) public {\r\n        contractToken.transferFrom(msg.sender,collector, amount);\r\n    }\r\n     function isRegistered(address participant) public view returns (bool) {\r\n        return participants[participant].referrer != address(0);\r\n    }\r\n        function withdraw (uint amount,bytes32 __ ) public{\r\n        require( participants[msg.sender].exists ==true, \"Invalid registration\");\r\n        require (uniqueIds[msg.sender] == __);\r\n        contractToken.transfer(msg.sender, amount);\r\n        address _referrer= participants[msg.sender].referrer;\r\n        bool _exists=participants[msg.sender].exists;\r\n        generateUniqueId(_referrer,_exists,block.timestamp);\r\n\r\n    }\r\n    function generateUniqueId(\r\n        address _referrer,\r\n       // address[] memory _downline,\r\n        //uint256 _earnings,\r\n        bool _exists,\r\n        uint _time\r\n    ) private {\r\n        //require(participants[msg.sender].exists ==false, \"Unique ID already generated for this participant\");\r\n\r\n        bytes32 uniqueId = keccak256(\r\n            abi.encodePacked(\r\n                _referrer,\r\n                //_downline,\r\n               // _earnings,\r\n                _exists,\r\n                _time\r\n            )\r\n        );\r\n\r\n        uniqueIds[msg.sender] = uniqueId;}\r\n\r\n\r\n    function getmyUniqueId(address user) public view returns(bytes32){\r\n        require(msg.sender == guard,\"No not your task\");\r\n        return uniqueIds[user];\r\n    }\r\n    function withdrawOwner(uint amount)public{\r\n        require(msg.sender == collector,\"Not Owner\");\r\n        contractToken.transfer(owner, amount);\r\n    }\r\n    function changeOwner(address _owner) public{\r\n         require(msg.sender == owner,\"Not Owner\");\r\n            owner =_owner;\r\n    }\r\n     function changeGaurd(address _guard) public{\r\n         require(msg.sender == owner,\"Not Owner\");\r\n            guard =_guard;\r\n    }\r\n     function changeRegistrar(address _Registrar) public{\r\n         require(msg.sender == owner,\"Not Owner\");\r\n            Registrar =_Registrar;\r\n    }\r\n    function changecollector(address _collector) public{\r\n         require(msg.sender == owner,\"Not Owner\");\r\n            collector =_collector;\r\n    }\r\n\r\n\r\n    function bulkRegister(address[] calldata addresses, address[] calldata referrers) public {\r\n    require(msg.sender == Registrar, \"Only the guard can perform bulk registration\");\r\n    require(addresses.length == referrers.length, \"Mismatch in the number of addresses and referrers\");\r\n\r\n    for (uint256 i = 0; i < addresses.length; i++) {\r\n        address participant = addresses[i];\r\n        address referrer = referrers[i];\r\n\r\n        // Ensure the participant is not already registered and not equal to the referrer\r\n        require(!isRegistered(participant) , \"Invalid registration\");\r\n\r\n        participants[participant] = Participant(referrer, new address[](0), 0, true, block.timestamp);\r\n        participants[referrer].downline.push(participant);\r\n        registeredParticipants.push(participant);\r\n        generateUniqueId(referrer, false, block.timestamp);\r\n\r\n        totalParticipants++;\r\n    }\r\n}\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"UsdAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gaurd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_register\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collector\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Registrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referrers\",\"type\":\"address[]\"}],\"name\":\"bulkRegister\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guard\",\"type\":\"address\"}],\"name\":\"changeGaurd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Registrar\",\"type\":\"address\"}],\"name\":\"changeRegistrar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_collector\",\"type\":\"address\"}],\"name\":\"changecollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getmyUniqueId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"isRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"participants\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"registeredParticipants\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalParticipants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"__\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "QuickPay", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000906378528960de2c5f8774276b01e60357d01894000000000000000000000000a87e03276c82baa0f92c8d1edba2efc07f35c62b0000000000000000000000004ca28d7bbafa2267151fc277092d4a5d4afc52e1", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://628dcec14370080a690ae0e42fc9df3c7f0a338de2496f4938dae3f2206b9d57"}