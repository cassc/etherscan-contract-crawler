{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface Itoken {\r\n    function balanceOf(address _to) external returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recepiend,\r\n        uint256 _amount\r\n    ) external returns (bool);\r\n\r\n    function burn(uint256 _amount) external returns (bool);\r\n}\r\n\r\ninterface Irouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory);\r\n}\r\n\r\ninterface Ifactory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\ninterface Ipair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112,\r\n            uint112,\r\n            uint32\r\n        );\r\n}\r\n\r\ncontract developers {\r\n    address onwer;\r\n    Itoken token;\r\n\r\n    constructor(address _token, address _onwer) {\r\n        token = Itoken(_token);\r\n        onwer = _onwer;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    modifier checkOnwer() {\r\n        require(onwer == msg.sender, \" no access!\");\r\n        _;\r\n    }\r\n\r\n    function newOnwer(address _newOnwer) public checkOnwer {\r\n        onwer = _newOnwer;\r\n    }\r\n\r\n    function withdrawalBNB(address _to, uint256 _amount) public checkOnwer {\r\n        payable(_to).transfer(_amount);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) public checkOnwer {\r\n        token.approve(_spender, _amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recepiend,\r\n        uint256 _amount\r\n    ) public checkOnwer {\r\n        token.transferFrom(_sender, _recepiend, _amount);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) public checkOnwer {\r\n        token.transfer(_to, _amount);\r\n    }\r\n\r\n    function burn(uint256 _amount) public checkOnwer {\r\n        token.burn(_amount);\r\n    }\r\n}\r\n\r\ncontract burnContract {\r\n    Irouter router;\r\n    Itoken token;\r\n    address pair;\r\n\r\n    uint256 public pendingAmount;\r\n\r\n    address[] path;\r\n\r\n    constructor(address _token, address _pair) {\r\n        router = Irouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        token = Itoken(_token);\r\n        path = [router.WETH(), _token];\r\n        pair = _pair;\r\n    }\r\n\r\n    receive() external payable {\r\n        _tokenBurning(msg.value);\r\n    }\r\n\r\n    fallback() external payable {\r\n        _tokenBurning(msg.value);\r\n    }\r\n\r\n    function _tokenBurning(uint256 _amount) private {\r\n        require(_amount > 0, \"error amount!\");\r\n\r\n        (, , uint256 timeGet) = Ipair(pair).getReserves();\r\n\r\n        if (timeGet == block.timestamp) {\r\n            pendingAmount += _amount;\r\n        } else {\r\n            if (pendingAmount > 0) {\r\n                _amount += pendingAmount;\r\n                pendingAmount = 0;\r\n            }\r\n\r\n            router.swapExactETHForTokens{value: _amount}(\r\n                0,\r\n                path,\r\n                address(this),\r\n                block.timestamp + 3600\r\n            );\r\n\r\n            uint256 amount = token.balanceOf(address(this));\r\n            require(amount > 0, \"zero balance for burn!\");\r\n            require(token.burn(amount), \"failed to burn tokens!\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract fayda {\r\n    string public constant name = \"Fayda\";\r\n    string public constant symbol = \"FAYD\";\r\n    uint256 public constant decimals = 18;\r\n    uint256 public totalSupply;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n    mapping(address => uint256) public lockedAddresses;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    Irouter router;\r\n    address public developer;\r\n    address public burnToken;\r\n    address public pair;\r\n\r\n    // Addresses with blocked marketing tokens\r\n    address[] promoGames = [\r\n        0x397d23D0Af6c83F539263dC202f0Bd6dC2B5ae14, // Game \"Tic Tac Toe\" 03-2024\r\n        0x8e8fC4F00A74C08128136b8E1Ee46f72c3aFb114, // Game \"Predictor\" 06-2024\r\n        0x23e821873CD79294DE34a4A826Aa74C7df3122aC, // Game \"Figures\" 10-2024\r\n        0xdb7f5a93F5692b5fCF8187C3d722ba758157db0F // Game \"FAYDA\" 12-2023\r\n    ];\r\n\r\n    // Token unlock time\r\n    uint256[] timeLock = [1709334000, 1717279200, 1727820000];\r\n\r\n    constructor() {\r\n        router = Irouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n        for (uint256 i = 0; i < 4; i++) {\r\n            mint(promoGames[i], 125e22);\r\n            if (i < 3) lockedAddresses[promoGames[i]] = timeLock[i];\r\n        }\r\n\r\n        pair = Ifactory(router.factory()).createPair(\r\n            router.WETH(),\r\n            address(this)\r\n        );\r\n\r\n        burnToken = address(new burnContract(address(this), pair));\r\n        developer = address(new developers(address(this), msg.sender));\r\n\r\n        mint(developer, 25e23);\r\n        mint(msg.sender, 425e23);\r\n\r\n        lastDay = block.timestamp / STEP;\r\n        emit Uprade_rate(block.timestamp, insuranceRate);\r\n    }\r\n\r\n    receive() external payable {\r\n        _tokenBurning(msg.value);\r\n    }\r\n\r\n    fallback() external payable {\r\n        _tokenBurning(msg.value);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) external returns (bool) {\r\n        _transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount)\r\n        external\r\n        returns (bool)\r\n    {\r\n        require(_amount > 0, \"BEP20: amount cannot be zero!\");\r\n        _approve(msg.sender, _spender, _amount);\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address _sender,\r\n        address _recepiend,\r\n        uint256 _amount\r\n    ) external returns (bool) {\r\n        require(\r\n            _amount <= allowance[_sender][msg.sender],\r\n            \"BEP20: allowance exceeded\"\r\n        );\r\n        _transfer(_sender, _recepiend, _amount);\r\n        _approve(\r\n            _sender,\r\n            msg.sender,\r\n            allowance[_sender][msg.sender] -= _amount\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function mint(address _to, uint256 _amount) private {\r\n        totalSupply += _amount;\r\n        balanceOf[_to] += _amount;\r\n        emit Transfer(address(0), _to, _amount);\r\n    }\r\n\r\n    function burn(uint256 _amount) external returns (bool) {\r\n        _burn(msg.sender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address _spender, uint256 _addedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            _spender,\r\n            allowance[msg.sender][_spender] += _addedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\r\n        external\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            _spender,\r\n            allowance[msg.sender][_spender] -= _subtractedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    modifier argumentChecking(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) {\r\n        require(\r\n            lockedAddresses[_from] < block.timestamp,\r\n            \"BEP20: blocked sender address!\"\r\n        );\r\n        require(_from != address(0), \"BEP20: transfer from the zero address!\");\r\n        require(_to != address(0), \"BEP20: transfer to the zero address!\");\r\n        require(balanceOf[_from] >= _amount, \"BEP20: no enough tokens!\");\r\n        _;\r\n    }\r\n\r\n    function _transfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) private argumentChecking(_from, _to, _amount) {\r\n        require(_amount > 0, \"BEP20: amount cannot be zero!\");\r\n        balanceOf[_from] -= _amount;\r\n        balanceOf[_to] += _amount;\r\n        emit Transfer(_from, _to, _amount);\r\n    }\r\n\r\n    function _approve(\r\n        address _owner,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) private argumentChecking(_owner, _spender, _amount) {\r\n        allowance[_owner][_spender] = _amount;\r\n        emit Approval(_owner, _spender, _amount);\r\n    }\r\n\r\n    function _burn(address _account, uint256 _amount) private {\r\n        balanceOf[_account] -= _amount;\r\n        totalSupply -= _amount;\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n    /*GAME*/\r\n    mapping(uint256 => dataGame) games;\r\n    uint256[] processGames;\r\n    uint256 startProcess;\r\n    uint256 gameCounter = 1;\r\n\r\n    int256 public insuranceRate = 100;\r\n    uint128 public devIncome;\r\n\r\n    uint256 constant STEP = 1 days;\r\n    uint256 lastDay;\r\n    dataLogs logs;\r\n\r\n    struct dataGame {\r\n        uint128 insuredAmount;\r\n        uint128 deposit;\r\n        uint16 players;\r\n        uint16[4] number;\r\n        address[4] users;\r\n        bool[4] useInsurance;\r\n        uint128 burnAmount;\r\n        uint128 createPrice;\r\n        uint128 currentBlock;\r\n    }\r\n\r\n    struct dataLogs {\r\n        int256 lastDayPeriod;\r\n        int256 lastCounterValue;\r\n    }\r\n\r\n    event New_game(\r\n        uint256 id,\r\n        address creator,\r\n        uint256 creatorNum,\r\n        uint256 players,\r\n        uint256 budget,\r\n        uint256 playCost,\r\n        uint256 insuredAmount,\r\n        bool useInsurance,\r\n        uint256 createPrice\r\n    );\r\n    event New_player(\r\n        uint256 id,\r\n        address player,\r\n        uint256 playerNum,\r\n        bool useInsurance\r\n    );\r\n    event Close_game(\r\n        uint256 id,\r\n        uint256 randomNum,\r\n        uint256[4] mintedTokens,\r\n        bool tax,\r\n        uint256 closePrice,\r\n        uint256 reserveToken,\r\n        uint256 reserveWBNB\r\n    );\r\n    event Uprade_rate(uint256 timestamp, int256 insuranceRate);\r\n\r\n    // Modifier to check the correctness of the selected numbers.\r\n    modifier checkNum(address _addr, uint256 _num) {\r\n        require(\r\n            _num > 0 && _num < 101,\r\n            \"Error: the selected number must be between 1 and 100!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Function for creating a game\r\n    function createGame(\r\n        uint128 _deposit,\r\n        uint16 _players,\r\n        uint16 _num,\r\n        bool _insurance\r\n    ) external payable checkNum(msg.sender, _num) {\r\n        require(\r\n            _deposit % 1e12 == 0,\r\n            \"Error: deposit must be divisible by 1e12!\"\r\n        );\r\n        require(\r\n            msg.value == (_deposit * 102) / 100,\r\n            \"Error: incorrect value sent!\"\r\n        );\r\n        require(msg.value >= 0.01 ether, \"Error: minimum value is 0.01 BNB!\");\r\n        require(\r\n            _players > 1 && _players < 5,\r\n            \"Error: must have 2 to 4 players!\"\r\n        );\r\n\r\n        uint128 fee = _deposit / 50;\r\n        uint128 devReward = fee / 20;\r\n\r\n        (uint256 price, , ) = _poolData();\r\n        uint256 insuredAmount = (price > 0)\r\n            ? (_deposit * 10**18 * uint256(insuranceRate)) / price / 100\r\n            : 0;\r\n\r\n        dataGame storage game = games[gameCounter];\r\n\r\n        game.insuredAmount = uint128(insuredAmount);\r\n        game.deposit = _deposit;\r\n        game.players = _players;\r\n        game.number[0] = _num;\r\n        game.users[0] = msg.sender;\r\n        game.burnAmount += fee - devReward;\r\n        game.createPrice = uint128(price);\r\n        game.currentBlock = uint128(block.number);\r\n\r\n        devIncome += devReward;\r\n\r\n        if (_insurance) {\r\n            require(\r\n                balanceOf[msg.sender] >= insuredAmount,\r\n                \"Error: not enough tokens for insurance!\"\r\n            );\r\n            game.useInsurance[0] = true;\r\n            _transfer(msg.sender, address(this), insuredAmount);\r\n        }\r\n\r\n        emit New_game(\r\n            gameCounter,\r\n            msg.sender,\r\n            _num,\r\n            _players,\r\n            game.deposit * _players,\r\n            msg.value,\r\n            insuredAmount,\r\n            _insurance,\r\n            price\r\n        );\r\n\r\n        gameCounter++;\r\n        _updateRate();\r\n    }\r\n\r\n    // Function to participate in the game\r\n    function playGame(\r\n        uint256 _id,\r\n        uint16 _num,\r\n        bool _insurance\r\n    ) public payable checkNum(msg.sender, _num) {\r\n        (\r\n            bool reParticipation,\r\n            uint256 activePlayers,\r\n            bool wrongNum\r\n        ) = _checkPlayer(_id, int16(_num));\r\n\r\n        dataGame storage game = games[_id];\r\n\r\n        uint128 fee = game.deposit / 50;\r\n        uint128 devReward = fee / 20;\r\n\r\n        require(game.currentBlock != block.number, \"Error: blocking!\");\r\n        require(!reParticipation, \"Error: you are already in this game!\");\r\n        require(activePlayers < game.players, \"Error: error in game ID!\");\r\n        require(!wrongNum, \"Error: wrong number selected!\");\r\n        require(msg.value == game.deposit + fee, \"Error: error in value!\");\r\n\r\n        game.number[activePlayers] = _num;\r\n        game.users[activePlayers] = msg.sender;\r\n        game.burnAmount += fee - devReward;\r\n\r\n        devIncome += devReward;\r\n\r\n        if (_insurance) {\r\n            require(\r\n                balanceOf[msg.sender] >= game.insuredAmount,\r\n                \"Error: not enough tokens for insurance!\"\r\n            );\r\n            game.useInsurance[activePlayers] = true;\r\n            _transfer(msg.sender, address(this), game.insuredAmount);\r\n        }\r\n\r\n        if (game.players == activePlayers + 1) {\r\n            game.currentBlock = uint128(block.number);\r\n            processGames.push(_id);\r\n        }\r\n\r\n        emit New_player(_id, msg.sender, _num, _insurance);\r\n\r\n        _closingGames();\r\n    }\r\n\r\n    // Function for checking a new player\r\n    function _checkPlayer(uint256 _id, int256 _num)\r\n        private\r\n        view\r\n        returns (\r\n            bool reParticipation,\r\n            uint256 activePlayers,\r\n            bool wrongNum\r\n        )\r\n    {\r\n        dataGame memory game = games[_id];\r\n        for (uint256 i = 0; i < game.players; i++) {\r\n            int256 gameNum = int16(game.number[i]);\r\n            if (gameNum > 0)\r\n                wrongNum =\r\n                    (gameNum >= _num ? gameNum - _num : _num - gameNum) < 10;\r\n            if (game.users[i] == msg.sender) reParticipation = true;\r\n            if (game.users[i] != address(0)) activePlayers++;\r\n        }\r\n    }\r\n\r\n    // Function for closing games in processing\r\n    function _closingGames() private {\r\n        for (uint256 i = startProcess; i < processGames.length; i++) {\r\n            dataGame memory game = games[processGames[i]];\r\n            if (game.currentBlock < block.number - 1) {\r\n                (uint256[4] memory shares, uint256 random) = _summarizing(\r\n                    processGames[i]\r\n                );\r\n                (uint256 closePrice, , ) = _poolData();\r\n                bool tax = closePrice < game.createPrice;\r\n                uint256 burnAmount = game.burnAmount;\r\n                uint256[4] memory mintAmount;\r\n                for (uint256 y = 0; y < game.players; y++) {\r\n                    uint256 share = shares[y];\r\n                    uint256 deposit = game.deposit;\r\n                    if (share <= deposit) {\r\n                        if (share > 0) payable(game.users[y]).transfer(share);\r\n                        if (game.useInsurance[y] && share < deposit)\r\n                            mintAmount[y] = deposit - share;\r\n                    } else {\r\n                        uint256 fee = tax\r\n                            ? ((share - deposit) / 100) * 85\r\n                            : (share - deposit) / 2;\r\n                        burnAmount += fee;\r\n                        payable(game.users[y]).transfer(share - fee);\r\n                    }\r\n                }\r\n                _tokenBurning(burnAmount);\r\n\r\n                (\r\n                    uint256[4] memory mintedTokens,\r\n                    uint256 reserve0,\r\n                    uint256 reserve1\r\n                ) = _compensation(game.players, game.users, mintAmount);\r\n                _returnInsurance(\r\n                    game.players,\r\n                    game.insuredAmount,\r\n                    game.useInsurance,\r\n                    game.users\r\n                );\r\n\r\n                emit Close_game(\r\n                    processGames[i],\r\n                    random,\r\n                    mintedTokens,\r\n                    tax,\r\n                    closePrice,\r\n                    reserve0,\r\n                    reserve1\r\n                );\r\n\r\n                startProcess++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function to compensate for losses\r\n    function _compensation(\r\n        uint16 _players,\r\n        address[4] memory _user,\r\n        uint256[4] memory _mintAmount\r\n    )\r\n        private\r\n        returns (\r\n            uint256[4] memory mintedTokens,\r\n            uint256 reserve0,\r\n            uint256 reserve1\r\n        )\r\n    {\r\n        (\r\n            uint256 _mintPrice,\r\n            uint256 _tokenReserve,\r\n            uint256 _wbnbReserve\r\n        ) = _poolData();\r\n        for (uint256 y = 0; y < _players; y++) {\r\n            if (_mintAmount[y] > 0 && _mintPrice > 0) {\r\n                mintedTokens[y] =\r\n                    (_mintAmount[y] * _tokenReserve) /\r\n                    (_wbnbReserve + _mintAmount[y]);\r\n                mint(_user[y], mintedTokens[y]);\r\n            }\r\n        }\r\n        return (mintedTokens, _tokenReserve, _wbnbReserve);\r\n    }\r\n\r\n    // Function of returning the insurance to players\r\n    function _returnInsurance(\r\n        uint16 _players,\r\n        uint256 _insuredAmount,\r\n        bool[4] memory _useInsurance,\r\n        address[4] memory _user\r\n    ) private {\r\n        for (uint256 y = 0; y < _players; y++) {\r\n            if (_useInsurance[y]) {\r\n                _transfer(address(this), _user[y], _insuredAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function for updating the insurance rate and sending rewards to the developer\r\n    function _updateRate() private {\r\n        uint256 currentDay = block.timestamp / STEP;\r\n        if (currentDay > lastDay) {\r\n            int256 newDayPeriod = int256(gameCounter) - logs.lastCounterValue;\r\n            if (newDayPeriod > 0) {\r\n                int256 lastPeriod = logs.lastDayPeriod;\r\n                int256 distinction = newDayPeriod - lastPeriod;\r\n                if (distinction != 0) {\r\n                    int256 percent = (lastPeriod == 0)\r\n                        ? (distinction * 100)\r\n                        : ((distinction * 100) / lastPeriod);\r\n                    int256 rate = (insuranceRate * (100 + percent)) / 100;\r\n                    insuranceRate = (rate > insuranceRate * 2)\r\n                        ? insuranceRate * 2\r\n                        : rate;\r\n                    if (insuranceRate < 100) {\r\n                        insuranceRate = 100;\r\n                    }\r\n                }\r\n                emit Uprade_rate(block.timestamp, insuranceRate);\r\n            }\r\n            logs = dataLogs(newDayPeriod, int256(gameCounter));\r\n            lastDay = currentDay;\r\n\r\n            if (devIncome > 0) {\r\n                (bool success, ) = developer.call{value: devIncome}(\"\");\r\n                require(success, \"reward error!\");\r\n                devIncome = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Function of sending fee and taxes for the purchase and burning of tokens\r\n    function _tokenBurning(uint256 _amount) private {\r\n        (bool success, ) = burnToken.call{value: _amount}(\"\");\r\n        require(success, \"burn error!\");\r\n    }\r\n\r\n    // Function to get the current token price and pool reserves\r\n    function _poolData()\r\n        private\r\n        view\r\n        returns (\r\n            uint256 price,\r\n            uint256 reserveToken,\r\n            uint256 reserveBNB\r\n        )\r\n    {\r\n        (uint256 reserveA, uint256 reserveB, ) = Ipair(pair).getReserves();\r\n        if (reserveA != 0 && reserveB != 0)\r\n            return ((reserveB * 10**18) / reserveA, reserveA, reserveB);\r\n    }\r\n\r\n    // Function to get player shares and generate a random number.\r\n    function _summarizing(uint256 _id)\r\n        private\r\n        view\r\n        returns (uint256[4] memory shares, uint256 random)\r\n    {\r\n        random =\r\n            (uint256(keccak256(abi.encodePacked(blockhash(block.number - 1)))) %\r\n                100) +\r\n            1;\r\n        dataGame memory game = games[_id];\r\n        uint256 budget = game.deposit * game.players;\r\n        uint256 allWeight;\r\n        for (uint256 i = 0; i < game.players; i++) {\r\n            uint256 diff = random > game.number[i]\r\n                ? random - game.number[i]\r\n                : game.number[i] - random;\r\n            if (diff > 0) {\r\n                shares[i] = diff * budget;\r\n                allWeight += diff;\r\n            }\r\n        }\r\n        for (uint256 i = 0; i < game.players; i++) shares[i] /= allWeight;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"randomNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[4]\",\"name\":\"mintedTokens\",\"type\":\"uint256[4]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"tax\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserveWBNB\",\"type\":\"uint256\"}],\"name\":\"Close_game\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"players\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"budget\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"insuredAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useInsurance\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createPrice\",\"type\":\"uint256\"}],\"name\":\"New_game\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"useInsurance\",\"type\":\"bool\"}],\"name\":\"New_player\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"insuranceRate\",\"type\":\"int256\"}],\"name\":\"Uprade_rate\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_deposit\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"_players\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_num\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_insurance\",\"type\":\"bool\"}],\"name\":\"createGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devIncome\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insuranceRate\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedAddresses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_num\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_insurance\",\"type\":\"bool\"}],\"name\":\"playGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recepiend\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "fayda", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f452ca3f080dc067a2698ec736e27368e214880ac89e69e252349ad9a8c4dbc8"}