{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >0.8.10;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount ) external returns (bool);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) { return msg.sender; }\r\n    function _msgData() internal view virtual returns (bytes calldata) { return msg.data; }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() { _transferOwnership(_msgSender()); }\r\n    function owner() public view virtual returns (address) { return _owner; }\r\n    modifier onlyOwner() { require(owner() == _msgSender(), \"Ownable: caller is not the owner\");  _; }\r\n    function renounceOwnership() public virtual onlyOwner { _transferOwnership(address(0)); }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); _transferOwnership(newOwner); }\r\n    function _transferOwnership(address newOwner) internal virtual { address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner); }\r\n}\r\n\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping (address => bool) internal authorizations;\r\n    constructor(address _owner) { owner = _owner; authorizations[_owner] = true; }\r\n    modifier onlyOwner() { require(isOwner(msg.sender), \"!OWNER\"); _; }\r\n    modifier authorized() { require(isAuthorized(msg.sender), \"!AUTHORIZED\"); _; }\r\n    function authorize(address adr) public onlyOwner { authorizations[adr] = true; }\r\n    function unauthorize(address adr) public onlyOwner { authorizations[adr] = false; }\r\n    function isOwner(address account) public view returns (bool) { return account == owner; }\r\n    function isAuthorized(address adr) public view returns (bool) { return authorizations[adr]; }\r\n    function transferOwnership(address payable adr) public onlyOwner { owner = adr; authorizations[adr] = true; emit OwnershipTransferred(adr); }\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ncontract A_SensiLockingV2 is Auth {\r\n    \r\n    struct LockStatus {\r\n        uint256 lockNumber;\r\n        address owner;\r\n        uint256 lockCreatedTimestamp;\r\n        uint256 lockEndedTimestamp;\r\n        uint256 amountLocked;\r\n        uint256 amountRewarded;\r\n        uint256 amountRelocked;\r\n        uint256 amountRedeemed;\r\n        uint256 timesRelocked;\r\n    }\r\n\r\n    //main contract properties\r\n    address public _lockTokenContractAddress;\r\n    uint public _lockTokenContractDecimals;\r\n    \r\n    //locking properties\r\n    bool public lockingEnabled;\r\n    uint256 public lockDurationSeconds;\r\n    uint256 public lockMinimumAmount;\r\n    uint256 public dailyRewardRate;\r\n    uint256 public dailyRewardRateFactor;\r\n    uint256 public dailyRewardLastCalculatedTimestamp;\r\n    uint256 public dailyRewardCooldownSeconds;\r\n\r\n    //accounting properties\r\n    LockStatus[] allLocks;\r\n    uint256 public totalLockedTokens;\r\n    uint256 public totalRewardPoolTokens;\r\n    uint256 totalRewardTokens;\r\n    \r\n    mapping (address => uint256) public userTotalLocked;\r\n    \r\n    event LockCreated(uint256 lockNumber, address inverstor, uint256 amount, uint256 createAt);\r\n    event LockRedeemed(uint256 amount, address wallet);\r\n    event LockExtended(uint256 lockNumber, address inverstor);\r\n    event DailyRewardCalculated(uint256 locksRewarded, uint256 estimatedReward, uint256 actualReward);\r\n\r\n    constructor() Auth(msg.sender) {\r\n        _lockTokenContractAddress = 0x63e77cF206801782239D4F126cfa22b517FB4eDb;\r\n        _lockTokenContractDecimals = 9;\r\n\r\n        lockDurationSeconds = 28 minutes;\r\n        dailyRewardRate = 10;\r\n        dailyRewardRateFactor = 1000;\r\n        lockMinimumAmount = 1000000000;\r\n        lockingEnabled = true;\r\n        dailyRewardLastCalculatedTimestamp = 0;\r\n        dailyRewardCooldownSeconds = 1 minutes;\r\n\r\n        totalRewardPoolTokens = 0;\r\n        totalLockedTokens = 0;\r\n        totalRewardTokens = 0;\r\n    }\r\n\r\n\r\n    /** \r\n     * #####################################\r\n     *  Reward calculation functions\r\n     * #######################################\r\n     * */\r\n    \r\n    /**\r\n     * @dev Returns the pool size, locked token amount, total interest\r\n     */\r\n    function getLockingStatistics() external view authorized returns(uint256, uint256, uint256, uint256) {\r\n        return (totalRewardPoolTokens, totalLockedTokens, totalRewardTokens, allLocks.length);\r\n    }\r\n\r\n    /**\r\n     *  @dev calculates the daily distribution for all wallets\r\n     * */\r\n    function calculateDailyReward() public authorized  {\r\n        //don't allow this to run if we are still within the cooldown period\r\n        require(block.timestamp > (dailyRewardLastCalculatedTimestamp + dailyRewardCooldownSeconds), \"Too early to distribute rewards again. Try again later.\");\r\n\r\n        uint locksRewarded = 0;\r\n        uint256 estimatedTodayReward = (totalRewardPoolTokens * dailyRewardRate / dailyRewardRateFactor);\r\n        uint256 actualTodayReward = 0;\r\n        for (uint i = 0; i < allLocks.length; i ++) {\r\n            if (block.timestamp > allLocks[i].lockCreatedTimestamp && block.timestamp < allLocks[i].lockEndedTimestamp) {\r\n                //reward = ((locked+relocked)/totalLocked)*(estimatedTodayReward)\r\n                uint256 rewardAmount = (allLocks[i].amountLocked + allLocks[i].amountRelocked) * estimatedTodayReward / totalLockedTokens;\r\n                \r\n                allLocks[i].amountRewarded += rewardAmount;\r\n                actualTodayReward += rewardAmount;\r\n                locksRewarded++;\r\n            }\r\n        }\r\n\r\n        //adjust totals\r\n        totalRewardTokens += actualTodayReward;\r\n        totalRewardPoolTokens -= actualTodayReward;\r\n        dailyRewardLastCalculatedTimestamp = block.timestamp;\r\n        emit DailyRewardCalculated(locksRewarded, estimatedTodayReward, actualTodayReward);\r\n    }\r\n\r\n    /** \r\n     * #####################################\r\n     *  Core locking functions\r\n     * #######################################\r\n     * */\r\n     \r\n    /**\r\n    * @dev Lock tokens into the contract\r\n    * @param _amount amount to lock\r\n    */\r\n    function _createLock(address _to, uint256 _amount) private {\r\n        require(lockingEnabled, \"Locking is not currently enabled.\");\r\n        require(_amount > lockMinimumAmount, \"Deposit is below minimum level.\");\r\n        require(IERC20(_lockTokenContractAddress).allowance(msg.sender, address(this)) >= _amount, \"Deposit is greater than approved contract allowance.\");\r\n        require(IERC20(_lockTokenContractAddress).transferFrom(msg.sender, address(this), _amount));\r\n        \r\n        //build new lock\r\n        LockStatus memory newLock;\r\n        newLock.lockNumber = allLocks.length;\r\n        newLock.owner = _to;\r\n        newLock.lockCreatedTimestamp = block.timestamp;\r\n        newLock.lockEndedTimestamp = block.timestamp + lockDurationSeconds;\r\n        newLock.amountLocked = _amount;\r\n        newLock.amountRelocked = 0;\r\n        newLock.amountRewarded = 0;\r\n        newLock.amountRedeemed = 0;\r\n        newLock.timesRelocked = 0;\r\n        allLocks.push(newLock);\r\n\r\n        //update internal counters\r\n        userTotalLocked[_to]++;\r\n        totalLockedTokens += _amount;\r\n\r\n        emit LockCreated(allLocks.length, _to, _amount, block.timestamp);\r\n    }\r\n\r\n    function createLock(uint256 _amount) public {\r\n        _createLock(msg.sender, _amount);\r\n    }\r\n\r\n    function giftLock(address _to, uint256 _amount) public {\r\n        _createLock(_to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev extendLock - allows people with active locks to reinvest their tokens\r\n    * @param _lockNumber amount to stake\r\n    */\r\n    function extendLock(uint256 _lockNumber) public {\r\n        require(lockingEnabled, \"Locking is not currently enabled.\");\r\n\r\n        //lock number can't be negative or greater than allLocks.length\r\n        require(_lockNumber >= 0 && _lockNumber <= allLocks.length, \"Invalid lock number.\");\r\n\r\n        bool lockFound = false;\r\n        if (allLocks[_lockNumber].owner == msg.sender && allLocks[_lockNumber].lockNumber == _lockNumber) {\r\n            lockFound = true;\r\n\r\n            //only locks that are still active can extend\r\n            require(block.timestamp > allLocks[_lockNumber].lockCreatedTimestamp && block.timestamp < allLocks[_lockNumber].lockEndedTimestamp, \"This lock is not currently active.\");\r\n\r\n            //only locks that have reward tokens can extend\r\n            require(allLocks[_lockNumber].amountRewarded > 0, \"This lock does not have rewards to extend with\");\r\n\r\n            //adjust totals\r\n            totalLockedTokens += allLocks[_lockNumber].amountRewarded;\r\n            totalRewardTokens -= allLocks[_lockNumber].amountRewarded;\r\n\r\n            //move reward tokens to relocked balance, zero out reward tokens, extend lock duration\r\n            allLocks[_lockNumber].amountRelocked += allLocks[_lockNumber].amountRewarded;\r\n            allLocks[_lockNumber].amountRewarded = 0;\r\n            allLocks[_lockNumber].lockEndedTimestamp = block.timestamp + lockDurationSeconds;\r\n            allLocks[_lockNumber].timesRelocked++;\r\n        }\r\n        \r\n        require(lockFound, \"Lock not owned by this address.\");\r\n        emit LockExtended(_lockNumber, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw tokens from lock\r\n    * @param _lockNumber amount to withdraw\r\n    */\r\n    function withdrawLock(uint256 _lockNumber) public  {\r\n        //lock number can't be negative or greater than allLocks.length\r\n        require(_lockNumber >= 0 && _lockNumber <= allLocks.length, \"Invalid lock number.\");\r\n\r\n        bool lockFound = false;\r\n        if (allLocks[_lockNumber].owner == msg.sender && allLocks[_lockNumber].lockNumber == _lockNumber) {\r\n            lockFound = true;\r\n            \r\n            //only allow withdrawls after withdrawl date\r\n            require(block.timestamp > allLocks[_lockNumber].lockCreatedTimestamp && block.timestamp > allLocks[_lockNumber].lockEndedTimestamp, \"This lock is not ready to be withdrawn.\");\r\n\r\n            //only allow withdrawls with more than 0 tokens available for withdrawl\r\n            //available reward = original lock + relocked + reward - any amount already redeemed\r\n            uint256 availableToWithdraw = (allLocks[_lockNumber].amountLocked + allLocks[_lockNumber].amountRelocked + allLocks[_lockNumber].amountRewarded - allLocks[_lockNumber].amountRedeemed);\r\n            require(availableToWithdraw > 0, \"There are no tokens to withdraw on this lock.\");\r\n\r\n            //only allow withdrawls that meet the contract token allowance\r\n            uint256 allowance = IERC20(_lockTokenContractAddress).allowance(msg.sender, address(this));\r\n            require(allowance >= availableToWithdraw, \"Check the token allowance\");\r\n\r\n            //perform withdrawl and update accounting values\r\n            require(IERC20(_lockTokenContractAddress).transfer(msg.sender, availableToWithdraw));\r\n            allLocks[_lockNumber].amountRedeemed = availableToWithdraw;\r\n\r\n            //update totals\r\n            totalLockedTokens -= (allLocks[_lockNumber].amountLocked + allLocks[_lockNumber].amountRelocked);\r\n            totalRewardTokens -= allLocks[_lockNumber].amountRewarded;\r\n            \r\n            emit LockRedeemed(availableToWithdraw, msg.sender);\r\n        }\r\n        \r\n        require(lockFound, \"Lock not owned by this address.\");\r\n    }\r\n\r\n\r\n    /** \r\n     * #####################################\r\n     *  Anonymous functions\r\n     * #######################################\r\n     * */\r\n\r\n    /**\r\n     * Get all locks for a given address\r\n     * @param _address user address\r\n     *\r\n     * */\r\n    function getLocksForAddress(address _address) external view returns( LockStatus[] memory ) {\r\n        LockStatus[] memory history = new LockStatus[](userTotalLocked[_address]);\r\n        uint count = 0;\r\n        for (uint i = 0; i < allLocks.length; i ++) {\r\n            if (allLocks[i].owner == _address) {\r\n                history[count] = allLocks[i];\r\n                count++;\r\n            }\r\n        }\r\n        return history;\r\n    }\r\n\r\n    /**\r\n     * Returns all the lock numbers for a given address\r\n     *\r\n     * */\r\n    function getLockNumbersForAddress(address _address) external view returns( uint256[] memory ) {\r\n        uint256[] memory history = new uint256[](userTotalLocked[_address]);\r\n        uint count = 0;\r\n        for (uint i = 0; i < allLocks.length; i ++) {\r\n            if (allLocks[i].owner == _address) {\r\n                history[count] = allLocks[i].lockNumber;\r\n                count++;\r\n            }\r\n        }\r\n        return history;\r\n    }\r\n\r\n    /**\r\n     * Returns a lock for a given lockNumber\r\n     *\r\n     * */\r\n    function getLockByLockNumber(uint256 _lockNumber) external view returns( LockStatus memory ) {\r\n        //lock number can't be negative or greater than allLocks.length\r\n        require(_lockNumber >= 0 && _lockNumber <= allLocks.length, \"Invalid lock number.\");\r\n        \r\n        return allLocks[_lockNumber];\r\n    }\r\n\r\n\r\n    /**\r\n     * ####################################\r\n     * ADMIN FUNCTIONS ONLY BY OWNER \r\n     * ####################################\r\n     *\r\n     * */\r\n\r\n    /**\r\n     * @dev Updates the daily reward rate\r\n     */\r\n    function setDailyRewardRate(uint256 _newDailyRewardRate) public onlyOwner {\r\n        dailyRewardRate = _newDailyRewardRate;\r\n    } \r\n    \r\n    /**\r\n     * @dev Updates the daily reward rate\r\n     */\r\n    function setDailyRewardRateFactor(uint256 _factor) public onlyOwner {\r\n        dailyRewardRateFactor = _factor;\r\n    } \r\n\r\n    /**\r\n     * @dev Updates the daily reward rate\r\n     */\r\n    function setDailyRewardCooldownSeconds(uint256 _cooldownSeconds) public onlyOwner {\r\n        dailyRewardCooldownSeconds = _cooldownSeconds;\r\n    } \r\n    \r\n    /**\r\n     * @dev Updates the token used by locking contract\r\n     */\r\n    function setPaymentToken(address _newContractAddress, uint _decimals) public onlyOwner {\r\n        _lockTokenContractAddress = _newContractAddress;\r\n        _lockTokenContractDecimals = _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows admin to enable/disable locking/relocking\r\n     */\r\n    function setLockingEnabled(bool _isEnabled) public onlyOwner {\r\n        lockingEnabled = _isEnabled;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows admin to enable/disable locking/relocking\r\n     */\r\n    function setLockDuration(uint256 _durationSeconds) public onlyOwner {\r\n        lockDurationSeconds = _durationSeconds;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows to change the minimum lock amount\r\n     */\r\n    function setLockMinimumAmount(uint256 _amount) public onlyOwner {\r\n        lockMinimumAmount = _amount;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw tokens from lock\r\n    */\r\n    function forceWithdrawLock(uint256 _lockNumber, bool _includeReward) public onlyOwner  {\r\n        //lock number can't be negative or greater than allLocks.length\r\n        require(_lockNumber >= 0 && _lockNumber <= allLocks.length, \"Invalid lock number.\");\r\n        \r\n        //only allow withdrawls with more than 0 tokens available for withdrawl\r\n        //available reward = original lock + relocked + reward - any amount already redeemed\r\n        uint256 availableToWithdraw = (allLocks[_lockNumber].amountLocked + allLocks[_lockNumber].amountRelocked);\r\n        if (_includeReward) { availableToWithdraw = (availableToWithdraw + allLocks[_lockNumber].amountRewarded); }\r\n        availableToWithdraw = (availableToWithdraw - allLocks[_lockNumber].amountRedeemed);\r\n\r\n        require(availableToWithdraw > 0, \"There are no tokens to withdraw on this lock.\");\r\n\r\n        //only allow withdrawls that meet the contract token allowance\r\n        uint256 allowance = IERC20(_lockTokenContractAddress).allowance(allLocks[_lockNumber].owner, address(this));\r\n        require(allowance >= availableToWithdraw, \"Check the token allowance.\");\r\n\r\n        //perform withdrawl and update accounting values\r\n        require(IERC20(_lockTokenContractAddress).transfer(allLocks[_lockNumber].owner, availableToWithdraw));\r\n        allLocks[_lockNumber].amountRedeemed = availableToWithdraw;\r\n\r\n        //update totals\r\n        totalLockedTokens -= (allLocks[_lockNumber].amountLocked + allLocks[_lockNumber].amountRelocked);\r\n        totalRewardTokens -= allLocks[_lockNumber].amountRewarded;\r\n\r\n        //if the lock has had its tokens forfeited, the reward tokens are returned back to the reward pool\r\n        if (!_includeReward) {\r\n            totalRewardPoolTokens += allLocks[_lockNumber].amountRewarded;\r\n            allLocks[_lockNumber].amountRewarded = 0;\r\n        }\r\n\r\n        emit LockRedeemed(availableToWithdraw, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Force withdrawl of all locks back to original wallets\r\n    */\r\n    function forceWithdrawAllLocks(bool _includeReward) public onlyOwner {\r\n        uint forcedWithdrawls = 0;\r\n        for (uint i = 0; i < allLocks.length; i ++) {\r\n            if ((allLocks[i].amountLocked + allLocks[i].amountRelocked + allLocks[i].amountRewarded - allLocks[i].amountRedeemed) > 0) {\r\n                forceWithdrawLock(i, _includeReward);\r\n                forcedWithdrawls++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add tokens to reward pool\r\n     * @param _amount token balance to add in reward pool\r\n     * */\r\n    function depositRewardPoolTokens(uint256 _amount) public payable onlyOwner {\r\n        require(_amount > 0, \"You need to deposit at least 1 token.\");\r\n        uint256 allowance = IERC20(_lockTokenContractAddress).allowance(msg.sender, address(this));\r\n        require(allowance >= _amount, \"Check the token allowance.\");\r\n        require(IERC20(_lockTokenContractAddress).transferFrom(msg.sender, address(this), _amount));\r\n        totalRewardPoolTokens += _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Add tokens to reward pool\r\n     * @param _wallet, target address to withdraw token\r\n     * @param _amount token amount to withdraw\r\n     * */\r\n    function withdrawRewardPoolTokens(address _wallet, uint256 _amount) public onlyOwner {\r\n        require(_amount > 0, \"You need to withdraw at least 0 tokens.\");\r\n\r\n        //only allow this function to withdraw tokens in the reward pool\r\n        require(totalRewardPoolTokens >= _amount, \"You cannot withdraw more tokens than the current reward pool balance.\");\r\n\r\n        //only allow this function to withdraw tokens that are actually assigned to this contract\r\n        require(IERC20(_lockTokenContractAddress).balanceOf(address(this)) > _amount, \"Total contract balance is less than requested token amount.\");\r\n    \r\n        //transfer tokens and remove amount from totalRewardPoolTokens balance\r\n        try IERC20(_lockTokenContractAddress).transfer(_wallet, _amount) {\r\n            totalRewardPoolTokens -= _amount;\r\n        }\r\n        //ensure we revert in case of failure \r\n        catch {\r\n            require(false, \"Failed to transfer tokens.\");\r\n        }\r\n    }\r\n\r\n    function withdrawToken(address destinationAddress, IERC20 token, uint256 amount) external onlyOwner {\r\n        if (address(token) == address(0)) {\r\n            (bool success, ) = destinationAddress.call{value: (amount == 0 ? address(this).balance : amount)}(new bytes(0)); \r\n            require(success, 'STE');\r\n        } else {\r\n            (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transfer.selector, destinationAddress, (amount == 0 ? token.balanceOf(address(this)) : amount))); \r\n            require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"locksRewarded\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"estimatedReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actualReward\",\"type\":\"uint256\"}],\"name\":\"DailyRewardCalculated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inverstor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"createAt\",\"type\":\"uint256\"}],\"name\":\"LockCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inverstor\",\"type\":\"address\"}],\"name\":\"LockExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"LockRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_lockTokenContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lockTokenContractDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateDailyReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"createLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyRewardCooldownSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyRewardLastCalculatedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyRewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dailyRewardRateFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositRewardPoolTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockNumber\",\"type\":\"uint256\"}],\"name\":\"extendLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_includeReward\",\"type\":\"bool\"}],\"name\":\"forceWithdrawAllLocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_includeReward\",\"type\":\"bool\"}],\"name\":\"forceWithdrawLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockNumber\",\"type\":\"uint256\"}],\"name\":\"getLockByLockNumber\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockCreatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockEndedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRewarded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRelocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRedeemed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timesRelocked\",\"type\":\"uint256\"}],\"internalType\":\"struct A_SensiLockingV2.LockStatus\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLockNumbersForAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockingStatistics\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getLocksForAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lockNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockCreatedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockEndedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRewarded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRelocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRedeemed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timesRelocked\",\"type\":\"uint256\"}],\"internalType\":\"struct A_SensiLockingV2.LockStatus[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"giftLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDurationSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockMinimumAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cooldownSeconds\",\"type\":\"uint256\"}],\"name\":\"setDailyRewardCooldownSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDailyRewardRate\",\"type\":\"uint256\"}],\"name\":\"setDailyRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_factor\",\"type\":\"uint256\"}],\"name\":\"setDailyRewardRateFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_durationSeconds\",\"type\":\"uint256\"}],\"name\":\"setLockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setLockMinimumAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"setLockingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_decimals\",\"type\":\"uint256\"}],\"name\":\"setPaymentToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardPoolTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockNumber\",\"type\":\"uint256\"}],\"name\":\"withdrawLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawRewardPoolTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "A_SensiLockingV2", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://14e0b924d6f2f0cc25ee606c0f95e56159966568bb6351484f7c12e82c22a72b"}