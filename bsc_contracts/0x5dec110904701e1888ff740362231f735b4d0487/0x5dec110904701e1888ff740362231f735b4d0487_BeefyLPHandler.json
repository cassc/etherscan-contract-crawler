{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/Denominations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Denominations {\\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\\n\\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\\n  address public constant USD = address(840);\\n  address public constant GBP = address(826);\\n  address public constant EUR = address(978);\\n  address public constant JPY = address(392);\\n  address public constant KRW = address(410);\\n  address public constant CNY = address(156);\\n  address public constant AUD = address(36);\\n  address public constant CAD = address(124);\\n  address public constant CHF = address(756);\\n  address public constant ARS = address(32);\\n  address public constant PHP = address(608);\\n  address public constant NZD = address(554);\\n  address public constant SGD = address(702);\\n  address public constant NGN = address(566);\\n  address public constant ZAR = address(710);\\n  address public constant RUB = address(643);\\n  address public constant INR = address(356);\\n  address public constant BRL = address(986);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-4.8.2/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-4.8.2/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.4.0;\\n\\n// computes square roots using the babylonian method\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\nlibrary Babylonian {\\n    // credit for this implementation goes to\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\n        if (x == 0) return 0;\\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\\n        // however that code costs significantly more gas\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) {\\n            xx >>= 128;\\n            r <<= 64;\\n        }\\n        if (xx >= 0x10000000000000000) {\\n            xx >>= 64;\\n            r <<= 32;\\n        }\\n        if (xx >= 0x100000000) {\\n            xx >>= 32;\\n            r <<= 16;\\n        }\\n        if (xx >= 0x10000) {\\n            xx >>= 16;\\n            r <<= 8;\\n        }\\n        if (xx >= 0x100) {\\n            xx >>= 8;\\n            r <<= 4;\\n        }\\n        if (xx >= 0x10) {\\n            xx >>= 4;\\n            r <<= 2;\\n        }\\n        if (xx >= 0x8) {\\n            r <<= 1;\\n        }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return (r < r1 ? r : r1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/FunctionParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.16;\\n\\nlibrary FunctionParameters {\\n  /**\\n   * @notice Struct having the init data for a new IndexFactory creation\\n   * @param _indexSwapLibrary Address of the base IndexSwapLibrary\\n   * @param _baseIndexSwapAddress Address of the base IndexSwap\\n   * @param _baseRebalancingAddres Address of the base Rebalancing module\\n   * @param _baseOffChainRebalancingAddress Address of the base Offchain-Rebalance module\\n   * @param _baseRebalanceAggregatorAddress Address of the base Rebalance Aggregator module\\n   * @param _baseExchangeHandlerAddress Address of the base Exchange Handler\\n   * @param _baseAssetManagerConfigAddress Address of the baes AssetManager Config address\\n   * @param _baseOffChainIndexSwapAddress Address of the base Offchain-IndexSwap module\\n   * @param _feeModuleImplementationAddress Address of the base Fee Module implementation\\n   * @param _baseVelvetGnosisSafeModuleAddress Address of the base Gnosis-Safe module\\n   * @param _gnosisSingleton Address of the Gnosis Singleton\\n   * @param _gnosisFallbackLibrary Address of the Gnosis Fallback Library\\n   * @param _gnosisMultisendLibrary Address of the Gnosis Multisend Library\\n   * @param _gnosisSafeProxyFactory Address of the Gnosis Safe Proxy Factory\\n   * @param _priceOracle Address of the base Price Oracle to be used\\n   * @param _tokenRegistry Address of the Token Registry to be used\\n   * @param _velvetProtocolFee Fee cut that is being charged (eg: 25% of the fees)\\n   */\\n  struct IndexFactoryInitData {\\n    address _indexSwapLibrary;\\n    address _baseIndexSwapAddress;\\n    address _baseRebalancingAddres;\\n    address _baseOffChainRebalancingAddress;\\n    address _baseRebalanceAggregatorAddress;\\n    address _baseExchangeHandlerAddress;\\n    address _baseAssetManagerConfigAddress;\\n    address _baseOffChainIndexSwapAddress;\\n    address _feeModuleImplementationAddress;\\n    address _baseVelvetGnosisSafeModuleAddress;\\n    address _gnosisSingleton;\\n    address _gnosisFallbackLibrary;\\n    address _gnosisMultisendLibrary;\\n    address _gnosisSafeProxyFactory;\\n    address _priceOracle;\\n    address _tokenRegistry;\\n  }\\n\\n  /**\\n   * @notice Data passed from the Factory for the init of IndexSwap module\\n   * @param _name Name of the Index Fund\\n   * @param _symbol Symbol to represent the Index Fund\\n   * @param _vault Address of the Vault associated with that Index Fund\\n   * @param _module Address of the Safe module  associated with that Index Fund\\n   * @param _oracle Address of the Price Oracle associated with that Index Fund\\n   * @param _accessController Address of the Access Controller associated with that Index Fund\\n   * @param _tokenRegistry Address of the Token Registry associated with that Index Fund\\n   * @param _exchange Address of the Exchange Handler associated with that Index Fund\\n   * @param _iAssetManagerConfig Address of the Asset Manager Config associated with that Index Fund\\n   * @param _feeModule Address of the Fee Module associated with that Index Fund\\n   */\\n  struct IndexSwapInitData {\\n    string _name;\\n    string _symbol;\\n    address _vault;\\n    address _module;\\n    address _oracle;\\n    address _accessController;\\n    address _tokenRegistry;\\n    address _exchange;\\n    address _iAssetManagerConfig;\\n    address _feeModule;\\n  }\\n\\n  /**\\n   * @notice Struct used to pass data when a Token is swapped to ETH (native token) using the swap handler\\n   * @param _token Address of the token being swapped\\n   * @param _to Receiver address that is receiving the swapped result\\n   * @param _swapHandler Address of the swap handler being used for the swap\\n   * @param _swapAmount Amount of tokens to be swapped\\n   * @param _slippage Slippage allowed for the swap\\n   * @param _lpSlippage LP Slippage allowed for the swap\\n   */\\n  struct SwapTokenToETHData {\\n    address _token;\\n    address _to;\\n    address _swapHandler;\\n    uint256 _swapAmount;\\n    uint256 _slippage;\\n    uint256 _lpSlippage;\\n  }\\n\\n  /**\\n   * @notice Struct used to pass data when ETH (native token) is swapped to some other Token using the swap handler\\n   * @param _token Address of the token being swapped to\\n   * @param _to Receiver address that will receive the swapped tokens\\n   * @param _swapHandler Address of the swap handler being used for the swap\\n   * @param _toUser Address used to return the dust amount accumulated while investment/withdrawal\\n   * @param _slippage Slippage allowed for the swap\\n   * @param _lpSlippage LP Slippage allowed for the swap\\n   * @param _swapAmount Amount of tokens that is to be swapped\\n   */\\n  struct SwapETHToTokenData {\\n    address _token;\\n    address _to;\\n    address _swapHandler;\\n    address _toUser;\\n    uint256 _slippage;\\n    uint256 _lpSlippage;\\n    uint256 _swapAmount;\\n  }\\n\\n  /**\\n   * @notice Struct used to pass data when ETH (native token) is swapped to some other Token using the swap handler\\n   * @param _token Address of the token being swapped to\\n   * @param _to Receiver address that will receive the swapped tokens\\n   * @param _swapHandler Address of the swap handler being used for the swap\\n   * @param _toUser Address used to return the dust amount accumulated while investment/withdrawal\\n   * @param _slippage Slippage allowed for the swap\\n   * @param _lpSlippage LP Slippage allowed for the swap\\n   */\\n  struct SwapETHToTokenPublicData {\\n    address _token;\\n    address _to;\\n    address _swapHandler;\\n    address _toUser;\\n    uint256 _slippage;\\n    uint256 _lpSlippage;\\n  }\\n\\n  /**\\n   * @notice Struct used to pass data when a Token is swapped to another token using the swap handler\\n   * @param _tokenIn Address of the token being swapped from\\n   * @param _tokenOut Address of the token being swapped to\\n   * @param _to Receiver address that will receive the swapped tokens\\n   * @param _swapHandler Address of the swap handler being used for the swap\\n   * @param _toUser Address used to return the dust amount accumulated while investment/withdrawal\\n   * @param _swapAmount Amount of tokens that is to be swapped\\n   * @param _slippage Slippage allowed for the swap\\n   * @param _lpSlippage LP Slippage allowed for the swap\\n   * @param _isInvesting Boolean parameter indicating if the swap is being done during investment or withdrawal\\n   */\\n  struct SwapTokenToTokenData {\\n    address _tokenIn;\\n    address _tokenOut;\\n    address _to;\\n    address _swapHandler;\\n    address _toUser;\\n    uint256 _swapAmount;\\n    uint256 _slippage;\\n    uint256 _lpSlippage;\\n    bool _isInvesting;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the swap of one token to another based on the input\\n   * @param _index Address of the IndexSwap associated with the swap tokens\\n   * @param _inputToken Address of the token being swapped from\\n   * @param _swapHandler Address of the swap handler being used\\n   * @param _toUser Address used to return the dust amount accumulated while investment/withdrawal\\n   * @param _tokenAmount Investment amount that is being distributed into all the portfolio tokens\\n   * @param _totalSupply Total supply of the Index tokens\\n   * @param amount The swap amount (in case totalSupply != 0) value calculated from the IndexSwapLibrary\\n   * @param _slippage Slippage for providing the liquidity\\n   * @param _lpSlippage LP Slippage for providing the liquidity\\n   */\\n  struct SwapTokenToTokensData {\\n    address _index;\\n    address _inputToken;\\n    address _swapHandler;\\n    address _toUser;\\n    uint256 _tokenAmount;\\n    uint256 _totalSupply;\\n    uint256[] amount;\\n    uint256[] _slippage;\\n    uint256[] _lpSlippage;\\n  }\\n\\n  /**\\n   * @notice Struct having the Offchain Investment data used for multiple functions\\n   * @param _offChainHandler Address of the off-chain handler being used\\n   * @param _buyAmount Array of amounts representing the distribution to all portfolio tokens; sum of this amount is the total investment amount\\n   * @param _buySwapData Array including the calldata which is required for the external swap handlers to swap (\\\"buy\\\") the portfolio tokens\\n   */\\n  struct ZeroExData {\\n    address _offChainHandler;\\n    uint256[] _buyAmount;\\n    bytes[] _buySwapData;\\n  }\\n\\n  /**\\n   * @notice Struct having the init data for a new Index Fund creation using the Factory\\n   * @param _assetManagerTreasury Address of the Asset Manager Treasury to be associated with the fund\\n   * @param _whitelistedTokens Array of tokens which limits the use of only those addresses as portfolio tokens in the fund\\n   * @param maxIndexInvestmentAmount Maximum Investment amount for the fund\\n   * @param maxIndexInvestmentAmount Minimum Investment amount for the fund\\n   * @param _managementFee Management fee (streaming fee) that the asset manager will receive for managing the fund\\n   * @param _performanceFee Fee that the asset manager will receive for managing the fund and if the portfolio performance well\\n   * @param _entryFee Entry fee for investing into the fund\\n   * @param _exitFee Exit fee for withdrawal from the fund\\n   * @param _public Boolean parameter for is the fund eligible for public investment or only some whitelist users can invest\\n   * @param _transferable Boolean parameter for is the Index tokens from the fund transferable or not\\n   * @param _transferableToPublic Boolean parameter for is the Index tokens from the fund transferable to public or only to whitelisted users\\n   * @param _whitelistTokens Boolean parameter which specifies if the asset manager can only choose portfolio tokens from the whitelisted array or not\\n   * @param name Name of the fund\\n   * @param symbol Symbol associated with the fund\\n   */\\n  struct IndexCreationInitData {\\n    address _assetManagerTreasury;\\n    address[] _whitelistedTokens;\\n    uint256 maxIndexInvestmentAmount;\\n    uint256 minIndexInvestmentAmount;\\n    uint256 _managementFee;\\n    uint256 _performanceFee;\\n    uint256 _entryFee;\\n    uint256 _exitFee;\\n    bool _public;\\n    bool _transferable;\\n    bool _transferableToPublic;\\n    bool _whitelistTokens;\\n    string name;\\n    string symbol;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the Enable Rebalance (1st transaction) during ZeroEx's `Update Weight` call\\n   * @param _lpSlippage Array of LP Slippage values passed to the function\\n   * @param _newWeights Array of new weights for the rebalance\\n   */\\n  struct EnableRebalanceData {\\n    uint256[] _lpSlippage;\\n    uint96[] _newWeights;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the init of Asset Manager Config\\n   * @param _managementFee Management fee (streaming fee) that the asset manager will receive for managing the fund\\n   * @param _performanceFee Fee that the asset manager will receive for managing the fund and if the portfolio performance well\\n   * @param _entryFee Entry fee associated with the config\\n   * @param _exitFee Exit fee associated with the config\\n   * @param _minInvestmentAmount Minimum investment amount specified as per the config\\n   * @param _maxInvestmentAmount Maximum investment amount specified as per the config\\n   * @param _tokenRegistry Address of the Token Registry associated with the config\\n   * @param _accessController Address of the Access Controller associated with the config\\n   * @param _assetManagerTreasury Address of the Asset Manager Treasury account\\n   * @param _whitelistTokens Boolean parameter which specifies if the asset manager can only choose portfolio tokens from the whitelisted array or not\\n   * @param _publicPortfolio Boolean parameter for is the portfolio eligible for public investment or not\\n   * @param _transferable Boolean parameter for is the Index tokens from the fund transferable to public or not\\n   * @param _transferableToPublic Boolean parameter for is the Index tokens from the fund transferable to public or not\\n   * @param _whitelistTokens Boolean parameter for is the token whitelisting enabled for the fund or not\\n   */\\n  struct AssetManagerConfigInitData {\\n    uint256 _managementFee;\\n    uint256 _performanceFee;\\n    uint256 _entryFee;\\n    uint256 _exitFee;\\n    uint256 _minInvestmentAmount;\\n    uint256 _maxInvestmentAmount;\\n    address _tokenRegistry;\\n    address _accessController;\\n    address _assetManagerTreasury;\\n    address[] _whitelistedTokens;\\n    bool _publicPortfolio;\\n    bool _transferable;\\n    bool _transferableToPublic;\\n    bool _whitelistTokens;\\n  }\\n\\n  /**\\n   * @notice Struct with data passed during the withdrawal from the Index Fund\\n   * @param _slippage Array of Slippage values passed for the withdrawal\\n   * @param _lpSlippage Array of LP Slippage values passed for the withdrawal\\n   * @param tokenAmount Amount of the Index Tokens that is to be withdrawn\\n   * @param _swapHandler Address of the swap handler being used for the withdrawal process\\n   * @param _token Address of the token being withdrawn to (must be a primary token)\\n   * @param isMultiAsset Boolean parameter for is the withdrawal being done in portfolio tokens (multi-token) or in the native token\\n   */\\n  struct WithdrawFund {\\n    uint256[] _slippage;\\n    uint256[] _lpSlippage;\\n    uint256 tokenAmount;\\n    address _swapHandler;\\n    address _token;\\n    bool isMultiAsset;\\n  }\\n\\n  /**\\n   * @notice Struct with data passed during the investment into the Index Fund\\n   * @param _slippage Array of Slippage values passed for the investment\\n   * @param _lpSlippage Array of LP Slippage values passed for the deposit into LP protocols\\n   * @param _tokenAmount Amount of token being invested\\n   * @param _to Address that would receive the index tokens post successful investment\\n   * @param _swapHandler Address of the swap handler being used for the investment process\\n   * @param _token Address of the token being made investment in\\n   */\\n  struct InvestFund {\\n    uint256[] _slippage;\\n    uint256[] _lpSlippage;\\n    uint256 _tokenAmount;\\n    address _swapHandler;\\n    address _token;\\n  }\\n\\n  /**\\n   * @notice Struct passed with values for the updation of tokens via the Rebalancing module\\n   * @param tokens Array of the new tokens that is to be updated to \\n   * @param _swapHandler Address of the swap handler being used for the token update\\n   * @param denorms Denorms of the new tokens\\n   * @param _slippageSell Slippage allowed for the sale of tokens\\n   * @param _slippageBuy Slippage allowed for the purchase of tokens\\n   * @param _lpSlippageSell LP Slippage allowed for the sale of tokens\\n   * @param _lpSlippageBuy LP Slippage allowed for the purchase of tokens\\n   */\\n  struct UpdateTokens {\\n    address[] tokens;\\n    address _swapHandler;\\n    uint96[] denorms;\\n    uint256[] _slippageSell;\\n    uint256[] _slippageBuy;\\n    uint256[] _lpSlippageSell;\\n    uint256[] _lpSlippageBuy;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the redeem of tokens using the handlers for different protocols\\n   * @param _amount Amount of protocol tokens to be redeemed using the handler\\n   * @param _lpSlippage LP Slippage allowed for the redeem process\\n   * @param _to Address that would receive the redeemed tokens\\n   * @param _yieldAsset Address of the protocol token that is being redeemed against\\n   * @param isWETH Boolean parameter for is the redeem being done for WETH (native token) or not\\n   */\\n  struct RedeemData {\\n    uint256 _amount;\\n    uint256 _lpSlippage;\\n    address _to;\\n    address _yieldAsset;\\n    bool isWETH;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the setup of different roles during an Index Fund creation\\n   * @param _exchangeHandler Addresss of the Exchange handler for the fund\\n   * @param _index Address of the IndexSwap for the fund\\n   * @param _tokenRegistry Address of the Token Registry for the fund\\n   * @param _portfolioCreator Address of the account creating/deploying the portfolio\\n   * @param _rebalancing Address of the Rebalancing module for the fund\\n   * @param _offChainRebalancing Address of the Offchain-Rebalancing module for the fund\\n   * @param _rebalanceAggregator Address of the Rebalance Aggregator for the fund\\n   * @param _feeModule Address of the Fee Module for the fund\\n   * @param _offChainIndexSwap Address of the OffChain-IndexSwap for the fund\\n   */\\n  struct AccessSetup {\\n    address _exchangeHandler;\\n    address _index;\\n    address _tokenRegistry;\\n    address _portfolioCreator;\\n    address _rebalancing;\\n    address _offChainRebalancing;\\n    address _rebalanceAggregator;\\n    address _feeModule;\\n    address _offChainIndexSwap;\\n  }\\n}\"\r\n    },\r\n    \"contracts/handler/AbstractLPHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\nimport {RouterInterface} from \\\"./interfaces/RouterInterface.sol\\\";\\nimport {SlippageControl} from \\\"./SlippageControl.sol\\\";\\nimport {DustHandler} from \\\"./DustHandler.sol\\\";\\nimport {IERC20Metadata} from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport {FunctionParameters} from \\\"../FunctionParameters.sol\\\";\\nimport {ErrorLibrary} from \\\"../library/ErrorLibrary.sol\\\";\\nimport {LPInterface} from \\\"./interfaces/LPInterface.sol\\\";\\nimport {Babylonian} from \\\"@uniswap/lib/contracts/libraries/Babylonian.sol\\\";\\nimport {FactoryInterface} from \\\"./interfaces/FactoryInterface.sol\\\";\\nimport {FullMath} from \\\"./libraries/FullMath.sol\\\";\\nimport {IPriceOracle} from \\\"../oracle/IPriceOracle.sol\\\";\\npragma solidity 0.8.16;\\n\\nabstract contract UniswapV2LPHandler is SlippageControl, DustHandler {\\n  event VELVET_ADDED_LIQUIDITY(uint256[] amountProvided, uint256 minAmountA, uint256 minAmountB, uint256 liquidity);\\n  event VELVET_REMOVE_LIQUIDITY(uint256 liquidityProvided, uint256 amountA, uint256 amountB);\\n\\n  function _approveAndDeposit(\\n    address[] memory underlying,\\n    address _router,\\n    uint256[] memory _amount,\\n    address _to\\n  ) internal returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\\n    TransferHelper.safeApprove(address(underlying[0]), _router, 0);\\n    TransferHelper.safeApprove(address(underlying[0]), _router, _amount[0]);\\n    TransferHelper.safeApprove(address(underlying[1]), _router, 0);\\n    TransferHelper.safeApprove(address(underlying[1]), _router, _amount[1]);\\n    (amountA, amountB, liquidity) = RouterInterface(_router).addLiquidity(\\n      address(underlying[0]),\\n      address(underlying[1]),\\n      _amount[0],\\n      _amount[1],\\n      1,\\n      1,\\n      _to,\\n      block.timestamp\\n    );\\n  }\\n\\n  function _approveAndDepositETH(\\n    address[] memory underlying,\\n    address _router,\\n    uint256[] memory _amount,\\n    address _to\\n  ) internal returns (uint256 amountA, uint256 amountB, uint256 liquidity) {\\n    RouterInterface router = RouterInterface(_router);\\n    uint256 i = underlying[0] == router.WETH() ? 1 : 0;\\n    TransferHelper.safeApprove(address(underlying[i]), _router, 0);\\n    TransferHelper.safeApprove(address(underlying[i]), _router, _amount[i]);\\n    (amountA, amountB, liquidity) = router.addLiquidityETH{value: msg.value}(\\n      underlying[i],\\n      _amount[i],\\n      1,\\n      1,\\n      _to,\\n      block.timestamp\\n    );\\n    (amountA, amountB) = sortReturnAmounts(i, amountA, amountB);\\n  }\\n\\n  /**\\n   * @notice This function adds liquidity to the BiSwap protocol\\n   * @param _lpAsset Address of the protocol asset to be deposited\\n   * @param _amount Amount that is to be deposited\\n   * @param _lpSlippage LP slippage value passed to the function\\n   * @param _to Address that would receive the cTokens in return\\n   * @param routerAddress Address of the protocol called\\n   */\\n  function _deposit(\\n    address _lpAsset,\\n    uint256[] memory _amount,\\n    uint256 _lpSlippage,\\n    address _to,\\n    address routerAddress,\\n    address user,\\n    address _oracle,\\n    uint priceA,\\n    uint priceB\\n  ) internal returns (uint256 _mintedAmount) {\\n    if (_lpAsset == address(0) || _to == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    address[] memory underlying = _getUnderlyingTokens(_lpAsset);\\n    uint256 amountA;\\n    uint256 amountB;\\n    uint256 liquidity;\\n    if (msg.value == 0) {\\n      (amountA, amountB, liquidity) = _approveAndDeposit(underlying, routerAddress, _amount, _to);\\n    } else {\\n      (amountA, amountB, liquidity) = _approveAndDepositETH(underlying, routerAddress, _amount, _to);\\n    }\\n    uint256 lpSlippage = _lpSlippage;\\n    validateLPSlippage(underlying, amountA, amountB, priceA, priceB, lpSlippage);\\n    _returnDust(\\n      underlying[0],\\n      user // we need to pass user from exchange\\n    );\\n    _returnDust(\\n      underlying[1],\\n      user // we need to pass user from exchange\\n    );\\n    emit VELVET_ADDED_LIQUIDITY(_amount, amountA, amountB, liquidity);\\n    _mintedAmount = _calculatePriceForBalance(_lpAsset, _oracle, liquidity);\\n  }\\n\\n  function _redeemETH(\\n    FunctionParameters.RedeemData calldata inputData,\\n    address[] memory _underlying,\\n    LPInterface _token,\\n    RouterInterface _router\\n  ) internal returns (uint256 amountA, uint256 amountB) {\\n    uint256 indexi = 0;\\n    uint256 indexj = 1;\\n    if (_underlying[0] == _router.WETH()) {\\n      indexi = 1;\\n      indexj = 0;\\n    }\\n    TransferHelper.safeApprove(address(_token), address(_router), 0);\\n    TransferHelper.safeApprove(address(_token), address(_router), inputData._amount);\\n    (amountA, amountB) = _router.removeLiquidityETH(\\n      _underlying[indexi],\\n      inputData._amount,\\n      1,\\n      1,\\n      inputData._to,\\n      block.timestamp\\n    );\\n    (amountA, amountB) = sortReturnAmounts(indexi, amountA, amountB);\\n  }\\n\\n  function sortReturnAmounts(\\n    uint256 _nonETHTokenPosition,\\n    uint256 amountATemp,\\n    uint256 amountBTemp\\n  ) internal pure returns (uint256 amountA, uint256 amountB) {\\n    (amountA, amountB) = _nonETHTokenPosition == 0 ? (amountATemp, amountBTemp) : (amountBTemp, amountATemp);\\n  }\\n\\n  /**\\n   * @notice This function remove liquidity from the called protocol\\n   */\\n  function _redeem(\\n    FunctionParameters.RedeemData calldata inputData,\\n    address routerAddress,\\n    uint priceA,\\n    uint priceB\\n  ) internal {\\n    if (inputData._yieldAsset == address(0) || inputData._to == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    LPInterface token = LPInterface(inputData._yieldAsset);\\n    if (inputData._amount > token.balanceOf(address(this))) {\\n      revert ErrorLibrary.NotEnoughBalanceInPancakeProtocol();\\n    }\\n    address[] memory underlying = _getUnderlyingTokens(inputData._yieldAsset);\\n    RouterInterface router = RouterInterface(routerAddress);\\n    uint256 amountA;\\n    uint256 amountB;\\n    if (inputData.isWETH) {\\n      (amountA, amountB) = _redeemETH(inputData, underlying, token, router);\\n    } else {\\n      TransferHelper.safeApprove(address(token), address(router), 0);\\n      TransferHelper.safeApprove(address(token), address(router), inputData._amount);\\n      (amountA, amountB) = router.removeLiquidity(\\n        underlying[0],\\n        underlying[1],\\n        inputData._amount,\\n        1,\\n        1,\\n        inputData._to,\\n        block.timestamp\\n      );\\n    }\\n    validateLPSlippage(underlying, amountA, amountB, priceA, priceB, inputData._lpSlippage);\\n    emit VELVET_REMOVE_LIQUIDITY(inputData._amount, amountA, amountB);\\n  }\\n\\n  function _calculatePriceForBalance(\\n    address _token,\\n    address _oracle,\\n    uint256 _balance\\n  ) internal view returns (uint256 finalLPPrice) {\\n    if (_token == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    uint fairLPPrice = IPriceOracle(_oracle).getPriceForOneTokenInUSD(_token);\\n    uint256 _tokenDecimal = IERC20Metadata(_token).decimals();\\n    finalLPPrice = (fairLPPrice * _balance) / (10 ** _tokenDecimal);\\n  }\\n\\n  /**\\n   * @notice This function returns address of the underlying asset\\n   * @param _lpToken Address of the protocol token whose underlying asset is needed\\n   * @return underlying Address of the underlying asset\\n   */\\n  function _getUnderlyingTokens(address _lpToken) internal view virtual returns (address[] memory) {\\n    if (_lpToken == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    address[] memory underlying = new address[](2);\\n    LPInterface token = LPInterface(_lpToken);\\n    underlying[0] = token.token0();\\n    underlying[1] = token.token1();\\n    return underlying;\\n  }\\n\\n  /**\\n   * @notice This function returns the protocol token balance of the passed address\\n   * @param _tokenHolder Address whose balance is to be retrieved\\n   * @param t Address of the protocol token\\n   * @return tokenBalance t token balance of the holder\\n   */\\n  function _getTokenBalance(address _tokenHolder, address t) internal view returns (uint256 tokenBalance) {\\n    if (_tokenHolder == address(0) || t == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    LPInterface token = LPInterface(t);\\n    tokenBalance = token.balanceOf(_tokenHolder);\\n  }\\n\\n  /**\\n   * @notice This function returns the protocol token balance of the passed address\\n   * @param _amountA Amount of token A from the LP\\n   * @param _amountA Amount of token A from the LP\\n   * @param _priceA Price of token A from the oracle\\n   * @param _priceB Price of token B from the oracle\\n   * @param _lpSlippage LP slippage sent by the user\\n   */\\n  function validateLPSlippage(\\n    address[] memory _underlying,\\n    uint _amountA,\\n    uint _amountB,\\n    uint _priceA,\\n    uint _priceB,\\n    uint _lpSlippage\\n  ) internal view {\\n    uint decimalFixedAmountA = (_amountA * (10 ** 18)) / (10 ** IERC20Metadata(_underlying[0]).decimals());\\n    uint decimalFixedAmountB = (_amountB * (10 ** 18)) / (10 ** IERC20Metadata(_underlying[1]).decimals());\\n    _validateLPSlippage(decimalFixedAmountA, decimalFixedAmountB, _priceA, _priceB, _lpSlippage);\\n  }\\n}\"\r\n    },\r\n    \"contracts/handler/Beefy/BeefyLPHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n// Beefy Official Docs: https://docs.beefy.finance/\\n// Beefy GitHub: https://github.com/beefyfinance\\n\\n/**\\n * @title Handler for the Beefy's LP protocol\\n * @author Velvet.Capital\\n * @notice This contract is used to add and remove liquidity\\n *      to/from the Beefy protocol.\\n * @dev This contract includes functionalities:\\n *      1. Add liquidity to the Beefy protocol\\n *      2. Redeem liquidity from the Beefy protocol\\n *      3. Get underlying asset address\\n *      4. Get protocol token balance\\n *      5. Get underlying asset balance\\n */\\n\\npragma solidity 0.8.16;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IERC20MetadataUpgradeable} from \\\"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\n\\nimport {LPInterface} from \\\"./interfaces/LPInterface.sol\\\";\\nimport {FactoryInterface} from \\\"./interfaces/FactoryInterface.sol\\\";\\nimport {Babylonian} from \\\"@uniswap/lib/contracts/libraries/Babylonian.sol\\\";\\nimport {ISolidlyPair} from \\\"./interfaces/ISolidlyPair.sol\\\";\\nimport {IPriceOracle} from \\\"../../oracle/IPriceOracle.sol\\\";\\nimport {IHandler} from \\\"../IHandler.sol\\\";\\nimport {IVaultBeefy} from \\\"./interfaces/IVaultBeefy.sol\\\";\\nimport {IStrategy} from \\\"./interfaces/IStrategy.sol\\\";\\n\\nimport {FullMath} from \\\"../libraries/FullMath.sol\\\";\\nimport {ErrorLibrary} from \\\"./../../library/ErrorLibrary.sol\\\";\\nimport {FunctionParameters} from \\\"../../FunctionParameters.sol\\\";\\nimport {UniswapV2LPHandler} from \\\"../AbstractLPHandler.sol\\\";\\nimport {Denominations} from \\\"@chainlink/contracts/src/v0.8/Denominations.sol\\\";\\n\\ncontract BeefyLPHandler is IHandler, UniswapV2LPHandler {\\n  uint256 internal constant DIVISOR_INT = 10_000;\\n  address internal immutable lpHandlerAddress;\\n  IPriceOracle internal _oracle;\\n\\n  event Deposit(address indexed user, address indexed token, uint256[] amounts, address indexed to);\\n  event Redeem(address indexed user, address indexed token, uint256 amount, address indexed to, bool isWETH);\\n\\n  constructor(address _lpHandlerAddress, address _priceOracle) {\\n     if(_priceOracle == address(0) || _lpHandlerAddress == address(0)){\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    lpHandlerAddress = _lpHandlerAddress;\\n    _oracle = IPriceOracle(_priceOracle);\\n  }\\n\\n  /**\\n   * @notice This function adds liquidity to the Beefy protocol\\n   * @param mooLpAsset Address of the protocol asset to be deposited\\n   * @param _amount Amount that is to be deposited\\n   * @param _lpSlippage LP slippage value passed to the function\\n   * @param _to Address that would receive the cTokens in return\\n   */\\n  function deposit(\\n    address mooLpAsset,\\n    uint256[] memory _amount,\\n    uint256 _lpSlippage,\\n    address _to,\\n    address user\\n  ) public payable override returns (uint256 _mintedAmount) {\\n    if (mooLpAsset == address(0) || _to == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    address[] memory underlying = getUnderlying(mooLpAsset);\\n    address underlyingLpToken = address(IStrategy(address(IVaultBeefy(mooLpAsset).strategy())).want());\\n    if (msg.value == 0) {\\n      uint256 tok1bal = IERC20Upgradeable(underlying[0]).balanceOf(address(this));\\n      uint256 tok2bal = IERC20Upgradeable(underlying[1]).balanceOf(address(this));\\n      if (tok1bal < _amount[0]) {\\n        revert ErrorLibrary.InsufficientTokenABalance();\\n      }\\n      if (tok2bal < _amount[1]) {\\n        revert ErrorLibrary.InsufficientTokenBBalance();\\n      }\\n      TransferHelper.safeTransfer(underlying[0], lpHandlerAddress, _amount[0]);\\n      TransferHelper.safeTransfer(underlying[1], lpHandlerAddress, _amount[1]);\\n      _mintedAmount = IHandler(lpHandlerAddress).deposit(\\n        address(underlyingLpToken),\\n        _amount,\\n        _lpSlippage,\\n        address(this),\\n        user\\n      );\\n    } else {\\n      uint256 amountBNB = address(this).balance;\\n      uint256 index = underlying[0] == WETH ? 1 : 0;\\n      uint256 tokbal = IERC20Upgradeable(underlying[index]).balanceOf(address(this));\\n      TransferHelper.safeTransfer(address(underlying[index]), lpHandlerAddress, tokbal);\\n      _mintedAmount = IHandler(lpHandlerAddress).deposit{value: amountBNB}(\\n        underlyingLpToken,\\n        _amount,\\n        _lpSlippage,\\n        address(this),\\n        user\\n      );\\n    }\\n\\n    uint256 LPTokens = IERC20Upgradeable(underlyingLpToken).balanceOf(address(this));\\n    TransferHelper.safeApprove(address(underlyingLpToken), address(mooLpAsset), LPTokens);\\n    IVaultBeefy(mooLpAsset).deposit(LPTokens);\\n    if (_to != address(this)) {\\n      uint256 assetBalance = IERC20Upgradeable(mooLpAsset).balanceOf(address(this));\\n      TransferHelper.safeTransfer(mooLpAsset, _to, assetBalance);\\n    }\\n    emit Deposit(msg.sender, mooLpAsset, _amount, _to);\\n  }\\n\\n  /**\\n   * @notice This function remove liquidity from the Beefy protocol\\n   */\\n  function redeem(FunctionParameters.RedeemData calldata inputData) public override {\\n    if (inputData._yieldAsset == address(0) || inputData._to == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n\\n    IVaultBeefy asset = IVaultBeefy(inputData._yieldAsset);\\n    address underlyingLpToken = address(IStrategy(address(asset.strategy())).want());\\n    if (inputData._amount > asset.balanceOf(address(this))) {\\n      revert ErrorLibrary.NotEnoughBalanceInBeefy();\\n    }\\n    asset.withdraw(inputData._amount);\\n    uint256 LPTokens = IERC20Upgradeable(underlyingLpToken).balanceOf(address(this));\\n    TransferHelper.safeTransfer(underlyingLpToken, lpHandlerAddress, LPTokens);\\n\\n    IHandler(lpHandlerAddress).redeem(\\n      FunctionParameters.RedeemData(\\n        inputData._amount,\\n        inputData._lpSlippage,\\n        inputData._to,\\n        underlyingLpToken,\\n        inputData.isWETH\\n      )\\n    );\\n\\n    emit Redeem(msg.sender, inputData._yieldAsset, inputData._amount, inputData._to, inputData.isWETH);\\n  }\\n\\n  /**\\n   * @notice This function returns address of the underlying asset\\n   * @param mooLpAsset Address of the protocol token whose underlying asset is needed\\n   * @return underlying Address of the underlying asset\\n   */\\n  function getUnderlying(address mooLpAsset) public view override returns (address[] memory) {\\n    if (address(mooLpAsset) == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    address[] memory underlying = new address[](2);\\n    address underlyingLpToken = address(IStrategy(address(IVaultBeefy(mooLpAsset).strategy())).want());\\n    ISolidlyPair token = ISolidlyPair(underlyingLpToken);\\n    underlying[0] = token.token0();\\n    underlying[1] = token.token1();\\n    return underlying;\\n  }\\n\\n  /**\\n   * @notice This function returns the protocol token balance of the passed address\\n   * @param _tokenHolder Address whose balance is to be retrieved\\n   * @param t Address of the protocol token\\n   * @return tokenBalance t token balance of the holder\\n   */\\n  function getTokenBalance(address _tokenHolder, address t) public view override returns (uint256 tokenBalance) {\\n    if (_tokenHolder == address(0) || t == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    IVaultBeefy asset = IVaultBeefy(t);\\n    tokenBalance = asset.balanceOf(_tokenHolder);\\n  }\\n\\n  /**\\n   * @notice This function returns the USD value of the LP asset using Fair LP Price model\\n   * @param _tokenHolder Address whose balance is to be retrieved\\n   * @param t Address of the protocol token\\n   */\\n  function getTokenBalanceUSD(address _tokenHolder, address t) public view override returns (uint256) {\\n    if (t == address(0) || _tokenHolder == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    IVaultBeefy asset = IVaultBeefy(t);\\n\\n    address underlyingLpToken = address(IStrategy(address(asset.strategy())).want());\\n    uint256 underlyingBalance = (getTokenBalance(_tokenHolder, t) * (asset.getPricePerFullShare()))/10 ** IERC20MetadataUpgradeable(t).decimals();\\n    return _calculatePriceForBalance(underlyingLpToken, address(_oracle), underlyingBalance);\\n  }\\n\\n  function getUnderlyingBalance(address _tokenHolder, address t) public view override returns (uint256[] memory) {}\\n\\n  function encodeData(address t, uint256 _amount) public returns (bytes memory) {}\\n\\n  function getRouterAddress() public view returns (address) {}\\n\\n  function getClaimTokenCalldata(address, address) public pure returns (bytes memory, address) {}\\n\\n  receive() external payable {}\\n}\"\r\n    },\r\n    \"contracts/handler/Beefy/interfaces/FactoryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\ninterface FactoryInterface {\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n  function feeTo() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/Beefy/interfaces/ISolidlyPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\ninterface ISolidlyPair {\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function burn(address to) external returns (uint amount0, uint amount1);\\n\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n  function stable() external view returns (bool);\\n\\n  function getAmountOut(uint256 amountIn, address tokenIn) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/Beefy/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\ninterface IStrategy {\\n  function vault() external view returns (address);\\n\\n  function want() external view returns (IERC20Upgradeable);\\n\\n  function beforeDeposit() external;\\n\\n  function deposit() external;\\n\\n  function withdraw(uint256) external;\\n\\n  function balanceOf() external view returns (uint256);\\n\\n  function balanceOfWant() external view returns (uint256);\\n\\n  function balanceOfPool() external view returns (uint256);\\n\\n  function harvest() external;\\n\\n  function retireStrat() external;\\n\\n  function panic() external;\\n\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function paused() external view returns (bool);\\n\\n  function unirouter() external view returns (address);\\n\\n  function stable() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/Beefy/interfaces/IVaultBeefy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {IStrategy} from \\\"./IStrategy.sol\\\";\\n\\ninterface IVaultBeefy is IERC20Upgradeable {\\n  function deposit(uint256) external;\\n\\n  function depositAll() external;\\n\\n  function withdraw(uint256) external;\\n\\n  function depositBNB() external payable; //only for mooVenusBNB\\n\\n  function withdrawBNB(uint256) external; //only for mooVenusBNB\\n\\n  function withdrawAll() external;\\n\\n  function getPricePerFullShare() external view returns (uint256);\\n\\n  function upgradeStrat() external;\\n\\n  function balance() external view returns (uint256);\\n\\n  function want() external view returns (IERC20Upgradeable);\\n\\n  function strategy() external view returns (IStrategy);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/Beefy/interfaces/LPInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.16;\\n\\ninterface LPInterface {\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external pure returns (uint8);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address owner) external view returns (uint);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function kLast() external view returns (uint);\\n\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/DustHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {ISwapHandler} from \\\"../handler/ISwapHandler.sol\\\";\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {ErrorLibrary} from \\\"../library/ErrorLibrary.sol\\\";\\n\\nabstract contract DustHandler {\\n  address public constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n\\n  // after investment if we can't deposit everything we might have underlying tokens left, no need to deposit/redeem - only swap\\n  function _returnDust(address _token, address _to) internal {\\n    if (_token == WETH) {\\n      (bool success, ) = payable(_to).call{value: address(this).balance}(\\\"\\\");\\n      if (!success) revert ErrorLibrary.TransferFailed();\\n    } else {\\n      uint balance = IERC20Upgradeable(_token).balanceOf(address(this));\\n      TransferHelper.safeTransfer(_token, _to, balance);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/handler/IHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n// lend token\\n// redeem token\\n// claim token\\n// get token balance\\n// get underlying balance\\n\\npragma solidity 0.8.16;\\n\\nimport {FunctionParameters} from \\\"../FunctionParameters.sol\\\";\\n\\ninterface IHandler {\\n  function deposit(address, uint256[] memory, uint256, address, address) external payable returns (uint256);\\n\\n  function redeem(FunctionParameters.RedeemData calldata inputData) external;\\n\\n  function getTokenBalance(address, address) external view returns (uint256);\\n\\n  function getUnderlyingBalance(address, address) external returns (uint256[] memory);\\n\\n  function getUnderlying(address) external view returns (address[] memory);\\n\\n  function getRouterAddress() external view returns (address);\\n\\n  function encodeData(address t, uint256 _amount) external returns (bytes memory);\\n\\n  function getClaimTokenCalldata(address _alpacaToken, address _holder) external returns (bytes memory, address);\\n\\n  function getTokenBalanceUSD(address _tokenHolder, address t) external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/handler/interfaces/FactoryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\ninterface FactoryInterface {\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n  function feeTo() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/interfaces/LPInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.16;\\n\\ninterface LPInterface {\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external pure returns (uint8);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address owner) external view returns (uint);\\n\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function kLast() external view returns (uint);\\n\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/interfaces/RouterInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.16;\\n\\ninterface RouterInterface {\\n  function WETH() external view returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountToken, uint amountETH);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/ISwapHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\ninterface ISwapHandler {\\n  function getETH() external view returns (address);\\n\\n  function getSwapAddress(uint256 _swapAmount, address _t) external view returns (address);\\n\\n  function swapTokensToETH(uint256 _swapAmount, uint256 _slippage, address _t, address _to, bool isEnabled) external returns (uint256);\\n\\n  function swapETHToTokens(uint256 _slippage, address _t, address _to) external payable returns (uint256);\\n\\n  function swapTokenToTokens(\\n    uint256 _swapAmount,\\n    uint256 _slippage,\\n    address _tokenIn,\\n    address _tokenOut,\\n    address _to,\\n    bool isEnabled\\n  ) external returns (uint256 swapResult);\\n\\n  function getPathForETH(address crypto) external view returns (address[] memory);\\n\\n  function getPathForToken(address token) external view returns (address[] memory);\\n\\n  function getSlippage(\\n    uint256 _amount,\\n    uint256 _slippage,\\n    address[] memory path\\n  ) external view returns (uint256 minAmount);\\n}\"\r\n    },\r\n    \"contracts/handler/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC-BY-4.0\\npragma solidity 0.8.16;\\n\\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\\n// license is CC-BY-4.0\\nimport {ErrorLibrary} from \\\"contracts/library/ErrorLibrary.sol\\\";\\nlibrary FullMath {\\n  function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\\n    uint256 mm = mulmod(x, y, type(uint).max);\\n    l = x * y;\\n    h = mm - l;\\n    if (mm < l) h -= 1;\\n  }\\n\\n  function fullDiv(uint256 l, uint256 h, uint256 d) private pure returns (uint256) {\\n    uint256 pow2 = d & (type(uint256).max - d + 1);\\n    d /= pow2;\\n    l /= pow2;\\n    l += h * (((type(uint256).max - pow2 + 1)) / pow2 + 1);\\n    uint256 r = 1;\\n    r *= 2 - d * r;\\n    r *= 2 - d * r;\\n    r *= 2 - d * r;\\n    r *= 2 - d * r;\\n    r *= 2 - d * r;\\n    r *= 2 - d * r;\\n    r *= 2 - d * r;\\n    r *= 2 - d * r;\\n    return l * r;\\n  }\\n\\n  function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256) {\\n    (uint256 l, uint256 h) = fullMul(x, y);\\n\\n    uint256 mm = mulmod(x, y, d);\\n    if (mm > l) h -= 1;\\n    l -= mm;\\n\\n    if (h == 0) return l / d;\\n\\n    if(h >= d)\\n      revert ErrorLibrary.FULLDIV_OVERFLOW();\\n    return fullDiv(l, h, d);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/handler/SlippageControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts-4.8.2/access/Ownable.sol\\\";\\n\\nimport {ErrorLibrary} from \\\"../library/ErrorLibrary.sol\\\";\\n\\n/*\\n  This contract is for LP slippage to protect the users of an imbalanced pool\\n */\\nabstract contract SlippageControl is Ownable {\\n  uint256 public maxSlippage;\\n\\n  uint256 public constant HUNDRED_PERCENT = 10_000;\\n\\n  event AddOrUpdateProtocolSlippage(uint256 _slippage);\\n\\n  /**\\n   * @notice This function updates/adds max slippage allowed\\n   */\\n  function addOrUpdateProtocolSlippage(uint256 _slippage) public onlyOwner {\\n    if (_slippage >= HUNDRED_PERCENT) {\\n      revert ErrorLibrary.IncorrectSlippageRange();\\n    }\\n    maxSlippage = _slippage;\\n    emit AddOrUpdateProtocolSlippage(_slippage);\\n  }\\n\\n  /**\\n   * @notice This function calculates slippage from the called protocol\\n   */\\n  function getSlippage(uint256 _amount, uint256 _lpSlippage) internal view returns (uint256 minAmount) {\\n    if (maxSlippage < _lpSlippage) {\\n      revert ErrorLibrary.InvalidLPSlippage();\\n    }\\n    minAmount = (_amount * (HUNDRED_PERCENT - _lpSlippage)) / (HUNDRED_PERCENT);\\n  }\\n\\n  /**\\n   * @notice This function validates liquidity slippage from the called protocol\\n   * @param _amountA The amount of tokenA used by the protocol\\n   * @param _amountB The amount of tokenB used by the protocol\\n   * @param _priceA The price of tokenA\\n   * @param _priceB The price of tokenB\\n   * @param _lpSlippage The max slippage between tokenA and tokenB accepted\\n   */\\n  function _validateLPSlippage(\\n    uint _amountA,\\n    uint _amountB,\\n    uint _priceA,\\n    uint _priceB,\\n    uint _lpSlippage\\n  ) internal view {\\n    if (maxSlippage < _lpSlippage) {\\n      revert ErrorLibrary.InvalidLPSlippage();\\n    }\\n    uint decimal = 10 ** 18;\\n    /**\\n     *  amountA * priceA = amountB * priceB ( in ideal scenario )\\n     *  amountA/amountB - priceB/priceA = 0\\n     *  When the amount of either token is not fully accepted then the\\n     *  amountA and amountB wont be equal to 0 and that becomes our lpSlippage\\n     */\\n\\n    uint amountDivision = (_amountA * decimal) / (_amountB); // 18 decimals \\n    uint priceDivision = (_priceB * decimal) / (_priceA); // 18 decimals\\n    uint absoluteValue = 0;\\n    if (amountDivision > priceDivision) {\\n      absoluteValue = amountDivision - priceDivision; // 18 decimals\\n    } else {\\n      absoluteValue = priceDivision - amountDivision; // 18 decimals\\n    }\\n    uint256 percentageDifference = (absoluteValue * decimal) / priceDivision;\\n    if (percentageDifference * HUNDRED_PERCENT > (_lpSlippage * decimal)) {\\n      revert ErrorLibrary.InvalidAmount();\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/library/ErrorLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\n/**\\n * @title ErrorLibrary\\n * @author Velvet.Capital\\n * @notice This is a library contract including custom defined errors\\n */\\n\\nlibrary ErrorLibrary {\\n  error ContractPaused();\\n  /// @notice Thrown when caller is not rebalancer contract\\n  error CallerNotRebalancerContract();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerNotAssetManager();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerNotSuperAdmin();\\n  /// @notice Thrown when caller is not whitelist manager\\n  error CallerNotWhitelistManager();\\n  /// @notice Thrown when length of slippage array is not equal to tokens array\\n  error InvalidSlippageLength();\\n  /// @notice Thrown when length of tokens array is zero\\n  error InvalidLength();\\n  /// @notice Thrown when token is not permitted\\n  error TokenNotPermitted();\\n  /// @notice Thrown when user is not allowed to invest\\n  error UserNotAllowedToInvest();\\n  /// @notice Thrown when index token in not initialized\\n  error NotInitialized();\\n  /// @notice Thrown when investment amount is greater than or less than the set range\\n  error WrongInvestmentAmount(uint256 minInvestment, uint256 maxInvestment);\\n  /// @notice Thrown when swap amount is greater than BNB balance of the contract\\n  error NotEnoughBNB();\\n  /// @notice Thrown when the total sum of weights is not equal to 10000\\n  error InvalidWeights(uint256 totalWeight);\\n  /// @notice Thrown when balance is below set velvet min investment amount\\n  error BalanceCantBeBelowVelvetMinInvestAmount(uint256 minVelvetInvestment);\\n  /// @notice Thrown when caller is not holding underlying token amount being swapped\\n  error CallerNotHavingGivenTokenAmount();\\n  /// @notice Thrown when length of denorms array is not equal to tokens array\\n  error InvalidInitInput();\\n  /// @notice Thrown when the tokens are already initialized\\n  error AlreadyInitialized();\\n  /// @notice Thrown when the token is not whitelisted\\n  error TokenNotWhitelisted();\\n  /// @notice Thrown when denorms array length is zero\\n  error InvalidDenorms();\\n  /// @notice Thrown when token address being passed is zero\\n  error InvalidTokenAddress();\\n  /// @notice Thrown when token is not permitted\\n  error InvalidToken();\\n  /// @notice Thrown when token is not approved\\n  error TokenNotApproved();\\n  /// @notice Thrown when transfer is prohibited\\n  error Transferprohibited();\\n  /// @notice Thrown when transaction caller balance is below than token amount being invested\\n  error LowBalance();\\n  /// @notice Thrown when address is already approved\\n  error AddressAlreadyApproved();\\n  /// @notice Thrown when swap handler is not enabled inside token registry\\n  error SwapHandlerNotEnabled();\\n  /// @notice Thrown when swap amount is zero\\n  error ZeroBalanceAmount();\\n  /// @notice Thrown when caller is not index manager\\n  error CallerNotIndexManager();\\n  /// @notice Thrown when caller is not fee module contract\\n  error CallerNotFeeModule();\\n  /// @notice Thrown when lp balance is zero\\n  error LpBalanceZero();\\n  /// @notice Thrown when desired swap amount is greater than token balance of this contract\\n  error InvalidAmount();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInAlpacaProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountMustBeEqualToValue();\\n  /// @notice Thrown when the mint function returned 0 for success & 1 for failure\\n  error MintProcessFailed();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInApeSwap();\\n  /// @notice Thrown when the redeeming was success(0) or failure(1)\\n  error RedeemingCTokenFailed();\\n  /// @notice Thrown when native BNB is sent for any vault other than mooVenusBNB\\n  error PleaseDepositUnderlyingToken();\\n  /// @notice Thrown when redeem amount is greater than tokenBalance of protocol\\n  error NotEnoughBalanceInBeefyProtocol();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInBeefy();\\n  /// @notice Thrown when the deposit amount of underlying token A is more than contract balance\\n  error InsufficientTokenABalance();\\n  /// @notice Thrown when the deposit amount of underlying token B is more than contract balance\\n  error InsufficientTokenBBalance();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInBiSwapProtocol();\\n  //Not enough funds\\n  error InsufficientFunds(uint256 available, uint256 required);\\n  //Not enough eth for protocol fee\\n  error InsufficientFeeFunds(uint256 available, uint256 required);\\n  //Order success but amount 0\\n  error ZeroTokensSwapped();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInLiqeeProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountMustBeEqualToValuePassed();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInPancakeProtocol();\\n  /// @notice Thrown when Pid passed is not equal to Pid stored in Pid map\\n  error InvalidPID();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error InsufficientBalance();\\n  /// @notice Thrown when the redeem function returns 1 for fail & 0 for success\\n  error RedeemingFailed();\\n  /// @notice Thrown when the token passed in getUnderlying is not vToken\\n  error NotVToken();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInWombatProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountNotEqualToPassedValue();\\n  /// @notice Thrown when slippage value passed is greater than 100\\n  error SlippageCannotBeGreaterThan100();\\n  /// @notice Thrown when tokens are already staked\\n  error TokensStaked();\\n  /// @notice Thrown when contract is not paused\\n  error ContractNotPaused();\\n  /// @notice Thrown when offchain handler is not valid\\n  error OffHandlerNotValid();\\n  /// @notice Thrown when offchain handler is not enabled\\n  error OffHandlerNotEnabled();\\n  /// @notice Thrown when swapHandler is not enabled\\n  error SwaphandlerNotEnabled();\\n  /// @notice Thrown when account other than asset manager calls\\n  error OnlyAssetManagerCanCall();\\n  /// @notice Thrown when already redeemed\\n  error AlreadyRedeemed();\\n  /// @notice Thrown when contract is not paused\\n  error NotPaused();\\n  /// @notice Thrown when token is not index token\\n  error TokenNotIndexToken();\\n  /// @notice Thrown when swaphandler is invalid\\n  error SwapHandlerNotValid();\\n  /// @notice Thrown when token that will be bought is invalid\\n  error BuyTokenAddressNotValid();\\n  /// @notice Thrown when not redeemed\\n  error NotRedeemed();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerIsNotAssetManager();\\n  /// @notice Thrown when account other than asset manager is trying to pause\\n  error OnlyAssetManagerCanCallUnpause();\\n  /// @notice Thrown when trying to redeem token that is not staked\\n  error TokensNotStaked();\\n  /// @notice Thrown when account other than asset manager is trying to revert or unpause\\n  error FifteenMinutesNotExcedeed();\\n  /// @notice Thrown when swapping weight is zero\\n  error WeightNotGreaterThan0();\\n  /// @notice Thrown when dividing by zero\\n  error DivBy0Sumweight();\\n  /// @notice Thrown when lengths of array are not equal\\n  error LengthsDontMatch();\\n  /// @notice Thrown when contract is not paused\\n  error ContractIsNotPaused();\\n  /// @notice Thrown when set time period is not over\\n  error TimePeriodNotOver();\\n  /// @notice Thrown when trying to set any fee greater than max allowed fee\\n  error InvalidFee();\\n  /// @notice Thrown when zero address is passed for treasury\\n  error ZeroAddressTreasury();\\n  /// @notice Thrown when assetManagerFee or performaceFee is set zero\\n  error ZeroFee();\\n  /// @notice Thrown when trying to enable an already enabled handler\\n  error HandlerAlreadyEnabled();\\n  /// @notice Thrown when trying to disable an already disabled handler\\n  error HandlerAlreadyDisabled();\\n  /// @notice Thrown when zero is passed as address for oracle address\\n  error InvalidOracleAddress();\\n  /// @notice Thrown when zero is passed as address for handler address\\n  error InvalidHandlerAddress();\\n  /// @notice Thrown when token is not in price oracle\\n  error TokenNotInPriceOracle();\\n  /// @notice Thrown when address is not approved\\n  error AddressNotApproved();\\n  /// @notice Thrown when minInvest amount passed is less than minInvest amount set\\n  error InvalidMinInvestmentAmount();\\n  /// @notice Thrown when maxInvest amount passed is greater than minInvest amount set\\n  error InvalidMaxInvestmentAmount();\\n  /// @notice Thrown when zero address is being passed\\n  error InvalidAddress();\\n  /// @notice Thrown when caller is not the owner\\n  error CallerNotOwner();\\n  /// @notice Thrown when out asset address is zero\\n  error InvalidOutAsset();\\n  /// @notice Thrown when protocol is not paused\\n  error ProtocolNotPaused();\\n  /// @notice Thrown when protocol is paused\\n  error ProtocolIsPaused();\\n  /// @notice Thrown when proxy implementation is wrong\\n  error ImplementationNotCorrect();\\n  /// @notice Thrown when caller is not offChain contract\\n  error CallerNotOffChainContract();\\n  /// @notice Thrown when user has already redeemed tokens\\n  error TokenAlreadyRedeemed();\\n  /// @notice Thrown when user has not redeemed tokens\\n  error TokensNotRedeemed();\\n  /// @notice Thrown when user has entered wrong amount\\n  error InvalidSellAmount();\\n  /// @notice Thrown when trasnfer fails\\n  error WithdrawTransferFailed();\\n  /// @notice Thrown when caller is not having minter role\\n  error CallerNotMinter();\\n  /// @notice Thrown when caller is not handler contract\\n  error CallerNotHandlerContract();\\n  /// @notice Thrown when token is not enabled\\n  error TokenNotEnabled();\\n  /// @notice Thrown when index creation is paused\\n  error IndexCreationIsPause();\\n  /// @notice Thrown denorm value sent is zero\\n  error ZeroDenormValue();\\n  /// @notice Thrown when asset manager is trying to input token which already exist\\n  error TokenAlreadyExist();\\n  /// @notice Thrown when cool down period is not passed\\n  error CoolDownPeriodNotPassed();\\n  /// @notice Thrown When Buy And Sell Token Are Same\\n  error BuyAndSellTokenAreSame();\\n  /// @notice Throws arrow when token is not a reward token\\n  error NotRewardToken();\\n  /// @notice Throws arrow when MetaAggregator Swap Failed\\n  error SwapFailed();\\n  /// @notice Throws arrow when Token is Not  Primary\\n  error NotPrimaryToken();\\n  /// @notice Throws when the setup is failed in gnosis\\n  error ModuleNotInitialised();\\n  /// @notice Throws when threshold is more than owner length\\n  error InvalidThresholdLength();\\n  /// @notice Throws when no owner address is passed while fund creation\\n  error NoOwnerPassed();\\n  /// @notice Throws when length of underlying token is greater than 1\\n  error InvalidTokenLength();\\n  /// @notice Throws when already an operation is taking place and another operation is called\\n  error AlreadyOngoingOperation();\\n  /// @notice Throws when wrong function is executed for revert offchain fund\\n  error InvalidExecution();\\n  /// @notice Throws when Final value after investment is zero\\n  error ZeroFinalInvestmentValue();\\n  /// @notice Throws when token amount after swap / token amount to be minted comes out as zero\\n  error ZeroTokenAmount();\\n  /// @notice Throws eth transfer failed\\n  error ETHTransferFailed();\\n  /// @notice Thorws when the caller does not have a default admin role\\n  error CallerNotAdmin();\\n  /// @notice Throws when buyAmount is not correct in offchainIndexSwap\\n  error InvalidBuyValues();\\n  /// @notice Throws when token is not primary\\n  error TokenNotPrimary();\\n  /// @notice Throws when tokenOut during withdraw is not permitted in the asset manager config\\n  error _tokenOutNotPermitted();\\n  /// @notice Throws when token balance is too small to be included in index\\n  error BalanceTooSmall();\\n  /// @notice Throws when a public fund is tried to made transferable only to whitelisted addresses\\n  error PublicFundToWhitelistedNotAllowed();\\n  /// @notice Throws when list input by user is invalid (meta aggregator)\\n  error InvalidInputTokenList();\\n  /// @notice Generic call failed error\\n  error CallFailed();\\n  /// @notice Generic transfer failed error\\n  error TransferFailed();\\n  /// @notice Throws when incorrect token amount is encountered during offchain/onchain investment\\n  error IncorrectInvestmentTokenAmount();\\n  /// @notice Throws when final invested amount after slippage is 0\\n  error ZeroInvestedAmountAfterSlippage();\\n  /// @notice Throws when the slippage trying to be set is in incorrect range\\n  error IncorrectSlippageRange();\\n  /// @notice Throws when invalid LP slippage is passed\\n  error InvalidLPSlippage();\\n  /// @notice Throws when invalid slippage for swapping is passed\\n  error InvalidSlippage();\\n  /// @notice Throws when msg.value is less than the amount passed into the handler\\n  error WrongNativeValuePassed();\\n  /// @notice Throws when there is an overflow during muldiv full math operation\\n  error FULLDIV_OVERFLOW();\\n  /// @notice Throws when the oracle price is not updated under set timeout\\n  error PriceOracleExpired();\\n  /// @notice Throws when the oracle price is returned 0\\n  error PriceOracleInvalid();\\n  /// @notice Throws when the initToken or updateTokenList function of IndexSwap is having more tokens than set by the Registry\\n  error TokenCountOutOfLimit(uint256 limit);\\n  /// @notice Throws when the array lenghts don't match for adding price feed or enabling tokens\\n  error IncorrectArrayLength();\\n  /// @notice Common Reentrancy error for IndexSwap and IndexSwapOffChain\\n  error ReentrancyGuardReentrantCall();\\n  /// @notice Throws when user calls updateFees function before proposing a new fee\\n  error NoNewFeeSet();\\n  /// @notice Throws when token is not ETH\\n  error TokenNotETH();\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {AggregatorV2V3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\n\\ninterface IPriceOracle {\\n  function WETH() external returns(address);\\n\\n  function _addFeed(address base, address quote, AggregatorV2V3Interface aggregator) external;\\n\\n  function decimals(address base, address quote) external view returns (uint8);\\n\\n  function latestRoundData(address base, address quote) external view returns (int256);\\n\\n  function getUsdEthPrice(uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function getEthUsdPrice(uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function getPrice(address base, address quote) external view returns (int256);\\n\\n  function getPriceForAmount(address token, uint256 amount, bool ethPath) external view returns (uint256 amountOut);\\n\\n  function getPriceForTokenAmount(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amount\\n  ) external view returns (uint256 amountOut);\\n\\n  function getPriceTokenUSD18Decimals(address _base, uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function getPriceForOneTokenInUSD(address _base) external view returns (uint256 amountOut);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpHandlerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IncorrectSlippageRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientTokenABalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientTokenBBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughBalanceInBeefy\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"AddOrUpdateProtocolSlippage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWETH\",\"type\":\"bool\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountProvided\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"VELVET_ADDED_LIQUIDITY\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityProvided\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"name\":\"VELVET_REMOVE_LIQUIDITY\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HUNDRED_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"addOrUpdateProtocolSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mooLpAsset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_lpSlippage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"encodeData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getClaimTokenCalldata\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getTokenBalanceUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mooLpAsset\",\"type\":\"address\"}],\"name\":\"getUnderlying\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getUnderlyingBalance\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpSlippage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isWETH\",\"type\":\"bool\"}],\"internalType\":\"struct FunctionParameters.RedeemData\",\"name\":\"inputData\",\"type\":\"tuple\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BeefyLPHandler", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000026ae500edce7c7a9f00007fcef026062e10e9fe1000000000000000000000000c2f2bf0c228714d038c2495343224c0d9199cc82", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}