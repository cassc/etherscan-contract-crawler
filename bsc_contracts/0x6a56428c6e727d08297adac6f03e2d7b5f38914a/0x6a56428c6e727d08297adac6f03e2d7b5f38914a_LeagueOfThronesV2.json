{"SourceCode": "// Sources flattened with hardhat v2.13.0 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.8.2\r\n\r\n// \r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.8.2\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.8.2\r\n\r\n// \r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.8.2\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/math/Math.sol@v4.8.2\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10**64) {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32) {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16) {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8) {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4) {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2) {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.8.2\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.8.2\r\n\r\n// \r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/LeagueOfThronesV2.sol\r\n\r\n// \r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\nenum SeasonStatus { Invalid, WaitForNTF ,Pending, End }\r\n\r\nenum MappingStatus { Invalid, Valid }\r\n\r\n\r\nstruct ExtraGeneralIds {\r\n    uint256[] generalIds;\r\n    MappingStatus status;\r\n}\r\n\r\n//union Record\r\nstruct UnionRecord{\r\n    address[] playerAddresses;\r\n    uint256 unionId;\r\n    mapping(address => ExtraGeneralIds) playerExtraGeneralIds;\r\n    MappingStatus status;\r\n}\r\n\r\n\r\n//season record\r\nstruct SeasonRecord{\r\n    mapping(uint256 => UnionRecord) unionRecords;\r\n    mapping(address => uint256) unionIdMapping;\r\n    mapping(address => uint256) unionRewardRecord;\r\n    mapping(address => uint256) gloryRewardRecord;\r\n    mapping(address => uint256) rechargeRecord;\r\n    MappingStatus rechargeStatus;\r\n    address rechargeAddress;\r\n    uint256 sumPlayers;\r\n    address ntf1ContractAddress;\r\n    address ntf2ContractAddress;\r\n    address rewardAddress;\r\n    uint256 playerLimit;\r\n    uint256 reward1Amount;\r\n    uint256 reward2Amount;\r\n    uint256 sumRecharge;\r\n    uint256[] rankConfigFromTo;\r\n    uint256[] rankConfigValue;\r\n    //reservation open ready end\r\n    uint256[] seasonTimeConfig;\r\n    SeasonStatus seasonStatus;\r\n    uint256 maxUnionDiffNum;\r\n\r\n}\r\n\r\nstruct SeaSonInfoResult{\r\n    uint256 unionId;\r\n    uint256[] generalIds;\r\n}\r\n\r\nstruct SeasonStatusResult{\r\n    uint256 sumPlayerNum;\r\n    uint256[] unionsPlayerNum;\r\n    uint256 maxUnionDiffNum;\r\n}\r\n\r\ncontract LeagueOfThronesV2 is Ownable{\r\n\r\n    event signUpInfo( string seasonId, address player, uint256 unionId, uint256[] extraGeneralIds,uint256 []originNFTIds,uint256 originUnionId);\r\n    event startSeasonInfo( string seasonId, uint256 playerLimit, address rewardAddress, uint256 rewardAmount1, uint256 rewardAmount2, uint256[] rankConfigFromTo, uint256[] rankConfigValue, uint256[] seasonTimeConfig);\r\n    event endSeasonInfo( string seasonId, uint256 unionId, address[] playerAddresses, uint256[] glorys, uint256 unionSumGlory);\r\n    event sendRankRewardInfo( string seasonId, address player, uint256 rank, uint256 amount);\r\n    event sendUnionRewardInfo( string seasonId, address player, uint256 glory, uint256 amount);\r\n    event rechargeInfo( string seasonId, address player, uint256 rechargeId,uint256 amount, uint256 totalAmount);\r\n    mapping( string => SeasonRecord) public seasonRecords;\r\n    string public nowSeasonId;\r\n\r\n    constructor() public onlyOwner{\r\n        nowSeasonId = \"\";\r\n    }\r\n\r\n    //start season and transfer reward to contract\r\n    function startSeason(\r\n        string memory seasonId,\r\n        uint256 playerLimit,\r\n        address rewardAddress,\r\n        uint256 rewardAmount1, \r\n        uint256 rewardAmount2, \r\n        uint256[] memory rankConfigFromTo,\r\n        uint256[] memory rankConfigValue,\r\n        uint256[] memory seasonTimeConfig,\r\n        uint256 maxUnionDiffNum\r\n        ) external onlyOwner payable {\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus == SeasonStatus.Invalid, \"Season can not start repeat\");\r\n        require(seasonTimeConfig.length == 4, \"time config length error\" );\r\n        require(maxUnionDiffNum > 0, \"maxUnionDiffNum must above zero\" );\r\n\r\n        uint256 rewordAmount = rewardAmount1 + rewardAmount2;\r\n        //BSC version modify ,no need to pre transfer\r\n        if (false) {\r\n            if(rewardAddress == address(0x0)){\r\n                require( msg.value == rewordAmount, \"Check the ETH amount\" );\r\n            }\r\n            else{\r\n                IERC20 token = IERC20(rewardAddress);\r\n                uint256 allowance = token.allowance(msg.sender, address(this));\r\n                require(allowance >= rewordAmount, \"Check the token allowance\");\r\n                token.transferFrom(msg.sender, address(this), rewordAmount);\r\n            }\r\n        }\r\n\r\n\r\n        sRecord.seasonStatus = SeasonStatus.WaitForNTF;\r\n        sRecord.rewardAddress = rewardAddress;\r\n        sRecord.reward1Amount = rewardAmount1;\r\n        sRecord.reward2Amount = rewardAmount2;\r\n        sRecord.playerLimit = playerLimit;\r\n        sRecord.maxUnionDiffNum = maxUnionDiffNum;\r\n        require(rankConfigFromTo.length == rankConfigValue.length * 2, \"rewardConfig length error\");\r\n        uint256 sumReward = 0;\r\n        bool indexRight = true;\r\n        uint256 lastEnd = 0;\r\n        for(uint256 i = 0; i < rankConfigValue.length; i++){\r\n            if(rankConfigFromTo[i * 2] != lastEnd + 1){\r\n                indexRight = false;\r\n                break;\r\n            }\r\n            lastEnd = rankConfigFromTo[i * 2 + 1];\r\n            sumReward += ((rankConfigFromTo[i * 2 + 1] - rankConfigFromTo[i * 2 ] + 1) * rankConfigValue[i]);\r\n        }\r\n        require(indexRight && sumReward == rewardAmount2, \"reward config error\");\r\n        sRecord.rankConfigFromTo = rankConfigFromTo;\r\n        sRecord.rankConfigValue = rankConfigValue;\r\n        sRecord.seasonTimeConfig = seasonTimeConfig;\r\n        emit startSeasonInfo(seasonId, playerLimit, rewardAddress, rewardAmount1, rewardAmount2, rankConfigFromTo, rankConfigValue, seasonTimeConfig);\r\n    }\r\n\r\n    //set nft address of season\r\n    function setNFTAddress(string memory seasonId, address ntf1Address, address ntf2Address) external onlyOwner {\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus == SeasonStatus.WaitForNTF, \"Season Haven't begin or NTF have set\");\r\n        sRecord.seasonStatus = SeasonStatus.Pending;\r\n        sRecord.ntf1ContractAddress = ntf1Address;\r\n        sRecord.ntf2ContractAddress = ntf2Address;\r\n        sRecord.seasonStatus = SeasonStatus.Pending;\r\n    }\r\n\r\n    function getNFTAddresses(string memory seasonId ) public view returns (address[] memory){\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        address[] memory addresses = new address[](2);\r\n        addresses[0] = sRecord.ntf1ContractAddress;\r\n        addresses[1] = sRecord.ntf2ContractAddress;\r\n        return addresses;\r\n    }\r\n\r\n    function random(uint number) public view returns(uint) {\r\n        return uint(keccak256(abi.encodePacked(block.timestamp,block.difficulty,  \r\n            msg.sender))) % number;\r\n    }\r\n\r\n\r\n    // params: \r\n    //  unionId:  0 for random\r\n    function signUpGame(string memory seasonId,uint256 unionId, uint256 ntf1TokenId, uint256 ntf2TokenId) external{\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus == SeasonStatus.Pending, \"Season Status Error\");\r\n        require( block.timestamp >= sRecord.seasonTimeConfig[0] && block.timestamp <= sRecord.seasonTimeConfig[3], \"It is not signUp time now\");\r\n        require( sRecord.sumPlayers < sRecord.playerLimit, \"the number of players has reached the limit\");\r\n        require( unionId >= 0 && unionId <= 4, \"unionId error\");\r\n\r\n\r\n        // Record original unionId to detect whether the player select random unionId\r\n        uint256 orginUnionId = unionId;\r\n        uint256[] memory originNFTIds = new uint256[](2);\r\n        originNFTIds[0] = ntf1TokenId;\r\n        originNFTIds[1] = ntf2TokenId;\r\n\r\n\r\n\r\n\r\n        // find wheather player has signUp and get union's player number\r\n        uint256[] memory unionPlayerNum = new uint256[](5);\r\n        uint256 minumUnionPlayerNum = sRecord.playerLimit;\r\n\r\n        bool hasSignUp = false;\r\n        for( uint i = 1 ; i <= 4 ; i ++ ){\r\n            UnionRecord storage unionRecord = sRecord.unionRecords[i];\r\n            if(unionRecord.status != MappingStatus.Invalid ){\r\n                unionPlayerNum[i] = unionRecord.playerAddresses.length;\r\n                ExtraGeneralIds storage extraIds =  unionRecord.playerExtraGeneralIds[msg.sender];\r\n                if(extraIds.status == MappingStatus.Valid){\r\n                    hasSignUp = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if(unionPlayerNum[i] < minumUnionPlayerNum){\r\n                minumUnionPlayerNum = unionPlayerNum[i];\r\n            }\r\n        }\r\n        require(hasSignUp == false , \"player has signUp\");\r\n        // random unionId\r\n        if (unionId!=0){\r\n            // unionId maxUnionDiffNum check\r\n            require(unionPlayerNum[unionId] - minumUnionPlayerNum < sRecord.maxUnionDiffNum, \"unionId maxUnionDiffNum check error\");\r\n        }else{\r\n            // random unionId of which player number is not above maxUnionDiffNum + currentUnionPlayerNum\r\n            uint256[] memory unionIdsList = new uint256[](4);\r\n            uint256 unionIdsListLen = 0;\r\n            for( uint i = 1 ; i <= 4 ; i ++ ){\r\n                if(unionPlayerNum[i] - minumUnionPlayerNum < sRecord.maxUnionDiffNum){\r\n                    // add to unionIdsList\r\n                    unionIdsList[unionIdsListLen] = i;\r\n                    unionIdsListLen ++ ;\r\n                }\r\n            }\r\n\r\n            // random unionId by block.timestamp\r\n            unionId = unionIdsList[uint(keccak256(abi.encodePacked(block.timestamp,block.difficulty, msg.sender))) % unionIdsListLen];\r\n        }\r\n\r\n        // update season record\r\n        sRecord.sumPlayers ++ ;\r\n        sRecord.unionIdMapping[msg.sender] = unionId;\r\n        UnionRecord storage unionRecord = sRecord.unionRecords[unionId];\r\n        if(unionRecord.status == MappingStatus.Invalid){\r\n            //gen union record\r\n            unionRecord.status = MappingStatus.Valid;\r\n            unionRecord.playerAddresses = new address[](0);\r\n        }\r\n        unionRecord.playerAddresses.push(msg.sender);\r\n\r\n        //Random extra general\r\n        IERC721 ntf1Contract = IERC721(sRecord.ntf1ContractAddress);\r\n        IERC721 ntf2Contract = IERC721(sRecord.ntf2ContractAddress);\r\n        ExtraGeneralIds storage extraIds = unionRecord.playerExtraGeneralIds[msg.sender];\r\n        extraIds.generalIds = new uint256[](0);\r\n        extraIds.status = MappingStatus.Valid;\r\n        try ntf1Contract.ownerOf(ntf1TokenId) returns(address owner){\r\n            if(owner == msg.sender){\r\n                extraIds.generalIds.push(random(4) + 7);\r\n            }\r\n        }\r\n        catch{\r\n\r\n        }\r\n        try ntf2Contract.ownerOf(ntf2TokenId) returns(address owner){\r\n            if(owner == msg.sender){\r\n                extraIds.generalIds.push(random(4) + 11);\r\n            }\r\n        }\r\n        catch{\r\n            \r\n        }\r\n        emit signUpInfo(seasonId , msg.sender, unionId, extraIds.generalIds, originNFTIds, orginUnionId);\r\n    }\r\n\r\n    function setRechargeToken(string memory seasonId, address tokenAddress) public onlyOwner {\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus == SeasonStatus.Pending, \"Season Status Error\");\r\n        require(sRecord.rechargeStatus == MappingStatus.Invalid, \"recharge token have set\");\r\n        sRecord.rechargeStatus = MappingStatus.Valid;\r\n        sRecord.rechargeAddress = tokenAddress;\r\n    }\r\n\r\n    function getRechargeToken(string memory seasonId) public view returns( address ) {\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus == SeasonStatus.Pending, \"Season Status Error\");\r\n        require(sRecord.rechargeStatus == MappingStatus.Valid, \"recharge token have not set\");\r\n        return sRecord.rechargeAddress;\r\n    }\r\n\r\n    function recharge(string memory seasonId, uint256 rechargeId ,uint256 amount) public payable {\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus == SeasonStatus.Pending, \"Season Status Error\");\r\n        require(sRecord.rechargeStatus == MappingStatus.Valid, \"recharge token have not set\");\r\n        // bool hasSignUp = false;\r\n        // for( uint i = 1 ; i <= 4 ; i ++ ){\r\n        //     UnionRecord storage unionRecord = sRecord.unionRecords[i];\r\n        //     if(unionRecord.status == MappingStatus.Invalid ){\r\n        //         continue;\r\n        //     }\r\n        //     else{\r\n        //         ExtraGeneralIds storage extraIds =  unionRecord.playerExtraGeneralIds[msg.sender];\r\n        //         if(extraIds.status == MappingStatus.Valid){\r\n        //             hasSignUp = true;\r\n        //             break;\r\n        //         }\r\n        //     }\r\n        // }\r\n        // require(hasSignUp == true , \"player have not signUp\");\r\n        if(sRecord.rechargeAddress == address(0x0)){\r\n            sRecord.rechargeRecord[msg.sender] += msg.value;\r\n            sRecord.sumRecharge += msg.value;\r\n            emit rechargeInfo(seasonId, msg.sender, rechargeId, msg.value, sRecord.rechargeRecord[msg.sender]);\r\n        }\r\n        else{\r\n            IERC20 token = IERC20(sRecord.rechargeAddress);\r\n            uint256 allowance = token.allowance(msg.sender, address(this));\r\n            require(allowance >= amount, \"Check the token allowance\");\r\n            token.transferFrom(msg.sender, address(this), amount);\r\n            sRecord.rechargeRecord[msg.sender] += amount;\r\n            sRecord.sumRecharge += amount;\r\n            emit rechargeInfo(seasonId, msg.sender, rechargeId, amount, sRecord.rechargeRecord[msg.sender]);\r\n        }\r\n    }\r\n\r\n    function getRechargeInfo( string memory seasonId, address player) public view returns (uint256, uint256){\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus != SeasonStatus.Invalid, \"Season is not exist\");\r\n        return (sRecord.rechargeRecord[player], sRecord.sumRecharge);\r\n    }\r\n\r\n\r\n    function getSeasonStatus( string memory seasonId ) public view returns ( SeasonStatusResult memory ){\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus == SeasonStatus.Pending, \"Season Status Error\");\r\n        SeasonStatusResult memory re = SeasonStatusResult( sRecord.sumPlayers , new uint256[](4),sRecord.maxUnionDiffNum);\r\n        for( uint i = 1 ; i <= 4 ; i ++ ){\r\n            UnionRecord storage unionRecord = sRecord.unionRecords[i];\r\n            if(unionRecord.status == MappingStatus.Invalid ){\r\n                re.unionsPlayerNum[i-1] = 0;\r\n            }\r\n            else{\r\n                re.unionsPlayerNum[i-1] = unionRecord.playerAddresses.length;\r\n            }\r\n        }\r\n        return re;\r\n    } \r\n\r\n    function getSignUpInfo( string memory seasonId, address playerAddress) public view returns ( SeaSonInfoResult memory){\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus != SeasonStatus.Invalid, \"Season Status Error\");\r\n        SeaSonInfoResult memory re = SeaSonInfoResult(0, new uint256[](0));\r\n        for( uint i = 1 ; i <= 4 ; i ++ ){\r\n            UnionRecord storage unionRecord = sRecord.unionRecords[i];\r\n            if(unionRecord.status == MappingStatus.Invalid ){\r\n                continue;\r\n            }\r\n            else{\r\n                ExtraGeneralIds storage extraIds = unionRecord.playerExtraGeneralIds[playerAddress];\r\n                if(extraIds.status == MappingStatus.Invalid){\r\n                    continue;\r\n                }\r\n                re.unionId = i;\r\n                re.generalIds = extraIds.generalIds;\r\n            }\r\n        }\r\n        return re;\r\n    }\r\n\r\n    function endSeason(  string memory seasonId, uint256 unionId, address[] memory playerAddresses, uint256[] memory glorys, uint256 unionSumGlory) external onlyOwner {\r\n        SeasonRecord storage sRecord = seasonRecords[seasonId];\r\n        require(sRecord.seasonStatus == SeasonStatus.Pending,  \"Season Status Error\");\r\n        require(playerAddresses.length == glorys.length, \"input array length do not equal\");\r\n        uint fromToIndex = 0;\r\n        uint rankMax = sRecord.rankConfigFromTo[sRecord.rankConfigFromTo.length - 1];\r\n        //IERC20 token = IERC20(sRecord.rewardAddress);\r\n        for(uint i = 0; i < playerAddresses.length; i++ ){  \r\n            address playerAddress = playerAddresses[i];\r\n            uint256 glory = glorys[i];\r\n            if(sRecord.unionIdMapping[playerAddress] == unionId){\r\n               uint256 amount = glory * sRecord.reward1Amount / unionSumGlory;\r\n               sRecord.unionRewardRecord[playerAddress] = amount; \r\n               transferReward(sRecord.rewardAddress, playerAddress, amount);\r\n               //if( token.transfer(playerAddress, amount)){\r\n               emit sendUnionRewardInfo(seasonId, playerAddress, glory, amount);\r\n               //}\r\n            }\r\n            if(i < rankMax){\r\n               uint256 to = sRecord.rankConfigFromTo[fromToIndex * 2 + 1];\r\n               if( i + 1 > to ){\r\n                  fromToIndex += 1;\r\n               }\r\n               uint256 amount = sRecord.rankConfigValue[fromToIndex];\r\n               sRecord.gloryRewardRecord[playerAddress] = amount;\r\n               transferReward(sRecord.rewardAddress, playerAddress, amount);\r\n               //if( token.transfer(playerAddress, amount)){\r\n               emit sendRankRewardInfo(seasonId, playerAddress, i + 1, amount);\r\n               //}\r\n            }\r\n        }\r\n        emit endSeasonInfo( seasonId,  unionId,  playerAddresses, glorys, unionSumGlory);\r\n    }\r\n\r\n    function withdraw( address tokenAddress, uint256 amount) external  onlyOwner{\r\n        if(tokenAddress == address(0x0)){\r\n            require(address(this).balance >=  amount, \"balance is not enough\");\r\n            payable(msg.sender).transfer(amount);\r\n        }\r\n        else{\r\n            IERC20 token = IERC20(tokenAddress);\r\n            uint256 balance = token.balanceOf(address(this));\r\n            require(balance >= amount, \"balance is not enough\");\r\n            token.transfer(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    function transferReward(address rewardAddress, address toAddress, uint256 amount) internal {\r\n        if(rewardAddress == address(0x0)){\r\n            require(address(this).balance >=  amount, \"balance is not enough\");\r\n            payable(toAddress).transfer(amount);\r\n        }\r\n        else{\r\n            IERC20 token = IERC20(rewardAddress);\r\n            uint256 balance = token.balanceOf(address(this));\r\n            require(balance >= amount, \"balance is not enough\");\r\n            token.transfer(toAddress, amount);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"playerAddresses\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"glorys\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unionSumGlory\",\"type\":\"uint256\"}],\"name\":\"endSeasonInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rechargeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"rechargeInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rank\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendRankRewardInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"glory\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendUnionRewardInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"extraGeneralIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"originNFTIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originUnionId\",\"type\":\"uint256\"}],\"name\":\"signUpInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"rankConfigFromTo\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"rankConfigValue\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"seasonTimeConfig\",\"type\":\"uint256[]\"}],\"name\":\"startSeasonInfo\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"unionId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"playerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"glorys\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"unionSumGlory\",\"type\":\"uint256\"}],\"name\":\"endSeason\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"}],\"name\":\"getNFTAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getRechargeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"}],\"name\":\"getRechargeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"}],\"name\":\"getSeasonStatus\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"sumPlayerNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"unionsPlayerNum\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxUnionDiffNum\",\"type\":\"uint256\"}],\"internalType\":\"struct SeasonStatusResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"getSignUpInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"unionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"generalIds\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SeaSonInfoResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nowSeasonId\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"rechargeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recharge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"seasonRecords\",\"outputs\":[{\"internalType\":\"enum MappingStatus\",\"name\":\"rechargeStatus\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"rechargeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sumPlayers\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ntf1ContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ntf2ContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"playerLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward1Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward2Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sumRecharge\",\"type\":\"uint256\"},{\"internalType\":\"enum SeasonStatus\",\"name\":\"seasonStatus\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"maxUnionDiffNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"ntf1Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ntf2Address\",\"type\":\"address\"}],\"name\":\"setNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setRechargeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"unionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ntf1TokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ntf2TokenId\",\"type\":\"uint256\"}],\"name\":\"signUpGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seasonId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"playerLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount2\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"rankConfigFromTo\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rankConfigValue\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"seasonTimeConfig\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxUnionDiffNum\",\"type\":\"uint256\"}],\"name\":\"startSeason\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LeagueOfThronesV2", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a99aa4676ac09739243311ce2dfe8ef98574ea6eaf77e1b0215c8c7e77efc00a"}