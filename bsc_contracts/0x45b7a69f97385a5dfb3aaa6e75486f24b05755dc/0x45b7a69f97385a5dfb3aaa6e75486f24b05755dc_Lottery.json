{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-04-28\r\n*/\r\n\r\n/**\r\n *Submitted for verification at BscScan.com on 2023-04-28\r\n*/\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.8.18;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Lottery is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct _player {\r\n        address[] players;\r\n        uint256 winningamount;\r\n        uint256 winners;\r\n        uint256 time;\r\n        uint256 currenttime;\r\n        uint256 received_entry;\r\n        uint256 total_entry;\r\n        uint256 multiple_entry;\r\n        address[] final_winners;\r\n        uint256[] amount_winners;\r\n        uint256[] winners_date;\r\n    }\r\n    struct lottery_info {\r\n        uint256 lottery_entries;\r\n        uint256 lottery_invested_amount;\r\n        uint256 lottery_completed;\r\n        uint256 lottery_reward;\r\n    }\r\n    struct _winer {\r\n        uint256 time;\r\n        address[] latest_winners;\r\n        uint256[] latest_winer_amount;\r\n    }\r\n\r\n    address private winner;\r\n\r\n    event NewEntry(address count);\r\n    event WinnerSelected(address winner, uint256 amount);\r\n\r\n    mapping(address => uint256) public winning_amount;\r\n    mapping(uint256 => mapping(address => uint256)) public playerentry;\r\n    mapping(address => uint256) public previouslevel;\r\n    mapping(uint256 => _player) public fin;\r\n    mapping(uint256 => _winer) public fin2;\r\n    mapping(uint256 => lottery_info) public lottey_detail;\r\n\r\n    uint256 public total_entries;\r\n    uint256 public total_invested_amount;\r\n    uint256 public total_reward;\r\n    uint256 public total_lottery_completed;\r\n    uint256 min_amount = 1e18;\r\n    uint256 public current_time = block.timestamp;\r\n\r\n    IBEP20 public Token;\r\n\r\n    constructor(IBEP20 _Token) {\r\n        Token = _Token;\r\n        startTime();\r\n    }\r\n\r\n    function change_prise(uint256 prise) public onlyOwner {\r\n        min_amount = prise;\r\n    }\r\n\r\n    function set_time(uint256 _level, uint256 __time) public onlyOwner {\r\n        fin[_level].time = __time;\r\n    }\r\n\r\n    function set_winningamount(uint256 _level, uint256 _amount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        fin[_level].winningamount = _amount;\r\n    }\r\n\r\n    function set_winners(uint256 _level, uint256 winners) public onlyOwner {\r\n        fin[_level].winners = winners;\r\n    }\r\n\r\n    function set_totalentry(uint256 _level, uint256 entry) public onlyOwner {\r\n        fin[_level].total_entry = entry;\r\n    }\r\n\r\n    function set_multipleentry(uint256 _level, uint256 multipleentry)\r\n        public\r\n        onlyOwner\r\n    {\r\n        fin[_level].multiple_entry = multipleentry;\r\n    }\r\n\r\n    function plans(uint256 _level, uint256 _entry) public {\r\n        delete fin2[_level].latest_winners;\r\n        delete fin2[_level].latest_winer_amount;\r\n        total_entries = total_entries.add(_entry);\r\n        uint256 amount = _entry.mul(1e18);\r\n        lottey_detail[_level].lottery_entries = lottey_detail[_level]\r\n            .lottery_entries\r\n            .add(_entry);\r\n        lottey_detail[_level].lottery_invested_amount = lottey_detail[_level]\r\n            .lottery_invested_amount\r\n            .add(amount);\r\n        total_invested_amount = total_invested_amount.add(amount);\r\n        fin[_level].currenttime = block.timestamp;\r\n        require(\r\n            fin[_level].received_entry <= fin[_level].total_entry,\r\n            \"total entries exceeded\"\r\n        );\r\n        fin[_level].received_entry = fin[_level].received_entry.add(_entry);\r\n        require(\r\n            playerentry[_level][msg.sender] < fin[_level].multiple_entry,\r\n            \"multiple entries exceeded\"\r\n        );\r\n        playerentry[_level][msg.sender] = playerentry[_level][msg.sender].add(\r\n            _entry\r\n        );\r\n        Token.transferFrom(msg.sender, address(this), amount);\r\n        for (uint256 i; i <= _entry; i++) {\r\n            fin[_level].players.push(msg.sender);\r\n        }\r\n    }\r\n\r\n    function showWinners(uint256 _level)\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory\r\n        )\r\n    {\r\n        fin[_level].final_winners;\r\n        fin[_level].amount_winners;\r\n        fin[_level].winners_date;\r\n\r\n        return (\r\n            fin[_level].final_winners,\r\n            fin[_level].amount_winners,\r\n            fin[_level].winners_date\r\n        );\r\n    }\r\n\r\n    function show_latest_winners(uint256 _level)\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            uint256[] memory,\r\n            uint256\r\n        )\r\n    {\r\n        fin2[_level].latest_winners;\r\n        fin2[_level].latest_winer_amount;\r\n        fin2[_level].time;\r\n\r\n        return (\r\n            fin2[_level].latest_winners,\r\n            fin2[_level].latest_winer_amount,\r\n            fin2[_level].time\r\n        );\r\n    }\r\n\r\n    function amount_everywinner(uint256 _level)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 newwinner = (fin[_level].received_entry)\r\n            .mul(fin[_level].winners)\r\n            .div(fin[_level].total_entry);\r\n        if (newwinner == fin[_level].winners) {\r\n            uint256 _amount = fin[_level].winners * fin[_level].winningamount;\r\n            uint256 _amounteverywinner = (_amount) / fin[_level].winners;\r\n            return (newwinner, _amount, _amounteverywinner);\r\n        } else if (newwinner == 0) {\r\n            uint256 _amount = min_amount;\r\n            uint256 _amounteverywinner = (_amount);\r\n            return (newwinner, _amount, _amounteverywinner);\r\n        } else {\r\n            uint256 _newwinner = (newwinner);\r\n            uint256 _amount = _newwinner * fin[_level].winningamount;\r\n            uint256 _amounteverywinner = (_amount) / _newwinner;\r\n            return (_newwinner, _amount, _amounteverywinner);\r\n        }\r\n    }\r\n\r\n    function randomNumberSelector(uint256 _level)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        block.timestamp,\r\n                        block.prevrandao,\r\n                        fin[_level].players\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    function startTime() internal {\r\n        fin[1].time = block.timestamp + 7 days;\r\n        fin[1].winningamount = 10e18;\r\n        fin[1].winners = 50;\r\n        fin[1].total_entry = 1000;\r\n        fin[1].multiple_entry = 10;\r\n\r\n        fin[2].time = block.timestamp + 7 days;\r\n        fin[2].winningamount = 20e18;\r\n        fin[2].winners = 25;\r\n        fin[2].total_entry = 1000;\r\n        fin[2].multiple_entry = 10;\r\n\r\n        fin[3].time = block.timestamp + 7 days;\r\n        fin[3].winningamount = 50e18;\r\n        fin[3].winners = 10;\r\n        fin[3].total_entry = 1000;\r\n        fin[3].multiple_entry = 10;\r\n\r\n        fin[4].time = block.timestamp + 14 days;\r\n        fin[4].winningamount = 100e18;\r\n        fin[4].winners = 10;\r\n        fin[4].total_entry = 2000;\r\n        fin[4].multiple_entry = 20;\r\n\r\n        fin[5].time = block.timestamp + 21 days;\r\n        fin[5].winningamount = 250e18;\r\n        fin[5].winners = 10;\r\n        fin[5].total_entry = 5000;\r\n        fin[5].multiple_entry = 50;\r\n\r\n        fin[6].time = block.timestamp + 21 days;\r\n        fin[6].winningamount = 500e18;\r\n        fin[6].winners = 5;\r\n        fin[6].total_entry = 5000;\r\n        fin[6].multiple_entry = 50;\r\n\r\n        fin[7].time = block.timestamp + 30 days;\r\n        fin[7].winningamount = 1000e18;\r\n        fin[7].winners = 4;\r\n        fin[7].total_entry = 8000;\r\n        fin[7].multiple_entry = 80;\r\n\r\n        fin[8].time = block.timestamp + 35 days;\r\n        fin[8].winningamount = 2500e18;\r\n        fin[8].winners = 2;\r\n        fin[8].total_entry = 10000;\r\n        fin[8].multiple_entry = 100;\r\n\r\n        fin[9].time = block.timestamp + 50 days;\r\n        fin[9].winningamount = 5000e18;\r\n        fin[9].winners = 2;\r\n        fin[9].total_entry = 20000;\r\n        fin[9].multiple_entry = 200;\r\n\r\n        fin[10].time = block.timestamp + 60 days;\r\n        fin[10].winningamount = 10000e18;\r\n        fin[10].winners = 2;\r\n        fin[10].total_entry = 40000;\r\n        fin[10].multiple_entry = 400;\r\n\r\n        fin[11].time = block.timestamp + 90 days;\r\n        fin[11].winningamount = 25000e18;\r\n        fin[11].winners = 3;\r\n        fin[11].total_entry = 100000;\r\n        fin[11].multiple_entry = 1000;\r\n\r\n        fin[12].time = block.timestamp + 180 days;\r\n        fin[12].winningamount = 50000e18;\r\n        fin[12].winners = 3;\r\n        fin[12].total_entry = 200000;\r\n        fin[12].multiple_entry = 2000;\r\n\r\n        fin[13].time = block.timestamp + 270 days;\r\n        fin[13].winningamount = 100000e18;\r\n        fin[13].winners = 2;\r\n        fin[13].total_entry = 300000;\r\n        fin[13].multiple_entry = 3000;\r\n\r\n        fin[14].time = block.timestamp + 300 days;\r\n        fin[14].winningamount = 250000e18;\r\n        fin[14].winners = 2;\r\n        fin[14].total_entry = 600000;\r\n        fin[14].multiple_entry = 6000;\r\n\r\n        fin[15].time = block.timestamp + 360 days;\r\n        fin[15].winningamount = 500000e18;\r\n        fin[15].winners = 2;\r\n        fin[15].total_entry = 1100000;\r\n        fin[15].multiple_entry = 11000;\r\n        fin[16].time = block.timestamp + 365 days;\r\n        fin[16].winningamount = 1000000e18;\r\n        fin[16].winners = 1;\r\n        fin[16].total_entry = 1500000;\r\n        fin[16].multiple_entry = 15000;\r\n    }\r\n\r\n    function selectWinner(uint256 _level) public onlyOwner {\r\n        if (fin[_level].players.length == 0) {\r\n            require(block.timestamp >= fin[_level].time, \"Time not reached\");\r\n            if (_level == 1 || _level == 2 || _level == 3) {\r\n                fin[_level].time = block.timestamp + 7 days;\r\n            } else if (_level == 4) {\r\n                fin[_level].time = block.timestamp + 14 days;\r\n            } else if (_level == 5 || _level == 6) {\r\n                fin[_level].time = block.timestamp + 21 days;\r\n            } else if (_level == 7) {\r\n                fin[_level].time = block.timestamp + 30 days;\r\n            } else if (_level == 8) {\r\n                fin[_level].time = block.timestamp + 35 days;\r\n            } else if (_level == 9) {\r\n                fin[_level].time = block.timestamp + 50 days;\r\n            } else if (_level == 10) {\r\n                fin[_level].time = block.timestamp + 60 days;\r\n            } else if (_level == 11) {\r\n                fin[_level].time = block.timestamp + 90 days;\r\n            } else if (_level == 12) {\r\n                fin[_level].time = block.timestamp + 180 days;\r\n            } else if (_level == 13) {\r\n                fin[_level].time = block.timestamp + 270 days;\r\n            } else if (_level == 14) {\r\n                fin[_level].time = block.timestamp + 300 days;\r\n            } else if (_level == 15) {\r\n                fin[_level].time = block.timestamp + 360 days;\r\n            } else {\r\n                fin[_level].time = block.timestamp + 365 days;\r\n            }\r\n        } else {\r\n            total_lottery_completed = total_lottery_completed.add(1);\r\n\r\n            for (uint256 i = 0; i < fin[_level].players.length; i++) {\r\n                address a = fin[_level].players[i];\r\n                playerentry[_level][a] = 0;\r\n            }\r\n            lottey_detail[_level].lottery_completed = lottey_detail[_level]\r\n                .lottery_completed\r\n                .add(1);\r\n            require(block.timestamp >= fin[_level].time, \"Time not reached\");\r\n\r\n            uint256 newwinner = (fin[_level].received_entry)\r\n                .mul(fin[_level].winners)\r\n                .div(fin[_level].total_entry);\r\n            if (newwinner == fin[_level].winners) {\r\n                uint256 _amount = fin[_level].winners *\r\n                    fin[_level].winningamount;\r\n                uint256 _amounteverywinner = (_amount) / fin[_level].winners;\r\n                for (uint256 i; i < fin[_level].winners; i++) {\r\n                    uint256 random = randomNumberSelector(_level) %\r\n                        fin[_level].players.length;\r\n                    winner = fin[_level].players[random];\r\n                    Token.transfer(winner, _amounteverywinner);\r\n\r\n                    fin[_level].final_winners.push(winner);\r\n                    fin[_level].amount_winners.push(_amounteverywinner);\r\n                    fin2[_level].latest_winners.push(winner);\r\n                    fin2[_level].latest_winer_amount.push(_amounteverywinner);\r\n                    fin2[_level].time = (block.timestamp);\r\n                    fin[_level].winners_date.push(block.timestamp);\r\n                    winning_amount[winner] += _amounteverywinner;\r\n                    lottey_detail[_level].lottery_reward = lottey_detail[_level]\r\n                        .lottery_reward\r\n                        .add(_amounteverywinner);\r\n                    total_reward = total_reward.add(_amounteverywinner);\r\n                    emit WinnerSelected(winner, _amounteverywinner);\r\n\r\n                    uint256 lastindex = (fin[_level].players.length) - 1;\r\n                    fin[_level].players[random] = fin[_level].players[\r\n                        lastindex\r\n                    ];\r\n                    fin[_level].players.pop();\r\n                }\r\n            } else if (newwinner == 0) {\r\n                uint256 _amount = (min_amount);\r\n\r\n                uint256 _amounteverywinner = _amount;\r\n\r\n                for (uint256 i; i < fin[_level].received_entry; i++) {\r\n                    uint256 random = randomNumberSelector(_level) %\r\n                        fin[_level].players.length;\r\n                    winner = fin[_level].players[random];\r\n                    Token.transfer(winner, _amounteverywinner);\r\n\r\n                    fin[_level].final_winners.push(winner);\r\n                    fin[_level].amount_winners.push(_amounteverywinner);\r\n                    fin[_level].winners_date.push(block.timestamp);\r\n                    fin2[_level].latest_winners.push(winner);\r\n                    fin2[_level].latest_winer_amount.push(_amounteverywinner);\r\n                    fin2[_level].time = (block.timestamp);\r\n                    winning_amount[winner] += _amounteverywinner;\r\n                    total_reward = total_reward.add(_amounteverywinner);\r\n                    lottey_detail[_level].lottery_reward = lottey_detail[_level]\r\n                        .lottery_reward\r\n                        .add(_amounteverywinner);\r\n                    emit WinnerSelected(winner, _amounteverywinner);\r\n                    uint256 lastindex = (fin[_level].players.length) - 1;\r\n                    fin[_level].players[random] = fin[_level].players[\r\n                        lastindex\r\n                    ];\r\n                    fin[_level].players.pop();\r\n                }\r\n            } else {\r\n                uint256 _newwinner = (newwinner);\r\n                uint256 _amount = _newwinner * fin[_level].winningamount;\r\n                uint256 _amounteverywinner = (_amount) / _newwinner;\r\n                for (uint256 i; i < _newwinner; i++) {\r\n                    uint256 random = randomNumberSelector(_level) %\r\n                        fin[_level].players.length;\r\n                    winner = fin[_level].players[random];\r\n                    Token.transfer(winner, _amounteverywinner);\r\n\r\n                    fin[_level].final_winners.push(winner);\r\n                    fin[_level].amount_winners.push(_amounteverywinner);\r\n                    fin[_level].winners_date.push(block.timestamp);\r\n                    fin2[_level].latest_winners.push(winner);\r\n                    fin2[_level].latest_winer_amount.push(_amounteverywinner);\r\n                    fin2[_level].time = (block.timestamp);\r\n                    winning_amount[winner] += _amounteverywinner;\r\n                    total_reward = total_reward.add(_amounteverywinner);\r\n                    lottey_detail[_level].lottery_reward = lottey_detail[_level]\r\n                        .lottery_reward\r\n                        .add(_amounteverywinner);\r\n                    emit WinnerSelected(winner, _amounteverywinner);\r\n\r\n                    uint256 lastindex = (fin[_level].players.length) - 1;\r\n                    fin[_level].players[random] = fin[_level].players[\r\n                        lastindex\r\n                    ];\r\n                    fin[_level].players.pop();\r\n                }\r\n            }\r\n            if (_level == 1 || _level == 2 || _level == 3) {\r\n                fin[_level].time = block.timestamp + 7 days;\r\n            } else if (_level == 4) {\r\n                fin[_level].time = block.timestamp + 14 days;\r\n            } else if (_level == 5 || _level == 6) {\r\n                fin[_level].time = block.timestamp + 21 days;\r\n            } else if (_level == 7) {\r\n                fin[_level].time = block.timestamp + 30 days;\r\n            } else if (_level == 8) {\r\n                fin[_level].time = block.timestamp + 35 days;\r\n            } else if (_level == 9) {\r\n                fin[_level].time = block.timestamp + 50 days;\r\n            } else if (_level == 10) {\r\n                fin[_level].time = block.timestamp + 60 days;\r\n            } else if (_level == 11) {\r\n                fin[_level].time = block.timestamp + 90 days;\r\n            } else if (_level == 12) {\r\n                fin[_level].time = block.timestamp + 180 days;\r\n            } else if (_level == 13) {\r\n                fin[_level].time = block.timestamp + 270 days;\r\n            } else if (_level == 14) {\r\n                fin[_level].time = block.timestamp + 300 days;\r\n            } else if (_level == 15) {\r\n                fin[_level].time = block.timestamp + 360 days;\r\n            } else {\r\n                fin[_level].time = block.timestamp + 365 days;\r\n            }\r\n\r\n            delete fin[_level].players;\r\n            delete fin[_level].received_entry;\r\n            playerentry[_level];\r\n        }\r\n    }\r\n\r\n    function WithdrawToken(address _Token, uint256 _amount) public onlyOwner {\r\n        require(\r\n            IBEP20(_Token).transfer(msg.sender, _amount),\r\n            \"Token transfer Error!\"\r\n        );\r\n    }\r\n\r\n    function withdrawBNB(uint256 _amount) public onlyOwner {\r\n        payable(msg.sender).transfer(_amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"_Token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"count\",\"type\":\"address\"}],\"name\":\"NewEntry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WinnerSelected\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Token\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"amount_everywinner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prise\",\"type\":\"uint256\"}],\"name\":\"change_prise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"current_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"winningamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winners\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currenttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received_entry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_entry\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiple_entry\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fin2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lottey_detail\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lottery_entries\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lottery_invested_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lottery_completed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lottery_reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_entry\",\"type\":\"uint256\"}],\"name\":\"plans\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerentry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"previouslevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"randomNumberSelector\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"selectWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multipleentry\",\"type\":\"uint256\"}],\"name\":\"set_multipleentry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"__time\",\"type\":\"uint256\"}],\"name\":\"set_time\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"entry\",\"type\":\"uint256\"}],\"name\":\"set_totalentry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"winners\",\"type\":\"uint256\"}],\"name\":\"set_winners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"set_winningamount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"showWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"show_latest_winners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_entries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_invested_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_lottery_completed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"winning_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Lottery", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b3630dae5fd525984f05c4f4c436a5c1c5b6fb660af0ef3502d865145d55a121"}