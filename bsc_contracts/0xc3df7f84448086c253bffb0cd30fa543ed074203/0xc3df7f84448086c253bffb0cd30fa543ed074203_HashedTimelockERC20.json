{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.12;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n* @title Hashed Timelock Contracts (HTLCs) on Ethereum ERC20 tokens.\r\n*\r\n* This contract provides a way to create and keep HTLCs for ERC20 tokens.\r\n*\r\n* See HashedTimelock.sol for a contract that provides the same functions\r\n* for the native ETH token.\r\n*\r\n* Protocol:\r\n*\r\n*  1) newContract(receiver, hashlock, timelock, tokenContract, amount) - a\r\n*      sender calls this to create a new HTLC on a given token (tokenContract)\r\n*       for a given amount. A 32 byte contract id is returned\r\n*  2) withdraw(contractId, preimage) - once the receiver knows the preimage of\r\n*      the hashlock hash they can claim the tokens with this function\r\n*  3) refund() - after timelock has expired and if the receiver did not\r\n*      withdraw the tokens the sender / creator of the HTLC can get their tokens\r\n*      back with this function.\r\n */\r\ncontract HashedTimelockERC20 {\r\n    event HTLCERC20New(\r\n        bytes32 indexed contractId,\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address tokenContract,\r\n        uint256 amount,\r\n        bytes32 hashlock,\r\n        uint256 timelock,\r\n        bool allowLateWithdrawal\r\n    );\r\n    event HTLCERC20Withdraw(bytes32 indexed contractId);\r\n    event HTLCERC20Refund(bytes32 indexed contractId);\r\n\r\n    struct LockContract {\r\n        bool allowLateWithdrawal;\r\n        bool withdrawn;\r\n        bool refunded;\r\n        address sender;\r\n        address receiver;\r\n        address tokenContract;\r\n        uint256 amount;\r\n        bytes32 hashlock;\r\n        // locked UNTIL this time. Unit depends on consensus algorithm.\r\n        // PoA, PoA and IBFT all use seconds. But Quorum Raft uses nano-seconds\r\n        uint256 timelock;\r\n        bytes32 preimage;\r\n    }\r\n\r\n    modifier tokensTransferable(address _token, address _sender, uint256 _amount) {\r\n        require(_amount > 0, \"token amount must be > 0\");\r\n        require(\r\n            IERC20(_token).allowance(_sender, address(this)) >= _amount,\r\n            \"token allowance must be >= amount\"\r\n        );\r\n        _;\r\n    }\r\n    modifier futureTimelock(uint256 _time) {\r\n        // only requirement is the timelock time is after the last blocktime (now).\r\n        // probably want something a bit further in the future then this.\r\n        // but this is still a useful sanity check:\r\n        require(_time > block.timestamp, \"timelock time must be in the future\");\r\n        _;\r\n    }\r\n    modifier contractExists(bytes32 _contractId) {\r\n        require(haveContract(_contractId), \"contractId does not exist\");\r\n        _;\r\n    }\r\n    modifier hashlockMatches(bytes32 _contractId, bytes32 _x) {\r\n        require(\r\n            contracts[_contractId].hashlock == sha256(abi.encodePacked(_x)),\r\n            \"hashlock hash does not match\"\r\n        );\r\n        _;\r\n    }\r\n    modifier withdrawable(bytes32 _contractId) {\r\n        require(contracts[_contractId].receiver == msg.sender, \"withdrawable: not receiver\");\r\n        require(contracts[_contractId].withdrawn == false, \"withdrawable: already withdrawn\");\r\n        require(contracts[_contractId].refunded == false, \"withdrawable: already refunded\");\r\n\r\n        if (contracts[_contractId].allowLateWithdrawal == false) {\r\n            // if we want to disallow claim to be made after the timeout, uncomment the following line\r\n            require(contracts[_contractId].timelock > block.timestamp, \"withdrawable: timelock time must be in the future\");\r\n        }\r\n\r\n        _;\r\n    }\r\n    modifier refundable(bytes32 _contractId) {\r\n        require(contracts[_contractId].sender == msg.sender, \"refundable: not sender\");\r\n        require(contracts[_contractId].refunded == false, \"refundable: already refunded\");\r\n        require(contracts[_contractId].withdrawn == false, \"refundable: already withdrawn\");\r\n        require(contracts[_contractId].timelock <= block.timestamp, \"refundable: timelock not yet passed\");\r\n        _;\r\n    }\r\n\r\n    mapping (bytes32 => LockContract) contracts;\r\n\r\n    /**\r\n     * @dev Sender / Payer sets up a new hash time lock contract depositing the\r\n     * funds and providing the reciever and terms.\r\n     *\r\n     * NOTE: _receiver must first call approve() on the token contract.\r\n     *       See allowance check in tokensTransferable modifier.\r\n\r\n     * @param _receiver Receiver of the tokens.\r\n     * @param _hashlock A sha-2 sha256 hash hashlock.\r\n     * @param _timelock UNIX epoch seconds time that the lock expires at.\r\n     *                  Refunds can be made after this time.\r\n     * @param _tokenContract ERC20 Token contract address.\r\n     * @param _amount Amount of the token to lock up.\r\n     * @return contractId Id of the new HTLC. This is needed for subsequent\r\n     *                    calls.\r\n     */\r\n    function newContract(\r\n        address _receiver,\r\n        bytes32 _hashlock,\r\n        uint256 _timelock,\r\n        bool _allowLateWithdrawal,\r\n        address _tokenContract,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        tokensTransferable(_tokenContract, msg.sender, _amount)\r\n        futureTimelock(_timelock)\r\n        returns (bytes32 contractId)\r\n    {\r\n        contractId = sha256(\r\n            abi.encodePacked(\r\n                msg.sender,\r\n                _receiver,\r\n                _tokenContract,\r\n                _amount,\r\n                _hashlock,\r\n                _timelock,\r\n                _allowLateWithdrawal\r\n            )\r\n        );\r\n\r\n        // Reject if a contract already exists with the same parameters. The\r\n        // sender must change one of these parameters (ideally providing a\r\n        // different _hashlock).\r\n        if (haveContract(contractId))\r\n            revert(\"Contract already exists\");\r\n\r\n        // This contract becomes the temporary owner of the tokens\r\n        if (!IERC20(_tokenContract).transferFrom(msg.sender, address(this), _amount))\r\n            revert(\"transferFrom sender to this failed\");\r\n\r\n        contracts[contractId] = LockContract(\r\n            _allowLateWithdrawal,\r\n            false,\r\n            false,\r\n            msg.sender,\r\n            _receiver,\r\n            _tokenContract,\r\n            _amount,\r\n            _hashlock,\r\n            _timelock,\r\n            0x0\r\n        );\r\n\r\n        emit HTLCERC20New(\r\n            contractId,\r\n            msg.sender,\r\n            _receiver,\r\n            _tokenContract,\r\n            _amount,\r\n            _hashlock,\r\n            _timelock,\r\n            _allowLateWithdrawal\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Called by the receiver once they know the preimage of the hashlock.\r\n    * This will transfer ownership of the locked tokens to their address.\r\n    *\r\n    * @param _contractId Id of the HTLC.\r\n    * @param _preimage sha256(_preimage) should equal the contract hashlock.\r\n     */\r\n    function withdraw(bytes32 _contractId, bytes32 _preimage)\r\n        external\r\n        contractExists(_contractId)\r\n        hashlockMatches(_contractId, _preimage)\r\n        withdrawable(_contractId)\r\n    {\r\n        LockContract storage c = contracts[_contractId];\r\n        c.preimage = _preimage;\r\n        c.withdrawn = true;\r\n\r\n        if (!IERC20(c.tokenContract).transfer(c.receiver, c.amount))\r\n            revert(\"transfer from this to receiver failed\");\r\n\r\n        emit HTLCERC20Withdraw(_contractId);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the sender if there was no withdraw AND the time lock has\r\n     * expired. This will restore ownership of the tokens to the sender.\r\n     *\r\n     * @param _contractId Id of HTLC to refund from.\r\n     */\r\n    function refund(bytes32 _contractId)\r\n        external\r\n        contractExists(_contractId)\r\n        refundable(_contractId)\r\n    {\r\n        LockContract storage c = contracts[_contractId];\r\n        c.refunded = true;\r\n\r\n        if (!IERC20(c.tokenContract).transfer(c.sender, c.amount))\r\n            revert(\"transfer from this to sender failed\");\r\n\r\n        emit HTLCERC20Refund(_contractId);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Get contract details.\r\n     * @param _contractId HTLC contract id\r\n     * @return sender All parameters in struct LockContract for _contractId HTLC\r\n     */\r\n    function getContract(bytes32 _contractId)\r\n        public\r\n        view\r\n        returns (\r\n            address sender,\r\n            address receiver,\r\n            address tokenContract,\r\n            uint256 amount,\r\n            bytes32 hashlock,\r\n            uint256 timelock,\r\n            bool allowLateWithdrawal,\r\n            bool withdrawn,\r\n            bool refunded,\r\n            bytes32 preimage\r\n        )\r\n    {\r\n        if (!haveContract(_contractId))\r\n            return (address(0), address(0), address(0), 0, 0, 0, false, false, false, 0);\r\n        LockContract storage c = contracts[_contractId];\r\n        return (\r\n            c.sender,\r\n            c.receiver,\r\n            c.tokenContract,\r\n            c.amount,\r\n            c.hashlock,\r\n            c.timelock,\r\n            c.allowLateWithdrawal,\r\n            c.withdrawn,\r\n            c.refunded,\r\n            c.preimage\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Is there a contract with id _contractId.\r\n     * @param _contractId Id into contracts mapping.\r\n     */\r\n    function haveContract(bytes32 _contractId)\r\n        internal\r\n        view\r\n        returns (bool exists)\r\n    {\r\n        exists = (contracts[_contractId].sender != address(0));\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"contractId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowLateWithdrawal\",\"type\":\"bool\"}],\"name\":\"HTLCERC20New\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"HTLCERC20Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"contractId\",\"type\":\"bytes32\"}],\"name\":\"HTLCERC20Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"getContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timelock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowLateWithdrawal\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"refunded\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"preimage\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_hashlock\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timelock\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_allowLateWithdrawal\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"newContract\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"contractId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contractId\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_contractId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_preimage\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "HashedTimelockERC20", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://eeb8abf107f78bc36d66c9a75e746b9a49ecaf5a8a9dbae5a9ce6ff8863f41f6"}