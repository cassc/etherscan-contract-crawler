{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Diamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.20;\\r\\n\\r\\nimport { LibDiamond } from \\\"./libraries/LibDiamond.sol\\\";\\r\\nimport { IDiamondCut } from \\\"./interfaces/IDiamondCut.sol\\\";\\r\\nimport { LibUtil } from \\\"./libraries/LibUtil.sol\\\";\\r\\n\\r\\ncontract Diamond {\\r\\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\\r\\n        LibDiamond.setContractOwner(_contractOwner);\\r\\n\\r\\n        // Add the diamondCut external function from the diamondCutFacet\\r\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\\r\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\r\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\r\\n        cut[0] = IDiamondCut.FacetCut({\\r\\n            facetAddress: _diamondCutFacet,\\r\\n            action: IDiamondCut.FacetCutAction.Add,\\r\\n            functionSelectors: functionSelectors\\r\\n        });\\r\\n        LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\r\\n    }\\r\\n\\r\\n    // Find facet for function that is called and execute the\\r\\n    // function if a facet is found and return any value.\\r\\n    // solhint-disable-next-line no-complex-fallback\\r\\n    fallback() external payable {\\r\\n        LibDiamond.DiamondStorage storage ds;\\r\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\r\\n\\r\\n        // get diamond storage\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n\\r\\n        // get facet from function selector\\r\\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\r\\n\\r\\n        if (facet == address(0)) {\\r\\n            revert LibDiamond.FunctionDoesNotExist();\\r\\n        }\\r\\n\\r\\n        // Execute external function from facet using delegatecall and return any value.\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            // copy function selector and any arguments\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n            // execute function call using the facet\\r\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\r\\n            // get any return value\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n            // return any return value or error back to the caller\\r\\n            switch result\\r\\n            case 0 {\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n            default {\\r\\n                return(0, returndatasize())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Able to receive ether\\r\\n    // solhint-disable-next-line no-empty-blocks\\r\\n    receive() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.20;\\r\\n\\r\\ninterface IDiamondCut {\\r\\n    enum FacetCutAction {\\r\\n        Add,\\r\\n        Replace,\\r\\n        Remove\\r\\n    }\\r\\n    // Add=0, Replace=1, Remove=2\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.20;\\r\\n\\r\\nlibrary LibBytes {\\r\\n    // solhint-disable no-inline-assembly\\r\\n\\r\\n    // LibBytes specific errors\\r\\n    error SliceOverflow();\\r\\n    error SliceOutOfBounds();\\r\\n    error AddressOutOfBounds();\\r\\n\\r\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n    // -------------------------\\r\\n\\r\\n    function slice(\\r\\n        bytes memory _bytes,\\r\\n        uint256 _start,\\r\\n        uint256 _length\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (_length + 31 < _length) revert SliceOverflow();\\r\\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\\r\\n\\r\\n        bytes memory tempBytes;\\r\\n\\r\\n        assembly {\\r\\n            switch iszero(_length)\\r\\n            case 0 {\\r\\n                // Get a location of some free memory and store it in tempBytes as\\r\\n                // Solidity does for memory variables.\\r\\n                tempBytes := mload(0x40)\\r\\n\\r\\n                // The first word of the slice result is potentially a partial\\r\\n                // word read from the original array. To read it, we calculate\\r\\n                // the length of that partial word and start copying that many\\r\\n                // bytes into the array. The first word we copy will start with\\r\\n                // data we don't care about, but the last `lengthmod` bytes will\\r\\n                // land at the beginning of the contents of the new array. When\\r\\n                // we're done copying, we overwrite the full first word with\\r\\n                // the actual length of the slice.\\r\\n                let lengthmod := and(_length, 31)\\r\\n\\r\\n                // The multiplication in the next line is necessary\\r\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\r\\n                // the following copy loop was copying the origin's length\\r\\n                // and then ending prematurely not copying everything it should.\\r\\n                let mc := add(\\r\\n                    add(tempBytes, lengthmod),\\r\\n                    mul(0x20, iszero(lengthmod))\\r\\n                )\\r\\n                let end := add(mc, _length)\\r\\n\\r\\n                for {\\r\\n                    // The multiplication in the next line has the same exact purpose\\r\\n                    // as the one above.\\r\\n                    let cc := add(\\r\\n                        add(\\r\\n                            add(_bytes, lengthmod),\\r\\n                            mul(0x20, iszero(lengthmod))\\r\\n                        ),\\r\\n                        _start\\r\\n                    )\\r\\n                } lt(mc, end) {\\r\\n                    mc := add(mc, 0x20)\\r\\n                    cc := add(cc, 0x20)\\r\\n                } {\\r\\n                    mstore(mc, mload(cc))\\r\\n                }\\r\\n\\r\\n                mstore(tempBytes, _length)\\r\\n\\r\\n                //update free-memory pointer\\r\\n                //allocating the array padded to 32 bytes like the compiler does now\\r\\n                mstore(0x40, and(add(mc, 31), not(31)))\\r\\n            }\\r\\n            //if we want a zero-length slice let's just return a zero-length array\\r\\n            default {\\r\\n                tempBytes := mload(0x40)\\r\\n                //zero out the 32 bytes slice we are about to return\\r\\n                //we need to do it because Solidity does not garbage collect\\r\\n                mstore(tempBytes, 0)\\r\\n\\r\\n                mstore(0x40, add(tempBytes, 0x20))\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return tempBytes;\\r\\n    }\\r\\n\\r\\n    function toAddress(\\r\\n        bytes memory _bytes,\\r\\n        uint256 _start\\r\\n    ) internal pure returns (address) {\\r\\n        if (_bytes.length < _start + 20) {\\r\\n            revert AddressOutOfBounds();\\r\\n        }\\r\\n        address tempAddress;\\r\\n\\r\\n        assembly {\\r\\n            tempAddress := div(\\r\\n                mload(add(add(_bytes, 0x20), _start)),\\r\\n                0x1000000000000000000000000\\r\\n            )\\r\\n        }\\r\\n\\r\\n        return tempAddress;\\r\\n    }\\r\\n\\r\\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\\r\\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\\r\\n    function toHexString(\\r\\n        uint256 value,\\r\\n        uint256 length\\r\\n    ) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = _SYMBOLS[value & 0xf];\\r\\n            value >>= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.20;\\r\\n\\r\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\r\\nimport { LibUtil } from \\\"../libraries/LibUtil.sol\\\";\\r\\n// import { OnlyContractOwner } from \\\"../Errors/GenericErrors.sol\\\";\\r\\n\\r\\nerror OnlyContractOwner();\\r\\n\\r\\n/// Implementation of EIP-2535 Diamond Standard\\r\\n/// https://eips.ethereum.org/EIPS/eip-2535\\r\\nlibrary LibDiamond {\\r\\n    bytes32 internal constant DIAMOND_STORAGE_POSITION =\\r\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\r\\n\\r\\n    // Diamond specific errors\\r\\n    error IncorrectFacetCutAction();\\r\\n    error NoSelectorsInFace();\\r\\n    error FunctionAlreadyExists();\\r\\n    error FacetAddressIsZero();\\r\\n    error FacetAddressIsNotZero();\\r\\n    error FacetContainsNoCode();\\r\\n    error FunctionDoesNotExist();\\r\\n    error FunctionIsImmutable();\\r\\n    error InitZeroButCalldataNotEmpty();\\r\\n    error CalldataEmptyButInitNotZero();\\r\\n    error InitReverted();\\r\\n    // ----------------\\r\\n\\r\\n    struct FacetAddressAndPosition {\\r\\n        address facetAddress;\\r\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\r\\n    }\\r\\n\\r\\n    struct FacetFunctionSelectors {\\r\\n        bytes4[] functionSelectors;\\r\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\r\\n    }\\r\\n\\r\\n    struct DiamondStorage {\\r\\n        // maps function selector to the facet address and\\r\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\r\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\r\\n        // maps facet addresses to function selectors\\r\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\r\\n        // facet addresses\\r\\n        address[] facetAddresses;\\r\\n        // Used to query if a contract implements an interface.\\r\\n        // Used to implement ERC-165.\\r\\n        mapping(bytes4 => bool) supportedInterfaces;\\r\\n        // owner of the contract\\r\\n        address contractOwner;\\r\\n    }\\r\\n\\r\\n    function diamondStorage()\\r\\n        internal\\r\\n        pure\\r\\n        returns (DiamondStorage storage ds)\\r\\n    {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    function setContractOwner(address _newOwner) internal {\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        address previousOwner = ds.contractOwner;\\r\\n        ds.contractOwner = _newOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\r\\n    }\\r\\n\\r\\n    function contractOwner() internal view returns (address contractOwner_) {\\r\\n        contractOwner_ = diamondStorage().contractOwner;\\r\\n    }\\r\\n\\r\\n    function enforceIsContractOwner() internal view {\\r\\n        if (msg.sender != diamondStorage().contractOwner)\\r\\n            revert OnlyContractOwner();\\r\\n    }\\r\\n\\r\\n    event DiamondCut(\\r\\n        IDiamondCut.FacetCut[] _diamondCut,\\r\\n        address _init,\\r\\n        bytes _calldata\\r\\n    );\\r\\n\\r\\n    // Internal function version of diamondCut\\r\\n    function diamondCut(\\r\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) internal {\\r\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\r\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\r\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\r\\n                addFunctions(\\r\\n                    _diamondCut[facetIndex].facetAddress,\\r\\n                    _diamondCut[facetIndex].functionSelectors\\r\\n                );\\r\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\r\\n                replaceFunctions(\\r\\n                    _diamondCut[facetIndex].facetAddress,\\r\\n                    _diamondCut[facetIndex].functionSelectors\\r\\n                );\\r\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\r\\n                removeFunctions(\\r\\n                    _diamondCut[facetIndex].facetAddress,\\r\\n                    _diamondCut[facetIndex].functionSelectors\\r\\n                );\\r\\n            } else {\\r\\n                revert IncorrectFacetCutAction();\\r\\n            }\\r\\n            unchecked {\\r\\n                ++facetIndex;\\r\\n            }\\r\\n        }\\r\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\r\\n        initializeDiamondCut(_init, _calldata);\\r\\n    }\\r\\n\\r\\n    function addFunctions(\\r\\n        address _facetAddress,\\r\\n        bytes4[] memory _functionSelectors\\r\\n    ) internal {\\r\\n        if (_functionSelectors.length == 0) {\\r\\n            revert NoSelectorsInFace();\\r\\n        }\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        if (LibUtil.isZeroAddress(_facetAddress)) {\\r\\n            revert FacetAddressIsZero();\\r\\n        }\\r\\n        uint96 selectorPosition = uint96(\\r\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\r\\n        );\\r\\n        // add new facet address if it does not exist\\r\\n        if (selectorPosition == 0) {\\r\\n            addFacet(ds, _facetAddress);\\r\\n        }\\r\\n        for (\\r\\n            uint256 selectorIndex;\\r\\n            selectorIndex < _functionSelectors.length;\\r\\n\\r\\n        ) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds\\r\\n                .selectorToFacetAndPosition[selector]\\r\\n                .facetAddress;\\r\\n            if (!LibUtil.isZeroAddress(oldFacetAddress)) {\\r\\n                revert FunctionAlreadyExists();\\r\\n            }\\r\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\r\\n            unchecked {\\r\\n                ++selectorPosition;\\r\\n                ++selectorIndex;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function replaceFunctions(\\r\\n        address _facetAddress,\\r\\n        bytes4[] memory _functionSelectors\\r\\n    ) internal {\\r\\n        if (_functionSelectors.length == 0) {\\r\\n            revert NoSelectorsInFace();\\r\\n        }\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        if (LibUtil.isZeroAddress(_facetAddress)) {\\r\\n            revert FacetAddressIsZero();\\r\\n        }\\r\\n        uint96 selectorPosition = uint96(\\r\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\r\\n        );\\r\\n        // add new facet address if it does not exist\\r\\n        if (selectorPosition == 0) {\\r\\n            addFacet(ds, _facetAddress);\\r\\n        }\\r\\n        for (\\r\\n            uint256 selectorIndex;\\r\\n            selectorIndex < _functionSelectors.length;\\r\\n\\r\\n        ) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds\\r\\n                .selectorToFacetAndPosition[selector]\\r\\n                .facetAddress;\\r\\n            if (oldFacetAddress == _facetAddress) {\\r\\n                revert FunctionAlreadyExists();\\r\\n            }\\r\\n            removeFunction(ds, oldFacetAddress, selector);\\r\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\r\\n            unchecked {\\r\\n                ++selectorPosition;\\r\\n                ++selectorIndex;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeFunctions(\\r\\n        address _facetAddress,\\r\\n        bytes4[] memory _functionSelectors\\r\\n    ) internal {\\r\\n        if (_functionSelectors.length == 0) {\\r\\n            revert NoSelectorsInFace();\\r\\n        }\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        // if function does not exist then do nothing and return\\r\\n        if (!LibUtil.isZeroAddress(_facetAddress)) {\\r\\n            revert FacetAddressIsNotZero();\\r\\n        }\\r\\n        for (\\r\\n            uint256 selectorIndex;\\r\\n            selectorIndex < _functionSelectors.length;\\r\\n\\r\\n        ) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds\\r\\n                .selectorToFacetAndPosition[selector]\\r\\n                .facetAddress;\\r\\n            removeFunction(ds, oldFacetAddress, selector);\\r\\n            unchecked {\\r\\n                ++selectorIndex;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addFacet(\\r\\n        DiamondStorage storage ds,\\r\\n        address _facetAddress\\r\\n    ) internal {\\r\\n        enforceHasContractCode(_facetAddress);\\r\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\\r\\n            .facetAddresses\\r\\n            .length;\\r\\n        ds.facetAddresses.push(_facetAddress);\\r\\n    }\\r\\n\\r\\n    function addFunction(\\r\\n        DiamondStorage storage ds,\\r\\n        bytes4 _selector,\\r\\n        uint96 _selectorPosition,\\r\\n        address _facetAddress\\r\\n    ) internal {\\r\\n        ds\\r\\n            .selectorToFacetAndPosition[_selector]\\r\\n            .functionSelectorPosition = _selectorPosition;\\r\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\r\\n            _selector\\r\\n        );\\r\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\r\\n    }\\r\\n\\r\\n    function removeFunction(\\r\\n        DiamondStorage storage ds,\\r\\n        address _facetAddress,\\r\\n        bytes4 _selector\\r\\n    ) internal {\\r\\n        if (LibUtil.isZeroAddress(_facetAddress)) {\\r\\n            revert FunctionDoesNotExist();\\r\\n        }\\r\\n        // an immutable function is a function defined directly in a diamond\\r\\n        if (_facetAddress == address(this)) {\\r\\n            revert FunctionIsImmutable();\\r\\n        }\\r\\n        // replace selector with last selector, then delete last selector\\r\\n        uint256 selectorPosition = ds\\r\\n            .selectorToFacetAndPosition[_selector]\\r\\n            .functionSelectorPosition;\\r\\n        uint256 lastSelectorPosition = ds\\r\\n            .facetFunctionSelectors[_facetAddress]\\r\\n            .functionSelectors\\r\\n            .length - 1;\\r\\n        // if not the same then replace _selector with lastSelector\\r\\n        if (selectorPosition != lastSelectorPosition) {\\r\\n            bytes4 lastSelector = ds\\r\\n                .facetFunctionSelectors[_facetAddress]\\r\\n                .functionSelectors[lastSelectorPosition];\\r\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\r\\n                selectorPosition\\r\\n            ] = lastSelector;\\r\\n            ds\\r\\n                .selectorToFacetAndPosition[lastSelector]\\r\\n                .functionSelectorPosition = uint96(selectorPosition);\\r\\n        }\\r\\n        // delete the last selector\\r\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\r\\n        delete ds.selectorToFacetAndPosition[_selector];\\r\\n\\r\\n        // if no more selectors for facet address then delete the facet address\\r\\n        if (lastSelectorPosition == 0) {\\r\\n            // replace facet address with last facet address and delete last facet address\\r\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\r\\n            uint256 facetAddressPosition = ds\\r\\n                .facetFunctionSelectors[_facetAddress]\\r\\n                .facetAddressPosition;\\r\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\r\\n                address lastFacetAddress = ds.facetAddresses[\\r\\n                    lastFacetAddressPosition\\r\\n                ];\\r\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\r\\n                ds\\r\\n                    .facetFunctionSelectors[lastFacetAddress]\\r\\n                    .facetAddressPosition = facetAddressPosition;\\r\\n            }\\r\\n            ds.facetAddresses.pop();\\r\\n            delete ds\\r\\n                .facetFunctionSelectors[_facetAddress]\\r\\n                .facetAddressPosition;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initializeDiamondCut(\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) internal {\\r\\n        if (LibUtil.isZeroAddress(_init)) {\\r\\n            if (_calldata.length != 0) {\\r\\n                revert InitZeroButCalldataNotEmpty();\\r\\n            }\\r\\n        } else {\\r\\n            if (_calldata.length == 0) {\\r\\n                revert CalldataEmptyButInitNotZero();\\r\\n            }\\r\\n            if (_init != address(this)) {\\r\\n                enforceHasContractCode(_init);\\r\\n            }\\r\\n            // solhint-disable-next-line avoid-low-level-calls\\r\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\r\\n            if (!success) {\\r\\n                if (error.length > 0) {\\r\\n                    // bubble up the error\\r\\n                    revert(string(error));\\r\\n                } else {\\r\\n                    revert InitReverted();\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function enforceHasContractCode(address _contract) internal view {\\r\\n        uint256 contractSize;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            contractSize := extcodesize(_contract)\\r\\n        }\\r\\n        if (contractSize == 0) {\\r\\n            revert FacetContainsNoCode();\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.20;\\r\\n\\r\\nimport \\\"./LibBytes.sol\\\";\\r\\n\\r\\nlibrary LibUtil {\\r\\n    using LibBytes for bytes;\\r\\n\\r\\n    function getRevertMsg(\\r\\n        bytes memory _res\\r\\n    ) internal pure returns (string memory) {\\r\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\r\\n        if (_res.length < 68) return \\\"Transaction reverted silently\\\";\\r\\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\\r\\n        return abi.decode(revertData, (string)); // All that remains is the revert string\\r\\n    }\\r\\n\\r\\n    /// @notice Determines whether the given address is the zero address\\r\\n    /// @param addr The address to verify\\r\\n    /// @return Boolean indicating if the address is the zero address\\r\\n    function isZeroAddress(address addr) internal pure returns (bool) {\\r\\n        return addr == address(0);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CalldataEmptyButInitNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FacetAddressIsNotZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FacetAddressIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FacetContainsNoCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FunctionAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FunctionDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FunctionIsImmutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectFacetCutAction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitReverted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitZeroButCalldataNotEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSelectorsInFace\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Diamond", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006829c091cfa40698dbb3da56ea5e13b2c6ba38dc000000000000000000000000ae659e594c607ee8cb63f51e7cfa5ad4ca77d393", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}