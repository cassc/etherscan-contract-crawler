{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity ^0.8.4;\r\n\r\nlibrary Address\r\n{\r\n    function isContract(address account) internal view returns (bool)\r\n    {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly\r\n        {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}\r\n\r\ninterface IERC20\r\n{\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Factory\r\n{\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint256) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint256);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair\r\n{\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out,address indexed to);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address owner) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n    function nonces(address owner) external view returns (uint256);\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint256);\r\n    function price1CumulativeLast() external view returns (uint256);\r\n    function kLast() external view returns (uint256);\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01\r\n{\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n    function removeLiquidity(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB);\r\n    function removeLiquidityETH(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external returns (uint256 amountToken, uint256 amountETH);\r\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint256 liquidity, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 amountA, uint256 amountB);\r\n    function removeLiquidityETHWithPermit(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 amountToken, uint256 amountETH);\r\n    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\r\n    function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\r\n    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable returns (uint256[] memory amounts);\r\n    function swapTokensForExactETH(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\r\n    function swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts);\r\n    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline) external payable returns (uint256[] memory amounts);\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external pure returns (uint256 amountOut);\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external pure returns (uint256 amountIn);\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01\r\n{\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external returns (uint256 amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint256 liquidity, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint256 amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n}\r\n\r\nabstract contract Context\r\n{\r\n    function _msgSender() internal view virtual returns (address payable)\r\n    {\r\n        return payable(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Ownable is Context\r\n{\r\n    address private _owner;\r\n    address private _newOwner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor()\r\n    {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        _newOwner = address(0);\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address)\r\n    {\r\n        return _owner;\r\n    }\r\n\r\n    function isOwner(address who) public view returns (bool)\r\n    {\r\n        return _owner == who;\r\n    }\r\n\r\n    modifier onlyOwner()\r\n    {\r\n        require(isOwner(_msgSender()), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        require(newOwner != _owner, \"Ownable: new owner is already the owner\");\r\n        _newOwner = newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public\r\n    {\r\n        require(_msgSender() == _newOwner);\r\n        emit OwnershipTransferred(_owner, _newOwner);\r\n        _owner = _newOwner;\r\n        _newOwner = address(0);\r\n    }\r\n\r\n    function getTime() public view returns (uint256)\r\n    {\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\ncontract VetterToken is Context, Ownable, IERC20\r\n{\r\n    using Address for address;\r\n\r\n    address private _rankContract;\r\n\r\n    modifier onlyRankContract()\r\n    {\r\n        require(_msgSender() == _rankContract, \"caller is not the rank contract\");\r\n        _;\r\n    }\r\n\r\n    string private constant _name = \"Vetter Token\";\r\n    string private constant _symbol = \"VETTER\";\r\n    uint8 private constant _decimals = 9;\r\n\r\n    address private presaleAddress = 0x000000000000000000000000000000000000dEaD;                        // External presale address\r\n    address payable private vetterAddress = payable(0x3636413005a394800F5E4B9fbF194521F3ac40F2);        // External Vetter Pool Address (to send the BNB to when auto selling)\r\n    address payable constant private addressV2Router = payable(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    IUniswapV2Router02 private uniswapV2Router;\r\n    address private uniswapV2Pair;\r\n\r\n    uint256 private constant _totalTokens =         4 * 10**9 * 10**_decimals;      // 4 Billion Tokens\r\n    uint256 private constant _initialFounder =      2 * 10**8 * 10**_decimals;      // 200 Million Tokens\r\n    uint256 private constant _initialStable =       2 * 10**8 * 10**_decimals;      // 200 Million Tokens\r\n    uint256 private constant _initialPrivateSale =  2290909091 * 10**_decimals;     // 2.3 Billion Tokens\r\n    uint256 private constant _initialPreSale =      654545455 * 10**_decimals;      // 645 Million Tokens\r\n    uint256 private constant _initialLiquidity =    654545455 * 10**_decimals;      // 645 Million Tokens\r\n\r\n    mapping(uint256 => uint256) private _tiers;     // The actual tier levels (number of Tokens needed per Tier)\r\n    uint256 private _numberOfTiers = 4;     // Used to control tier levels for DAPP access (0 - number of tier inclusive) [Tier 0 is always 0 tokens]\r\n    uint256 private constant _initialTier1 = 10000;\r\n    uint256 private constant _initialTier2 = 100000;\r\n    uint256 private constant _initialTier3 = 250000;\r\n    uint256 private constant _initialTier4 = 500000;\r\n\r\n    mapping(address => uint256) private _tokensOwned;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) private _isExcludedFromFee;\r\n\r\n    struct Founder\r\n    {\r\n        address payable _founder;\r\n        uint256 _percentage;\r\n    }\r\n\r\n    mapping (address => bool) private _architects;\r\n    mapping (uint256 => Founder) _founderList;\r\n    uint256 private _numberOfFounders;\r\n\r\n    uint256 private constant _initialFounderLock = 365 days;                            // Time to the first token release\r\n    uint256 private constant _founderRelease = 30 days;                                 // Days to the next token release after the first\r\n    uint256 private constant _founderPercentPerPeriod = 10;                             // The percentage of the founder pool released over time...\r\n    uint256 private _timeTokenLaunched;                                                 // When the contract was created...\r\n\r\n    uint256 private _founderTokens = _initialFounder;                                   // Track them until they are sent out...timed release\r\n    uint256 private _stableTokens = _initialStable;                                     // Track them until they are sent out...timed release\r\n    uint256 private _privateSaleTokens = _initialPrivateSale;                           // Track them until they are sent out...air dropped\r\n    uint256 private _presaleAndLiquidityTokens = _initialPreSale + _initialLiquidity;   // Track them until they are sent out...sent to presale provider\r\n\r\n    struct Share\r\n    {\r\n        address _wallet;    // Who was in the sale\r\n        uint256 _shares;    // This is based upon 1 share = 0.01 BNB\r\n        bool _private;      // Used to determine airdropped amounts\r\n        bool _active;       // Used to determine if still qualified for stablizer token releases\r\n        uint256 _minTokens; // Lowest Level to remain active for stablizer token releases\r\n    }\r\n\r\n    uint256 private constant _stableRelease = 90 days;              // Days between each token release\r\n    uint256 private _stablePercent = 10;                            // The percentage of the stable pool to release next\r\n    uint256 private _stablePeriod = 0;                              // Which period we are currently in\r\n    mapping (address => uint256) private _shareHolderIndex;         // Index of address in list\r\n    mapping (uint256 => Share) private _shareHolders;               // Used for Private Sale Airdrop and Stabilizer Token Distribution\r\n    uint256 private _numberOfShareholders;                          // Count of entries in the Shares List\r\n\r\n    mapping (address => uint256) private _admins;                   // 0 = No, 1 = reviewer only, 2 = full admin\r\n    uint256 private _numberOfAdmins;                                // Number of Admins\r\n    mapping (uint256 => address) private _adminIndex;               // Admin list index\r\n\r\n    bool private _taxesEnabled = false;\r\n\r\n    uint256 private _marketingBuyTax = 50;              // (stored at 10x so 5% is 50)\r\n    uint256 private _marketingSellTax = 50;             // (stored at 10x so 5% is 50)\r\n    uint256 private constant _marketTaxCap = 50;        // 5% max\r\n    uint256 private _marketingTokens;                   // Marketing/Dev Pool\r\n\r\n    uint256 private _participitoryBuyTax = 20;          // (stored at 10x so 2% is 20)\r\n    uint256 private _participitorySellTax = 50;         // (stored at 10x so 5% is 50)\r\n    uint256 private constant _participitoryCap = 50;    // 5% max\r\n    uint256 private _participitoryTokens;               // Participitory Pool\r\n\r\n    uint256 private _vetterBuyTax = 20;                 // (stored at 10x so 2% is 20)\r\n    uint256 private _vetterSellTax = 50;                // (stored at 10x so 5% is 50)\r\n    uint256 private constant _vetterCap = 50;           // 5% max\r\n    uint256 private constant _maxHighTaxTime = 2 days;  // Maximum time the vetter tax can be set to a higher rate before cap sets in\r\n    uint256 private _vetterTokens;                      // Vetter Pool\r\n    uint256 private _vetterReserve;                     // Vetter to keep on hand...set to 0 initially\r\n    mapping (address => uint256) private _vetters;      // Vetter Type: 0 = not vetter, 1 = full vetter, 2 = trial vetter\r\n    uint256 private _numberOfVetters;                   // Count of vetters\r\n    mapping (uint256 => address) private _vetterList;   // List of vetter addresses\r\n\r\n    uint256 private _liquidityBuyTax = 20;              // (stored at 10x so 2% is 20)\r\n    uint256 private _liquiditySellTax = 20;             // (stored at 10x so 2% is 20)\r\n    uint256 private constant _liquidityCap = 20;        // 2% max\r\n    uint256 private _liquidityTokens;                   // Liquidity Pool\r\n\r\n    uint256 private _royaltyBuyTax = 10;                // (stored at 10x so 1% is 10)\r\n    uint256 private _royaltySellTax = 10;               // (stored at 10x so 1% is 10)\r\n    uint256 private constant _royaltyCap = 20;          // 2% max\r\n    uint256 private constant _royaltyMin = 10;          // 1% min\r\n    uint256 private _royaltyTokens;                     // Royalty Pool\r\n    uint256 private _royaltyUndistributed;              // Amount of Pool Not Yet istributed\r\n    uint256 private _royaltyTierRequired = 3;           // Minimum Tier Needed to claim Royalties\r\n\r\n    struct Royalties\r\n    {\r\n        uint256 whenAvailable;\r\n        uint256 amountToClaim;\r\n    }\r\n    uint256 private _numRoyaltyHolders;                     // Count of address now able to claim royalties\r\n    uint256 private _numberOfDistributions;                 // Needed to iterate the mapping list when needed\r\n    mapping (uint256 => Royalties) private _distributions;  // The actual amounts by date listing...index to time/amount\r\n    mapping (address => uint256) private _royaltyIndex;     // Addresses in royalty list to time last claimed\r\n\r\n    constructor()\r\n    {\r\n        // Distribute the tokens...\r\n        _tokensOwned[address(this)] = _totalTokens - _presaleAndLiquidityTokens;\r\n        emit Transfer(address(0), address(this), _totalTokens - _presaleAndLiquidityTokens);\r\n        _tokensOwned[owner()] = _presaleAndLiquidityTokens;\r\n        emit Transfer(address(0), owner(), _presaleAndLiquidityTokens);\r\n        _presaleAndLiquidityTokens = 0;\r\n\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(addressV2Router);\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        uniswapV2Router = _uniswapV2Router;\r\n\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[owner()] = true;\r\n        _isExcludedFromFee[addressV2Router] = true;\r\n        _isExcludedFromFee[uniswapV2Pair] = true;\r\n        _isExcludedFromFee[vetterAddress] = true;\r\n\r\n        _tiers[1] = _initialTier1;\r\n        _tiers[2] = _initialTier2;\r\n        _tiers[3] = _initialTier3;\r\n        _tiers[4] = _initialTier4;\r\n\r\n        _timeTokenLaunched = block.timestamp;\r\n    }\r\n\r\n    // To receive ETH from uniswapV2Router when swapping\r\n    receive() external payable {}\r\n\r\n    function totalSupply() external pure override returns (uint256)\r\n    {\r\n        return _totalTokens;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256)\r\n    {\r\n        return _tokensOwned[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    // Account for the correct amount to be approved since they only see the post tax amount in their wallet\r\n    function approve(address spender, uint256 amount) public override returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool)\r\n    {\r\n        require(amount <= _allowances[sender][_msgSender()], \"ERC20: transfer amount exceeds allowance\");\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\r\n        return true;\r\n    }\r\n\r\n    function name() external pure returns (string memory)\r\n    {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external pure returns (string memory)\r\n    {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure returns (uint8)\r\n    {\r\n        return _decimals;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool)\r\n    {\r\n        require(subtractedValue <= _allowances[_msgSender()][spender], \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private\r\n    {\r\n        // Approve token transfer to cover all possible scenarios\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        // Add the liquidity\r\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, // Slippage is unavoidable\r\n            0, // Slippage is unavoidable\r\n            owner(),\r\n            getTime()\r\n        );\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private\r\n    {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) private\r\n    {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n        require(amount <= _tokensOwned[from], \"Transfer amount would exceed balance\");\r\n\r\n        _tokensOwned[from] = _tokensOwned[from] - amount;\r\n\r\n        uint256 remaining = amount;\r\n        uint256 sellTax;\r\n        uint256 buyTax;\r\n\r\n        if(_taxesEnabled && !_isExcludedFromFee[from] && (from != presaleAddress))\r\n        {\r\n            sellTax = remaining - _handleSellTax(remaining);\r\n            remaining = remaining - sellTax;\r\n        }\r\n\r\n        if(_taxesEnabled && !_isExcludedFromFee[to] && (from != presaleAddress))\r\n        {\r\n            buyTax = remaining - _handleBuyTax(remaining);\r\n            remaining = remaining - buyTax;\r\n        }\r\n\r\n        // Add the taxed tokens to the contract...\r\n        if(amount > remaining)\r\n        {\r\n            _tokensOwned[address(this)] = _tokensOwned[address(this)] + (amount - remaining);\r\n            if(buyTax > 0) emit Transfer(to, address(this), buyTax);\r\n            if(sellTax > 0) emit Transfer(from, address(this), sellTax);\r\n        }\r\n\r\n        // Give tokens to the new owner...\r\n        _tokensOwned[to] = _tokensOwned[to] + remaining;\r\n        emit Transfer(from, to, remaining);\r\n\r\n        // Save time if these are all gone now...\r\n        if(_stableTokens > 0)\r\n        {\r\n            // Check if still eligible for stable rewards...\r\n            if(_shareHolderIndex[from] > 0)\r\n            {\r\n                // Handle the normal case in the list...won't catch the case where the first entry is actually supposed to be index 0\r\n                if(_tokensOwned[from] < _shareHolders[_shareHolderIndex[from]]._minTokens) _shareHolders[_shareHolderIndex[from]]._active = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function isFounderPercentageValid() internal view returns(bool)\r\n    {\r\n        uint256 percentageSum = 0;\r\n        for(uint256 index = 1; index <= _numberOfFounders; index++)\r\n        {\r\n            percentageSum = percentageSum + _founderList[index]._percentage;\r\n        }\r\n        return(percentageSum == 100);\r\n    }\r\n\r\n    event MarketingPoolSwap(uint256 tokensSwapped);\r\n\r\n    function swapMarketingPoolTokens(uint256 amount) external onlyArchitect\r\n    {\r\n        require(amount <= _marketingTokens, \"Not enough tokens to convert\");\r\n        require(isFounderPercentageValid(), \"Founder percentages are not set to 100%\");\r\n\r\n        uint256 initialBalance = address(this).balance;\r\n        swapTokensForBNB(amount);\r\n        uint256 transferredBalance = address(this).balance - initialBalance;\r\n        if (transferredBalance == 0) return;\r\n\r\n        _tokensOwned[address(this)] = _tokensOwned[address(this)] - amount;\r\n        _marketingTokens = _marketingTokens - amount;\r\n        emit MarketingPoolSwap(amount);\r\n\r\n        // Send to Marketing addresses controlled by the founder list\r\n        uint256 remaining = transferredBalance;\r\n        for(uint256 index = 1; index <= _numberOfFounders; index++)\r\n        {\r\n            uint256 sendAmt = (transferredBalance * _founderList[index]._percentage) / 100;\r\n            transferBNBToAddress(_founderList[index]._founder, sendAmt);\r\n            remaining = remaining - sendAmt;\r\n        }\r\n        // Should not be any left, but if the division was not even...\r\n        if(remaining > 0) transferBNBToAddress(payable(owner()), remaining);\r\n    }\r\n\r\n    event VetterPoolSwapped(uint256 amountSentToInvestmentPool);\r\n\r\n    function swapVetterPoolTokens(uint256 amount) external onlyArchitect\r\n    {\r\n        require(amount <= _vetterTokens, \"Not enough to swap\");\r\n        require(_vetterTokens > _vetterReserve, \"Can't reduce pool below reserve amount\");\r\n\r\n        uint256 swapAmt = amount;\r\n        if(_vetterTokens - swapAmt < _vetterReserve)\r\n        {\r\n            swapAmt = _vetterTokens - _vetterReserve;\r\n        }\r\n\r\n        uint256 initialBalance = address(this).balance;\r\n        swapTokensForBNB(swapAmt);\r\n        uint256 transferredBalance = address(this).balance - initialBalance;\r\n        if (transferredBalance == 0) return;\r\n\r\n        // Send to vetter address\r\n        _tokensOwned[address(this)] = _tokensOwned[address(this)] - swapAmt;\r\n        _vetterTokens = _vetterTokens - swapAmt;\r\n        transferBNBToAddress(vetterAddress, transferredBalance);\r\n        emit VetterPoolSwapped(swapAmt);\r\n    }\r\n\r\n    function setVetterReserve(uint256 vetter) public onlyArchitect\r\n    {\r\n        _vetterReserve = vetter;\r\n    }\r\n\r\n    event SetVetterAddress(address wallet);\r\n\r\n    function setVetterAddress(address _vetterAddress) external onlyArchitect\r\n    {\r\n        vetterAddress = payable(_vetterAddress);\r\n        _isExcludedFromFee[vetterAddress] = true;\r\n        emit SetVetterAddress(_vetterAddress);\r\n    }\r\n\r\n    event LiquidityAddedToLP(uint256 tokensAdded);\r\n\r\n    function addLiquidityPoolTokensToLP(uint256 amount) external onlyArchitect\r\n    {\r\n        require(amount <= _liquidityTokens, \"Not enough to liquify\");\r\n\r\n        // split the contract balance into halves\r\n        uint256 half = amount / 2;\r\n        uint256 otherHalf = amount - half;\r\n\r\n        // capture the contract's current BNB balance.\r\n        // this is so that we can capture exactly the amount of BNB that the\r\n        // swap creates, and not make the liquidity event include any BNB that\r\n        // has been manually sent to the contract\r\n        uint256 initialBalance = address(this).balance;\r\n\r\n        // Enough liquidity???\r\n        if(swapTokensForBNB(half))\r\n        {\r\n            uint256 newBalance = address(this).balance - initialBalance;\r\n            if(newBalance > 0)\r\n            {\r\n                _tokensOwned[address(this)] = _tokensOwned[address(this)] - amount;\r\n                _liquidityTokens = _liquidityTokens - amount;\r\n                addLiquidity(otherHalf, newBalance);\r\n                emit LiquidityAddedToLP(amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Just converts the tokens held by the contract itself to BNB...from whatever pool holds them...and gives them to the spcified wallet address\r\n    function swapTokensForBNB(uint256 tokenAmount) private returns (bool status)\r\n    {\r\n        // Generate the uniswap pair path of token -> WETH\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        if(allowance(address(this), address(uniswapV2Router)) < tokenAmount)\r\n        {\r\n          _approve(address(this), address(uniswapV2Router), ~uint256(0));\r\n        }\r\n\r\n        // Make the swap\r\n        try uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,              // Accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            getTime()\r\n        )\r\n        {\r\n          return true;\r\n        }\r\n        catch\r\n        {\r\n          return false;\r\n        }\r\n    }\r\n\r\n    function _handleBuyTax(uint256 starting) private returns(uint256)\r\n    {\r\n        uint256 remaining = starting;\r\n\r\n        uint256 tax = (starting * _marketingBuyTax) / 1000;\r\n        _marketingTokens = _marketingTokens + tax;\r\n        remaining = remaining - tax;\r\n\r\n        tax = (starting * _participitoryBuyTax) / 1000;\r\n        _participitoryTokens = _participitoryTokens + tax;\r\n        remaining = remaining - tax;\r\n\r\n        tax = (starting * _vetterBuyTax) / 1000;\r\n        _vetterTokens = _vetterTokens + tax;\r\n        remaining = remaining - tax;\r\n\r\n        tax = (starting * _liquidityBuyTax) / 1000;\r\n        _liquidityTokens = _liquidityTokens + tax;\r\n        remaining = remaining - tax;\r\n\r\n        tax = (starting * _royaltyBuyTax) / 1000;\r\n        _royaltyTokens = _royaltyTokens + tax;\r\n        _royaltyUndistributed = _royaltyUndistributed + tax;\r\n        remaining = remaining - tax;\r\n\r\n        return remaining;\r\n    }\r\n\r\n    function _handleSellTax(uint256 starting) private returns(uint256)\r\n    {\r\n        uint256 remaining = starting;\r\n\r\n        uint256 tax = (starting * _marketingSellTax) / 1000;\r\n        _marketingTokens = _marketingTokens + tax;\r\n        remaining = remaining - tax;\r\n\r\n        tax = (starting * _participitorySellTax) / 1000;\r\n        _participitoryTokens = _participitoryTokens + tax;\r\n        remaining = remaining - tax;\r\n\r\n        tax = (starting * _vetterSellTax) / 1000;\r\n        _vetterTokens = _vetterTokens + tax;\r\n        remaining = remaining - tax;\r\n\r\n        tax = (starting * _liquiditySellTax) / 1000;\r\n        _liquidityTokens = _liquidityTokens + tax;\r\n        remaining = remaining - tax;\r\n\r\n        tax = (starting * _royaltySellTax) / 1000;\r\n        _royaltyTokens = _royaltyTokens + tax;\r\n        _royaltyUndistributed = _royaltyUndistributed + tax;\r\n        remaining = remaining - tax;\r\n\r\n        return remaining;\r\n    }\r\n\r\n    event TaxesEnabled(bool enabled);\r\n\r\n    function takeTaxes(bool _enabled) external onlyArchitect\r\n    {\r\n        _taxesEnabled = _enabled;\r\n        emit TaxesEnabled(_taxesEnabled);\r\n    }\r\n\r\n    event BuyTaxesChanged(uint256 marketing, uint256 participatory, uint256 vetter, uint256 liquidity, uint256 royalty);\r\n    event SellTaxesChanged(uint256 marketing, uint256 participatory, uint256 vetter, uint256 liquidity, uint256 royalty);\r\n\r\n    function setAllTaxes(uint256 marketingBuy, uint256 marketingSell, uint256 participatoryBuy, uint256 participatorySell, uint256 vetterBuy, uint256 vetterSell, uint256 liquidityBuy, uint256 liquiditySell, uint256 royaltyBuy, uint256 royaltySell) public onlyArchitect\r\n    {\r\n        require(marketingBuy <= _marketTaxCap && marketingSell <= _marketTaxCap, \"Marketing Tax Exceeds Cap\");\r\n        require(participatoryBuy <= _participitoryCap && participatorySell <= _participitoryCap, \"Participatory Tax Exceeds Cap\");\r\n        require(vetterBuy <= _vetterCap && vetterSell <= _vetterCap, \"Vetter Tax Exceeds Cap\");\r\n        require(liquidityBuy <= _liquidityCap && liquiditySell <= _liquidityCap, \"Liquidity Tax Exceeds Cap\");\r\n        require(royaltyBuy <= _royaltyCap && royaltySell <= _royaltyCap, \"Royalty Tax Exceeds Cap\");\r\n        require(royaltyBuy >= _royaltyMin && royaltySell >= _royaltyMin, \"Royalty Tax Below Minimum\");\r\n\r\n        _marketingBuyTax = marketingBuy;\r\n        _marketingSellTax = marketingSell;\r\n\r\n        _participitoryBuyTax = participatoryBuy;\r\n        _participitorySellTax = participatorySell;\r\n\r\n        _vetterBuyTax = vetterBuy;\r\n        _vetterSellTax = vetterSell;\r\n\r\n        _liquidityBuyTax = liquidityBuy;\r\n        _liquiditySellTax = liquiditySell;\r\n\r\n        _royaltyBuyTax = royaltyBuy;\r\n        _royaltySellTax = royaltySell;\r\n\r\n        emit BuyTaxesChanged(_marketingBuyTax, _participitoryBuyTax, _vetterBuyTax, _liquidityBuyTax, _royaltyBuyTax);\r\n        emit SellTaxesChanged(_marketingSellTax, _participitorySellTax, _vetterSellTax, _liquiditySellTax, _royaltySellTax);\r\n    }\r\n\r\n    event LaunchTaxChanged(uint256 newVetterTax);\r\n\r\n    // Bot measure to deincentivize selling early...\r\n    // Ignores the normal caps we have in place...but only able to be called in the initial days of launch\r\n    function setInitialLaunchTaxes(uint256 amount) public onlyArchitect\r\n    {\r\n        require(getTime() < _timeTokenLaunched + _maxHighTaxTime, \"Past Allowed High Tax Period\");\r\n        require(amount < 670, \"Can't exceed maximum sell tax of 80%\");\r\n        _vetterSellTax = amount;\r\n        emit LaunchTaxChanged(_vetterSellTax);\r\n    }\r\n\r\n    function getTotalBuyTax() public view returns (uint256)\r\n    {\r\n        return(_marketingBuyTax + _participitoryBuyTax + _vetterBuyTax + _liquidityBuyTax + _royaltyBuyTax);\r\n    }\r\n\r\n    function getTotalSellTax() public view returns (uint256)\r\n    {\r\n        return(_marketingSellTax + _participitorySellTax + _vetterSellTax + _liquiditySellTax + _royaltySellTax);\r\n    }\r\n\r\n    event ParticipitoryRewarded(address indexed to, uint256 value);\r\n\r\n    function rewardParticipatory(address to, uint256 amount) external onlyRankContract\r\n    {\r\n        require(amount <= _participitoryTokens, \"Not enough to reward\");\r\n\r\n        _tokensOwned[address(this)] = _tokensOwned[address(this)] - amount;\r\n        _participitoryTokens = _participitoryTokens - amount;\r\n        _tokensOwned[to] = _tokensOwned[to] + amount;\r\n        emit Transfer(address(this), to, amount);\r\n        emit ParticipitoryRewarded(to, amount);\r\n    }\r\n\r\n    event VetterRewarded(address indexed to, uint256 value);\r\n\r\n    function rewardVetter(address to, uint256 amount) external onlyRankContract\r\n    {\r\n        require(amount <= _vetterTokens, \"Not enough to reward\");\r\n\r\n        // Send vetter to them\r\n        _tokensOwned[address(this)] = _tokensOwned[address(this)] - amount;\r\n        _vetterTokens = _vetterTokens - amount;\r\n        _tokensOwned[to] = _tokensOwned[to] + amount;\r\n        emit Transfer(address(this), to, amount);\r\n        emit VetterRewarded(to, amount);\r\n    }\r\n\r\n    event TipSent(address indexed from, address indexed to, uint256 value);\r\n\r\n    function transferTipAmount(address from, address to, uint256 amount) external onlyRankContract\r\n    {\r\n        _transfer(from, to, amount);\r\n        emit TipSent(from, to, amount);\r\n    }\r\n\r\n    // Return the current tracking of the size of initial tokens created in pools as well as taxed pools...\r\n    // Values:\r\n    //  0) Total the contract still holds\r\n    //  1) Contract Tokens allocated to Founder Pool\r\n    //  2) Contract Tokens allocated to Stable Pool\r\n    //  3) Contract Tokens allocated to Private Airdrop Pool\r\n    //  4) Contract Tokens allocated to Presale/Liquidity Pool\r\n    function getTokenPoolSizes() public view returns(uint256,uint256,uint256,uint256,uint256)\r\n    {\r\n        return (balanceOf(address(this)), _founderTokens, _stableTokens, _privateSaleTokens, _presaleAndLiquidityTokens);\r\n    }\r\n\r\n    // Return the current tracking of the size of initial tokens created in pools as well as taxed pools...\r\n    // Values:\r\n    //  1) Marketing Tokens Held by the contract\r\n    //  2) Participatory Tokens Held by the contract\r\n    //  3) Vetter Tokens Held by the contract\r\n    //  4) Liquidity Tokens Held by the contract\r\n    //  5) Royalty Tokens Held by the contract\r\n    //  6) Royalty Tokens Not Distributed Yet\r\n    function getTaxPoolSizes() public view returns(uint256,uint256,uint256,uint256,uint256,uint256)\r\n    {\r\n        return (_marketingTokens, _participitoryTokens, _vetterTokens, _liquidityTokens, _royaltyTokens, _royaltyUndistributed);\r\n    }\r\n\r\n    function isExcludedFromFee(address account) external view returns (bool)\r\n    {\r\n        return _isExcludedFromFee[account];\r\n    }\r\n\r\n    event ExcludeFromFee(address wallet);\r\n\r\n    function excludeFromFee(address account) external onlyArchitect\r\n    {\r\n        _isExcludedFromFee[account] = true;\r\n        emit ExcludeFromFee(account);\r\n    }\r\n\r\n    event IncludeInFee(address wallet);\r\n\r\n    function includeInFee(address account) external onlyArchitect\r\n    {\r\n        _isExcludedFromFee[account] = false;\r\n        emit IncludeInFee(account);\r\n    }\r\n\r\n    function getSellBnBAmount(uint256 tokenAmount) public view returns (uint256)\r\n    {\r\n        address[] memory path = new address[](2);\r\n\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(tokenAmount, path);\r\n\r\n        return amounts[1];\r\n    }\r\n\r\n    // Used to get BNB from the contract...\r\n    function transferBNBToAddress(address payable recipient, uint256 amount) private\r\n    {\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    function getPairAddress() external view onlyArchitect returns (address)\r\n    {\r\n        return uniswapV2Pair;\r\n    }\r\n\r\n    event ChangeRouter(address router, address pair);\r\n\r\n    // Used when Pancake Swap is upgraded to a new version...\r\n    function changeRouterVersion(address _router) external onlyArchitect returns (address _pair)\r\n    {\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(_router);\r\n\r\n        _pair = IUniswapV2Factory(_uniswapV2Router.factory()).getPair(address(this), _uniswapV2Router.WETH());\r\n        if (_pair == address(0))\r\n        {\r\n            // Pair doesn't exist\r\n            _pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        }\r\n\r\n        // Set the router/pair of the contract variables\r\n        uniswapV2Pair = _pair;\r\n        uniswapV2Router = _uniswapV2Router;\r\n        _isExcludedFromFee[address(uniswapV2Router)] = true;\r\n        emit ChangeRouter(address(uniswapV2Router), address(uniswapV2Pair));\r\n    }\r\n\r\n    function setPresaleAddress(address who) external onlyArchitect\r\n    {\r\n        presaleAddress = who;\r\n        _isExcludedFromFee[who] = true;\r\n    }\r\n\r\n    event TransferForeignTokens(address token, address to, uint256 amount);\r\n\r\n    // Used to get random tokens sent to this address out to a wallet...\r\n    function transferForeignToken(address _token, address _to) external onlyArchitect returns (bool _sent)\r\n    {\r\n        require(_token != address(this), \"Can't let you take all native token\");\r\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\r\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\r\n        if(_sent) emit TransferForeignTokens(_token, _to, _contractBalance);\r\n    }\r\n\r\n    function _setRankContract(address _contractAddress) external onlyArchitect\r\n    {\r\n        _rankContract = _contractAddress;\r\n    }\r\n\r\n    // Is wallet in list of architects\r\n    function isArchitect(address who) public view returns(bool)\r\n    {\r\n        return _architects[who];\r\n    }\r\n\r\n    // Add a new wallet address to list\r\n    function addArchitect(address who, uint256 percentage) external onlyArchitect\r\n    {\r\n        require(percentage <= 100,\"Bad Percentage Provided\");\r\n        require(!_architects[who],\"Architect Already Added\");\r\n\r\n        _architects[who] = true;\r\n        //_founderList.push(Founder(payable(who), percentage));\r\n        _numberOfFounders = _numberOfFounders + 1;\r\n        _founderList[_numberOfFounders] = Founder(payable(who), percentage);\r\n\r\n        _isExcludedFromFee[who] = true;\r\n        addOrAdjustVetter(who, true);\r\n\r\n        if(_royaltyIndex[who] > 0) return;\r\n        _royaltyIndex[who] = getTime();\r\n        _numRoyaltyHolders = _numRoyaltyHolders + 1;\r\n    }\r\n\r\n    // Remove a wallet address from list\r\n    function removeArchitect(address who) external onlyArchitect\r\n    {\r\n        require(_architects[who],\"Not an Architect\");\r\n\r\n        _architects[who] = false;\r\n        _removeVetter(who);\r\n\r\n        for(uint256 index = 1; index <= _numberOfFounders; index++)\r\n        {\r\n            // Find the entry in the list...\r\n            if(_founderList[index]._founder == who)\r\n            {\r\n                // Move the last entry to this position...\r\n                _founderList[index] = _founderList[_numberOfFounders];\r\n                // Remove the last element to shrink the array down...\r\n                _numberOfFounders = _numberOfFounders - 1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Add a new wallet address to list\r\n    function adjustArchitect(address who, uint256 percentage) external onlyArchitect\r\n    {\r\n        require(percentage <= 100,\"Bad Percentage Provided\");\r\n        require(_architects[who],\"Not an Architect\");\r\n\r\n        for(uint256 index = 1; index <= _numberOfFounders; index++)\r\n        {\r\n            // Find the entry in the list...\r\n            if(_founderList[index]._founder == who)\r\n            {\r\n                _founderList[index]._percentage = percentage;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function distributeFounderTokens() external onlyArchitect\r\n    {\r\n        require(isFounderPercentageValid(), \"Founder percentages are not set to 100%\");\r\n\r\n        // First check if we are past the initial lock period...\r\n        if(getTime() < _timeTokenLaunched + _initialFounderLock) return;\r\n\r\n        uint256 totalUnlocked = 0;\r\n        uint256 periods = 0;\r\n        while((totalUnlocked < 100) && (getTime() > (_timeTokenLaunched + _initialFounderLock + (_founderRelease * periods))))\r\n        {\r\n            totalUnlocked = totalUnlocked + _founderPercentPerPeriod;\r\n            periods++;\r\n        }\r\n\r\n        if(periods < 1) return;\r\n\r\n        // We may have sent some out already...so determine how many we can give out that are left now...\r\n        // Use FounderCurrent - ShouldBeRemaining where ShouldBeRemaining = InitialAmount - AmountToDistribute\r\n        // where AmountToDistribute = NumberOfPeriods * TokensPerPeriod\r\n        // where TokensPerPeriod = PercentageOfOriginal\r\n        uint256 tokensPerPeriod = (_initialFounder * _founderPercentPerPeriod) / 100;\r\n        uint256 tokensToDistribute = _founderTokens - (_initialFounder - (periods * tokensPerPeriod));\r\n\r\n        // Now hand them out...\r\n        for(uint256 index = 1; index <= _numberOfFounders; index++)\r\n        {\r\n            uint256 amount = (tokensToDistribute * _founderList[index]._percentage) / 100;\r\n            _tokensOwned[address(this)] = _tokensOwned[address(this)] - amount;\r\n            _founderTokens = _founderTokens - amount;\r\n            _tokensOwned[_founderList[index]._founder] = _tokensOwned[_founderList[index]._founder] + amount;\r\n            emit Transfer(address(this), _founderList[index]._founder, amount);\r\n        }\r\n    }\r\n\r\n    modifier onlyArchitect()\r\n    {\r\n        require(isArchitect(_msgSender()) || isOwner(_msgSender()), \"Caller is not an architect.\");\r\n        _;\r\n    }\r\n\r\n    function getNumberOfFounders() view external returns(uint256)\r\n    {\r\n        return _numberOfFounders;\r\n    }\r\n\r\n    function _getAllFounders() view public returns(Founder[] memory)\r\n    {\r\n        Founder[] memory founders = new Founder[](_numberOfFounders);\r\n        for(uint256 index = 1; index <= _numberOfFounders; index++)\r\n        {\r\n            founders[index-1] = _founderList[index];\r\n        }\r\n        return founders;\r\n    }\r\n\r\n    // Is wallet in list of admins\r\n    function isAdmin(address who) public view returns(bool)\r\n    {\r\n        return _admins[who] > 0;\r\n    }\r\n\r\n    function isFullAdmin(address who) public view returns(bool)\r\n    {\r\n        return _admins[who] > 1;\r\n    }\r\n\r\n    // Add a new wallet address to list\r\n    function addAdmin(address who, bool full) external onlyArchitect\r\n    {\r\n        if(!isAdmin(who))\r\n        {\r\n            _numberOfAdmins = _numberOfAdmins + 1;\r\n            _adminIndex[_numberOfAdmins] = who;\r\n        }\r\n        if(full) _admins[who] = 2;\r\n        else _admins[who] = 1;\r\n    }\r\n\r\n    // Remove a wallet address from list\r\n    function removeAdmin(address who) external onlyArchitect\r\n    {\r\n        if(!isAdmin(who)) return;\r\n\r\n        _admins[who] = 0;\r\n        for(uint256 index = 1; index <= _numberOfAdmins; index++)\r\n        {\r\n            if(_adminIndex[index] == who)\r\n            {\r\n                // Move the last entry to here in the mapping...\r\n                _adminIndex[index] = _adminIndex[_numberOfAdmins];\r\n                _numberOfAdmins = _numberOfAdmins - 1;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    modifier onlyAdmin()\r\n    {\r\n        require(isFullAdmin(_msgSender()) || isArchitect(_msgSender()) || isOwner(_msgSender()), \"Caller is not an admin.\");\r\n        _;\r\n    }\r\n\r\n    function _getAllAdmins() view public returns(address[] memory)\r\n    {\r\n        address[] memory admins = new address[](_numberOfAdmins);\r\n        for(uint256 index = 1; index <= _numberOfAdmins; index++)\r\n        {\r\n            admins[index-1] = _adminIndex[index];\r\n        }\r\n        return admins;\r\n    }\r\n\r\n    function getNumberOfAdmins() view external returns(uint256)\r\n    {\r\n        return _numberOfAdmins;\r\n    }\r\n\r\n    // Is wallet in list of vetters\r\n    function isVetter(address who) public view returns(bool)\r\n    {\r\n        return _vetters[who] > 0;\r\n    }\r\n\r\n    // Is wallet in list of trial vetters\r\n    function isTrialVetter(address who) public view returns(bool)\r\n    {\r\n        return _vetters[who] == 2;\r\n    }\r\n\r\n    // Is wallet in list of full vetters\r\n    function isFullVetter(address who) public view returns(bool)\r\n    {\r\n        return _vetters[who] == 1;\r\n    }\r\n\r\n    // Add a new wallet address to list\r\n    function addOrAdjustVetter(address who, bool full) public onlyAdmin\r\n    {\r\n        if(!isVetter(who))\r\n        {\r\n            _numberOfVetters = _numberOfVetters + 1;\r\n            _vetterList[_numberOfVetters] = who;\r\n        }\r\n        if(full) _vetters[who] = 1;\r\n        else _vetters[who] = 2;\r\n    }\r\n\r\n    // Prevent admins from removing architects...\r\n    function removeVetter(address who) public onlyAdmin\r\n    {\r\n        if(isArchitect(_msgSender()))\r\n        {\r\n            _removeVetter(who);\r\n            return;\r\n        }\r\n\r\n        require(!isArchitect(who), \"Cannot remove the architects from the list.\");\r\n        _removeVetter(who);\r\n    }\r\n\r\n    // Remove a wallet address from list\r\n    function _removeVetter(address who) internal\r\n    {\r\n        if(!isVetter(who)) return;\r\n\r\n        _vetters[who] = 0;\r\n        for(uint256 index = 1; index <= _numberOfVetters; index++)\r\n        {\r\n            if(_vetterList[index] == who)\r\n            {\r\n                // Move the last entry to here in the mapping...\r\n                _vetterList[index] = _vetterList[_numberOfVetters];\r\n                _numberOfVetters = _numberOfVetters - 1;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getNumberOfVetters() view external returns(uint256)\r\n    {\r\n        return _numberOfVetters;\r\n    }\r\n\r\n    function _getAllVetters() view public returns(address[] memory)\r\n    {\r\n        address[] memory vetters = new address[](_numberOfVetters);\r\n        for(uint256 index = 1; index <= _numberOfVetters; index++)\r\n        {\r\n            vetters[index-1] = _vetterList[index];\r\n        }\r\n        return vetters;\r\n    }\r\n\r\n    function _getAllShareholders() view public returns(address[] memory)\r\n    {\r\n        address[] memory holders = new address[](_numberOfShareholders);\r\n        for(uint256 index = 1; index <= _numberOfShareholders; index++)\r\n        {\r\n            holders[index-1] = _shareHolders[index]._wallet;\r\n        }\r\n        return holders;\r\n    }\r\n\r\n    function addToStableList(address _wallet, uint256 _shares, bool _private, bool _active) external onlyArchitect\r\n    {\r\n        bool active = _active;\r\n        if(_shares == 0) active = false;\r\n\r\n        _numberOfShareholders = _numberOfShareholders + 1;\r\n        _shareHolderIndex[_wallet] = _numberOfShareholders;\r\n        _shareHolders[_numberOfShareholders] = Share(_wallet, _shares, _private, active, 0);\r\n    }\r\n\r\n    function getStableListEntry(address who) view external returns(uint256, bool, bool, uint256)\r\n    {\r\n        Share memory s = _shareHolders[_shareHolderIndex[who]];\r\n        return (s._shares, s._private, s._active, s._minTokens);\r\n    }\r\n\r\n    function adjustStableListEnrty(address _wallet, uint256 _shares, bool _private, bool _active, uint256 _minTokens) external onlyArchitect\r\n    {\r\n        bool active = _active;\r\n        if(_shares == 0) active = false;\r\n\r\n        _shareHolders[_shareHolderIndex[_wallet]]._shares = _shares;\r\n        _shareHolders[_shareHolderIndex[_wallet]]._private = _private;\r\n        _shareHolders[_shareHolderIndex[_wallet]]._active = active;\r\n        _shareHolders[_shareHolderIndex[_wallet]]._minTokens = _minTokens;\r\n    }\r\n\r\n    function getStableShares() public view returns(uint256)\r\n    {\r\n        uint256 shares = 0;\r\n        for(uint256 index = 1; index <= _numberOfShareholders; index++)\r\n        {\r\n            if(_shareHolders[index]._active) shares = shares + _shareHolders[index]._shares;\r\n        }\r\n        return shares;\r\n    }\r\n\r\n    function getPrivateShares() public view returns(uint256)\r\n    {\r\n        uint256 shares = 0;\r\n        for(uint256 index = 1; index <= _numberOfShareholders; index++)\r\n        {\r\n            if(_shareHolders[index]._active && _shareHolders[index]._private) shares = shares + _shareHolders[index]._shares;\r\n        }\r\n        return shares;\r\n    }\r\n\r\n    function distributeStableTokens() external onlyArchitect\r\n    {\r\n        require(_stableTokens > 0, \"Stable Token Distribution Already Happened\");\r\n\r\n        // First check if we are past the lock period...\r\n        if(getTime() < _timeTokenLaunched + (_stableRelease * (_stablePeriod + 1))) return;\r\n\r\n        _stablePeriod = _stablePeriod + 1;\r\n\r\n        uint256 tokensThisPeriod = (_initialStable * (_stablePeriod * _stablePercent)) / 100;\r\n        uint256 tokensPerShare = tokensThisPeriod / getStableShares();\r\n\r\n        // Now hand them out...\r\n        for(uint256 index = 1; index <= _numberOfShareholders; index++)\r\n        {\r\n            if(_shareHolders[index]._active)\r\n            {\r\n                uint256 amount = tokensPerShare * _shareHolders[index]._shares;\r\n                _tokensOwned[_shareHolders[index]._wallet] = _tokensOwned[_shareHolders[index]._wallet] + amount;\r\n                _tokensOwned[address(this)] = _tokensOwned[address(this)] - amount;\r\n                _stableTokens = _stableTokens - amount;\r\n                _shareHolders[index]._minTokens = _shareHolders[index]._minTokens + amount;\r\n                emit Transfer(address(this), _shareHolders[index]._wallet, amount);\r\n            }\r\n        }\r\n\r\n        // Be sure on the final stage that all of the tokens were distributed...\r\n        if(_stablePeriod > 3 && _stableTokens > 0)\r\n        {\r\n            _participitoryTokens = _participitoryTokens + _stableTokens;\r\n            _stableTokens = 0;\r\n        }\r\n    }\r\n\r\n    function airdropPrivateTokens() external onlyArchitect\r\n    {\r\n        require(_privateSaleTokens > 0, \"AirDrop Already Happened\");\r\n\r\n        uint256 tokensPerShare = _privateSaleTokens / getPrivateShares();\r\n\r\n        // Now hand them out...\r\n        for(uint256 index = 1; index <= _numberOfShareholders; index++)\r\n        {\r\n            if(_shareHolders[index]._private)\r\n            {\r\n                uint256 amount = tokensPerShare * _shareHolders[index]._shares;\r\n                _tokensOwned[address(this)] = _tokensOwned[address(this)] - amount;\r\n                _privateSaleTokens = _privateSaleTokens - amount;\r\n                _tokensOwned[_shareHolders[index]._wallet] = _tokensOwned[_shareHolders[index]._wallet] + amount;\r\n                _shareHolders[index]._minTokens = _shareHolders[index]._minTokens + amount;\r\n                emit Transfer(address(this), _shareHolders[index]._wallet, amount);\r\n            }\r\n        }\r\n        // Should not be any left, but make sure it is cleared out...\r\n        if(_privateSaleTokens > 0)\r\n        {\r\n            _participitoryTokens = _participitoryTokens + _privateSaleTokens;\r\n            _privateSaleTokens = 0;\r\n        }\r\n    }\r\n\r\n    // Return the number of tiers currently in use\r\n    function _getMaxTier() view public returns(uint256)\r\n    {\r\n        return _numberOfTiers;\r\n    }\r\n\r\n    // Get the number of tokens needed at a specified Tier\r\n    function _getTierLevel(uint256 level) view public returns(uint256)\r\n    {\r\n        require(level <= _getMaxTier(),\"Not a Valid Tier Level\");\r\n        return _tiers[level];\r\n    }\r\n\r\n    // Get the token counts for all tier levels\r\n    function _getAllTiers() view public returns(uint256[] memory)\r\n    {\r\n        uint256 maxTier = _getMaxTier();\r\n        uint256[] memory tierLevels = new uint256[](maxTier + 1);\r\n        for(uint256 level = 0; level <= maxTier; level++)\r\n        {\r\n            tierLevels[level] = _tiers[level];\r\n        }\r\n        return tierLevels;\r\n    }\r\n\r\n    event TierLevelChanged(uint256 tier, uint256 newLevel);\r\n\r\n    // Set the number of tokens needed at a specified Tier\r\n    function _setTierLevel(uint256 level, uint256 newAmount) external onlyArchitect\r\n    {\r\n        require(level <= _getMaxTier(),\"Not a Valid Tier Level\");\r\n        _tiers[level] = newAmount;\r\n        emit TierLevelChanged(level, newAmount);\r\n    }\r\n\r\n    // Add to tier count and set the number of tokens needed\r\n    function _addNewTier(uint256 newAmount) external onlyArchitect\r\n    {\r\n        _numberOfTiers = _numberOfTiers + 1;\r\n        _tiers[_numberOfTiers] = newAmount;\r\n        emit TierLevelChanged(_numberOfTiers, newAmount);\r\n    }\r\n\r\n    // Return the Tier of a wallet address by tokens held\r\n    function _getWalletTier(address who) view public returns(uint256)\r\n    {\r\n        uint256 whoBal = balanceOf(who);\r\n        if(whoBal > 0)\r\n        {\r\n            for(uint256 level = _getMaxTier(); level > 0; level--)\r\n            {\r\n                if(whoBal > _getTierLevel(level)) return level;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // Return Tier and Access Information (wallet tier, owner, architect, admin, reviewer, trial vetter, full vetter, active in stable pool)\r\n    function _getUserInfo(address who) view external returns(uint256, uint256, bool, bool, bool, bool, bool)\r\n    {\r\n        return (_getWalletTier(who), _tokensOwned[who], isArchitect(who), isFullAdmin(who), isAdmin(who), isTrialVetter(who), isFullVetter(who));\r\n    }\r\n\r\n    function addToRoyaltyHolders(address who) external onlyRankContract\r\n    {\r\n        if(_royaltyIndex[who] > 0) return;\r\n\r\n        _royaltyIndex[who] = getTime();\r\n        _numRoyaltyHolders = _numRoyaltyHolders + 1;\r\n    }\r\n\r\n    event RoyaltyDistribution(uint256 amount, uint256 timeAdded);\r\n\r\n    function distributeRoyaltyTokens() external onlyArchitect\r\n    {\r\n        require(_royaltyUndistributed > 0 && _royaltyTokens > 0, \"Nothing to Distribute\");\r\n        require(_numRoyaltyHolders > 0, \"Noone to Distribute to\");\r\n        uint256 amount = _royaltyUndistributed / _numRoyaltyHolders;\r\n        _royaltyUndistributed = _royaltyUndistributed - (amount * _numRoyaltyHolders);  // Account for a division remainder\r\n        _numberOfDistributions = _numberOfDistributions + 1;\r\n        _distributions[_numberOfDistributions] = Royalties(getTime(), amount);\r\n        emit RoyaltyDistribution(amount, getTime());\r\n    }\r\n\r\n    function checkRoyaltyAmount() public view returns(uint256)\r\n    {\r\n        uint256 lastTime = _royaltyIndex[_msgSender()];\r\n        if(lastTime < 1) return 0;\r\n\r\n        uint256 available = 0;\r\n        for(uint256 index = 1; index <= _numberOfDistributions; index++)\r\n        {\r\n            if(_distributions[index].whenAvailable > lastTime) available = available + _distributions[index].amountToClaim;\r\n        }\r\n        return available;\r\n    }\r\n\r\n    function getRoyaltyAmount(address who) public view returns(uint256)\r\n    {\r\n        uint256 lastTime = _royaltyIndex[who];\r\n        if(lastTime < 1) return 0;\r\n\r\n        uint256 available = 0;\r\n        for(uint256 index = 1; index <= _numberOfDistributions; index++)\r\n        {\r\n            if(_distributions[index].whenAvailable > lastTime) available = available + _distributions[index].amountToClaim;\r\n        }\r\n        return available;\r\n    }\r\n\r\n    event RoyaltyClaimed(address indexed to, uint256 received);\r\n\r\n    function claimRoyalties() external\r\n    {\r\n        require(_royaltyIndex[_msgSender()] > 0, \"Not a Royalty Holder\");\r\n        require(_getWalletTier(_msgSender()) > _royaltyTierRequired, \"Must Meet Tier Requirement To Claim\");\r\n        uint256 amount = checkRoyaltyAmount();\r\n        require(amount > 0, \"No Royalty To Claim\");\r\n\r\n        _tokensOwned[address(this)] = _tokensOwned[address(this)] - amount;\r\n        _royaltyTokens = _royaltyTokens - amount;\r\n        _tokensOwned[_msgSender()] = _tokensOwned[_msgSender()] + amount;\r\n        _royaltyIndex[_msgSender()] = getTime();\r\n        emit Transfer(address(this), _msgSender(), amount);\r\n        emit RoyaltyClaimed(_msgSender(), amount);\r\n    }\r\n\r\n    event RoyaltyTierChanged(uint256 newTier, uint256 tokenNeeed);\r\n\r\n    function setMinRoyaltyTier(uint256 tierLevel) external onlyArchitect\r\n    {\r\n        require(tierLevel <= _getMaxTier(), \"Invalid Tier Level\");\r\n        _royaltyTierRequired = tierLevel;\r\n        emit RoyaltyTierChanged(tierLevel, _getTierLevel(tierLevel));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"participatory\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vetter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"name\":\"BuyTaxesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"ChangeRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"ExcludeFromFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"IncludeInFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVetterTax\",\"type\":\"uint256\"}],\"name\":\"LaunchTaxChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensAdded\",\"type\":\"uint256\"}],\"name\":\"LiquidityAddedToLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"}],\"name\":\"MarketingPoolSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ParticipitoryRewarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"RoyaltyClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeAdded\",\"type\":\"uint256\"}],\"name\":\"RoyaltyDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenNeeed\",\"type\":\"uint256\"}],\"name\":\"RoyaltyTierChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"participatory\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vetter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royalty\",\"type\":\"uint256\"}],\"name\":\"SellTaxesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SetVetterAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"TaxesEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLevel\",\"type\":\"uint256\"}],\"name\":\"TierLevelChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TipSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferForeignTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSentToInvestmentPool\",\"type\":\"uint256\"}],\"name\":\"VetterPoolSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"VetterRewarded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"_addNewTier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getAllAdmins\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getAllFounders\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"_founder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"internalType\":\"struct VetterToken.Founder[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getAllShareholders\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getAllTiers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getAllVetters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getMaxTier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"_getTierLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"_getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"_getWalletTier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"_setRankContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"_setTierLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"full\",\"type\":\"bool\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"addArchitect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityPoolTokensToLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"full\",\"type\":\"bool\"}],\"name\":\"addOrAdjustVetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"addToRoyaltyHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_private\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"addToStableList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"adjustArchitect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_private\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_minTokens\",\"type\":\"uint256\"}],\"name\":\"adjustStableListEnrty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropPrivateTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"changeRouterVersion\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkRoyaltyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeFounderTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeRoyaltyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeStableTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfAdmins\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfFounders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfVetters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrivateShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getRoyaltyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getSellBnBAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getStableListEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStableShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTaxPoolSizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPoolSizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBuyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isArchitect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isFullAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isFullVetter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isTrialVetter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isVetter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"removeArchitect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"removeVetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rewardParticipatory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rewardVetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketingBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"participatoryBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"participatorySell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vetterBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vetterSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltyBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltySell\",\"type\":\"uint256\"}],\"name\":\"setAllTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setInitialLaunchTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tierLevel\",\"type\":\"uint256\"}],\"name\":\"setMinRoyaltyTier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"setPresaleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vetterAddress\",\"type\":\"address\"}],\"name\":\"setVetterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"vetter\",\"type\":\"uint256\"}],\"name\":\"setVetterReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapMarketingPoolTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swapVetterPoolTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"takeTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferForeignToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferTipAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "VetterToken", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cc7fa0643ad1482e74a0dae730c09fe40b6c435b3fb6ed31161c6fdde81c5d72"}