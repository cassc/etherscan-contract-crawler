{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >= 0.8.0 <0.9.0;\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File: contracts/standards/ERC165.sol\r\n\r\n\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\n\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\n// File: contracts/interfaces/IERC2981.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ninterface IERC2981 is IERC165 {\r\n    function royaltyInfo(\r\n        uint256 tokenId,\r\n        uint256 salePrice\r\n    ) external view returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n\r\ninterface IERC721VirtualAsset is IERC721, IERC2981 {\r\n     function mintTo(address _to, address _royaltyReceiver)  external;\r\n     function mintTo(address _to, address _royaltyReceiver, bytes memory data)  external;\r\n}\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IERC1155VirtualAsset is IERC1155 {\r\n    function mintTo( address _to, uint256 _tokenId, uint256 _amount)  external;\r\n    function mintTo( address _to, uint256 _tokenId, uint256 _amount, bytes memory data)  external;\r\n}\r\n\r\nlibrary Counters {\r\n    struct Counter {\r\n        uint256 _value;\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\ncontract TokenAccessControl {\r\n    bool public paused = false;\r\n    address public owner;\r\n    address public newContractOwner;\r\n    mapping(address => bool) public authorizedContracts;\r\n\r\n    event Pause();\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier ifNotPaused() {\r\n        require(!paused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"caller is not an owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorizedUser() {\r\n        require(\r\n            authorizedContracts[msg.sender],\r\n            \"caller is not an authorized user\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrAuthorizedUser() {\r\n        require(\r\n            authorizedContracts[msg.sender] || msg.sender == owner,\r\n            \"caller is not an authorized user or an owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        newContractOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public ifNotPaused {\r\n        require(msg.sender == newContractOwner);\r\n        emit OwnershipTransferred(owner, newContractOwner);\r\n        owner = newContractOwner;\r\n        newContractOwner = address(0);\r\n    }\r\n\r\n    function setAuthorizedUser(\r\n        address _operator,\r\n        bool _approve\r\n    ) public onlyOwner {\r\n        if (_approve) {\r\n            authorizedContracts[_operator] = true;\r\n        } else {\r\n            delete authorizedContracts[_operator];\r\n        }\r\n    }\r\n\r\n    function setPause(bool _paused) public onlyOwner {\r\n        paused = _paused;\r\n        if (paused) {\r\n            emit Pause();\r\n        }\r\n    }\r\n}\r\n\r\ncontract MarketMinting is TokenAccessControl, ERC1155Holder, ERC721Holder {\r\n    using Counters for Counters.Counter;\r\n    struct Offer {\r\n        address nftAddress;\r\n        uint256 nftTokenId; // 0 for erc721\r\n        uint256 amount; // always 1 for erc721\r\n        address paymentTokenAddress;\r\n        uint256 price;\r\n        uint256 fee;\r\n        address seller;\r\n        address buyer;\r\n        address royaltyReceiver;\r\n        uint createdAtBlock;\r\n        bytes nftRawData;\r\n    }\r\n    Counters.Counter private offerId;\r\n    mapping(uint256 => Offer) offers;\r\n\r\n    uint _offerValidityBlocks = 100;\r\n   \r\n    bytes4 constant private IERC165_ID = 0x01ffc9a7;\r\n    bytes4 constant private IERC1155_ID = 0xd9b67a26;\r\n    bytes4 constant private IERC721_ID = 0x80ac58cd;\r\n    bytes4 constant private IERC2981_ID = 0x2a55205a;\r\n\r\n    event CreateMarketMintingOffer(uint256 indexed offerId, address nftAddress, uint256 nftTokenId, uint256 amount,\r\n     address paymentTokenAddress, uint256 price, uint256 fee, address seller, address buyer, address royaltyReceiver, bytes rawNftData);\r\n    event BuyMarketMintingOffer(uint256 indexed offerId, address nftAddress, uint256 nftTokenId,\r\n     uint256 amount, address paymentTokenAddress, uint256 price, address seller, address buyer, address royaltyReceiver);\r\n    event CancelMarketMintingOffer(uint256 indexed offerId, address nftAddress, uint256 nftTokenId, uint256 amount, address seller, address buyer);\r\n    event RoyaltyPayment(address from, address indexed to, address indexed tokenAddress, uint256 indexed amount, address nftAddress, uint256 tokenId);\r\n\r\n\r\n    constructor(){\r\n        offerId._value=300;\r\n    }\r\n    \r\n    function createOffer(address nftAddress, uint256 nftTokenId, uint256 amount, address paymentTokenAddress,\r\n     uint256 price, uint256 fee, address seller, address buyer, address royaltyReceiver, bytes memory rawNftData) external onlyOwner returns (uint256 _offerId) {\r\n        offerId.increment();\r\n        require(price>0, \"Market: price should be greater than 0\");\r\n        require(fee>=0, \" Market: fee cannot be negative\");\r\n        require(fee<price, \"Market: fee cannot be greater than price\");\r\n        offers[offerId.current()] = Offer(nftAddress, nftTokenId, amount, paymentTokenAddress, price, fee, seller, buyer, royaltyReceiver, block.number, rawNftData);\r\n\r\n        emit CreateMarketMintingOffer(offerId.current(), nftAddress, nftTokenId, amount, paymentTokenAddress, price, fee,  seller, buyer, royaltyReceiver,\r\n        rawNftData);\r\n        return offerId.current();\r\n    }\r\n\r\n    function buyOffer(uint256 _offerId) external payable {\r\n        Offer memory offer = offers[_offerId];\r\n        require(offer.seller != address(0), \"Market: offer is not valid\");\r\n        require(offer.buyer == msg.sender, \"Market: you are not eligible to buy this offer\");\r\n        require(offer.createdAtBlock+_offerValidityBlocks >= block.number, \"Market: offer is not valid\");\r\n        delete offers[_offerId];\r\n        uint256 royaltyAmount = 0;\r\n        address royaltyReceiver = address(0);\r\n        uint256 priceAfterFee = offer.price - offer.fee;\r\n\r\n        if(IERC165(offer.nftAddress).supportsInterface(IERC1155_ID)){\r\n            if(offer.nftRawData.length == 0){\r\n                IERC1155VirtualAsset(offer.nftAddress).mintTo(msg.sender, offer.nftTokenId, offer.amount);\r\n            }\r\n            else{\r\n                IERC1155VirtualAsset(offer.nftAddress).mintTo(msg.sender, offer.nftTokenId, offer.amount, offer.nftRawData);\r\n            }\r\n        }\r\n        else{\r\n            if(offer.nftRawData.length == 0){\r\n                IERC721VirtualAsset(offer.nftAddress).mintTo(msg.sender, offer.royaltyReceiver);\r\n            }\r\n            else{\r\n                IERC721VirtualAsset(offer.nftAddress).mintTo(msg.sender, offer.royaltyReceiver, offer.nftRawData);\r\n            }\r\n        }\r\n\r\n        (royaltyReceiver, royaltyAmount) = getRoyaltyInfo(offer.nftAddress, offer.nftTokenId, priceAfterFee);\r\n        \r\n        if(offer.paymentTokenAddress!=address(0)){\r\n            IERC20(offer.paymentTokenAddress).transferFrom(msg.sender, offer.seller, priceAfterFee-royaltyAmount);\r\n            if(royaltyAmount != 0){\r\n                IERC20(offer.paymentTokenAddress).transferFrom(msg.sender, royaltyReceiver, royaltyAmount);\r\n                emit RoyaltyPayment(msg.sender, royaltyReceiver, offer.paymentTokenAddress, royaltyAmount, offer.nftAddress,\r\n                offer.nftTokenId);\r\n            }\r\n            if(offer.fee!=0){\r\n                IERC20(offer.paymentTokenAddress).transferFrom(msg.sender, address(this), offer.fee);\r\n            }\r\n        }\r\n        else{\r\n            require(msg.value >= offer.price, \"Market: insufficient value has been sent\");\r\n            if(priceAfterFee-royaltyAmount>0){\r\n                payable(offer.seller).transfer(priceAfterFee-royaltyAmount);\r\n            }\r\n            if(royaltyAmount > 0){\r\n                payable(royaltyReceiver).transfer(royaltyAmount);\r\n                emit RoyaltyPayment(msg.sender, royaltyReceiver, offer.paymentTokenAddress, royaltyAmount, offer.nftAddress,\r\n                offer.nftTokenId);\r\n            }\r\n        }\r\n        emit BuyMarketMintingOffer(_offerId, offer.nftAddress, offer.nftTokenId, offer.amount, offer.paymentTokenAddress, offer.price,\r\n        offer.seller, offer.buyer, offer.royaltyReceiver);\r\n    }\r\n\r\n    function cancelOffer(uint256 _offerId) public onlyOwner{\r\n        require(offers[_offerId].seller != address(0), \"Market: offer is not valid\");\r\n        Offer memory offer = offers[_offerId];\r\n        delete offers[_offerId];\r\n        emit CancelMarketMintingOffer(_offerId, offer.nftAddress, offer.nftTokenId, offer.amount, offer.seller, offer.buyer);\r\n    }\r\n\r\n    function getOffer(uint256 _offerId) public view returns(Offer memory){\r\n        return offers[_offerId];\r\n    }\r\n\r\n    function setOfferValidity(uint blockCountValidity) public onlyOwner{\r\n        _offerValidityBlocks = blockCountValidity;\r\n    }\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n\r\n    fallback() external payable {\r\n\r\n    }\r\n\r\n    function withdraw(address contractAddress, uint16 standard, uint256 tokenId, uint256 amount) public onlyOwner{\r\n        if(contractAddress==address(0)){\r\n            payable(msg.sender).transfer(amount);\r\n        }\r\n        else if(standard==20){\r\n            if(amount==0) amount = IERC20(contractAddress).balanceOf(address(this));\r\n            IERC20(contractAddress).transfer(msg.sender, amount);\r\n        }\r\n        else if(standard==721){\r\n            IERC721(contractAddress).safeTransferFrom(address(this), msg.sender, tokenId);\r\n        }\r\n        else if(standard==1155){\r\n            if(amount==0) amount = IERC1155(contractAddress).balanceOf(address(this), tokenId);\r\n            IERC1155(contractAddress).safeTransferFrom(address(this), msg.sender, tokenId, amount, \"\");\r\n        }\r\n    }\r\n\r\n    function getRoyaltyInfo(address contractAddress, uint256 tokenId, uint256 price) internal view returns(address, uint256){\r\n        (bool isSuccess, bytes memory response) = contractAddress.staticcall(abi.encodeWithSignature(\"supportsInterface(bytes4)\",IERC2981_ID));\r\n        if(isSuccess && abi.decode(response, (bool))){\r\n            return IERC2981(contractAddress).royaltyInfo(tokenId, price);\r\n        }\r\n        return (address(0), 0);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"}],\"name\":\"BuyMarketMintingOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"CancelMarketMintingOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"offerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"rawNftData\",\"type\":\"bytes\"}],\"name\":\"CreateMarketMintingOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"RoyaltyPayment\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"buyOffer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"rawNftData\",\"type\":\"bytes\"}],\"name\":\"createOffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_offerId\",\"type\":\"uint256\"}],\"name\":\"getOffer\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"createdAtBlock\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"nftRawData\",\"type\":\"bytes\"}],\"internalType\":\"struct MarketMinting.Offer\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newContractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approve\",\"type\":\"bool\"}],\"name\":\"setAuthorizedUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockCountValidity\",\"type\":\"uint256\"}],\"name\":\"setOfferValidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"standard\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MarketMinting", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e14a2e98bc5108ccb690395274df0bd52c475efd6ef0ad0427ee4d2ad157131b"}