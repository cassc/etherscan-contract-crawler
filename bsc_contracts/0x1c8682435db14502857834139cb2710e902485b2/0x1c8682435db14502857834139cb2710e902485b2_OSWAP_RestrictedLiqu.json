{"SourceCode": "// Sources flattened with hardhat v2.6.4 https://hardhat.org\r\n\r\n// File contracts/restricted/interfaces/IOSWAP_RestrictedLiquidityProvider.sol\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity =0.6.11;\r\n\r\ninterface IOSWAP_RestrictedLiquidityProvider {\r\n\r\n    function factory() external view returns (address);\r\n    function WETH() external view returns (address);\r\n    function govToken() external view returns (address);\r\n    function configStore() external view returns (address);\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool addingTokenA,\r\n        uint256 pairIndex,\r\n        uint256 offerIndex,\r\n        uint256 amountIn,\r\n        bool locked,\r\n        uint256 restrictedPrice,\r\n        uint256 startDate,\r\n        uint256 expire,\r\n        uint256 deadline\r\n    ) external returns (address pair, uint256 _offerIndex);\r\n    function addLiquidityETH(\r\n        address tokenA,\r\n        bool addingTokenA,\r\n        uint256 pairIndex,\r\n        uint256 offerIndex,\r\n        uint256 amountAIn,\r\n        bool locked,\r\n        uint256 restrictedPrice,\r\n        uint256 startDate,\r\n        uint256 expire,\r\n        uint256 deadline\r\n    ) external payable returns (address pair, uint256 _offerIndex);\r\n    function addLiquidityAndTrader(\r\n        uint256[11] calldata param, \r\n        address[] calldata trader, \r\n        uint256[] calldata allocation\r\n    ) external returns (address pair, uint256 offerIndex);\r\n    function addLiquidityETHAndTrader(\r\n        uint256[10] calldata param, \r\n        address[] calldata trader, \r\n        uint256[] calldata allocation\r\n    ) external payable returns (address pair, uint256 offerIndex);\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool removingTokenA,\r\n        address to,\r\n        uint256 pairIndex,\r\n        uint256 offerIndex,\r\n        uint256 amountOut,\r\n        uint256 receivingOut,\r\n        uint256 deadline\r\n    ) external;\r\n    function removeLiquidityETH(\r\n        address tokenA,\r\n        bool removingTokenA,\r\n        address to,\r\n        uint256 pairIndex,\r\n        uint256 offerIndex,\r\n        uint256 amountOut,\r\n        uint256 receivingOut,\r\n        uint256 deadline\r\n    ) external;\r\n    function removeAllLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        address to,\r\n        uint256 pairIndex,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n    function removeAllLiquidityETH(\r\n        address tokenA,\r\n        address to,\r\n        uint256 pairIndex,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n}\r\n\r\n\r\n// File contracts/commons/interfaces/IOSWAP_PausablePair.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\ninterface IOSWAP_PausablePair {\r\n    function isLive() external view returns (bool);\r\n    function factory() external view returns (address);\r\n\r\n    function setLive(bool _isLive) external;\r\n}\r\n\r\n\r\n// File contracts/restricted/interfaces/IOSWAP_RestrictedPair.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\ninterface IOSWAP_RestrictedPair is IOSWAP_PausablePair {\r\n\r\n    struct Offer {\r\n        address provider;\r\n        bool locked;\r\n        bool allowAll;\r\n        uint256 amount;\r\n        uint256 receiving;\r\n        uint256 restrictedPrice;\r\n        uint256 startDate;\r\n        uint256 expire;\r\n    } \r\n\r\n    event NewProviderOffer(address indexed provider, bool indexed direction, uint256 index, bool allowAll, uint256 restrictedPrice, uint256 startDate, uint256 expire);\r\n    event AddLiquidity(address indexed provider, bool indexed direction, uint256 indexed index, uint256 amount, uint256 newAmountBalance);\r\n    event Lock(bool indexed direction, uint256 indexed index);\r\n    event RemoveLiquidity(address indexed provider, bool indexed direction, uint256 indexed index, uint256 amountOut, uint256 receivingOut, uint256 newAmountBalance, uint256 newReceivingBalance);\r\n    event Swap(address indexed to, bool indexed direction, uint256 amountIn, uint256 amountOut, uint256 tradeFee, uint256 protocolFee);\r\n    event SwappedOneOffer(address indexed provider, bool indexed direction, uint256 indexed index, uint256 price, uint256 amountOut, uint256 amountIn, uint256 newAmountBalance, uint256 newReceivingBalance);\r\n\r\n    event ApprovedTrader(bool indexed direction, uint256 indexed offerIndex, address indexed trader, uint256 allocation);\r\n\r\n    function counter(bool direction) external view returns (uint256);\r\n    function offers(bool direction, uint256 i) external view returns (\r\n        address provider,\r\n        bool locked,\r\n        bool allowAll,\r\n        uint256 amount,\r\n        uint256 receiving,\r\n        uint256 restrictedPrice,\r\n        uint256 startDate,\r\n        uint256 expire\r\n    );\r\n\r\n    function providerOfferIndex(bool direction, address provider, uint256 i) external view returns (uint256 index);\r\n    function approvedTrader(bool direction, uint256 offerIndex, uint256 i) external view returns (address trader);\r\n    function isApprovedTrader(bool direction, uint256 offerIndex, address trader) external view returns (bool);\r\n    function traderAllocation(bool direction, uint256 offerIndex, address trader) external view returns (uint256 amount);\r\n\r\n    function governance() external view returns (address);\r\n    function whitelistFactory() external view returns (address);\r\n    function restrictedLiquidityProvider() external view returns (address);\r\n    function govToken() external view returns (address);\r\n    function configStore() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function scaleDirection() external view returns (bool);\r\n    function scaler() external view returns (uint256);\r\n\r\n    function lastGovBalance() external view returns (uint256);\r\n    function lastToken0Balance() external view returns (uint256);\r\n    function lastToken1Balance() external view returns (uint256);\r\n    function protocolFeeBalance0() external view returns (uint256);\r\n    function protocolFeeBalance1() external view returns (uint256);\r\n    function feeBalance() external view returns (uint256);\r\n\r\n    function initialize(address _token0, address _token1) external;\r\n\r\n    function getProviderOfferIndexLength(address provider, bool direction) external view returns (uint256);\r\n    function getTraderOffer(address trader, bool direction, uint256 start, uint256 length) external view returns (uint256[] memory index, address[] memory provider, bool[] memory lockedAndAllowAll, uint256[] memory receiving, uint256[] memory amountAndPrice, uint256[] memory startDateAndExpire);\r\n    function getProviderOffer(address _provider, bool direction, uint256 start, uint256 length) external view returns (uint256[] memory index, address[] memory provider, bool[] memory lockedAndAllowAll, uint256[] memory receiving, uint256[] memory amountAndPrice, uint256[] memory startDateAndExpire);\r\n    function getApprovedTraderLength(bool direction, uint256 offerIndex) external view returns (uint256);\r\n    function getApprovedTrader(bool direction, uint256 offerIndex, uint256 start, uint256 end) external view returns (address[] memory traders, uint256[] memory allocation);\r\n\r\n    function getOffers(bool direction, uint256 start, uint256 length) external view returns (uint256[] memory index, address[] memory provider, bool[] memory lockedAndAllowAll, uint256[] memory receiving, uint256[] memory amountAndPrice, uint256[] memory startDateAndExpire);\r\n\r\n    function getLastBalances() external view returns (uint256, uint256);\r\n    function getBalances() external view returns (uint256, uint256, uint256);\r\n\r\n    function getAmountOut(address tokenIn, uint256 amountIn, address trader, bytes calldata data) external view returns (uint256 amountOut);\r\n    function getAmountIn(address tokenOut, uint256 amountOut, address trader, bytes calldata data) external view returns (uint256 amountIn);\r\n\r\n    function createOrder(address provider, bool direction, bool allowAll, uint256 restrictedPrice, uint256 startDate, uint256 expire) external returns (uint256 index);\r\n    function addLiquidity(bool direction, uint256 index) external;\r\n    function lockOffer(bool direction, uint256 index) external;\r\n    function removeLiquidity(address provider, bool direction, uint256 index, uint256 amountOut, uint256 receivingOut) external;\r\n    function removeAllLiquidity(address provider) external returns (uint256 amount0, uint256 amount1);\r\n    function removeAllLiquidity1D(address provider, bool direction) external returns (uint256 totalAmount, uint256 totalReceiving);\r\n\r\n    function setApprovedTrader(bool direction, uint256 offerIndex, address trader, uint256 allocation) external;\r\n    function setMultipleApprovedTraders(bool direction, uint256 offerIndex, address[] calldata trader, uint256[] calldata allocation) external;\r\n\r\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, address trader, bytes calldata data) external;\r\n\r\n    function sync() external;\r\n\r\n    function redeemProtocolFee() external;\r\n}\r\n\r\n\r\n// File contracts/commons/interfaces/IOSWAP_PausableFactory.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\ninterface IOSWAP_PausableFactory {\r\n    event Shutdowned();\r\n    event Restarted();\r\n    event PairShutdowned(address indexed pair);\r\n    event PairRestarted(address indexed pair);\r\n\r\n    function governance() external view returns (address);\r\n\r\n    function isLive() external returns (bool);\r\n    function setLive(bool _isLive) external;\r\n    function setLiveForPair(address pair, bool live) external;\r\n}\r\n\r\n\r\n// File contracts/restricted/interfaces/IOSWAP_RestrictedFactory.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\ninterface IOSWAP_RestrictedFactory is IOSWAP_PausableFactory { \r\n\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint newPairSize, uint newSize);\r\n    event Shutdowned();\r\n    event Restarted();\r\n    event PairShutdowned(address indexed pair);\r\n    event PairRestarted(address indexed pair);\r\n    event ParamSet(bytes32 name, bytes32 value);\r\n    event ParamSet2(bytes32 name, bytes32 value1, bytes32 value2);\r\n    event OracleAdded(address indexed token0, address indexed token1, address oracle);\r\n\r\n    function whitelistFactory() external view returns (address);\r\n    function pairCreator() external returns (address);\r\n    function configStore() external returns (address);\r\n\r\n    function tradeFee() external returns (uint256);\r\n    function protocolFee() external returns (uint256);\r\n    function protocolFeeTo() external returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB, uint256 i) external returns (address pair);\r\n    function pairIdx(address pair) external returns (uint256 i);\r\n    function allPairs(uint256 i) external returns (address pair);\r\n\r\n    function restrictedLiquidityProvider() external returns (address);\r\n    function oracles(address tokenA, address tokenB) external returns (address oracle);\r\n    function isOracle(address oracle) external returns (bool);\r\n\r\n    function init(address _restrictedLiquidityProvider) external;\r\n    function getCreateAddresses() external view returns (address _governance, address _whitelistFactory, address _restrictedLiquidityProvider, address _configStore);\r\n\r\n    function pairLength(address tokenA, address tokenB) external view returns (uint256);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setOracle(address tokenA, address tokenB, address oracle) external;\r\n    function addOldOracleToNewPair(address tokenA, address tokenB, address oracle) external;\r\n\r\n    function isPair(address pair) external view returns (bool);\r\n\r\n    function setTradeFee(uint256 _tradeFee) external;\r\n    function setProtocolFee(uint256 _protocolFee) external;\r\n    function setProtocolFeeTo(address _protocolFeeTo) external;\r\n\r\n    function checkAndGetOracleSwapParams(address tokenA, address tokenB) external view returns (address oracle_, uint256 tradeFee_, uint256 protocolFee_);\r\n    function checkAndGetOracle(address tokenA, address tokenB) external view returns (address oracle);\r\n}\r\n\r\n\r\n// File contracts/gov/interfaces/IOAXDEX_Governance.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\ninterface IOAXDEX_Governance {\r\n\r\n    struct NewStake {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n    struct VotingConfig {\r\n        uint256 minExeDelay;\r\n        uint256 minVoteDuration;\r\n        uint256 maxVoteDuration;\r\n        uint256 minOaxTokenToCreateVote;\r\n        uint256 minQuorum;\r\n    }\r\n\r\n    event ParamSet(bytes32 indexed name, bytes32 value);\r\n    event ParamSet2(bytes32 name, bytes32 value1, bytes32 value2);\r\n    event AddVotingConfig(bytes32 name, \r\n        uint256 minExeDelay,\r\n        uint256 minVoteDuration,\r\n        uint256 maxVoteDuration,\r\n        uint256 minOaxTokenToCreateVote,\r\n        uint256 minQuorum);\r\n    event SetVotingConfig(bytes32 indexed configName, bytes32 indexed paramName, uint256 minExeDelay);\r\n\r\n    event Stake(address indexed who, uint256 value);\r\n    event Unstake(address indexed who, uint256 value);\r\n\r\n    event NewVote(address indexed vote);\r\n    event NewPoll(address indexed poll);\r\n    event Vote(address indexed account, address indexed vote, uint256 option);\r\n    event Poll(address indexed account, address indexed poll, uint256 option);\r\n    event Executed(address indexed vote);\r\n    event Veto(address indexed vote);\r\n\r\n    function votingConfigs(bytes32) external view returns (uint256 minExeDelay,\r\n        uint256 minVoteDuration,\r\n        uint256 maxVoteDuration,\r\n        uint256 minOaxTokenToCreateVote,\r\n        uint256 minQuorum);\r\n    function votingConfigProfiles(uint256) external view returns (bytes32);\r\n\r\n    function oaxToken() external view returns (address);\r\n    function freezedStake(address) external view returns (uint256 amount, uint256 timestamp);\r\n    function stakeOf(address) external view returns (uint256);\r\n    function totalStake() external view returns (uint256);\r\n\r\n    function votingRegister() external view returns (address);\r\n    function votingExecutor(uint256) external view returns (address);\r\n    function votingExecutorInv(address) external view returns (uint256);\r\n    function isVotingExecutor(address) external view returns (bool);\r\n    function admin() external view returns (address);\r\n    function minStakePeriod() external view returns (uint256);\r\n\r\n    function voteCount() external view returns (uint256);\r\n    function votingIdx(address) external view returns (uint256);\r\n    function votings(uint256) external view returns (address);\r\n\r\n\r\n\tfunction votingConfigProfilesLength() external view returns(uint256);\r\n\tfunction getVotingConfigProfiles(uint256 start, uint256 length) external view returns(bytes32[] memory profiles);\r\n    function getVotingParams(bytes32) external view returns (uint256 _minExeDelay, uint256 _minVoteDuration, uint256 _maxVoteDuration, uint256 _minOaxTokenToCreateVote, uint256 _minQuorum);\r\n\r\n    function setVotingRegister(address _votingRegister) external;\r\n    function votingExecutorLength() external view returns (uint256);\r\n    function initVotingExecutor(address[] calldata _setVotingExecutor) external;\r\n    function setVotingExecutor(address _setVotingExecutor, bool _bool) external;\r\n    function initAdmin(address _admin) external;\r\n    function setAdmin(address _admin) external;\r\n    function addVotingConfig(bytes32 name, uint256 minExeDelay, uint256 minVoteDuration, uint256 maxVoteDuration, uint256 minOaxTokenToCreateVote, uint256 minQuorum) external;\r\n    function setVotingConfig(bytes32 configName, bytes32 paramName, uint256 paramValue) external;\r\n    function setMinStakePeriod(uint _minStakePeriod) external;\r\n\r\n    function stake(uint256 value) external;\r\n    function unlockStake() external;\r\n    function unstake(uint256 value) external;\r\n    function allVotings() external view returns (address[] memory);\r\n    function getVotingCount() external view returns (uint256);\r\n    function getVotings(uint256 start, uint256 count) external view returns (address[] memory _votings);\r\n\r\n    function isVotingContract(address votingContract) external view returns (bool);\r\n\r\n    function getNewVoteId() external returns (uint256);\r\n    function newVote(address vote, bool isExecutiveVote) external;\r\n    function voted(bool poll, address account, uint256 option) external;\r\n    function executed() external;\r\n    function veto(address voting) external;\r\n    function closeVote(address vote) external;\r\n}\r\n\r\n\r\n// File contracts/libraries/TransferHelper.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IWETH.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\n\r\n// File contracts/restricted/interfaces/IOSWAP_ConfigStore.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\ninterface IOSWAP_ConfigStore {\r\n    event ParamSet(bytes32 indexed name, bytes32 value);\r\n\r\n    function governance() external view returns (address);\r\n\r\n    function customParam(bytes32 paramName) external view returns (bytes32 paramValue);\r\n    function customParamNames(uint256 i) external view returns (bytes32 paramName);\r\n    function customParamNamesLength() external view returns (uint256 length);\r\n    function customParamNamesIdx(bytes32 paramName) external view returns (uint256 i);\r\n\r\n    function setCustomParam(bytes32 paramName, bytes32 paramValue) external;\r\n    function setMultiCustomParam(bytes32[] calldata paramName, bytes32[] calldata paramValue) external;\r\n}\r\n\r\n\r\n// File contracts/restricted/OSWAP_RestrictedLiquidityProvider.sol\r\n\r\n\r\npragma solidity =0.6.11;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OSWAP_RestrictedLiquidityProvider is IOSWAP_RestrictedLiquidityProvider {\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 constant FEE_PER_ORDER = \"RestrictedPair.feePerOrder\";\r\n    bytes32 constant FEE_PER_TRADER = \"RestrictedPair.feePerTrader\";\r\n\r\n    address public immutable override factory;\r\n    address public immutable override WETH;\r\n    address public immutable override govToken;\r\n    address public immutable override configStore;\r\n\r\n    modifier ensure(uint256 deadline) {\r\n        require(deadline >= block.timestamp, 'EXPIRED');\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WETH) public {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n        govToken = IOAXDEX_Governance(IOSWAP_RestrictedFactory(_factory).governance()).oaxToken();\r\n        configStore = IOSWAP_RestrictedFactory(_factory).configStore();\r\n    }\r\n    \r\n    receive() external payable {\r\n        require(msg.sender == WETH, 'Transfer failed'); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // **** ADD LIQUIDITY ****\r\n    function _getPair(address tokenA, address tokenB, uint256 pairIndex) internal returns (address pair) {\r\n        uint256 pairLen = IOSWAP_RestrictedFactory(factory).pairLength(tokenA, tokenB);\r\n        if (pairIndex == 0 && pairLen == 0) {\r\n            pair = IOSWAP_RestrictedFactory(factory).createPair(tokenA, tokenB);\r\n        } else {\r\n            require(pairIndex <= pairLen, \"Invalid pair index\");\r\n            pair = pairFor(tokenA, tokenB, pairIndex);\r\n        }\r\n    }\r\n    function _checkOrder(\r\n        address pair,\r\n        bool direction, \r\n        uint256 offerIndex,\r\n        bool allowAll,\r\n        uint256 restrictedPrice,\r\n        uint256 startDate,\r\n        uint256 expire\r\n    ) internal view {\r\n        (,,bool _allowAll,,,uint256 _restrictedPrice,uint256 _startDate,uint256 _expire) = IOSWAP_RestrictedPair(pair).offers(direction, offerIndex);\r\n        require(allowAll==_allowAll && restrictedPrice==_restrictedPrice && startDate==_startDate && expire==_expire, \"Order params not match\");\r\n    }\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool addingTokenA,\r\n        uint256 pairIndex,\r\n        uint256 offerIndex,\r\n        uint256 amountIn,\r\n        bool allowAll,\r\n        uint256 restrictedPrice,\r\n        uint256 startDate,\r\n        uint256 expire,\r\n        uint256 deadline\r\n    ) public virtual override ensure(deadline) returns (address pair, uint256 _offerIndex) {\r\n        pair = _getPair(tokenA, tokenB, pairIndex);\r\n\r\n        bool direction = (tokenA < tokenB) ? !addingTokenA : addingTokenA;\r\n\r\n        if (offerIndex == 0) {\r\n            uint256 feeIn = uint256(IOSWAP_ConfigStore(configStore).customParam(FEE_PER_ORDER));\r\n            TransferHelper.safeTransferFrom(govToken, msg.sender, pair, feeIn);\r\n            offerIndex = IOSWAP_RestrictedPair(pair).createOrder(msg.sender, direction, allowAll, restrictedPrice, startDate, expire);\r\n        } else {\r\n            _checkOrder(pair, direction, offerIndex, allowAll, restrictedPrice, startDate, expire);\r\n        }\r\n\r\n        if (amountIn > 0) {\r\n            TransferHelper.safeTransferFrom(addingTokenA ? tokenA : tokenB, msg.sender, pair, amountIn);\r\n            IOSWAP_RestrictedPair(pair).addLiquidity(direction, offerIndex);\r\n        }\r\n\r\n        _offerIndex = offerIndex;\r\n    }\r\n    function addLiquidityETH(\r\n        address tokenA,\r\n        bool addingTokenA,\r\n        uint256 pairIndex,\r\n        uint256 offerIndex,\r\n        uint256 amountAIn,\r\n        bool allowAll,\r\n        uint256 restrictedPrice,\r\n        uint256 startDate,\r\n        uint256 expire,\r\n        uint256 deadline\r\n    ) public virtual override payable ensure(deadline) returns (/*bool direction, */address pair, uint256 _offerIndex) {\r\n        pair = _getPair(tokenA, WETH, pairIndex);\r\n\r\n        bool direction = (tokenA < WETH) ? !addingTokenA : addingTokenA;\r\n\r\n        if (offerIndex == 0) {\r\n            uint256 feeIn = uint256(IOSWAP_ConfigStore(configStore).customParam(FEE_PER_ORDER));\r\n            TransferHelper.safeTransferFrom(govToken, msg.sender, pair, feeIn);\r\n            offerIndex = IOSWAP_RestrictedPair(pair).createOrder(msg.sender, direction, allowAll, restrictedPrice, startDate, expire);\r\n        } else {\r\n            _checkOrder(pair, direction, offerIndex, allowAll, restrictedPrice, startDate, expire);\r\n        }\r\n\r\n        if (addingTokenA) {\r\n            if (amountAIn > 0)\r\n                TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountAIn);\r\n        } else {\r\n            uint256 ETHIn = msg.value;\r\n            IWETH(WETH).deposit{value: ETHIn}();\r\n            require(IWETH(WETH).transfer(pair, ETHIn), 'Transfer failed');\r\n        }\r\n        if (amountAIn > 0 || msg.value > 0)\r\n            IOSWAP_RestrictedPair(pair).addLiquidity(direction, offerIndex);\r\n\r\n        _offerIndex = offerIndex;\r\n    }\r\n\r\n    function _addLiquidity(address tokenA, address tokenB, bool addingTokenA, uint256[11] calldata param) internal virtual \r\n        returns (address pair, uint256 offerIndex) \r\n    {\r\n        (pair, offerIndex) = addLiquidity(\r\n            tokenA,\r\n            tokenB,\r\n            addingTokenA,\r\n            param[3],\r\n            param[4],\r\n            param[5],\r\n            param[6]==1,\r\n            param[7],\r\n            param[8],\r\n            param[9],\r\n            param[10]\r\n        );\r\n    }\r\n    function addLiquidityAndTrader(\r\n        uint256[11] calldata param, \r\n        address[] calldata trader, \r\n        uint256[] calldata allocation\r\n    ) external virtual override \r\n        returns (address pair, uint256 offerIndex) \r\n    {\r\n        require(param.length == 11, \"Invalid param length\");\r\n        address tokenA = address(bytes20(bytes32(param[0]<<96)));\r\n        address tokenB = address(bytes20(bytes32(param[1]<<96)));\r\n        bool b = param[2]==1; // addingTokenA\r\n        (pair, offerIndex) = _addLiquidity(tokenA, tokenB, b, param);\r\n        b = (tokenA < tokenB) ? !b : b; // direction\r\n        \r\n        uint256 feePerTrader = uint256(IOSWAP_ConfigStore(configStore).customParam(FEE_PER_TRADER));\r\n        TransferHelper.safeTransferFrom(govToken, msg.sender, pair, feePerTrader.mul(trader.length));\r\n        IOSWAP_RestrictedPair(pair).setMultipleApprovedTraders(b, offerIndex, trader, allocation);\r\n    }\r\n    function _addLiquidityETH(address tokenA, bool addingTokenA, uint256[10] calldata param) internal virtual\r\n        returns (address pair, uint256 offerIndex) \r\n    {\r\n        (pair, offerIndex) = addLiquidityETH(\r\n            tokenA,\r\n            addingTokenA,\r\n            param[2],\r\n            param[3],\r\n            param[4],\r\n            param[5]==1,\r\n            param[6],\r\n            param[7],\r\n            param[8],\r\n            param[9]\r\n        );\r\n    }\r\n    function addLiquidityETHAndTrader(\r\n        uint256[10] calldata param, \r\n        address[] calldata trader, \r\n        uint256[] calldata allocation\r\n    ) external virtual override payable \r\n        returns (address pair, uint256 offerIndex) \r\n    {\r\n        require(param.length == 10, \"Invalid param length\");\r\n        address tokenA = address(bytes20(bytes32(param[0]<<96)));\r\n        bool b = param[1]==1; // addingTokenA\r\n        (pair, offerIndex) = _addLiquidityETH(tokenA, b, param);\r\n        b = (tokenA < WETH) ? !b : b; // direction\r\n        uint256 feePerTrader = uint256(IOSWAP_ConfigStore(configStore).customParam(FEE_PER_TRADER));\r\n        TransferHelper.safeTransferFrom(govToken, msg.sender, pair, feePerTrader.mul(trader.length));\r\n        IOSWAP_RestrictedPair(pair).setMultipleApprovedTraders(b, offerIndex, trader, allocation);\r\n    }\r\n\r\n    // **** REMOVE LIQUIDITY ****\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        bool removingTokenA,\r\n        address to,\r\n        uint256 pairIndex,\r\n        uint256 offerIndex,\r\n        uint256 amountOut,\r\n        uint256 receivingOut,\r\n        uint256 deadline\r\n    ) public virtual override ensure(deadline) {\r\n        address pair = pairFor(tokenA, tokenB, pairIndex);\r\n        bool direction = (tokenA < tokenB) ? !removingTokenA : removingTokenA;\r\n        IOSWAP_RestrictedPair(pair).removeLiquidity(msg.sender, direction, offerIndex, amountOut, receivingOut);\r\n\r\n        (uint256 tokenAOut, uint256 tokenBOut) = removingTokenA ? (amountOut, receivingOut) : (receivingOut, amountOut);\r\n        if (tokenAOut > 0) {\r\n            TransferHelper.safeTransfer(tokenA, to, tokenAOut);\r\n        }\r\n        if (tokenBOut > 0) {\r\n            TransferHelper.safeTransfer(tokenB, to, tokenBOut);\r\n        }\r\n    }\r\n    function removeLiquidityETH(\r\n        address tokenA,\r\n        bool removingTokenA,\r\n        address to,\r\n        uint256 pairIndex,\r\n        uint256 offerIndex,\r\n        uint256 amountOut,\r\n        uint256 receivingOut,\r\n        uint256 deadline\r\n    ) public virtual override ensure(deadline) {\r\n        address pair = pairFor(tokenA, WETH, pairIndex);\r\n        bool direction = (tokenA < WETH) ? !removingTokenA : removingTokenA;\r\n        IOSWAP_RestrictedPair(pair).removeLiquidity(msg.sender, direction, offerIndex, amountOut, receivingOut);\r\n\r\n        (uint256 tokenOut, uint256 ethOut) = removingTokenA ? (amountOut, receivingOut) : (receivingOut, amountOut);\r\n\r\n        if (tokenOut > 0) {\r\n            TransferHelper.safeTransfer(tokenA, to, tokenOut);\r\n        }\r\n        if (ethOut > 0) {\r\n            IWETH(WETH).withdraw(ethOut);\r\n            TransferHelper.safeTransferETH(to, ethOut);\r\n        }\r\n    }\r\n    function removeAllLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        address to,\r\n        uint256 pairIndex,\r\n        uint256 deadline\r\n    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {\r\n        address pair = pairFor(tokenA, tokenB, pairIndex);\r\n        (uint256 amount0, uint256 amount1) = IOSWAP_RestrictedPair(pair).removeAllLiquidity(msg.sender);\r\n        // (uint256 amount0, uint256 amount1) = IOSWAP_RestrictedPair(pair).removeAllLiquidity1D(msg.sender, false);\r\n        // (uint256 amount2, uint256 amount3) = IOSWAP_RestrictedPair(pair).removeAllLiquidity1D(msg.sender, true);\r\n        // amount0 = amount0.add(amount3);\r\n        // amount1 = amount1.add(amount2);\r\n        (amountA, amountB) = (tokenA < tokenB) ? (amount0, amount1) : (amount1, amount0);\r\n        TransferHelper.safeTransfer(tokenA, to, amountA);\r\n        TransferHelper.safeTransfer(tokenB, to, amountB);\r\n    }\r\n    function removeAllLiquidityETH(\r\n        address tokenA,\r\n        address to, \r\n        uint256 pairIndex,\r\n        uint256 deadline\r\n    ) public virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {\r\n        address pair = pairFor(tokenA, WETH, pairIndex);\r\n        (uint256 amount0, uint256 amount1) = IOSWAP_RestrictedPair(pair).removeAllLiquidity(msg.sender);\r\n        // (uint256 amount0, uint256 amount1) = IOSWAP_RestrictedPair(pair).removeAllLiquidity1D(msg.sender, false);\r\n        // (uint256 amount2, uint256 amount3) = IOSWAP_RestrictedPair(pair).removeAllLiquidity1D(msg.sender, true);\r\n        // amount0 = amount0.add(amount3);\r\n        // amount1 = amount1.add(amount2);\r\n        (amountToken, amountETH) = (tokenA < WETH) ? (amount0, amount1) : (amount1, amount0);\r\n        TransferHelper.safeTransfer(tokenA, to, amountToken);\r\n        IWETH(WETH).withdraw(amountETH);\r\n        TransferHelper.safeTransferETH(to, amountETH);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address tokenA, address tokenB, uint256 index) internal view returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint256(keccak256(abi.encodePacked(\r\n                hex'ff',    \r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1, index)),\r\n                /*restricted*/hex'4b0218ad658fd16b26a314d9bb11304340b61c68be30b5b14dbdaed3d789c73f' // restricted init code hash\r\n            ))));\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"addingTokenA\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowAll\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"restrictedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expire\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offerIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[11]\",\"name\":\"param\",\"type\":\"uint256[11]\"},{\"internalType\":\"address[]\",\"name\":\"trader\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"allocation\",\"type\":\"uint256[]\"}],\"name\":\"addLiquidityAndTrader\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"addingTokenA\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAIn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowAll\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"restrictedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expire\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offerIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"param\",\"type\":\"uint256[10]\"},{\"internalType\":\"address[]\",\"name\":\"trader\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"allocation\",\"type\":\"uint256[]\"}],\"name\":\"addLiquidityETHAndTrader\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configStore\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"govToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeAllLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeAllLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"removingTokenA\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivingOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"removingTokenA\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receivingOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "OSWAP_RestrictedLiquidityProvider", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "00000000000000000000000091d137464b93cac7e2c2d4444a9d8609e4473b70000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a9c7ebce6dd8221b7646c18d7cf9c6b93cb81c5269236fc23afd79232c217b3d"}