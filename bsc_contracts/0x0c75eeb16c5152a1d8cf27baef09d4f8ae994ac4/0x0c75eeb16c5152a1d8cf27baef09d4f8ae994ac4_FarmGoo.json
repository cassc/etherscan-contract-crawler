{"SourceCode": "pragma solidity 0.5.8;\r\n\r\n/**\r\n *\r\n * https://moonshots.farm\r\n * \r\n * Want to own the next 1000x SHIB/DOGE/HEX token? Farm a new/trending moonshot every other day, automagically!\r\n *\r\n */\r\n\r\ncontract GooFarm {\r\n    address public farmToken = address(0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95);\r\n   \r\n    function stake(address player, uint256 amount) external;\r\n    function unstake(address player, uint256 amount) external;\r\n}\r\n\r\n\r\ncontract BonesGooFarm {\r\n    using SafeMath for uint256;\r\n\r\n    FarmGoo public farmGoo = FarmGoo(0x0C75EEb16c5152A1D8CF27BaeF09D4f8aE994aC4);\r\n    address public farmToken = address(0x08426874d46f90e5E527604fA5E3e30486770Eb3);\r\n    ERC20 token = ERC20(farmToken);\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => uint256) public unlockTime;\r\n\taddress blobby = msg.sender;\r\n\r\n    function stake(address player, uint256 amount) external {\r\n        require(msg.sender == address(farmGoo));\r\n\r\n        token.transferFrom(player, address(this), amount);\r\n        balances[player] += amount;\r\n\r\n        if (unlockTime[player] == 0) {\r\n            unlockTime[player] = now + 30 days;\r\n        }\r\n    }\r\n\r\n    function unstake(address player, uint256 amount) external {\r\n        require(msg.sender == address(farmGoo));\r\n        require(now > unlockTime[player]);\r\n\r\n\t\tbalances[player] = balances[player].sub(amount);\r\n\t\trequire(token.transfer(player, amount));\r\n    }\r\n\r\n    function newFarmGoo(address goo) external {\r\n        require(msg.sender == blobby);\r\n        farmGoo = FarmGoo(goo);\r\n        token.approve(address(farmGoo), 2 ** 255);\r\n    }\r\n\r\n}\r\n\r\ninterface SyrupPool {\r\n\tfunction enterStaking(uint256 _amount) external;\r\n\tfunction leaveStaking(uint256 _amount) external;\r\n\tfunction emergencyWithdraw(uint256 _pid) external;\r\n\tfunction pendingCake(uint256 _pid, address _user) external view returns (uint256); \r\n}\r\n\r\ninterface UniswapV2 {\r\n\tfunction swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n\tfunction addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\n\r\n\r\n\r\ncontract FarmGoo {\r\n    using SafeMath for uint256;\r\n\r\n    ERC20 constant banana = ERC20(0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95);\r\n\r\n    uint256 public totalGooProduction;\r\n    address public owner = msg.sender; // Minor management of game\r\n\r\n    uint256 constant public researchDivPercent = 8;\r\n    uint256 constant public gooDepositDivPercent = 2;\r\n\r\n    uint256 public totalBananaResearchPool; // Banana dividends to be distributed to players\r\n    uint256[] private totalGooProductionSnapshots; // The total goo production for each prior day past\r\n    uint256[] private totalGooDepositSnapshots;  // The total goo deposited for each prior day past\r\n    uint256[] private allocatedGooResearchSnapshots; // Div pot #1 (research banana allocated to each prior day past)\r\n    uint256[] private allocatedGooDepositSnapshots;  // Div pot #2 (deposit banana allocated to each prior day past)\r\n    uint256 public nextSnapshotTime;\r\n    uint256 public nextGooDepositSnapshotTime;\r\n    uint256 public startTime;\r\n\r\n    // Balances for each player\r\n    mapping(address => uint256) private gooBalance;\r\n    mapping(address => mapping(uint256 => uint256)) private gooProductionSnapshots; // Store player's goo production for given day (snapshot)\r\n    mapping(address => mapping(uint256 => uint256)) private gooDepositSnapshots;    // Store player's goo deposited for given day (snapshot)\r\n    mapping(address => mapping(uint256 => bool)) private gooProductionZeroedSnapshots; // This isn't great but we need know difference between 0 production and an unused/inactive day.\r\n\r\n    mapping(address => uint256) private lastGooSaveTime; // Seconds (last time player claimed their produced goo)\r\n    mapping(address => uint256) public lastGooProductionUpdate; // Days (last snapshot player updated their production)\r\n    mapping(address => uint256) private lastGooResearchFundClaim; // Days (snapshot number)\r\n    mapping(address => uint256) private lastGooDepositFundClaim; // Days (snapshot number)\r\n\r\n    // Stuff owned by each player\r\n    mapping(address => mapping(uint256 => uint256)) private unitsOwned;\r\n    mapping(address => mapping(uint256 => bool)) private upgradesOwned;\r\n\r\n    // Upgrades (Increase unit's production / attack etc.)\r\n    mapping(address => mapping(uint256 => uint256)) private unitGooProductionIncreases; // Adds to the goo per second\r\n    mapping(address => mapping(uint256 => uint256)) private unitGooProductionMultiplier; // Multiplies the goo per second\r\n    mapping(address => mapping(uint256 => uint256)) private unitCostReduction;\r\n\r\n    modifier SnapshotCheck {\r\n        if (now >= nextSnapshotTime && nextSnapshotTime != 0){\r\n            snapshotDailyGooResearchFunding();\r\n        }\r\n        if (now >= nextGooDepositSnapshotTime && nextGooDepositSnapshotTime != 0){\r\n            snapshotDailyGooDepositFunding();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function beginGame(uint256 firstDivsTime) external {\r\n        require(msg.sender == owner);\r\n        require(startTime == 0);\r\n        startTime = now;\r\n        nextSnapshotTime = firstDivsTime;\r\n        nextGooDepositSnapshotTime = firstDivsTime + 12 hours;\r\n        totalGooDepositSnapshots.push(0); // Add initial-zero snapshot\r\n    }\r\n\r\n    function balanceOf(address player) public view returns(uint256) {\r\n        return gooBalance[player] + balanceOfUnclaimedGoo(player);\r\n    }\r\n\r\n    function balanceOfUnclaimedGoo(address player) internal view returns (uint256) {\r\n        uint256 lastSave = lastGooSaveTime[player];\r\n        if (lastSave > 0 && lastSave < now) {\r\n            return (getGooProduction(player) * (now - lastSave)) / 100;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getGooProduction(address player) public view returns (uint256){\r\n        return gooProductionSnapshots[player][lastGooProductionUpdate[player]];\r\n    }\r\n\r\n    function updatePlayersGoo(address player) internal {\r\n        uint256 gooGain = balanceOfUnclaimedGoo(player);\r\n        lastGooSaveTime[player] = now;\r\n        gooBalance[player] += gooGain;\r\n    }\r\n\r\n    function updatePlayersGooFromPurchase(address player, uint256 purchaseCost) internal {\r\n        uint256 unclaimedGoo = balanceOfUnclaimedGoo(player);\r\n\r\n        if (purchaseCost > unclaimedGoo) {\r\n            uint256 gooDecrease = purchaseCost - unclaimedGoo;\r\n            require(gooBalance[player] >= gooDecrease);\r\n            gooBalance[player] -= gooDecrease;\r\n        } else {\r\n            uint256 gooGain = unclaimedGoo - purchaseCost;\r\n            gooBalance[player] += gooGain;\r\n        }\r\n\r\n        lastGooSaveTime[player] = now;\r\n    }\r\n\r\n    function increasePlayersGooProduction(address player, uint256 increase) internal {\r\n        gooProductionSnapshots[player][allocatedGooResearchSnapshots.length] = getGooProduction(player) + increase;\r\n        lastGooProductionUpdate[player] = allocatedGooResearchSnapshots.length;\r\n        totalGooProduction += increase;\r\n    }\r\n\r\n    function reducePlayersGooProduction(address player, uint256 decrease) internal {\r\n        uint256 previousProduction = getGooProduction(player);\r\n        uint256 newProduction = previousProduction.sub(decrease);\r\n\r\n        if (newProduction == 0) { // Special case which tangles with \"inactive day\" snapshots (claiming divs)\r\n            gooProductionZeroedSnapshots[player][allocatedGooResearchSnapshots.length] = true;\r\n            delete gooProductionSnapshots[player][allocatedGooResearchSnapshots.length]; // 0\r\n        } else {\r\n            gooProductionSnapshots[player][allocatedGooResearchSnapshots.length] = newProduction;\r\n        }\r\n\r\n        lastGooProductionUpdate[player] = allocatedGooResearchSnapshots.length;\r\n        totalGooProduction -= decrease;\r\n    }\r\n\r\n    function addBanana(uint256 amount) external {\r\n        banana.transferFrom(msg.sender, address(this), amount);\r\n        totalBananaResearchPool += amount;\r\n    }\r\n\r\n    function withdrawBanana() external SnapshotCheck {\r\n        claimResearchDividends();\r\n        claimGooDepositDividends();\r\n    }\r\n\r\n    function fundGooResearch(uint256 amount) external SnapshotCheck {\r\n        updatePlayersGooFromPurchase(msg.sender, amount);\r\n        totalGooDepositSnapshots[totalGooDepositSnapshots.length - 1] += amount;\r\n        gooDepositSnapshots[msg.sender][totalGooDepositSnapshots.length - 1] += amount;\r\n    }\r\n\r\n    function claimResearchDividends() public SnapshotCheck {\r\n        uint256 startSnapshot = lastGooResearchFundClaim[msg.sender];\r\n        uint256 endSnapShot = allocatedGooResearchSnapshots.length - 1;\r\n\r\n        uint256 researchShare;\r\n        uint256 previousProduction;\r\n        if (startSnapshot > 0) {\r\n            previousProduction = gooProductionSnapshots[msg.sender][startSnapshot - 1];\r\n        }\r\n\r\n        for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\r\n\r\n            // Slightly complex things by accounting for days/snapshots when user made no tx's\r\n            uint256 productionDuringSnapshot = gooProductionSnapshots[msg.sender][i];\r\n            bool soldAllProduction = gooProductionZeroedSnapshots[msg.sender][i];\r\n            if (productionDuringSnapshot == 0 && !soldAllProduction) {\r\n                productionDuringSnapshot = previousProduction;\r\n            } else {\r\n               previousProduction = productionDuringSnapshot;\r\n            }\r\n\r\n            uint256 totalProduction = totalGooProductionSnapshots[i];\r\n            if (totalProduction > 0) {\r\n                researchShare += (allocatedGooResearchSnapshots[i] * productionDuringSnapshot) / totalProduction;\r\n            }\r\n        }\r\n\r\n\r\n        if (gooProductionSnapshots[msg.sender][endSnapShot] == 0 && !gooProductionZeroedSnapshots[msg.sender][endSnapShot] && previousProduction > 0) {\r\n            gooProductionSnapshots[msg.sender][endSnapShot] = previousProduction; // Checkpoint for next claim\r\n        }\r\n\r\n        lastGooResearchFundClaim[msg.sender] = endSnapShot + 1;\r\n        banana.transfer(msg.sender, researchShare);\r\n    }\r\n\r\n\r\n    function claimGooDepositDividends() public SnapshotCheck {\r\n        uint256 startSnapshot = lastGooDepositFundClaim[msg.sender];\r\n        uint256 endSnapShot = allocatedGooDepositSnapshots.length - 1;\r\n\r\n        uint256 depositShare;\r\n        if (allocatedGooDepositSnapshots.length > 0) {\r\n            for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\r\n                uint256 totalDeposited = totalGooDepositSnapshots[i];\r\n                if (totalDeposited > 0) {\r\n                    depositShare += (allocatedGooDepositSnapshots[i] * gooDepositSnapshots[msg.sender][i]) / totalDeposited;\r\n                }\r\n            }\r\n        }\r\n\r\n        lastGooDepositFundClaim[msg.sender] = endSnapShot + 1;\r\n        banana.transfer(msg.sender, depositShare);\r\n    }\r\n\r\n\r\n    // Allocate pot #1 divs for the day (00:00 cron job)\r\n    function snapshotDailyGooResearchFunding() public {\r\n        require(now >= nextSnapshotTime);\r\n\r\n        uint256 todaysGooResearchFund = (totalBananaResearchPool * researchDivPercent) / 100; // 8% of pool daily\r\n        totalBananaResearchPool -= todaysGooResearchFund;\r\n\r\n        totalGooProductionSnapshots.push(totalGooProduction);\r\n        allocatedGooResearchSnapshots.push(todaysGooResearchFund);\r\n        nextSnapshotTime = now + 24 hours;\r\n    }\r\n\r\n    // Allocate pot #2 divs for the day (12:00 cron job)\r\n    function snapshotDailyGooDepositFunding() public {\r\n        require(now >= nextGooDepositSnapshotTime);\r\n\r\n        uint256 todaysGooDepositFund = (totalBananaResearchPool * gooDepositDivPercent) / 100; // 2% of pool daily\r\n        totalBananaResearchPool -= todaysGooDepositFund;\r\n\r\n        totalGooDepositSnapshots.push(0); // Reset for to store next day's deposits\r\n        allocatedGooDepositSnapshots.push(todaysGooDepositFund); // Store to payout divs for previous day deposits\r\n        nextGooDepositSnapshotTime = now + 24 hours;\r\n    }\r\n\r\n\r\n    function getUnitsProduction(address player, uint256 unitId, uint256 amount) internal view returns (uint256) {\r\n        return (amount * (unitInfo[unitId].baseGooProduction + unitGooProductionIncreases[player][unitId]) * (10 + unitGooProductionMultiplier[player][unitId]));\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    ////////////////////////// GOO 2 ///////////////////////////\r\n\r\n\r\n    mapping(uint256 => Unit) private unitInfo;\r\n    mapping(uint256 => Upgrade) private upgradeInfo;\r\n\r\n    uint256 public numUpgrades;\r\n    uint256 public numProdUnits;\r\n\r\n    address[] public players;\r\n\r\n    struct Unit {\r\n        uint256 unitId;\r\n        uint256 baseGooCost;\r\n        uint256 gooCostIncreaseHalf; // Halfed to make maths slightly less (cancels a 2 out)\r\n        uint256 baseGooProduction;\r\n        address farmAddress;\r\n    }\r\n\r\n    struct Upgrade {\r\n        uint256 upgradeId;\r\n        uint256 gooCost;\r\n        uint256 upgradeClass;\r\n        uint256 unitId;\r\n        uint256 upgradeValue;\r\n        uint256 prerequisiteUpgrade;\r\n    }\r\n\r\n    function addUpgrade(uint256 id, uint256 goo, uint256 class, uint256 unit, uint256 value, uint256 prereq) external {\r\n        require(msg.sender == owner);\r\n        if (upgradeInfo[id].upgradeId == 0) {\r\n            numUpgrades++;\r\n        }\r\n        upgradeInfo[id] = Upgrade(id, goo, class, unit, value, prereq);\r\n    }\r\n\r\n    function addUnit(uint256 id, uint256 goo, uint256 gooIncreaseHalf, uint256 production, address farmToken) external {\r\n        require(msg.sender == owner);\r\n        if (unitInfo[id].unitId == 0) {\r\n            numProdUnits++;\r\n        }\r\n        unitInfo[id] = Unit(id, goo, gooIncreaseHalf, production, farmToken);\r\n    }\r\n\r\n    function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) internal {\r\n        uint256 productionGain;\r\n        if (upgradeClass == 0) {\r\n            unitGooProductionIncreases[player][unitId] += upgradeValue;\r\n            productionGain = unitsOwned[player][unitId] * upgradeValue * (10 + unitGooProductionMultiplier[player][unitId]);\r\n            increasePlayersGooProduction(player, productionGain);\r\n        } else if (upgradeClass == 1) {\r\n            Unit memory unit = unitInfo[unitId];\r\n            unitGooProductionMultiplier[player][unitId] += upgradeValue;\r\n            productionGain = unitsOwned[player][unitId] * upgradeValue * (unit.baseGooProduction + unitGooProductionIncreases[player][unitId]);\r\n            increasePlayersGooProduction(player, productionGain);\r\n        } else if (upgradeClass == 9) {\r\n            unitCostReduction[player][unitId] += upgradeValue; // Unit cost reduction\r\n        }\r\n    }\r\n\r\n    function getGooCostForUnit(uint256 unitId, uint256 existing, uint256 amount, uint256 discount) internal view returns (uint256 totalCost) {\r\n        Unit storage unit = unitInfo[unitId];\r\n        if (amount == 1) { // 1\r\n            if (existing == 0) {\r\n                totalCost = unit.baseGooCost;\r\n            } else {\r\n                totalCost = unit.baseGooCost + (existing * unit.gooCostIncreaseHalf * 2);\r\n            }\r\n        } else if (amount > 1) {\r\n            uint256 existingCost;\r\n            if (existing > 0) { // Gated by unit limit\r\n                existingCost = (unit.baseGooCost * existing) + (existing * (existing - 1) * unit.gooCostIncreaseHalf);\r\n            }\r\n\r\n            existing = existing.add(amount);\r\n            totalCost = unit.baseGooCost.mul(existing).add(existing.mul(existing - 1).mul(unit.gooCostIncreaseHalf)) - existingCost;\r\n        }\r\n\r\n        if (discount > 0 && discount < 100) {\r\n            totalCost = (totalCost * (100 - discount)) / 100;\r\n        }\r\n    }\r\n\r\n    // To display on website\r\n    function getGameInfo() external view returns (uint256[9] memory data) {\r\n        uint256 snapshotsLength = totalGooDepositSnapshots.length - 1;\r\n\r\n        data[0] = now;\r\n        data[1] = totalBananaResearchPool;\r\n        data[2] = totalGooProduction;\r\n        data[3] = totalGooDepositSnapshots[snapshotsLength];\r\n        data[4] = gooDepositSnapshots[msg.sender][snapshotsLength];\r\n        data[5] = nextSnapshotTime;\r\n        data[6] = balanceOf(msg.sender);\r\n        data[7] = getGooProduction(msg.sender);\r\n        data[8] = nextGooDepositSnapshotTime;\r\n    }\r\n\r\n    function getUnitsOwned(uint256[] calldata ids) external view returns (uint256[] memory) {\r\n        uint256[] memory units = new uint256[](ids.length);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            units[i] = unitsOwned[msg.sender][ids[i]];\r\n        }\r\n\r\n        return units;\r\n    }\r\n\r\n    function getUpgradesOwned(uint256[] calldata ids) external view returns (bool[] memory) {\r\n        bool[] memory upgrades = new bool[](ids.length);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            upgrades[i] = upgradesOwned[msg.sender][ids[i]];\r\n        }\r\n\r\n        return upgrades;\r\n    }\r\n\r\n    function getUpgradeValues(uint256[] calldata ids) external view returns (uint256[4][] memory) {\r\n        uint256[4][] memory upgradeValues = new uint256[4][](ids.length);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 unitId = ids[i];\r\n            upgradeValues[i][0] = unitGooProductionIncreases[msg.sender][unitId];\r\n            upgradeValues[i][1] = unitGooProductionMultiplier[msg.sender][unitId];\r\n            upgradeValues[i][2] = unitCostReduction[msg.sender][unitId];\r\n        }\r\n\r\n        return upgradeValues;\r\n    }\r\n\r\n    function numPlayers() external view returns (uint256) {\r\n        return players.length;\r\n    }\r\n\r\n    function getPlayersInfo(uint256 start, uint256 amount) external view returns (address[] memory, uint256[2][] memory, uint256) {\r\n        uint256 toFetch = amount;\r\n        uint256 totalPlayers = players.length;\r\n        if (players.length < toFetch) {\r\n            toFetch = totalPlayers;\r\n        }\r\n\r\n        address[] memory users = new address[](toFetch);\r\n        uint256[2][] memory stats = new uint256[2][](toFetch);\r\n\r\n        uint256 index = start;\r\n        for (uint256 i = 0; i < toFetch; i++) {\r\n            if (index >= totalPlayers) {\r\n                index = index - totalPlayers;\r\n            }\r\n\r\n            address player = players[index];\r\n            users[i] = player;\r\n            stats[i][0] = balanceOf(player);\r\n            stats[i][1] = getGooProduction(player);\r\n            index++;\r\n        }\r\n\r\n        return (users, stats, index);\r\n    }\r\n\r\n    function viewUnclaimedDividends() external view returns (uint256, uint256) {\r\n        uint256 startSnapshot = lastGooResearchFundClaim[msg.sender];\r\n        uint256 latestSnapshot;\r\n\r\n        uint256 researchShare;\r\n        uint256 previousProduction;\r\n\r\n        if (startSnapshot > 0) {\r\n            previousProduction = gooProductionSnapshots[msg.sender][startSnapshot - 1];\r\n        }\r\n\r\n        if (allocatedGooResearchSnapshots.length > 0) {\r\n            latestSnapshot = allocatedGooResearchSnapshots.length - 1;\r\n            for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\r\n                // Slightly complex things by accounting for days/snapshots when user made no tx's\r\n                uint256 productionDuringSnapshot = gooProductionSnapshots[msg.sender][i];\r\n                bool soldAllProduction = gooProductionZeroedSnapshots[msg.sender][i];\r\n                if (productionDuringSnapshot == 0 && !soldAllProduction) {\r\n                    productionDuringSnapshot = previousProduction;\r\n                } else {\r\n                   previousProduction = productionDuringSnapshot;\r\n                }\r\n\r\n                uint256 totalProduction = totalGooProductionSnapshots[i];\r\n                if (totalProduction > 0) {\r\n                    researchShare += (allocatedGooResearchSnapshots[i] * productionDuringSnapshot) / totalProduction;\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 depositShare;\r\n        if (allocatedGooDepositSnapshots.length > 0) {\r\n            latestSnapshot = allocatedGooDepositSnapshots.length - 1;\r\n            for (uint256 j = lastGooDepositFundClaim[msg.sender]; j <= latestSnapshot; j++) {\r\n                uint256 totalDeposits = totalGooDepositSnapshots[j];\r\n                if (totalDeposits > 0) {\r\n                    depositShare += (allocatedGooDepositSnapshots[j] * gooDepositSnapshots[msg.sender][j]) / totalDeposits;\r\n                }\r\n            }\r\n        }\r\n\r\n        return (researchShare, depositShare);\r\n    }\r\n\r\n    function buyFarmUnit(uint256 unitId, uint256 amount) external SnapshotCheck {\r\n        Unit memory unit = unitInfo[unitId];\r\n        require(unit.farmAddress != address(0));\r\n\r\n        if (getGooProduction(msg.sender) == 0) {\r\n            players.push(msg.sender);\r\n        }\r\n        \r\n        GooFarm farm = GooFarm(unit.farmAddress);\r\n        ERC20 token = ERC20(farm.farmToken());\r\n        uint256 cakeCost = amount * (10 ** uint256(token.decimals() - 1)); // 1 banana = 10 units\r\n        farm.stake(msg.sender, cakeCost);\r\n\r\n        updatePlayersGoo(msg.sender);\r\n        increasePlayersGooProduction(msg.sender, (unit.baseGooProduction + unitGooProductionIncreases[msg.sender][unitId]) * (10 + unitGooProductionMultiplier[msg.sender][unitId]).mul(amount));\r\n        unitsOwned[msg.sender][unitId] = unitsOwned[msg.sender][unitId] + amount;\r\n    }\r\n\r\n    function sellFarmUnit(uint256 unitId, uint256 amount) external SnapshotCheck {\r\n        Unit memory unit = unitInfo[unitId];\r\n        require(unit.farmAddress != address(0));\r\n\r\n        GooFarm farm = GooFarm(unit.farmAddress);\r\n        ERC20 token = ERC20(farm.farmToken());\r\n        uint256 cakeCost = amount * (10 ** uint256(token.decimals() - 1)); // 1 banana = 10 units\r\n        farm.unstake(msg.sender, cakeCost);\r\n\r\n        updatePlayersGoo(msg.sender);\r\n        reducePlayersGooProduction(msg.sender, (unit.baseGooProduction + unitGooProductionIncreases[msg.sender][unitId]) * (10 + unitGooProductionMultiplier[msg.sender][unitId]).mul(amount));\r\n        unitsOwned[msg.sender][unitId] = unitsOwned[msg.sender][unitId].sub(amount);\r\n    }\r\n\r\n    function buyUnit(uint256 unitId, uint256 amount) external SnapshotCheck {\r\n        Unit memory unit = unitInfo[unitId];\r\n        address player = msg.sender;\r\n        require(unit.unitId > 0); // Valid unit\r\n        require(unit.farmAddress == address(0));\r\n\r\n        if (getGooProduction(player) == 0) {\r\n            players.push(player);\r\n        }\r\n\r\n        uint256 existing = unitsOwned[player][unitId];\r\n        uint256 newTotal = existing.add(amount);\r\n\r\n        updatePlayersGooFromPurchase(player, getGooCostForUnit(unitId, existing, amount, unitCostReduction[player][unitId]));\r\n\r\n        increasePlayersGooProduction(player, (unit.baseGooProduction + unitGooProductionIncreases[player][unitId]) * (10 + unitGooProductionMultiplier[player][unitId]).mul(amount));\r\n        unitsOwned[player][unitId] = newTotal;\r\n    }\r\n\r\n    function buyUpgrade(uint256 upgradeId) external SnapshotCheck {\r\n        Upgrade memory upgrade = upgradeInfo[upgradeId];\r\n        address player = msg.sender;\r\n        require(upgrade.upgradeId > 0); // Valid upgrade\r\n        require(!upgradesOwned[player][upgradeId]); // Haven't already purchased\r\n\r\n        if (upgrade.prerequisiteUpgrade > 0) {\r\n            require(upgradesOwned[player][upgrade.prerequisiteUpgrade]);\r\n        }\r\n\r\n        // Update players goo\r\n        updatePlayersGooFromPurchase(player, upgrade.gooCost);\r\n\r\n        upgradeUnitMultipliers(player, upgrade.upgradeClass, upgrade.unitId, upgrade.upgradeValue);\r\n        upgradesOwned[player][upgradeId] = true;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\ninterface ERC20 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction balanceOf(address who) external view returns (uint256);\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) external returns (bool);\r\n\tfunction approve(address spender, uint256 value) external returns (bool);\r\n\tfunction approveAndCall(address spender, uint tokens, bytes calldata data) external returns (bool success);\r\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\tfunction burn(uint256 amount) external;\r\n    function decimals() external view returns (uint8);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\r\n    uint256 c = add(a,m);\r\n    uint256 d = sub(c,1);\r\n    return mul(div(d,m),m);\r\n  }\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyFarmUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addBanana\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPlayersInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[2][]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"data\",\"type\":\"uint256[9]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getGooProduction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"getUnitsOwned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"firstDivsTime\",\"type\":\"uint256\"}],\"name\":\"beginGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numUpgrades\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastGooProductionUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gooDepositDivPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buyUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"goo\",\"type\":\"uint256\"},{\"name\":\"class\",\"type\":\"uint256\"},{\"name\":\"unit\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"prereq\",\"type\":\"uint256\"}],\"name\":\"addUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBananaResearchPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"viewUnclaimedDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unitId\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellFarmUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalGooProduction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"researchDivPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimResearchDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fundGooResearch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"upgradeId\",\"type\":\"uint256\"}],\"name\":\"buyUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextSnapshotTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"goo\",\"type\":\"uint256\"},{\"name\":\"gooIncreaseHalf\",\"type\":\"uint256\"},{\"name\":\"production\",\"type\":\"uint256\"},{\"name\":\"farmToken\",\"type\":\"address\"}],\"name\":\"addUnit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numProdUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"snapshotDailyGooResearchFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"getUpgradeValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"getUpgradesOwned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimGooDepositDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBanana\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"snapshotDailyGooDepositFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextGooDepositSnapshotTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FarmGoo", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://dcc4ffdeed048d89937b61b53890e33dbfe17debb6d17ba144774c14f70f7c27"}